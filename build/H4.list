
build/H4.elf:     file format elf32-littlearm


Disassembly of section .text:

080001a0 <Reset_Handler>:
 80001a0:	b672      	cpsid	i
 80001a2:	4834      	ldr	r0, [pc, #208]	@ (8000274 <endfiniloop+0x4>)
 80001a4:	f380 8809 	msr	PSP, r0
 80001a8:	f240 0000 	movw	r0, #0
 80001ac:	f2cc 0000 	movt	r0, #49152	@ 0xc000
 80001b0:	f64e 7134 	movw	r1, #61236	@ 0xef34
 80001b4:	f2ce 0100 	movt	r1, #57344	@ 0xe000
 80001b8:	6008      	str	r0, [r1, #0]
 80001ba:	f3bf 8f4f 	dsb	sy
 80001be:	f3bf 8f6f 	isb	sy
 80001c2:	f240 0000 	movw	r0, #0
 80001c6:	f2c0 00f0 	movt	r0, #240	@ 0xf0
 80001ca:	f64e 5188 	movw	r1, #60808	@ 0xed88
 80001ce:	f2ce 0100 	movt	r1, #57344	@ 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	f3bf 8f4f 	dsb	sy
 80001d8:	f3bf 8f6f 	isb	sy
 80001dc:	f04f 0000 	mov.w	r0, #0
 80001e0:	eee1 0a10 	vmsr	fpscr, r0
 80001e4:	f64e 713c 	movw	r1, #61244	@ 0xef3c
 80001e8:	f2ce 0100 	movt	r1, #57344	@ 0xe000
 80001ec:	6008      	str	r0, [r1, #0]
 80001ee:	2006      	movs	r0, #6
 80001f0:	f380 8814 	msr	CONTROL, r0
 80001f4:	f3bf 8f6f 	isb	sy
 80001f8:	f000 fbaa 	bl	8000950 <__core_init>
 80001fc:	f002 f91c 	bl	8002438 <__early_init>
 8000200:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
 8000204:	491c      	ldr	r1, [pc, #112]	@ (8000278 <endfiniloop+0x8>)
 8000206:	4a1d      	ldr	r2, [pc, #116]	@ (800027c <endfiniloop+0xc>)

08000208 <msloop>:
 8000208:	4291      	cmp	r1, r2
 800020a:	bf3c      	itt	cc
 800020c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000210:	e7fa      	bcc.n	8000208 <msloop>
 8000212:	491b      	ldr	r1, [pc, #108]	@ (8000280 <endfiniloop+0x10>)
 8000214:	4a17      	ldr	r2, [pc, #92]	@ (8000274 <endfiniloop+0x4>)

08000216 <psloop>:
 8000216:	4291      	cmp	r1, r2
 8000218:	bf3c      	itt	cc
 800021a:	f841 0b04 	strcc.w	r0, [r1], #4
 800021e:	e7fa      	bcc.n	8000216 <psloop>
 8000220:	4918      	ldr	r1, [pc, #96]	@ (8000284 <endfiniloop+0x14>)
 8000222:	4a19      	ldr	r2, [pc, #100]	@ (8000288 <endfiniloop+0x18>)
 8000224:	4b19      	ldr	r3, [pc, #100]	@ (800028c <endfiniloop+0x1c>)

08000226 <dloop>:
 8000226:	429a      	cmp	r2, r3
 8000228:	bf3e      	ittt	cc
 800022a:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800022e:	f842 0b04 	strcc.w	r0, [r2], #4
 8000232:	e7f8      	bcc.n	8000226 <dloop>
 8000234:	2000      	movs	r0, #0
 8000236:	4916      	ldr	r1, [pc, #88]	@ (8000290 <endfiniloop+0x20>)
 8000238:	4a16      	ldr	r2, [pc, #88]	@ (8000294 <endfiniloop+0x24>)

0800023a <bloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <bloop>
 8000244:	f000 fb8a 	bl	800095c <__init_ram_areas>
 8000248:	f000 fb84 	bl	8000954 <__late_init>
 800024c:	4c12      	ldr	r4, [pc, #72]	@ (8000298 <endfiniloop+0x28>)
 800024e:	4d13      	ldr	r5, [pc, #76]	@ (800029c <endfiniloop+0x2c>)

08000250 <initloop>:
 8000250:	42ac      	cmp	r4, r5
 8000252:	da03      	bge.n	800025c <endinitloop>
 8000254:	f854 1b04 	ldr.w	r1, [r4], #4
 8000258:	4788      	blx	r1
 800025a:	e7f9      	b.n	8000250 <initloop>

0800025c <endinitloop>:
 800025c:	f008 fa94 	bl	8008788 <main>
 8000260:	4c0f      	ldr	r4, [pc, #60]	@ (80002a0 <endfiniloop+0x30>)
 8000262:	4d10      	ldr	r5, [pc, #64]	@ (80002a4 <endfiniloop+0x34>)

08000264 <finiloop>:
 8000264:	42ac      	cmp	r4, r5
 8000266:	da03      	bge.n	8000270 <endfiniloop>
 8000268:	f854 1b04 	ldr.w	r1, [r4], #4
 800026c:	4788      	blx	r1
 800026e:	e7f9      	b.n	8000264 <finiloop>

08000270 <endfiniloop>:
 8000270:	f000 bb72 	b.w	8000958 <__default_exit>
 8000274:	20000300 	.word	0x20000300
 8000278:	20000000 	.word	0x20000000
 800027c:	20000100 	.word	0x20000100
 8000280:	20000100 	.word	0x20000100
 8000284:	08019e3c 	.word	0x08019e3c
 8000288:	20000300 	.word	0x20000300
 800028c:	200003f8 	.word	0x200003f8
 8000290:	200003f8 	.word	0x200003f8
 8000294:	200099fc 	.word	0x200099fc
 8000298:	080001a0 	.word	0x080001a0
 800029c:	080001a0 	.word	0x080001a0
 80002a0:	080001a0 	.word	0x080001a0
 80002a4:	080001a0 	.word	0x080001a0

080002a8 <_port_switch>:
 80002a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002ac:	ed2d 8a10 	vpush	{s16-s31}
 80002b0:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002b4:	68c3      	ldr	r3, [r0, #12]
 80002b6:	469d      	mov	sp, r3
 80002b8:	ecbd 8a10 	vpop	{s16-s31}
 80002bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002c0 <_port_thread_start>:
 80002c0:	2300      	movs	r3, #0
 80002c2:	f383 8811 	msr	BASEPRI, r3
 80002c6:	4628      	mov	r0, r5
 80002c8:	47a0      	blx	r4
 80002ca:	2000      	movs	r0, #0
 80002cc:	f000 fdda 	bl	8000e84 <chThdExit>

080002d0 <_port_switch_from_isr>:
 80002d0:	f000 fd66 	bl	8000da0 <chSchDoReschedule>

080002d4 <_port_exit_from_isr>:
 80002d4:	df00      	svc	0
 80002d6:	e7fe      	b.n	80002d6 <_port_exit_from_isr+0x2>

080002d8 <__aeabi_drsub>:
 80002d8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80002dc:	e002      	b.n	80002e4 <__adddf3>
 80002de:	bf00      	nop

080002e0 <__aeabi_dsub>:
 80002e0:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080002e4 <__adddf3>:
 80002e4:	b530      	push	{r4, r5, lr}
 80002e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002ee:	ea94 0f05 	teq	r4, r5
 80002f2:	bf08      	it	eq
 80002f4:	ea90 0f02 	teqeq	r0, r2
 80002f8:	bf1f      	itttt	ne
 80002fa:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002fe:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000302:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000306:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800030a:	f000 80e2 	beq.w	80004d2 <__adddf3+0x1ee>
 800030e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000312:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000316:	bfb8      	it	lt
 8000318:	426d      	neglt	r5, r5
 800031a:	dd0c      	ble.n	8000336 <__adddf3+0x52>
 800031c:	442c      	add	r4, r5
 800031e:	ea80 0202 	eor.w	r2, r0, r2
 8000322:	ea81 0303 	eor.w	r3, r1, r3
 8000326:	ea82 0000 	eor.w	r0, r2, r0
 800032a:	ea83 0101 	eor.w	r1, r3, r1
 800032e:	ea80 0202 	eor.w	r2, r0, r2
 8000332:	ea81 0303 	eor.w	r3, r1, r3
 8000336:	2d36      	cmp	r5, #54	@ 0x36
 8000338:	bf88      	it	hi
 800033a:	bd30      	pophi	{r4, r5, pc}
 800033c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000340:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000344:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000348:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800034c:	d002      	beq.n	8000354 <__adddf3+0x70>
 800034e:	4240      	negs	r0, r0
 8000350:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000354:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000358:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800035c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000360:	d002      	beq.n	8000368 <__adddf3+0x84>
 8000362:	4252      	negs	r2, r2
 8000364:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000368:	ea94 0f05 	teq	r4, r5
 800036c:	f000 80a7 	beq.w	80004be <__adddf3+0x1da>
 8000370:	f1a4 0401 	sub.w	r4, r4, #1
 8000374:	f1d5 0e20 	rsbs	lr, r5, #32
 8000378:	db0d      	blt.n	8000396 <__adddf3+0xb2>
 800037a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800037e:	fa22 f205 	lsr.w	r2, r2, r5
 8000382:	1880      	adds	r0, r0, r2
 8000384:	f141 0100 	adc.w	r1, r1, #0
 8000388:	fa03 f20e 	lsl.w	r2, r3, lr
 800038c:	1880      	adds	r0, r0, r2
 800038e:	fa43 f305 	asr.w	r3, r3, r5
 8000392:	4159      	adcs	r1, r3
 8000394:	e00e      	b.n	80003b4 <__adddf3+0xd0>
 8000396:	f1a5 0520 	sub.w	r5, r5, #32
 800039a:	f10e 0e20 	add.w	lr, lr, #32
 800039e:	2a01      	cmp	r2, #1
 80003a0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003a4:	bf28      	it	cs
 80003a6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003aa:	fa43 f305 	asr.w	r3, r3, r5
 80003ae:	18c0      	adds	r0, r0, r3
 80003b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003b4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80003b8:	d507      	bpl.n	80003ca <__adddf3+0xe6>
 80003ba:	f04f 0e00 	mov.w	lr, #0
 80003be:	f1dc 0c00 	rsbs	ip, ip, #0
 80003c2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003c6:	eb6e 0101 	sbc.w	r1, lr, r1
 80003ca:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 80003ce:	d31b      	bcc.n	8000408 <__adddf3+0x124>
 80003d0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 80003d4:	d30c      	bcc.n	80003f0 <__adddf3+0x10c>
 80003d6:	0849      	lsrs	r1, r1, #1
 80003d8:	ea5f 0030 	movs.w	r0, r0, rrx
 80003dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003e0:	f104 0401 	add.w	r4, r4, #1
 80003e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003e8:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80003ec:	f080 809a 	bcs.w	8000524 <__adddf3+0x240>
 80003f0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80003f4:	bf08      	it	eq
 80003f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003fa:	f150 0000 	adcs.w	r0, r0, #0
 80003fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000402:	ea41 0105 	orr.w	r1, r1, r5
 8000406:	bd30      	pop	{r4, r5, pc}
 8000408:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800040c:	4140      	adcs	r0, r0
 800040e:	eb41 0101 	adc.w	r1, r1, r1
 8000412:	3c01      	subs	r4, #1
 8000414:	bf28      	it	cs
 8000416:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 800041a:	d2e9      	bcs.n	80003f0 <__adddf3+0x10c>
 800041c:	f091 0f00 	teq	r1, #0
 8000420:	bf04      	itt	eq
 8000422:	4601      	moveq	r1, r0
 8000424:	2000      	moveq	r0, #0
 8000426:	fab1 f381 	clz	r3, r1
 800042a:	bf08      	it	eq
 800042c:	3320      	addeq	r3, #32
 800042e:	f1a3 030b 	sub.w	r3, r3, #11
 8000432:	f1b3 0220 	subs.w	r2, r3, #32
 8000436:	da0c      	bge.n	8000452 <__adddf3+0x16e>
 8000438:	320c      	adds	r2, #12
 800043a:	dd08      	ble.n	800044e <__adddf3+0x16a>
 800043c:	f102 0c14 	add.w	ip, r2, #20
 8000440:	f1c2 020c 	rsb	r2, r2, #12
 8000444:	fa01 f00c 	lsl.w	r0, r1, ip
 8000448:	fa21 f102 	lsr.w	r1, r1, r2
 800044c:	e00c      	b.n	8000468 <__adddf3+0x184>
 800044e:	f102 0214 	add.w	r2, r2, #20
 8000452:	bfd8      	it	le
 8000454:	f1c2 0c20 	rsble	ip, r2, #32
 8000458:	fa01 f102 	lsl.w	r1, r1, r2
 800045c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000460:	bfdc      	itt	le
 8000462:	ea41 010c 	orrle.w	r1, r1, ip
 8000466:	4090      	lslle	r0, r2
 8000468:	1ae4      	subs	r4, r4, r3
 800046a:	bfa2      	ittt	ge
 800046c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000470:	4329      	orrge	r1, r5
 8000472:	bd30      	popge	{r4, r5, pc}
 8000474:	ea6f 0404 	mvn.w	r4, r4
 8000478:	3c1f      	subs	r4, #31
 800047a:	da1c      	bge.n	80004b6 <__adddf3+0x1d2>
 800047c:	340c      	adds	r4, #12
 800047e:	dc0e      	bgt.n	800049e <__adddf3+0x1ba>
 8000480:	f104 0414 	add.w	r4, r4, #20
 8000484:	f1c4 0220 	rsb	r2, r4, #32
 8000488:	fa20 f004 	lsr.w	r0, r0, r4
 800048c:	fa01 f302 	lsl.w	r3, r1, r2
 8000490:	ea40 0003 	orr.w	r0, r0, r3
 8000494:	fa21 f304 	lsr.w	r3, r1, r4
 8000498:	ea45 0103 	orr.w	r1, r5, r3
 800049c:	bd30      	pop	{r4, r5, pc}
 800049e:	f1c4 040c 	rsb	r4, r4, #12
 80004a2:	f1c4 0220 	rsb	r2, r4, #32
 80004a6:	fa20 f002 	lsr.w	r0, r0, r2
 80004aa:	fa01 f304 	lsl.w	r3, r1, r4
 80004ae:	ea40 0003 	orr.w	r0, r0, r3
 80004b2:	4629      	mov	r1, r5
 80004b4:	bd30      	pop	{r4, r5, pc}
 80004b6:	fa21 f004 	lsr.w	r0, r1, r4
 80004ba:	4629      	mov	r1, r5
 80004bc:	bd30      	pop	{r4, r5, pc}
 80004be:	f094 0f00 	teq	r4, #0
 80004c2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 80004c6:	bf06      	itte	eq
 80004c8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 80004cc:	3401      	addeq	r4, #1
 80004ce:	3d01      	subne	r5, #1
 80004d0:	e74e      	b.n	8000370 <__adddf3+0x8c>
 80004d2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004d6:	bf18      	it	ne
 80004d8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004dc:	d029      	beq.n	8000532 <__adddf3+0x24e>
 80004de:	ea94 0f05 	teq	r4, r5
 80004e2:	bf08      	it	eq
 80004e4:	ea90 0f02 	teqeq	r0, r2
 80004e8:	d005      	beq.n	80004f6 <__adddf3+0x212>
 80004ea:	ea54 0c00 	orrs.w	ip, r4, r0
 80004ee:	bf04      	itt	eq
 80004f0:	4619      	moveq	r1, r3
 80004f2:	4610      	moveq	r0, r2
 80004f4:	bd30      	pop	{r4, r5, pc}
 80004f6:	ea91 0f03 	teq	r1, r3
 80004fa:	bf1e      	ittt	ne
 80004fc:	2100      	movne	r1, #0
 80004fe:	2000      	movne	r0, #0
 8000500:	bd30      	popne	{r4, r5, pc}
 8000502:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000506:	d105      	bne.n	8000514 <__adddf3+0x230>
 8000508:	0040      	lsls	r0, r0, #1
 800050a:	4149      	adcs	r1, r1
 800050c:	bf28      	it	cs
 800050e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8000512:	bd30      	pop	{r4, r5, pc}
 8000514:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8000518:	bf3c      	itt	cc
 800051a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 800051e:	bd30      	popcc	{r4, r5, pc}
 8000520:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000524:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8000528:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800052c:	f04f 0000 	mov.w	r0, #0
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000536:	bf1a      	itte	ne
 8000538:	4619      	movne	r1, r3
 800053a:	4610      	movne	r0, r2
 800053c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000540:	bf1c      	itt	ne
 8000542:	460b      	movne	r3, r1
 8000544:	4602      	movne	r2, r0
 8000546:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800054a:	bf06      	itte	eq
 800054c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000550:	ea91 0f03 	teqeq	r1, r3
 8000554:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000558:	bd30      	pop	{r4, r5, pc}
 800055a:	bf00      	nop

0800055c <__aeabi_ui2d>:
 800055c:	f090 0f00 	teq	r0, #0
 8000560:	bf04      	itt	eq
 8000562:	2100      	moveq	r1, #0
 8000564:	4770      	bxeq	lr
 8000566:	b530      	push	{r4, r5, lr}
 8000568:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800056c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000570:	f04f 0500 	mov.w	r5, #0
 8000574:	f04f 0100 	mov.w	r1, #0
 8000578:	e750      	b.n	800041c <__adddf3+0x138>
 800057a:	bf00      	nop

0800057c <__aeabi_i2d>:
 800057c:	f090 0f00 	teq	r0, #0
 8000580:	bf04      	itt	eq
 8000582:	2100      	moveq	r1, #0
 8000584:	4770      	bxeq	lr
 8000586:	b530      	push	{r4, r5, lr}
 8000588:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800058c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000590:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000594:	bf48      	it	mi
 8000596:	4240      	negmi	r0, r0
 8000598:	f04f 0100 	mov.w	r1, #0
 800059c:	e73e      	b.n	800041c <__adddf3+0x138>
 800059e:	bf00      	nop

080005a0 <__aeabi_f2d>:
 80005a0:	0042      	lsls	r2, r0, #1
 80005a2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005a6:	ea4f 0131 	mov.w	r1, r1, rrx
 80005aa:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005ae:	bf1f      	itttt	ne
 80005b0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80005b4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 80005b8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 80005bc:	4770      	bxne	lr
 80005be:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 80005c2:	bf08      	it	eq
 80005c4:	4770      	bxeq	lr
 80005c6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 80005ca:	bf04      	itt	eq
 80005cc:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 80005d0:	4770      	bxeq	lr
 80005d2:	b530      	push	{r4, r5, lr}
 80005d4:	f44f 7460 	mov.w	r4, #896	@ 0x380
 80005d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80005dc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80005e0:	e71c      	b.n	800041c <__adddf3+0x138>
 80005e2:	bf00      	nop

080005e4 <__aeabi_ul2d>:
 80005e4:	ea50 0201 	orrs.w	r2, r0, r1
 80005e8:	bf08      	it	eq
 80005ea:	4770      	bxeq	lr
 80005ec:	b530      	push	{r4, r5, lr}
 80005ee:	f04f 0500 	mov.w	r5, #0
 80005f2:	e00a      	b.n	800060a <__aeabi_l2d+0x16>

080005f4 <__aeabi_l2d>:
 80005f4:	ea50 0201 	orrs.w	r2, r0, r1
 80005f8:	bf08      	it	eq
 80005fa:	4770      	bxeq	lr
 80005fc:	b530      	push	{r4, r5, lr}
 80005fe:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8000602:	d502      	bpl.n	800060a <__aeabi_l2d+0x16>
 8000604:	4240      	negs	r0, r0
 8000606:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800060a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800060e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000612:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000616:	f43f aed8 	beq.w	80003ca <__adddf3+0xe6>
 800061a:	f04f 0203 	mov.w	r2, #3
 800061e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000622:	bf18      	it	ne
 8000624:	3203      	addne	r2, #3
 8000626:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800062a:	bf18      	it	ne
 800062c:	3203      	addne	r2, #3
 800062e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000632:	f1c2 0320 	rsb	r3, r2, #32
 8000636:	fa00 fc03 	lsl.w	ip, r0, r3
 800063a:	fa20 f002 	lsr.w	r0, r0, r2
 800063e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000642:	ea40 000e 	orr.w	r0, r0, lr
 8000646:	fa21 f102 	lsr.w	r1, r1, r2
 800064a:	4414      	add	r4, r2
 800064c:	e6bd      	b.n	80003ca <__adddf3+0xe6>
 800064e:	bf00      	nop

08000650 <__aeabi_d2f>:
 8000650:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000654:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000658:	bf24      	itt	cs
 800065a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 800065e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000662:	d90d      	bls.n	8000680 <__aeabi_d2f+0x30>
 8000664:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000668:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 800066c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000670:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000674:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000678:	bf08      	it	eq
 800067a:	f020 0001 	biceq.w	r0, r0, #1
 800067e:	4770      	bx	lr
 8000680:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000684:	d121      	bne.n	80006ca <__aeabi_d2f+0x7a>
 8000686:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 800068a:	bfbc      	itt	lt
 800068c:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000690:	4770      	bxlt	lr
 8000692:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000696:	ea4f 5252 	mov.w	r2, r2, lsr #21
 800069a:	f1c2 0218 	rsb	r2, r2, #24
 800069e:	f1c2 0c20 	rsb	ip, r2, #32
 80006a2:	fa10 f30c 	lsls.w	r3, r0, ip
 80006a6:	fa20 f002 	lsr.w	r0, r0, r2
 80006aa:	bf18      	it	ne
 80006ac:	f040 0001 	orrne.w	r0, r0, #1
 80006b0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80006b4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80006b8:	fa03 fc0c 	lsl.w	ip, r3, ip
 80006bc:	ea40 000c 	orr.w	r0, r0, ip
 80006c0:	fa23 f302 	lsr.w	r3, r3, r2
 80006c4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80006c8:	e7cc      	b.n	8000664 <__aeabi_d2f+0x14>
 80006ca:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80006ce:	d107      	bne.n	80006e0 <__aeabi_d2f+0x90>
 80006d0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80006d4:	bf1e      	ittt	ne
 80006d6:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 80006da:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 80006de:	4770      	bxne	lr
 80006e0:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 80006e4:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 80006e8:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80006ec:	4770      	bx	lr
 80006ee:	bf00      	nop

080006f0 <__aeabi_frsub>:
 80006f0:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
 80006f4:	e002      	b.n	80006fc <__addsf3>
 80006f6:	bf00      	nop

080006f8 <__aeabi_fsub>:
 80006f8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

080006fc <__addsf3>:
 80006fc:	0042      	lsls	r2, r0, #1
 80006fe:	bf1f      	itttt	ne
 8000700:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000704:	ea92 0f03 	teqne	r2, r3
 8000708:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 800070c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000710:	d06a      	beq.n	80007e8 <__addsf3+0xec>
 8000712:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000716:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 800071a:	bfc1      	itttt	gt
 800071c:	18d2      	addgt	r2, r2, r3
 800071e:	4041      	eorgt	r1, r0
 8000720:	4048      	eorgt	r0, r1
 8000722:	4041      	eorgt	r1, r0
 8000724:	bfb8      	it	lt
 8000726:	425b      	neglt	r3, r3
 8000728:	2b19      	cmp	r3, #25
 800072a:	bf88      	it	hi
 800072c:	4770      	bxhi	lr
 800072e:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 8000732:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000736:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 800073a:	bf18      	it	ne
 800073c:	4240      	negne	r0, r0
 800073e:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000742:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 8000746:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
 800074a:	bf18      	it	ne
 800074c:	4249      	negne	r1, r1
 800074e:	ea92 0f03 	teq	r2, r3
 8000752:	d03f      	beq.n	80007d4 <__addsf3+0xd8>
 8000754:	f1a2 0201 	sub.w	r2, r2, #1
 8000758:	fa41 fc03 	asr.w	ip, r1, r3
 800075c:	eb10 000c 	adds.w	r0, r0, ip
 8000760:	f1c3 0320 	rsb	r3, r3, #32
 8000764:	fa01 f103 	lsl.w	r1, r1, r3
 8000768:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 800076c:	d502      	bpl.n	8000774 <__addsf3+0x78>
 800076e:	4249      	negs	r1, r1
 8000770:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000774:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 8000778:	d313      	bcc.n	80007a2 <__addsf3+0xa6>
 800077a:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 800077e:	d306      	bcc.n	800078e <__addsf3+0x92>
 8000780:	0840      	lsrs	r0, r0, #1
 8000782:	ea4f 0131 	mov.w	r1, r1, rrx
 8000786:	f102 0201 	add.w	r2, r2, #1
 800078a:	2afe      	cmp	r2, #254	@ 0xfe
 800078c:	d251      	bcs.n	8000832 <__addsf3+0x136>
 800078e:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 8000792:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000796:	bf08      	it	eq
 8000798:	f020 0001 	biceq.w	r0, r0, #1
 800079c:	ea40 0003 	orr.w	r0, r0, r3
 80007a0:	4770      	bx	lr
 80007a2:	0049      	lsls	r1, r1, #1
 80007a4:	eb40 0000 	adc.w	r0, r0, r0
 80007a8:	3a01      	subs	r2, #1
 80007aa:	bf28      	it	cs
 80007ac:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
 80007b0:	d2ed      	bcs.n	800078e <__addsf3+0x92>
 80007b2:	fab0 fc80 	clz	ip, r0
 80007b6:	f1ac 0c08 	sub.w	ip, ip, #8
 80007ba:	ebb2 020c 	subs.w	r2, r2, ip
 80007be:	fa00 f00c 	lsl.w	r0, r0, ip
 80007c2:	bfaa      	itet	ge
 80007c4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80007c8:	4252      	neglt	r2, r2
 80007ca:	4318      	orrge	r0, r3
 80007cc:	bfbc      	itt	lt
 80007ce:	40d0      	lsrlt	r0, r2
 80007d0:	4318      	orrlt	r0, r3
 80007d2:	4770      	bx	lr
 80007d4:	f092 0f00 	teq	r2, #0
 80007d8:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
 80007dc:	bf06      	itte	eq
 80007de:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
 80007e2:	3201      	addeq	r2, #1
 80007e4:	3b01      	subne	r3, #1
 80007e6:	e7b5      	b.n	8000754 <__addsf3+0x58>
 80007e8:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80007ec:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80007f0:	bf18      	it	ne
 80007f2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80007f6:	d021      	beq.n	800083c <__addsf3+0x140>
 80007f8:	ea92 0f03 	teq	r2, r3
 80007fc:	d004      	beq.n	8000808 <__addsf3+0x10c>
 80007fe:	f092 0f00 	teq	r2, #0
 8000802:	bf08      	it	eq
 8000804:	4608      	moveq	r0, r1
 8000806:	4770      	bx	lr
 8000808:	ea90 0f01 	teq	r0, r1
 800080c:	bf1c      	itt	ne
 800080e:	2000      	movne	r0, #0
 8000810:	4770      	bxne	lr
 8000812:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
 8000816:	d104      	bne.n	8000822 <__addsf3+0x126>
 8000818:	0040      	lsls	r0, r0, #1
 800081a:	bf28      	it	cs
 800081c:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
 8000820:	4770      	bx	lr
 8000822:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
 8000826:	bf3c      	itt	cc
 8000828:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
 800082c:	4770      	bxcc	lr
 800082e:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 8000832:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
 8000836:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 800083a:	4770      	bx	lr
 800083c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000840:	bf16      	itet	ne
 8000842:	4608      	movne	r0, r1
 8000844:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000848:	4601      	movne	r1, r0
 800084a:	0242      	lsls	r2, r0, #9
 800084c:	bf06      	itte	eq
 800084e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000852:	ea90 0f01 	teqeq	r0, r1
 8000856:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
 800085a:	4770      	bx	lr

0800085c <__aeabi_ui2f>:
 800085c:	f04f 0300 	mov.w	r3, #0
 8000860:	e004      	b.n	800086c <__aeabi_i2f+0x8>
 8000862:	bf00      	nop

08000864 <__aeabi_i2f>:
 8000864:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
 8000868:	bf48      	it	mi
 800086a:	4240      	negmi	r0, r0
 800086c:	ea5f 0c00 	movs.w	ip, r0
 8000870:	bf08      	it	eq
 8000872:	4770      	bxeq	lr
 8000874:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000
 8000878:	4601      	mov	r1, r0
 800087a:	f04f 0000 	mov.w	r0, #0
 800087e:	e01c      	b.n	80008ba <__aeabi_l2f+0x2a>

08000880 <__aeabi_ul2f>:
 8000880:	ea50 0201 	orrs.w	r2, r0, r1
 8000884:	bf08      	it	eq
 8000886:	4770      	bxeq	lr
 8000888:	f04f 0300 	mov.w	r3, #0
 800088c:	e00a      	b.n	80008a4 <__aeabi_l2f+0x14>
 800088e:	bf00      	nop

08000890 <__aeabi_l2f>:
 8000890:	ea50 0201 	orrs.w	r2, r0, r1
 8000894:	bf08      	it	eq
 8000896:	4770      	bxeq	lr
 8000898:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
 800089c:	d502      	bpl.n	80008a4 <__aeabi_l2f+0x14>
 800089e:	4240      	negs	r0, r0
 80008a0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80008a4:	ea5f 0c01 	movs.w	ip, r1
 80008a8:	bf02      	ittt	eq
 80008aa:	4684      	moveq	ip, r0
 80008ac:	4601      	moveq	r1, r0
 80008ae:	2000      	moveq	r0, #0
 80008b0:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
 80008b4:	bf08      	it	eq
 80008b6:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
 80008ba:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
 80008be:	fabc f28c 	clz	r2, ip
 80008c2:	3a08      	subs	r2, #8
 80008c4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80008c8:	db10      	blt.n	80008ec <__aeabi_l2f+0x5c>
 80008ca:	fa01 fc02 	lsl.w	ip, r1, r2
 80008ce:	4463      	add	r3, ip
 80008d0:	fa00 fc02 	lsl.w	ip, r0, r2
 80008d4:	f1c2 0220 	rsb	r2, r2, #32
 80008d8:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80008dc:	fa20 f202 	lsr.w	r2, r0, r2
 80008e0:	eb43 0002 	adc.w	r0, r3, r2
 80008e4:	bf08      	it	eq
 80008e6:	f020 0001 	biceq.w	r0, r0, #1
 80008ea:	4770      	bx	lr
 80008ec:	f102 0220 	add.w	r2, r2, #32
 80008f0:	fa01 fc02 	lsl.w	ip, r1, r2
 80008f4:	f1c2 0220 	rsb	r2, r2, #32
 80008f8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80008fc:	fa21 f202 	lsr.w	r2, r1, r2
 8000900:	eb43 0002 	adc.w	r0, r3, r2
 8000904:	bf08      	it	eq
 8000906:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 800090a:	4770      	bx	lr

0800090c <__aeabi_uldivmod>:
 800090c:	b953      	cbnz	r3, 8000924 <__aeabi_uldivmod+0x18>
 800090e:	b94a      	cbnz	r2, 8000924 <__aeabi_uldivmod+0x18>
 8000910:	2900      	cmp	r1, #0
 8000912:	bf08      	it	eq
 8000914:	2800      	cmpeq	r0, #0
 8000916:	bf1c      	itt	ne
 8000918:	f04f 31ff 	movne.w	r1, #4294967295
 800091c:	f04f 30ff 	movne.w	r0, #4294967295
 8000920:	f000 b80c 	b.w	800093c <__aeabi_idiv0>
 8000924:	f1ad 0c08 	sub.w	ip, sp, #8
 8000928:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800092c:	f010 fde8 	bl	8011500 <__udivmoddi4>
 8000930:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000934:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000938:	b004      	add	sp, #16
 800093a:	4770      	bx	lr

0800093c <__aeabi_idiv0>:
 800093c:	4770      	bx	lr
 800093e:	bf00      	nop

08000940 <strlen>:
 8000940:	4603      	mov	r3, r0
 8000942:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000946:	2a00      	cmp	r2, #0
 8000948:	d1fb      	bne.n	8000942 <strlen+0x2>
 800094a:	1a18      	subs	r0, r3, r0
 800094c:	3801      	subs	r0, #1
 800094e:	4770      	bx	lr

08000950 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000950:	4770      	bx	lr
 8000952:	bf00      	nop

08000954 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000954:	4770      	bx	lr
 8000956:	bf00      	nop

08000958 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8000958:	e7fe      	b.n	8000958 <__default_exit>
 800095a:	bf00      	nop

0800095c <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800095c:	b570      	push	{r4, r5, r6, lr}
 800095e:	4d13      	ldr	r5, [pc, #76]	@ (80009ac <__init_ram_areas+0x50>)
 8000960:	f105 0480 	add.w	r4, r5, #128	@ 0x80
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000964:	e955 0103 	ldrd	r0, r1, [r5, #-12]
 8000968:	4288      	cmp	r0, r1
    uint32_t *tp = rap->init_text_area;
 800096a:	f855 2c10 	ldr.w	r2, [r5, #-16]
    while (p < rap->clear_area) {
 800096e:	d20d      	bcs.n	800098c <__init_ram_areas+0x30>
 8000970:	3a04      	subs	r2, #4
    uint32_t *p = rap->init_area;
 8000972:	4603      	mov	r3, r0
      *p = *tp;
 8000974:	f852 6f04 	ldr.w	r6, [r2, #4]!
 8000978:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 800097c:	428b      	cmp	r3, r1
 800097e:	d3f9      	bcc.n	8000974 <__init_ram_areas+0x18>
 8000980:	3901      	subs	r1, #1
 8000982:	1a09      	subs	r1, r1, r0
 8000984:	f021 0103 	bic.w	r1, r1, #3
 8000988:	3004      	adds	r0, #4
 800098a:	4408      	add	r0, r1
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800098c:	f855 2c04 	ldr.w	r2, [r5, #-4]
 8000990:	4282      	cmp	r2, r0
 8000992:	d907      	bls.n	80009a4 <__init_ram_areas+0x48>
      *p = 0;
 8000994:	3a01      	subs	r2, #1
 8000996:	1a12      	subs	r2, r2, r0
 8000998:	f022 0203 	bic.w	r2, r2, #3
 800099c:	3204      	adds	r2, #4
 800099e:	2100      	movs	r1, #0
 80009a0:	f010 ff44 	bl	801182c <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80009a4:	3510      	adds	r5, #16
 80009a6:	42a5      	cmp	r5, r4
 80009a8:	d1dc      	bne.n	8000964 <__init_ram_areas+0x8>
#endif
}
 80009aa:	bd70      	pop	{r4, r5, r6, pc}
 80009ac:	080118e8 	.word	0x080118e8

080009b0 <_unhandled_exception>:
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
 80009b0:	e7fe      	b.n	80009b0 <_unhandled_exception>
 80009b2:	bf00      	nop

080009b4 <_idle_thread>:
 */
static void _idle_thread(void *p) {

  (void)p;

  while (true) {
 80009b4:	e7fe      	b.n	80009b4 <_idle_thread>
 80009b6:	bf00      	nop

080009b8 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80009b8:	b538      	push	{r3, r4, r5, lr}
#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
#else
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 80009ba:	4d19      	ldr	r5, [pc, #100]	@ (8000a20 <chSysInit+0x68>)
  _scheduler_init();
 80009bc:	f000 f904 	bl	8000bc8 <_scheduler_init>
  _vt_init();
 80009c0:	f000 f880 	bl	8000ac4 <_vt_init>
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 80009c4:	4917      	ldr	r1, [pc, #92]	@ (8000a24 <chSysInit+0x6c>)
 80009c6:	2280      	movs	r2, #128	@ 0x80
 80009c8:	4628      	mov	r0, r5
 80009ca:	f000 f9eb 	bl	8000da4 <_thread_init>
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80009ce:	4b16      	ldr	r3, [pc, #88]	@ (8000a28 <chSysInit+0x70>)
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 80009d0:	4a16      	ldr	r2, [pc, #88]	@ (8000a2c <chSysInit+0x74>)
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 80009d2:	f845 0c18 	str.w	r0, [r5, #-24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80009d6:	2101      	movs	r1, #1
 80009d8:	2400      	movs	r4, #0
 80009da:	7501      	strb	r1, [r0, #20]
    currp->wabase = &__main_thread_stack_base__;
 80009dc:	6102      	str	r2, [r0, #16]
 80009de:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80009e0:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80009e2:	4a13      	ldr	r2, [pc, #76]	@ (8000a30 <chSysInit+0x78>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80009e4:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
 80009e8:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 80009ea:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80009ec:	60da      	str	r2, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80009ee:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80009f2:	4910      	ldr	r1, [pc, #64]	@ (8000a34 <chSysInit+0x7c>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80009f4:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 80009f8:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80009fc:	680a      	ldr	r2, [r1, #0]
 80009fe:	f042 0201 	orr.w	r2, r2, #1
 8000a02:	600a      	str	r2, [r1, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a04:	2010      	movs	r0, #16
 8000a06:	2220      	movs	r2, #32
 8000a08:	77d8      	strb	r0, [r3, #31]
 8000a0a:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a0e:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8000a12:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8000a14:	4808      	ldr	r0, [pc, #32]	@ (8000a38 <chSysInit+0x80>)
  }
#endif
}
 8000a16:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) chThdCreate(&idle_descriptor);
 8000a1a:	f000 b9e3 	b.w	8000de4 <chThdCreate>
 8000a1e:	bf00      	nop
 8000a20:	20000558 	.word	0x20000558
 8000a24:	08011958 	.word	0x08011958
 8000a28:	e000ed00 	.word	0xe000ed00
 8000a2c:	20000100 	.word	0x20000100
 8000a30:	05fa0300 	.word	0x05fa0300
 8000a34:	e0001000 	.word	0xe0001000
 8000a38:	08012828 	.word	0x08012828

08000a3c <chSysHalt>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000a3c:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000a3e:	4b01      	ldr	r3, [pc, #4]	@ (8000a44 <chSysHalt+0x8>)
 8000a40:	6258      	str	r0, [r3, #36]	@ 0x24

  /* Harmless infinite loop.*/
  while (true) {
 8000a42:	e7fe      	b.n	8000a42 <chSysHalt+0x6>
 8000a44:	20000530 	.word	0x20000530

08000a48 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000a48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000a4c:	4d1c      	ldr	r5, [pc, #112]	@ (8000ac0 <chSysTimerHandlerI+0x78>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000a4e:	f04f 4880 	mov.w	r8, #1073741824	@ 0x40000000
 8000a52:	696c      	ldr	r4, [r5, #20]
 8000a54:	f8d8 0024 	ldr.w	r0, [r8, #36]	@ 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000a58:	6a29      	ldr	r1, [r5, #32]
 8000a5a:	68a3      	ldr	r3, [r4, #8]
 8000a5c:	1a42      	subs	r2, r0, r1
 8000a5e:	4293      	cmp	r3, r2
 8000a60:	f105 0614 	add.w	r6, r5, #20
 8000a64:	d81e      	bhi.n	8000aa4 <chSysTimerHandlerI+0x5c>
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000a66:	2700      	movs	r7, #0
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a68:	f04f 0920 	mov.w	r9, #32
 8000a6c:	e00d      	b.n	8000a8a <chSysTimerHandlerI+0x42>
 8000a6e:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8000a72:	6920      	ldr	r0, [r4, #16]
 8000a74:	47d0      	blx	sl
 8000a76:	f389 8811 	msr	BASEPRI, r9
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8000a7a:	696c      	ldr	r4, [r5, #20]
 8000a7c:	f8d8 0024 	ldr.w	r0, [r8, #36]	@ 0x24
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000a80:	6a29      	ldr	r1, [r5, #32]
 8000a82:	68a3      	ldr	r3, [r4, #8]
 8000a84:	1a42      	subs	r2, r0, r1
 8000a86:	4293      	cmp	r3, r2
 8000a88:	d80c      	bhi.n	8000aa4 <chSysTimerHandlerI+0x5c>
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000a8a:	6822      	ldr	r2, [r4, #0]
    fn = vtp->func;
 8000a8c:	f8d4 a00c 	ldr.w	sl, [r4, #12]
    ch.vtlist.lasttime += vtp->delta;
 8000a90:	440b      	add	r3, r1
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000a92:	42b2      	cmp	r2, r6
    ch.vtlist.lasttime += vtp->delta;
 8000a94:	622b      	str	r3, [r5, #32]
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000a96:	6056      	str	r6, [r2, #4]
    ch.vtlist.next = vtp->next;
 8000a98:	616a      	str	r2, [r5, #20]
    vtp->func = NULL;
 8000a9a:	60e7      	str	r7, [r4, #12]
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000a9c:	d1e7      	bne.n	8000a6e <chSysTimerHandlerI+0x26>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000a9e:	f000 fa93 	bl	8000fc8 <stStopAlarm>
}
 8000aa2:	e7e4      	b.n	8000a6e <chSysTimerHandlerI+0x26>
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000aa4:	42b4      	cmp	r4, r6
 8000aa6:	d009      	beq.n	8000abc <chSysTimerHandlerI+0x74>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8000aa8:	440b      	add	r3, r1
 8000aaa:	1a1b      	subs	r3, r3, r0
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8000aac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000ab0:	2b02      	cmp	r3, #2
 8000ab2:	bf2c      	ite	cs
 8000ab4:	18c0      	addcs	r0, r0, r3
 8000ab6:	3002      	addcc	r0, #2
 8000ab8:	f000 ba8c 	b.w	8000fd4 <stSetAlarm>
 8000abc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000ac0:	20000530 	.word	0x20000530

08000ac4 <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
 8000ac4:	4a05      	ldr	r2, [pc, #20]	@ (8000adc <_vt_init+0x18>)

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000ac6:	4613      	mov	r3, r2
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8000ac8:	f04f 30ff 	mov.w	r0, #4294967295
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000acc:	f843 2914 	str.w	r2, [r3], #-20
  ch.vtlist.delta = (systime_t)-1;
 8000ad0:	2100      	movs	r1, #0
 8000ad2:	e9c3 2006 	strd	r2, r0, [r3, #24]
 8000ad6:	6219      	str	r1, [r3, #32]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000ad8:	4770      	bx	lr
 8000ada:	bf00      	nop
 8000adc:	20000544 	.word	0x20000544

08000ae0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000ae0:	b570      	push	{r4, r5, r6, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000ae2:	4e1c      	ldr	r6, [pc, #112]	@ (8000b54 <chVTDoSetI+0x74>)
 8000ae4:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000ae8:	2902      	cmp	r1, #2
 8000aea:	6a64      	ldr	r4, [r4, #36]	@ 0x24
  vtp->func = vtfunc;
 8000aec:	e9c0 2303 	strd	r2, r3, [r0, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000af0:	4632      	mov	r2, r6
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000af2:	bf38      	it	cc
 8000af4:	2102      	movcc	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000af6:	f852 3f14 	ldr.w	r3, [r2, #20]!
 8000afa:	4293      	cmp	r3, r2
                vtfunc_t vtfunc, void *par) {
 8000afc:	4605      	mov	r5, r0
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8000afe:	eb01 0004 	add.w	r0, r1, r4
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b02:	d01d      	beq.n	8000b40 <chVTDoSetI+0x60>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 8000b04:	6a34      	ldr	r4, [r6, #32]
    if (delta < ch.vtlist.next->delta) {
 8000b06:	689a      	ldr	r2, [r3, #8]
    delta = now + delay - ch.vtlist.lasttime;
 8000b08:	1b04      	subs	r4, r0, r4
    if (delta < ch.vtlist.next->delta) {
 8000b0a:	42a2      	cmp	r2, r4
 8000b0c:	d813      	bhi.n	8000b36 <chVTDoSetI+0x56>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8000b0e:	4294      	cmp	r4, r2
 8000b10:	d904      	bls.n	8000b1c <chVTDoSetI+0x3c>
    delta -= p->delta;
    p = p->next;
 8000b12:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 8000b14:	1aa4      	subs	r4, r4, r2
  while (p->delta < delta) {
 8000b16:	689a      	ldr	r2, [r3, #8]
 8000b18:	42a2      	cmp	r2, r4
 8000b1a:	d3fa      	bcc.n	8000b12 <chVTDoSetI+0x32>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000b1c:	685a      	ldr	r2, [r3, #4]
 8000b1e:	e9c5 3200 	strd	r3, r2, [r5]
  vtp->prev->next = vtp;
 8000b22:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 8000b24:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
 8000b26:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8000b28:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000b2a:	f04f 31ff 	mov.w	r1, #4294967295
  p->delta -= delta;
 8000b2e:	1b12      	subs	r2, r2, r4
 8000b30:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000b32:	61f1      	str	r1, [r6, #28]
}
 8000b34:	bd70      	pop	{r4, r5, r6, pc}
 8000b36:	f000 fa4d 	bl	8000fd4 <stSetAlarm>
  p = ch.vtlist.next;
 8000b3a:	6973      	ldr	r3, [r6, #20]
  while (p->delta < delta) {
 8000b3c:	689a      	ldr	r2, [r3, #8]
}
 8000b3e:	e7e6      	b.n	8000b0e <chVTDoSetI+0x2e>
      ch.vtlist.next = vtp;
 8000b40:	e9c6 5505 	strd	r5, r5, [r6, #20]
      ch.vtlist.lasttime = now;
 8000b44:	6234      	str	r4, [r6, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8000b46:	e9c5 3300 	strd	r3, r3, [r5]
      vtp->delta = delay;
 8000b4a:	60a9      	str	r1, [r5, #8]
}
 8000b4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  stStartAlarm(time);
 8000b50:	f000 ba32 	b.w	8000fb8 <stStartAlarm>
 8000b54:	20000530 	.word	0x20000530

08000b58 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000b58:	4a1a      	ldr	r2, [pc, #104]	@ (8000bc4 <chVTDoResetI+0x6c>)
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000b5a:	6803      	ldr	r3, [r0, #0]
  if (ch.vtlist.next != vtp) {
 8000b5c:	6951      	ldr	r1, [r2, #20]
 8000b5e:	4281      	cmp	r1, r0
void chVTDoResetI(virtual_timer_t *vtp) {
 8000b60:	b410      	push	{r4}
  if (ch.vtlist.next != vtp) {
 8000b62:	d00e      	beq.n	8000b82 <chVTDoResetI+0x2a>
    vtp->prev->next = vtp->next;
 8000b64:	6841      	ldr	r1, [r0, #4]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b66:	3214      	adds	r2, #20
    vtp->func = NULL;
 8000b68:	2400      	movs	r4, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b6a:	4293      	cmp	r3, r2
    vtp->prev->next = vtp->next;
 8000b6c:	600b      	str	r3, [r1, #0]
    vtp->next->prev = vtp->prev;
 8000b6e:	6059      	str	r1, [r3, #4]
    vtp->func = NULL;
 8000b70:	60c4      	str	r4, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b72:	d003      	beq.n	8000b7c <chVTDoResetI+0x24>
      vtp->next->delta += vtp->delta;
 8000b74:	689a      	ldr	r2, [r3, #8]
 8000b76:	6881      	ldr	r1, [r0, #8]
 8000b78:	440a      	add	r2, r1
 8000b7a:	609a      	str	r2, [r3, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000b7c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b80:	4770      	bx	lr
  ch.vtlist.next = vtp->next;
 8000b82:	4610      	mov	r0, r2
  vtp->func = NULL;
 8000b84:	2400      	movs	r4, #0
  ch.vtlist.next = vtp->next;
 8000b86:	f840 3f14 	str.w	r3, [r0, #20]!
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b8a:	4283      	cmp	r3, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000b8c:	6058      	str	r0, [r3, #4]
  vtp->func = NULL;
 8000b8e:	60cc      	str	r4, [r1, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b90:	d014      	beq.n	8000bbc <chVTDoResetI+0x64>
  ch.vtlist.next->delta += vtp->delta;
 8000b92:	6898      	ldr	r0, [r3, #8]
 8000b94:	6889      	ldr	r1, [r1, #8]
 8000b96:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
 8000b9a:	4401      	add	r1, r0
 8000b9c:	6099      	str	r1, [r3, #8]
 8000b9e:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000ba0:	6a13      	ldr	r3, [r2, #32]
 8000ba2:	1ac2      	subs	r2, r0, r3
  if (nowdelta >= ch.vtlist.next->delta) {
 8000ba4:	4291      	cmp	r1, r2
 8000ba6:	d9e9      	bls.n	8000b7c <chVTDoResetI+0x24>
  delta = ch.vtlist.next->delta - nowdelta;
 8000ba8:	1a1b      	subs	r3, r3, r0
 8000baa:	440b      	add	r3, r1
}
 8000bac:	f85d 4b04 	ldr.w	r4, [sp], #4
  stSetAlarm(time);
 8000bb0:	2b02      	cmp	r3, #2
 8000bb2:	bf2c      	ite	cs
 8000bb4:	18c0      	addcs	r0, r0, r3
 8000bb6:	3002      	addcc	r0, #2
 8000bb8:	f000 ba0c 	b.w	8000fd4 <stSetAlarm>
 8000bbc:	f85d 4b04 	ldr.w	r4, [sp], #4
  stStopAlarm();
 8000bc0:	f000 ba02 	b.w	8000fc8 <stStopAlarm>
 8000bc4:	20000530 	.word	0x20000530

08000bc8 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000bc8:	4b02      	ldr	r3, [pc, #8]	@ (8000bd4 <_scheduler_init+0xc>)

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000bca:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bcc:	e9c3 3300 	strd	r3, r3, [r3]
 8000bd0:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
  ch.rlist.older = (thread_t *)&ch.rlist;
#endif
}
 8000bd2:	4770      	bx	lr
 8000bd4:	20000530 	.word	0x20000530

08000bd8 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000bd8:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 8000bda:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000bdc:	4b05      	ldr	r3, [pc, #20]	@ (8000bf4 <chSchReadyI+0x1c>)
  tp->state = CH_STATE_READY;
 8000bde:	7502      	strb	r2, [r0, #20]
    cp = cp->queue.next;
 8000be0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000be2:	689a      	ldr	r2, [r3, #8]
 8000be4:	428a      	cmp	r2, r1
 8000be6:	d2fb      	bcs.n	8000be0 <chSchReadyI+0x8>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000be8:	685a      	ldr	r2, [r3, #4]
 8000bea:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8000bee:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000bf0:	6058      	str	r0, [r3, #4]

  return tp;
}
 8000bf2:	4770      	bx	lr
 8000bf4:	20000530 	.word	0x20000530

08000bf8 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000bf8:	b508      	push	{r3, lr}
 8000bfa:	2320      	movs	r3, #32
 8000bfc:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8000c00:	7d03      	ldrb	r3, [r0, #20]
 8000c02:	2b03      	cmp	r3, #3
 8000c04:	d010      	beq.n	8000c28 <wakeup+0x30>
 8000c06:	2b04      	cmp	r3, #4
 8000c08:	d009      	beq.n	8000c1e <wakeup+0x26>
 8000c0a:	b12b      	cbz	r3, 8000c18 <wakeup+0x20>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000c0c:	f04f 33ff 	mov.w	r3, #4294967295
 8000c10:	6183      	str	r3, [r0, #24]
  (void) chSchReadyI(tp);
 8000c12:	f7ff ffe1 	bl	8000bd8 <chSchReadyI>
 8000c16:	2300      	movs	r3, #0
 8000c18:	f383 8811 	msr	BASEPRI, r3
  chSysUnlockFromISR();
}
 8000c1c:	bd08      	pop	{r3, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000c1e:	e9d0 3200 	ldrd	r3, r2, [r0]
 8000c22:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c24:	605a      	str	r2, [r3, #4]

  return tp;
 8000c26:	e7f1      	b.n	8000c0c <wakeup+0x14>
    *tp->u.wttrp = NULL;
 8000c28:	6983      	ldr	r3, [r0, #24]
 8000c2a:	2200      	movs	r2, #0
 8000c2c:	601a      	str	r2, [r3, #0]
    break;
 8000c2e:	e7ed      	b.n	8000c0c <wakeup+0x14>

08000c30 <chSchReadyAheadI>:
  tp->state = CH_STATE_READY;
 8000c30:	2200      	movs	r2, #0
  } while (cp->prio > tp->prio);
 8000c32:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000c34:	4b05      	ldr	r3, [pc, #20]	@ (8000c4c <chSchReadyAheadI+0x1c>)
  tp->state = CH_STATE_READY;
 8000c36:	7502      	strb	r2, [r0, #20]
    cp = cp->queue.next;
 8000c38:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8000c3a:	689a      	ldr	r2, [r3, #8]
 8000c3c:	428a      	cmp	r2, r1
 8000c3e:	d8fb      	bhi.n	8000c38 <chSchReadyAheadI+0x8>
  tp->queue.prev             = cp->queue.prev;
 8000c40:	685a      	ldr	r2, [r3, #4]
 8000c42:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8000c46:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c48:	6058      	str	r0, [r3, #4]
}
 8000c4a:	4770      	bx	lr
 8000c4c:	20000530 	.word	0x20000530

08000c50 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8000c50:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8000c52:	4c10      	ldr	r4, [pc, #64]	@ (8000c94 <chSchGoSleepS+0x44>)
 8000c54:	6925      	ldr	r5, [r4, #16]
  thread_t *tp = tqp->next;
 8000c56:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8000c58:	7528      	strb	r0, [r5, #20]
  tqp->next             = tp->queue.next;
 8000c5a:	681a      	ldr	r2, [r3, #0]
 8000c5c:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8000c5e:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000c60:	6054      	str	r4, [r2, #4]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000c62:	6123      	str	r3, [r4, #16]
  currp->state = CH_STATE_CURRENT;
 8000c64:	7519      	strb	r1, [r3, #20]
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000c66:	f3ef 8209 	mrs	r2, PSP
  chSysSwitch(currp, otp);
 8000c6a:	6929      	ldr	r1, [r5, #16]
 8000c6c:	3a64      	subs	r2, #100	@ 0x64
 8000c6e:	4291      	cmp	r1, r2
 8000c70:	d805      	bhi.n	8000c7e <chSchGoSleepS+0x2e>
 8000c72:	4629      	mov	r1, r5
 8000c74:	4618      	mov	r0, r3
}
 8000c76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000c7a:	f7ff bb15 	b.w	80002a8 <_port_switch>
 8000c7e:	4806      	ldr	r0, [pc, #24]	@ (8000c98 <chSchGoSleepS+0x48>)
 8000c80:	f7ff fedc 	bl	8000a3c <chSysHalt>
 8000c84:	6923      	ldr	r3, [r4, #16]
 8000c86:	4629      	mov	r1, r5
 8000c88:	4618      	mov	r0, r3
}
 8000c8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000c8e:	f7ff bb0b 	b.w	80002a8 <_port_switch>
 8000c92:	bf00      	nop
 8000c94:	20000530 	.word	0x20000530
 8000c98:	08011968 	.word	0x08011968

08000c9c <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000c9c:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000c9e:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000ca0:	b087      	sub	sp, #28
  if (TIME_INFINITE != time) {
 8000ca2:	d012      	beq.n	8000cca <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000ca4:	4d0c      	ldr	r5, [pc, #48]	@ (8000cd8 <chSchGoSleepTimeoutS+0x3c>)
 8000ca6:	4a0d      	ldr	r2, [pc, #52]	@ (8000cdc <chSchGoSleepTimeoutS+0x40>)
 8000ca8:	692b      	ldr	r3, [r5, #16]
 8000caa:	4604      	mov	r4, r0
 8000cac:	a801      	add	r0, sp, #4
 8000cae:	f7ff ff17 	bl	8000ae0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000cb2:	4620      	mov	r0, r4
 8000cb4:	f7ff ffcc 	bl	8000c50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cb8:	9b04      	ldr	r3, [sp, #16]
 8000cba:	b113      	cbz	r3, 8000cc2 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8000cbc:	a801      	add	r0, sp, #4
 8000cbe:	f7ff ff4b 	bl	8000b58 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8000cc2:	692b      	ldr	r3, [r5, #16]
}
 8000cc4:	6998      	ldr	r0, [r3, #24]
 8000cc6:	b007      	add	sp, #28
 8000cc8:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
 8000cca:	4d03      	ldr	r5, [pc, #12]	@ (8000cd8 <chSchGoSleepTimeoutS+0x3c>)
 8000ccc:	f7ff ffc0 	bl	8000c50 <chSchGoSleepS>
  return currp->u.rdymsg;
 8000cd0:	692b      	ldr	r3, [r5, #16]
}
 8000cd2:	6998      	ldr	r0, [r3, #24]
 8000cd4:	b007      	add	sp, #28
 8000cd6:	bd30      	pop	{r4, r5, pc}
 8000cd8:	20000530 	.word	0x20000530
 8000cdc:	08000bf9 	.word	0x08000bf9

08000ce0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000ce0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8000ce2:	4e14      	ldr	r6, [pc, #80]	@ (8000d34 <chSchWakeupS+0x54>)
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000ce4:	6181      	str	r1, [r0, #24]
  thread_t *otp = currp;
 8000ce6:	6933      	ldr	r3, [r6, #16]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000ce8:	6881      	ldr	r1, [r0, #8]
 8000cea:	689a      	ldr	r2, [r3, #8]
 8000cec:	4291      	cmp	r1, r2
 8000cee:	d803      	bhi.n	8000cf8 <chSchWakeupS+0x18>
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8000cf0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chSchReadyI(ntp);
 8000cf4:	f7ff bf70 	b.w	8000bd8 <chSchReadyI>
 8000cf8:	4604      	mov	r4, r0
    otp = chSchReadyI(otp);
 8000cfa:	4618      	mov	r0, r3
 8000cfc:	f7ff ff6c 	bl	8000bd8 <chSchReadyI>
    ntp->state = CH_STATE_CURRENT;
 8000d00:	2301      	movs	r3, #1
    otp = chSchReadyI(otp);
 8000d02:	4605      	mov	r5, r0
    currp = ntp;
 8000d04:	6134      	str	r4, [r6, #16]
    ntp->state = CH_STATE_CURRENT;
 8000d06:	7523      	strb	r3, [r4, #20]
 8000d08:	f3ef 8309 	mrs	r3, PSP
    chSysSwitch(ntp, otp);
 8000d0c:	6902      	ldr	r2, [r0, #16]
 8000d0e:	3b64      	subs	r3, #100	@ 0x64
 8000d10:	429a      	cmp	r2, r3
 8000d12:	d805      	bhi.n	8000d20 <chSchWakeupS+0x40>
 8000d14:	4629      	mov	r1, r5
 8000d16:	4620      	mov	r0, r4
}
 8000d18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 8000d1c:	f7ff bac4 	b.w	80002a8 <_port_switch>
 8000d20:	4805      	ldr	r0, [pc, #20]	@ (8000d38 <chSchWakeupS+0x58>)
 8000d22:	f7ff fe8b 	bl	8000a3c <chSysHalt>
 8000d26:	4629      	mov	r1, r5
 8000d28:	4620      	mov	r0, r4
}
 8000d2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 8000d2e:	f7ff babb 	b.w	80002a8 <_port_switch>
 8000d32:	bf00      	nop
 8000d34:	20000530 	.word	0x20000530
 8000d38:	08011968 	.word	0x08011968

08000d3c <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000d3c:	4b04      	ldr	r3, [pc, #16]	@ (8000d50 <chSchIsPreemptionRequired+0x14>)
 8000d3e:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->prio;
 8000d40:	691b      	ldr	r3, [r3, #16]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8000d42:	6890      	ldr	r0, [r2, #8]
 8000d44:	689b      	ldr	r3, [r3, #8]
#endif
}
 8000d46:	4298      	cmp	r0, r3
 8000d48:	bf94      	ite	ls
 8000d4a:	2000      	movls	r0, #0
 8000d4c:	2001      	movhi	r0, #1
 8000d4e:	4770      	bx	lr
 8000d50:	20000530 	.word	0x20000530

08000d54 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000d54:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8000d56:	4c10      	ldr	r4, [pc, #64]	@ (8000d98 <chSchDoRescheduleAhead+0x44>)
  thread_t *tp = tqp->next;
 8000d58:	6823      	ldr	r3, [r4, #0]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8000d5a:	6920      	ldr	r0, [r4, #16]
  tqp->next             = tp->queue.next;
 8000d5c:	681a      	ldr	r2, [r3, #0]
 8000d5e:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8000d60:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000d62:	6054      	str	r4, [r2, #4]
 8000d64:	7519      	strb	r1, [r3, #20]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000d66:	6123      	str	r3, [r4, #16]
  otp = chSchReadyAheadI(otp);
 8000d68:	f7ff ff62 	bl	8000c30 <chSchReadyAheadI>
 8000d6c:	4605      	mov	r5, r0
 8000d6e:	f3ef 8309 	mrs	r3, PSP

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000d72:	6902      	ldr	r2, [r0, #16]
 8000d74:	3b64      	subs	r3, #100	@ 0x64
 8000d76:	429a      	cmp	r2, r3
 8000d78:	d805      	bhi.n	8000d86 <chSchDoRescheduleAhead+0x32>
 8000d7a:	6920      	ldr	r0, [r4, #16]
 8000d7c:	4629      	mov	r1, r5
}
 8000d7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000d82:	f7ff ba91 	b.w	80002a8 <_port_switch>
 8000d86:	4805      	ldr	r0, [pc, #20]	@ (8000d9c <chSchDoRescheduleAhead+0x48>)
 8000d88:	f7ff fe58 	bl	8000a3c <chSysHalt>
 8000d8c:	6920      	ldr	r0, [r4, #16]
 8000d8e:	4629      	mov	r1, r5
}
 8000d90:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000d94:	f7ff ba88 	b.w	80002a8 <_port_switch>
 8000d98:	20000530 	.word	0x20000530
 8000d9c:	08011968 	.word	0x08011968

08000da0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000da0:	f7ff bfd8 	b.w	8000d54 <chSchDoRescheduleAhead>

08000da4 <_thread_init>:
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000da4:	2102      	movs	r1, #2
  tp->prio      = prio;
 8000da6:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 8000da8:	8281      	strh	r1, [r0, #20]
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 8000daa:	4770      	bx	lr

08000dac <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000dac:	b430      	push	{r4, r5}
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000dae:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000db2:	6902      	ldr	r2, [r0, #16]
 8000db4:	f843 2c44 	str.w	r2, [r3, #-68]
 8000db8:	f1a3 0584 	sub.w	r5, r3, #132	@ 0x84
  tp->state     = CH_STATE_WTSTART;
 8000dbc:	2202      	movs	r2, #2
  tp->wabase = tdp->wbase;
 8000dbe:	e943 5105 	strd	r5, r1, [r3, #-20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000dc2:	4c07      	ldr	r4, [pc, #28]	@ (8000de0 <chThdCreateSuspendedI+0x34>)
 8000dc4:	6945      	ldr	r5, [r0, #20]
  tp->prio      = prio;
 8000dc6:	68c1      	ldr	r1, [r0, #12]
  tp->state     = CH_STATE_WTSTART;
 8000dc8:	f823 2c0c 	strh.w	r2, [r3, #-12]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000dcc:	f843 5c40 	str.w	r5, [r3, #-64]
 8000dd0:	f843 4c24 	str.w	r4, [r3, #-36]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8000dd4:	f1a3 0020 	sub.w	r0, r3, #32
 8000dd8:	bc30      	pop	{r4, r5}
  tp->prio      = prio;
 8000dda:	f843 1c18 	str.w	r1, [r3, #-24]
}
 8000dde:	4770      	bx	lr
 8000de0:	080002c1 	.word	0x080002c1

08000de4 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8000de4:	b510      	push	{r4, lr}
 8000de6:	4604      	mov	r4, r0
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 8000de8:	6840      	ldr	r0, [r0, #4]
                  (uint8_t *)tdp->wend,
 8000dea:	68a2      	ldr	r2, [r4, #8]
  while (startp < endp) {
 8000dec:	4290      	cmp	r0, r2
 8000dee:	d203      	bcs.n	8000df8 <chThdCreate+0x14>
    *startp++ = v;
 8000df0:	1a12      	subs	r2, r2, r0
 8000df2:	2155      	movs	r1, #85	@ 0x55
 8000df4:	f010 fd1a 	bl	801182c <memset>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000df8:	2320      	movs	r3, #32
 8000dfa:	f383 8811 	msr	BASEPRI, r3
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8000dfe:	4620      	mov	r0, r4
 8000e00:	f7ff ffd4 	bl	8000dac <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8000e04:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
 8000e06:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8000e08:	f7ff ff6a 	bl	8000ce0 <chSchWakeupS>
 8000e0c:	2300      	movs	r3, #0
 8000e0e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8000e12:	4620      	mov	r0, r4
 8000e14:	bd10      	pop	{r4, pc}
 8000e16:	bf00      	nop

08000e18 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e1a:	461f      	mov	r7, r3
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8000e1c:	1843      	adds	r3, r0, r1
  while (startp < endp) {
 8000e1e:	4298      	cmp	r0, r3
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000e20:	4605      	mov	r5, r0
 8000e22:	460c      	mov	r4, r1
 8000e24:	4616      	mov	r6, r2
  while (startp < endp) {
 8000e26:	d203      	bcs.n	8000e30 <chThdCreateStatic+0x18>
    *startp++ = v;
 8000e28:	460a      	mov	r2, r1
 8000e2a:	2155      	movs	r1, #85	@ 0x55
 8000e2c:	f010 fcfe 	bl	801182c <memset>
 8000e30:	2320      	movs	r3, #32
 8000e32:	f383 8811 	msr	BASEPRI, r3
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8000e36:	3c20      	subs	r4, #32
 8000e38:	442c      	add	r4, r5
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e3a:	f1a4 0364 	sub.w	r3, r4, #100	@ 0x64
 8000e3e:	9906      	ldr	r1, [sp, #24]
 8000e40:	4a0a      	ldr	r2, [pc, #40]	@ (8000e6c <chThdCreateStatic+0x54>)
 8000e42:	60e3      	str	r3, [r4, #12]
  tp->state     = CH_STATE_WTSTART;
 8000e44:	2302      	movs	r3, #2
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e46:	f844 1c20 	str.w	r1, [r4, #-32]
  tp->state     = CH_STATE_WTSTART;
 8000e4a:	82a3      	strh	r3, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e4c:	f844 7c24 	str.w	r7, [r4, #-36]
  tp->wabase = (stkalign_t *)wsp;
 8000e50:	6125      	str	r5, [r4, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e52:	f844 2c04 	str.w	r2, [r4, #-4]
  tp->prio      = prio;
 8000e56:	60a6      	str	r6, [r4, #8]

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000e58:	2100      	movs	r1, #0
 8000e5a:	4620      	mov	r0, r4
 8000e5c:	f7ff ff40 	bl	8000ce0 <chSchWakeupS>
 8000e60:	2300      	movs	r3, #0
 8000e62:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8000e66:	4620      	mov	r0, r4
 8000e68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e6a:	bf00      	nop
 8000e6c:	080002c1 	.word	0x080002c1

08000e70 <chThdExitS>:
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8000e70:	4b03      	ldr	r3, [pc, #12]	@ (8000e80 <chThdExitS+0x10>)

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8000e72:	691b      	ldr	r3, [r3, #16]
void chThdExitS(msg_t msg) {
 8000e74:	4602      	mov	r2, r0
  tp->u.exitcode = msg;
 8000e76:	619a      	str	r2, [r3, #24]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8000e78:	200f      	movs	r0, #15
 8000e7a:	f7ff bee9 	b.w	8000c50 <chSchGoSleepS>
 8000e7e:	bf00      	nop
 8000e80:	20000530 	.word	0x20000530

08000e84 <chThdExit>:
 8000e84:	2320      	movs	r3, #32
 8000e86:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 8000e8a:	f7ff bff1 	b.w	8000e70 <chThdExitS>
 8000e8e:	bf00      	nop

08000e90 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000e90:	b508      	push	{r3, lr}
 8000e92:	4601      	mov	r1, r0
 8000e94:	2320      	movs	r3, #32
 8000e96:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000e9a:	2008      	movs	r0, #8
 8000e9c:	f7ff fefe 	bl	8000c9c <chSchGoSleepTimeoutS>
 8000ea0:	2300      	movs	r3, #0
 8000ea2:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8000ea6:	bd08      	pop	{r3, pc}

08000ea8 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000ea8:	b169      	cbz	r1, 8000ec6 <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000eaa:	4a08      	ldr	r2, [pc, #32]	@ (8000ecc <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000eac:	b410      	push	{r4}
  queue_insert(currp, tqp);
 8000eae:	6912      	ldr	r2, [r2, #16]
  tp->queue.prev             = tqp->prev;
 8000eb0:	6844      	ldr	r4, [r0, #4]
 8000eb2:	4603      	mov	r3, r0
 8000eb4:	e9c2 3400 	strd	r3, r4, [r2]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000eb8:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 8000eba:	6022      	str	r2, [r4, #0]
}
 8000ebc:	f85d 4b04 	ldr.w	r4, [sp], #4
  tqp->prev                  = tp;
 8000ec0:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000ec2:	f7ff beeb 	b.w	8000c9c <chSchGoSleepTimeoutS>
}
 8000ec6:	f04f 30ff 	mov.w	r0, #4294967295
 8000eca:	4770      	bx	lr
 8000ecc:	20000530 	.word	0x20000530

08000ed0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000ed0:	4603      	mov	r3, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000ed2:	6800      	ldr	r0, [r0, #0]

  if (queue_notempty(tqp)) {
 8000ed4:	4283      	cmp	r3, r0
 8000ed6:	d005      	beq.n	8000ee4 <chThdDequeueNextI+0x14>
  tqp->next             = tp->queue.next;
 8000ed8:	6802      	ldr	r2, [r0, #0]
 8000eda:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000edc:	6053      	str	r3, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000ede:	6181      	str	r1, [r0, #24]
  (void) chSchReadyI(tp);
 8000ee0:	f7ff be7a 	b.w	8000bd8 <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000ee4:	4770      	bx	lr
 8000ee6:	bf00      	nop

08000ee8 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8000ee8:	b538      	push	{r3, r4, r5, lr}
 8000eea:	4604      	mov	r4, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000eec:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 8000eee:	4284      	cmp	r4, r0
 8000ef0:	d009      	beq.n	8000f06 <chThdDequeueAllI+0x1e>
 8000ef2:	460d      	mov	r5, r1
  tqp->next             = tp->queue.next;
 8000ef4:	6803      	ldr	r3, [r0, #0]
 8000ef6:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ef8:	605c      	str	r4, [r3, #4]
  tp->u.rdymsg = msg;
 8000efa:	6185      	str	r5, [r0, #24]
  (void) chSchReadyI(tp);
 8000efc:	f7ff fe6c 	bl	8000bd8 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000f00:	6820      	ldr	r0, [r4, #0]
 8000f02:	4284      	cmp	r4, r0
 8000f04:	d1f6      	bne.n	8000ef4 <chThdDequeueAllI+0xc>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000f06:	bd38      	pop	{r3, r4, r5, pc}

08000f08 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8000f08:	b480      	push	{r7}
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000f0a:	4a09      	ldr	r2, [pc, #36]	@ (8000f30 <SVC_Handler+0x28>)
 8000f0c:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 8000f0e:	f023 0301 	bic.w	r3, r3, #1
void SVC_Handler(void) {
 8000f12:	af00      	add	r7, sp, #0
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000f14:	6353      	str	r3, [r2, #52]	@ 0x34
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000f16:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000f1a:	3368      	adds	r3, #104	@ 0x68
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000f1c:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000f20:	2300      	movs	r3, #0
 8000f22:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8000f26:	46bd      	mov	sp, r7
 8000f28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f2c:	4770      	bx	lr
 8000f2e:	bf00      	nop
 8000f30:	e000ef00 	.word	0xe000ef00

08000f34 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000f34:	b598      	push	{r3, r4, r7, lr}
 8000f36:	2320      	movs	r3, #32
 8000f38:	af00      	add	r7, sp, #0
 8000f3a:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000f3e:	4b11      	ldr	r3, [pc, #68]	@ (8000f84 <_port_irq_epilogue+0x50>)
 8000f40:	685b      	ldr	r3, [r3, #4]
 8000f42:	f413 6300 	ands.w	r3, r3, #2048	@ 0x800
 8000f46:	d102      	bne.n	8000f4e <_port_irq_epilogue+0x1a>
 8000f48:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000f4c:	bd98      	pop	{r3, r4, r7, pc}
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000f4e:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000f52:	f3ef 8409 	mrs	r4, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000f56:	4b0c      	ldr	r3, [pc, #48]	@ (8000f88 <_port_irq_epilogue+0x54>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8000f58:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000f5c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8000f5e:	f844 3c08 	str.w	r3, [r4, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8000f62:	f844 2c4c 	str.w	r2, [r4, #-76]
    ctxp--;
 8000f66:	f1a4 0368 	sub.w	r3, r4, #104	@ 0x68
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000f6a:	f383 8809 	msr	PSP, r3
    if (chSchIsPreemptionRequired()) {
 8000f6e:	f7ff fee5 	bl	8000d3c <chSchIsPreemptionRequired>
 8000f72:	b118      	cbz	r0, 8000f7c <_port_irq_epilogue+0x48>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000f74:	4b05      	ldr	r3, [pc, #20]	@ (8000f8c <_port_irq_epilogue+0x58>)
 8000f76:	f844 3c50 	str.w	r3, [r4, #-80]
}
 8000f7a:	bd98      	pop	{r3, r4, r7, pc}
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000f7c:	4b04      	ldr	r3, [pc, #16]	@ (8000f90 <_port_irq_epilogue+0x5c>)
 8000f7e:	f844 3c50 	str.w	r3, [r4, #-80]
}
 8000f82:	bd98      	pop	{r3, r4, r7, pc}
 8000f84:	e000ed00 	.word	0xe000ed00
 8000f88:	e000ef00 	.word	0xe000ef00
 8000f8c:	080002d1 	.word	0x080002d1
 8000f90:	080002d4 	.word	0x080002d4

08000f94 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000f94:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8000f96:	f000 fec5 	bl	8001d24 <hal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000f9a:	f000 faed 	bl	8001578 <sdInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8000f9e:	f000 fc97 	bl	80018d0 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8000fa2:	f000 fb7d 	bl	80016a0 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000fa6:	f001 fa49 	bl	800243c <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8000faa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stInit();
 8000fae:	f000 b801 	b.w	8000fb4 <stInit>
 8000fb2:	bf00      	nop

08000fb4 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8000fb4:	f000 bf32 	b.w	8001e1c <st_lld_init>

08000fb8 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fb8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  STM32_ST_TIM->SR     = 0;
 8000fbc:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000fbe:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fc0:	6358      	str	r0, [r3, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 8000fc2:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000fc4:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 8000fc6:	4770      	bx	lr

08000fc8 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000fc8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000fcc:	2200      	movs	r2, #0
 8000fce:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000fd0:	4770      	bx	lr
 8000fd2:	bf00      	nop

08000fd4 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fd4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000fd8:	6358      	str	r0, [r3, #52]	@ 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8000fda:	4770      	bx	lr

08000fdc <bqPrepareBuffer>:
}

static void bqPrepareBuffer(io_buffers_queue_t *bqp, size_t size)
{
  /* Writing size field in the buffer.*/
  *((size_t *)(void *)bqp->bwrptr) = size;
 8000fdc:	68c3      	ldr	r3, [r0, #12]
{
 8000fde:	b410      	push	{r4}

  /* Posting the buffer in the queue.*/
  bqp->bcounter++;
  bqp->bwrptr += bqp->bsize;
  if (bqp->bwrptr >= bqp->btop) {
 8000fe0:	6944      	ldr	r4, [r0, #20]
  *((size_t *)(void *)bqp->bwrptr) = size;
 8000fe2:	6019      	str	r1, [r3, #0]
  bqp->bwrptr += bqp->bsize;
 8000fe4:	6981      	ldr	r1, [r0, #24]
  bqp->bcounter++;
 8000fe6:	6882      	ldr	r2, [r0, #8]
  bqp->bwrptr += bqp->bsize;
 8000fe8:	440b      	add	r3, r1
  if (bqp->bwrptr >= bqp->btop) {
 8000fea:	42a3      	cmp	r3, r4
  bqp->bwrptr += bqp->bsize;
 8000fec:	60c3      	str	r3, [r0, #12]
  bqp->bcounter++;
 8000fee:	f102 0201 	add.w	r2, r2, #1
    bqp->bwrptr = bqp->buffers;
 8000ff2:	bf28      	it	cs
 8000ff4:	6a03      	ldrcs	r3, [r0, #32]
  }
}
 8000ff6:	f85d 4b04 	ldr.w	r4, [sp], #4
  bqp->bcounter++;
 8000ffa:	6082      	str	r2, [r0, #8]
    bqp->bwrptr = bqp->buffers;
 8000ffc:	bf28      	it	cs
 8000ffe:	60c3      	strcs	r3, [r0, #12]
}
 8001000:	4770      	bx	lr
 8001002:	bf00      	nop

08001004 <bqObjectInit>:

  osalThreadQueueObjectInit(&bqp->waiting);
  bqp->bcounter  = 0;
  bqp->brdptr    = bp;
  bqp->bwrptr    = bp;
  bqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8001004:	3204      	adds	r2, #4
                   bqnotify_t nfy, void *link) {
 8001006:	b410      	push	{r4}
  bqp->bsize     = size + sizeof (size_t);
  bqp->bn        = n;
  bqp->buffers   = bp;
 8001008:	e9c0 3107 	strd	r3, r1, [r0, #28]
  bqp->bsize     = size + sizeof (size_t);
 800100c:	6182      	str	r2, [r0, #24]
  bqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800100e:	fb03 1202 	mla	r2, r3, r2, r1
  bqp->bcounter  = 0;
 8001012:	2300      	movs	r3, #0
  bqp->ptr       = NULL;
  bqp->top       = NULL;
  bqp->notify    = nfy;
 8001014:	9c01      	ldr	r4, [sp, #4]
  bqp->bcounter  = 0;
 8001016:	6083      	str	r3, [r0, #8]
  bqp->top       = NULL;
 8001018:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
                   bqnotify_t nfy, void *link) {
 800101c:	9b02      	ldr	r3, [sp, #8]
  bqp->notify    = nfy;
 800101e:	62c4      	str	r4, [r0, #44]	@ 0x2c
  tqp->next = (thread_t *)tqp;
 8001020:	e9c0 0000 	strd	r0, r0, [r0]
  bqp->bwrptr    = bp;
 8001024:	e9c0 1103 	strd	r1, r1, [r0, #12]
  bqp->link      = link;
}
 8001028:	f85d 4b04 	ldr.w	r4, [sp], #4
  bqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800102c:	6142      	str	r2, [r0, #20]
  bqp->link      = link;
 800102e:	6303      	str	r3, [r0, #48]	@ 0x30
}
 8001030:	4770      	bx	lr
 8001032:	bf00      	nop

08001034 <bqResetI>:
 * @iclass
 */
void bqResetI(io_buffers_queue_t *bqp) {
  osalDbgCheckClassI();

  bqp->bcounter  = 0;
 8001034:	6a01      	ldr	r1, [r0, #32]
 8001036:	2200      	movs	r2, #0
  bqp->brdptr    = bqp->buffers;
  bqp->bwrptr    = bqp->buffers;
 8001038:	e9c0 1103 	strd	r1, r1, [r0, #12]
  bqp->ptr       = NULL;
 800103c:	e9c0 2209 	strd	r2, r2, [r0, #36]	@ 0x24
  bqp->bcounter  = 0;
 8001040:	6082      	str	r2, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001042:	f06f 0101 	mvn.w	r1, #1
 8001046:	f7ff bf4f 	b.w	8000ee8 <chThdDequeueAllI>
 800104a:	bf00      	nop

0800104c <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 800104c:	b508      	push	{r3, lr}
  osalDbgCheckClassI();

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!bqIsFullI(ibqp), "buffers queue full");
  /* Prepare buffer for input */
  bqPrepareBuffer(ibqp, size);
 800104e:	f7ff ffc5 	bl	8000fdc <bqPrepareBuffer>
  /* Waking up one waiting thread, if any.*/
  bq_Restore(ibqp);
}
 8001052:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdDequeueNextI(tqp, msg);
 8001056:	2100      	movs	r1, #0
 8001058:	f7ff bf3a 	b.w	8000ed0 <chThdDequeueNextI>

0800105c <ibqGetFullBufferTimeoutS>:
  if (bqIsEmptyI(bqp))
 800105c:	6883      	ldr	r3, [r0, #8]
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @sclass
 */
msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp, systime_t timeout) {
 800105e:	b510      	push	{r4, lr}
 8001060:	4604      	mov	r4, r0
  if (bqIsEmptyI(bqp))
 8001062:	b13b      	cbz	r3, 8001074 <ibqGetFullBufferTimeoutS+0x18>
  msg_t msg = waitReadyTimeout(ibqp, timeout);
  if (msg == MSG_OK) {
    osalDbgAssert(!bqIsEmptyI(ibqp), "still empty");

    /* Setting up the "current" buffer and its boundary.*/
    ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001064:	6923      	ldr	r3, [r4, #16]
    ibqp->top = ibqp->ptr + *((size_t *)(void *)ibqp->brdptr);
 8001066:	681a      	ldr	r2, [r3, #0]
    ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001068:	3304      	adds	r3, #4
    ibqp->top = ibqp->ptr + *((size_t *)(void *)ibqp->brdptr);
 800106a:	441a      	add	r2, r3
 800106c:	e9c4 3209 	strd	r3, r2, [r4, #36]	@ 0x24
 8001070:	2000      	movs	r0, #0
  }
  return msg;
}
 8001072:	bd10      	pop	{r4, pc}
  return chThdEnqueueTimeoutS(tqp, time);
 8001074:	f7ff ff18 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 8001078:	2800      	cmp	r0, #0
 800107a:	d0f3      	beq.n	8001064 <ibqGetFullBufferTimeoutS+0x8>
}
 800107c:	bd10      	pop	{r4, pc}
 800107e:	bf00      	nop

08001080 <ibqReleaseEmptyBufferS>:
  if (bqp->brdptr >= bqp->btop) {
 8001080:	e9d0 3104 	ldrd	r3, r1, [r0, #16]
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @sclass
 */
void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8001084:	b410      	push	{r4}
  bqp->brdptr += bqp->bsize;
 8001086:	6984      	ldr	r4, [r0, #24]
  bqp->bcounter--;
 8001088:	6882      	ldr	r2, [r0, #8]
  bqp->brdptr += bqp->bsize;
 800108a:	4423      	add	r3, r4
  if (bqp->brdptr >= bqp->btop) {
 800108c:	428b      	cmp	r3, r1
  bqp->brdptr += bqp->bsize;
 800108e:	6103      	str	r3, [r0, #16]
    bqp->brdptr = bqp->buffers;
 8001090:	bf24      	itt	cs
 8001092:	6a03      	ldrcs	r3, [r0, #32]
 8001094:	6103      	strcs	r3, [r0, #16]
  bqp->bcounter--;
 8001096:	3a01      	subs	r2, #1
  if (bqp->notify != NULL) bqp->notify(bqp);
 8001098:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  bqp->bcounter--;
 800109a:	6082      	str	r2, [r0, #8]

  /* Freeing a buffer slot in the queue.*/
  bqReleaseEmptyBuffer(ibqp);

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 800109c:	2200      	movs	r2, #0
 800109e:	6242      	str	r2, [r0, #36]	@ 0x24
  if (bqp->notify != NULL) bqp->notify(bqp);
 80010a0:	b113      	cbz	r3, 80010a8 <ibqReleaseEmptyBufferS+0x28>
  /* Notifying the buffer release.*/
  bq_Notify(ibqp);
}
 80010a2:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (bqp->notify != NULL) bqp->notify(bqp);
 80010a6:	4718      	bx	r3
}
 80010a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80010ac:	4770      	bx	lr
 80010ae:	bf00      	nop

080010b0 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 80010b0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80010b2:	2320      	movs	r3, #32
 80010b4:	4605      	mov	r5, r0
 80010b6:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 80010ba:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 80010bc:	b174      	cbz	r4, 80010dc <ibqGetTimeout+0x2c>
      return msg;
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 80010be:	f814 6b01 	ldrb.w	r6, [r4], #1
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 80010c2:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
  ibqp->ptr++;
 80010c4:	626c      	str	r4, [r5, #36]	@ 0x24
  if (ibqp->ptr >= ibqp->top) {
 80010c6:	4294      	cmp	r4, r2
 80010c8:	d204      	bcs.n	80010d4 <ibqGetTimeout+0x24>
 80010ca:	2300      	movs	r3, #0
 80010cc:	f383 8811 	msr	BASEPRI, r3
    ibqReleaseEmptyBufferS(ibqp);
  }

  osalSysUnlock();
  return msg;
}
 80010d0:	4630      	mov	r0, r6
 80010d2:	bd70      	pop	{r4, r5, r6, pc}
    ibqReleaseEmptyBufferS(ibqp);
 80010d4:	4628      	mov	r0, r5
 80010d6:	f7ff ffd3 	bl	8001080 <ibqReleaseEmptyBufferS>
 80010da:	e7f6      	b.n	80010ca <ibqGetTimeout+0x1a>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80010dc:	f7ff ffbe 	bl	800105c <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 80010e0:	4606      	mov	r6, r0
 80010e2:	b908      	cbnz	r0, 80010e8 <ibqGetTimeout+0x38>
  msg = (msg_t)*ibqp->ptr;
 80010e4:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
 80010e6:	e7ea      	b.n	80010be <ibqGetTimeout+0xe>
 80010e8:	f384 8811 	msr	BASEPRI, r4
      return msg;
 80010ec:	e7f0      	b.n	80010d0 <ibqGetTimeout+0x20>
 80010ee:	bf00      	nop

080010f0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80010f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80010f4:	4698      	mov	r8, r3
 80010f6:	4605      	mov	r5, r0
 80010f8:	460f      	mov	r7, r1
 80010fa:	4616      	mov	r6, r2
 80010fc:	2320      	movs	r3, #32
 80010fe:	f383 8811 	msr	BASEPRI, r3
  size_t c = 0, size;
 8001102:	f04f 0900 	mov.w	r9, #0
}
 8001106:	e016      	b.n	8001136 <ibqReadTimeout+0x46>
    size = (size_t)(bqp->top - bqp->ptr);
 8001108:	6aac      	ldr	r4, [r5, #40]	@ 0x28
    if (size > (n - c)) {
 800110a:	eba6 0309 	sub.w	r3, r6, r9
    size = (size_t)(bqp->top - bqp->ptr);
 800110e:	1a64      	subs	r4, r4, r1
    if (size > (n - c)) {
 8001110:	429c      	cmp	r4, r3
 8001112:	bf28      	it	cs
 8001114:	461c      	movcs	r4, r3
    else     memcpy(bp, bqp->ptr, size);     // from buffer (read)
 8001116:	4622      	mov	r2, r4
 8001118:	4638      	mov	r0, r7
 800111a:	f010 fba3 	bl	8011864 <memcpy>
    if (bqp->ptr >= bqp->top) {
 800111e:	e9d5 0309 	ldrd	r0, r3, [r5, #36]	@ 0x24
    bqp->ptr += size;
 8001122:	4420      	add	r0, r4
    if (bqp->ptr >= bqp->top) {
 8001124:	4298      	cmp	r0, r3
    bqp->ptr += size;
 8001126:	6268      	str	r0, [r5, #36]	@ 0x24
    c        += size;
 8001128:	44a1      	add	r9, r4
      else     ibqReleaseEmptyBufferS(bqp);                           // Read complete  (empty)
 800112a:	4628      	mov	r0, r5
    if (bqp->ptr >= bqp->top) {
 800112c:	d301      	bcc.n	8001132 <ibqReadTimeout+0x42>
      else     ibqReleaseEmptyBufferS(bqp);                           // Read complete  (empty)
 800112e:	f7ff ffa7 	bl	8001080 <ibqReleaseEmptyBufferS>
  } while(c < n);
 8001132:	454e      	cmp	r6, r9
 8001134:	d909      	bls.n	800114a <ibqReadTimeout+0x5a>
    if (bqp->ptr == NULL) {
 8001136:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 8001138:	2900      	cmp	r1, #0
 800113a:	d1e5      	bne.n	8001108 <ibqReadTimeout+0x18>
                        ibqGetFullBufferTimeoutS(bqp, timeout);
 800113c:	4641      	mov	r1, r8
 800113e:	4628      	mov	r0, r5
 8001140:	f7ff ff8c 	bl	800105c <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8001144:	b908      	cbnz	r0, 800114a <ibqReadTimeout+0x5a>
    size = (size_t)(bqp->top - bqp->ptr);
 8001146:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 8001148:	e7de      	b.n	8001108 <ibqReadTimeout+0x18>
 800114a:	2300      	movs	r3, #0
 800114c:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(n > 0U);
  return bqCopyTimeout(ibqp, false, bp, n, timeout);
}
 8001150:	4648      	mov	r0, r9
 8001152:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001156:	bf00      	nop

08001158 <ibqGetEmptyBufferI>:
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  if (bqIsFullI(ibqp)) {
 8001158:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
 800115c:	4293      	cmp	r3, r2
 800115e:	d001      	beq.n	8001164 <ibqGetEmptyBufferI+0xc>
    return NULL;
  }

  return ibqp->bwrptr + sizeof (size_t);
 8001160:	1d18      	adds	r0, r3, #4
 8001162:	4770      	bx	lr
  if (bqIsFullI(ibqp)) {
 8001164:	6882      	ldr	r2, [r0, #8]
 8001166:	2a00      	cmp	r2, #0
 8001168:	d0fa      	beq.n	8001160 <ibqGetEmptyBufferI+0x8>
    return NULL;
 800116a:	2000      	movs	r0, #0
}
 800116c:	4770      	bx	lr
 800116e:	bf00      	nop

08001170 <obqGetFullBufferI>:
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp, size_t *sizep) {
  osalDbgCheckClassI();

  if (bqIsEmptyI(obqp)) {
 8001170:	6883      	ldr	r3, [r0, #8]
 8001172:	b123      	cbz	r3, 800117e <obqGetFullBufferI+0xe>
    return NULL;
  }
  /* Buffer size.*/
  *sizep = *((size_t *)(void *)obqp->brdptr);
 8001174:	6900      	ldr	r0, [r0, #16]
 8001176:	f850 3b04 	ldr.w	r3, [r0], #4
 800117a:	600b      	str	r3, [r1, #0]
  return obqp->brdptr + sizeof (size_t);
 800117c:	4770      	bx	lr
    return NULL;
 800117e:	4618      	mov	r0, r3
}
 8001180:	4770      	bx	lr
 8001182:	bf00      	nop

08001184 <obqReleaseEmptyBufferI>:
  if (bqp->brdptr >= bqp->btop) {
 8001184:	e9d0 3104 	ldrd	r3, r1, [r0, #16]
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8001188:	b410      	push	{r4}
  bqp->brdptr += bqp->bsize;
 800118a:	6984      	ldr	r4, [r0, #24]
  bqp->bcounter--;
 800118c:	6882      	ldr	r2, [r0, #8]
  bqp->brdptr += bqp->bsize;
 800118e:	4423      	add	r3, r4
  if (bqp->brdptr >= bqp->btop) {
 8001190:	428b      	cmp	r3, r1
  bqp->brdptr += bqp->bsize;
 8001192:	6103      	str	r3, [r0, #16]
  bqp->bcounter--;
 8001194:	f102 32ff 	add.w	r2, r2, #4294967295
    bqp->brdptr = bqp->buffers;
 8001198:	bf28      	it	cs
 800119a:	6a03      	ldrcs	r3, [r0, #32]
  osalDbgAssert(!bqIsEmptyI(obqp), "buffers queue empty");
  /* Freeing a buffer slot in the queue.*/
  bqReleaseEmptyBuffer(obqp);
  /* Waking up one waiting thread, if any.*/
  bq_Restore(obqp);
}
 800119c:	f85d 4b04 	ldr.w	r4, [sp], #4
  bqp->bcounter--;
 80011a0:	6082      	str	r2, [r0, #8]
    bqp->brdptr = bqp->buffers;
 80011a2:	bf28      	it	cs
 80011a4:	6103      	strcs	r3, [r0, #16]
  chThdDequeueNextI(tqp, msg);
 80011a6:	2100      	movs	r1, #0
 80011a8:	f7ff be92 	b.w	8000ed0 <chThdDequeueNextI>

080011ac <obqGetEmptyBufferTimeoutS>:
  if (bqIsFullI(bqp))
 80011ac:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
 80011b0:	4293      	cmp	r3, r2
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 80011b2:	b510      	push	{r4, lr}
 80011b4:	4604      	mov	r4, r0
  if (bqIsFullI(bqp))
 80011b6:	d006      	beq.n	80011c6 <obqGetEmptyBufferTimeoutS+0x1a>
  msg_t msg = waitFreeTimeout(obqp, timeout);
  if (msg == MSG_OK) {
    osalDbgAssert(!bqIsFullI(obqp), "still full");
    /* Setting up the "current" buffer and its boundary.*/
    obqp->ptr = obqp->bwrptr + sizeof (size_t);
    obqp->top = obqp->bwrptr + obqp->bsize;
 80011b8:	69a1      	ldr	r1, [r4, #24]
    obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80011ba:	1d1a      	adds	r2, r3, #4
    obqp->top = obqp->bwrptr + obqp->bsize;
 80011bc:	440b      	add	r3, r1
 80011be:	e9c4 2309 	strd	r2, r3, [r4, #36]	@ 0x24
 80011c2:	2000      	movs	r0, #0
  }
  return msg;
}
 80011c4:	bd10      	pop	{r4, pc}
  if (bqIsFullI(bqp))
 80011c6:	6882      	ldr	r2, [r0, #8]
 80011c8:	2a00      	cmp	r2, #0
 80011ca:	d0f5      	beq.n	80011b8 <obqGetEmptyBufferTimeoutS+0xc>
  return chThdEnqueueTimeoutS(tqp, time);
 80011cc:	f7ff fe6c 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 80011d0:	2800      	cmp	r0, #0
 80011d2:	d1f7      	bne.n	80011c4 <obqGetEmptyBufferTimeoutS+0x18>
    obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80011d4:	68e3      	ldr	r3, [r4, #12]
 80011d6:	e7ef      	b.n	80011b8 <obqGetEmptyBufferTimeoutS+0xc>

080011d8 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80011d8:	b510      	push	{r4, lr}

  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!bqIsFullI(obqp), "buffers queue full");
  /* Prepare buffer for output */
  bqPrepareBuffer(obqp, size);
 80011da:	f7ff feff 	bl	8000fdc <bqPrepareBuffer>
  if (bqp->notify != NULL) bqp->notify(bqp);
 80011de:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80011e0:	2200      	movs	r2, #0
 80011e2:	6242      	str	r2, [r0, #36]	@ 0x24
  if (bqp->notify != NULL) bqp->notify(bqp);
 80011e4:	b113      	cbz	r3, 80011ec <obqPostFullBufferS+0x14>
  /* Notifying the buffer release.*/
  bq_Notify(obqp);
}
 80011e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (bqp->notify != NULL) bqp->notify(bqp);
 80011ea:	4718      	bx	r3
}
 80011ec:	bd10      	pop	{r4, pc}
 80011ee:	bf00      	nop

080011f0 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 80011f0:	b570      	push	{r4, r5, r6, lr}
 80011f2:	2320      	movs	r3, #32
 80011f4:	4604      	mov	r4, r0
 80011f6:	460d      	mov	r5, r1
 80011f8:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 80011fc:	6a46      	ldr	r6, [r0, #36]	@ 0x24
 80011fe:	b186      	cbz	r6, 8001222 <obqPutTimeout+0x32>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8001200:	7035      	strb	r5, [r6, #0]
  obqp->ptr++;

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8001202:	e9d4 3209 	ldrd	r3, r2, [r4, #36]	@ 0x24
  obqp->ptr++;
 8001206:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8001208:	4293      	cmp	r3, r2
  obqp->ptr++;
 800120a:	6263      	str	r3, [r4, #36]	@ 0x24
  if (obqp->ptr >= obqp->top) {
 800120c:	d203      	bcs.n	8001216 <obqPutTimeout+0x26>
 800120e:	2000      	movs	r0, #0
 8001210:	f380 8811 	msr	BASEPRI, r0
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  }

  osalSysUnlock();
  return MSG_OK;
}
 8001214:	bd70      	pop	{r4, r5, r6, pc}
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8001216:	69a1      	ldr	r1, [r4, #24]
 8001218:	4620      	mov	r0, r4
 800121a:	3904      	subs	r1, #4
 800121c:	f7ff ffdc 	bl	80011d8 <obqPostFullBufferS>
 8001220:	e7f5      	b.n	800120e <obqPutTimeout+0x1e>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8001222:	4611      	mov	r1, r2
 8001224:	f7ff ffc2 	bl	80011ac <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8001228:	b908      	cbnz	r0, 800122e <obqPutTimeout+0x3e>
  *obqp->ptr = b;
 800122a:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 800122c:	e7e8      	b.n	8001200 <obqPutTimeout+0x10>
 800122e:	f386 8811 	msr	BASEPRI, r6
}
 8001232:	bd70      	pop	{r4, r5, r6, pc}

08001234 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001234:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001238:	4699      	mov	r9, r3
 800123a:	4605      	mov	r5, r0
 800123c:	4688      	mov	r8, r1
 800123e:	4617      	mov	r7, r2
 8001240:	2320      	movs	r3, #32
 8001242:	f383 8811 	msr	BASEPRI, r3
  size_t c = 0, size;
 8001246:	2600      	movs	r6, #0
}
 8001248:	e018      	b.n	800127c <obqWriteTimeout+0x48>
    size = (size_t)(bqp->top - bqp->ptr);
 800124a:	6aac      	ldr	r4, [r5, #40]	@ 0x28
    if (size > (n - c)) {
 800124c:	1bbb      	subs	r3, r7, r6
    size = (size_t)(bqp->top - bqp->ptr);
 800124e:	1a24      	subs	r4, r4, r0
    if (size > (n - c)) {
 8001250:	429c      	cmp	r4, r3
 8001252:	bf28      	it	cs
 8001254:	461c      	movcs	r4, r3
    if (dir) memcpy(bqp->ptr, &bp[c], size); // to buffer (write)
 8001256:	4622      	mov	r2, r4
 8001258:	eb08 0106 	add.w	r1, r8, r6
 800125c:	f010 fb02 	bl	8011864 <memcpy>
    if (bqp->ptr >= bqp->top) {
 8001260:	e9d5 3209 	ldrd	r3, r2, [r5, #36]	@ 0x24
    bqp->ptr += size;
 8001264:	4423      	add	r3, r4
    if (bqp->ptr >= bqp->top) {
 8001266:	4293      	cmp	r3, r2
    bqp->ptr += size;
 8001268:	626b      	str	r3, [r5, #36]	@ 0x24
    c        += size;
 800126a:	4426      	add	r6, r4
      if (dir) obqPostFullBufferS(bqp, bqp->bsize - sizeof (size_t)); // Write complete (full)
 800126c:	4628      	mov	r0, r5
    if (bqp->ptr >= bqp->top) {
 800126e:	d303      	bcc.n	8001278 <obqWriteTimeout+0x44>
      if (dir) obqPostFullBufferS(bqp, bqp->bsize - sizeof (size_t)); // Write complete (full)
 8001270:	69a9      	ldr	r1, [r5, #24]
 8001272:	3904      	subs	r1, #4
 8001274:	f7ff ffb0 	bl	80011d8 <obqPostFullBufferS>
  } while(c < n);
 8001278:	42b7      	cmp	r7, r6
 800127a:	d909      	bls.n	8001290 <obqWriteTimeout+0x5c>
    if (bqp->ptr == NULL) {
 800127c:	6a68      	ldr	r0, [r5, #36]	@ 0x24
 800127e:	2800      	cmp	r0, #0
 8001280:	d1e3      	bne.n	800124a <obqWriteTimeout+0x16>
      msg_t msg = dir ? obqGetEmptyBufferTimeoutS(bqp, timeout) :
 8001282:	4649      	mov	r1, r9
 8001284:	4628      	mov	r0, r5
 8001286:	f7ff ff91 	bl	80011ac <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 800128a:	b908      	cbnz	r0, 8001290 <obqWriteTimeout+0x5c>
    size = (size_t)(bqp->top - bqp->ptr);
 800128c:	6a68      	ldr	r0, [r5, #36]	@ 0x24
 800128e:	e7dc      	b.n	800124a <obqWriteTimeout+0x16>
 8001290:	2300      	movs	r3, #0
 8001292:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(n > 0U);
  return bqCopyTimeout(obqp, true, (uint8_t *)bp, n, timeout);
}
 8001296:	4630      	mov	r0, r6
 8001298:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800129c <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 800129c:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (bqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 800129e:	6885      	ldr	r5, [r0, #8]
 80012a0:	b945      	cbnz	r5, 80012b4 <obqTryFlushI+0x18>
 80012a2:	6a41      	ldr	r1, [r0, #36]	@ 0x24
 80012a4:	4604      	mov	r4, r0
 80012a6:	b129      	cbz	r1, 80012b4 <obqTryFlushI+0x18>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80012a8:	68c3      	ldr	r3, [r0, #12]
 80012aa:	3904      	subs	r1, #4

    if (size > 0U) {
 80012ac:	1ac9      	subs	r1, r1, r3
 80012ae:	d103      	bne.n	80012b8 <obqTryFlushI+0x1c>
      /* No "current" buffer.*/
      obqp->ptr = NULL;
      return true;
    }
  }
  return false;
 80012b0:	4608      	mov	r0, r1
}
 80012b2:	bd38      	pop	{r3, r4, r5, pc}
  return false;
 80012b4:	2000      	movs	r0, #0
}
 80012b6:	bd38      	pop	{r3, r4, r5, pc}
      bqPrepareBuffer(obqp, size);
 80012b8:	f7ff fe90 	bl	8000fdc <bqPrepareBuffer>
      return true;
 80012bc:	2001      	movs	r0, #1
      obqp->ptr = NULL;
 80012be:	6265      	str	r5, [r4, #36]	@ 0x24
}
 80012c0:	bd38      	pop	{r3, r4, r5, pc}
 80012c2:	bf00      	nop

080012c4 <q_GetI>:
    return osalThreadEnqueueTimeoutS(&qp->q_waiting, timeout);
  return MSG_OK;
}

/* Getting the character from the queue.*/
static msg_t q_GetI(io_queue_t *qp) {
 80012c4:	4603      	mov	r3, r0
 80012c6:	b410      	push	{r4}
  qp->q_counter--;
 80012c8:	6919      	ldr	r1, [r3, #16]
  uint8_t b = qp->q_buffer[qp->q_rd++];
 80012ca:	69c0      	ldr	r0, [r0, #28]
 80012cc:	68dc      	ldr	r4, [r3, #12]
  qp->q_counter--;
 80012ce:	3901      	subs	r1, #1
 80012d0:	6119      	str	r1, [r3, #16]
  if (qp->q_rd >= qp->q_size) qp->q_rd = 0;
 80012d2:	6959      	ldr	r1, [r3, #20]
  uint8_t b = qp->q_buffer[qp->q_rd++];
 80012d4:	1c42      	adds	r2, r0, #1
 80012d6:	61da      	str	r2, [r3, #28]
  if (qp->q_rd >= qp->q_size) qp->q_rd = 0;
 80012d8:	428a      	cmp	r2, r1
 80012da:	bf28      	it	cs
 80012dc:	2200      	movcs	r2, #0
  uint8_t b = qp->q_buffer[qp->q_rd++];
 80012de:	5c20      	ldrb	r0, [r4, r0]
  if (qp->q_rd >= qp->q_size) qp->q_rd = 0;
 80012e0:	61da      	str	r2, [r3, #28]

  return (msg_t)b;
}
 80012e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012e6:	4770      	bx	lr

080012e8 <q_PutI>:

/* Putting the character into the queue.*/
static void q_PutI(io_queue_t *qp, uint8_t b) {
  qp->q_counter++;
 80012e8:	6903      	ldr	r3, [r0, #16]
  qp->q_buffer[qp->q_wr++] = b;
 80012ea:	6982      	ldr	r2, [r0, #24]
  qp->q_counter++;
 80012ec:	3301      	adds	r3, #1
 80012ee:	6103      	str	r3, [r0, #16]
  qp->q_buffer[qp->q_wr++] = b;
 80012f0:	1c53      	adds	r3, r2, #1
 80012f2:	6183      	str	r3, [r0, #24]
 80012f4:	68c3      	ldr	r3, [r0, #12]
 80012f6:	5499      	strb	r1, [r3, r2]
  if (qp->q_wr >= qp->q_size) qp->q_wr = 0;
 80012f8:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 80012fc:	4293      	cmp	r3, r2
 80012fe:	bf28      	it	cs
 8001300:	2300      	movcs	r3, #0
 8001302:	6183      	str	r3, [r0, #24]
}
 8001304:	4770      	bx	lr
 8001306:	bf00      	nop

08001308 <qObjectInit>:
 *                      data is read from the queue. The value can be @p NULL.
 * @param[in] link      application defined pointer
 *
 * @init
 */
void qObjectInit(io_queue_t *iqp, uint8_t *bp, qsize_t size, qnotify_t infy) {
 8001308:	b410      	push	{r4}
  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800130a:	2400      	movs	r4, #0
  iqp->q_buffer  = bp;
 800130c:	e9c0 1403 	strd	r1, r4, [r0, #12]
  iqp->q_rd      = 0;
  iqp->q_wr      = 0;
 8001310:	e9c0 4406 	strd	r4, r4, [r0, #24]
 8001314:	e9c0 0000 	strd	r0, r0, [r0]
  iqp->q_size    = size;
  iqp->q_notify  = infy;
}
 8001318:	f85d 4b04 	ldr.w	r4, [sp], #4
  iqp->q_size    = size;
 800131c:	6142      	str	r2, [r0, #20]
  iqp->q_notify  = infy;
 800131e:	6083      	str	r3, [r0, #8]
}
 8001320:	4770      	bx	lr
 8001322:	bf00      	nop

08001324 <qPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t qPutI(io_queue_t *iqp, uint8_t b) {
 8001324:	b508      	push	{r3, lr}
  osalDbgCheckClassI();
  if (qIsFullI(iqp)) {
 8001326:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 800132a:	429a      	cmp	r2, r3
 800132c:	d206      	bcs.n	800133c <qPutI+0x18>
    return MSG_TIMEOUT;
  }
  q_PutI(iqp, b);
 800132e:	f7ff ffdb 	bl	80012e8 <q_PutI>
  chThdDequeueNextI(tqp, msg);
 8001332:	2100      	movs	r1, #0
 8001334:	f7ff fdcc 	bl	8000ed0 <chThdDequeueNextI>
  q_Restore(iqp);
  return MSG_OK;
 8001338:	2000      	movs	r0, #0
}
 800133a:	bd08      	pop	{r3, pc}
    return MSG_TIMEOUT;
 800133c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001340:	bd08      	pop	{r3, pc}
 8001342:	bf00      	nop

08001344 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001344:	b538      	push	{r3, r4, r5, lr}
 8001346:	4604      	mov	r4, r0
 8001348:	2320      	movs	r3, #32
 800134a:	f383 8811 	msr	BASEPRI, r3
  if (qIsEmptyI(qp))
 800134e:	6903      	ldr	r3, [r0, #16]
 8001350:	b163      	cbz	r3, 800136c <iqGetTimeout+0x28>
  osalSysLock();
  /* Waiting until there is a character available or a timeout occurs.*/
  msg_t msg = waitReadyTimeout(iqp, timeout);
  if (msg == MSG_OK) {
    /* Getting the character from the queue.*/
    msg = q_GetI(iqp);
 8001352:	4620      	mov	r0, r4
 8001354:	f7ff ffb6 	bl	80012c4 <q_GetI>
  if (qp->q_notify != NULL) qp->q_notify(qp);
 8001358:	68a3      	ldr	r3, [r4, #8]
    msg = q_GetI(iqp);
 800135a:	4605      	mov	r5, r0
  if (qp->q_notify != NULL) qp->q_notify(qp);
 800135c:	b10b      	cbz	r3, 8001362 <iqGetTimeout+0x1e>
 800135e:	4620      	mov	r0, r4
 8001360:	4798      	blx	r3
 8001362:	2300      	movs	r3, #0
 8001364:	f383 8811 	msr	BASEPRI, r3
    /* Inform the low side that the queue has at least one slot available.*/
    q_Notify(iqp);
  }
  osalSysUnlock();
  return msg;
}
 8001368:	4628      	mov	r0, r5
 800136a:	bd38      	pop	{r3, r4, r5, pc}
  return chThdEnqueueTimeoutS(tqp, time);
 800136c:	f7ff fd9c 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 8001370:	4605      	mov	r5, r0
 8001372:	2800      	cmp	r0, #0
 8001374:	d0ed      	beq.n	8001352 <iqGetTimeout+0xe>
 8001376:	2300      	movs	r3, #0
 8001378:	f383 8811 	msr	BASEPRI, r3
}
 800137c:	4628      	mov	r0, r5
 800137e:	bd38      	pop	{r3, r4, r5, pc}

08001380 <iqReadTimeout>:
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
qsize_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp, qsize_t n, systime_t timeout) {
 8001380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001384:	b083      	sub	sp, #12
 8001386:	4604      	mov	r4, r0
 8001388:	9301      	str	r3, [sp, #4]
 800138a:	4688      	mov	r8, r1
 800138c:	4617      	mov	r7, r2
 800138e:	2320      	movs	r3, #32
 8001390:	f383 8811 	msr	BASEPRI, r3
  qsize_t r = 0;
 8001394:	f04f 0a00 	mov.w	sl, #0
}
 8001398:	e010      	b.n	80013bc <iqReadTimeout+0x3c>
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     n);
 800139a:	462a      	mov	r2, r5
 800139c:	4618      	mov	r0, r3
 800139e:	f010 fa61 	bl	8011864 <memcpy>
  iqp->q_rd      += n;
 80013a2:	69e6      	ldr	r6, [r4, #28]
 80013a4:	442e      	add	r6, r5
  iqp->q_counter -= n;
 80013a6:	6923      	ldr	r3, [r4, #16]
  iqp->q_rd      += n;
 80013a8:	61e6      	str	r6, [r4, #28]
  iqp->q_counter -= n;
 80013aa:	1b5b      	subs	r3, r3, r5
 80013ac:	6123      	str	r3, [r4, #16]
  osalSysLock();
  while (waitReadyTimeout(iqp, timeout) == MSG_OK) {
    qsize_t done = q_read(iqp, &bp[r], n - r);
    /* Inform the low side that the queue has at least one empty slot available.*/
    q_Notify(iqp);
    r += done;
 80013ae:	44aa      	add	sl, r5
  if (qp->q_notify != NULL) qp->q_notify(qp);
 80013b0:	68a3      	ldr	r3, [r4, #8]
 80013b2:	b10b      	cbz	r3, 80013b8 <iqReadTimeout+0x38>
 80013b4:	4620      	mov	r0, r4
 80013b6:	4798      	blx	r3
    if (r >= n) break;
 80013b8:	4557      	cmp	r7, sl
 80013ba:	d929      	bls.n	8001410 <iqReadTimeout+0x90>
  if (qIsEmptyI(qp))
 80013bc:	6923      	ldr	r3, [r4, #16]
 80013be:	b303      	cbz	r3, 8001402 <iqReadTimeout+0x82>
    qsize_t done = q_read(iqp, &bp[r], n - r);
 80013c0:	eba7 050a 	sub.w	r5, r7, sl
  if (n > s) n = s;
 80013c4:	429d      	cmp	r5, r3
 80013c6:	bf28      	it	cs
 80013c8:	461d      	movcs	r5, r3
  if (n == 0) return 0;
 80013ca:	2d00      	cmp	r5, #0
 80013cc:	d0f0      	beq.n	80013b0 <iqReadTimeout+0x30>
  if (n == 1) {
 80013ce:	2d01      	cmp	r5, #1
    qsize_t done = q_read(iqp, &bp[r], n - r);
 80013d0:	eb08 030a 	add.w	r3, r8, sl
  if (n == 1) {
 80013d4:	d023      	beq.n	800141e <iqReadTimeout+0x9e>
  s = iqp->q_size - iqp->q_rd;
 80013d6:	69e6      	ldr	r6, [r4, #28]
 80013d8:	f8d4 b014 	ldr.w	fp, [r4, #20]
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     n);
 80013dc:	68e1      	ldr	r1, [r4, #12]
  s = iqp->q_size - iqp->q_rd;
 80013de:	ebab 0906 	sub.w	r9, fp, r6
  if (n < s) {
 80013e2:	454d      	cmp	r5, r9
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     n);
 80013e4:	4431      	add	r1, r6
  if (n < s) {
 80013e6:	d3d8      	bcc.n	800139a <iqReadTimeout+0x1a>
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     s);
 80013e8:	464a      	mov	r2, r9
 80013ea:	4618      	mov	r0, r3
 80013ec:	f010 fa3a 	bl	8011864 <memcpy>
    memcpy((void *)&bp[s], (void *)&iqp->q_buffer[0        ], n - s);
 80013f0:	eba6 060b 	sub.w	r6, r6, fp
 80013f4:	442e      	add	r6, r5
 80013f6:	68e1      	ldr	r1, [r4, #12]
 80013f8:	4448      	add	r0, r9
 80013fa:	4632      	mov	r2, r6
 80013fc:	f010 fa32 	bl	8011864 <memcpy>
    iqp->q_rd = -s;
 8001400:	e7d1      	b.n	80013a6 <iqReadTimeout+0x26>
  return chThdEnqueueTimeoutS(tqp, time);
 8001402:	9901      	ldr	r1, [sp, #4]
 8001404:	4620      	mov	r0, r4
 8001406:	f7ff fd4f 	bl	8000ea8 <chThdEnqueueTimeoutS>
  while (waitReadyTimeout(iqp, timeout) == MSG_OK) {
 800140a:	b908      	cbnz	r0, 8001410 <iqReadTimeout+0x90>
  qsize_t s = qGetFullI(iqp);
 800140c:	6923      	ldr	r3, [r4, #16]
 800140e:	e7d7      	b.n	80013c0 <iqReadTimeout+0x40>
 8001410:	2300      	movs	r3, #0
 8001412:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return r;
}
 8001416:	4650      	mov	r0, sl
 8001418:	b003      	add	sp, #12
 800141a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *bp = q_GetI(iqp);
 800141e:	4620      	mov	r0, r4
 8001420:	f7ff ff50 	bl	80012c4 <q_GetI>
 8001424:	f808 000a 	strb.w	r0, [r8, sl]
    r += done;
 8001428:	f10a 0a01 	add.w	sl, sl, #1
    return 1;
 800142c:	e7c0      	b.n	80013b0 <iqReadTimeout+0x30>
 800142e:	bf00      	nop

08001430 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001430:	b538      	push	{r3, r4, r5, lr}
 8001432:	4604      	mov	r4, r0
 8001434:	460d      	mov	r5, r1
 8001436:	2320      	movs	r3, #32
 8001438:	f383 8811 	msr	BASEPRI, r3
  if (qIsFullI(qp))
 800143c:	e9d0 1304 	ldrd	r1, r3, [r0, #16]
 8001440:	4299      	cmp	r1, r3
 8001442:	d20b      	bcs.n	800145c <oqPutTimeout+0x2c>
  osalSysLock();
  /* Waiting until there is a slot available or a timeout occurs.*/
  msg_t msg = waitFreeTimeout(oqp, timeout);
  if (msg == MSG_OK) {
    /* Putting the character into the queue.*/
    q_PutI(oqp, b);
 8001444:	4629      	mov	r1, r5
 8001446:	4620      	mov	r0, r4
 8001448:	f7ff ff4e 	bl	80012e8 <q_PutI>
  if (qp->q_notify != NULL) qp->q_notify(qp);
 800144c:	68a3      	ldr	r3, [r4, #8]
 800144e:	b103      	cbz	r3, 8001452 <oqPutTimeout+0x22>
 8001450:	4798      	blx	r3
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001452:	2000      	movs	r0, #0
 8001454:	2300      	movs	r3, #0
 8001456:	f383 8811 	msr	BASEPRI, r3
    /* Inform the low side that the queue has at least one character available.*/
    q_Notify(oqp);
  }
  osalSysUnlock();
  return msg;
}
 800145a:	bd38      	pop	{r3, r4, r5, pc}
 800145c:	4611      	mov	r1, r2
 800145e:	f7ff fd23 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 8001462:	2800      	cmp	r0, #0
 8001464:	d0ee      	beq.n	8001444 <oqPutTimeout+0x14>
 8001466:	2300      	movs	r3, #0
 8001468:	f383 8811 	msr	BASEPRI, r3
}
 800146c:	bd38      	pop	{r3, r4, r5, pc}
 800146e:	bf00      	nop

08001470 <qGetI>:
 *
 * @iclass
 */
msg_t qGetI(io_queue_t *oqp) {
  osalDbgCheckClassI();
  if (qIsEmptyI(oqp))
 8001470:	6903      	ldr	r3, [r0, #16]
msg_t qGetI(io_queue_t *oqp) {
 8001472:	b510      	push	{r4, lr}
  if (qIsEmptyI(oqp))
 8001474:	b153      	cbz	r3, 800148c <qGetI+0x1c>
 8001476:	4604      	mov	r4, r0
    return MSG_TIMEOUT;
  msg_t b = q_GetI(oqp);
 8001478:	f7ff ff24 	bl	80012c4 <q_GetI>
  chThdDequeueNextI(tqp, msg);
 800147c:	2100      	movs	r1, #0
 800147e:	4603      	mov	r3, r0
 8001480:	4620      	mov	r0, r4
 8001482:	461c      	mov	r4, r3
 8001484:	f7ff fd24 	bl	8000ed0 <chThdDequeueNextI>
  q_Restore(oqp); // Restore on last byte
  return b;
}
 8001488:	4620      	mov	r0, r4
 800148a:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
 800148c:	f04f 34ff 	mov.w	r4, #4294967295
 8001490:	e7fa      	b.n	8001488 <qGetI+0x18>
 8001492:	bf00      	nop

08001494 <oqWriteTimeout>:
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
qsize_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp, qsize_t n, systime_t timeout) {
 8001494:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001498:	b083      	sub	sp, #12
 800149a:	4605      	mov	r5, r0
 800149c:	9301      	str	r3, [sp, #4]
 800149e:	4688      	mov	r8, r1
 80014a0:	2320      	movs	r3, #32
 80014a2:	f383 8811 	msr	BASEPRI, r3
  qsize_t w = 0;
 80014a6:	2600      	movs	r6, #0
 80014a8:	4691      	mov	r9, r2
}
 80014aa:	e00f      	b.n	80014cc <oqWriteTimeout+0x38>
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     n);
 80014ac:	4622      	mov	r2, r4
 80014ae:	f010 f9d9 	bl	8011864 <memcpy>
  oqp->q_wr      += n;
 80014b2:	69af      	ldr	r7, [r5, #24]
 80014b4:	4427      	add	r7, r4
  oqp->q_counter += n;
 80014b6:	692b      	ldr	r3, [r5, #16]
  oqp->q_wr      += n;
 80014b8:	61af      	str	r7, [r5, #24]
  oqp->q_counter += n;
 80014ba:	4423      	add	r3, r4
 80014bc:	612b      	str	r3, [r5, #16]
  osalSysLock();
  while (waitFreeTimeout(oqp, timeout) == MSG_OK) {
    qsize_t done = q_write(oqp, &bp[w], n - w);
    /* Inform the low side that the queue has at least one character available.*/
    q_Notify(oqp);
    w += done;
 80014be:	4426      	add	r6, r4
  if (qp->q_notify != NULL) qp->q_notify(qp);
 80014c0:	68ab      	ldr	r3, [r5, #8]
 80014c2:	b10b      	cbz	r3, 80014c8 <oqWriteTimeout+0x34>
 80014c4:	4628      	mov	r0, r5
 80014c6:	4798      	blx	r3
    if (w >= n) break;
 80014c8:	45b1      	cmp	r9, r6
 80014ca:	d92e      	bls.n	800152a <oqWriteTimeout+0x96>
  if (qIsFullI(qp))
 80014cc:	e9d5 3704 	ldrd	r3, r7, [r5, #16]
 80014d0:	42bb      	cmp	r3, r7
 80014d2:	d222      	bcs.n	800151a <oqWriteTimeout+0x86>
    qsize_t done = q_write(oqp, &bp[w], n - w);
 80014d4:	eba9 0406 	sub.w	r4, r9, r6
  qsize_t s = qGetEmptyI(oqp);
 80014d8:	1afb      	subs	r3, r7, r3
  if (n > s) n = s;
 80014da:	429c      	cmp	r4, r3
 80014dc:	bf28      	it	cs
 80014de:	461c      	movcs	r4, r3
  if (n == 0) return 0;
 80014e0:	2c00      	cmp	r4, #0
 80014e2:	d0ed      	beq.n	80014c0 <oqWriteTimeout+0x2c>
  if (n == 1) {
 80014e4:	2c01      	cmp	r4, #1
    qsize_t done = q_write(oqp, &bp[w], n - w);
 80014e6:	eb08 0106 	add.w	r1, r8, r6
  if (n == 1) {
 80014ea:	d025      	beq.n	8001538 <oqWriteTimeout+0xa4>
  s = oqp->q_size - oqp->q_wr;
 80014ec:	f8d5 b018 	ldr.w	fp, [r5, #24]
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     n);
 80014f0:	68e8      	ldr	r0, [r5, #12]
  s = oqp->q_size - oqp->q_wr;
 80014f2:	eba7 0a0b 	sub.w	sl, r7, fp
  if (n < s) {
 80014f6:	4554      	cmp	r4, sl
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     n);
 80014f8:	4458      	add	r0, fp
  if (n < s) {
 80014fa:	d3d7      	bcc.n	80014ac <oqWriteTimeout+0x18>
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     s);
 80014fc:	4652      	mov	r2, sl
 80014fe:	9100      	str	r1, [sp, #0]
    memcpy((void *)&oqp->q_buffer[0        ], (const void *)&bp[s], n - s);
 8001500:	ebab 0b07 	sub.w	fp, fp, r7
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     s);
 8001504:	f010 f9ae 	bl	8011864 <memcpy>
    memcpy((void *)&oqp->q_buffer[0        ], (const void *)&bp[s], n - s);
 8001508:	9900      	ldr	r1, [sp, #0]
 800150a:	68e8      	ldr	r0, [r5, #12]
 800150c:	eb0b 0704 	add.w	r7, fp, r4
 8001510:	463a      	mov	r2, r7
 8001512:	4451      	add	r1, sl
 8001514:	f010 f9a6 	bl	8011864 <memcpy>
    oqp->q_wr = -s;
 8001518:	e7cd      	b.n	80014b6 <oqWriteTimeout+0x22>
  return chThdEnqueueTimeoutS(tqp, time);
 800151a:	9901      	ldr	r1, [sp, #4]
 800151c:	4628      	mov	r0, r5
 800151e:	f7ff fcc3 	bl	8000ea8 <chThdEnqueueTimeoutS>
  while (waitFreeTimeout(oqp, timeout) == MSG_OK) {
 8001522:	b910      	cbnz	r0, 800152a <oqWriteTimeout+0x96>
  qsize_t s = qGetEmptyI(oqp);
 8001524:	e9d5 3704 	ldrd	r3, r7, [r5, #16]
 8001528:	e7d4      	b.n	80014d4 <oqWriteTimeout+0x40>
 800152a:	2300      	movs	r3, #0
 800152c:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return w;
}
 8001530:	4630      	mov	r0, r6
 8001532:	b003      	add	sp, #12
 8001534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    q_PutI(oqp, *bp);
 8001538:	f818 1006 	ldrb.w	r1, [r8, r6]
 800153c:	4628      	mov	r0, r5
 800153e:	f7ff fed3 	bl	80012e8 <q_PutI>
    w += done;
 8001542:	3601      	adds	r6, #1
    return 1;
 8001544:	e7bc      	b.n	80014c0 <oqWriteTimeout+0x2c>
 8001546:	bf00      	nop

08001548 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001548:	f04f 31ff 	mov.w	r1, #4294967295
 800154c:	3008      	adds	r0, #8
 800154e:	f7ff bef9 	b.w	8001344 <iqGetTimeout>
 8001552:	bf00      	nop

08001554 <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001554:	f04f 32ff 	mov.w	r2, #4294967295
 8001558:	3028      	adds	r0, #40	@ 0x28
 800155a:	f7ff bf69 	b.w	8001430 <oqPutTimeout>
 800155e:	bf00      	nop

08001560 <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001560:	f04f 33ff 	mov.w	r3, #4294967295
 8001564:	3008      	adds	r0, #8
 8001566:	f7ff bf0b 	b.w	8001380 <iqReadTimeout>
 800156a:	bf00      	nop

0800156c <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800156c:	f04f 33ff 	mov.w	r3, #4294967295
 8001570:	3028      	adds	r0, #40	@ 0x28
 8001572:	f7ff bf8f 	b.w	8001494 <oqWriteTimeout>
 8001576:	bf00      	nop

08001578 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8001578:	f000 bcb6 	b.w	8001ee8 <sd_lld_init>

0800157c <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 800157c:	b570      	push	{r4, r5, r6, lr}
 800157e:	4604      	mov	r4, r0
 8001580:	460b      	mov	r3, r1
  sdp->vmt = &vmt;
 8001582:	480b      	ldr	r0, [pc, #44]	@ (80015b0 <sdObjectInit+0x34>)
 8001584:	6020      	str	r0, [r4, #0]
  //osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001586:	2101      	movs	r1, #1
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001588:	4615      	mov	r5, r2
  sdp->state = SD_STOP;
 800158a:	7121      	strb	r1, [r4, #4]
  qObjectInit(&sdp->iqueue, sdp->ib, sizeof(sdp->ib), inotify);
 800158c:	f104 0008 	add.w	r0, r4, #8
 8001590:	f104 0148 	add.w	r1, r4, #72	@ 0x48
 8001594:	2240      	movs	r2, #64	@ 0x40
 8001596:	f7ff feb7 	bl	8001308 <qObjectInit>
  qObjectInit(&sdp->oqueue, sdp->ob, sizeof(sdp->ob), onotify);
 800159a:	462b      	mov	r3, r5
 800159c:	f104 0188 	add.w	r1, r4, #136	@ 0x88
 80015a0:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 80015a4:	2240      	movs	r2, #64	@ 0x40
}
 80015a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  qObjectInit(&sdp->oqueue, sdp->ob, sizeof(sdp->ob), onotify);
 80015aa:	f7ff bead 	b.w	8001308 <qObjectInit>
 80015ae:	bf00      	nop
 80015b0:	08012840 	.word	0x08012840

080015b4 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 80015b4:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80015b6:	6b04      	ldr	r4, [r0, #48]	@ 0x30

  /* If the USB driver is not in the appropriate state then transactions must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80015b8:	f8d4 213c 	ldr.w	r2, [r4, #316]	@ 0x13c
 80015bc:	6813      	ldr	r3, [r2, #0]
 80015be:	7819      	ldrb	r1, [r3, #0]
 80015c0:	2904      	cmp	r1, #4
static void obnotify(io_buffers_queue_t *bqp) {
 80015c2:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80015c4:	d102      	bne.n	80015cc <obnotify+0x18>
 80015c6:	7921      	ldrb	r1, [r4, #4]
 80015c8:	2902      	cmp	r1, #2
 80015ca:	d001      	beq.n	80015d0 <obnotify+0x1c>
  uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  if (buf == NULL)  return;

  /* Buffer found, starting a new transaction.*/
  usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
}
 80015cc:	b002      	add	sp, #8
 80015ce:	bd10      	pop	{r4, pc}
      usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80015d0:	7910      	ldrb	r0, [r2, #4]
 80015d2:	8919      	ldrh	r1, [r3, #8]
 80015d4:	2201      	movs	r2, #1
 80015d6:	fa02 f300 	lsl.w	r3, r2, r0
      (sdup->state != SDU_READY) ||
 80015da:	420b      	tst	r3, r1
 80015dc:	d1f6      	bne.n	80015cc <obnotify+0x18>
  uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80015de:	a901      	add	r1, sp, #4
 80015e0:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 80015e4:	f7ff fdc4 	bl	8001170 <obqGetFullBufferI>
  if (buf == NULL)  return;
 80015e8:	4602      	mov	r2, r0
 80015ea:	2800      	cmp	r0, #0
 80015ec:	d0ee      	beq.n	80015cc <obnotify+0x18>
  usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80015ee:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
 80015f2:	9b01      	ldr	r3, [sp, #4]
 80015f4:	7901      	ldrb	r1, [r0, #4]
 80015f6:	6800      	ldr	r0, [r0, #0]
 80015f8:	f000 f9ba 	bl	8001970 <usbStartTransmitI>
 80015fc:	e7e6      	b.n	80015cc <obnotify+0x18>
 80015fe:	bf00      	nop

08001600 <get>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, USB_READ_TIMEOUT);
 8001600:	f04f 31ff 	mov.w	r1, #4294967295
 8001604:	3008      	adds	r0, #8
 8001606:	f7ff bd53 	b.w	80010b0 <ibqGetTimeout>
 800160a:	bf00      	nop

0800160c <put>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800160c:	f8d0 313c 	ldr.w	r3, [r0, #316]	@ 0x13c
 8001610:	681b      	ldr	r3, [r3, #0]
 8001612:	781b      	ldrb	r3, [r3, #0]
 8001614:	2b04      	cmp	r3, #4
 8001616:	d104      	bne.n	8001622 <put+0x16>
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, USB_WRITE_TIMEOUT);
 8001618:	f04f 32ff 	mov.w	r2, #4294967295
 800161c:	303c      	adds	r0, #60	@ 0x3c
 800161e:	f7ff bde7 	b.w	80011f0 <obqPutTimeout>
}
 8001622:	f06f 0001 	mvn.w	r0, #1
 8001626:	4770      	bx	lr

08001628 <read>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, USB_READ_TIMEOUT);
 8001628:	f04f 33ff 	mov.w	r3, #4294967295
 800162c:	3008      	adds	r0, #8
 800162e:	f7ff bd5f 	b.w	80010f0 <ibqReadTimeout>
 8001632:	bf00      	nop

08001634 <write>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8001634:	f8d0 313c 	ldr.w	r3, [r0, #316]	@ 0x13c
 8001638:	681b      	ldr	r3, [r3, #0]
 800163a:	781b      	ldrb	r3, [r3, #0]
 800163c:	2b04      	cmp	r3, #4
 800163e:	d001      	beq.n	8001644 <write+0x10>
}
 8001640:	2000      	movs	r0, #0
 8001642:	4770      	bx	lr
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, USB_WRITE_TIMEOUT);
 8001644:	f04f 33ff 	mov.w	r3, #4294967295
 8001648:	303c      	adds	r0, #60	@ 0x3c
 800164a:	f7ff bdf3 	b.w	8001234 <obqWriteTimeout>
 800164e:	bf00      	nop

08001650 <sdu_start_receive.isra.0>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) || (sdup->state != SDU_READY)) {
 8001650:	f8d0 213c 	ldr.w	r2, [r0, #316]	@ 0x13c
 8001654:	6813      	ldr	r3, [r2, #0]
 8001656:	7819      	ldrb	r1, [r3, #0]
 8001658:	2904      	cmp	r1, #4
 800165a:	d11c      	bne.n	8001696 <sdu_start_receive.isra.0+0x46>
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 800165c:	b510      	push	{r4, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) || (sdup->state != SDU_READY)) {
 800165e:	7901      	ldrb	r1, [r0, #4]
 8001660:	2902      	cmp	r1, #2
 8001662:	4604      	mov	r4, r0
 8001664:	d000      	beq.n	8001668 <sdu_start_receive.isra.0+0x18>
}
 8001666:	bd10      	pop	{r4, pc}
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8001668:	7950      	ldrb	r0, [r2, #5]
 800166a:	8959      	ldrh	r1, [r3, #10]
 800166c:	2201      	movs	r2, #1
 800166e:	fa02 f300 	lsl.w	r3, r2, r0
 8001672:	420b      	tst	r3, r1
 8001674:	d1f7      	bne.n	8001666 <sdu_start_receive.isra.0+0x16>
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8001676:	f104 0008 	add.w	r0, r4, #8
 800167a:	f7ff fd6d 	bl	8001158 <ibqGetEmptyBufferI>
  if (buf == NULL) {
 800167e:	4602      	mov	r2, r0
 8001680:	2800      	cmp	r0, #0
 8001682:	d0f0      	beq.n	8001666 <sdu_start_receive.isra.0+0x16>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out, buf, SERIAL_USB_RX_BUFFERS_SIZE);
 8001684:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
 8001688:	2340      	movs	r3, #64	@ 0x40
 800168a:	7941      	ldrb	r1, [r0, #5]
 800168c:	6800      	ldr	r0, [r0, #0]
}
 800168e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out, buf, SERIAL_USB_RX_BUFFERS_SIZE);
 8001692:	f000 b957 	b.w	8001944 <usbStartReceiveI>
 8001696:	4770      	bx	lr

08001698 <ibnotify>:
  (void) sdu_start_receive(sdup);
 8001698:	6b00      	ldr	r0, [r0, #48]	@ 0x30
 800169a:	f7ff bfd9 	b.w	8001650 <sdu_start_receive.isra.0>
 800169e:	bf00      	nop

080016a0 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 80016a0:	4770      	bx	lr
 80016a2:	bf00      	nop

080016a4 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 80016a4:	b510      	push	{r4, lr}

  sdup->vmt = &vmt;
  //osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
  bqObjectInit(&sdup->ibqueue, sdup->ib,
 80016a6:	4a0e      	ldr	r2, [pc, #56]	@ (80016e0 <sduObjectInit+0x3c>)
  sdup->vmt = &vmt;
 80016a8:	490e      	ldr	r1, [pc, #56]	@ (80016e4 <sduObjectInit+0x40>)
void sduObjectInit(SerialUSBDriver *sdup) {
 80016aa:	b082      	sub	sp, #8
  sdup->state = SDU_STOP;
 80016ac:	2301      	movs	r3, #1
void sduObjectInit(SerialUSBDriver *sdup) {
 80016ae:	4604      	mov	r4, r0
  sdup->vmt = &vmt;
 80016b0:	6001      	str	r1, [r0, #0]
  sdup->state = SDU_STOP;
 80016b2:	7103      	strb	r3, [r0, #4]
  bqObjectInit(&sdup->ibqueue, sdup->ib,
 80016b4:	f100 0170 	add.w	r1, r0, #112	@ 0x70
 80016b8:	e9cd 2000 	strd	r2, r0, [sp]
 80016bc:	2240      	movs	r2, #64	@ 0x40
 80016be:	3008      	adds	r0, #8
 80016c0:	f7ff fca0 	bl	8001004 <bqObjectInit>
               SERIAL_USB_RX_BUFFERS_SIZE, SERIAL_USB_RX_BUFFERS_NUMBER,
               ibnotify, sdup);
  bqObjectInit(&sdup->obqueue, sdup->ob,
 80016c4:	4a08      	ldr	r2, [pc, #32]	@ (80016e8 <sduObjectInit+0x44>)
 80016c6:	2302      	movs	r3, #2
 80016c8:	e9cd 2400 	strd	r2, r4, [sp]
 80016cc:	f104 01b4 	add.w	r1, r4, #180	@ 0xb4
 80016d0:	2240      	movs	r2, #64	@ 0x40
 80016d2:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 80016d6:	f7ff fc95 	bl	8001004 <bqObjectInit>
               SERIAL_USB_TX_BUFFERS_SIZE, SERIAL_USB_TX_BUFFERS_NUMBER,
               obnotify, sdup);
}
 80016da:	b002      	add	sp, #8
 80016dc:	bd10      	pop	{r4, pc}
 80016de:	bf00      	nop
 80016e0:	08001699 	.word	0x08001699
 80016e4:	08012860 	.word	0x08012860
 80016e8:	080015b5 	.word	0x080015b5

080016ec <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 80016ec:	680b      	ldr	r3, [r1, #0]
 80016ee:	2220      	movs	r2, #32
 80016f0:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80016f4:	790a      	ldrb	r2, [r1, #4]
 80016f6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80016fa:	6290      	str	r0, [r2, #40]	@ 0x28
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80016fc:	794a      	ldrb	r2, [r1, #5]
 80016fe:	3211      	adds	r2, #17
 8001700:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 8001704:	798a      	ldrb	r2, [r1, #6]
 8001706:	b112      	cbz	r2, 800170e <sduStart+0x22>
    usbp->in_params[config->int_in - 1U]  = sdup;
 8001708:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800170c:	6298      	str	r0, [r3, #40]	@ 0x28
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 800170e:	2302      	movs	r3, #2
 8001710:	7103      	strb	r3, [r0, #4]
  sdup->config = config;
 8001712:	f8c0 113c 	str.w	r1, [r0, #316]	@ 0x13c
 8001716:	2300      	movs	r3, #0
 8001718:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 800171c:	4770      	bx	lr
 800171e:	bf00      	nop

08001720 <sduDisconnectI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduDisconnectI(SerialUSBDriver *sdup) {
 8001720:	b510      	push	{r4, lr}
 8001722:	4604      	mov	r4, r0

  /* Queues reset in order to signal the driver stop to the application.*/
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
  bqResetI(&sdup->ibqueue);
 8001724:	3008      	adds	r0, #8
 8001726:	f7ff fc85 	bl	8001034 <bqResetI>
  bqResetI(&sdup->obqueue);
 800172a:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
}
 800172e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  bqResetI(&sdup->obqueue);
 8001732:	f7ff bc7f 	b.w	8001034 <bqResetI>
 8001736:	bf00      	nop

08001738 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8001738:	b510      	push	{r4, lr}
 800173a:	4604      	mov	r4, r0
  bqResetI(&sdup->ibqueue);
 800173c:	3008      	adds	r0, #8
 800173e:	f7ff fc79 	bl	8001034 <bqResetI>
  bqResetI(&sdup->obqueue);
 8001742:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 8001746:	f7ff fc75 	bl	8001034 <bqResetI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
  (void) sdu_start_receive(sdup);
 800174a:	4620      	mov	r0, r4
}
 800174c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void) sdu_start_receive(sdup);
 8001750:	f7ff bf7e 	b.w	8001650 <sdu_start_receive.isra.0>

08001754 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup.bmRequestType & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8001754:	f890 3074 	ldrb.w	r3, [r0, #116]	@ 0x74
 8001758:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 800175c:	2b20      	cmp	r3, #32
 800175e:	d001      	beq.n	8001764 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 8001760:	2000      	movs	r0, #0
    }
  }
  return false;
}
 8001762:	4770      	bx	lr
    switch (usbp->setup.bRequest) {
 8001764:	f890 3075 	ldrb.w	r3, [r0, #117]	@ 0x75
 8001768:	2b21      	cmp	r3, #33	@ 0x21
 800176a:	d807      	bhi.n	800177c <sduRequestsHook+0x28>
 800176c:	2b1f      	cmp	r3, #31
 800176e:	d9f7      	bls.n	8001760 <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8001770:	4a05      	ldr	r2, [pc, #20]	@ (8001788 <sduRequestsHook+0x34>)
 8001772:	2307      	movs	r3, #7
 8001774:	e9c0 231a 	strd	r2, r3, [r0, #104]	@ 0x68
      return true;
 8001778:	2001      	movs	r0, #1
 800177a:	4770      	bx	lr
    switch (usbp->setup.bRequest) {
 800177c:	2b22      	cmp	r3, #34	@ 0x22
 800177e:	d1ef      	bne.n	8001760 <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001780:	2300      	movs	r3, #0
 8001782:	e9c0 331a 	strd	r3, r3, [r0, #104]	@ 0x68
      return true;
 8001786:	e7f7      	b.n	8001778 <sduRequestsHook+0x24>
 8001788:	20000300 	.word	0x20000300

0800178c <sduSOFHookI>:
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800178c:	f8d0 213c 	ldr.w	r2, [r0, #316]	@ 0x13c
 8001790:	6813      	ldr	r3, [r2, #0]
 8001792:	7819      	ldrb	r1, [r3, #0]
 8001794:	2904      	cmp	r1, #4
 8001796:	d107      	bne.n	80017a8 <sduSOFHookI+0x1c>
void sduSOFHookI(SerialUSBDriver *sdup) {
 8001798:	b530      	push	{r4, r5, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800179a:	7901      	ldrb	r1, [r0, #4]
 800179c:	2902      	cmp	r1, #2
void sduSOFHookI(SerialUSBDriver *sdup) {
 800179e:	b083      	sub	sp, #12
 80017a0:	4604      	mov	r4, r0
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80017a2:	d002      	beq.n	80017aa <sduSOFHookI+0x1e>

    osalDbgAssert(buf != NULL, "queue is empty");

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  }
}
 80017a4:	b003      	add	sp, #12
 80017a6:	bd30      	pop	{r4, r5, pc}
 80017a8:	4770      	bx	lr
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80017aa:	7910      	ldrb	r0, [r2, #4]
 80017ac:	8919      	ldrh	r1, [r3, #8]
 80017ae:	2201      	movs	r2, #1
 80017b0:	fa02 f300 	lsl.w	r3, r2, r0
 80017b4:	420b      	tst	r3, r1
 80017b6:	d1f5      	bne.n	80017a4 <sduSOFHookI+0x18>
  if (obqTryFlushI(&sdup->obqueue)) {
 80017b8:	f104 053c 	add.w	r5, r4, #60	@ 0x3c
 80017bc:	4628      	mov	r0, r5
 80017be:	f7ff fd6d 	bl	800129c <obqTryFlushI>
 80017c2:	2800      	cmp	r0, #0
 80017c4:	d0ee      	beq.n	80017a4 <sduSOFHookI+0x18>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80017c6:	a901      	add	r1, sp, #4
 80017c8:	4628      	mov	r0, r5
 80017ca:	f7ff fcd1 	bl	8001170 <obqGetFullBufferI>
 80017ce:	4602      	mov	r2, r0
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80017d0:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
 80017d4:	9b01      	ldr	r3, [sp, #4]
 80017d6:	7901      	ldrb	r1, [r0, #4]
 80017d8:	6800      	ldr	r0, [r0, #0]
 80017da:	f000 f8c9 	bl	8001970 <usbStartTransmitI>
 80017de:	e7e1      	b.n	80017a4 <sduSOFHookI+0x18>

080017e0 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80017e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80017e2:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80017e6:	b083      	sub	sp, #12
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80017e8:	6a9e      	ldr	r6, [r3, #40]	@ 0x28

  if (sdup == NULL) {
 80017ea:	b1ce      	cbz	r6, 8001820 <sduDataTransmitted+0x40>
 80017ec:	4604      	mov	r4, r0
 80017ee:	460d      	mov	r5, r1
 80017f0:	2320      	movs	r3, #32
 80017f2:	f383 8811 	msr	BASEPRI, r3

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 80017f6:	eb00 0781 	add.w	r7, r0, r1, lsl #2
    obqReleaseEmptyBufferI(&sdup->obqueue);
 80017fa:	363c      	adds	r6, #60	@ 0x3c
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 80017fc:	68fb      	ldr	r3, [r7, #12]
 80017fe:	695b      	ldr	r3, [r3, #20]
 8001800:	681b      	ldr	r3, [r3, #0]
 8001802:	b9db      	cbnz	r3, 800183c <sduDataTransmitted+0x5c>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001804:	a901      	add	r1, sp, #4
 8001806:	4630      	mov	r0, r6
 8001808:	f7ff fcb2 	bl	8001170 <obqGetFullBufferI>

  if (buf != NULL) {
 800180c:	4602      	mov	r2, r0
 800180e:	b148      	cbz	r0, 8001824 <sduDataTransmitted+0x44>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 8001810:	9b01      	ldr	r3, [sp, #4]
 8001812:	4629      	mov	r1, r5
 8001814:	4620      	mov	r0, r4
 8001816:	f000 f8ab 	bl	8001970 <usbStartTransmitI>
 800181a:	2300      	movs	r3, #0
 800181c:	f383 8811 	msr	BASEPRI, r3
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 8001820:	b003      	add	sp, #12
 8001822:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (usbp->epc[ep]->in_state->txsize == usbp->epc[ep]->in_maxsize) {
 8001824:	68fb      	ldr	r3, [r7, #12]
 8001826:	6959      	ldr	r1, [r3, #20]
 8001828:	8a1b      	ldrh	r3, [r3, #16]
 800182a:	6809      	ldr	r1, [r1, #0]
 800182c:	4299      	cmp	r1, r3
 800182e:	d1f4      	bne.n	800181a <sduDataTransmitted+0x3a>
    usbStartTransmitI(usbp, ep, NULL, 0);
 8001830:	4603      	mov	r3, r0
 8001832:	4629      	mov	r1, r5
 8001834:	4620      	mov	r0, r4
 8001836:	f000 f89b 	bl	8001970 <usbStartTransmitI>
 800183a:	e7ee      	b.n	800181a <sduDataTransmitted+0x3a>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 800183c:	4630      	mov	r0, r6
 800183e:	f7ff fca1 	bl	8001184 <obqReleaseEmptyBufferI>
 8001842:	e7df      	b.n	8001804 <sduDataTransmitted+0x24>

08001844 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001844:	3111      	adds	r1, #17
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8001846:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001848:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]

  if (sdup == NULL) {
 800184c:	b194      	cbz	r4, 8001874 <sduDataReceived+0x30>
 800184e:	2320      	movs	r3, #32
 8001850:	f383 8811 	msr	BASEPRI, r3
    return;
  }

  osalSysLockFromISR();
  /* Checking for zero-size transactions.*/
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8001854:	f8d4 213c 	ldr.w	r2, [r4, #316]	@ 0x13c
 8001858:	6813      	ldr	r3, [r2, #0]
 800185a:	7952      	ldrb	r2, [r2, #5]
 800185c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8001860:	68db      	ldr	r3, [r3, #12]
 8001862:	699b      	ldr	r3, [r3, #24]
 8001864:	6859      	ldr	r1, [r3, #4]
                                       sdup->config->bulk_out);
  if (size > (size_t)0) {
 8001866:	b931      	cbnz	r1, 8001876 <sduDataReceived+0x32>
  }

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 8001868:	4620      	mov	r0, r4
 800186a:	f7ff fef1 	bl	8001650 <sdu_start_receive.isra.0>
 800186e:	2300      	movs	r3, #0
 8001870:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlockFromISR();
}
 8001874:	bd10      	pop	{r4, pc}
    ibqPostFullBufferI(&sdup->ibqueue, size);
 8001876:	f104 0008 	add.w	r0, r4, #8
 800187a:	f7ff fbe7 	bl	800104c <ibqPostFullBufferI>
 800187e:	e7f3      	b.n	8001868 <sduDataReceived+0x24>

08001880 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8001880:	4770      	bx	lr
 8001882:	bf00      	nop

08001884 <_usb_ep0_error>:

/*  Error response, the state machine goes into an error state, the low
 *  level layer will have to reset it to USB_EP0_WAITING_SETUP after
 *  receiving a SETUP packet.
 */
static void _usb_ep0_error(USBDriver *usbp) {
 8001884:	b510      	push	{r4, lr}
  usb_lld_stall_in(usbp, 0);
 8001886:	2100      	movs	r1, #0
static void _usb_ep0_error(USBDriver *usbp) {
 8001888:	4604      	mov	r4, r0
  usb_lld_stall_in(usbp, 0);
 800188a:	f000 fd83 	bl	8002394 <usb_lld_stall_in>
  usb_lld_stall_out(usbp, 0);
 800188e:	2100      	movs	r1, #0
 8001890:	4620      	mov	r0, r4
 8001892:	f000 fd6d 	bl	8002370 <usb_lld_stall_out>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001896:	6863      	ldr	r3, [r4, #4]
 8001898:	681b      	ldr	r3, [r3, #0]
 800189a:	b113      	cbz	r3, 80018a2 <_usb_ep0_error+0x1e>
 800189c:	2105      	movs	r1, #5
 800189e:	4620      	mov	r0, r4
 80018a0:	4798      	blx	r3
  usbp->ep0state = USB_EP0_ERROR;
 80018a2:	2306      	movs	r3, #6
 80018a4:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 80018a8:	bd10      	pop	{r4, pc}
 80018aa:	bf00      	nop

080018ac <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 80018ac:	b510      	push	{r4, lr}
  usbp->address = usbp->setup.wValue;
 80018ae:	f8b0 3076 	ldrh.w	r3, [r0, #118]	@ 0x76
 80018b2:	f880 307e 	strb.w	r3, [r0, #126]	@ 0x7e
static void set_address(USBDriver *usbp) {
 80018b6:	4604      	mov	r4, r0
  usb_lld_set_address(usbp);
 80018b8:	f000 fb5c 	bl	8001f74 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80018bc:	6863      	ldr	r3, [r4, #4]
 80018be:	681b      	ldr	r3, [r3, #0]
 80018c0:	b113      	cbz	r3, 80018c8 <set_address+0x1c>
 80018c2:	2101      	movs	r1, #1
 80018c4:	4620      	mov	r0, r4
 80018c6:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 80018c8:	2303      	movs	r3, #3
 80018ca:	7023      	strb	r3, [r4, #0]
}
 80018cc:	bd10      	pop	{r4, pc}
 80018ce:	bf00      	nop

080018d0 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 80018d0:	f000 bb24 	b.w	8001f1c <usb_lld_init>

080018d4 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 80018d4:	b538      	push	{r3, r4, r5, lr}
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 80018d6:	2500      	movs	r5, #0
void usbObjectInit(USBDriver *usbp) {
 80018d8:	4604      	mov	r4, r0
  usbp->state        = USB_STOP;
 80018da:	2301      	movs	r3, #1
 80018dc:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
 80018de:	6045      	str	r5, [r0, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 80018e0:	2238      	movs	r2, #56	@ 0x38
 80018e2:	4629      	mov	r1, r5
 80018e4:	302c      	adds	r0, #44	@ 0x2c
 80018e6:	f00f ffa1 	bl	801182c <memset>
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 80018ea:	60a5      	str	r5, [r4, #8]
  usbp->receiving    = 0;
}
 80018ec:	bd38      	pop	{r3, r4, r5, pc}
 80018ee:	bf00      	nop

080018f0 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 80018f0:	b510      	push	{r4, lr}
 80018f2:	460b      	mov	r3, r1
 80018f4:	4604      	mov	r4, r0
 80018f6:	2220      	movs	r2, #32
 80018f8:	f382 8811 	msr	BASEPRI, r2
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80018fc:	2100      	movs	r1, #0
  usbp->config = config;
 80018fe:	6043      	str	r3, [r0, #4]
    usbp->epc[i] = NULL;
 8001900:	300c      	adds	r0, #12
 8001902:	f00f ff93 	bl	801182c <memset>
  }
  usb_lld_start(usbp);
 8001906:	4620      	mov	r0, r4
 8001908:	f000 fb0e 	bl	8001f28 <usb_lld_start>
  usbp->state = USB_READY;
 800190c:	2202      	movs	r2, #2
 800190e:	2300      	movs	r3, #0
 8001910:	7022      	strb	r2, [r4, #0]
 8001912:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8001916:	bd10      	pop	{r4, pc}

08001918 <usbInitEndpointI>:

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8001918:	6953      	ldr	r3, [r2, #20]
  usbp->epc[ep] = epcp;
 800191a:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 800191e:	f8cc 200c 	str.w	r2, [ip, #12]
  if (epcp->in_state != NULL) {
 8001922:	b13b      	cbz	r3, 8001934 <usbInitEndpointI+0x1c>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8001924:	f04f 0c00 	mov.w	ip, #0
 8001928:	f8c3 c000 	str.w	ip, [r3]
 800192c:	f8c3 c004 	str.w	ip, [r3, #4]
 8001930:	f8c3 c008 	str.w	ip, [r3, #8]
  }
  if (epcp->out_state != NULL) {
 8001934:	6993      	ldr	r3, [r2, #24]
 8001936:	b11b      	cbz	r3, 8001940 <usbInitEndpointI+0x28>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8001938:	2200      	movs	r2, #0
 800193a:	601a      	str	r2, [r3, #0]
 800193c:	605a      	str	r2, [r3, #4]
 800193e:	609a      	str	r2, [r3, #8]
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8001940:	f000 bb22 	b.w	8001f88 <usb_lld_init_endpoint>

08001944 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8001944:	b570      	push	{r4, r5, r6, lr}
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8001946:	eb00 0581 	add.w	r5, r0, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800194a:	8946      	ldrh	r6, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 800194c:	68ed      	ldr	r5, [r5, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800194e:	f04f 0e01 	mov.w	lr, #1
  osp = usbp->epc[ep]->out_state;
 8001952:	69ad      	ldr	r5, [r5, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001954:	fa0e fe01 	lsl.w	lr, lr, r1
 8001958:	ea4e 0e06 	orr.w	lr, lr, r6
 800195c:	f8a0 e00a 	strh.w	lr, [r0, #10]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8001960:	60aa      	str	r2, [r5, #8]
  osp->rxsize = n;
  osp->rxcnt  = 0;
 8001962:	2200      	movs	r2, #0
 8001964:	e9c5 3200 	strd	r3, r2, [r5]
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 8001968:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usb_lld_start_out(usbp, ep);
 800196c:	f000 bbc0 	b.w	80020f0 <usb_lld_start_out>

08001970 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8001970:	b570      	push	{r4, r5, r6, lr}
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8001972:	eb00 0581 	add.w	r5, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001976:	8906      	ldrh	r6, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8001978:	68ed      	ldr	r5, [r5, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800197a:	f04f 0e01 	mov.w	lr, #1
  isp = usbp->epc[ep]->in_state;
 800197e:	696d      	ldr	r5, [r5, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001980:	fa0e fe01 	lsl.w	lr, lr, r1
 8001984:	ea4e 0e06 	orr.w	lr, lr, r6
 8001988:	f8a0 e008 	strh.w	lr, [r0, #8]
  /*lint -restore*/
  isp->txbuf  = buf;
 800198c:	60aa      	str	r2, [r5, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 800198e:	2200      	movs	r2, #0
 8001990:	e9c5 3200 	strd	r3, r2, [r5]
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 8001994:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usb_lld_start_in(usbp, ep);
 8001998:	f000 bbbc 	b.w	8002114 <usb_lld_start_in>

0800199c <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 800199c:	b570      	push	{r4, r5, r6, lr}
  unsigned i;
  /* State transition.*/
  usbp->state         = USB_READY;
 800199e:	2302      	movs	r3, #2
void _usb_reset(USBDriver *usbp) {
 80019a0:	4604      	mov	r4, r0
  /* Resetting internal state.*/
  usbp->status        = 0;
 80019a2:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 80019a4:	7003      	strb	r3, [r0, #0]
  usbp->status        = 0;
 80019a6:	67c5      	str	r5, [r0, #124]	@ 0x7c
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
 80019a8:	6085      	str	r5, [r0, #8]
  /* Invalidates all endpoints into the USBDriver structure.*/
#if USB_USE_WAIT == TRUE
  _usb_reset_all_threads(usbp);
#endif
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80019aa:	2220      	movs	r2, #32
 80019ac:	4629      	mov	r1, r5
 80019ae:	300c      	adds	r0, #12
 80019b0:	f00f ff3c 	bl	801182c <memset>
  }
  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80019b4:	f884 5064 	strb.w	r5, [r4, #100]	@ 0x64
  /* Low level reset.*/
  usb_lld_reset(usbp);
 80019b8:	4620      	mov	r0, r4
 80019ba:	f000 fb3b 	bl	8002034 <usb_lld_reset>
  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80019be:	6863      	ldr	r3, [r4, #4]
 80019c0:	681b      	ldr	r3, [r3, #0]
 80019c2:	b123      	cbz	r3, 80019ce <_usb_reset+0x32>
 80019c4:	4629      	mov	r1, r5
 80019c6:	4620      	mov	r0, r4
}
 80019c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80019cc:	4718      	bx	r3
}
 80019ce:	bd70      	pop	{r4, r5, r6, pc}

080019d0 <_usb_suspend>:
 */
void _usb_suspend(USBDriver *usbp) {
  /* State transition.*/
  usbp->state = USB_SUSPENDED;
  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80019d0:	6842      	ldr	r2, [r0, #4]
  usbp->state = USB_SUSPENDED;
 80019d2:	2105      	movs	r1, #5
 80019d4:	7001      	strb	r1, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80019d6:	6813      	ldr	r3, [r2, #0]
 80019d8:	b10b      	cbz	r3, 80019de <_usb_suspend+0xe>
 80019da:	2103      	movs	r1, #3
 80019dc:	4718      	bx	r3
  /* Signaling the event to threads waiting on endpoints.*/
#if USB_USE_WAIT == TRUE
  _usb_reset_all_threads(usbp);
#endif
}
 80019de:	4770      	bx	lr

080019e0 <_usb_wakeup>:
 */
void _usb_wakeup(USBDriver *usbp) {
  /* State transition.*/
  usbp->state = USB_ACTIVE;
  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80019e0:	6842      	ldr	r2, [r0, #4]
  usbp->state = USB_ACTIVE;
 80019e2:	2104      	movs	r1, #4
 80019e4:	7001      	strb	r1, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80019e6:	6813      	ldr	r3, [r2, #0]
 80019e8:	b103      	cbz	r3, 80019ec <_usb_wakeup+0xc>
 80019ea:	4718      	bx	r3
}
 80019ec:	4770      	bx	lr
 80019ee:	bf00      	nop

080019f0 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80019f0:	b538      	push	{r3, r4, r5, lr}
 80019f2:	4604      	mov	r4, r0
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80019f4:	2500      	movs	r5, #0
 80019f6:	f880 5064 	strb.w	r5, [r0, #100]	@ 0x64
  /* Read received setup packet from out endpoint */
  usbReadSetup(usbp, ep, (uint8_t *)&usbp->setup);
 80019fa:	f100 0274 	add.w	r2, r0, #116	@ 0x74
 80019fe:	f000 fb53 	bl	80020a8 <usb_lld_read_setup>
  /* Reset callback for usbSetupTransfer macro */
  usbp->ep0endcb = NULL;
  /* First verify if the application has an handler installed for this request.*/
  if ((usbp->config->requests_hook_cb == NULL) || !(usbp->config->requests_hook_cb(usbp))) {
 8001a02:	6863      	ldr	r3, [r4, #4]
  usbp->ep0endcb = NULL;
 8001a04:	6725      	str	r5, [r4, #112]	@ 0x70
  if ((usbp->config->requests_hook_cb == NULL) || !(usbp->config->requests_hook_cb(usbp))) {
 8001a06:	689b      	ldr	r3, [r3, #8]
 8001a08:	b1eb      	cbz	r3, 8001a46 <_usb_ep0setup+0x56>
 8001a0a:	4620      	mov	r0, r4
 8001a0c:	4798      	blx	r3
 8001a0e:	b1d0      	cbz	r0, 8001a46 <_usb_ep0setup+0x56>
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > usbp->setup.wLength)
 8001a10:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8001a12:	f8b4 307a 	ldrh.w	r3, [r4, #122]	@ 0x7a
 8001a16:	4293      	cmp	r3, r2
    usbp->ep0n = usbp->setup.wLength;
 8001a18:	bf38      	it	cc
 8001a1a:	66e3      	strcc	r3, [r4, #108]	@ 0x6c
 8001a1c:	2320      	movs	r3, #32
 8001a1e:	f383 8811 	msr	BASEPRI, r3

  /* Process prepared ep0 ask / answer, disable ISR event for this time*/
  osalSysLockFromISR();
  if ((usbp->setup.bmRequestType & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001a22:	f994 2074 	ldrsb.w	r2, [r4, #116]	@ 0x74
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8001a26:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
  if ((usbp->setup.bmRequestType & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001a28:	2a00      	cmp	r2, #0
 8001a2a:	db23      	blt.n	8001a74 <_usb_ep0setup+0x84>
      usb_lld_end_setup(usbp, ep);
#endif
      usbp->ep0state = USB_EP0_WAITING_STS;
    }
  } else { /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8001a2c:	b37b      	cbz	r3, 8001a8e <_usb_ep0setup+0x9e>
      /* Starts the receive phase.*/
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8001a2e:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
 8001a30:	2100      	movs	r1, #0
 8001a32:	4620      	mov	r0, r4
 8001a34:	f7ff ff86 	bl	8001944 <usbStartReceiveI>
      usbp->ep0state = USB_EP0_RX;
 8001a38:	2304      	movs	r3, #4
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001a3a:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001a3e:	2300      	movs	r3, #0
 8001a40:	f383 8811 	msr	BASEPRI, r3
#endif
      usbp->ep0state = USB_EP0_SENDING_STS;
    }
  }
  osalSysUnlockFromISR();
}
 8001a44:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t rtype = usbp->setup.bmRequestType;
 8001a46:	f894 3074 	ldrb.w	r3, [r4, #116]	@ 0x74
  if ((rtype & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_STD) {
 8001a4a:	f013 0f60 	tst.w	r3, #96	@ 0x60
 8001a4e:	d12b      	bne.n	8001aa8 <_usb_ep0setup+0xb8>
    uint16_t request = usbp->setup.bRequest;
 8001a50:	f003 031f 	and.w	r3, r3, #31
    switch (rtype & USB_RTYPE_RECIPIENT_MASK) {
 8001a54:	2b01      	cmp	r3, #1
    uint16_t request = usbp->setup.bRequest;
 8001a56:	f894 2075 	ldrb.w	r2, [r4, #117]	@ 0x75
    switch (rtype & USB_RTYPE_RECIPIENT_MASK) {
 8001a5a:	d024      	beq.n	8001aa6 <_usb_ep0setup+0xb6>
 8001a5c:	2b02      	cmp	r3, #2
 8001a5e:	d034      	beq.n	8001aca <_usb_ep0setup+0xda>
 8001a60:	bb13      	cbnz	r3, 8001aa8 <_usb_ep0setup+0xb8>
  switch (request) {
 8001a62:	2a09      	cmp	r2, #9
 8001a64:	d820      	bhi.n	8001aa8 <_usb_ep0setup+0xb8>
 8001a66:	e8df f002 	tbb	[pc, r2]
 8001a6a:	6d8a      	.short	0x6d8a
 8001a6c:	b91f6d1f 	.word	0xb91f6d1f
 8001a70:	90a11fa7 	.word	0x90a11fa7
    if (usbp->ep0n != 0U) {
 8001a74:	b1eb      	cbz	r3, 8001ab2 <_usb_ep0setup+0xc2>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8001a76:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
 8001a78:	2100      	movs	r1, #0
 8001a7a:	4620      	mov	r0, r4
 8001a7c:	f7ff ff78 	bl	8001970 <usbStartTransmitI>
      usbp->ep0state = USB_EP0_TX;
 8001a80:	2301      	movs	r3, #1
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001a82:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001a86:	2300      	movs	r3, #0
 8001a88:	f383 8811 	msr	BASEPRI, r3
}
 8001a8c:	bd38      	pop	{r3, r4, r5, pc}
      usbStartTransmitI(usbp, 0, NULL, 0);
 8001a8e:	461a      	mov	r2, r3
 8001a90:	4619      	mov	r1, r3
 8001a92:	4620      	mov	r0, r4
 8001a94:	f7ff ff6c 	bl	8001970 <usbStartTransmitI>
 8001a98:	2305      	movs	r3, #5
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001a9a:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001a9e:	2300      	movs	r3, #0
 8001aa0:	f383 8811 	msr	BASEPRI, r3
}
 8001aa4:	bd38      	pop	{r3, r4, r5, pc}
  switch (request) {
 8001aa6:	b3aa      	cbz	r2, 8001b14 <_usb_ep0setup+0x124>
      _usb_ep0_error(usbp);
 8001aa8:	4620      	mov	r0, r4
}
 8001aaa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      _usb_ep0_error(usbp);
 8001aae:	f7ff bee9 	b.w	8001884 <_usb_ep0_error>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8001ab2:	461a      	mov	r2, r3
 8001ab4:	4619      	mov	r1, r3
 8001ab6:	4620      	mov	r0, r4
 8001ab8:	f7ff ff44 	bl	8001944 <usbStartReceiveI>
 8001abc:	2303      	movs	r3, #3
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001abe:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001ac2:	2300      	movs	r3, #0
 8001ac4:	f383 8811 	msr	BASEPRI, r3
}
 8001ac8:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t ep  = usbp->setup.wIndex & 0x0F;
 8001aca:	f8b4 3078 	ldrh.w	r3, [r4, #120]	@ 0x78
 8001ace:	f003 010f 	and.w	r1, r3, #15
  bool in_mode = usbp->setup.wIndex & 0x80;
 8001ad2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
  switch (request) {
 8001ad6:	2a0c      	cmp	r2, #12
 8001ad8:	d8e6      	bhi.n	8001aa8 <_usb_ep0setup+0xb8>
 8001ada:	a001      	add	r0, pc, #4	@ (adr r0, 8001ae0 <_usb_ep0setup+0xf0>)
 8001adc:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8001ae0:	08001b63 	.word	0x08001b63
 8001ae4:	08001b21 	.word	0x08001b21
 8001ae8:	08001aa9 	.word	0x08001aa9
 8001aec:	08001b21 	.word	0x08001b21
 8001af0:	08001aa9 	.word	0x08001aa9
 8001af4:	08001aa9 	.word	0x08001aa9
 8001af8:	08001aa9 	.word	0x08001aa9
 8001afc:	08001aa9 	.word	0x08001aa9
 8001b00:	08001aa9 	.word	0x08001aa9
 8001b04:	08001aa9 	.word	0x08001aa9
 8001b08:	08001aa9 	.word	0x08001aa9
 8001b0c:	08001aa9 	.word	0x08001aa9
 8001b10:	08001b15 	.word	0x08001b15
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8001b14:	4a3d      	ldr	r2, [pc, #244]	@ (8001c0c <_usb_ep0setup+0x21c>)
 8001b16:	2302      	movs	r3, #2
 8001b18:	e9c4 231a 	strd	r2, r3, [r4, #104]	@ 0x68
      usbp->state = usbp->configuration != 0 ? USB_ACTIVE : USB_SELECTED;
 8001b1c:	2202      	movs	r2, #2
 8001b1e:	e778      	b.n	8001a12 <_usb_ep0setup+0x22>
    if (usbp->setup.wValue != USB_FEATURE_ENDPOINT_HALT)
 8001b20:	f8b4 0076 	ldrh.w	r0, [r4, #118]	@ 0x76
 8001b24:	2800      	cmp	r0, #0
 8001b26:	d1bf      	bne.n	8001aa8 <_usb_ep0setup+0xb8>
    if (ep == 0)
 8001b28:	2900      	cmp	r1, #0
 8001b2a:	d0bd      	beq.n	8001aa8 <_usb_ep0setup+0xb8>
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001b2c:	2a01      	cmp	r2, #1
    switch (in_mode ? usb_lld_get_status_in(usbp, ep) : usb_lld_get_status_out(usbp, ep))
 8001b2e:	b2c9      	uxtb	r1, r1
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001b30:	4620      	mov	r0, r4
 8001b32:	d061      	beq.n	8001bf8 <_usb_ep0setup+0x208>
    else                                  {if (in_mode) usb_lld_stall_in(usbp, ep); else usb_lld_stall_out(usbp, ep);}
 8001b34:	2b00      	cmp	r3, #0
 8001b36:	d063      	beq.n	8001c00 <_usb_ep0setup+0x210>
 8001b38:	f000 fc2c 	bl	8002394 <usb_lld_stall_in>
        usbSetupTransfer(usbp, NULL, 0, NULL);
 8001b3c:	2300      	movs	r3, #0
 8001b3e:	e9c4 331a 	strd	r3, r3, [r4, #104]	@ 0x68
        return true;
 8001b42:	e76b      	b.n	8001a1c <_usb_ep0setup+0x2c>
      if (usbp->setup.wValue == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8001b44:	f8b4 3076 	ldrh.w	r3, [r4, #118]	@ 0x76
 8001b48:	2b01      	cmp	r3, #1
 8001b4a:	d1ad      	bne.n	8001aa8 <_usb_ep0setup+0xb8>
        usbp->status&=~2U;
 8001b4c:	f8b4 307c 	ldrh.w	r3, [r4, #124]	@ 0x7c
        if (request == USB_REQ_SET_FEATURE)
 8001b50:	2a03      	cmp	r2, #3
        usbp->status&=~2U;
 8001b52:	bf14      	ite	ne
 8001b54:	f023 0302 	bicne.w	r3, r3, #2
          usbp->status|= 2U;
 8001b58:	f043 0302 	orreq.w	r3, r3, #2
 8001b5c:	f8a4 307c 	strh.w	r3, [r4, #124]	@ 0x7c
 8001b60:	e7ec      	b.n	8001b3c <_usb_ep0setup+0x14c>
    switch (in_mode ? usb_lld_get_status_in(usbp, ep) : usb_lld_get_status_out(usbp, ep))
 8001b62:	b2c9      	uxtb	r1, r1
 8001b64:	4620      	mov	r0, r4
 8001b66:	2b00      	cmp	r3, #0
 8001b68:	d03e      	beq.n	8001be8 <_usb_ep0setup+0x1f8>
 8001b6a:	f000 fa8f 	bl	800208c <usb_lld_get_status_in>
 8001b6e:	2801      	cmp	r0, #1
 8001b70:	d03d      	beq.n	8001bee <_usb_ep0setup+0x1fe>
 8001b72:	2802      	cmp	r0, #2
 8001b74:	d198      	bne.n	8001aa8 <_usb_ep0setup+0xb8>
      case EP_STATUS_ACTIVE: usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8001b76:	4b26      	ldr	r3, [pc, #152]	@ (8001c10 <_usb_ep0setup+0x220>)
 8001b78:	e9c4 301a 	strd	r3, r0, [r4, #104]	@ 0x68
        return true;
 8001b7c:	e7ce      	b.n	8001b1c <_usb_ep0setup+0x12c>
      usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8001b7e:	f104 027c 	add.w	r2, r4, #124	@ 0x7c
 8001b82:	2302      	movs	r3, #2
 8001b84:	e9c4 231a 	strd	r2, r3, [r4, #104]	@ 0x68
      return true;
 8001b88:	e7c8      	b.n	8001b1c <_usb_ep0setup+0x12c>
      usbp->configuration = usbp->setup.wValue;
 8001b8a:	f894 3076 	ldrb.w	r3, [r4, #118]	@ 0x76
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001b8e:	6862      	ldr	r2, [r4, #4]
      usbp->configuration = usbp->setup.wValue;
 8001b90:	f884 307f 	strb.w	r3, [r4, #127]	@ 0x7f
      usbp->state = usbp->configuration != 0 ? USB_ACTIVE : USB_SELECTED;
 8001b94:	2b00      	cmp	r3, #0
 8001b96:	bf0c      	ite	eq
 8001b98:	2103      	moveq	r1, #3
 8001b9a:	2104      	movne	r1, #4
 8001b9c:	7021      	strb	r1, [r4, #0]
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001b9e:	6813      	ldr	r3, [r2, #0]
 8001ba0:	2b00      	cmp	r3, #0
 8001ba2:	d0cb      	beq.n	8001b3c <_usb_ep0setup+0x14c>
 8001ba4:	2102      	movs	r1, #2
 8001ba6:	4620      	mov	r0, r4
 8001ba8:	4798      	blx	r3
 8001baa:	e7c7      	b.n	8001b3c <_usb_ep0setup+0x14c>
      usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8001bac:	2201      	movs	r2, #1
 8001bae:	f104 037f 	add.w	r3, r4, #127	@ 0x7f
 8001bb2:	e9c4 321a 	strd	r3, r2, [r4, #104]	@ 0x68
      return true;
 8001bb6:	e72c      	b.n	8001a12 <_usb_ep0setup+0x22>
                                        (usbp->setup.wValue>>8)&0xFF,
 8001bb8:	f8b4 1076 	ldrh.w	r1, [r4, #118]	@ 0x76
        const USBDescriptor *dp = usbp->config->get_descriptor_cb(usbp,
 8001bbc:	6862      	ldr	r2, [r4, #4]
 8001bbe:	f8b4 3078 	ldrh.w	r3, [r4, #120]	@ 0x78
 8001bc2:	6855      	ldr	r5, [r2, #4]
 8001bc4:	4620      	mov	r0, r4
 8001bc6:	b2ca      	uxtb	r2, r1
 8001bc8:	0a09      	lsrs	r1, r1, #8
 8001bca:	47a8      	blx	r5
        if (dp == NULL) return false;
 8001bcc:	2800      	cmp	r0, #0
 8001bce:	f43f af6b 	beq.w	8001aa8 <_usb_ep0setup+0xb8>
        usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8001bd2:	e9d0 2300 	ldrd	r2, r3, [r0]
 8001bd6:	e9c4 321a 	strd	r3, r2, [r4, #104]	@ 0x68
        return true;
 8001bda:	e71a      	b.n	8001a12 <_usb_ep0setup+0x22>
      usbSetupTransfer(usbp, NULL, 0, set_address);
 8001bdc:	4a0d      	ldr	r2, [pc, #52]	@ (8001c14 <_usb_ep0setup+0x224>)
 8001bde:	6722      	str	r2, [r4, #112]	@ 0x70
 8001be0:	2300      	movs	r3, #0
 8001be2:	e9c4 331a 	strd	r3, r3, [r4, #104]	@ 0x68
      return true;
 8001be6:	e719      	b.n	8001a1c <_usb_ep0setup+0x2c>
    switch (in_mode ? usb_lld_get_status_in(usbp, ep) : usb_lld_get_status_out(usbp, ep))
 8001be8:	f000 fa42 	bl	8002070 <usb_lld_get_status_out>
 8001bec:	e7bf      	b.n	8001b6e <_usb_ep0setup+0x17e>
      case EP_STATUS_STALLED:usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8001bee:	4a0a      	ldr	r2, [pc, #40]	@ (8001c18 <_usb_ep0setup+0x228>)
 8001bf0:	2302      	movs	r3, #2
 8001bf2:	e9c4 231a 	strd	r2, r3, [r4, #104]	@ 0x68
        return true;
 8001bf6:	e791      	b.n	8001b1c <_usb_ep0setup+0x12c>
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001bf8:	b12b      	cbz	r3, 8001c06 <_usb_ep0setup+0x216>
 8001bfa:	f000 fbf5 	bl	80023e8 <usb_lld_clear_in>
 8001bfe:	e79d      	b.n	8001b3c <_usb_ep0setup+0x14c>
    else                                  {if (in_mode) usb_lld_stall_in(usbp, ep); else usb_lld_stall_out(usbp, ep);}
 8001c00:	f000 fbb6 	bl	8002370 <usb_lld_stall_out>
 8001c04:	e79a      	b.n	8001b3c <_usb_ep0setup+0x14c>
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001c06:	f000 fbd7 	bl	80023b8 <usb_lld_clear_out>
 8001c0a:	e797      	b.n	8001b3c <_usb_ep0setup+0x14c>
 8001c0c:	08012888 	.word	0x08012888
 8001c10:	08012884 	.word	0x08012884
 8001c14:	080018ad 	.word	0x080018ad
 8001c18:	08012880 	.word	0x08012880

08001c1c <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001c1c:	b538      	push	{r3, r4, r5, lr}
  (void)ep;
  switch (usbp->ep0state) {
 8001c1e:	f890 3064 	ldrb.w	r3, [r0, #100]	@ 0x64
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001c22:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001c24:	2b06      	cmp	r3, #6
 8001c26:	d819      	bhi.n	8001c5c <_usb_ep0in+0x40>
 8001c28:	e8df f003 	tbb	[pc, r3]
 8001c2c:	19090419 	.word	0x19090419
 8001c30:	1d19      	.short	0x1d19
 8001c32:	19          	.byte	0x19
 8001c33:	00          	.byte	0x00
  case USB_EP0_TX:
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < usbp->setup.wLength) &&
 8001c34:	6ec5      	ldr	r5, [r0, #108]	@ 0x6c
 8001c36:	f8b0 207a 	ldrh.w	r2, [r0, #122]	@ 0x7a
 8001c3a:	4295      	cmp	r5, r2
 8001c3c:	d31a      	bcc.n	8001c74 <_usb_ep0in+0x58>
 8001c3e:	2320      	movs	r3, #32
 8001c40:	f383 8811 	msr	BASEPRI, r3
    __attribute__ ((fallthrough));
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 8001c44:	2300      	movs	r3, #0
 8001c46:	461a      	mov	r2, r3
 8001c48:	4619      	mov	r1, r3
 8001c4a:	4620      	mov	r0, r4
 8001c4c:	f7ff fe7a 	bl	8001944 <usbStartReceiveI>
 8001c50:	2300      	movs	r3, #0
 8001c52:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
#else
    /* Use hardware end phase send */
    usb_lld_end_setup(usbp, ep);
#endif
    usbp->ep0state = USB_EP0_WAITING_STS;
 8001c56:	2303      	movs	r3, #3
 8001c58:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
    _usb_ep0_error(usbp);
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001c5c:	bd38      	pop	{r3, r4, r5, pc}
 8001c5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _usb_ep0_error(usbp);
 8001c62:	f7ff be0f 	b.w	8001884 <_usb_ep0_error>
    if (usbp->ep0endcb != NULL)
 8001c66:	6f03      	ldr	r3, [r0, #112]	@ 0x70
 8001c68:	b103      	cbz	r3, 8001c6c <_usb_ep0in+0x50>
      usbp->ep0endcb(usbp);
 8001c6a:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001c6c:	2300      	movs	r3, #0
 8001c6e:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 8001c72:	bd38      	pop	{r3, r4, r5, pc}
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8001c74:	68c2      	ldr	r2, [r0, #12]
 8001c76:	8a12      	ldrh	r2, [r2, #16]
 8001c78:	fbb5 f1f2 	udiv	r1, r5, r2
 8001c7c:	fb02 5511 	mls	r5, r2, r1, r5
    if ((usbp->ep0n < usbp->setup.wLength) &&
 8001c80:	2d00      	cmp	r5, #0
 8001c82:	d1dc      	bne.n	8001c3e <_usb_ep0in+0x22>
 8001c84:	2320      	movs	r3, #32
 8001c86:	f383 8811 	msr	BASEPRI, r3
      usbStartTransmitI(usbp, 0, NULL, 0);
 8001c8a:	462b      	mov	r3, r5
 8001c8c:	462a      	mov	r2, r5
 8001c8e:	4629      	mov	r1, r5
 8001c90:	f7ff fe6e 	bl	8001970 <usbStartTransmitI>
 8001c94:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8001c98:	2302      	movs	r3, #2
 8001c9a:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 8001c9e:	bd38      	pop	{r3, r4, r5, pc}

08001ca0 <_usb_ep0out>:
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  (void)ep;
  switch (usbp->ep0state) {
 8001ca0:	f890 3064 	ldrb.w	r3, [r0, #100]	@ 0x64
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001ca4:	b510      	push	{r4, lr}
 8001ca6:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001ca8:	2b06      	cmp	r3, #6
 8001caa:	d813      	bhi.n	8001cd4 <_usb_ep0out+0x34>
 8001cac:	e8df f003 	tbb	[pc, r3]
 8001cb0:	17131313 	.word	0x17131313
 8001cb4:	1304      	.short	0x1304
 8001cb6:	13          	.byte	0x13
 8001cb7:	00          	.byte	0x00
 8001cb8:	2320      	movs	r3, #32
 8001cba:	f383 8811 	msr	BASEPRI, r3
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 8001cbe:	2300      	movs	r3, #0
 8001cc0:	461a      	mov	r2, r3
 8001cc2:	4619      	mov	r1, r3
 8001cc4:	f7ff fe54 	bl	8001970 <usbStartTransmitI>
 8001cc8:	2300      	movs	r3, #0
 8001cca:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
#else
    /* Use hardware end phase send */
    usb_lld_end_setup(usbp, ep);
#endif
    usbp->ep0state = USB_EP0_SENDING_STS;
 8001cce:	2305      	movs	r3, #5
 8001cd0:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
    _usb_ep0_error(usbp);
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001cd4:	bd10      	pop	{r4, pc}
 8001cd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    _usb_ep0_error(usbp);
 8001cda:	f7ff bdd3 	b.w	8001884 <_usb_ep0_error>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8001cde:	68c3      	ldr	r3, [r0, #12]
 8001ce0:	699b      	ldr	r3, [r3, #24]
 8001ce2:	685b      	ldr	r3, [r3, #4]
 8001ce4:	2b00      	cmp	r3, #0
 8001ce6:	d1f5      	bne.n	8001cd4 <_usb_ep0out+0x34>
    if (usbp->ep0endcb != NULL)
 8001ce8:	6f03      	ldr	r3, [r0, #112]	@ 0x70
 8001cea:	b103      	cbz	r3, 8001cee <_usb_ep0out+0x4e>
      usbp->ep0endcb(usbp);
 8001cec:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001cee:	2300      	movs	r3, #0
 8001cf0:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 8001cf4:	bd10      	pop	{r4, pc}
 8001cf6:	bf00      	nop

08001cf8 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001cf8:	0943      	lsrs	r3, r0, #5
 8001cfa:	009b      	lsls	r3, r3, #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001cfc:	f100 4c60 	add.w	ip, r0, #3758096384	@ 0xe0000000
 8001d00:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 8001d04:	f503 4361 	add.w	r3, r3, #57600	@ 0xe100
 8001d08:	0109      	lsls	r1, r1, #4
 8001d0a:	f50c 4c61 	add.w	ip, ip, #57600	@ 0xe100
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d0e:	f000 001f 	and.w	r0, r0, #31
 8001d12:	2201      	movs	r2, #1
 8001d14:	4082      	lsls	r2, r0
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001d16:	b2c9      	uxtb	r1, r1
 8001d18:	f88c 1300 	strb.w	r1, [ip, #768]	@ 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d1c:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001d20:	601a      	str	r2, [r3, #0]
}
 8001d22:	4770      	bx	lr

08001d24 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8001d24:	4b0d      	ldr	r3, [pc, #52]	@ (8001d5c <hal_lld_init+0x38>)
 8001d26:	f04f 31ff 	mov.w	r1, #4294967295
 8001d2a:	2200      	movs	r2, #0
 8001d2c:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8001d2e:	6299      	str	r1, [r3, #40]	@ 0x28
 8001d30:	629a      	str	r2, [r3, #40]	@ 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001d32:	6918      	ldr	r0, [r3, #16]
 8001d34:	6119      	str	r1, [r3, #16]
 8001d36:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8001d38:	68d8      	ldr	r0, [r3, #12]
 8001d3a:	60d9      	str	r1, [r3, #12]
 8001d3c:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001d3e:	69da      	ldr	r2, [r3, #28]
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8001d40:	4907      	ldr	r1, [pc, #28]	@ (8001d60 <hal_lld_init+0x3c>)
  rccEnablePWRInterface(FALSE);
 8001d42:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8001d46:	61da      	str	r2, [r3, #28]
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001d48:	699a      	ldr	r2, [r3, #24]
 8001d4a:	f042 0201 	orr.w	r2, r2, #1
 8001d4e:	619a      	str	r2, [r3, #24]
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8001d50:	680b      	ldr	r3, [r1, #0]
 8001d52:	f043 0320 	orr.w	r3, r3, #32
 8001d56:	600b      	str	r3, [r1, #0]
#endif
}
 8001d58:	4770      	bx	lr
 8001d5a:	bf00      	nop
 8001d5c:	40021000 	.word	0x40021000
 8001d60:	40010000 	.word	0x40010000

08001d64 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001d64:	4a1f      	ldr	r2, [pc, #124]	@ (8001de4 <stm32_clock_init+0x80>)
 8001d66:	6813      	ldr	r3, [r2, #0]
 8001d68:	f043 0301 	orr.w	r3, r3, #1
 8001d6c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001d6e:	6813      	ldr	r3, [r2, #0]
 8001d70:	0798      	lsls	r0, r3, #30
 8001d72:	d5fc      	bpl.n	8001d6e <stm32_clock_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001d74:	6853      	ldr	r3, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001d76:	491b      	ldr	r1, [pc, #108]	@ (8001de4 <stm32_clock_init+0x80>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001d78:	f023 0303 	bic.w	r3, r3, #3
 8001d7c:	6053      	str	r3, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001d7e:	6853      	ldr	r3, [r2, #4]
 8001d80:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001d82:	684b      	ldr	r3, [r1, #4]
 8001d84:	f013 030c 	ands.w	r3, r3, #12
 8001d88:	d1fb      	bne.n	8001d82 <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001d8a:	6808      	ldr	r0, [r1, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001d8c:	4a15      	ldr	r2, [pc, #84]	@ (8001de4 <stm32_clock_init+0x80>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001d8e:	f000 00f9 	and.w	r0, r0, #249	@ 0xf9
 8001d92:	6008      	str	r0, [r1, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001d94:	604b      	str	r3, [r1, #4]
  RCC->CR |= RCC_CR_HSEON;
 8001d96:	680b      	ldr	r3, [r1, #0]
 8001d98:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001d9c:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001d9e:	6813      	ldr	r3, [r2, #0]
 8001da0:	0399      	lsls	r1, r3, #14
 8001da2:	d5fc      	bpl.n	8001d9e <stm32_clock_init+0x3a>

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001da4:	f242 1110 	movw	r1, #8464	@ 0x2110
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001da8:	2330      	movs	r3, #48	@ 0x30
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8001daa:	480f      	ldr	r0, [pc, #60]	@ (8001de8 <stm32_clock_init+0x84>)
 8001dac:	6050      	str	r0, [r2, #4]
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001dae:	62d1      	str	r1, [r2, #44]	@ 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001db0:	6313      	str	r3, [r2, #48]	@ 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001db2:	6813      	ldr	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001db4:	490b      	ldr	r1, [pc, #44]	@ (8001de4 <stm32_clock_init+0x80>)
  RCC->CR   |= RCC_CR_PLLON;
 8001db6:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001dba:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001dbc:	680b      	ldr	r3, [r1, #0]
 8001dbe:	019b      	lsls	r3, r3, #6
 8001dc0:	d5fc      	bpl.n	8001dbc <stm32_clock_init+0x58>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001dc2:	4b0a      	ldr	r3, [pc, #40]	@ (8001dec <stm32_clock_init+0x88>)
 8001dc4:	2212      	movs	r2, #18
 8001dc6:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001dc8:	684b      	ldr	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001dca:	4a06      	ldr	r2, [pc, #24]	@ (8001de4 <stm32_clock_init+0x80>)
  RCC->CFGR |= STM32_SW;
 8001dcc:	f043 0302 	orr.w	r3, r3, #2
 8001dd0:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001dd2:	6853      	ldr	r3, [r2, #4]
 8001dd4:	f003 030c 	and.w	r3, r3, #12
 8001dd8:	2b08      	cmp	r3, #8
 8001dda:	d1fa      	bne.n	8001dd2 <stm32_clock_init+0x6e>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 8001ddc:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8001dde:	6313      	str	r3, [r2, #48]	@ 0x30
#endif /* !STM32_NO_INIT */
}
 8001de0:	4770      	bx	lr
 8001de2:	bf00      	nop
 8001de4:	40021000 	.word	0x40021000
 8001de8:	071d0400 	.word	0x071d0400
 8001dec:	40022000 	.word	0x40022000

08001df0 <VectorB0>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001df0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8001df4:	691a      	ldr	r2, [r3, #16]
 8001df6:	0792      	lsls	r2, r2, #30
 8001df8:	d401      	bmi.n	8001dfe <VectorB0+0xe>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001dfa:	f7ff b89b 	b.w	8000f34 <_port_irq_epilogue>
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001dfe:	b510      	push	{r4, lr}
    STM32_ST_TIM->SR = 0U;
 8001e00:	2400      	movs	r4, #0
 8001e02:	611c      	str	r4, [r3, #16]
 8001e04:	2320      	movs	r3, #32
 8001e06:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 8001e0a:	f7fe fe1d 	bl	8000a48 <chSysTimerHandlerI>
 8001e0e:	f384 8811 	msr	BASEPRI, r4
}
 8001e12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001e16:	f7ff b88d 	b.w	8000f34 <_port_irq_epilogue>
 8001e1a:	bf00      	nop

08001e1c <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001e1c:	490f      	ldr	r1, [pc, #60]	@ (8001e5c <st_lld_init+0x40>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001e1e:	4810      	ldr	r0, [pc, #64]	@ (8001e60 <st_lld_init+0x44>)
  ST_ENABLE_CLOCK();
 8001e20:	69ca      	ldr	r2, [r1, #28]
 8001e22:	f042 0201 	orr.w	r2, r2, #1
void st_lld_init(void) {
 8001e26:	b430      	push	{r4, r5}
  ST_ENABLE_CLOCK();
 8001e28:	61ca      	str	r2, [r1, #28]
  ST_ENABLE_STOP();
 8001e2a:	6881      	ldr	r1, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001e2c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8001e30:	f240 24cf 	movw	r4, #719	@ 0x2cf
  ST_ENABLE_STOP();
 8001e34:	f041 0101 	orr.w	r1, r1, #1
 8001e38:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001e3a:	2200      	movs	r2, #0
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001e3c:	629c      	str	r4, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001e3e:	f04f 35ff 	mov.w	r5, #4294967295
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001e42:	2401      	movs	r4, #1
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001e44:	62dd      	str	r5, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e46:	2102      	movs	r1, #2
  STM32_ST_TIM->CCMR1  = 0;
 8001e48:	619a      	str	r2, [r3, #24]
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e4a:	201c      	movs	r0, #28
  STM32_ST_TIM->CCR[0] = 0;
 8001e4c:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->DIER   = 0;
 8001e4e:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001e50:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001e52:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001e54:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001e56:	bc30      	pop	{r4, r5}
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e58:	f7ff bf4e 	b.w	8001cf8 <nvicEnableVector>
 8001e5c:	40021000 	.word	0x40021000
 8001e60:	e0042000 	.word	0xe0042000

08001e64 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8001e64:	4a02      	ldr	r2, [pc, #8]	@ (8001e70 <notify1+0xc>)
 8001e66:	6813      	ldr	r3, [r2, #0]
 8001e68:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8001e6c:	6013      	str	r3, [r2, #0]
}
 8001e6e:	4770      	bx	lr
 8001e70:	40013800 	.word	0x40013800

08001e74 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001e74:	b570      	push	{r4, r5, r6, lr}
  USART_TypeDef *u = sdp->usart;
 8001e76:	4b1a      	ldr	r3, [pc, #104]	@ (8001ee0 <VectorD4+0x6c>)
 8001e78:	f8d3 40c8 	ldr.w	r4, [r3, #200]	@ 0xc8
  uint32_t cr1 = u->CR1;
 8001e7c:	6826      	ldr	r6, [r4, #0]
  uint32_t isr = u->ISR;
 8001e7e:	69e5      	ldr	r5, [r4, #28]
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001e80:	b082      	sub	sp, #8
 8001e82:	2220      	movs	r2, #32
  u->ICR = isr;
 8001e84:	6225      	str	r5, [r4, #32]
 8001e86:	f382 8811 	msr	BASEPRI, r2
  while (isr & USART_ISR_RXNE) {
 8001e8a:	06aa      	lsls	r2, r5, #26
 8001e8c:	d509      	bpl.n	8001ea2 <VectorD4+0x2e>
    qPutI(&sdp->iqueue, (uint8_t)u->RDR);
 8001e8e:	3308      	adds	r3, #8
 8001e90:	9301      	str	r3, [sp, #4]
 8001e92:	8ca1      	ldrh	r1, [r4, #36]	@ 0x24
 8001e94:	9801      	ldr	r0, [sp, #4]
 8001e96:	b2c9      	uxtb	r1, r1
 8001e98:	f7ff fa44 	bl	8001324 <qPutI>
    isr = u->ISR;
 8001e9c:	69e5      	ldr	r5, [r4, #28]
  while (isr & USART_ISR_RXNE) {
 8001e9e:	06ab      	lsls	r3, r5, #26
 8001ea0:	d4f7      	bmi.n	8001e92 <VectorD4+0x1e>
  if (cr1 & USART_CR1_TXEIE) {
 8001ea2:	0630      	lsls	r0, r6, #24
 8001ea4:	d410      	bmi.n	8001ec8 <VectorD4+0x54>
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 8001ea6:	0672      	lsls	r2, r6, #25
 8001ea8:	d504      	bpl.n	8001eb4 <VectorD4+0x40>
 8001eaa:	066b      	lsls	r3, r5, #25
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001eac:	bf44      	itt	mi
 8001eae:	f026 0640 	bicmi.w	r6, r6, #64	@ 0x40
 8001eb2:	6026      	strmi	r6, [r4, #0]
 8001eb4:	2300      	movs	r3, #0
 8001eb6:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8001eba:	b002      	add	sp, #8
 8001ebc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8001ec0:	f7ff b838 	b.w	8000f34 <_port_irq_epilogue>
      u->TDR = b;
 8001ec4:	8520      	strh	r0, [r4, #40]	@ 0x28
      isr = u->ISR;
 8001ec6:	69e5      	ldr	r5, [r4, #28]
    while (isr & USART_ISR_TXE) {
 8001ec8:	0629      	lsls	r1, r5, #24
 8001eca:	d5ec      	bpl.n	8001ea6 <VectorD4+0x32>
      msg_t b = qGetI(&sdp->oqueue);
 8001ecc:	4805      	ldr	r0, [pc, #20]	@ (8001ee4 <VectorD4+0x70>)
 8001ece:	f7ff facf 	bl	8001470 <qGetI>
      if (b < MSG_OK) {
 8001ed2:	2800      	cmp	r0, #0
      u->TDR = b;
 8001ed4:	b280      	uxth	r0, r0
      if (b < MSG_OK) {
 8001ed6:	daf5      	bge.n	8001ec4 <VectorD4+0x50>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8001ed8:	f026 0380 	bic.w	r3, r6, #128	@ 0x80
 8001edc:	6023      	str	r3, [r4, #0]
        break;
 8001ede:	e7e2      	b.n	8001ea6 <VectorD4+0x32>
 8001ee0:	20000574 	.word	0x20000574
 8001ee4:	2000059c 	.word	0x2000059c

08001ee8 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8001ee8:	b510      	push	{r4, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8001eea:	4a08      	ldr	r2, [pc, #32]	@ (8001f0c <sd_lld_init+0x24>)
 8001eec:	4808      	ldr	r0, [pc, #32]	@ (8001f10 <sd_lld_init+0x28>)
  SD1.usart = USART1;
 8001eee:	4c08      	ldr	r4, [pc, #32]	@ (8001f10 <sd_lld_init+0x28>)
  sdObjectInit(&SD1, NULL, notify1);
 8001ef0:	2100      	movs	r1, #0
 8001ef2:	f7ff fb43 	bl	800157c <sdObjectInit>
  SD1.usart = USART1;
 8001ef6:	4a07      	ldr	r2, [pc, #28]	@ (8001f14 <sd_lld_init+0x2c>)
  SD1.clock = STM32_USART1CLK;
 8001ef8:	4b07      	ldr	r3, [pc, #28]	@ (8001f18 <sd_lld_init+0x30>)
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001efa:	2102      	movs	r1, #2
  SD1.clock = STM32_USART1CLK;
 8001efc:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001f00:	2025      	movs	r0, #37	@ 0x25
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8001f02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001f06:	f7ff bef7 	b.w	8001cf8 <nvicEnableVector>
 8001f0a:	bf00      	nop
 8001f0c:	08001e65 	.word	0x08001e65
 8001f10:	20000574 	.word	0x20000574
 8001f14:	40013800 	.word	0x40013800
 8001f18:	044aa200 	.word	0x044aa200

08001f1c <usb_lld_init>:
 *
 * @notapi
 */
void usb_lld_init(void) {
  /* Driver initialization.*/
  usbObjectInit(&USBD1);
 8001f1c:	4801      	ldr	r0, [pc, #4]	@ (8001f24 <usb_lld_init+0x8>)
 8001f1e:	f7ff bcd9 	b.w	80018d4 <usbObjectInit>
 8001f22:	bf00      	nop
 8001f24:	20000650 	.word	0x20000650

08001f28 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8001f28:	b538      	push	{r3, r4, r5, lr}

  if (usbp->state == USB_STOP) {
 8001f2a:	7803      	ldrb	r3, [r0, #0]
 8001f2c:	2b01      	cmp	r3, #1
 8001f2e:	d000      	beq.n	8001f32 <usb_lld_start+0xa>
    }
#endif
    /* Reset procedure enforced on driver start.*/
    _usb_reset(usbp);
  }
}
 8001f30:	bd38      	pop	{r3, r4, r5, pc}
    if (&USBD1 == usbp) {
 8001f32:	4a0d      	ldr	r2, [pc, #52]	@ (8001f68 <usb_lld_start+0x40>)
 8001f34:	4290      	cmp	r0, r2
 8001f36:	4604      	mov	r4, r0
 8001f38:	d004      	beq.n	8001f44 <usb_lld_start+0x1c>
    _usb_reset(usbp);
 8001f3a:	4620      	mov	r0, r4
}
 8001f3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _usb_reset(usbp);
 8001f40:	f7ff bd2c 	b.w	800199c <_usb_reset>
      rccEnableUSB(FALSE);
 8001f44:	4909      	ldr	r1, [pc, #36]	@ (8001f6c <usb_lld_start+0x44>)
      STM32_USB->CNTR = CNTR_FRES;
 8001f46:	4d0a      	ldr	r5, [pc, #40]	@ (8001f70 <usb_lld_start+0x48>)
      rccEnableUSB(FALSE);
 8001f48:	69ca      	ldr	r2, [r1, #28]
 8001f4a:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8001f4e:	61ca      	str	r2, [r1, #28]
      nvicEnableVector(STM32_USB1_HP_NUMBER, STM32_USB_USB1_HP_IRQ_PRIORITY);
 8001f50:	204a      	movs	r0, #74	@ 0x4a
      STM32_USB->CNTR = CNTR_FRES;
 8001f52:	642b      	str	r3, [r5, #64]	@ 0x40
      nvicEnableVector(STM32_USB1_HP_NUMBER, STM32_USB_USB1_HP_IRQ_PRIORITY);
 8001f54:	210d      	movs	r1, #13
 8001f56:	f7ff fecf 	bl	8001cf8 <nvicEnableVector>
      nvicEnableVector(STM32_USB1_LP_NUMBER, STM32_USB_USB1_LP_IRQ_PRIORITY);
 8001f5a:	2103      	movs	r1, #3
 8001f5c:	204b      	movs	r0, #75	@ 0x4b
 8001f5e:	f7ff fecb 	bl	8001cf8 <nvicEnableVector>
      STM32_USB->CNTR = 0;
 8001f62:	2300      	movs	r3, #0
 8001f64:	642b      	str	r3, [r5, #64]	@ 0x40
 8001f66:	e7e8      	b.n	8001f3a <usb_lld_start+0x12>
 8001f68:	20000650 	.word	0x20000650
 8001f6c:	40021000 	.word	0x40021000
 8001f70:	40005c00 	.word	0x40005c00

08001f74 <usb_lld_set_address>:
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 8001f74:	f890 307e 	ldrb.w	r3, [r0, #126]	@ 0x7e
 8001f78:	4a02      	ldr	r2, [pc, #8]	@ (8001f84 <usb_lld_set_address+0x10>)
 8001f7a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8001f7e:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8001f80:	4770      	bx	lr
 8001f82:	bf00      	nop
 8001f84:	40005c00 	.word	0x40005c00

08001f88 <usb_lld_init_endpoint>:
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint16_t epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8001f88:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8001f8c:	b5f0      	push	{r4, r5, r6, r7, lr}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8001f8e:	68dc      	ldr	r4, [r3, #12]
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 8001f90:	4a27      	ldr	r2, [pc, #156]	@ (8002030 <usb_lld_init_endpoint+0xa8>)
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8001f92:	6823      	ldr	r3, [r4, #0]
  dp = USB_GET_DESCRIPTOR(ep);
 8001f94:	6d12      	ldr	r2, [r2, #80]	@ 0x50

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 8001f96:	6965      	ldr	r5, [r4, #20]
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8001f98:	f003 0303 	and.w	r3, r3, #3
 8001f9c:	2b03      	cmp	r3, #3
 8001f9e:	bf18      	it	ne
 8001fa0:	fab3 f383 	clzne	r3, r3
  dp = USB_GET_DESCRIPTOR(ep);
 8001fa4:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8001fa8:	bf18      	it	ne
 8001faa:	095b      	lsrne	r3, r3, #5
  dp = USB_GET_DESCRIPTOR(ep);
 8001fac:	f502 42c0 	add.w	r2, r2, #24576	@ 0x6000
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8001fb0:	bf14      	ite	ne
 8001fb2:	025b      	lslne	r3, r3, #9
 8001fb4:	f44f 63c0 	moveq.w	r3, #1536	@ 0x600
  dp = USB_GET_DESCRIPTOR(ep);
 8001fb8:	ea4f 1e01 	mov.w	lr, r1, lsl #4
 8001fbc:	eb02 1c01 	add.w	ip, r2, r1, lsl #4
  if (epcp->in_state != NULL) {
 8001fc0:	b17d      	cbz	r5, 8001fe2 <usb_lld_init_endpoint+0x5a>
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8001fc2:	8a25      	ldrh	r5, [r4, #16]
  next = usbp->pmnext;
 8001fc4:	f8d0 6080 	ldr.w	r6, [r0, #128]	@ 0x80
  usbp->pmnext += (size + 1) & ~1;
 8001fc8:	3501      	adds	r5, #1
 8001fca:	f025 0501 	bic.w	r5, r5, #1
 8001fce:	4435      	add	r5, r6
    dp->TXCOUNT0 = 0;
 8001fd0:	2700      	movs	r7, #0
 8001fd2:	f8cc 7004 	str.w	r7, [ip, #4]
  usbp->pmnext += (size + 1) & ~1;
 8001fd6:	f8c0 5080 	str.w	r5, [r0, #128]	@ 0x80
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8001fda:	f84e 6002 	str.w	r6, [lr, r2]
    }
    else {
      epr |= EPR_STAT_TX_NAK;
    }
#else
    epr |= EPR_STAT_TX_NAK;
 8001fde:	f043 0320 	orr.w	r3, r3, #32
#endif
  }

  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
 8001fe2:	69a2      	ldr	r2, [r4, #24]
 8001fe4:	b192      	cbz	r2, 800200c <usb_lld_init_endpoint+0x84>
    uint16_t nblocks;
    /* Endpoint size and address initialization.*/
    /* > 62 Round up, div by 32 and sub 1 == (size + 31)/32 - 1 == (size-1)/32)*/
    if (epcp->out_maxsize > 62)
 8001fe6:	8a62      	ldrh	r2, [r4, #18]
 8001fe8:	2a3e      	cmp	r2, #62	@ 0x3e
 8001fea:	d819      	bhi.n	8002020 <usb_lld_init_endpoint+0x98>
      nblocks = ((epcp->out_maxsize - 1) >> 5) | (1<<5);
    else
      nblocks = ((epcp->out_maxsize + 1) >> 1);
 8001fec:	3201      	adds	r2, #1
 8001fee:	0854      	lsrs	r4, r2, #1
    dp->RXCOUNT0 = nblocks << 10;
 8001ff0:	02a4      	lsls	r4, r4, #10
 8001ff2:	f8cc 400c 	str.w	r4, [ip, #12]
  next = usbp->pmnext;
 8001ff6:	f8d0 4080 	ldr.w	r4, [r0, #128]	@ 0x80
  usbp->pmnext += (size + 1) & ~1;
 8001ffa:	f022 0201 	bic.w	r2, r2, #1
 8001ffe:	4422      	add	r2, r4
 8002000:	f8c0 2080 	str.w	r2, [r0, #128]	@ 0x80
    }
    else {
      epr |= EPR_STAT_RX_NAK;
    }
#else
    epr |= EPR_STAT_RX_NAK;
 8002004:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8002008:	f8cc 4008 	str.w	r4, [ip, #8]
#endif
  }

  /* CHEPxR register cleared and initialized.*/
  STM32_USB->EPR[ep] = STM32_USB->EPR[ep];
 800200c:	008a      	lsls	r2, r1, #2
 800200e:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 8002012:	f502 42b8 	add.w	r2, r2, #23552	@ 0x5c00
  STM32_USB->EPR[ep] = epr | ep;
 8002016:	430b      	orrs	r3, r1
  STM32_USB->EPR[ep] = STM32_USB->EPR[ep];
 8002018:	6811      	ldr	r1, [r2, #0]
 800201a:	6011      	str	r1, [r2, #0]
  STM32_USB->EPR[ep] = epr | ep;
 800201c:	6013      	str	r3, [r2, #0]
}
 800201e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      nblocks = ((epcp->out_maxsize - 1) >> 5) | (1<<5);
 8002020:	1e54      	subs	r4, r2, #1
 8002022:	f3c4 144f 	ubfx	r4, r4, #5, #16
 8002026:	f044 0420 	orr.w	r4, r4, #32
 800202a:	3201      	adds	r2, #1
 800202c:	e7e0      	b.n	8001ff0 <usb_lld_init_endpoint+0x68>
 800202e:	bf00      	nop
 8002030:	40005c00 	.word	0x40005c00

08002034 <usb_lld_reset>:
  STM32_USB->BTABLE = BTABLE_ADDR;
 8002034:	4a0c      	ldr	r2, [pc, #48]	@ (8002068 <usb_lld_reset+0x34>)
void usb_lld_reset(USBDriver *usbp) {
 8002036:	b410      	push	{r4}
  STM32_USB->BTABLE = BTABLE_ADDR;
 8002038:	2100      	movs	r1, #0
  STM32_USB->DADDR  = DADDR_EF;
 800203a:	2480      	movs	r4, #128	@ 0x80
  STM32_USB->BTABLE = BTABLE_ADDR;
 800203c:	6511      	str	r1, [r2, #80]	@ 0x50
  STM32_USB->ISTR   = 0;
 800203e:	6451      	str	r1, [r2, #68]	@ 0x44
  STM32_USB->DADDR  = DADDR_EF;
 8002040:	64d4      	str	r4, [r2, #76]	@ 0x4c
  if (usbp->config->sof_cb != NULL)
 8002042:	6844      	ldr	r4, [r0, #4]
 8002044:	68e4      	ldr	r4, [r4, #12]
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
 8002046:	428c      	cmp	r4, r1
 8002048:	bf14      	ite	ne
 800204a:	f44f 441e 	movne.w	r4, #40448	@ 0x9e00
 800204e:	f44f 441c 	moveq.w	r4, #39936	@ 0x9c00
  STM32_USB->CNTR = cntr;
 8002052:	6414      	str	r4, [r2, #64]	@ 0x40
  usbp->pmnext = 64;
 8002054:	2440      	movs	r4, #64	@ 0x40
  usbp->epc[0] = &ep0config;
 8002056:	4a05      	ldr	r2, [pc, #20]	@ (800206c <usb_lld_reset+0x38>)
  usbp->pmnext = 64;
 8002058:	f8c0 4080 	str.w	r4, [r0, #128]	@ 0x80
  usbp->epc[0] = &ep0config;
 800205c:	60c2      	str	r2, [r0, #12]
}
 800205e:	f85d 4b04 	ldr.w	r4, [sp], #4
  usb_lld_init_endpoint(usbp, 0);
 8002062:	f7ff bf91 	b.w	8001f88 <usb_lld_init_endpoint>
 8002066:	bf00      	nop
 8002068:	40005c00 	.word	0x40005c00
 800206c:	0801288c 	.word	0x0801288c

08002070 <usb_lld_get_status_out>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 8002070:	4b05      	ldr	r3, [pc, #20]	@ (8002088 <usb_lld_get_status_out+0x18>)
 8002072:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 8002076:	f410 5040 	ands.w	r0, r0, #12288	@ 0x3000
 800207a:	d004      	beq.n	8002086 <usb_lld_get_status_out+0x16>
  case EPR_STAT_RX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_RX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 800207c:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
 8002080:	bf0c      	ite	eq
 8002082:	2001      	moveq	r0, #1
 8002084:	2002      	movne	r0, #2
  }
}
 8002086:	4770      	bx	lr
 8002088:	40005c00 	.word	0x40005c00

0800208c <usb_lld_get_status_in>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 800208c:	4b05      	ldr	r3, [pc, #20]	@ (80020a4 <usb_lld_get_status_in+0x18>)
 800208e:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 8002092:	f010 0030 	ands.w	r0, r0, #48	@ 0x30
 8002096:	d003      	beq.n	80020a0 <usb_lld_get_status_in+0x14>
  case EPR_STAT_TX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_TX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8002098:	2810      	cmp	r0, #16
 800209a:	bf0c      	ite	eq
 800209c:	2001      	moveq	r0, #1
 800209e:	2002      	movne	r0, #2
  }
}
 80020a0:	4770      	bx	lr
 80020a2:	bf00      	nop
 80020a4:	40005c00 	.word	0x40005c00

080020a8 <usb_lld_read_setup>:
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
  (void)usbp;

  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80020a8:	4b10      	ldr	r3, [pc, #64]	@ (80020ec <usb_lld_read_setup+0x44>)
 80020aa:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80020ac:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 80020b0:	f503 43c0 	add.w	r3, r3, #24576	@ 0x6000
 80020b4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 80020b8:	b410      	push	{r4}
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 80020ba:	689b      	ldr	r3, [r3, #8]
 80020bc:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 80020c0:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 80020c4:	005b      	lsls	r3, r3, #1
  uint32_t n;
  for (n = 0; n < 4; n++)
    ((uint16_t *)buf)[n] = pmap[n];
 80020c6:	2000      	movs	r0, #0
 80020c8:	681c      	ldr	r4, [r3, #0]
 80020ca:	4601      	mov	r1, r0
 80020cc:	f364 000f 	bfi	r0, r4, #0, #16
 80020d0:	685c      	ldr	r4, [r3, #4]
 80020d2:	f364 401f 	bfi	r0, r4, #16, #16
 80020d6:	e9d3 4302 	ldrd	r4, r3, [r3, #8]
 80020da:	f364 010f 	bfi	r1, r4, #0, #16
 80020de:	f363 411f 	bfi	r1, r3, #16, #16
}
 80020e2:	f85d 4b04 	ldr.w	r4, [sp], #4
    ((uint16_t *)buf)[n] = pmap[n];
 80020e6:	6010      	str	r0, [r2, #0]
 80020e8:	6051      	str	r1, [r2, #4]
}
 80020ea:	4770      	bx	lr
 80020ec:	40005c00 	.word	0x40005c00

080020f0 <usb_lld_start_out>:
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 80020f0:	4a07      	ldr	r2, [pc, #28]	@ (8002110 <usb_lld_start_out+0x20>)
 80020f2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80020f6:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 80020fa:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80020fe:	f483 5340 	eor.w	r3, r3, #12288	@ 0x3000
 8002102:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8002106:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800210a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 800210e:	4770      	bx	lr
 8002110:	40005c00 	.word	0x40005c00

08002114 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8002114:	eb00 0081 	add.w	r0, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8002118:	b470      	push	{r4, r5, r6}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 800211a:	68c3      	ldr	r3, [r0, #12]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800211c:	4a1d      	ldr	r2, [pc, #116]	@ (8002194 <usb_lld_start_in+0x80>)
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800211e:	695d      	ldr	r5, [r3, #20]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002120:	6d10      	ldr	r0, [r2, #80]	@ 0x50
 // if (isp->txsize < isp->txcnt) return;
  /* Get data count for send */
  size_t n = isp->txsize - isp->txcnt;
  /* Limit by max size */
  if (n > epcp->in_maxsize)
 8002122:	8a1b      	ldrh	r3, [r3, #16]
  size_t n = isp->txsize - isp->txcnt;
 8002124:	e9d5 4600 	ldrd	r4, r6, [r5]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002128:	f100 4080 	add.w	r0, r0, #1073741824	@ 0x40000000
  size_t n = isp->txsize - isp->txcnt;
 800212c:	1ba4      	subs	r4, r4, r6
  if (n > epcp->in_maxsize)
 800212e:	429c      	cmp	r4, r3
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002130:	f500 40c0 	add.w	r0, r0, #24576	@ 0x6000
 8002134:	ea4f 1201 	mov.w	r2, r1, lsl #4
  if (n > epcp->in_maxsize)
 8002138:	bf28      	it	cs
 800213a:	461c      	movcs	r4, r3
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800213c:	5812      	ldr	r2, [r2, r0]
    n = epcp->in_maxsize;
  usb_packet_write_from_buffer(ep, &isp->txbuf[isp->txcnt], n);
 800213e:	68ab      	ldr	r3, [r5, #8]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002140:	eb00 1001 	add.w	r0, r0, r1, lsl #4
  for (size_t i = 0; i < ((n+1)>>1); i++)
 8002144:	f104 0c01 	add.w	ip, r4, #1
 8002148:	ea5f 0c5c 	movs.w	ip, ip, lsr #1
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 800214c:	6044      	str	r4, [r0, #4]
  for (size_t i = 0; i < ((n+1)>>1); i++)
 800214e:	d00d      	beq.n	800216c <usb_lld_start_in+0x58>
 8002150:	f102 5200 	add.w	r2, r2, #536870912	@ 0x20000000
 8002154:	f502 5240 	add.w	r2, r2, #12288	@ 0x3000
 8002158:	4433      	add	r3, r6
 800215a:	0052      	lsls	r2, r2, #1
 800215c:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
    pmap[i] = ((uint16_t *)buf)[i];
 8002160:	f833 0b02 	ldrh.w	r0, [r3], #2
 8002164:	f842 0b04 	str.w	r0, [r2], #4
  for (size_t i = 0; i < ((n+1)>>1); i++)
 8002168:	4563      	cmp	r3, ip
 800216a:	d1f9      	bne.n	8002160 <usb_lld_start_in+0x4c>
  /* Transaction data updated.*/
  isp->txcnt+= n;
  /* Starting IN operation.*/
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 800216c:	4a09      	ldr	r2, [pc, #36]	@ (8002194 <usb_lld_start_in+0x80>)
 800216e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8002172:	f423 43f0 	bic.w	r3, r3, #30720	@ 0x7800
 8002176:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800217a:	f083 0330 	eor.w	r3, r3, #48	@ 0x30
 800217e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
  isp->txcnt+= n;
 8002182:	4434      	add	r4, r6
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002184:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
  isp->txcnt+= n;
 8002188:	606c      	str	r4, [r5, #4]
}
 800218a:	bc70      	pop	{r4, r5, r6}
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 800218c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8002190:	4770      	bx	lr
 8002192:	bf00      	nop
 8002194:	40005c00 	.word	0x40005c00

08002198 <Vector16C>:
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8002198:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t istr = STM32_USB->ISTR;
 800219c:	4b71      	ldr	r3, [pc, #452]	@ (8002364 <Vector16C+0x1cc>)
 800219e:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
  STM32_USB->ISTR = ~istr;
 80021a0:	43e2      	mvns	r2, r4
  if ((istr & ISTR_RESET) != 0U) {
 80021a2:	0561      	lsls	r1, r4, #21
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 80021a4:	b087      	sub	sp, #28
  STM32_USB->ISTR = ~istr;
 80021a6:	645a      	str	r2, [r3, #68]	@ 0x44
  if ((istr & ISTR_RESET) != 0U) {
 80021a8:	f100 80c4 	bmi.w	8002334 <Vector16C+0x19c>
  if ((istr & ISTR_SUSP) != 0U) {
 80021ac:	0522      	lsls	r2, r4, #20
 80021ae:	f100 80c7 	bmi.w	8002340 <Vector16C+0x1a8>
  if ((istr & ISTR_WKUP) != 0U) {
 80021b2:	04e3      	lsls	r3, r4, #19
 80021b4:	d504      	bpl.n	80021c0 <Vector16C+0x28>
    uint32_t fnr = STM32_USB->FNR;
 80021b6:	4b6b      	ldr	r3, [pc, #428]	@ (8002364 <Vector16C+0x1cc>)
 80021b8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
    if ((fnr & FNR_RXDP) == 0U) {
 80021ba:	0417      	lsls	r7, r2, #16
 80021bc:	f140 80c9 	bpl.w	8002352 <Vector16C+0x1ba>
  if ((istr & ISTR_SOF) != 0U) {
 80021c0:	05a6      	lsls	r6, r4, #22
 80021c2:	d507      	bpl.n	80021d4 <Vector16C+0x3c>
    _usb_isr_invoke_sof_cb(usbp);
 80021c4:	f8df b1a4 	ldr.w	fp, [pc, #420]	@ 800236c <Vector16C+0x1d4>
 80021c8:	f8db 3004 	ldr.w	r3, [fp, #4]
 80021cc:	68db      	ldr	r3, [r3, #12]
 80021ce:	b10b      	cbz	r3, 80021d4 <Vector16C+0x3c>
 80021d0:	4658      	mov	r0, fp
 80021d2:	4798      	blx	r3
  while ((istr & ISTR_CTR) != 0U) {
 80021d4:	0425      	lsls	r5, r4, #16
 80021d6:	d53e      	bpl.n	8002256 <Vector16C+0xbe>
 80021d8:	f8df b190 	ldr.w	fp, [pc, #400]	@ 800236c <Vector16C+0x1d4>
    EPR_CLEAR_CTR_RX(ep);
 80021dc:	4f62      	ldr	r7, [pc, #392]	@ (8002368 <Vector16C+0x1d0>)
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80021de:	f8df a184 	ldr.w	sl, [pc, #388]	@ 8002364 <Vector16C+0x1cc>
 80021e2:	e01a      	b.n	800221a <Vector16C+0x82>
    USBInEndpointState *isp = epcp->in_state;
 80021e4:	6970      	ldr	r0, [r6, #20]
    EPR_CLEAR_CTR_TX(ep);
 80021e6:	6819      	ldr	r1, [r3, #0]
    if (isp->txcnt < isp->txsize) { /* Transfer not completed, there are more packets to send.*/
 80021e8:	e9d0 0400 	ldrd	r0, r4, [r0]
    EPR_CLEAR_CTR_TX(ep);
 80021ec:	4039      	ands	r1, r7
 80021ee:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
    if (isp->txcnt < isp->txsize) { /* Transfer not completed, there are more packets to send.*/
 80021f2:	4284      	cmp	r4, r0
    EPR_CLEAR_CTR_TX(ep);
 80021f4:	6019      	str	r1, [r3, #0]
    if (isp->txcnt < isp->txsize) { /* Transfer not completed, there are more packets to send.*/
 80021f6:	d333      	bcc.n	8002260 <Vector16C+0xc8>
      _usb_isr_invoke_in_cb(usbp, ep);
 80021f8:	f8bb 3008 	ldrh.w	r3, [fp, #8]
 80021fc:	68b4      	ldr	r4, [r6, #8]
 80021fe:	2101      	movs	r1, #1
 8002200:	4091      	lsls	r1, r2
 8002202:	ea23 0301 	bic.w	r3, r3, r1
 8002206:	f8ab 3008 	strh.w	r3, [fp, #8]
 800220a:	b114      	cbz	r4, 8002212 <Vector16C+0x7a>
 800220c:	4857      	ldr	r0, [pc, #348]	@ (800236c <Vector16C+0x1d4>)
 800220e:	4611      	mov	r1, r2
 8002210:	47a0      	blx	r4
    istr = STM32_USB->ISTR;
 8002212:	f8da 4044 	ldr.w	r4, [sl, #68]	@ 0x44
  while ((istr & ISTR_CTR) != 0U) {
 8002216:	0423      	lsls	r3, r4, #16
 8002218:	d51d      	bpl.n	8002256 <Vector16C+0xbe>
  uint32_t ep = istr & ISTR_EP_ID_MASK;
 800221a:	f004 020f 	and.w	r2, r4, #15
  uint32_t epr = STM32_USB->EPR[ep];
 800221e:	0093      	lsls	r3, r2, #2
 8002220:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8002224:	f102 0c02 	add.w	ip, r2, #2
 8002228:	f503 43b8 	add.w	r3, r3, #23552	@ 0x5c00
 800222c:	eb0b 018c 	add.w	r1, fp, ip, lsl #2
  if ((istr & ISTR_DIR) == 0U) {
 8002230:	06e4      	lsls	r4, r4, #27
  uint32_t epr = STM32_USB->EPR[ep];
 8002232:	681d      	ldr	r5, [r3, #0]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8002234:	684e      	ldr	r6, [r1, #4]
  if ((istr & ISTR_DIR) == 0U) {
 8002236:	d5d5      	bpl.n	80021e4 <Vector16C+0x4c>
    EPR_CLEAR_CTR_RX(ep);
 8002238:	6818      	ldr	r0, [r3, #0]
 800223a:	4038      	ands	r0, r7
 800223c:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
 8002240:	6018      	str	r0, [r3, #0]
    if (epr & EPR_SETUP) {
 8002242:	0528      	lsls	r0, r5, #20
      usb_lld_start_in(usbp, ep);
 8002244:	b2d1      	uxtb	r1, r2
    if (epr & EPR_SETUP) {
 8002246:	d510      	bpl.n	800226a <Vector16C+0xd2>
      _usb_isr_invoke_setup_cb(usbp, ep);
 8002248:	6873      	ldr	r3, [r6, #4]
 800224a:	4848      	ldr	r0, [pc, #288]	@ (800236c <Vector16C+0x1d4>)
 800224c:	4798      	blx	r3
    istr = STM32_USB->ISTR;
 800224e:	f8da 4044 	ldr.w	r4, [sl, #68]	@ 0x44
  while ((istr & ISTR_CTR) != 0U) {
 8002252:	0423      	lsls	r3, r4, #16
 8002254:	d4e1      	bmi.n	800221a <Vector16C+0x82>
}
 8002256:	b007      	add	sp, #28
 8002258:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 800225c:	f7fe be6a 	b.w	8000f34 <_port_irq_epilogue>
      usb_lld_start_in(usbp, ep);
 8002260:	4842      	ldr	r0, [pc, #264]	@ (800236c <Vector16C+0x1d4>)
 8002262:	4611      	mov	r1, r2
 8002264:	f7ff ff56 	bl	8002114 <usb_lld_start_in>
 8002268:	e7d3      	b.n	8002212 <Vector16C+0x7a>
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800226a:	f8da 0050 	ldr.w	r0, [sl, #80]	@ 0x50
      USBOutEndpointState *osp = epcp->out_state;
 800226e:	f8d6 e018 	ldr.w	lr, [r6, #24]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002272:	f100 4080 	add.w	r0, r0, #1073741824	@ 0x40000000
 8002276:	f500 40c0 	add.w	r0, r0, #24576	@ 0x6000
 800227a:	eb00 1002 	add.w	r0, r0, r2, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800227e:	6884      	ldr	r4, [r0, #8]
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8002280:	f8d0 800c 	ldr.w	r8, [r0, #12]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002284:	f104 5000 	add.w	r0, r4, #536870912	@ 0x20000000
 8002288:	f500 5040 	add.w	r0, r0, #12288	@ 0x3000
 800228c:	0044      	lsls	r4, r0, #1
      n = usb_packet_read_to_buffer(ep, &osp->rxbuf[osp->rxcnt]);
 800228e:	f8de 0004 	ldr.w	r0, [lr, #4]
 8002292:	9001      	str	r0, [sp, #4]
 8002294:	4605      	mov	r5, r0
 8002296:	f8de 0008 	ldr.w	r0, [lr, #8]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800229a:	9405      	str	r4, [sp, #20]
      n = usb_packet_read_to_buffer(ep, &osp->rxbuf[osp->rxcnt]);
 800229c:	4428      	add	r0, r5
 800229e:	9002      	str	r0, [sp, #8]
  for (i = 0; i < (n>>1); i++)
 80022a0:	f3c8 0548 	ubfx	r5, r8, #1, #9
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 80022a4:	f3c8 0009 	ubfx	r0, r8, #0, #10
 80022a8:	9003      	str	r0, [sp, #12]
  for (i = 0; i < (n>>1); i++)
 80022aa:	b15d      	cbz	r5, 80022c4 <Vector16C+0x12c>
 80022ac:	9802      	ldr	r0, [sp, #8]
 80022ae:	9204      	str	r2, [sp, #16]
 80022b0:	3802      	subs	r0, #2
 80022b2:	eb00 0945 	add.w	r9, r0, r5, lsl #1
    ((uint16_t *)buf)[i] = pmap[i];
 80022b6:	f854 2b04 	ldr.w	r2, [r4], #4
 80022ba:	f820 2f02 	strh.w	r2, [r0, #2]!
  for (i = 0; i < (n>>1); i++)
 80022be:	4581      	cmp	r9, r0
 80022c0:	d1f9      	bne.n	80022b6 <Vector16C+0x11e>
 80022c2:	9a04      	ldr	r2, [sp, #16]
  if (n&1) buf[i*2] = (uint8_t)pmap[i];
 80022c4:	f018 0f01 	tst.w	r8, #1
 80022c8:	d008      	beq.n	80022dc <Vector16C+0x144>
 80022ca:	9805      	ldr	r0, [sp, #20]
 80022cc:	9c02      	ldr	r4, [sp, #8]
 80022ce:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
 80022d2:	f804 0015 	strb.w	r0, [r4, r5, lsl #1]
      osp->rxcnt += n;
 80022d6:	f8de 0004 	ldr.w	r0, [lr, #4]
 80022da:	9001      	str	r0, [sp, #4]
 80022dc:	9801      	ldr	r0, [sp, #4]
 80022de:	9d03      	ldr	r5, [sp, #12]
      if (osp->rxcnt >= osp->rxsize || n < epcp->out_maxsize) {
 80022e0:	f8de 4000 	ldr.w	r4, [lr]
      osp->rxcnt += n;
 80022e4:	4428      	add	r0, r5
      if (osp->rxcnt >= osp->rxsize || n < epcp->out_maxsize) {
 80022e6:	42a0      	cmp	r0, r4
      osp->rxcnt += n;
 80022e8:	f8ce 0004 	str.w	r0, [lr, #4]
      if (osp->rxcnt >= osp->rxsize || n < epcp->out_maxsize) {
 80022ec:	d202      	bcs.n	80022f4 <Vector16C+0x15c>
 80022ee:	8a70      	ldrh	r0, [r6, #18]
 80022f0:	42a8      	cmp	r0, r5
 80022f2:	d912      	bls.n	800231a <Vector16C+0x182>
        _usb_isr_invoke_out_cb(usbp, ep);
 80022f4:	eb0b 0c8c 	add.w	ip, fp, ip, lsl #2
 80022f8:	2001      	movs	r0, #1
 80022fa:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80022fe:	68dc      	ldr	r4, [r3, #12]
 8002300:	f8bb 300a 	ldrh.w	r3, [fp, #10]
 8002304:	4090      	lsls	r0, r2
 8002306:	ea23 0300 	bic.w	r3, r3, r0
 800230a:	f8ab 300a 	strh.w	r3, [fp, #10]
 800230e:	2c00      	cmp	r4, #0
 8002310:	f43f af7f 	beq.w	8002212 <Vector16C+0x7a>
 8002314:	4815      	ldr	r0, [pc, #84]	@ (800236c <Vector16C+0x1d4>)
 8002316:	47a0      	blx	r4
 8002318:	e77b      	b.n	8002212 <Vector16C+0x7a>
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800231a:	681a      	ldr	r2, [r3, #0]
 800231c:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8002320:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8002324:	f482 5240 	eor.w	r2, r2, #12288	@ 0x3000
 8002328:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800232c:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8002330:	601a      	str	r2, [r3, #0]
 8002332:	e76e      	b.n	8002212 <Vector16C+0x7a>
    _usb_reset(usbp);
 8002334:	480d      	ldr	r0, [pc, #52]	@ (800236c <Vector16C+0x1d4>)
 8002336:	f7ff fb31 	bl	800199c <_usb_reset>
  if ((istr & ISTR_SUSP) != 0U) {
 800233a:	0522      	lsls	r2, r4, #20
 800233c:	f57f af39 	bpl.w	80021b2 <Vector16C+0x1a>
    STM32_USB->CNTR |= CNTR_FSUSP;
 8002340:	4a08      	ldr	r2, [pc, #32]	@ (8002364 <Vector16C+0x1cc>)
    _usb_suspend(usbp);
 8002342:	480a      	ldr	r0, [pc, #40]	@ (800236c <Vector16C+0x1d4>)
    STM32_USB->CNTR |= CNTR_FSUSP;
 8002344:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8002346:	f043 0308 	orr.w	r3, r3, #8
 800234a:	6413      	str	r3, [r2, #64]	@ 0x40
    _usb_suspend(usbp);
 800234c:	f7ff fb40 	bl	80019d0 <_usb_suspend>
 8002350:	e72f      	b.n	80021b2 <Vector16C+0x1a>
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8002352:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
      _usb_wakeup(usbp);
 8002354:	4805      	ldr	r0, [pc, #20]	@ (800236c <Vector16C+0x1d4>)
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8002356:	f022 0208 	bic.w	r2, r2, #8
 800235a:	641a      	str	r2, [r3, #64]	@ 0x40
      _usb_wakeup(usbp);
 800235c:	f7ff fb40 	bl	80019e0 <_usb_wakeup>
 8002360:	e72e      	b.n	80021c0 <Vector16C+0x28>
 8002362:	bf00      	nop
 8002364:	40005c00 	.word	0x40005c00
 8002368:	ffff070f 	.word	0xffff070f
 800236c:	20000650 	.word	0x20000650

08002370 <usb_lld_stall_out>:
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8002370:	4a07      	ldr	r2, [pc, #28]	@ (8002390 <usb_lld_stall_out+0x20>)
 8002372:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8002376:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 800237a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800237e:	f483 5380 	eor.w	r3, r3, #4096	@ 0x1000
 8002382:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8002386:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800238a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 800238e:	4770      	bx	lr
 8002390:	40005c00 	.word	0x40005c00

08002394 <usb_lld_stall_in>:
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8002394:	4a07      	ldr	r2, [pc, #28]	@ (80023b4 <usb_lld_stall_in+0x20>)
 8002396:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 800239a:	f423 43f0 	bic.w	r3, r3, #30720	@ 0x7800
 800239e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80023a2:	f083 0310 	eor.w	r3, r3, #16
 80023a6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80023aa:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80023ae:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 80023b2:	4770      	bx	lr
 80023b4:	40005c00 	.word	0x40005c00

080023b8 <usb_lld_clear_out>:
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
  (void)usbp;
  /* Makes sure to not put to NAK an endpoint that is already transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 80023b8:	0089      	lsls	r1, r1, #2
 80023ba:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 80023be:	f501 41b8 	add.w	r1, r1, #23552	@ 0x5c00
 80023c2:	680b      	ldr	r3, [r1, #0]
 80023c4:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 80023c8:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 80023cc:	d00b      	beq.n	80023e6 <usb_lld_clear_out+0x2e>
    EPR_SET_STAT_RX(ep, EPR_STAT_RX_NAK);
 80023ce:	680b      	ldr	r3, [r1, #0]
 80023d0:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 80023d4:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80023d8:	f483 5300 	eor.w	r3, r3, #8192	@ 0x2000
 80023dc:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80023e0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80023e4:	600b      	str	r3, [r1, #0]
}
 80023e6:	4770      	bx	lr

080023e8 <usb_lld_clear_in>:
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
  (void)usbp;
  /* Makes sure to not put to NAK an endpoint that is already transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 80023e8:	0089      	lsls	r1, r1, #2
 80023ea:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 80023ee:	f501 41b8 	add.w	r1, r1, #23552	@ 0x5c00
 80023f2:	680b      	ldr	r3, [r1, #0]
 80023f4:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 80023f8:	2b30      	cmp	r3, #48	@ 0x30
 80023fa:	d00b      	beq.n	8002414 <usb_lld_clear_in+0x2c>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 80023fc:	680b      	ldr	r3, [r1, #0]
 80023fe:	f423 43f0 	bic.w	r3, r3, #30720	@ 0x7800
 8002402:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8002406:	f083 0320 	eor.w	r3, r3, #32
 800240a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800240e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002412:	600b      	str	r3, [r1, #0]
}
 8002414:	4770      	bx	lr
 8002416:	bf00      	nop

08002418 <boardDFUEnter>:
   VAL_GPIOI_ODR,   VAL_GPIOI_AFRL,   VAL_GPIOI_AFRH}
#endif
};
#endif

void boardDFUEnter(void) {
 8002418:	b480      	push	{r7}
  __set_MSP(*((uint32_t *)(STM32F303xC_SYSTEM_MEMORY)));
 800241a:	4b06      	ldr	r3, [pc, #24]	@ (8002434 <boardDFUEnter+0x1c>)
void boardDFUEnter(void) {
 800241c:	af00      	add	r7, sp, #0
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 800241e:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
 8002422:	f382 8808 	msr	MSP, r2
  ((void (*)(void))(*((uint32_t *)(STM32F303xC_SYSTEM_MEMORY + 4))))(); // jump to DFU
 8002426:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
}
 800242a:	46bd      	mov	sp, r7
 800242c:	f85d 7b04 	ldr.w	r7, [sp], #4
  ((void (*)(void))(*((uint32_t *)(STM32F303xC_SYSTEM_MEMORY + 4))))(); // jump to DFU
 8002430:	4718      	bx	r3
 8002432:	bf00      	nop
 8002434:	1fffd000 	.word	0x1fffd000

08002438 <__early_init>:
 * Early initialization code.
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {
  stm32_clock_init();
 8002438:	f7ff bc94 	b.w	8001d64 <stm32_clock_init>

0800243c <boardInit>:
/*
 * Board-specific initialization code.
 */
void boardInit(void) {
  // Speedup flash latency
  FLASH->ACR= FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY_0;
 800243c:	4b01      	ldr	r3, [pc, #4]	@ (8002444 <boardInit+0x8>)
 800243e:	2211      	movs	r2, #17
 8002440:	601a      	str	r2, [r3, #0]
}
 8002442:	4770      	bx	lr
 8002444:	40022000 	.word	0x40022000

08002448 <long_to_string_with_divisor>:
#pragma pack(pop)

static char *long_to_string_with_divisor(char *p,
                                         longval_t num,
                                         uint32_t radix,
                                         int      precision) {
 8002448:	b5f0      	push	{r4, r5, r6, r7, lr}
  char *q = p + MAX_FILLER;
  char *b = q;
  // convert to string from end buffer to begin
  do {
    uint8_t c = num % radix;
 800244a:	fbb1 fef2 	udiv	lr, r1, r2
 800244e:	fb02 141e 	mls	r4, r2, lr, r1
    num /= radix;
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 8002452:	2c09      	cmp	r4, #9
 8002454:	bf8c      	ite	hi
 8002456:	2537      	movhi	r5, #55	@ 0x37
 8002458:	2530      	movls	r5, #48	@ 0x30
 800245a:	fa55 f484 	uxtab	r4, r5, r4
  char *q = p + MAX_FILLER;
 800245e:	f100 060b 	add.w	r6, r0, #11
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 8002462:	7284      	strb	r4, [r0, #10]
 8002464:	f100 0c0a 	add.w	ip, r0, #10
  }while((precision && --precision) || num);
 8002468:	b33b      	cbz	r3, 80024ba <long_to_string_with_divisor+0x72>
 800246a:	3b01      	subs	r3, #1
 800246c:	d025      	beq.n	80024ba <long_to_string_with_divisor+0x72>
    uint8_t c = num % radix;
 800246e:	fbbe f7f2 	udiv	r7, lr, r2
 8002472:	fb02 e517 	mls	r5, r2, r7, lr
 8002476:	b2ec      	uxtb	r4, r5
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 8002478:	2d09      	cmp	r5, #9
 800247a:	f104 0530 	add.w	r5, r4, #48	@ 0x30
 800247e:	f104 0437 	add.w	r4, r4, #55	@ 0x37
 8002482:	bf94      	ite	ls
 8002484:	f80c 5d01 	strbls.w	r5, [ip, #-1]!
 8002488:	f80c 4d01 	strbhi.w	r4, [ip, #-1]!
  }while((precision && --precision) || num);
 800248c:	3b01      	subs	r3, #1
    uint8_t c = num % radix;
 800248e:	4671      	mov	r1, lr
    num /= radix;
 8002490:	46be      	mov	lr, r7
  }while((precision && --precision) || num);
 8002492:	d1ec      	bne.n	800246e <long_to_string_with_divisor+0x26>
 8002494:	428a      	cmp	r2, r1
    uint8_t c = num % radix;
 8002496:	4671      	mov	r1, lr
  }while((precision && --precision) || num);
 8002498:	d812      	bhi.n	80024c0 <long_to_string_with_divisor+0x78>
    uint8_t c = num % radix;
 800249a:	fbbe f5f2 	udiv	r5, lr, r2
 800249e:	fb02 e415 	mls	r4, r2, r5, lr
 80024a2:	b2e3      	uxtb	r3, r4
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 80024a4:	2c09      	cmp	r4, #9
 80024a6:	f103 0437 	add.w	r4, r3, #55	@ 0x37
 80024aa:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 80024ae:	bf8c      	ite	hi
 80024b0:	f80c 4d01 	strbhi.w	r4, [ip, #-1]!
 80024b4:	f80c 3d01 	strbls.w	r3, [ip, #-1]!
    num /= radix;
 80024b8:	46ae      	mov	lr, r5
  }while((precision && --precision) || num);
 80024ba:	428a      	cmp	r2, r1
    uint8_t c = num % radix;
 80024bc:	4671      	mov	r1, lr
  }while((precision && --precision) || num);
 80024be:	d9ec      	bls.n	800249a <long_to_string_with_divisor+0x52>
  // copy string at begin
  int i = (int)(b - q);
 80024c0:	1e43      	subs	r3, r0, #1
 80024c2:	eba6 010c 	sub.w	r1, r6, ip
  do
    *p++ = *q++;
 80024c6:	f81c 2b01 	ldrb.w	r2, [ip], #1
 80024ca:	f803 2f01 	strb.w	r2, [r3, #1]!
  while (--i);
 80024ce:	4566      	cmp	r6, ip
 80024d0:	d1f9      	bne.n	80024c6 <long_to_string_with_divisor+0x7e>
  return p;
}
 80024d2:	4408      	add	r0, r1
 80024d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80024d6:	bf00      	nop

080024d8 <ftoa>:
}

#if CHPRINTF_USE_FLOAT
static char *ftoa(char *p, float num, int precision) {
  // Check precision limit
  if (precision > FLOAT_PRECISION)
 80024d8:	2909      	cmp	r1, #9
static char *ftoa(char *p, float num, int precision) {
 80024da:	b570      	push	{r4, r5, r6, lr}
    precision = FLOAT_PRECISION;
  uint32_t multi = pow10[precision];
  uint32_t l = num;
 80024dc:	eefc 7ac0 	vcvt.u32.f32	s15, s0
  if (precision > FLOAT_PRECISION)
 80024e0:	460e      	mov	r6, r1
  uint32_t multi = pow10[precision];
 80024e2:	4b1b      	ldr	r3, [pc, #108]	@ (8002550 <ftoa+0x78>)
  if (precision > FLOAT_PRECISION)
 80024e4:	bfa8      	it	ge
 80024e6:	2609      	movge	r6, #9
  // Round value
  uint32_t k = ((num-l)*multi+0.5);
 80024e8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  uint32_t multi = pow10[precision];
 80024ec:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
  uint32_t k = ((num-l)*multi+0.5);
 80024f0:	ee30 0a47 	vsub.f32	s0, s0, s14
 80024f4:	ee07 3a10 	vmov	s14, r3
 80024f8:	eef8 6a47 	vcvt.f32.u32	s13, s14
 80024fc:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 8002500:	eea0 7a26 	vfma.f32	s14, s0, s13
static char *ftoa(char *p, float num, int precision) {
 8002504:	460d      	mov	r5, r1
  uint32_t k = ((num-l)*multi+0.5);
 8002506:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800250a:	ee17 4a10 	vmov	r4, s14
  // Fix rounding error if get
  if (k>=multi){k-=multi;l++;}
 800250e:	42a3      	cmp	r3, r4
 8002510:	d805      	bhi.n	800251e <ftoa+0x46>
 8002512:	1ae4      	subs	r4, r4, r3
 8002514:	ee17 3a90 	vmov	r3, s15
 8002518:	3301      	adds	r3, #1
 800251a:	ee07 3a90 	vmov	s15, r3
  p = long_to_string_with_divisor(p, l, 10, 0);
 800251e:	ee17 1a90 	vmov	r1, s15
 8002522:	2300      	movs	r3, #0
 8002524:	220a      	movs	r2, #10
 8002526:	f7ff ff8f 	bl	8002448 <long_to_string_with_divisor>
  if (precision) {
 800252a:	b17d      	cbz	r5, 800254c <ftoa+0x74>
    *p++ = DIGIT_SEPARATOR;
 800252c:	4a09      	ldr	r2, [pc, #36]	@ (8002554 <ftoa+0x7c>)
 800252e:	8a92      	ldrh	r2, [r2, #20]
 8002530:	f012 0f40 	tst.w	r2, #64	@ 0x40
 8002534:	bf0c      	ite	eq
 8002536:	222e      	moveq	r2, #46	@ 0x2e
 8002538:	222c      	movne	r2, #44	@ 0x2c
 800253a:	f800 2b01 	strb.w	r2, [r0], #1
    p=long_to_string_with_divisor(p, k, 10, precision);
 800253e:	4633      	mov	r3, r6
 8002540:	4621      	mov	r1, r4
 8002542:	220a      	movs	r2, #10
  }
  return p;
}
 8002544:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    p=long_to_string_with_divisor(p, k, 10, precision);
 8002548:	f7ff bf7e 	b.w	8002448 <long_to_string_with_divisor>
}
 800254c:	bd70      	pop	{r4, r5, r6, pc}
 800254e:	bf00      	nop
 8002550:	080128d0 	.word	0x080128d0
 8002554:	20000318 	.word	0x20000318

08002558 <put>:
  uint16_t size;
} printStream;

static msg_t put(void *ip, uint8_t b) {
  printStream *ps = ip;
  if (ps->size > 1){
 8002558:	8903      	ldrh	r3, [r0, #8]
 800255a:	2b01      	cmp	r3, #1
 800255c:	d906      	bls.n	800256c <put+0x14>
   *(ps->buffer++) = b;
 800255e:	6843      	ldr	r3, [r0, #4]
 8002560:	1c5a      	adds	r2, r3, #1
 8002562:	6042      	str	r2, [r0, #4]
 8002564:	7019      	strb	r1, [r3, #0]
   ps->size--;
 8002566:	8903      	ldrh	r3, [r0, #8]
 8002568:	3b01      	subs	r3, #1
 800256a:	8103      	strh	r3, [r0, #8]
  }
  return MSG_OK;
}
 800256c:	2000      	movs	r0, #0
 800256e:	4770      	bx	lr

08002570 <chvprintf>:
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8002570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002574:	ed2d 8b02 	vpush	{d8}
    c = *fmt++;
 8002578:	460c      	mov	r4, r1
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800257a:	b08b      	sub	sp, #44	@ 0x2c
    c = *fmt++;
 800257c:	f814 1b01 	ldrb.w	r1, [r4], #1
    if (c == 0)
 8002580:	2900      	cmp	r1, #0
 8002582:	f000 829c 	beq.w	8002abe <chvprintf+0x54e>
 8002586:	4691      	mov	r9, r2
  int n = 0;
 8002588:	2300      	movs	r3, #0
  char *p, *s, c, filler=' ';
 800258a:	2220      	movs	r2, #32
 800258c:	4606      	mov	r6, r0
 800258e:	4693      	mov	fp, r2
 8002590:	469a      	mov	sl, r3
 8002592:	e00a      	b.n	80025aa <chvprintf+0x3a>
      streamPut(chp, (uint8_t)c);
 8002594:	6833      	ldr	r3, [r6, #0]
 8002596:	4630      	mov	r0, r6
 8002598:	689b      	ldr	r3, [r3, #8]
 800259a:	4798      	blx	r3
      n++;
 800259c:	f10a 0a01 	add.w	sl, sl, #1
    c = *fmt++;
 80025a0:	f814 1b01 	ldrb.w	r1, [r4], #1
    if (c == 0)
 80025a4:	2900      	cmp	r1, #0
 80025a6:	f000 8089 	beq.w	80026bc <chvprintf+0x14c>
    if (c != '%') {
 80025aa:	2925      	cmp	r1, #37	@ 0x25
 80025ac:	d1f2      	bne.n	8002594 <chvprintf+0x24>
 80025ae:	4623      	mov	r3, r4
    state = 0;
 80025b0:	f04f 0800 	mov.w	r8, #0
 80025b4:	461c      	mov	r4, r3
      if (*fmt == '-')
 80025b6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80025ba:	2a30      	cmp	r2, #48	@ 0x30
 80025bc:	d86b      	bhi.n	8002696 <chvprintf+0x126>
 80025be:	2a1f      	cmp	r2, #31
 80025c0:	d90d      	bls.n	80025de <chvprintf+0x6e>
 80025c2:	3a20      	subs	r2, #32
 80025c4:	2a10      	cmp	r2, #16
 80025c6:	d80a      	bhi.n	80025de <chvprintf+0x6e>
 80025c8:	e8df f002 	tbb	[pc, r2]
 80025cc:	09090972 	.word	0x09090972
 80025d0:	09090909 	.word	0x09090909
 80025d4:	6f090909 	.word	0x6f090909
 80025d8:	09096c09 	.word	0x09096c09
 80025dc:	5e          	.byte	0x5e
 80025dd:	00          	.byte	0x00
 80025de:	2500      	movs	r5, #0
 80025e0:	e005      	b.n	80025ee <chvprintf+0x7e>
        c = va_arg(ap, int);
 80025e2:	f851 2b04 	ldr.w	r2, [r1], #4
 80025e6:	b2d2      	uxtb	r2, r2
 80025e8:	4689      	mov	r9, r1
      width = width * 10 + c;
 80025ea:	eb02 0540 	add.w	r5, r2, r0, lsl #1
      c = *fmt++;
 80025ee:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c >= '0' && c <= '9')
 80025f2:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80025f6:	b2d2      	uxtb	r2, r2
 80025f8:	2a09      	cmp	r2, #9
        c = va_arg(ap, int);
 80025fa:	4649      	mov	r1, r9
      width = width * 10 + c;
 80025fc:	eb05 0085 	add.w	r0, r5, r5, lsl #2
      if (c >= '0' && c <= '9')
 8002600:	d9f3      	bls.n	80025ea <chvprintf+0x7a>
      else if (c == '*')
 8002602:	2b2a      	cmp	r3, #42	@ 0x2a
 8002604:	d0ed      	beq.n	80025e2 <chvprintf+0x72>
    if (c == '.') {
 8002606:	2b2e      	cmp	r3, #46	@ 0x2e
 8002608:	f000 8172 	beq.w	80028f0 <chvprintf+0x380>
      state|=DEFAULT_PRESCISION;
 800260c:	f048 0840 	orr.w	r8, r8, #64	@ 0x40
    precision = 0;
 8002610:	2700      	movs	r7, #0
    switch (c) {
 8002612:	f1a3 0244 	sub.w	r2, r3, #68	@ 0x44
 8002616:	2a34      	cmp	r2, #52	@ 0x34
 8002618:	d857      	bhi.n	80026ca <chvprintf+0x15a>
 800261a:	e8df f012 	tbh	[pc, r2, lsl #1]
 800261e:	0092      	.short	0x0092
 8002620:	00a10056 	.word	0x00a10056
 8002624:	00560056 	.word	0x00560056
 8002628:	00560092 	.word	0x00560092
 800262c:	00560056 	.word	0x00560056
 8002630:	00560056 	.word	0x00560056
 8002634:	00560187 	.word	0x00560187
 8002638:	00560056 	.word	0x00560056
 800263c:	00560056 	.word	0x00560056
 8002640:	005600c1 	.word	0x005600c1
 8002644:	01850056 	.word	0x01850056
 8002648:	00560056 	.word	0x00560056
 800264c:	00560056 	.word	0x00560056
 8002650:	00560056 	.word	0x00560056
 8002654:	00560056 	.word	0x00560056
 8002658:	00560056 	.word	0x00560056
 800265c:	009200d8 	.word	0x009200d8
 8002660:	00a10056 	.word	0x00a10056
 8002664:	00560056 	.word	0x00560056
 8002668:	00560092 	.word	0x00560092
 800266c:	00560056 	.word	0x00560056
 8002670:	00560056 	.word	0x00560056
 8002674:	00560187 	.word	0x00560187
 8002678:	00560124 	.word	0x00560124
 800267c:	005600e9 	.word	0x005600e9
 8002680:	005600c1 	.word	0x005600c1
 8002684:	01850056 	.word	0x01850056
        state|=PAD_ZERO;
 8002688:	461c      	mov	r4, r3
      if (*fmt == '-')
 800268a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800268e:	2a30      	cmp	r2, #48	@ 0x30
        state|=PAD_ZERO;
 8002690:	f048 0810 	orr.w	r8, r8, #16
      if (*fmt == '-')
 8002694:	d993      	bls.n	80025be <chvprintf+0x4e>
 8002696:	2a62      	cmp	r2, #98	@ 0x62
 8002698:	d00d      	beq.n	80026b6 <chvprintf+0x146>
 800269a:	2a6a      	cmp	r2, #106	@ 0x6a
 800269c:	d19f      	bne.n	80025de <chvprintf+0x6e>
        state|=COMPLEX;
 800269e:	f048 0880 	orr.w	r8, r8, #128	@ 0x80
 80026a2:	e787      	b.n	80025b4 <chvprintf+0x44>
        state|=LEFT_ALIGN;
 80026a4:	f048 0802 	orr.w	r8, r8, #2
 80026a8:	e784      	b.n	80025b4 <chvprintf+0x44>
        state|=POSITIVE;
 80026aa:	f048 0804 	orr.w	r8, r8, #4
 80026ae:	e781      	b.n	80025b4 <chvprintf+0x44>
        state|=PLUS_SPACE;
 80026b0:	f048 0820 	orr.w	r8, r8, #32
 80026b4:	e77e      	b.n	80025b4 <chvprintf+0x44>
        state|=SHORT_FLOAT;
 80026b6:	f448 7880 	orr.w	r8, r8, #256	@ 0x100
      if (*fmt == '-')
 80026ba:	e77b      	b.n	80025b4 <chvprintf+0x44>
 80026bc:	4653      	mov	r3, sl
}
 80026be:	4618      	mov	r0, r3
 80026c0:	b00b      	add	sp, #44	@ 0x2c
 80026c2:	ecbd 8b02 	vpop	{d8}
 80026c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *p++ = c;
 80026ca:	f88d 3010 	strb.w	r3, [sp, #16]
 80026ce:	f10d 0711 	add.w	r7, sp, #17
      break;
 80026d2:	2301      	movs	r3, #1
    if ((width -=(int)(p - s)) < 0)
 80026d4:	1aeb      	subs	r3, r5, r3
 80026d6:	d470      	bmi.n	80027ba <chvprintf+0x24a>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 80026d8:	f018 0f10 	tst.w	r8, #16
 80026dc:	f000 811d 	beq.w	800291a <chvprintf+0x3aa>
    if (!(state&LEFT_ALIGN)) {
 80026e0:	f018 0f02 	tst.w	r8, #2
 80026e4:	f000 81cd 	beq.w	8002a82 <chvprintf+0x512>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 80026e8:	f04f 0b30 	mov.w	fp, #48	@ 0x30
    if (!(state&LEFT_ALIGN)) {
 80026ec:	a904      	add	r1, sp, #16
    while (s < p) {
 80026ee:	42b9      	cmp	r1, r7
 80026f0:	d219      	bcs.n	8002726 <chvprintf+0x1b6>
    s = tmpbuf;
 80026f2:	9401      	str	r4, [sp, #4]
 80026f4:	460d      	mov	r5, r1
 80026f6:	4634      	mov	r4, r6
 80026f8:	4688      	mov	r8, r1
 80026fa:	461e      	mov	r6, r3
      streamPut(chp, (uint8_t)*s++);
 80026fc:	6822      	ldr	r2, [r4, #0]
 80026fe:	f815 1b01 	ldrb.w	r1, [r5], #1
 8002702:	6892      	ldr	r2, [r2, #8]
 8002704:	4620      	mov	r0, r4
 8002706:	4790      	blx	r2
    while (s < p) {
 8002708:	42bd      	cmp	r5, r7
 800270a:	d3f7      	bcc.n	80026fc <chvprintf+0x18c>
 800270c:	4633      	mov	r3, r6
 800270e:	4626      	mov	r6, r4
 8002710:	9c01      	ldr	r4, [sp, #4]
 8002712:	4641      	mov	r1, r8
 8002714:	1e7a      	subs	r2, r7, #1
 8002716:	1a52      	subs	r2, r2, r1
 8002718:	3101      	adds	r1, #1
 800271a:	428f      	cmp	r7, r1
 800271c:	bf38      	it	cc
 800271e:	2200      	movcc	r2, #0
 8002720:	f10a 0a01 	add.w	sl, sl, #1
 8002724:	4492      	add	sl, r2
    while (width) {
 8002726:	2b00      	cmp	r3, #0
 8002728:	f43f af3a 	beq.w	80025a0 <chvprintf+0x30>
 800272c:	461d      	mov	r5, r3
 800272e:	461f      	mov	r7, r3
      streamPut(chp, (uint8_t)filler);
 8002730:	6833      	ldr	r3, [r6, #0]
 8002732:	4659      	mov	r1, fp
 8002734:	689b      	ldr	r3, [r3, #8]
 8002736:	4630      	mov	r0, r6
 8002738:	4798      	blx	r3
    while (width) {
 800273a:	3d01      	subs	r5, #1
 800273c:	d1f8      	bne.n	8002730 <chvprintf+0x1c0>
 800273e:	44ba      	add	sl, r7
 8002740:	e72e      	b.n	80025a0 <chvprintf+0x30>
        value.l = va_arg(ap, int32_t);
 8002742:	f859 1b04 	ldr.w	r1, [r9], #4
      if (value.l < 0) {
 8002746:	2900      	cmp	r1, #0
 8002748:	f2c0 8134 	blt.w	80029b4 <chvprintf+0x444>
      else if (state & POSITIVE)
 800274c:	f018 0f04 	tst.w	r8, #4
 8002750:	f040 81d9 	bne.w	8002b06 <chvprintf+0x596>
      else if (state & PLUS_SPACE)
 8002754:	f018 0f20 	tst.w	r8, #32
 8002758:	f000 81ec 	beq.w	8002b34 <chvprintf+0x5c4>
 800275c:	2320      	movs	r3, #32
 800275e:	e1d3      	b.n	8002b08 <chvprintf+0x598>
      if (state & SHORT_FLOAT)
 8002760:	f418 7f80 	tst.w	r8, #256	@ 0x100
 8002764:	f040 80e4 	bne.w	8002930 <chvprintf+0x3c0>
        value.f = va_arg(ap, double);
 8002768:	f109 0907 	add.w	r9, r9, #7
 800276c:	f029 0907 	bic.w	r9, r9, #7
 8002770:	e8f9 0102 	ldrd	r0, r1, [r9], #8
 8002774:	9301      	str	r3, [sp, #4]
 8002776:	f7fd ff6b 	bl	8000650 <__aeabi_d2f>
 800277a:	ee08 0a10 	vmov	s16, r0
      if (value.f < 0) {
 800277e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8002782:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        value.f = va_arg(ap, double);
 8002786:	9b01      	ldr	r3, [sp, #4]
      if (value.f < 0) {
 8002788:	f100 80da 	bmi.w	8002940 <chvprintf+0x3d0>
      else if (state & POSITIVE)
 800278c:	f018 0f04 	tst.w	r8, #4
 8002790:	f040 81c1 	bne.w	8002b16 <chvprintf+0x5a6>
      else if (state & PLUS_SPACE)
 8002794:	f018 0f20 	tst.w	r8, #32
 8002798:	f000 81c9 	beq.w	8002b2e <chvprintf+0x5be>
 800279c:	2220      	movs	r2, #32
 800279e:	e1bb      	b.n	8002b18 <chvprintf+0x5a8>
      goto unsigned_common;
 80027a0:	220a      	movs	r2, #10
      p = long_to_string_with_divisor(p, value.u, c, 0);
 80027a2:	a804      	add	r0, sp, #16
 80027a4:	2300      	movs	r3, #0
 80027a6:	f859 1b04 	ldr.w	r1, [r9], #4
 80027aa:	9001      	str	r0, [sp, #4]
 80027ac:	f7ff fe4c 	bl	8002448 <long_to_string_with_divisor>
    if ((width -=(int)(p - s)) < 0)
 80027b0:	9b01      	ldr	r3, [sp, #4]
 80027b2:	1ac3      	subs	r3, r0, r3
 80027b4:	1aeb      	subs	r3, r5, r3
      p = long_to_string_with_divisor(p, value.u, c, 0);
 80027b6:	4607      	mov	r7, r0
    if ((width -=(int)(p - s)) < 0)
 80027b8:	d58e      	bpl.n	80026d8 <chvprintf+0x168>
    if (!(state&LEFT_ALIGN)) {
 80027ba:	f018 0302 	ands.w	r3, r8, #2
 80027be:	f000 8168 	beq.w	8002a92 <chvprintf+0x522>
 80027c2:	a904      	add	r1, sp, #16
    while (s < p) {
 80027c4:	428f      	cmp	r7, r1
 80027c6:	bf88      	it	hi
 80027c8:	2300      	movhi	r3, #0
 80027ca:	d892      	bhi.n	80026f2 <chvprintf+0x182>
 80027cc:	e6e8      	b.n	80025a0 <chvprintf+0x30>
      *p++ = va_arg(ap, int);
 80027ce:	f859 3b04 	ldr.w	r3, [r9], #4
 80027d2:	f88d 3010 	strb.w	r3, [sp, #16]
    if ((width -=(int)(p - s)) < 0)
 80027d6:	1e6b      	subs	r3, r5, #1
 80027d8:	f100 80dc 	bmi.w	8002994 <chvprintf+0x424>
    if (!(state&LEFT_ALIGN)) {
 80027dc:	f018 0f02 	tst.w	r8, #2
 80027e0:	f000 8207 	beq.w	8002bf2 <chvprintf+0x682>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 80027e4:	f04f 0b20 	mov.w	fp, #32
      *p++ = va_arg(ap, int);
 80027e8:	f10d 0711 	add.w	r7, sp, #17
    s = tmpbuf;
 80027ec:	a904      	add	r1, sp, #16
 80027ee:	e780      	b.n	80026f2 <chvprintf+0x182>
      if ((s = va_arg(ap, char *)) == 0)
 80027f0:	f859 1b04 	ldr.w	r1, [r9], #4
 80027f4:	2900      	cmp	r1, #0
 80027f6:	f000 80f5 	beq.w	80029e4 <chvprintf+0x474>
      for (p = s; *p && (--precision >= 0); p++)
 80027fa:	780b      	ldrb	r3, [r1, #0]
        precision = 32767;
 80027fc:	f018 0f40 	tst.w	r8, #64	@ 0x40
 8002800:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8002804:	bf18      	it	ne
 8002806:	4617      	movne	r7, r2
      for (p = s; *p && (--precision >= 0); p++)
 8002808:	2b00      	cmp	r3, #0
 800280a:	f000 8223 	beq.w	8002c54 <chvprintf+0x6e4>
 800280e:	1e4a      	subs	r2, r1, #1
 8002810:	443a      	add	r2, r7
        s = (char*)"(null)";
 8002812:	460f      	mov	r7, r1
 8002814:	e002      	b.n	800281c <chvprintf+0x2ac>
      for (p = s; *p && (--precision >= 0); p++)
 8002816:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 800281a:	b113      	cbz	r3, 8002822 <chvprintf+0x2b2>
 800281c:	1bd3      	subs	r3, r2, r7
 800281e:	2b00      	cmp	r3, #0
 8002820:	daf9      	bge.n	8002816 <chvprintf+0x2a6>
    if ((width -=(int)(p - s)) < 0)
 8002822:	1a7b      	subs	r3, r7, r1
 8002824:	1aeb      	subs	r3, r5, r3
 8002826:	d4cd      	bmi.n	80027c4 <chvprintf+0x254>
      state&=~PAD_ZERO;
 8002828:	f028 0810 	bic.w	r8, r8, #16
    if (!(state&LEFT_ALIGN)) {
 800282c:	f018 0f02 	tst.w	r8, #2
 8002830:	d177      	bne.n	8002922 <chvprintf+0x3b2>
    if ((width -=(int)(p - s)) < 0)
 8002832:	461d      	mov	r5, r3
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002834:	f04f 0b20 	mov.w	fp, #32
      while (width){
 8002838:	2b00      	cmp	r3, #0
 800283a:	d0c3      	beq.n	80027c4 <chvprintf+0x254>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 800283c:	9401      	str	r4, [sp, #4]
 800283e:	46a8      	mov	r8, r5
 8002840:	4634      	mov	r4, r6
 8002842:	460e      	mov	r6, r1
        streamPut(chp, (uint8_t)filler);
 8002844:	6822      	ldr	r2, [r4, #0]
 8002846:	4659      	mov	r1, fp
 8002848:	6892      	ldr	r2, [r2, #8]
 800284a:	4620      	mov	r0, r4
 800284c:	4790      	blx	r2
      while (width){
 800284e:	f1b8 0801 	subs.w	r8, r8, #1
 8002852:	d1f7      	bne.n	8002844 <chvprintf+0x2d4>
 8002854:	4631      	mov	r1, r6
    while (s < p) {
 8002856:	42b9      	cmp	r1, r7
 8002858:	4626      	mov	r6, r4
 800285a:	4643      	mov	r3, r8
 800285c:	9c01      	ldr	r4, [sp, #4]
 800285e:	44aa      	add	sl, r5
 8002860:	f4ff af47 	bcc.w	80026f2 <chvprintf+0x182>
 8002864:	e69c      	b.n	80025a0 <chvprintf+0x30>
      p=ulong_freq(p, va_arg(ap, pfreq_t), precision);
 8002866:	4649      	mov	r1, r9
 8002868:	f851 2b04 	ldr.w	r2, [r1], #4
  if (precision == 0)
 800286c:	2f00      	cmp	r7, #0
 800286e:	f000 808c 	beq.w	800298a <chvprintf+0x41a>
  if (precision == 0 || precision > MAX_FREQ_PRESCISION)
 8002872:	2f0e      	cmp	r7, #14
 8002874:	bfa8      	it	ge
 8002876:	270e      	movge	r7, #14
 8002878:	46b9      	mov	r9, r7
  uint8_t flag = FREQ_PSET;
 800287a:	f04f 0c01 	mov.w	ip, #1
    freq/= 10;
 800287e:	4baf      	ldr	r3, [pc, #700]	@ (8002b3c <chvprintf+0x5cc>)
 8002880:	fba3 3002 	umull	r3, r0, r3, r2
 8002884:	08c0      	lsrs	r0, r0, #3
    uint32_t c = freq % 10;
 8002886:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 800288a:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    *--q = c + '0';
 800288e:	3330      	adds	r3, #48	@ 0x30
 8002890:	b2db      	uxtb	r3, r3
    if (freq == 0) break;
 8002892:	2a09      	cmp	r2, #9
    *--q = c + '0';
 8002894:	f88d 301d 	strb.w	r3, [sp, #29]
    if (freq == 0) break;
 8002898:	f240 81c7 	bls.w	8002c2a <chvprintf+0x6ba>
  uint32_t s = 0;
 800289c:	2300      	movs	r3, #0
 800289e:	e9cd 4501 	strd	r4, r5, [sp, #4]
  uint32_t format = 0b100100100100100;
 80028a2:	f644 1e24 	movw	lr, #18724	@ 0x4924
    *--q = c + '0';
 80028a6:	f10d 021d 	add.w	r2, sp, #29
  char *q = p + MAX_FREQ_PRESCISION;
 80028aa:	f10d 071e 	add.w	r7, sp, #30
 80028ae:	461d      	mov	r5, r3
 80028b0:	e019      	b.n	80028e6 <chvprintf+0x376>
      *--q = ' ';
 80028b2:	f04f 0320 	mov.w	r3, #32
 80028b6:	f807 3c02 	strb.w	r3, [r7, #-2]
      s++;
 80028ba:	3501      	adds	r5, #1
      *--q = ' ';
 80028bc:	3f02      	subs	r7, #2
    freq/= 10;
 80028be:	4b9f      	ldr	r3, [pc, #636]	@ (8002b3c <chvprintf+0x5cc>)
 80028c0:	fba3 3400 	umull	r3, r4, r3, r0
 80028c4:	08e4      	lsrs	r4, r4, #3
    uint32_t c = freq % 10;
 80028c6:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 80028ca:	eba0 0343 	sub.w	r3, r0, r3, lsl #1
    *--q = c + '0';
 80028ce:	3330      	adds	r3, #48	@ 0x30
 80028d0:	b2db      	uxtb	r3, r3
    if (freq == 0) break;
 80028d2:	2809      	cmp	r0, #9
    *--q = c + '0';
 80028d4:	f807 3c01 	strb.w	r3, [r7, #-1]
    format >>= 1;
 80028d8:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
    *--q = c + '0';
 80028dc:	f107 32ff 	add.w	r2, r7, #4294967295
    if (freq == 0) break;
 80028e0:	f240 8088 	bls.w	80029f4 <chvprintf+0x484>
 80028e4:	4620      	mov	r0, r4
    if (format & 1) {
 80028e6:	f01e 0f01 	tst.w	lr, #1
 80028ea:	d1e2      	bne.n	80028b2 <chvprintf+0x342>
    *--q = c + '0';
 80028ec:	4617      	mov	r7, r2
 80028ee:	e7e6      	b.n	80028be <chvprintf+0x34e>
    precision = 0;
 80028f0:	2700      	movs	r7, #0
 80028f2:	e005      	b.n	8002900 <chvprintf+0x390>
          c = va_arg(ap, int);
 80028f4:	f851 2b04 	ldr.w	r2, [r1], #4
 80028f8:	b2d2      	uxtb	r2, r2
 80028fa:	4689      	mov	r9, r1
        precision = precision * 10 + c;
 80028fc:	eb02 0740 	add.w	r7, r2, r0, lsl #1
        c = *fmt++;
 8002900:	f814 3b01 	ldrb.w	r3, [r4], #1
        if (c >= '0' && c <= '9')
 8002904:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8002908:	b2d2      	uxtb	r2, r2
 800290a:	2a09      	cmp	r2, #9
          c = va_arg(ap, int);
 800290c:	4649      	mov	r1, r9
        precision = precision * 10 + c;
 800290e:	eb07 0087 	add.w	r0, r7, r7, lsl #2
        if (c >= '0' && c <= '9')
 8002912:	d9f3      	bls.n	80028fc <chvprintf+0x38c>
        else if (c == '*')
 8002914:	2b2a      	cmp	r3, #42	@ 0x2a
 8002916:	d0ed      	beq.n	80028f4 <chvprintf+0x384>
 8002918:	e67b      	b.n	8002612 <chvprintf+0xa2>
 800291a:	a904      	add	r1, sp, #16
    if (!(state&LEFT_ALIGN)) {
 800291c:	f018 0f02 	tst.w	r8, #2
 8002920:	d087      	beq.n	8002832 <chvprintf+0x2c2>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002922:	f04f 0b20 	mov.w	fp, #32
 8002926:	e6e2      	b.n	80026ee <chvprintf+0x17e>
    switch (c) {
 8002928:	2210      	movs	r2, #16
 800292a:	e73a      	b.n	80027a2 <chvprintf+0x232>
 800292c:	2208      	movs	r2, #8
 800292e:	e738      	b.n	80027a2 <chvprintf+0x232>
      if (value.f < 0) {
 8002930:	ecb9 8a01 	vldmia	r9!, {s16}
 8002934:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8002938:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800293c:	f57f af26 	bpl.w	800278c <chvprintf+0x21c>
        *p++ = '-';
 8002940:	222d      	movs	r2, #45	@ 0x2d
 8002942:	f88d 2010 	strb.w	r2, [sp, #16]
 8002946:	aa04      	add	r2, sp, #16
        state|=NEGATIVE;
 8002948:	f048 0808 	orr.w	r8, r8, #8
        value.f = -value.f;
 800294c:	eeb1 8a48 	vneg.f32	s16, s16
        *p++ = '-';
 8002950:	f10d 0011 	add.w	r0, sp, #17
 8002954:	9201      	str	r2, [sp, #4]
      if (state & COMPLEX)
 8002956:	f018 0f80 	tst.w	r8, #128	@ 0x80
        *p++ = 'j';
 800295a:	bf1c      	itt	ne
 800295c:	226a      	movne	r2, #106	@ 0x6a
 800295e:	f800 2b01 	strbne.w	r2, [r0], #1
 8002962:	e9cd 0302 	strd	r0, r3, [sp, #8]
      if (value.f == infinityf()){
 8002966:	f00e fdc5 	bl	80114f4 <infinityf>
 800296a:	eeb4 0a48 	vcmp.f32	s0, s16
 800296e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002972:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
 8002976:	f040 80a9 	bne.w	8002acc <chvprintf+0x55c>
        *p++ = S_INFINITY[0]; *p++ = ' ';
 800297a:	4607      	mov	r7, r0
 800297c:	f242 0319 	movw	r3, #8217	@ 0x2019
 8002980:	f827 3b02 	strh.w	r3, [r7], #2
    if ((width -=(int)(p - s)) < 0)
 8002984:	9b01      	ldr	r3, [sp, #4]
 8002986:	1afb      	subs	r3, r7, r3
        break;
 8002988:	e6a4      	b.n	80026d4 <chvprintf+0x164>
    flag|=FREQ_PREFIX_SPACE;
 800298a:	f04f 0c03 	mov.w	ip, #3
    precision = MAX_FREQ_PRESCISION;
 800298e:	f04f 090e 	mov.w	r9, #14
 8002992:	e774      	b.n	800287e <chvprintf+0x30e>
    if (!(state&LEFT_ALIGN)) {
 8002994:	f018 0302 	ands.w	r3, r8, #2
 8002998:	f000 8143 	beq.w	8002c22 <chvprintf+0x6b2>
      streamPut(chp, (uint8_t)*s++);
 800299c:	6833      	ldr	r3, [r6, #0]
 800299e:	f89d 1010 	ldrb.w	r1, [sp, #16]
 80029a2:	689b      	ldr	r3, [r3, #8]
 80029a4:	4630      	mov	r0, r6
 80029a6:	ad04      	add	r5, sp, #16
 80029a8:	4798      	blx	r3
      *p++ = va_arg(ap, int);
 80029aa:	f10d 0711 	add.w	r7, sp, #17
    s = tmpbuf;
 80029ae:	4629      	mov	r1, r5
      streamPut(chp, (uint8_t)*s++);
 80029b0:	2300      	movs	r3, #0
 80029b2:	e6af      	b.n	8002714 <chvprintf+0x1a4>
        *p++ = '-';
 80029b4:	232d      	movs	r3, #45	@ 0x2d
 80029b6:	f88d 3010 	strb.w	r3, [sp, #16]
 80029ba:	ab04      	add	r3, sp, #16
        state|=NEGATIVE;
 80029bc:	f048 0808 	orr.w	r8, r8, #8
        value.l = -value.l;
 80029c0:	4249      	negs	r1, r1
        *p++ = '-';
 80029c2:	f10d 0011 	add.w	r0, sp, #17
 80029c6:	9301      	str	r3, [sp, #4]
      if (state & COMPLEX)
 80029c8:	f018 0f80 	tst.w	r8, #128	@ 0x80
        *p++ = 'j';
 80029cc:	bf1c      	itt	ne
 80029ce:	236a      	movne	r3, #106	@ 0x6a
 80029d0:	f800 3b01 	strbne.w	r3, [r0], #1
      p = long_to_string_with_divisor(p, value.l, 10, 0);
 80029d4:	220a      	movs	r2, #10
 80029d6:	2300      	movs	r3, #0
 80029d8:	f7ff fd36 	bl	8002448 <long_to_string_with_divisor>
    if ((width -=(int)(p - s)) < 0)
 80029dc:	9b01      	ldr	r3, [sp, #4]
      p = long_to_string_with_divisor(p, value.l, 10, 0);
 80029de:	4607      	mov	r7, r0
    if ((width -=(int)(p - s)) < 0)
 80029e0:	1ac3      	subs	r3, r0, r3
      break;
 80029e2:	e677      	b.n	80026d4 <chvprintf+0x164>
      if (state&DEFAULT_PRESCISION)
 80029e4:	f018 0f40 	tst.w	r8, #64	@ 0x40
        s = (char*)"(null)";
 80029e8:	4955      	ldr	r1, [pc, #340]	@ (8002b40 <chvprintf+0x5d0>)
      if (state&DEFAULT_PRESCISION)
 80029ea:	f43f af10 	beq.w	800280e <chvprintf+0x29e>
        precision = 32767;
 80029ee:	f647 77ff 	movw	r7, #32767	@ 0x7fff
 80029f2:	e70c      	b.n	800280e <chvprintf+0x29e>
  int i = (b - q);
 80029f4:	f10d 001e 	add.w	r0, sp, #30
 80029f8:	462f      	mov	r7, r5
 80029fa:	eba0 0e02 	sub.w	lr, r0, r2
  s = bigPrefix[s];
 80029fe:	4851      	ldr	r0, [pc, #324]	@ (8002b44 <chvprintf+0x5d4>)
  int i = (b - q);
 8002a00:	9c01      	ldr	r4, [sp, #4]
 8002a02:	9d02      	ldr	r5, [sp, #8]
  s = bigPrefix[s];
 8002a04:	5dc0      	ldrb	r0, [r0, r7]
    *--q = c + '0';
 8002a06:	af04      	add	r7, sp, #16
 8002a08:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8002a0c:	9701      	str	r7, [sp, #4]
  } while (--i);
 8002a0e:	44be      	add	lr, r7
 8002a10:	e006      	b.n	8002a20 <chvprintf+0x4b0>
    if (!(flag & FREQ_PSET) && precision-- < 0) break;
 8002a12:	462a      	mov	r2, r5
 8002a14:	b17c      	cbz	r4, 8002a36 <chvprintf+0x4c6>
    *p++ = c;
 8002a16:	f807 3b01 	strb.w	r3, [r7], #1
  } while (--i);
 8002a1a:	4577      	cmp	r7, lr
 8002a1c:	d015      	beq.n	8002a4a <chvprintf+0x4da>
    char c = *q++;
 8002a1e:	7813      	ldrb	r3, [r2, #0]
    if (c == ' ') {
 8002a20:	2b20      	cmp	r3, #32
    char c = *q++;
 8002a22:	f102 0501 	add.w	r5, r2, #1
    if (c == ' ') {
 8002a26:	f00c 0401 	and.w	r4, ip, #1
 8002a2a:	d1f2      	bne.n	8002a12 <chvprintf+0x4a2>
      if (flag & FREQ_PSET) {
 8002a2c:	b1fc      	cbz	r4, 8002a6e <chvprintf+0x4fe>
        flag &= ~FREQ_PSET;
 8002a2e:	f00c 0cfe 	and.w	ip, ip, #254	@ 0xfe
    char c = *q++;
 8002a32:	462a      	mov	r2, r5
        c = '.';
 8002a34:	232e      	movs	r3, #46	@ 0x2e
    if (!(flag & FREQ_PSET) && precision-- < 0) break;
 8002a36:	f1b9 0f00 	cmp.w	r9, #0
 8002a3a:	f109 34ff 	add.w	r4, r9, #4294967295
 8002a3e:	db5c      	blt.n	8002afa <chvprintf+0x58a>
    *p++ = c;
 8002a40:	f807 3b01 	strb.w	r3, [r7], #1
  } while (--i);
 8002a44:	4577      	cmp	r7, lr
    if (!(flag & FREQ_PSET) && precision-- < 0) break;
 8002a46:	46a1      	mov	r9, r4
  } while (--i);
 8002a48:	d1e9      	bne.n	8002a1e <chvprintf+0x4ae>
 8002a4a:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8002a4e:	f00c 0c02 	and.w	ip, ip, #2
  if ((flag & FREQ_PREFIX_SPACE) && s != ' ')
 8002a52:	f1bc 0f00 	cmp.w	ip, #0
 8002a56:	d004      	beq.n	8002a62 <chvprintf+0x4f2>
 8002a58:	2820      	cmp	r0, #32
    *p++ = ' ';
 8002a5a:	bf1c      	itt	ne
 8002a5c:	2320      	movne	r3, #32
 8002a5e:	f807 3b01 	strbne.w	r3, [r7], #1
  *p++ = s;
 8002a62:	f807 0b01 	strb.w	r0, [r7], #1
    if ((width -=(int)(p - s)) < 0)
 8002a66:	9b01      	ldr	r3, [sp, #4]
      p=ulong_freq(p, va_arg(ap, pfreq_t), precision);
 8002a68:	4689      	mov	r9, r1
    if ((width -=(int)(p - s)) < 0)
 8002a6a:	1afb      	subs	r3, r7, r3
      break;
 8002a6c:	e632      	b.n	80026d4 <chvprintf+0x164>
      } else if (!(flag & FREQ_PREFIX_SPACE))
 8002a6e:	f1bc 0f00 	cmp.w	ip, #0
 8002a72:	d102      	bne.n	8002a7a <chvprintf+0x50a>
        c = *q++;
 8002a74:	7853      	ldrb	r3, [r2, #1]
 8002a76:	3202      	adds	r2, #2
 8002a78:	e7dd      	b.n	8002a36 <chvprintf+0x4c6>
    char c = *q++;
 8002a7a:	462a      	mov	r2, r5
 8002a7c:	f04f 0c02 	mov.w	ip, #2
 8002a80:	e7d9      	b.n	8002a36 <chvprintf+0x4c6>
      if ((state&(NEGATIVE|POSITIVE|PLUS_SPACE)) && (state&PAD_ZERO)) {
 8002a82:	f018 0f2c 	tst.w	r8, #44	@ 0x2c
 8002a86:	d13b      	bne.n	8002b00 <chvprintf+0x590>
    if ((width -=(int)(p - s)) < 0)
 8002a88:	461d      	mov	r5, r3
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002a8a:	f04f 0b30 	mov.w	fp, #48	@ 0x30
      if ((state&(NEGATIVE|POSITIVE|PLUS_SPACE)) && (state&PAD_ZERO)) {
 8002a8e:	a904      	add	r1, sp, #16
 8002a90:	e6d2      	b.n	8002838 <chvprintf+0x2c8>
 8002a92:	f018 0f2c 	tst.w	r8, #44	@ 0x2c
 8002a96:	f43f ae94 	beq.w	80027c2 <chvprintf+0x252>
 8002a9a:	f018 0f10 	tst.w	r8, #16
 8002a9e:	f43f ae90 	beq.w	80027c2 <chvprintf+0x252>
        streamPut(chp, (uint8_t)*s++);
 8002aa2:	6832      	ldr	r2, [r6, #0]
 8002aa4:	f89d 1010 	ldrb.w	r1, [sp, #16]
 8002aa8:	6892      	ldr	r2, [r2, #8]
 8002aaa:	9301      	str	r3, [sp, #4]
 8002aac:	4630      	mov	r0, r6
 8002aae:	4790      	blx	r2
        n++;
 8002ab0:	9b01      	ldr	r3, [sp, #4]
 8002ab2:	f10a 0a01 	add.w	sl, sl, #1
 8002ab6:	461d      	mov	r5, r3
        streamPut(chp, (uint8_t)*s++);
 8002ab8:	f10d 0111 	add.w	r1, sp, #17
 8002abc:	e6bc      	b.n	8002838 <chvprintf+0x2c8>
  int n = 0;
 8002abe:	460b      	mov	r3, r1
}
 8002ac0:	4618      	mov	r0, r3
 8002ac2:	b00b      	add	sp, #44	@ 0x2c
 8002ac4:	ecbd 8b02 	vpop	{d8}
 8002ac8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (state&DEFAULT_PRESCISION)
 8002acc:	f018 0f40 	tst.w	r8, #64	@ 0x40
 8002ad0:	d029      	beq.n	8002b26 <chvprintf+0x5b6>
        precision = (c=='F') ? FLOAT_PREFIX_PRECISION : FLOAT_PRECISION;
 8002ad2:	2b46      	cmp	r3, #70	@ 0x46
 8002ad4:	d03e      	beq.n	8002b54 <chvprintf+0x5e4>
 8002ad6:	2709      	movs	r7, #9
      p = (c=='F') ? ftoaS(p, value.f, precision) : ftoa(p, value.f, precision);
 8002ad8:	4639      	mov	r1, r7
 8002ada:	eeb0 0a48 	vmov.f32	s0, s16
 8002ade:	f7ff fcfb 	bl	80024d8 <ftoa>
 8002ae2:	4607      	mov	r7, r0
      if (state & PAD_ZERO) { // remove zeros at end
 8002ae4:	f018 0f10 	tst.w	r8, #16
 8002ae8:	f040 808a 	bne.w	8002c00 <chvprintf+0x690>
    if ((width -=(int)(p - s)) < 0)
 8002aec:	9901      	ldr	r1, [sp, #4]
 8002aee:	1a7b      	subs	r3, r7, r1
 8002af0:	1aeb      	subs	r3, r5, r3
 8002af2:	f57f af13 	bpl.w	800291c <chvprintf+0x3ac>
    s = tmpbuf;
 8002af6:	9901      	ldr	r1, [sp, #4]
 8002af8:	e664      	b.n	80027c4 <chvprintf+0x254>
 8002afa:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8002afe:	e7a8      	b.n	8002a52 <chvprintf+0x4e2>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002b00:	f04f 0b30 	mov.w	fp, #48	@ 0x30
 8002b04:	e7cd      	b.n	8002aa2 <chvprintf+0x532>
 8002b06:	232b      	movs	r3, #43	@ 0x2b
        *p++ = ' ';
 8002b08:	f88d 3010 	strb.w	r3, [sp, #16]
 8002b0c:	ab04      	add	r3, sp, #16
        *p++ = '+';
 8002b0e:	f10d 0011 	add.w	r0, sp, #17
 8002b12:	9301      	str	r3, [sp, #4]
 8002b14:	e758      	b.n	80029c8 <chvprintf+0x458>
 8002b16:	222b      	movs	r2, #43	@ 0x2b
        *p++ = ' ';
 8002b18:	f88d 2010 	strb.w	r2, [sp, #16]
 8002b1c:	aa04      	add	r2, sp, #16
        *p++ = '+';
 8002b1e:	f10d 0011 	add.w	r0, sp, #17
 8002b22:	9201      	str	r2, [sp, #4]
 8002b24:	e717      	b.n	8002956 <chvprintf+0x3e6>
      p = (c=='F') ? ftoaS(p, value.f, precision) : ftoa(p, value.f, precision);
 8002b26:	2b46      	cmp	r3, #70	@ 0x46
 8002b28:	d1d6      	bne.n	8002ad8 <chvprintf+0x568>
 8002b2a:	b23b      	sxth	r3, r7
 8002b2c:	e014      	b.n	8002b58 <chvprintf+0x5e8>
    p = tmpbuf;
 8002b2e:	a804      	add	r0, sp, #16
 8002b30:	9001      	str	r0, [sp, #4]
 8002b32:	e710      	b.n	8002956 <chvprintf+0x3e6>
 8002b34:	a804      	add	r0, sp, #16
 8002b36:	9001      	str	r0, [sp, #4]
 8002b38:	e746      	b.n	80029c8 <chvprintf+0x458>
 8002b3a:	bf00      	nop
 8002b3c:	cccccccd 	.word	0xcccccccd
 8002b40:	08011978 	.word	0x08011978
 8002b44:	080128c4 	.word	0x080128c4
 8002b48:	447a0000 	.word	0x447a0000
 8002b4c:	3a83126f 	.word	0x3a83126f
 8002b50:	497423ff 	.word	0x497423ff
 8002b54:	2703      	movs	r7, #3
        precision = (c=='F') ? FLOAT_PREFIX_PRECISION : FLOAT_PRECISION;
 8002b56:	463b      	mov	r3, r7
  if (num >= 1000.0f){
 8002b58:	ed1f 7a05 	vldr	s14, [pc, #-20]	@ 8002b48 <chvprintf+0x5d8>
 8002b5c:	eeb4 8ac7 	vcmpe.f32	s16, s14
 8002b60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002b64:	db67      	blt.n	8002c36 <chvprintf+0x6c6>
    for (ptr = bigPrefix+1; *ptr && num >= 1000.0f; num/=1000.0f, ptr++)
 8002b66:	ed5f 6a07 	vldr	s13, [pc, #-28]	@ 8002b4c <chvprintf+0x5dc>
 8002b6a:	ed1f 7a07 	vldr	s14, [pc, #-28]	@ 8002b50 <chvprintf+0x5e0>
 8002b6e:	4a50      	ldr	r2, [pc, #320]	@ (8002cb0 <chvprintf+0x740>)
 8002b70:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8002b74:	eef0 7a48 	vmov.f32	s15, s16
 8002b78:	ee28 8a26 	vmul.f32	s16, s16, s13
 8002b7c:	b121      	cbz	r1, 8002b88 <chvprintf+0x618>
 8002b7e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002b82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002b86:	daf3      	bge.n	8002b70 <chvprintf+0x600>
    prefix = ptr[-1];
 8002b88:	f812 2c01 	ldrb.w	r2, [r2, #-1]
  if (prefix)
 8002b8c:	b10a      	cbz	r2, 8002b92 <chvprintf+0x622>
    precision--;
 8002b8e:	3f01      	subs	r7, #1
 8002b90:	b23b      	sxth	r3, r7
  uint32_t l = num;
 8002b92:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 8002b96:	ee17 1a90 	vmov	r1, s15
  if (l >= 100)
 8002b9a:	2963      	cmp	r1, #99	@ 0x63
 8002b9c:	d954      	bls.n	8002c48 <chvprintf+0x6d8>
    precision-=2;
 8002b9e:	3b02      	subs	r3, #2
 8002ba0:	b21b      	sxth	r3, r3
  p=ftoa(p, num, precision);
 8002ba2:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
 8002ba6:	eeb0 0a48 	vmov.f32	s0, s16
 8002baa:	9203      	str	r2, [sp, #12]
 8002bac:	9302      	str	r3, [sp, #8]
 8002bae:	f7ff fc93 	bl	80024d8 <ftoa>
  if (precision){
 8002bb2:	9b02      	ldr	r3, [sp, #8]
 8002bb4:	9a03      	ldr	r2, [sp, #12]
 8002bb6:	2b00      	cmp	r3, #0
  p=ftoa(p, num, precision);
 8002bb8:	4607      	mov	r7, r0
  if (precision){
 8002bba:	dd14      	ble.n	8002be6 <chvprintf+0x676>
    while (p[-1]=='0') p--;
 8002bbc:	f810 1c01 	ldrb.w	r1, [r0, #-1]
 8002bc0:	2930      	cmp	r1, #48	@ 0x30
 8002bc2:	d105      	bne.n	8002bd0 <chvprintf+0x660>
 8002bc4:	1e43      	subs	r3, r0, #1
 8002bc6:	461f      	mov	r7, r3
 8002bc8:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 8002bcc:	2930      	cmp	r1, #48	@ 0x30
 8002bce:	d0fa      	beq.n	8002bc6 <chvprintf+0x656>
    if (p[-1]==DIGIT_SEPARATOR) p--;
 8002bd0:	4b38      	ldr	r3, [pc, #224]	@ (8002cb4 <chvprintf+0x744>)
 8002bd2:	8a9b      	ldrh	r3, [r3, #20]
 8002bd4:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8002bd8:	bf0c      	ite	eq
 8002bda:	232e      	moveq	r3, #46	@ 0x2e
 8002bdc:	232c      	movne	r3, #44	@ 0x2c
 8002bde:	4299      	cmp	r1, r3
 8002be0:	bf08      	it	eq
 8002be2:	f107 37ff 	addeq.w	r7, r7, #4294967295
  if (prefix)
 8002be6:	2a00      	cmp	r2, #0
 8002be8:	f43f af7c 	beq.w	8002ae4 <chvprintf+0x574>
    *p++ = prefix;
 8002bec:	f807 2b01 	strb.w	r2, [r7], #1
 8002bf0:	e778      	b.n	8002ae4 <chvprintf+0x574>
    if ((width -=(int)(p - s)) < 0)
 8002bf2:	461d      	mov	r5, r3
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002bf4:	f04f 0b20 	mov.w	fp, #32
      *p++ = va_arg(ap, int);
 8002bf8:	f10d 0711 	add.w	r7, sp, #17
    s = tmpbuf;
 8002bfc:	a904      	add	r1, sp, #16
 8002bfe:	e61b      	b.n	8002838 <chvprintf+0x2c8>
        while (p[-1]=='0') p--;
 8002c00:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 8002c04:	2a30      	cmp	r2, #48	@ 0x30
        state^= PAD_ZERO;
 8002c06:	f088 0810 	eor.w	r8, r8, #16
        while (p[-1]=='0') p--;
 8002c0a:	d105      	bne.n	8002c18 <chvprintf+0x6a8>
 8002c0c:	1e7b      	subs	r3, r7, #1
 8002c0e:	461f      	mov	r7, r3
 8002c10:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8002c14:	2a30      	cmp	r2, #48	@ 0x30
 8002c16:	d0fa      	beq.n	8002c0e <chvprintf+0x69e>
        if (p[-1]=='.') p--;
 8002c18:	2a2e      	cmp	r2, #46	@ 0x2e
 8002c1a:	bf08      	it	eq
 8002c1c:	f107 37ff 	addeq.w	r7, r7, #4294967295
 8002c20:	e764      	b.n	8002aec <chvprintf+0x57c>
    if (!(state&LEFT_ALIGN)) {
 8002c22:	f10d 0711 	add.w	r7, sp, #17
 8002c26:	a904      	add	r1, sp, #16
 8002c28:	e563      	b.n	80026f2 <chvprintf+0x182>
    if (freq == 0) break;
 8002c2a:	f04f 0e01 	mov.w	lr, #1
 8002c2e:	2020      	movs	r0, #32
    *--q = c + '0';
 8002c30:	f10d 021d 	add.w	r2, sp, #29
 8002c34:	e6e7      	b.n	8002a06 <chvprintf+0x496>
  else if (num < 1.0f){
 8002c36:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8002c3a:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8002c3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c42:	d411      	bmi.n	8002c68 <chvprintf+0x6f8>
  char prefix=0;
 8002c44:	2200      	movs	r2, #0
 8002c46:	e7a4      	b.n	8002b92 <chvprintf+0x622>
  else if (l >= 10)
 8002c48:	2909      	cmp	r1, #9
    precision-=1;
 8002c4a:	bf84      	itt	hi
 8002c4c:	f103 33ff 	addhi.w	r3, r3, #4294967295
 8002c50:	b21b      	sxthhi	r3, r3
 8002c52:	e7a6      	b.n	8002ba2 <chvprintf+0x632>
    if ((width -=(int)(p - s)) < 0)
 8002c54:	2d00      	cmp	r5, #0
 8002c56:	f6ff aca3 	blt.w	80025a0 <chvprintf+0x30>
    if (!(state&LEFT_ALIGN)) {
 8002c5a:	f018 0f02 	tst.w	r8, #2
 8002c5e:	d01e      	beq.n	8002c9e <chvprintf+0x72e>
    if ((width -=(int)(p - s)) < 0)
 8002c60:	462b      	mov	r3, r5
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002c62:	f04f 0b20 	mov.w	fp, #32
 8002c66:	e55e      	b.n	8002726 <chvprintf+0x1b6>
    for (ptr = smallPrefix; *ptr && num < 1.0f; num*=1000.0f, ptr++)
 8002c68:	eddf 6a13 	vldr	s13, [pc, #76]	@ 8002cb8 <chvprintf+0x748>
 8002c6c:	4913      	ldr	r1, [pc, #76]	@ (8002cbc <chvprintf+0x74c>)
 8002c6e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8002c72:	eef0 7a48 	vmov.f32	s15, s16
 8002c76:	ee28 8a07 	vmul.f32	s16, s16, s14
 8002c7a:	b13a      	cbz	r2, 8002c8c <chvprintf+0x71c>
 8002c7c:	eef4 7ae6 	vcmpe.f32	s15, s13
 8002c80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c84:	d4f3      	bmi.n	8002c6e <chvprintf+0x6fe>
    prefix = num > 1e-3 ? ptr[-1] : 0;
 8002c86:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 8002c8a:	e77f      	b.n	8002b8c <chvprintf+0x61c>
 8002c8c:	ed9f 7a0c 	vldr	s14, [pc, #48]	@ 8002cc0 <chvprintf+0x750>
 8002c90:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002c94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c98:	f77f af7b 	ble.w	8002b92 <chvprintf+0x622>
 8002c9c:	e7f3      	b.n	8002c86 <chvprintf+0x716>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002c9e:	f04f 0b20 	mov.w	fp, #32
      while (width){
 8002ca2:	2d00      	cmp	r5, #0
 8002ca4:	f43f ac7c 	beq.w	80025a0 <chvprintf+0x30>
 8002ca8:	460f      	mov	r7, r1
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002caa:	f04f 0b20 	mov.w	fp, #32
 8002cae:	e5c5      	b.n	800283c <chvprintf+0x2cc>
 8002cb0:	080128c5 	.word	0x080128c5
 8002cb4:	20000318 	.word	0x20000318
 8002cb8:	3a83126f 	.word	0x3a83126f
 8002cbc:	080128b8 	.word	0x080128b8
 8002cc0:	358637bd 	.word	0x358637bd

08002cc4 <plot_printf>:

static const struct printStreamVMT vmt = {NULL, NULL, put, NULL};
// Simple print in buffer function
int plot_printf(char *str, int size, const char *fmt, ...) {
 8002cc4:	b40c      	push	{r2, r3}
 8002cc6:	b510      	push	{r4, lr}
  va_list ap;
  printStream ps;
  int retval;
  if (size <= 0) return 0;
 8002cc8:	1e0c      	subs	r4, r1, #0
int plot_printf(char *str, int size, const char *fmt, ...) {
 8002cca:	b084      	sub	sp, #16
  if (size <= 0) return 0;
 8002ccc:	dd15      	ble.n	8002cfa <plot_printf+0x36>
  // Init small memory stream for print
  ps.vmt    = &vmt;
 8002cce:	4b0e      	ldr	r3, [pc, #56]	@ (8002d08 <plot_printf+0x44>)
  ps.buffer = (uint8_t *)str;
  ps.size   = size;
  // Performing the print operation using the common code.
  va_start(ap, fmt);
  retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8002cd0:	9906      	ldr	r1, [sp, #24]
  ps.size   = size;
 8002cd2:	f8ad 400c 	strh.w	r4, [sp, #12]
  ps.buffer = (uint8_t *)str;
 8002cd6:	e9cd 3001 	strd	r3, r0, [sp, #4]
  va_start(ap, fmt);
 8002cda:	aa07      	add	r2, sp, #28
  retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8002cdc:	a801      	add	r0, sp, #4
  va_start(ap, fmt);
 8002cde:	9200      	str	r2, [sp, #0]
  retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8002ce0:	f7ff fc46 	bl	8002570 <chvprintf>
  va_end(ap);
  *(ps.buffer)=0;
 8002ce4:	9b02      	ldr	r3, [sp, #8]
 8002ce6:	2200      	movs	r2, #0
  if (retval > size-1) retval = size-1;
 8002ce8:	4284      	cmp	r4, r0
  *(ps.buffer)=0;
 8002cea:	701a      	strb	r2, [r3, #0]
  if (retval > size-1) retval = size-1;
 8002cec:	dc00      	bgt.n	8002cf0 <plot_printf+0x2c>
 8002cee:	1e60      	subs	r0, r4, #1
  // Return number of bytes that would have been written.
  return retval;
}
 8002cf0:	b004      	add	sp, #16
 8002cf2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8002cf6:	b002      	add	sp, #8
 8002cf8:	4770      	bx	lr
  if (size <= 0) return 0;
 8002cfa:	2000      	movs	r0, #0
}
 8002cfc:	b004      	add	sp, #16
 8002cfe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8002d02:	b002      	add	sp, #8
 8002d04:	4770      	bx	lr
 8002d06:	bf00      	nop
 8002d08:	080128a8 	.word	0x080128a8

08002d0c <mem_cpy>:
static void mem_cpy (void* dst, const void* src, UINT cnt)
{
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

	if (cnt != 0) {
 8002d0c:	3801      	subs	r0, #1
 8002d0e:	440a      	add	r2, r1
		do {
			*d++ = *s++;
 8002d10:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002d14:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 8002d18:	4291      	cmp	r1, r2
 8002d1a:	d1f9      	bne.n	8002d10 <mem_cpy+0x4>
	}
}
 8002d1c:	4770      	bx	lr
	...

08002d20 <mem_set>:

/* Fill memory block */
static void mem_set (void* dst, int val, UINT cnt)
{
	BYTE *d = (BYTE*)dst;
 8002d20:	4402      	add	r2, r0

	do {
		*d++ = (BYTE)val;
 8002d22:	f800 1b01 	strb.w	r1, [r0], #1
	} while (--cnt);
 8002d26:	4290      	cmp	r0, r2
 8002d28:	d1fb      	bne.n	8002d22 <mem_set+0x2>
}
 8002d2a:	4770      	bx	lr

08002d2c <mem_cmp>:


/* Compare memory block */
static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
{
 8002d2c:	b510      	push	{r4, lr}
 8002d2e:	4603      	mov	r3, r0
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;
 8002d30:	4402      	add	r2, r0

	do {
		r = *d++ - *s++;
 8002d32:	f813 0b01 	ldrb.w	r0, [r3], #1
 8002d36:	f811 4b01 	ldrb.w	r4, [r1], #1
	} while (--cnt && r == 0);
 8002d3a:	4293      	cmp	r3, r2
		r = *d++ - *s++;
 8002d3c:	eba0 0004 	sub.w	r0, r0, r4
	} while (--cnt && r == 0);
 8002d40:	d001      	beq.n	8002d46 <mem_cmp+0x1a>
 8002d42:	2800      	cmp	r0, #0
 8002d44:	d0f5      	beq.n	8002d32 <mem_cmp+0x6>

	return r;
}
 8002d46:	bd10      	pop	{r4, pc}

08002d48 <clst2sect>:
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002d48:	69c3      	ldr	r3, [r0, #28]
	clst -= 2;		/* Cluster number is origin from 2 */
 8002d4a:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002d4c:	3b02      	subs	r3, #2
 8002d4e:	428b      	cmp	r3, r1
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 8002d50:	bf83      	ittte	hi
 8002d52:	8943      	ldrhhi	r3, [r0, #10]
 8002d54:	6b00      	ldrhi	r0, [r0, #48]	@ 0x30
 8002d56:	fb01 0003 	mlahi	r0, r1, r3, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002d5a:	2000      	movls	r0, #0
}
 8002d5c:	4770      	bx	lr
	...

08002d60 <sum_sfn>:
/*-----------------------------------------------------------------------*/

static BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 8002d60:	4603      	mov	r3, r0
 8002d62:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
 8002d66:	2000      	movs	r0, #0
	UINT n = 11;

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8002d68:	01c2      	lsls	r2, r0, #7
 8002d6a:	ea42 0250 	orr.w	r2, r2, r0, lsr #1
 8002d6e:	f813 0b01 	ldrb.w	r0, [r3], #1
 8002d72:	fa50 f282 	uxtab	r2, r0, r2
	} while (--n);
 8002d76:	428b      	cmp	r3, r1
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8002d78:	b2d0      	uxtb	r0, r2
	} while (--n);
 8002d7a:	d1f5      	bne.n	8002d68 <sum_sfn+0x8>
	return sum;
}
 8002d7c:	4770      	bx	lr
	...

08002d80 <xdir_sum>:
/*-----------------------------------------------------------------------*/

static WORD xdir_sum (	/* Get checksum of the directoly entry block */
	const BYTE* dir		/* Directory entry block to be calculated */
)
{
 8002d80:	b510      	push	{r4, lr}
	UINT i, szblk;
	WORD sum;


	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 8002d82:	7842      	ldrb	r2, [r0, #1]
{
 8002d84:	4604      	mov	r4, r0
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 8002d86:	3201      	adds	r2, #1
	for (i = sum = 0; i < szblk; i++) {
 8002d88:	2000      	movs	r0, #0
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 8002d8a:	0152      	lsls	r2, r2, #5
	for (i = sum = 0; i < szblk; i++) {
 8002d8c:	4603      	mov	r3, r0
 8002d8e:	2b02      	cmp	r3, #2
 8002d90:	bf08      	it	eq
 8002d92:	2304      	moveq	r3, #4
		if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
			i++;
		} else {
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 8002d94:	03c1      	lsls	r1, r0, #15
 8002d96:	ea41 0150 	orr.w	r1, r1, r0, lsr #1
 8002d9a:	5ce0      	ldrb	r0, [r4, r3]
	for (i = sum = 0; i < szblk; i++) {
 8002d9c:	3301      	adds	r3, #1
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 8002d9e:	fa10 f181 	uxtah	r1, r0, r1
	for (i = sum = 0; i < szblk; i++) {
 8002da2:	429a      	cmp	r2, r3
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 8002da4:	b288      	uxth	r0, r1
	for (i = sum = 0; i < szblk; i++) {
 8002da6:	d8f2      	bhi.n	8002d8e <xdir_sum+0xe>
		}
	}
	return sum;
}
 8002da8:	bd10      	pop	{r4, pc}
	...

08002dac <get_achar>:
	chr = tchar2uni(ptr);
	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
	chr = ff_wtoupper(chr);

#else									/* ANSI/OEM input */
	chr = (BYTE)*(*ptr)++;				/* Get a byte */
 8002dac:	6803      	ldr	r3, [r0, #0]
 8002dae:	1c5a      	adds	r2, r3, #1
 8002db0:	6002      	str	r2, [r0, #0]
 8002db2:	7818      	ldrb	r0, [r3, #0]
	if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
 8002db4:	f1a0 0361 	sub.w	r3, r0, #97	@ 0x61
 8002db8:	2b19      	cmp	r3, #25
 8002dba:	d801      	bhi.n	8002dc0 <get_achar+0x14>
 8002dbc:	3820      	subs	r0, #32
#if FF_CODE_PAGE == 0
	if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
#elif FF_CODE_PAGE < 900
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 8002dbe:	4770      	bx	lr
 8002dc0:	287f      	cmp	r0, #127	@ 0x7f
 8002dc2:	d903      	bls.n	8002dcc <get_achar+0x20>
 8002dc4:	4b02      	ldr	r3, [pc, #8]	@ (8002dd0 <get_achar+0x24>)
 8002dc6:	4403      	add	r3, r0
 8002dc8:	f813 0c80 	ldrb.w	r0, [r3, #-128]
	}
#endif

#endif
	return chr;
}
 8002dcc:	4770      	bx	lr
 8002dce:	bf00      	nop
 8002dd0:	08012d38 	.word	0x08012d38

08002dd4 <pattern_match>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	UINT skip,			/* Number of pre-skip chars (number of ?s, b8:infinite (* specified)) */
	UINT recur			/* Recursion count */
)
{
 8002dd4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002dd6:	b085      	sub	sp, #20
 8002dd8:	4605      	mov	r5, r0
 8002dda:	9101      	str	r1, [sp, #4]
 8002ddc:	4614      	mov	r4, r2
 8002dde:	461e      	mov	r6, r3
	const TCHAR *pptr, *nptr;
	DWORD pchr, nchr;
	UINT sk;


	while ((skip & 0xFF) != 0) {		/* Pre-skip name chars */
 8002de0:	b2e3      	uxtb	r3, r4
 8002de2:	b13b      	cbz	r3, 8002df4 <pattern_match+0x20>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 8002de4:	a801      	add	r0, sp, #4
 8002de6:	f7ff ffe1 	bl	8002dac <get_achar>
 8002dea:	b908      	cbnz	r0, 8002df0 <pattern_match+0x1c>
 8002dec:	2000      	movs	r0, #0
 8002dee:	e042      	b.n	8002e76 <pattern_match+0xa2>
		skip--;
 8002df0:	3c01      	subs	r4, #1
 8002df2:	e7f5      	b.n	8002de0 <pattern_match+0xc>
	}
	if (*pat == 0 && skip) return 1;	/* Matched? (short circuit) */
 8002df4:	782b      	ldrb	r3, [r5, #0]
 8002df6:	b993      	cbnz	r3, 8002e1e <pattern_match+0x4a>
 8002df8:	b18c      	cbz	r4, 8002e1e <pattern_match+0x4a>
 8002dfa:	2001      	movs	r0, #1
 8002dfc:	e03b      	b.n	8002e76 <pattern_match+0xa2>
				if (recur == 0) return 0;	/* Too many wildcard terms? */
				sk = 0;
				do {	/* Analyze the wildcard term */
					if (*pptr++ == '?') sk++; else sk |= 0x100;
				} while (*pptr == '?' || *pptr == '*');
				if (pattern_match(pptr, nptr, sk, recur - 1)) return 1;	/* Test new branch (recursive call) */
 8002dfe:	9f03      	ldr	r7, [sp, #12]
 8002e00:	9002      	str	r0, [sp, #8]
 8002e02:	1e73      	subs	r3, r6, #1
 8002e04:	4639      	mov	r1, r7
 8002e06:	f7ff ffe5 	bl	8002dd4 <pattern_match>
 8002e0a:	2800      	cmp	r0, #0
 8002e0c:	d1f5      	bne.n	8002dfa <pattern_match+0x26>
				nchr = *nptr; break;	/* Branch mismatched */
 8002e0e:	7839      	ldrb	r1, [r7, #0]
			pchr = get_achar(&pptr);	/* Get a pattern char */
			nchr = get_achar(&nptr);	/* Get a name char */
			if (pchr != nchr) break;	/* Branch mismatched? */
			if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
		}
		get_achar(&nam);			/* nam++ */
 8002e10:	a801      	add	r0, sp, #4
 8002e12:	f7ff ffcb 	bl	8002dac <get_achar>
	} while (skip && nchr);		/* Retry until end of name if infinite search is specified */
 8002e16:	2c00      	cmp	r4, #0
 8002e18:	d0e8      	beq.n	8002dec <pattern_match+0x18>
 8002e1a:	2900      	cmp	r1, #0
 8002e1c:	d0e6      	beq.n	8002dec <pattern_match+0x18>
		pptr = pat; nptr = nam;			/* Top of pattern and name to match */
 8002e1e:	9b01      	ldr	r3, [sp, #4]
 8002e20:	9502      	str	r5, [sp, #8]
 8002e22:	9303      	str	r3, [sp, #12]
			if (*pptr == '?' || *pptr == '*') {	/* Wildcard term? */
 8002e24:	9802      	ldr	r0, [sp, #8]
 8002e26:	7802      	ldrb	r2, [r0, #0]
 8002e28:	2a3f      	cmp	r2, #63	@ 0x3f
 8002e2a:	d001      	beq.n	8002e30 <pattern_match+0x5c>
 8002e2c:	2a2a      	cmp	r2, #42	@ 0x2a
 8002e2e:	d115      	bne.n	8002e5c <pattern_match+0x88>
				if (recur == 0) return 0;	/* Too many wildcard terms? */
 8002e30:	2e00      	cmp	r6, #0
 8002e32:	d0db      	beq.n	8002dec <pattern_match+0x18>
 8002e34:	3001      	adds	r0, #1
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8002e36:	2a3f      	cmp	r2, #63	@ 0x3f
 8002e38:	4603      	mov	r3, r0
 8002e3a:	f04f 0200 	mov.w	r2, #0
 8002e3e:	d104      	bne.n	8002e4a <pattern_match+0x76>
 8002e40:	3201      	adds	r2, #1
 8002e42:	e004      	b.n	8002e4e <pattern_match+0x7a>
				} while (*pptr == '?' || *pptr == '*');
 8002e44:	292a      	cmp	r1, #42	@ 0x2a
 8002e46:	d1da      	bne.n	8002dfe <pattern_match+0x2a>
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8002e48:	4618      	mov	r0, r3
 8002e4a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
				} while (*pptr == '?' || *pptr == '*');
 8002e4e:	7801      	ldrb	r1, [r0, #0]
 8002e50:	293f      	cmp	r1, #63	@ 0x3f
 8002e52:	f103 0301 	add.w	r3, r3, #1
 8002e56:	d1f5      	bne.n	8002e44 <pattern_match+0x70>
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8002e58:	4618      	mov	r0, r3
 8002e5a:	e7f1      	b.n	8002e40 <pattern_match+0x6c>
			pchr = get_achar(&pptr);	/* Get a pattern char */
 8002e5c:	a802      	add	r0, sp, #8
 8002e5e:	f7ff ffa5 	bl	8002dac <get_achar>
 8002e62:	4607      	mov	r7, r0
			nchr = get_achar(&nptr);	/* Get a name char */
 8002e64:	a803      	add	r0, sp, #12
 8002e66:	f7ff ffa1 	bl	8002dac <get_achar>
			if (pchr != nchr) break;	/* Branch mismatched? */
 8002e6a:	4287      	cmp	r7, r0
			nchr = get_achar(&nptr);	/* Get a name char */
 8002e6c:	4601      	mov	r1, r0
			if (pchr != nchr) break;	/* Branch mismatched? */
 8002e6e:	d1cf      	bne.n	8002e10 <pattern_match+0x3c>
			if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 8002e70:	2f00      	cmp	r7, #0
 8002e72:	d1d7      	bne.n	8002e24 <pattern_match+0x50>
 8002e74:	e7c1      	b.n	8002dfa <pattern_match+0x26>

	return 0;
}
 8002e76:	b005      	add	sp, #20
 8002e78:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08002e7c <get_ldnumber>:
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
 8002e7c:	6803      	ldr	r3, [r0, #0]
	if (!tp) return vol;	/* Invalid path name? */
 8002e7e:	b17b      	cbz	r3, 8002ea0 <get_ldnumber+0x24>
	tt = tp = *path;
 8002e80:	461a      	mov	r2, r3
	do tc = *tt++; while (!IsTerminator(tc) && tc != ':');	/* Find a colon in the path */
 8002e82:	f812 1b01 	ldrb.w	r1, [r2], #1
 8002e86:	291f      	cmp	r1, #31
 8002e88:	d908      	bls.n	8002e9c <get_ldnumber+0x20>
 8002e8a:	293a      	cmp	r1, #58	@ 0x3a
 8002e8c:	d1f9      	bne.n	8002e82 <get_ldnumber+0x6>

	if (tc == ':') {	/* DOS/Windows style volume ID? */
		i = FF_VOLUMES;
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 8002e8e:	7819      	ldrb	r1, [r3, #0]
 8002e90:	2930      	cmp	r1, #48	@ 0x30
 8002e92:	d105      	bne.n	8002ea0 <get_ldnumber+0x24>
 8002e94:	3302      	adds	r3, #2
 8002e96:	429a      	cmp	r2, r3
 8002e98:	d102      	bne.n	8002ea0 <get_ldnumber+0x24>
			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
		}
#endif
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
			vol = i;		/* Drive number */
			*path = tt;		/* Snip the drive prefix off */
 8002e9a:	6002      	str	r2, [r0, #0]
			vol = i;		/* Drive number */
 8002e9c:	2000      	movs	r0, #0
 8002e9e:	4770      	bx	lr
	if (!tp) return vol;	/* Invalid path name? */
 8002ea0:	f04f 30ff 	mov.w	r0, #4294967295
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
}
 8002ea4:	4770      	bx	lr
	...

08002ea8 <validate>:

static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
 8002ea8:	b538      	push	{r3, r4, r5, lr}
 8002eaa:	460d      	mov	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8002eac:	b910      	cbnz	r0, 8002eb4 <validate+0xc>
	FRESULT res = FR_INVALID_OBJECT;
 8002eae:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8002eb0:	2300      	movs	r3, #0
 8002eb2:	e011      	b.n	8002ed8 <validate+0x30>
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8002eb4:	6803      	ldr	r3, [r0, #0]
 8002eb6:	4604      	mov	r4, r0
 8002eb8:	2b00      	cmp	r3, #0
 8002eba:	d0f8      	beq.n	8002eae <validate+0x6>
 8002ebc:	781a      	ldrb	r2, [r3, #0]
 8002ebe:	2a00      	cmp	r2, #0
 8002ec0:	d0f5      	beq.n	8002eae <validate+0x6>
 8002ec2:	8881      	ldrh	r1, [r0, #4]
 8002ec4:	88da      	ldrh	r2, [r3, #6]
 8002ec6:	4291      	cmp	r1, r2
 8002ec8:	d1f1      	bne.n	8002eae <validate+0x6>
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8002eca:	7858      	ldrb	r0, [r3, #1]
 8002ecc:	f00d fb62 	bl	8010594 <disk_status>
 8002ed0:	f010 0001 	ands.w	r0, r0, #1
 8002ed4:	d1eb      	bne.n	8002eae <validate+0x6>
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8002ed6:	6823      	ldr	r3, [r4, #0]
 8002ed8:	602b      	str	r3, [r5, #0]
	return res;
}
 8002eda:	bd38      	pop	{r3, r4, r5, pc}

08002edc <sync_window>:
{
 8002edc:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Is the disk access window dirty? */
 8002ede:	78c3      	ldrb	r3, [r0, #3]
 8002ee0:	b1cb      	cbz	r3, 8002f16 <sync_window+0x3a>
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
 8002ee2:	f100 053c 	add.w	r5, r0, #60	@ 0x3c
 8002ee6:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 8002ee8:	4604      	mov	r4, r0
 8002eea:	2301      	movs	r3, #1
 8002eec:	7840      	ldrb	r0, [r0, #1]
 8002eee:	4629      	mov	r1, r5
 8002ef0:	f00d fb9e 	bl	8010630 <disk_write>
 8002ef4:	b988      	cbnz	r0, 8002f1a <sync_window+0x3e>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8002ef6:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8002ef8:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8002efa:	6a22      	ldr	r2, [r4, #32]
			fs->wflag = 0;	/* Clear window dirty flag */
 8002efc:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8002efe:	1acb      	subs	r3, r1, r3
 8002f00:	4293      	cmp	r3, r2
 8002f02:	d208      	bcs.n	8002f16 <sync_window+0x3a>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8002f04:	78a3      	ldrb	r3, [r4, #2]
 8002f06:	2b02      	cmp	r3, #2
 8002f08:	d105      	bne.n	8002f16 <sync_window+0x3a>
 8002f0a:	440a      	add	r2, r1
 8002f0c:	7860      	ldrb	r0, [r4, #1]
 8002f0e:	2301      	movs	r3, #1
 8002f10:	4629      	mov	r1, r5
 8002f12:	f00d fb8d 	bl	8010630 <disk_write>
	FRESULT res = FR_OK;
 8002f16:	2000      	movs	r0, #0
 8002f18:	e000      	b.n	8002f1c <sync_window+0x40>
			res = FR_DISK_ERR;
 8002f1a:	2001      	movs	r0, #1
}
 8002f1c:	bd38      	pop	{r3, r4, r5, pc}
	...

08002f20 <move_window>:
{
 8002f20:	b538      	push	{r3, r4, r5, lr}
	if (sect != fs->winsect) {	/* Window offset changed? */
 8002f22:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8002f24:	428b      	cmp	r3, r1
 8002f26:	d011      	beq.n	8002f4c <move_window+0x2c>
 8002f28:	4604      	mov	r4, r0
 8002f2a:	460d      	mov	r5, r1
		res = sync_window(fs);		/* Flush the window */
 8002f2c:	f7ff ffd6 	bl	8002edc <sync_window>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8002f30:	b968      	cbnz	r0, 8002f4e <move_window+0x2e>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 8002f32:	7860      	ldrb	r0, [r4, #1]
 8002f34:	2301      	movs	r3, #1
 8002f36:	462a      	mov	r2, r5
 8002f38:	f104 013c 	add.w	r1, r4, #60	@ 0x3c
 8002f3c:	f00d fb36 	bl	80105ac <disk_read>
 8002f40:	b110      	cbz	r0, 8002f48 <move_window+0x28>
				res = FR_DISK_ERR;
 8002f42:	2001      	movs	r0, #1
				sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
 8002f44:	f04f 35ff 	mov.w	r5, #4294967295
			fs->winsect = sect;
 8002f48:	63a5      	str	r5, [r4, #56]	@ 0x38
 8002f4a:	e000      	b.n	8002f4e <move_window+0x2e>
	FRESULT res = FR_OK;
 8002f4c:	2000      	movs	r0, #0
}
 8002f4e:	bd38      	pop	{r3, r4, r5, pc}

08002f50 <check_fs>:
{
 8002f50:	b538      	push	{r3, r4, r5, lr}
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
 8002f52:	2300      	movs	r3, #0
 8002f54:	70c3      	strb	r3, [r0, #3]
 8002f56:	f04f 33ff 	mov.w	r3, #4294967295
 8002f5a:	6383      	str	r3, [r0, #56]	@ 0x38
{
 8002f5c:	4604      	mov	r4, r0
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 8002f5e:	f7ff ffdf 	bl	8002f20 <move_window>
 8002f62:	2800      	cmp	r0, #0
 8002f64:	d148      	bne.n	8002ff8 <check_fs+0xa8>
	sign = ld_word(fs->win + BS_55AA);
 8002f66:	f8b4 523a 	ldrh.w	r5, [r4, #570]	@ 0x23a
	if (sign == 0xAA55 && !memcmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is an exFAT VBR */
 8002f6a:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 8002f6e:	429d      	cmp	r5, r3
 8002f70:	d107      	bne.n	8002f82 <check_fs+0x32>
 8002f72:	4924      	ldr	r1, [pc, #144]	@ (8003004 <check_fs+0xb4>)
 8002f74:	220b      	movs	r2, #11
 8002f76:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 8002f7a:	f7ff fed7 	bl	8002d2c <mem_cmp>
 8002f7e:	2800      	cmp	r0, #0
 8002f80:	d03c      	beq.n	8002ffc <check_fs+0xac>
	b = fs->win[BS_JmpBoot];
 8002f82:	f894 303c 	ldrb.w	r3, [r4, #60]	@ 0x3c
	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near call) */
 8002f86:	2beb      	cmp	r3, #235	@ 0xeb
 8002f88:	d003      	beq.n	8002f92 <check_fs+0x42>
 8002f8a:	3318      	adds	r3, #24
 8002f8c:	b2db      	uxtb	r3, r3
 8002f8e:	2b01      	cmp	r3, #1
 8002f90:	d82b      	bhi.n	8002fea <check_fs+0x9a>
		if (sign == 0xAA55 && !memcmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) {
 8002f92:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 8002f96:	429d      	cmp	r5, r3
 8002f98:	d106      	bne.n	8002fa8 <check_fs+0x58>
 8002f9a:	491b      	ldr	r1, [pc, #108]	@ (8003008 <check_fs+0xb8>)
 8002f9c:	2208      	movs	r2, #8
 8002f9e:	f104 008e 	add.w	r0, r4, #142	@ 0x8e
 8002fa2:	f7ff fec3 	bl	8002d2c <mem_cmp>
 8002fa6:	b360      	cbz	r0, 8003002 <check_fs+0xb2>
		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS	/* Properness of sector size (512-4096 and 2^n) */
 8002fa8:	f8b4 3047 	ldrh.w	r3, [r4, #71]	@ 0x47
 8002fac:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8002fb0:	d11b      	bne.n	8002fea <check_fs+0x9a>
		b = fs->win[BPB_SecPerClus];
 8002fb2:	f894 3049 	ldrb.w	r3, [r4, #73]	@ 0x49
			&& b != 0 && (b & (b - 1)) == 0				/* Properness of cluster size (2^n) */
 8002fb6:	b1c3      	cbz	r3, 8002fea <check_fs+0x9a>
 8002fb8:	1e5a      	subs	r2, r3, #1
 8002fba:	421a      	tst	r2, r3
 8002fbc:	d115      	bne.n	8002fea <check_fs+0x9a>
			&& ld_word(fs->win + BPB_RsvdSecCnt) != 0	/* Properness of reserved sectors (MNBZ) */
 8002fbe:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
 8002fc2:	b193      	cbz	r3, 8002fea <check_fs+0x9a>
			&& (UINT)fs->win[BPB_NumFATs] - 1 <= 1		/* Properness of FATs (1 or 2) */
 8002fc4:	f894 304c 	ldrb.w	r3, [r4, #76]	@ 0x4c
 8002fc8:	3b01      	subs	r3, #1
 8002fca:	2b01      	cmp	r3, #1
 8002fcc:	d80d      	bhi.n	8002fea <check_fs+0x9a>
			&& ld_word(fs->win + BPB_RootEntCnt) != 0	/* Properness of root dir entries (MNBZ) */
 8002fce:	f8b4 304d 	ldrh.w	r3, [r4, #77]	@ 0x4d
 8002fd2:	b153      	cbz	r3, 8002fea <check_fs+0x9a>
			&& (ld_word(fs->win + BPB_TotSec16) >= 128 || ld_dword(fs->win + BPB_TotSec32) >= 0x10000)	/* Properness of volume sectors (>=128) */
 8002fd4:	f8b4 304f 	ldrh.w	r3, [r4, #79]	@ 0x4f
 8002fd8:	2b7f      	cmp	r3, #127	@ 0x7f
 8002fda:	d803      	bhi.n	8002fe4 <check_fs+0x94>
 8002fdc:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 8002fde:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8002fe2:	d302      	bcc.n	8002fea <check_fs+0x9a>
			&& ld_word(fs->win + BPB_FATSz16) != 0) {	/* Properness of FAT size (MNBZ) */
 8002fe4:	f8b4 3052 	ldrh.w	r3, [r4, #82]	@ 0x52
 8002fe8:	b953      	cbnz	r3, 8003000 <check_fs+0xb0>
	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (valid or invalid BS) */
 8002fea:	f64a 2055 	movw	r0, #43605	@ 0xaa55
 8002fee:	4285      	cmp	r5, r0
 8002ff0:	bf14      	ite	ne
 8002ff2:	2003      	movne	r0, #3
 8002ff4:	2002      	moveq	r0, #2
 8002ff6:	e004      	b.n	8003002 <check_fs+0xb2>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 8002ff8:	2004      	movs	r0, #4
 8002ffa:	e002      	b.n	8003002 <check_fs+0xb2>
	if (sign == 0xAA55 && !memcmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is an exFAT VBR */
 8002ffc:	2001      	movs	r0, #1
 8002ffe:	e000      	b.n	8003002 <check_fs+0xb2>
			return 0;	/* It is an FAT32 VBR */
 8003000:	2000      	movs	r0, #0
}
 8003002:	bd38      	pop	{r3, r4, r5, pc}
 8003004:	080128f8 	.word	0x080128f8
 8003008:	08012904 	.word	0x08012904

0800300c <change_bitmap>:
	clst -= 2;	/* The first bit corresponds to cluster #2 */
 800300c:	3902      	subs	r1, #2
{
 800300e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
 8003012:	6b46      	ldr	r6, [r0, #52]	@ 0x34
	bm = 1 << (clst % 8);					/* Bit mask in the byte */
 8003014:	f001 0407 	and.w	r4, r1, #7
 8003018:	f04f 0a01 	mov.w	sl, #1
 800301c:	fa0a f404 	lsl.w	r4, sl, r4
{
 8003020:	4605      	mov	r5, r0
 8003022:	4617      	mov	r7, r2
 8003024:	4698      	mov	r8, r3
	sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
 8003026:	eb06 3611 	add.w	r6, r6, r1, lsr #12
	i = clst / 8 % SS(fs);					/* Byte offset in the sector */
 800302a:	f3c1 09c8 	ubfx	r9, r1, #3, #9
	bm = 1 << (clst % 8);					/* Bit mask in the byte */
 800302e:	b2e4      	uxtb	r4, r4
		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
 8003030:	4631      	mov	r1, r6
 8003032:	4628      	mov	r0, r5
 8003034:	3601      	adds	r6, #1
 8003036:	f7ff ff73 	bl	8002f20 <move_window>
 800303a:	bb08      	cbnz	r0, 8003080 <change_bitmap+0x74>
				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
 800303c:	eb05 0109 	add.w	r1, r5, r9
 8003040:	f891 303c 	ldrb.w	r3, [r1, #60]	@ 0x3c
 8003044:	ea03 0204 	and.w	r2, r3, r4
 8003048:	3a00      	subs	r2, #0
 800304a:	bf18      	it	ne
 800304c:	2201      	movne	r2, #1
 800304e:	4542      	cmp	r2, r8
 8003050:	d015      	beq.n	800307e <change_bitmap+0x72>
				fs->win[i] ^= bm;	/* Flip the bit */
 8003052:	4063      	eors	r3, r4
				if (--ncl == 0) return FR_OK;	/* All bits processed? */
 8003054:	3f01      	subs	r7, #1
				fs->win[i] ^= bm;	/* Flip the bit */
 8003056:	f881 303c 	strb.w	r3, [r1, #60]	@ 0x3c
				fs->wflag = 1;
 800305a:	f885 a003 	strb.w	sl, [r5, #3]
				if (--ncl == 0) return FR_OK;	/* All bits processed? */
 800305e:	d00f      	beq.n	8003080 <change_bitmap+0x74>
			} while (bm <<= 1);		/* Next bit */
 8003060:	0064      	lsls	r4, r4, #1
 8003062:	f014 04ff 	ands.w	r4, r4, #255	@ 0xff
 8003066:	d1e9      	bne.n	800303c <change_bitmap+0x30>
		} while (++i < SS(fs));		/* Next byte */
 8003068:	f109 0301 	add.w	r3, r9, #1
 800306c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
			bm = 1;
 8003070:	f04f 0401 	mov.w	r4, #1
		i = 0;
 8003074:	f04f 0900 	mov.w	r9, #0
		} while (++i < SS(fs));		/* Next byte */
 8003078:	d2da      	bcs.n	8003030 <change_bitmap+0x24>
 800307a:	4699      	mov	r9, r3
 800307c:	e7de      	b.n	800303c <change_bitmap+0x30>
				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
 800307e:	2002      	movs	r0, #2
}
 8003080:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08003084 <put_fat>:
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8003084:	2901      	cmp	r1, #1
 8003086:	d96f      	bls.n	8003168 <put_fat+0xe4>
{
 8003088:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 800308c:	69c3      	ldr	r3, [r0, #28]
 800308e:	428b      	cmp	r3, r1
 8003090:	4605      	mov	r5, r0
 8003092:	460c      	mov	r4, r1
 8003094:	d96a      	bls.n	800316c <put_fat+0xe8>
		switch (fs->fs_type) {
 8003096:	7803      	ldrb	r3, [r0, #0]
 8003098:	2b02      	cmp	r3, #2
 800309a:	4616      	mov	r6, r2
 800309c:	d03e      	beq.n	800311c <put_fat+0x98>
 800309e:	d802      	bhi.n	80030a6 <put_fat+0x22>
 80030a0:	2b01      	cmp	r3, #1
 80030a2:	d004      	beq.n	80030ae <put_fat+0x2a>
 80030a4:	e062      	b.n	800316c <put_fat+0xe8>
 80030a6:	3b03      	subs	r3, #3
 80030a8:	2b01      	cmp	r3, #1
 80030aa:	d944      	bls.n	8003136 <put_fat+0xb2>
 80030ac:	e05e      	b.n	800316c <put_fat+0xe8>
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 80030ae:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80030b2:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80030b4:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 80030b8:	f7ff ff32 	bl	8002f20 <move_window>
			if (res != FR_OK) break;
 80030bc:	b108      	cbz	r0, 80030c2 <put_fat+0x3e>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80030be:	2001      	movs	r0, #1
 80030c0:	e055      	b.n	800316e <put_fat+0xea>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 80030c2:	f014 0401 	ands.w	r4, r4, #1
			p = fs->win + bc++ % SS(fs);
 80030c6:	f107 0801 	add.w	r8, r7, #1
 80030ca:	f105 093c 	add.w	r9, r5, #60	@ 0x3c
 80030ce:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 80030d2:	b2f3      	uxtb	r3, r6
 80030d4:	d006      	beq.n	80030e4 <put_fat+0x60>
 80030d6:	f819 2007 	ldrb.w	r2, [r9, r7]
 80030da:	f002 020f 	and.w	r2, r2, #15
 80030de:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 80030e2:	b2db      	uxtb	r3, r3
 80030e4:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80030e8:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
			fs->wflag = 1;
 80030ea:	2301      	movs	r3, #1
 80030ec:	70eb      	strb	r3, [r5, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80030ee:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 80030f2:	4628      	mov	r0, r5
 80030f4:	f7ff ff14 	bl	8002f20 <move_window>
			if (res != FR_OK) break;
 80030f8:	2800      	cmp	r0, #0
 80030fa:	d1e0      	bne.n	80030be <put_fat+0x3a>
			p = fs->win + bc % SS(fs);
 80030fc:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 8003100:	b114      	cbz	r4, 8003108 <put_fat+0x84>
 8003102:	f3c6 1607 	ubfx	r6, r6, #4, #8
 8003106:	e006      	b.n	8003116 <put_fat+0x92>
 8003108:	f819 3008 	ldrb.w	r3, [r9, r8]
 800310c:	f3c6 2603 	ubfx	r6, r6, #8, #4
 8003110:	f023 030f 	bic.w	r3, r3, #15
 8003114:	431e      	orrs	r6, r3
 8003116:	f809 6008 	strb.w	r6, [r9, r8]
			fs->wflag = 1;
 800311a:	e021      	b.n	8003160 <put_fat+0xdc>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 800311c:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 800311e:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8003122:	f7ff fefd 	bl	8002f20 <move_window>
			if (res != FR_OK) break;
 8003126:	2800      	cmp	r0, #0
 8003128:	d1c9      	bne.n	80030be <put_fat+0x3a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 800312a:	0064      	lsls	r4, r4, #1
 800312c:	f404 74ff 	and.w	r4, r4, #510	@ 0x1fe
 8003130:	442c      	add	r4, r5
 8003132:	87a6      	strh	r6, [r4, #60]	@ 0x3c
			fs->wflag = 1;
 8003134:	e014      	b.n	8003160 <put_fat+0xdc>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8003136:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8003138:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 800313c:	f7ff fef0 	bl	8002f20 <move_window>
			if (res != FR_OK) break;
 8003140:	2800      	cmp	r0, #0
 8003142:	d1bc      	bne.n	80030be <put_fat+0x3a>
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 8003144:	782b      	ldrb	r3, [r5, #0]
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8003146:	00a4      	lsls	r4, r4, #2
 8003148:	f404 74fe 	and.w	r4, r4, #508	@ 0x1fc
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 800314c:	2b04      	cmp	r3, #4
 800314e:	442c      	add	r4, r5
 8003150:	d005      	beq.n	800315e <put_fat+0xda>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8003152:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003154:	f026 4670 	bic.w	r6, r6, #4026531840	@ 0xf0000000
 8003158:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 800315c:	431e      	orrs	r6, r3
			st_dword(fs->win + clst * 4 % SS(fs), val);
 800315e:	63e6      	str	r6, [r4, #60]	@ 0x3c
			fs->wflag = 1;
 8003160:	2301      	movs	r3, #1
 8003162:	70eb      	strb	r3, [r5, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003164:	2000      	movs	r0, #0
 8003166:	e002      	b.n	800316e <put_fat+0xea>
	FRESULT res = FR_INT_ERR;
 8003168:	2002      	movs	r0, #2
}
 800316a:	4770      	bx	lr
	FRESULT res = FR_INT_ERR;
 800316c:	2002      	movs	r0, #2
}
 800316e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08003174 <fill_last_frag>:
{
 8003174:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003176:	4604      	mov	r4, r0
 8003178:	460f      	mov	r7, r1
 800317a:	4616      	mov	r6, r2
	while (obj->n_frag > 0) {	/* Create the chain of last fragment */
 800317c:	69e3      	ldr	r3, [r4, #28]
 800317e:	b173      	cbz	r3, 800319e <fill_last_frag+0x2a>
		res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
 8003180:	2b01      	cmp	r3, #1
 8003182:	eba7 0503 	sub.w	r5, r7, r3
 8003186:	bf14      	ite	ne
 8003188:	1caa      	addne	r2, r5, #2
 800318a:	4632      	moveq	r2, r6
 800318c:	6820      	ldr	r0, [r4, #0]
 800318e:	1c69      	adds	r1, r5, #1
 8003190:	f7ff ff78 	bl	8003084 <put_fat>
		if (res != FR_OK) return res;
 8003194:	b920      	cbnz	r0, 80031a0 <fill_last_frag+0x2c>
		obj->n_frag--;
 8003196:	69e3      	ldr	r3, [r4, #28]
 8003198:	3b01      	subs	r3, #1
 800319a:	61e3      	str	r3, [r4, #28]
 800319c:	e7ee      	b.n	800317c <fill_last_frag+0x8>
	return FR_OK;
 800319e:	4618      	mov	r0, r3
}
 80031a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080031a4 <fill_first_frag>:
	if (obj->stat == 3) {	/* Has the object been changed 'fragmented' in this session? */
 80031a4:	79c3      	ldrb	r3, [r0, #7]
 80031a6:	2b03      	cmp	r3, #3
 80031a8:	d112      	bne.n	80031d0 <fill_first_frag+0x2c>
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 80031aa:	6881      	ldr	r1, [r0, #8]
 80031ac:	6983      	ldr	r3, [r0, #24]
{
 80031ae:	b570      	push	{r4, r5, r6, lr}
 80031b0:	4604      	mov	r4, r0
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 80031b2:	18cd      	adds	r5, r1, r3
 80031b4:	42a9      	cmp	r1, r5
 80031b6:	d007      	beq.n	80031c8 <fill_first_frag+0x24>
			res = put_fat(obj->fs, cl, cl + 1);
 80031b8:	1c4e      	adds	r6, r1, #1
 80031ba:	6820      	ldr	r0, [r4, #0]
 80031bc:	4632      	mov	r2, r6
 80031be:	f7ff ff61 	bl	8003084 <put_fat>
			if (res != FR_OK) return res;
 80031c2:	b920      	cbnz	r0, 80031ce <fill_first_frag+0x2a>
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 80031c4:	4631      	mov	r1, r6
 80031c6:	e7f5      	b.n	80031b4 <fill_first_frag+0x10>
		obj->stat = 0;	/* Change status 'FAT chain is valid' */
 80031c8:	2300      	movs	r3, #0
 80031ca:	71e3      	strb	r3, [r4, #7]
	return FR_OK;
 80031cc:	2000      	movs	r0, #0
}
 80031ce:	bd70      	pop	{r4, r5, r6, pc}
	return FR_OK;
 80031d0:	2000      	movs	r0, #0
}
 80031d2:	4770      	bx	lr

080031d4 <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80031d4:	2901      	cmp	r1, #1
 80031d6:	f240 8087 	bls.w	80032e8 <get_fat+0x114>
{
 80031da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = obj->fs;
 80031dc:	6806      	ldr	r6, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80031de:	69f3      	ldr	r3, [r6, #28]
 80031e0:	428b      	cmp	r3, r1
 80031e2:	460c      	mov	r4, r1
 80031e4:	f240 8082 	bls.w	80032ec <get_fat+0x118>
		switch (fs->fs_type) {
 80031e8:	7833      	ldrb	r3, [r6, #0]
 80031ea:	3b01      	subs	r3, #1
 80031ec:	2b03      	cmp	r3, #3
 80031ee:	d87d      	bhi.n	80032ec <get_fat+0x118>
 80031f0:	e8df f003 	tbb	[pc, r3]
 80031f4:	47372902 	.word	0x47372902
			bc = (UINT)clst; bc += bc / 2;
 80031f8:	eb01 0551 	add.w	r5, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80031fc:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80031fe:	4630      	mov	r0, r6
 8003200:	eb01 2155 	add.w	r1, r1, r5, lsr #9
 8003204:	f7ff fe8c 	bl	8002f20 <move_window>
 8003208:	b110      	cbz	r0, 8003210 <get_fat+0x3c>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 800320a:	f04f 30ff 	mov.w	r0, #4294967295
 800320e:	e071      	b.n	80032f4 <get_fat+0x120>
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 8003210:	1c6f      	adds	r7, r5, #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003212:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 8003214:	f3c5 0508 	ubfx	r5, r5, #0, #9
 8003218:	4435      	add	r5, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800321a:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 800321e:	4630      	mov	r0, r6
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 8003220:	f895 503c 	ldrb.w	r5, [r5, #60]	@ 0x3c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8003224:	f7ff fe7c 	bl	8002f20 <move_window>
 8003228:	2800      	cmp	r0, #0
 800322a:	d1ee      	bne.n	800320a <get_fat+0x36>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 800322c:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8003230:	4437      	add	r7, r6
 8003232:	f897 303c 	ldrb.w	r3, [r7, #60]	@ 0x3c
 8003236:	ea45 2003 	orr.w	r0, r5, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 800323a:	07e3      	lsls	r3, r4, #31
 800323c:	bf4c      	ite	mi
 800323e:	0900      	lsrmi	r0, r0, #4
 8003240:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8003244:	e056      	b.n	80032f4 <get_fat+0x120>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8003246:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8003248:	4630      	mov	r0, r6
 800324a:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 800324e:	f7ff fe67 	bl	8002f20 <move_window>
 8003252:	2800      	cmp	r0, #0
 8003254:	d1d9      	bne.n	800320a <get_fat+0x36>
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 8003256:	0064      	lsls	r4, r4, #1
 8003258:	f404 74ff 	and.w	r4, r4, #510	@ 0x1fe
 800325c:	4434      	add	r4, r6
 800325e:	8fa0      	ldrh	r0, [r4, #60]	@ 0x3c
			break;
 8003260:	e048      	b.n	80032f4 <get_fat+0x120>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8003262:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8003264:	4630      	mov	r0, r6
 8003266:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 800326a:	f7ff fe59 	bl	8002f20 <move_window>
 800326e:	2800      	cmp	r0, #0
 8003270:	d1cb      	bne.n	800320a <get_fat+0x36>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 8003272:	00a4      	lsls	r4, r4, #2
 8003274:	f404 74fe 	and.w	r4, r4, #508	@ 0x1fc
 8003278:	4434      	add	r4, r6
 800327a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 800327c:	f020 4070 	bic.w	r0, r0, #4026531840	@ 0xf0000000
			break;
 8003280:	e038      	b.n	80032f4 <get_fat+0x120>
			if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must have valid data length */
 8003282:	e9d0 3104 	ldrd	r3, r1, [r0, #16]
 8003286:	ea53 0201 	orrs.w	r2, r3, r1
 800328a:	79c5      	ldrb	r5, [r0, #7]
 800328c:	d001      	beq.n	8003292 <get_fat+0xbe>
 800328e:	6882      	ldr	r2, [r0, #8]
 8003290:	b902      	cbnz	r2, 8003294 <get_fat+0xc0>
 8003292:	bb5d      	cbnz	r5, 80032ec <get_fat+0x118>
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 8003294:	6882      	ldr	r2, [r0, #8]
				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 8003296:	2d02      	cmp	r5, #2
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 8003298:	eba4 0202 	sub.w	r2, r4, r2
				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 800329c:	d10d      	bne.n	80032ba <get_fat+0xe6>
				DWORD clen = (DWORD)((LBA_t)((obj->objsize - 1) / SS(fs)) / fs->csize);	/* Number of clusters - 1 */
 800329e:	3b01      	subs	r3, #1
 80032a0:	f141 31ff 	adc.w	r1, r1, #4294967295
 80032a4:	0a5b      	lsrs	r3, r3, #9
 80032a6:	ea43 53c1 	orr.w	r3, r3, r1, lsl #23
 80032aa:	8971      	ldrh	r1, [r6, #10]
 80032ac:	fbb3 f3f1 	udiv	r3, r3, r1
				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 80032b0:	429a      	cmp	r2, r3
 80032b2:	d81b      	bhi.n	80032ec <get_fat+0x118>
					val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
 80032b4:	d01c      	beq.n	80032f0 <get_fat+0x11c>
 80032b6:	1c60      	adds	r0, r4, #1
 80032b8:	e01c      	b.n	80032f4 <get_fat+0x120>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 80032ba:	2d03      	cmp	r5, #3
 80032bc:	d102      	bne.n	80032c4 <get_fat+0xf0>
 80032be:	6983      	ldr	r3, [r0, #24]
 80032c0:	4293      	cmp	r3, r2
 80032c2:	d8f8      	bhi.n	80032b6 <get_fat+0xe2>
					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 80032c4:	69c3      	ldr	r3, [r0, #28]
 80032c6:	b99b      	cbnz	r3, 80032f0 <get_fat+0x11c>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80032c8:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80032ca:	4630      	mov	r0, r6
 80032cc:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80032d0:	f7ff fe26 	bl	8002f20 <move_window>
 80032d4:	2800      	cmp	r0, #0
 80032d6:	d198      	bne.n	800320a <get_fat+0x36>
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 80032d8:	00a4      	lsls	r4, r4, #2
 80032da:	f404 74fe 	and.w	r4, r4, #508	@ 0x1fc
 80032de:	4426      	add	r6, r4
 80032e0:	6bf0      	ldr	r0, [r6, #60]	@ 0x3c
 80032e2:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 80032e6:	e005      	b.n	80032f4 <get_fat+0x120>
 80032e8:	2001      	movs	r0, #1
}
 80032ea:	4770      	bx	lr
 80032ec:	2001      	movs	r0, #1
 80032ee:	e001      	b.n	80032f4 <get_fat+0x120>
					val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
 80032f0:	f06f 4000 	mvn.w	r0, #2147483648	@ 0x80000000
}
 80032f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080032f8 <dir_sdi>:
{
 80032f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = dp->obj.fs;
 80032fa:	6805      	ldr	r5, [r0, #0]
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 80032fc:	782b      	ldrb	r3, [r5, #0]
 80032fe:	2b04      	cmp	r3, #4
 8003300:	bf14      	ite	ne
 8003302:	f44f 1200 	movne.w	r2, #2097152	@ 0x200000
 8003306:	f04f 5280 	moveq.w	r2, #268435456	@ 0x10000000
 800330a:	428a      	cmp	r2, r1
 800330c:	d801      	bhi.n	8003312 <dir_sdi+0x1a>
		return FR_INT_ERR;
 800330e:	2002      	movs	r0, #2
 8003310:	e038      	b.n	8003384 <dir_sdi+0x8c>
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8003312:	06ca      	lsls	r2, r1, #27
 8003314:	460c      	mov	r4, r1
 8003316:	d1fa      	bne.n	800330e <dir_sdi+0x16>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8003318:	6882      	ldr	r2, [r0, #8]
	dp->dptr = ofs;				/* Set current offset */
 800331a:	6301      	str	r1, [r0, #48]	@ 0x30
 800331c:	4606      	mov	r6, r0
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800331e:	b95a      	cbnz	r2, 8003338 <dir_sdi+0x40>
 8003320:	2b02      	cmp	r3, #2
 8003322:	d805      	bhi.n	8003330 <dir_sdi+0x38>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 8003324:	892b      	ldrh	r3, [r5, #8]
 8003326:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
 800332a:	d9f0      	bls.n	800330e <dir_sdi+0x16>
		dp->sect = fs->dirbase;
 800332c:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 800332e:	e01a      	b.n	8003366 <dir_sdi+0x6e>
		clst = (DWORD)fs->dirbase;
 8003330:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
 8003332:	71c2      	strb	r2, [r0, #7]
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 8003334:	b90b      	cbnz	r3, 800333a <dir_sdi+0x42>
 8003336:	e7f5      	b.n	8003324 <dir_sdi+0x2c>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8003338:	4613      	mov	r3, r2
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800333a:	896f      	ldrh	r7, [r5, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 800333c:	461a      	mov	r2, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 800333e:	027f      	lsls	r7, r7, #9
		while (ofs >= csz) {				/* Follow cluster chain */
 8003340:	42bc      	cmp	r4, r7
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8003342:	4611      	mov	r1, r2
		while (ofs >= csz) {				/* Follow cluster chain */
 8003344:	d30c      	bcc.n	8003360 <dir_sdi+0x68>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8003346:	4630      	mov	r0, r6
 8003348:	f7ff ff44 	bl	80031d4 <get_fat>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800334c:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 800334e:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003350:	d017      	beq.n	8003382 <dir_sdi+0x8a>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8003352:	2801      	cmp	r0, #1
 8003354:	d9db      	bls.n	800330e <dir_sdi+0x16>
 8003356:	69eb      	ldr	r3, [r5, #28]
 8003358:	4283      	cmp	r3, r0
 800335a:	d9d8      	bls.n	800330e <dir_sdi+0x16>
			ofs -= csz;
 800335c:	1be4      	subs	r4, r4, r7
 800335e:	e7ef      	b.n	8003340 <dir_sdi+0x48>
		dp->sect = clst2sect(fs, clst);
 8003360:	4628      	mov	r0, r5
 8003362:	f7ff fcf1 	bl	8002d48 <clst2sect>
	dp->clust = clst;					/* Current cluster# */
 8003366:	e9c6 200d 	strd	r2, r0, [r6, #52]	@ 0x34
	if (dp->sect == 0) return FR_INT_ERR;
 800336a:	2800      	cmp	r0, #0
 800336c:	d0cf      	beq.n	800330e <dir_sdi+0x16>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800336e:	eb00 2054 	add.w	r0, r0, r4, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8003372:	353c      	adds	r5, #60	@ 0x3c
 8003374:	f3c4 0408 	ubfx	r4, r4, #0, #9
 8003378:	4425      	add	r5, r4
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800337a:	63b0      	str	r0, [r6, #56]	@ 0x38
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800337c:	63f5      	str	r5, [r6, #60]	@ 0x3c
	return FR_OK;
 800337e:	2000      	movs	r0, #0
 8003380:	e000      	b.n	8003384 <dir_sdi+0x8c>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003382:	2001      	movs	r0, #1
}
 8003384:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003388 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8003388:	2901      	cmp	r1, #1
{
 800338a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs = obj->fs;
 800338e:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8003390:	d801      	bhi.n	8003396 <remove_chain+0xe>
 8003392:	2002      	movs	r0, #2
 8003394:	e077      	b.n	8003486 <remove_chain+0xfe>
 8003396:	69eb      	ldr	r3, [r5, #28]
 8003398:	428b      	cmp	r3, r1
 800339a:	460c      	mov	r4, r1
 800339c:	d9f9      	bls.n	8003392 <remove_chain+0xa>
 800339e:	4606      	mov	r6, r0
 80033a0:	4617      	mov	r7, r2
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 80033a2:	b90a      	cbnz	r2, 80033a8 <remove_chain+0x20>
{
 80033a4:	46a1      	mov	r9, r4
 80033a6:	e027      	b.n	80033f8 <remove_chain+0x70>
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 80033a8:	782b      	ldrb	r3, [r5, #0]
 80033aa:	2b04      	cmp	r3, #4
 80033ac:	d102      	bne.n	80033b4 <remove_chain+0x2c>
 80033ae:	79c3      	ldrb	r3, [r0, #7]
 80033b0:	2b02      	cmp	r3, #2
 80033b2:	d0f7      	beq.n	80033a4 <remove_chain+0x1c>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 80033b4:	f04f 32ff 	mov.w	r2, #4294967295
 80033b8:	4639      	mov	r1, r7
 80033ba:	4628      	mov	r0, r5
 80033bc:	f7ff fe62 	bl	8003084 <put_fat>
		if (res != FR_OK) return res;
 80033c0:	2800      	cmp	r0, #0
 80033c2:	d0ef      	beq.n	80033a4 <remove_chain+0x1c>
 80033c4:	e05f      	b.n	8003486 <remove_chain+0xfe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 80033c6:	2801      	cmp	r0, #1
 80033c8:	d0e3      	beq.n	8003392 <remove_chain+0xa>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 80033ca:	1c42      	adds	r2, r0, #1
 80033cc:	d02d      	beq.n	800342a <remove_chain+0xa2>
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 80033ce:	782b      	ldrb	r3, [r5, #0]
 80033d0:	2b04      	cmp	r3, #4
 80033d2:	d12c      	bne.n	800342e <remove_chain+0xa6>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 80033d4:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
 80033d8:	3a02      	subs	r2, #2
 80033da:	4293      	cmp	r3, r2
 80033dc:	d205      	bcs.n	80033ea <remove_chain+0x62>
			fs->free_clst++;
 80033de:	3301      	adds	r3, #1
 80033e0:	61ab      	str	r3, [r5, #24]
			fs->fsi_flag |= 1;
 80033e2:	792b      	ldrb	r3, [r5, #4]
 80033e4:	f043 0301 	orr.w	r3, r3, #1
 80033e8:	712b      	strb	r3, [r5, #4]
		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 80033ea:	f108 0201 	add.w	r2, r8, #1
 80033ee:	42a2      	cmp	r2, r4
 80033f0:	d125      	bne.n	800343e <remove_chain+0xb6>
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 80033f2:	69eb      	ldr	r3, [r5, #28]
 80033f4:	42a3      	cmp	r3, r4
 80033f6:	d907      	bls.n	8003408 <remove_chain+0x80>
		nxt = get_fat(obj, clst);			/* Get cluster status */
 80033f8:	4621      	mov	r1, r4
 80033fa:	4630      	mov	r0, r6
 80033fc:	f7ff feea 	bl	80031d4 <get_fat>
		if (nxt == 0) break;				/* Empty cluster? */
 8003400:	46a0      	mov	r8, r4
 8003402:	4604      	mov	r4, r0
 8003404:	2800      	cmp	r0, #0
 8003406:	d1de      	bne.n	80033c6 <remove_chain+0x3e>
	if (fs->fs_type == FS_EXFAT) {
 8003408:	782b      	ldrb	r3, [r5, #0]
 800340a:	2b04      	cmp	r3, #4
 800340c:	d129      	bne.n	8003462 <remove_chain+0xda>
 800340e:	e025      	b.n	800345c <remove_chain+0xd4>
			if (obj->stat == 0) {	/* Is it a fragmented chain from the beginning of this session? */
 8003410:	79f3      	ldrb	r3, [r6, #7]
 8003412:	bb63      	cbnz	r3, 800346e <remove_chain+0xe6>
				clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
 8003414:	68b4      	ldr	r4, [r6, #8]
				while (clst != pclst) {
 8003416:	42bc      	cmp	r4, r7
 8003418:	d032      	beq.n	8003480 <remove_chain+0xf8>
					nxt = get_fat(obj, clst);
 800341a:	4621      	mov	r1, r4
 800341c:	4630      	mov	r0, r6
 800341e:	f7ff fed9 	bl	80031d4 <get_fat>
					if (nxt < 2) return FR_INT_ERR;
 8003422:	2801      	cmp	r0, #1
 8003424:	d9b5      	bls.n	8003392 <remove_chain+0xa>
					if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
 8003426:	1c43      	adds	r3, r0, #1
 8003428:	d11d      	bne.n	8003466 <remove_chain+0xde>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800342a:	2001      	movs	r0, #1
 800342c:	e02b      	b.n	8003486 <remove_chain+0xfe>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 800342e:	2200      	movs	r2, #0
 8003430:	4641      	mov	r1, r8
 8003432:	4628      	mov	r0, r5
 8003434:	f7ff fe26 	bl	8003084 <put_fat>
			if (res != FR_OK) return res;
 8003438:	2800      	cmp	r0, #0
 800343a:	d0cb      	beq.n	80033d4 <remove_chain+0x4c>
 800343c:	e023      	b.n	8003486 <remove_chain+0xfe>
			if (fs->fs_type == FS_EXFAT) {
 800343e:	782b      	ldrb	r3, [r5, #0]
 8003440:	2b04      	cmp	r3, #4
 8003442:	d001      	beq.n	8003448 <remove_chain+0xc0>
			scl = ecl = nxt;
 8003444:	46a1      	mov	r9, r4
 8003446:	e7d4      	b.n	80033f2 <remove_chain+0x6a>
				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
 8003448:	2300      	movs	r3, #0
 800344a:	eba2 0209 	sub.w	r2, r2, r9
 800344e:	4649      	mov	r1, r9
 8003450:	4628      	mov	r0, r5
 8003452:	f7ff fddb 	bl	800300c <change_bitmap>
				if (res != FR_OK) return res;
 8003456:	2800      	cmp	r0, #0
 8003458:	d0f4      	beq.n	8003444 <remove_chain+0xbc>
 800345a:	e014      	b.n	8003486 <remove_chain+0xfe>
		if (pclst == 0) {	/* Has the entire chain been removed? */
 800345c:	2f00      	cmp	r7, #0
 800345e:	d1d7      	bne.n	8003410 <remove_chain+0x88>
			obj->stat = 0;		/* Change the chain status 'initial' */
 8003460:	71f7      	strb	r7, [r6, #7]
	return FR_OK;
 8003462:	2000      	movs	r0, #0
 8003464:	e00f      	b.n	8003486 <remove_chain+0xfe>
					if (nxt != clst + 1) break;	/* Not contiguous? */
 8003466:	3401      	adds	r4, #1
 8003468:	4284      	cmp	r4, r0
 800346a:	d0d4      	beq.n	8003416 <remove_chain+0x8e>
 800346c:	e7f9      	b.n	8003462 <remove_chain+0xda>
				if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Was the chain fragmented in this session and got contiguous again? */
 800346e:	2b03      	cmp	r3, #3
 8003470:	d1f7      	bne.n	8003462 <remove_chain+0xda>
 8003472:	68b3      	ldr	r3, [r6, #8]
 8003474:	42bb      	cmp	r3, r7
 8003476:	d8f4      	bhi.n	8003462 <remove_chain+0xda>
 8003478:	69b2      	ldr	r2, [r6, #24]
 800347a:	4413      	add	r3, r2
 800347c:	42bb      	cmp	r3, r7
 800347e:	d3f0      	bcc.n	8003462 <remove_chain+0xda>
					obj->stat = 2;		/* Change the chain status 'contiguous' */
 8003480:	2302      	movs	r3, #2
 8003482:	71f3      	strb	r3, [r6, #7]
 8003484:	e7ed      	b.n	8003462 <remove_chain+0xda>
}
 8003486:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

0800348c <dir_clear>:
{
 800348c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003490:	4605      	mov	r5, r0
 8003492:	460e      	mov	r6, r1
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8003494:	f7ff fd22 	bl	8002edc <sync_window>
 8003498:	4604      	mov	r4, r0
 800349a:	bb00      	cbnz	r0, 80034de <dir_clear+0x52>
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 800349c:	4631      	mov	r1, r6
 800349e:	4628      	mov	r0, r5
 80034a0:	f7ff fc52 	bl	8002d48 <clst2sect>
	memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 80034a4:	f105 083c 	add.w	r8, r5, #60	@ 0x3c
	fs->winsect = sect;				/* Set window to top of the cluster */
 80034a8:	63a8      	str	r0, [r5, #56]	@ 0x38
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 80034aa:	4607      	mov	r7, r0
	memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 80034ac:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80034b0:	4621      	mov	r1, r4
 80034b2:	4640      	mov	r0, r8
 80034b4:	f7ff fc34 	bl	8002d20 <mem_set>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 80034b8:	4626      	mov	r6, r4
 80034ba:	896b      	ldrh	r3, [r5, #10]
 80034bc:	42b3      	cmp	r3, r6
 80034be:	d804      	bhi.n	80034ca <dir_clear+0x3e>
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 80034c0:	896c      	ldrh	r4, [r5, #10]
 80034c2:	1ba4      	subs	r4, r4, r6
 80034c4:	bf18      	it	ne
 80034c6:	2401      	movne	r4, #1
 80034c8:	e009      	b.n	80034de <dir_clear+0x52>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 80034ca:	7868      	ldrb	r0, [r5, #1]
 80034cc:	2301      	movs	r3, #1
 80034ce:	19f2      	adds	r2, r6, r7
 80034d0:	4641      	mov	r1, r8
 80034d2:	f00d f8ad 	bl	8010630 <disk_write>
 80034d6:	2800      	cmp	r0, #0
 80034d8:	d1f2      	bne.n	80034c0 <dir_clear+0x34>
 80034da:	3601      	adds	r6, #1
 80034dc:	e7ed      	b.n	80034ba <dir_clear+0x2e>
}
 80034de:	4620      	mov	r0, r4
 80034e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080034e4 <put_utf>:
{
 80034e4:	b538      	push	{r3, r4, r5, lr}
 80034e6:	460d      	mov	r5, r1
	wc = ff_uni2oem(chr, CODEPAGE);
 80034e8:	f240 3162 	movw	r1, #866	@ 0x362
{
 80034ec:	4614      	mov	r4, r2
	wc = ff_uni2oem(chr, CODEPAGE);
 80034ee:	f001 fe75 	bl	80051dc <ff_uni2oem>
	if (wc >= 0x100) {	/* Is this a DBC? */
 80034f2:	28ff      	cmp	r0, #255	@ 0xff
 80034f4:	d906      	bls.n	8003504 <put_utf+0x20>
		if (szb < 2) return 0;
 80034f6:	2c01      	cmp	r4, #1
 80034f8:	d909      	bls.n	800350e <put_utf+0x2a>
		*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
 80034fa:	0a03      	lsrs	r3, r0, #8
 80034fc:	702b      	strb	r3, [r5, #0]
		*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
 80034fe:	7068      	strb	r0, [r5, #1]
		return 2;
 8003500:	2402      	movs	r4, #2
 8003502:	e007      	b.n	8003514 <put_utf+0x30>
	if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
 8003504:	b128      	cbz	r0, 8003512 <put_utf+0x2e>
 8003506:	b12c      	cbz	r4, 8003514 <put_utf+0x30>
	*buf++ = (TCHAR)wc;					/* Store the character */
 8003508:	7028      	strb	r0, [r5, #0]
	return 1;
 800350a:	2401      	movs	r4, #1
 800350c:	e002      	b.n	8003514 <put_utf+0x30>
		if (szb < 2) return 0;
 800350e:	2400      	movs	r4, #0
 8003510:	e000      	b.n	8003514 <put_utf+0x30>
 8003512:	4604      	mov	r4, r0
}
 8003514:	4620      	mov	r0, r4
 8003516:	bd38      	pop	{r3, r4, r5, pc}

08003518 <get_fileinfo>:
{
 8003518:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	fno->fname[0] = 0;			/* Invaidate file info */
 800351c:	2500      	movs	r5, #0
	FATFS *fs = dp->obj.fs;
 800351e:	6807      	ldr	r7, [r0, #0]
	fno->fname[0] = 0;			/* Invaidate file info */
 8003520:	768d      	strb	r5, [r1, #26]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 8003522:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8003524:	2b00      	cmp	r3, #0
 8003526:	f000 80c3 	beq.w	80036b0 <get_fileinfo+0x198>
	if (fs->fs_type == FS_EXFAT) {	/* exFAT volume */
 800352a:	783b      	ldrb	r3, [r7, #0]
 800352c:	2b04      	cmp	r3, #4
 800352e:	460c      	mov	r4, r1
 8003530:	d145      	bne.n	80035be <get_fileinfo+0xa6>
		hs = 0;
 8003532:	462b      	mov	r3, r5
		si = SZDIRE * 2; di = 0;	/* 1st C1 entry in the entry block */
 8003534:	462e      	mov	r6, r5
 8003536:	f04f 0840 	mov.w	r8, #64	@ 0x40
		while (nc < fs->dirbuf[XDIR_NumName]) {
 800353a:	693a      	ldr	r2, [r7, #16]
 800353c:	f892 1023 	ldrb.w	r1, [r2, #35]	@ 0x23
 8003540:	42a9      	cmp	r1, r5
 8003542:	d921      	bls.n	8003588 <get_fileinfo+0x70>
			if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
 8003544:	f1b8 0f7f 	cmp.w	r8, #127	@ 0x7f
 8003548:	d820      	bhi.n	800358c <get_fileinfo+0x74>
			if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
 800354a:	f018 0f1f 	tst.w	r8, #31
 800354e:	bf08      	it	eq
 8003550:	f108 0802 	addeq.w	r8, r8, #2
			wc = ld_word(fs->dirbuf + si); si += 2; nc++;	/* Get a character */
 8003554:	3501      	adds	r5, #1
 8003556:	f832 0008 	ldrh.w	r0, [r2, r8]
 800355a:	f108 0802 	add.w	r8, r8, #2
			if (hs == 0 && IsSurrogate(wc)) {		/* Is it a surrogate? */
 800355e:	b92b      	cbnz	r3, 800356c <get_fileinfo+0x54>
 8003560:	f500 5220 	add.w	r2, r0, #10240	@ 0x2800
 8003564:	b292      	uxth	r2, r2
 8003566:	f5b2 6f00 	cmp.w	r2, #2048	@ 0x800
 800356a:	d30b      	bcc.n	8003584 <get_fileinfo+0x6c>
			nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
 800356c:	f106 011a 	add.w	r1, r6, #26
 8003570:	f1c6 0220 	rsb	r2, r6, #32
 8003574:	4421      	add	r1, r4
 8003576:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 800357a:	f7ff ffb3 	bl	80034e4 <put_utf>
			if (nw == 0) { di = 0; break; }			/* Buffer overflow or wrong char? */
 800357e:	b128      	cbz	r0, 800358c <get_fileinfo+0x74>
			di += nw;
 8003580:	4406      	add	r6, r0
			hs = 0;
 8003582:	2000      	movs	r0, #0
 8003584:	4603      	mov	r3, r0
 8003586:	e7d8      	b.n	800353a <get_fileinfo+0x22>
		if (hs != 0) di = 0;					/* Broken surrogate pair? */
 8003588:	b903      	cbnz	r3, 800358c <get_fileinfo+0x74>
		if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
 800358a:	b916      	cbnz	r6, 8003592 <get_fileinfo+0x7a>
 800358c:	233f      	movs	r3, #63	@ 0x3f
 800358e:	76a3      	strb	r3, [r4, #26]
 8003590:	2601      	movs	r6, #1
		fno->fname[di] = 0;						/* Terminate the name */
 8003592:	4426      	add	r6, r4
 8003594:	2300      	movs	r3, #0
 8003596:	76b3      	strb	r3, [r6, #26]
		fno->altname[0] = 0;					/* exFAT does not support SFN */
 8003598:	7363      	strb	r3, [r4, #13]
		fno->fattrib = fs->dirbuf[XDIR_Attr] & AM_MASKX;		/* Attribute */
 800359a:	693b      	ldr	r3, [r7, #16]
 800359c:	791a      	ldrb	r2, [r3, #4]
 800359e:	f002 0137 	and.w	r1, r2, #55	@ 0x37
 80035a2:	7321      	strb	r1, [r4, #12]
		fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 80035a4:	06d2      	lsls	r2, r2, #27
 80035a6:	bf58      	it	pl
 80035a8:	e9d3 010e 	ldrdpl	r0, r1, [r3, #56]	@ 0x38
		fno->ftime = ld_word(fs->dirbuf + XDIR_ModTime + 0);	/* Time */
 80035ac:	899a      	ldrh	r2, [r3, #12]
 80035ae:	8162      	strh	r2, [r4, #10]
		fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 80035b0:	bf44      	itt	mi
 80035b2:	2000      	movmi	r0, #0
 80035b4:	2100      	movmi	r1, #0
 80035b6:	e9c4 0100 	strd	r0, r1, [r4]
		fno->fdate = ld_word(fs->dirbuf + XDIR_ModTime + 2);	/* Date */
 80035ba:	89db      	ldrh	r3, [r3, #14]
 80035bc:	e077      	b.n	80036ae <get_fileinfo+0x196>
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 80035be:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 80035c0:	3301      	adds	r3, #1
 80035c2:	4606      	mov	r6, r0
 80035c4:	d024      	beq.n	8003610 <get_fileinfo+0xf8>
			hs = 0;
 80035c6:	46a9      	mov	r9, r5
			si = di = 0;
 80035c8:	46a8      	mov	r8, r5
			while (fs->lfnbuf[si] != 0) {
 80035ca:	68fb      	ldr	r3, [r7, #12]
 80035cc:	5b58      	ldrh	r0, [r3, r5]
 80035ce:	b1b8      	cbz	r0, 8003600 <get_fileinfo+0xe8>
				if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
 80035d0:	f1b9 0f00 	cmp.w	r9, #0
 80035d4:	d105      	bne.n	80035e2 <get_fileinfo+0xca>
 80035d6:	f500 5320 	add.w	r3, r0, #10240	@ 0x2800
 80035da:	b29b      	uxth	r3, r3
 80035dc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80035e0:	d30b      	bcc.n	80035fa <get_fileinfo+0xe2>
				nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
 80035e2:	f108 011a 	add.w	r1, r8, #26
 80035e6:	f1c8 0220 	rsb	r2, r8, #32
 80035ea:	4421      	add	r1, r4
 80035ec:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80035f0:	f7ff ff78 	bl	80034e4 <put_utf>
				if (nw == 0) { di = 0; break; }	/* Buffer overflow or wrong char? */
 80035f4:	b128      	cbz	r0, 8003602 <get_fileinfo+0xea>
				di += nw;
 80035f6:	4480      	add	r8, r0
				hs = 0;
 80035f8:	2000      	movs	r0, #0
 80035fa:	3502      	adds	r5, #2
 80035fc:	4681      	mov	r9, r0
 80035fe:	e7e4      	b.n	80035ca <get_fileinfo+0xb2>
 8003600:	4640      	mov	r0, r8
			if (hs != 0) di = 0;	/* Broken surrogate pair? */
 8003602:	f1b9 0f00 	cmp.w	r9, #0
 8003606:	bf18      	it	ne
 8003608:	2000      	movne	r0, #0
			fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
 800360a:	1823      	adds	r3, r4, r0
 800360c:	2200      	movs	r2, #0
 800360e:	769a      	strb	r2, [r3, #26]
		wc = dp->dir[si++];			/* Get a char */
 8003610:	6bf1      	ldr	r1, [r6, #60]	@ 0x3c
 8003612:	2300      	movs	r3, #0
 8003614:	1e4d      	subs	r5, r1, #1
 8003616:	4618      	mov	r0, r3
 8003618:	f815 2f01 	ldrb.w	r2, [r5, #1]!
		if (wc == ' ') continue;	/* Skip padding spaces */
 800361c:	2a20      	cmp	r2, #32
		wc = dp->dir[si++];			/* Get a char */
 800361e:	f100 0001 	add.w	r0, r0, #1
		if (wc == ' ') continue;	/* Skip padding spaces */
 8003622:	d00d      	beq.n	8003640 <get_fileinfo+0x128>
		if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
 8003624:	2a05      	cmp	r2, #5
 8003626:	bf08      	it	eq
 8003628:	22e5      	moveq	r2, #229	@ 0xe5
		if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
 800362a:	2809      	cmp	r0, #9
 800362c:	d105      	bne.n	800363a <get_fileinfo+0x122>
 800362e:	2b0b      	cmp	r3, #11
 8003630:	d803      	bhi.n	800363a <get_fileinfo+0x122>
 8003632:	18e6      	adds	r6, r4, r3
 8003634:	272e      	movs	r7, #46	@ 0x2e
 8003636:	7377      	strb	r7, [r6, #13]
 8003638:	3301      	adds	r3, #1
		fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
 800363a:	18e6      	adds	r6, r4, r3
 800363c:	3301      	adds	r3, #1
 800363e:	7372      	strb	r2, [r6, #13]
	while (si < 11) {		/* Get SFN from SFN entry */
 8003640:	280b      	cmp	r0, #11
 8003642:	d1e9      	bne.n	8003618 <get_fileinfo+0x100>
	fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
 8003644:	18e2      	adds	r2, r4, r3
 8003646:	2000      	movs	r0, #0
 8003648:	7350      	strb	r0, [r2, #13]
	if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
 800364a:	7ea2      	ldrb	r2, [r4, #26]
 800364c:	bb22      	cbnz	r2, 8003698 <get_fileinfo+0x180>
		if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
 800364e:	b11b      	cbz	r3, 8003658 <get_fileinfo+0x140>
 8003650:	f104 030c 	add.w	r3, r4, #12
			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 8003654:	2008      	movs	r0, #8
 8003656:	e00b      	b.n	8003670 <get_fileinfo+0x158>
			fno->fname[di++] = '?';
 8003658:	233f      	movs	r3, #63	@ 0x3f
 800365a:	76a3      	strb	r3, [r4, #26]
 800365c:	2301      	movs	r3, #1
 800365e:	e015      	b.n	800368c <get_fileinfo+0x174>
				if (wc == '.') lcf = NS_EXT;
 8003660:	2a2e      	cmp	r2, #46	@ 0x2e
				wc = (WCHAR)fno->altname[si];
 8003662:	4613      	mov	r3, r2
				if (wc == '.') lcf = NS_EXT;
 8003664:	d00e      	beq.n	8003684 <get_fileinfo+0x16c>
				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
 8003666:	3a41      	subs	r2, #65	@ 0x41
 8003668:	2a19      	cmp	r2, #25
 800366a:	d906      	bls.n	800367a <get_fileinfo+0x162>
				fno->fname[di] = (TCHAR)wc;
 800366c:	736b      	strb	r3, [r5, #13]
 800366e:	462b      	mov	r3, r5
			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 8003670:	785a      	ldrb	r2, [r3, #1]
 8003672:	1c5d      	adds	r5, r3, #1
 8003674:	2a00      	cmp	r2, #0
 8003676:	d1f3      	bne.n	8003660 <get_fileinfo+0x148>
 8003678:	e006      	b.n	8003688 <get_fileinfo+0x170>
				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
 800367a:	7b0a      	ldrb	r2, [r1, #12]
 800367c:	4210      	tst	r0, r2
 800367e:	d0f5      	beq.n	800366c <get_fileinfo+0x154>
 8003680:	3320      	adds	r3, #32
 8003682:	e7f3      	b.n	800366c <get_fileinfo+0x154>
				if (wc == '.') lcf = NS_EXT;
 8003684:	2010      	movs	r0, #16
 8003686:	e7f1      	b.n	800366c <get_fileinfo+0x154>
 8003688:	1b1b      	subs	r3, r3, r4
 800368a:	3b0c      	subs	r3, #12
		fno->fname[di] = 0;	/* Terminate the LFN */
 800368c:	4423      	add	r3, r4
 800368e:	2200      	movs	r2, #0
 8003690:	769a      	strb	r2, [r3, #26]
		if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
 8003692:	7b0b      	ldrb	r3, [r1, #12]
 8003694:	b903      	cbnz	r3, 8003698 <get_fileinfo+0x180>
 8003696:	7363      	strb	r3, [r4, #13]
	fno->fattrib = dp->dir[DIR_Attr] & AM_MASK;			/* Attribute */
 8003698:	7acb      	ldrb	r3, [r1, #11]
 800369a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800369e:	7323      	strb	r3, [r4, #12]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
 80036a0:	69cb      	ldr	r3, [r1, #28]
 80036a2:	6023      	str	r3, [r4, #0]
 80036a4:	2300      	movs	r3, #0
 80036a6:	6063      	str	r3, [r4, #4]
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
 80036a8:	8acb      	ldrh	r3, [r1, #22]
 80036aa:	8163      	strh	r3, [r4, #10]
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
 80036ac:	8b0b      	ldrh	r3, [r1, #24]
 80036ae:	8123      	strh	r3, [r4, #8]
}
 80036b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080036b4 <xname_sum>:
{
 80036b4:	b538      	push	{r3, r4, r5, lr}
 80036b6:	4605      	mov	r5, r0
	WORD sum = 0;
 80036b8:	2400      	movs	r4, #0
	while ((chr = *name++) != 0) {
 80036ba:	f835 0b02 	ldrh.w	r0, [r5], #2
 80036be:	b188      	cbz	r0, 80036e4 <xname_sum+0x30>
		chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
 80036c0:	f001 fdbc 	bl	800523c <ff_wtoupper>
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 80036c4:	03e3      	lsls	r3, r4, #15
 80036c6:	ea43 0354 	orr.w	r3, r3, r4, lsr #1
 80036ca:	b2c2      	uxtb	r2, r0
 80036cc:	fa12 f383 	uxtah	r3, r2, r3
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 80036d0:	f3c3 044e 	ubfx	r4, r3, #1, #15
 80036d4:	ea44 34c3 	orr.w	r4, r4, r3, lsl #15
 80036d8:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80036dc:	fa10 f484 	uxtah	r4, r0, r4
 80036e0:	b2a4      	uxth	r4, r4
 80036e2:	e7ea      	b.n	80036ba <xname_sum+0x6>
}
 80036e4:	4620      	mov	r0, r4
 80036e6:	bd38      	pop	{r3, r4, r5, pc}

080036e8 <sync_fs>:
{
 80036e8:	b570      	push	{r4, r5, r6, lr}
 80036ea:	4604      	mov	r4, r0
	res = sync_window(fs);
 80036ec:	f7ff fbf6 	bl	8002edc <sync_window>
	if (res == FR_OK) {
 80036f0:	bb88      	cbnz	r0, 8003756 <sync_fs+0x6e>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 80036f2:	7823      	ldrb	r3, [r4, #0]
 80036f4:	2b03      	cmp	r3, #3
 80036f6:	d126      	bne.n	8003746 <sync_fs+0x5e>
 80036f8:	7923      	ldrb	r3, [r4, #4]
 80036fa:	2b01      	cmp	r3, #1
 80036fc:	d123      	bne.n	8003746 <sync_fs+0x5e>
			memset(fs->win, 0, sizeof fs->win);
 80036fe:	f104 063c 	add.w	r6, r4, #60	@ 0x3c
 8003702:	4601      	mov	r1, r0
 8003704:	4605      	mov	r5, r0
 8003706:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800370a:	4630      	mov	r0, r6
 800370c:	f7ff fb08 	bl	8002d20 <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);					/* Boot signature */
 8003710:	f64a 2255 	movw	r2, #43605	@ 0xaa55
 8003714:	f8a4 223a 	strh.w	r2, [r4, #570]	@ 0x23a
			st_dword(fs->win + FSI_LeadSig, 0x41615252);		/* Leading signature */
 8003718:	4a0f      	ldr	r2, [pc, #60]	@ (8003758 <sync_fs+0x70>)
 800371a:	63e2      	str	r2, [r4, #60]	@ 0x3c
			st_dword(fs->win + FSI_StrucSig, 0x61417272);		/* Structure signature */
 800371c:	f102 52ff 	add.w	r2, r2, #534773760	@ 0x1fe00000
 8003720:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 8003724:	3220      	adds	r2, #32
 8003726:	f8c4 2220 	str.w	r2, [r4, #544]	@ 0x220
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);	/* Number of free clusters */
 800372a:	69a2      	ldr	r2, [r4, #24]
 800372c:	f8c4 2224 	str.w	r2, [r4, #548]	@ 0x224
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
 8003730:	6962      	ldr	r2, [r4, #20]
 8003732:	f8c4 2228 	str.w	r2, [r4, #552]	@ 0x228
			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
 8003736:	6a62      	ldr	r2, [r4, #36]	@ 0x24
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 8003738:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
 800373a:	3201      	adds	r2, #1
 800373c:	63a2      	str	r2, [r4, #56]	@ 0x38
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 800373e:	4631      	mov	r1, r6
 8003740:	f00c ff76 	bl	8010630 <disk_write>
			fs->fsi_flag = 0;
 8003744:	7125      	strb	r5, [r4, #4]
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8003746:	2200      	movs	r2, #0
 8003748:	7860      	ldrb	r0, [r4, #1]
 800374a:	4611      	mov	r1, r2
 800374c:	f00c ffc0 	bl	80106d0 <disk_ioctl>
 8003750:	3800      	subs	r0, #0
 8003752:	bf18      	it	ne
 8003754:	2001      	movne	r0, #1
}
 8003756:	bd70      	pop	{r4, r5, r6, pc}
 8003758:	41615252 	.word	0x41615252

0800375c <mount_volume>:
{
 800375c:	b5f0      	push	{r4, r5, r6, r7, lr}
	*rfs = 0;
 800375e:	2300      	movs	r3, #0
{
 8003760:	b085      	sub	sp, #20
	*rfs = 0;
 8003762:	600b      	str	r3, [r1, #0]
{
 8003764:	460e      	mov	r6, r1
 8003766:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
 8003768:	f7ff fb88 	bl	8002e7c <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800376c:	3001      	adds	r0, #1
 800376e:	f000 8111 	beq.w	8003994 <mount_volume+0x238>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 8003772:	4b8b      	ldr	r3, [pc, #556]	@ (80039a0 <mount_volume+0x244>)
 8003774:	681c      	ldr	r4, [r3, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 8003776:	2c00      	cmp	r4, #0
 8003778:	f000 810e 	beq.w	8003998 <mount_volume+0x23c>
	*rfs = fs;							/* Return pointer to the filesystem object */
 800377c:	6034      	str	r4, [r6, #0]
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 800377e:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8003780:	f005 05fe 	and.w	r5, r5, #254	@ 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 8003784:	b15b      	cbz	r3, 800379e <mount_volume+0x42>
		stat = disk_status(fs->pdrv);
 8003786:	7860      	ldrb	r0, [r4, #1]
 8003788:	f00c ff04 	bl	8010594 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 800378c:	07c3      	lsls	r3, r0, #31
 800378e:	d406      	bmi.n	800379e <mount_volume+0x42>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8003790:	b90d      	cbnz	r5, 8003796 <mount_volume+0x3a>
			return FR_OK;				/* The filesystem object is already valid */
 8003792:	2000      	movs	r0, #0
 8003794:	e186      	b.n	8003aa4 <mount_volume+0x348>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8003796:	0747      	lsls	r7, r0, #29
 8003798:	d5fb      	bpl.n	8003792 <mount_volume+0x36>
				return FR_WRITE_PROTECTED;
 800379a:	200a      	movs	r0, #10
 800379c:	e182      	b.n	8003aa4 <mount_volume+0x348>
	fs->fs_type = 0;					/* Clear the filesystem object */
 800379e:	2000      	movs	r0, #0
 80037a0:	8020      	strh	r0, [r4, #0]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 80037a2:	f00c fe73 	bl	801048c <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 80037a6:	07c6      	lsls	r6, r0, #31
 80037a8:	f100 80f8 	bmi.w	800399c <mount_volume+0x240>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 80037ac:	b10d      	cbz	r5, 80037b2 <mount_volume+0x56>
 80037ae:	0741      	lsls	r1, r0, #29
 80037b0:	d4f3      	bmi.n	800379a <mount_volume+0x3e>
	fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD format */
 80037b2:	2100      	movs	r1, #0
 80037b4:	4620      	mov	r0, r4
 80037b6:	f7ff fbcb 	bl	8002f50 <check_fs>
	if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is an FAT VBR as auto scan, not a BS or disk error */
 80037ba:	2802      	cmp	r0, #2
 80037bc:	d11b      	bne.n	80037f6 <mount_volume+0x9a>
		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 80037be:	f8d4 3202 	ldr.w	r3, [r4, #514]	@ 0x202
 80037c2:	9300      	str	r3, [sp, #0]
 80037c4:	f8d4 3212 	ldr.w	r3, [r4, #530]	@ 0x212
 80037c8:	9301      	str	r3, [sp, #4]
 80037ca:	f8d4 3222 	ldr.w	r3, [r4, #546]	@ 0x222
 80037ce:	9302      	str	r3, [sp, #8]
 80037d0:	f8d4 3232 	ldr.w	r3, [r4, #562]	@ 0x232
 80037d4:	9303      	str	r3, [sp, #12]
	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
 80037d6:	466e      	mov	r6, sp
		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 80037d8:	2500      	movs	r5, #0
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
 80037da:	f856 1b04 	ldr.w	r1, [r6], #4
 80037de:	b129      	cbz	r1, 80037ec <mount_volume+0x90>
 80037e0:	4620      	mov	r0, r4
 80037e2:	f7ff fbb5 	bl	8002f50 <check_fs>
	} while (part == 0 && fmt >= 2 && ++i < 4);
 80037e6:	2801      	cmp	r0, #1
 80037e8:	d801      	bhi.n	80037ee <mount_volume+0x92>
 80037ea:	e00b      	b.n	8003804 <mount_volume+0xa8>
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
 80037ec:	2003      	movs	r0, #3
	} while (part == 0 && fmt >= 2 && ++i < 4);
 80037ee:	3501      	adds	r5, #1
 80037f0:	2d04      	cmp	r5, #4
 80037f2:	d1f2      	bne.n	80037da <mount_volume+0x7e>
 80037f4:	e152      	b.n	8003a9c <mount_volume+0x340>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80037f6:	2804      	cmp	r0, #4
 80037f8:	f000 80ca 	beq.w	8003990 <mount_volume+0x234>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 80037fc:	2801      	cmp	r0, #1
 80037fe:	d901      	bls.n	8003804 <mount_volume+0xa8>
 8003800:	200d      	movs	r0, #13
 8003802:	e14f      	b.n	8003aa4 <mount_volume+0x348>
	if (fmt == 1) {
 8003804:	2801      	cmp	r0, #1
	bsect = fs->winsect;					/* Volume offset */
 8003806:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
	if (fmt == 1) {
 8003808:	d10a      	bne.n	8003820 <mount_volume+0xc4>
 800380a:	f104 0246 	add.w	r2, r4, #70	@ 0x46
		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
 800380e:	230b      	movs	r3, #11
 8003810:	f812 5f01 	ldrb.w	r5, [r2, #1]!
 8003814:	2d00      	cmp	r5, #0
 8003816:	d1f3      	bne.n	8003800 <mount_volume+0xa4>
 8003818:	3301      	adds	r3, #1
 800381a:	2b40      	cmp	r3, #64	@ 0x40
 800381c:	d1f8      	bne.n	8003810 <mount_volume+0xb4>
 800381e:	e0cb      	b.n	80039b8 <mount_volume+0x25c>
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8003820:	f8b4 3047 	ldrh.w	r3, [r4, #71]	@ 0x47
 8003824:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8003828:	d1ea      	bne.n	8003800 <mount_volume+0xa4>
		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 800382a:	f8b4 6052 	ldrh.w	r6, [r4, #82]	@ 0x52
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 800382e:	b906      	cbnz	r6, 8003832 <mount_volume+0xd6>
 8003830:	6e26      	ldr	r6, [r4, #96]	@ 0x60
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8003832:	f894 704c 	ldrb.w	r7, [r4, #76]	@ 0x4c
		fs->fsize = fasize;
 8003836:	6226      	str	r6, [r4, #32]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8003838:	1e7b      	subs	r3, r7, #1
 800383a:	2b01      	cmp	r3, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800383c:	70a7      	strb	r7, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800383e:	d8df      	bhi.n	8003800 <mount_volume+0xa4>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 8003840:	f894 5049 	ldrb.w	r5, [r4, #73]	@ 0x49
 8003844:	8165      	strh	r5, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8003846:	2d00      	cmp	r5, #0
 8003848:	d0da      	beq.n	8003800 <mount_volume+0xa4>
 800384a:	1e6b      	subs	r3, r5, #1
 800384c:	422b      	tst	r3, r5
 800384e:	d1d7      	bne.n	8003800 <mount_volume+0xa4>
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8003850:	f8b4 c04d 	ldrh.w	ip, [r4, #77]	@ 0x4d
 8003854:	f8a4 c008 	strh.w	ip, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8003858:	f01c 0f0f 	tst.w	ip, #15
 800385c:	d1d0      	bne.n	8003800 <mount_volume+0xa4>
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 800385e:	f8b4 304f 	ldrh.w	r3, [r4, #79]	@ 0x4f
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8003862:	b903      	cbnz	r3, 8003866 <mount_volume+0x10a>
 8003864:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 8003866:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 800386a:	2a00      	cmp	r2, #0
 800386c:	d0c8      	beq.n	8003800 <mount_volume+0xa4>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800386e:	4377      	muls	r7, r6
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8003870:	eb02 101c 	add.w	r0, r2, ip, lsr #4
 8003874:	4438      	add	r0, r7
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8003876:	4283      	cmp	r3, r0
 8003878:	d3c2      	bcc.n	8003800 <mount_volume+0xa4>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800387a:	1a1b      	subs	r3, r3, r0
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800387c:	42ab      	cmp	r3, r5
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800387e:	fbb3 fef5 	udiv	lr, r3, r5
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8003882:	d3bd      	bcc.n	8003800 <mount_volume+0xa4>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 8003884:	4b47      	ldr	r3, [pc, #284]	@ (80039a4 <mount_volume+0x248>)
 8003886:	459e      	cmp	lr, r3
 8003888:	d8ba      	bhi.n	8003800 <mount_volume+0xa4>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 800388a:	f64f 73f5 	movw	r3, #65525	@ 0xfff5
 800388e:	459e      	cmp	lr, r3
 8003890:	d806      	bhi.n	80038a0 <mount_volume+0x144>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8003892:	f640 75f5 	movw	r5, #4085	@ 0xff5
 8003896:	45ae      	cmp	lr, r5
 8003898:	bf8c      	ite	hi
 800389a:	2502      	movhi	r5, #2
 800389c:	2501      	movls	r5, #1
 800389e:	e000      	b.n	80038a2 <mount_volume+0x146>
 80038a0:	2503      	movs	r5, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80038a2:	f10e 0302 	add.w	r3, lr, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80038a6:	440a      	add	r2, r1
		fs->database = bsect + sysect;					/* Data start sector */
 80038a8:	4408      	add	r0, r1
		if (fmt == FS_FAT32) {
 80038aa:	2d03      	cmp	r5, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80038ac:	61e3      	str	r3, [r4, #28]
		fs->volbase = bsect;							/* Volume start sector */
 80038ae:	6261      	str	r1, [r4, #36]	@ 0x24
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80038b0:	62a2      	str	r2, [r4, #40]	@ 0x28
		fs->database = bsect + sysect;					/* Data start sector */
 80038b2:	6320      	str	r0, [r4, #48]	@ 0x30
		if (fmt == FS_FAT32) {
 80038b4:	d107      	bne.n	80038c6 <mount_volume+0x16a>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 80038b6:	f8b4 2066 	ldrh.w	r2, [r4, #102]	@ 0x66
 80038ba:	ea5c 0202 	orrs.w	r2, ip, r2
 80038be:	d19f      	bne.n	8003800 <mount_volume+0xa4>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 80038c0:	6ea7      	ldr	r7, [r4, #104]	@ 0x68
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 80038c2:	009b      	lsls	r3, r3, #2
 80038c4:	e00d      	b.n	80038e2 <mount_volume+0x186>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 80038c6:	f1bc 0f00 	cmp.w	ip, #0
 80038ca:	d099      	beq.n	8003800 <mount_volume+0xa4>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80038cc:	2d02      	cmp	r5, #2
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 80038ce:	4417      	add	r7, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 80038d0:	ea4f 0243 	mov.w	r2, r3, lsl #1
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80038d4:	bf1b      	ittet	ne
 80038d6:	18d2      	addne	r2, r2, r3
 80038d8:	f003 0301 	andne.w	r3, r3, #1
 80038dc:	4613      	moveq	r3, r2
 80038de:	eb03 0352 	addne.w	r3, r3, r2, lsr #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80038e2:	f203 13ff 	addw	r3, r3, #511	@ 0x1ff
 80038e6:	ebb6 2f53 	cmp.w	r6, r3, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 80038ea:	62e7      	str	r7, [r4, #44]	@ 0x2c
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80038ec:	d388      	bcc.n	8003800 <mount_volume+0xa4>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 80038ee:	f04f 33ff 	mov.w	r3, #4294967295
 80038f2:	e9c4 3305 	strd	r3, r3, [r4, #20]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 80038f6:	2d03      	cmp	r5, #3
		fs->fsi_flag = 0x80;
 80038f8:	f04f 0380 	mov.w	r3, #128	@ 0x80
 80038fc:	7123      	strb	r3, [r4, #4]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 80038fe:	d122      	bne.n	8003946 <mount_volume+0x1ea>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8003900:	f8b4 306c 	ldrh.w	r3, [r4, #108]	@ 0x6c
 8003904:	2b01      	cmp	r3, #1
 8003906:	d11e      	bne.n	8003946 <mount_volume+0x1ea>
			&& move_window(fs, bsect + 1) == FR_OK)
 8003908:	3101      	adds	r1, #1
 800390a:	4620      	mov	r0, r4
 800390c:	f7ff fb08 	bl	8002f20 <move_window>
 8003910:	b9c8      	cbnz	r0, 8003946 <mount_volume+0x1ea>
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 8003912:	f8b4 223a 	ldrh.w	r2, [r4, #570]	@ 0x23a
			fs->fsi_flag = 0;
 8003916:	7120      	strb	r0, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 8003918:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 800391c:	429a      	cmp	r2, r3
 800391e:	d112      	bne.n	8003946 <mount_volume+0x1ea>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 8003920:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 8003922:	4b21      	ldr	r3, [pc, #132]	@ (80039a8 <mount_volume+0x24c>)
 8003924:	429a      	cmp	r2, r3
 8003926:	d10e      	bne.n	8003946 <mount_volume+0x1ea>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8003928:	f103 53ff 	add.w	r3, r3, #534773760	@ 0x1fe00000
 800392c:	f8d4 2220 	ldr.w	r2, [r4, #544]	@ 0x220
 8003930:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8003934:	3320      	adds	r3, #32
 8003936:	429a      	cmp	r2, r3
 8003938:	d105      	bne.n	8003946 <mount_volume+0x1ea>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 800393a:	f8d4 3224 	ldr.w	r3, [r4, #548]	@ 0x224
 800393e:	61a3      	str	r3, [r4, #24]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8003940:	f8d4 3228 	ldr.w	r3, [r4, #552]	@ 0x228
 8003944:	6163      	str	r3, [r4, #20]
	fs->id = ++Fsid;		/* Volume mount ID */
 8003946:	4a19      	ldr	r2, [pc, #100]	@ (80039ac <mount_volume+0x250>)
	fs->fs_type = (BYTE)fmt;/* FAT sub-type */
 8003948:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 800394a:	8813      	ldrh	r3, [r2, #0]
 800394c:	3301      	adds	r3, #1
 800394e:	b29b      	uxth	r3, r3
 8003950:	8013      	strh	r3, [r2, #0]
 8003952:	80e3      	strh	r3, [r4, #6]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 8003954:	4b16      	ldr	r3, [pc, #88]	@ (80039b0 <mount_volume+0x254>)
 8003956:	60e3      	str	r3, [r4, #12]
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
 8003958:	4b16      	ldr	r3, [pc, #88]	@ (80039b4 <mount_volume+0x258>)
 800395a:	6123      	str	r3, [r4, #16]
	return FR_OK;
 800395c:	e719      	b.n	8003792 <mount_volume+0x36>
		bcl = ld_dword(fs->win + i + 20);				/* Bitmap cluster */
 800395e:	f104 063c 	add.w	r6, r4, #60	@ 0x3c
 8003962:	4435      	add	r5, r6
 8003964:	696d      	ldr	r5, [r5, #20]
		if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;	/* (Wrong cluster#) */
 8003966:	2d01      	cmp	r5, #1
 8003968:	f67f af4a 	bls.w	8003800 <mount_volume+0xa4>
 800396c:	69e3      	ldr	r3, [r4, #28]
 800396e:	42ab      	cmp	r3, r5
 8003970:	f67f af46 	bls.w	8003800 <mount_volume+0xa4>
		fs->bitbase = fs->database + fs->csize * (bcl - 2);	/* Bitmap sector */
 8003974:	8961      	ldrh	r1, [r4, #10]
 8003976:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003978:	1eaa      	subs	r2, r5, #2
 800397a:	fb02 3301 	mla	r3, r2, r1, r3
 800397e:	6363      	str	r3, [r4, #52]	@ 0x34
			if (move_window(fs, fs->fatbase + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;
 8003980:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8003982:	4620      	mov	r0, r4
 8003984:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
 8003988:	f7ff faca 	bl	8002f20 <move_window>
 800398c:	2800      	cmp	r0, #0
 800398e:	d076      	beq.n	8003a7e <mount_volume+0x322>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003990:	2001      	movs	r0, #1
 8003992:	e087      	b.n	8003aa4 <mount_volume+0x348>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003994:	200b      	movs	r0, #11
 8003996:	e085      	b.n	8003aa4 <mount_volume+0x348>
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 8003998:	200c      	movs	r0, #12
 800399a:	e083      	b.n	8003aa4 <mount_volume+0x348>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800399c:	2003      	movs	r0, #3
 800399e:	e081      	b.n	8003aa4 <mount_volume+0x348>
 80039a0:	20000788 	.word	0x20000788
 80039a4:	0ffffff5 	.word	0x0ffffff5
 80039a8:	41615252 	.word	0x41615252
 80039ac:	20000784 	.word	0x20000784
 80039b0:	200006d4 	.word	0x200006d4
 80039b4:	20000704 	.word	0x20000704
		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (must be version 1.0) */
 80039b8:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	@ 0xa4
 80039bc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80039c0:	f47f af1e 	bne.w	8003800 <mount_volume+0xa4>
		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
 80039c4:	f894 30a8 	ldrb.w	r3, [r4, #168]	@ 0xa8
 80039c8:	2b09      	cmp	r3, #9
 80039ca:	f47f af19 	bne.w	8003800 <mount_volume+0xa4>
		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA of the volume + 1 */
 80039ce:	e9d4 0621 	ldrd	r0, r6, [r4, #132]	@ 0x84
		if (!FF_LBA64 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be accessed in 32-bit LBA) */
 80039d2:	f04f 33ff 	mov.w	r3, #4294967295
		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA of the volume + 1 */
 80039d6:	1808      	adds	r0, r1, r0
 80039d8:	f146 0600 	adc.w	r6, r6, #0
		if (!FF_LBA64 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be accessed in 32-bit LBA) */
 80039dc:	4283      	cmp	r3, r0
 80039de:	eb75 0306 	sbcs.w	r3, r5, r6
 80039e2:	f4ff af0d 	bcc.w	8003800 <mount_volume+0xa4>
		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
 80039e6:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 80039ea:	6223      	str	r3, [r4, #32]
		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
 80039ec:	f894 30aa 	ldrb.w	r3, [r4, #170]	@ 0xaa
 80039f0:	70a3      	strb	r3, [r4, #2]
		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
 80039f2:	2b01      	cmp	r3, #1
 80039f4:	f47f af04 	bne.w	8003800 <mount_volume+0xa4>
		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
 80039f8:	f894 20a9 	ldrb.w	r2, [r4, #169]	@ 0xa9
 80039fc:	4093      	lsls	r3, r2
 80039fe:	b29a      	uxth	r2, r3
 8003a00:	8162      	strh	r2, [r4, #10]
		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768 sectors) */
 8003a02:	2a00      	cmp	r2, #0
 8003a04:	f43f aefc 	beq.w	8003800 <mount_volume+0xa4>
		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
 8003a08:	f8d4 c098 	ldr.w	ip, [r4, #152]	@ 0x98
		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
 8003a0c:	4a26      	ldr	r2, [pc, #152]	@ (8003aa8 <mount_volume+0x34c>)
 8003a0e:	4594      	cmp	ip, r2
 8003a10:	f63f aef6 	bhi.w	8003800 <mount_volume+0xa4>
		fs->n_fatent = nclst + 2;
 8003a14:	f10c 0202 	add.w	r2, ip, #2
 8003a18:	61e2      	str	r2, [r4, #28]
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8003a1a:	f8d4 2094 	ldr.w	r2, [r4, #148]	@ 0x94
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8003a1e:	f8d4 708c 	ldr.w	r7, [r4, #140]	@ 0x8c
		fs->volbase = bsect;
 8003a22:	6261      	str	r1, [r4, #36]	@ 0x24
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003a24:	b29b      	uxth	r3, r3
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8003a26:	440a      	add	r2, r1
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003a28:	fb0c f303 	mul.w	r3, ip, r3
 8003a2c:	189b      	adds	r3, r3, r2
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8003a2e:	6322      	str	r2, [r4, #48]	@ 0x30
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003a30:	eb45 0205 	adc.w	r2, r5, r5
 8003a34:	4298      	cmp	r0, r3
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8003a36:	440f      	add	r7, r1
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003a38:	eb76 0202 	sbcs.w	r2, r6, r2
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8003a3c:	62a7      	str	r7, [r4, #40]	@ 0x28
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003a3e:	f4ff aedf 	bcc.w	8003800 <mount_volume+0xa4>
		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
 8003a42:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
 8003a46:	62e3      	str	r3, [r4, #44]	@ 0x2c
		so = i = 0;
 8003a48:	462e      	mov	r6, r5
			if (i == 0) {
 8003a4a:	b975      	cbnz	r5, 8003a6a <mount_volume+0x30e>
				if (so >= fs->csize) return FR_NO_FILESYSTEM;	/* Not found? */
 8003a4c:	8963      	ldrh	r3, [r4, #10]
 8003a4e:	42b3      	cmp	r3, r6
 8003a50:	f67f aed6 	bls.w	8003800 <mount_volume+0xa4>
				if (move_window(fs, clst2sect(fs, (DWORD)fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;
 8003a54:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8003a56:	4620      	mov	r0, r4
 8003a58:	f7ff f976 	bl	8002d48 <clst2sect>
 8003a5c:	1981      	adds	r1, r0, r6
 8003a5e:	4620      	mov	r0, r4
 8003a60:	f7ff fa5e 	bl	8002f20 <move_window>
 8003a64:	2800      	cmp	r0, #0
 8003a66:	d193      	bne.n	8003990 <mount_volume+0x234>
				so++;
 8003a68:	3601      	adds	r6, #1
			if (fs->win[i] == ET_BITMAP) break;			/* Is it a bitmap entry? */
 8003a6a:	1963      	adds	r3, r4, r5
 8003a6c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8003a70:	2b81      	cmp	r3, #129	@ 0x81
 8003a72:	f43f af74 	beq.w	800395e <mount_volume+0x202>
			i = (i + SZDIRE) % SS(fs);	/* Next entry */
 8003a76:	3520      	adds	r5, #32
 8003a78:	f3c5 0508 	ubfx	r5, r5, #0, #9
			if (i == 0) {
 8003a7c:	e7e5      	b.n	8003a4a <mount_volume+0x2ee>
			cv = ld_dword(fs->win + bcl % (SS(fs) / 4) * 4);
 8003a7e:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
 8003a82:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
			if (cv == 0xFFFFFFFF) break;				/* Last link? */
 8003a86:	1c5a      	adds	r2, r3, #1
 8003a88:	d004      	beq.n	8003a94 <mount_volume+0x338>
			if (cv != ++bcl) return FR_NO_FILESYSTEM;	/* Fragmented? */
 8003a8a:	3501      	adds	r5, #1
 8003a8c:	42ab      	cmp	r3, r5
 8003a8e:	f43f af77 	beq.w	8003980 <mount_volume+0x224>
 8003a92:	e6b5      	b.n	8003800 <mount_volume+0xa4>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8003a94:	e9c4 3305 	strd	r3, r3, [r4, #20]
		fmt = FS_EXFAT;			/* FAT sub-type */
 8003a98:	2504      	movs	r5, #4
 8003a9a:	e754      	b.n	8003946 <mount_volume+0x1ea>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003a9c:	2804      	cmp	r0, #4
 8003a9e:	f47f aeaf 	bne.w	8003800 <mount_volume+0xa4>
 8003aa2:	e775      	b.n	8003990 <mount_volume+0x234>
}
 8003aa4:	b005      	add	sp, #20
 8003aa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003aa8:	7ffffffd 	.word	0x7ffffffd

08003aac <create_chain>:
{
 8003aac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	FATFS *fs = obj->fs;
 8003ab0:	6805      	ldr	r5, [r0, #0]
{
 8003ab2:	4606      	mov	r6, r0
	if (clst == 0) {	/* Create a new chain */
 8003ab4:	4688      	mov	r8, r1
 8003ab6:	b931      	cbnz	r1, 8003ac6 <create_chain+0x1a>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 8003ab8:	696f      	ldr	r7, [r5, #20]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8003aba:	b1a7      	cbz	r7, 8003ae6 <create_chain+0x3a>
 8003abc:	69eb      	ldr	r3, [r5, #28]
 8003abe:	42bb      	cmp	r3, r7
 8003ac0:	bf98      	it	ls
 8003ac2:	2701      	movls	r7, #1
 8003ac4:	e010      	b.n	8003ae8 <create_chain+0x3c>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8003ac6:	f7ff fb85 	bl	80031d4 <get_fat>
		if (cs < 2) return 1;				/* Test for insanity */
 8003aca:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8003acc:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Test for insanity */
 8003ace:	d801      	bhi.n	8003ad4 <create_chain+0x28>
 8003ad0:	2401      	movs	r4, #1
 8003ad2:	e0d7      	b.n	8003c84 <create_chain+0x1d8>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 8003ad4:	1c42      	adds	r2, r0, #1
 8003ad6:	f000 80bb 	beq.w	8003c50 <create_chain+0x1a4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8003ada:	69eb      	ldr	r3, [r5, #28]
 8003adc:	4283      	cmp	r3, r0
 8003ade:	f200 80d1 	bhi.w	8003c84 <create_chain+0x1d8>
		scl = clst;							/* Cluster to start to find */
 8003ae2:	4647      	mov	r7, r8
 8003ae4:	e000      	b.n	8003ae8 <create_chain+0x3c>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8003ae6:	2701      	movs	r7, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8003ae8:	69ab      	ldr	r3, [r5, #24]
 8003aea:	b90b      	cbnz	r3, 8003af0 <create_chain+0x44>
 8003aec:	2400      	movs	r4, #0
 8003aee:	e0c9      	b.n	8003c84 <create_chain+0x1d8>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003af0:	782a      	ldrb	r2, [r5, #0]
	if (clst >= fs->n_fatent - 2) clst = 0;
 8003af2:	69eb      	ldr	r3, [r5, #28]
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003af4:	2a04      	cmp	r2, #4
 8003af6:	d159      	bne.n	8003bac <create_chain+0x100>
	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
 8003af8:	f1a7 0a02 	sub.w	sl, r7, #2
	if (clst >= fs->n_fatent - 2) clst = 0;
 8003afc:	3b02      	subs	r3, #2
 8003afe:	459a      	cmp	sl, r3
 8003b00:	bf28      	it	cs
 8003b02:	f04f 0a00 	movcs.w	sl, #0
	scl = val = clst; ctr = 0;
 8003b06:	46d1      	mov	r9, sl
		if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
 8003b08:	6b69      	ldr	r1, [r5, #52]	@ 0x34
 8003b0a:	4628      	mov	r0, r5
 8003b0c:	eb01 3119 	add.w	r1, r1, r9, lsr #12
 8003b10:	f7ff fa06 	bl	8002f20 <move_window>
 8003b14:	bb30      	cbnz	r0, 8003b64 <create_chain+0xb8>
		i = val / 8 % SS(fs); bm = 1 << (val % 8);
 8003b16:	f009 0207 	and.w	r2, r9, #7
 8003b1a:	2301      	movs	r3, #1
 8003b1c:	4093      	lsls	r3, r2
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003b1e:	69ea      	ldr	r2, [r5, #28]
		i = val / 8 % SS(fs); bm = 1 << (val % 8);
 8003b20:	f3c9 01c8 	ubfx	r1, r9, #3, #9
 8003b24:	b2db      	uxtb	r3, r3
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003b26:	3a02      	subs	r2, #2
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003b28:	1868      	adds	r0, r5, r1
			bm = 1;
 8003b2a:	464c      	mov	r4, r9
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003b2c:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003b30:	f109 0901 	add.w	r9, r9, #1
 8003b34:	4591      	cmp	r9, r2
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003b36:	ea00 0003 	and.w	r0, r0, r3
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003b3a:	d202      	bcs.n	8003b42 <create_chain+0x96>
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003b3c:	005b      	lsls	r3, r3, #1
 8003b3e:	b2db      	uxtb	r3, r3
 8003b40:	e003      	b.n	8003b4a <create_chain+0x9e>
					val = 0; bm = 0; i = SS(fs);
 8003b42:	2300      	movs	r3, #0
 8003b44:	4699      	mov	r9, r3
 8003b46:	f44f 7100 	mov.w	r1, #512	@ 0x200
				if (bv == 0) {	/* Is it a free cluster? */
 8003b4a:	b908      	cbnz	r0, 8003b50 <create_chain+0xa4>
					if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
 8003b4c:	3402      	adds	r4, #2
 8003b4e:	e00d      	b.n	8003b6c <create_chain+0xc0>
				if (val == clst) return 0;	/* All cluster scanned? */
 8003b50:	45ca      	cmp	sl, r9
 8003b52:	d00a      	beq.n	8003b6a <create_chain+0xbe>
			} while (bm != 0);
 8003b54:	2b00      	cmp	r3, #0
 8003b56:	d1e7      	bne.n	8003b28 <create_chain+0x7c>
		} while (++i < SS(fs));
 8003b58:	3101      	adds	r1, #1
 8003b5a:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
 8003b5e:	d2d3      	bcs.n	8003b08 <create_chain+0x5c>
			bm = 1;
 8003b60:	2301      	movs	r3, #1
 8003b62:	e7e1      	b.n	8003b28 <create_chain+0x7c>
		if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
 8003b64:	f04f 34ff 	mov.w	r4, #4294967295
 8003b68:	e000      	b.n	8003b6c <create_chain+0xc0>
				if (val == clst) return 0;	/* All cluster scanned? */
 8003b6a:	2400      	movs	r4, #0
		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
 8003b6c:	1e63      	subs	r3, r4, #1
 8003b6e:	3303      	adds	r3, #3
 8003b70:	f200 8088 	bhi.w	8003c84 <create_chain+0x1d8>
		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
 8003b74:	2301      	movs	r3, #1
 8003b76:	461a      	mov	r2, r3
 8003b78:	4621      	mov	r1, r4
 8003b7a:	4628      	mov	r0, r5
 8003b7c:	f7ff fa46 	bl	800300c <change_bitmap>
		if (res == FR_INT_ERR) return 1;
 8003b80:	2802      	cmp	r0, #2
 8003b82:	d0a5      	beq.n	8003ad0 <create_chain+0x24>
		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
 8003b84:	2801      	cmp	r0, #1
 8003b86:	d063      	beq.n	8003c50 <create_chain+0x1a4>
		if (clst == 0) {							/* Is it a new chain? */
 8003b88:	f1b8 0f00 	cmp.w	r8, #0
 8003b8c:	d102      	bne.n	8003b94 <create_chain+0xe8>
			obj->stat = 2;							/* Set status 'contiguous' */
 8003b8e:	2302      	movs	r3, #2
 8003b90:	71f3      	strb	r3, [r6, #7]
 8003b92:	e04c      	b.n	8003c2e <create_chain+0x182>
			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
 8003b94:	79f3      	ldrb	r3, [r6, #7]
 8003b96:	2b02      	cmp	r3, #2
 8003b98:	d15d      	bne.n	8003c56 <create_chain+0x1aa>
 8003b9a:	1c7b      	adds	r3, r7, #1
 8003b9c:	42a3      	cmp	r3, r4
 8003b9e:	d046      	beq.n	8003c2e <create_chain+0x182>
				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
 8003ba0:	68b3      	ldr	r3, [r6, #8]
 8003ba2:	1afb      	subs	r3, r7, r3
 8003ba4:	61b3      	str	r3, [r6, #24]
				obj->stat = 3;						/* Change status 'just fragmented' */
 8003ba6:	2303      	movs	r3, #3
 8003ba8:	71f3      	strb	r3, [r6, #7]
 8003baa:	e054      	b.n	8003c56 <create_chain+0x1aa>
		if (scl == clst) {						/* Stretching an existing chain? */
 8003bac:	4547      	cmp	r7, r8
 8003bae:	d116      	bne.n	8003bde <create_chain+0x132>
			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
 8003bb0:	1c7c      	adds	r4, r7, #1
			if (ncl >= fs->n_fatent) ncl = 2;
 8003bb2:	42a3      	cmp	r3, r4
 8003bb4:	bf98      	it	ls
 8003bb6:	2402      	movls	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 8003bb8:	4621      	mov	r1, r4
 8003bba:	4630      	mov	r0, r6
 8003bbc:	f7ff fb0a 	bl	80031d4 <get_fat>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8003bc0:	2801      	cmp	r0, #1
 8003bc2:	d085      	beq.n	8003ad0 <create_chain+0x24>
 8003bc4:	1c43      	adds	r3, r0, #1
 8003bc6:	d043      	beq.n	8003c50 <create_chain+0x1a4>
			if (cs != 0) {						/* Not free? */
 8003bc8:	b140      	cbz	r0, 8003bdc <create_chain+0x130>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 8003bca:	f8d5 9014 	ldr.w	r9, [r5, #20]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 8003bce:	f1b9 0f01 	cmp.w	r9, #1
 8003bd2:	d904      	bls.n	8003bde <create_chain+0x132>
 8003bd4:	69eb      	ldr	r3, [r5, #28]
 8003bd6:	4599      	cmp	r9, r3
 8003bd8:	d302      	bcc.n	8003be0 <create_chain+0x134>
 8003bda:	e000      	b.n	8003bde <create_chain+0x132>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 8003bdc:	b9bc      	cbnz	r4, 8003c0e <create_chain+0x162>
			if (ncl >= fs->n_fatent) ncl = 2;
 8003bde:	46b9      	mov	r9, r7
			ncl = scl;	/* Start cluster */
 8003be0:	464c      	mov	r4, r9
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8003be2:	69eb      	ldr	r3, [r5, #28]
				ncl++;							/* Next cluster */
 8003be4:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8003be6:	42a3      	cmp	r3, r4
 8003be8:	d804      	bhi.n	8003bf4 <create_chain+0x148>
					if (ncl > scl) return 0;	/* No free cluster found? */
 8003bea:	f1b9 0f01 	cmp.w	r9, #1
 8003bee:	f43f af7d 	beq.w	8003aec <create_chain+0x40>
					ncl = 2;
 8003bf2:	2402      	movs	r4, #2
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 8003bf4:	4621      	mov	r1, r4
 8003bf6:	4630      	mov	r0, r6
 8003bf8:	f7ff faec 	bl	80031d4 <get_fat>
				if (cs == 0) break;				/* Found a free cluster? */
 8003bfc:	b138      	cbz	r0, 8003c0e <create_chain+0x162>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8003bfe:	2801      	cmp	r0, #1
 8003c00:	f43f af66 	beq.w	8003ad0 <create_chain+0x24>
 8003c04:	3001      	adds	r0, #1
 8003c06:	d023      	beq.n	8003c50 <create_chain+0x1a4>
				if (ncl == scl) return 0;		/* No free cluster found? */
 8003c08:	454c      	cmp	r4, r9
 8003c0a:	d1ea      	bne.n	8003be2 <create_chain+0x136>
 8003c0c:	e76e      	b.n	8003aec <create_chain+0x40>
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
 8003c0e:	f04f 32ff 	mov.w	r2, #4294967295
 8003c12:	4621      	mov	r1, r4
 8003c14:	4628      	mov	r0, r5
 8003c16:	f7ff fa35 	bl	8003084 <put_fat>
		if (res == FR_OK && clst != 0) {
 8003c1a:	b9b0      	cbnz	r0, 8003c4a <create_chain+0x19e>
 8003c1c:	f1b8 0f00 	cmp.w	r8, #0
 8003c20:	d005      	beq.n	8003c2e <create_chain+0x182>
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 8003c22:	4622      	mov	r2, r4
 8003c24:	4641      	mov	r1, r8
 8003c26:	4628      	mov	r0, r5
 8003c28:	f7ff fa2c 	bl	8003084 <put_fat>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8003c2c:	b968      	cbnz	r0, 8003c4a <create_chain+0x19e>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8003c2e:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
 8003c32:	3a02      	subs	r2, #2
 8003c34:	4293      	cmp	r3, r2
 8003c36:	bf9c      	itt	ls
 8003c38:	f103 33ff 	addls.w	r3, r3, #4294967295
 8003c3c:	61ab      	strls	r3, [r5, #24]
		fs->fsi_flag |= 1;
 8003c3e:	792b      	ldrb	r3, [r5, #4]
		fs->last_clst = ncl;
 8003c40:	616c      	str	r4, [r5, #20]
		fs->fsi_flag |= 1;
 8003c42:	f043 0301 	orr.w	r3, r3, #1
 8003c46:	712b      	strb	r3, [r5, #4]
 8003c48:	e01c      	b.n	8003c84 <create_chain+0x1d8>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8003c4a:	2801      	cmp	r0, #1
 8003c4c:	f47f af40 	bne.w	8003ad0 <create_chain+0x24>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 8003c50:	f04f 34ff 	mov.w	r4, #4294967295
 8003c54:	e016      	b.n	8003c84 <create_chain+0x1d8>
			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
 8003c56:	f108 0201 	add.w	r2, r8, #1
 8003c5a:	42a2      	cmp	r2, r4
				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
 8003c5c:	69f3      	ldr	r3, [r6, #28]
			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
 8003c5e:	d104      	bne.n	8003c6a <create_chain+0x1be>
				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
 8003c60:	b10b      	cbz	r3, 8003c66 <create_chain+0x1ba>
 8003c62:	3301      	adds	r3, #1
 8003c64:	e00c      	b.n	8003c80 <create_chain+0x1d4>
 8003c66:	2302      	movs	r3, #2
 8003c68:	e00a      	b.n	8003c80 <create_chain+0x1d4>
				if (obj->n_frag == 0) obj->n_frag = 1;
 8003c6a:	b90b      	cbnz	r3, 8003c70 <create_chain+0x1c4>
 8003c6c:	2301      	movs	r3, #1
 8003c6e:	61f3      	str	r3, [r6, #28]
				res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
 8003c70:	4622      	mov	r2, r4
 8003c72:	4641      	mov	r1, r8
 8003c74:	4630      	mov	r0, r6
 8003c76:	f7ff fa7d 	bl	8003174 <fill_last_frag>
				if (res == FR_OK) obj->n_frag = 1;
 8003c7a:	2800      	cmp	r0, #0
 8003c7c:	d1e5      	bne.n	8003c4a <create_chain+0x19e>
 8003c7e:	2301      	movs	r3, #1
 8003c80:	61f3      	str	r3, [r6, #28]
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8003c82:	e7d4      	b.n	8003c2e <create_chain+0x182>
}
 8003c84:	4620      	mov	r0, r4
 8003c86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08003c8c <dir_next>:
{
 8003c8c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs = dp->obj.fs;
 8003c90:	6806      	ldr	r6, [r0, #0]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8003c92:	6b07      	ldr	r7, [r0, #48]	@ 0x30
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 8003c94:	7833      	ldrb	r3, [r6, #0]
 8003c96:	2b04      	cmp	r3, #4
 8003c98:	bf14      	ite	ne
 8003c9a:	f44f 1300 	movne.w	r3, #2097152	@ 0x200000
 8003c9e:	f04f 5380 	moveq.w	r3, #268435456	@ 0x10000000
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8003ca2:	3720      	adds	r7, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 8003ca4:	42bb      	cmp	r3, r7
 8003ca6:	bf9c      	itt	ls
 8003ca8:	2300      	movls	r3, #0
 8003caa:	6383      	strls	r3, [r0, #56]	@ 0x38
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003cac:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8003cae:	4604      	mov	r4, r0
 8003cb0:	4689      	mov	r9, r1
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003cb2:	b173      	cbz	r3, 8003cd2 <dir_next+0x46>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8003cb4:	f3c7 0808 	ubfx	r8, r7, #0, #9
 8003cb8:	f1b8 0f00 	cmp.w	r8, #0
 8003cbc:	d13b      	bne.n	8003d36 <dir_next+0xaa>
		if (dp->clust == 0) {	/* Static table */
 8003cbe:	6b41      	ldr	r1, [r0, #52]	@ 0x34
		dp->sect++;				/* Next sector */
 8003cc0:	3301      	adds	r3, #1
 8003cc2:	6383      	str	r3, [r0, #56]	@ 0x38
		if (dp->clust == 0) {	/* Static table */
 8003cc4:	b939      	cbnz	r1, 8003cd6 <dir_next+0x4a>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8003cc6:	8933      	ldrh	r3, [r6, #8]
 8003cc8:	ebb3 1f57 	cmp.w	r3, r7, lsr #5
 8003ccc:	d833      	bhi.n	8003d36 <dir_next+0xaa>
				dp->sect = 0; return FR_NO_FILE;
 8003cce:	2300      	movs	r3, #0
 8003cd0:	63a3      	str	r3, [r4, #56]	@ 0x38
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003cd2:	2004      	movs	r0, #4
 8003cd4:	e036      	b.n	8003d44 <dir_next+0xb8>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 8003cd6:	8973      	ldrh	r3, [r6, #10]
 8003cd8:	3b01      	subs	r3, #1
 8003cda:	ea13 2357 	ands.w	r3, r3, r7, lsr #9
 8003cde:	d12a      	bne.n	8003d36 <dir_next+0xaa>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 8003ce0:	f7ff fa78 	bl	80031d4 <get_fat>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8003ce4:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 8003ce6:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8003ce8:	d801      	bhi.n	8003cee <dir_next+0x62>
 8003cea:	2002      	movs	r0, #2
 8003cec:	e02a      	b.n	8003d44 <dir_next+0xb8>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003cee:	1c42      	adds	r2, r0, #1
 8003cf0:	d101      	bne.n	8003cf6 <dir_next+0x6a>
 8003cf2:	2001      	movs	r0, #1
 8003cf4:	e026      	b.n	8003d44 <dir_next+0xb8>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 8003cf6:	69f3      	ldr	r3, [r6, #28]
 8003cf8:	4283      	cmp	r3, r0
 8003cfa:	d816      	bhi.n	8003d2a <dir_next+0x9e>
					if (!stretch) {								/* If no stretch, report EOT */
 8003cfc:	f1b9 0f00 	cmp.w	r9, #0
 8003d00:	d0e5      	beq.n	8003cce <dir_next+0x42>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8003d02:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8003d04:	4620      	mov	r0, r4
 8003d06:	f7ff fed1 	bl	8003aac <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8003d0a:	4605      	mov	r5, r0
 8003d0c:	b1c8      	cbz	r0, 8003d42 <dir_next+0xb6>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8003d0e:	2801      	cmp	r0, #1
 8003d10:	d0eb      	beq.n	8003cea <dir_next+0x5e>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003d12:	1c43      	adds	r3, r0, #1
 8003d14:	d0ed      	beq.n	8003cf2 <dir_next+0x66>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 8003d16:	4601      	mov	r1, r0
 8003d18:	4630      	mov	r0, r6
 8003d1a:	f7ff fbb7 	bl	800348c <dir_clear>
 8003d1e:	2800      	cmp	r0, #0
 8003d20:	d1e7      	bne.n	8003cf2 <dir_next+0x66>
					if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
 8003d22:	79e3      	ldrb	r3, [r4, #7]
 8003d24:	f043 0304 	orr.w	r3, r3, #4
 8003d28:	71e3      	strb	r3, [r4, #7]
				dp->clust = clst;		/* Initialize data for new cluster */
 8003d2a:	6365      	str	r5, [r4, #52]	@ 0x34
				dp->sect = clst2sect(fs, clst);
 8003d2c:	4629      	mov	r1, r5
 8003d2e:	4630      	mov	r0, r6
 8003d30:	f7ff f80a 	bl	8002d48 <clst2sect>
 8003d34:	63a0      	str	r0, [r4, #56]	@ 0x38
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8003d36:	363c      	adds	r6, #60	@ 0x3c
 8003d38:	4446      	add	r6, r8
	dp->dptr = ofs;						/* Current entry */
 8003d3a:	6327      	str	r7, [r4, #48]	@ 0x30
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8003d3c:	63e6      	str	r6, [r4, #60]	@ 0x3c
	return FR_OK;
 8003d3e:	2000      	movs	r0, #0
 8003d40:	e000      	b.n	8003d44 <dir_next+0xb8>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8003d42:	2007      	movs	r0, #7
}
 8003d44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08003d48 <load_xdir>:
{
 8003d48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003d4c:	4605      	mov	r5, r0
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 8003d4e:	6800      	ldr	r0, [r0, #0]
	res = move_window(dp->obj.fs, dp->sect);
 8003d50:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 8003d52:	6906      	ldr	r6, [r0, #16]
	res = move_window(dp->obj.fs, dp->sect);
 8003d54:	f7ff f8e4 	bl	8002f20 <move_window>
	if (res != FR_OK) return res;
 8003d58:	b108      	cbz	r0, 8003d5e <load_xdir+0x16>
 8003d5a:	2401      	movs	r4, #1
 8003d5c:	e05c      	b.n	8003e18 <load_xdir+0xd0>
	if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_INT_ERR;	/* Invalid order */
 8003d5e:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8003d60:	780b      	ldrb	r3, [r1, #0]
 8003d62:	2b85      	cmp	r3, #133	@ 0x85
 8003d64:	d001      	beq.n	8003d6a <load_xdir+0x22>
 8003d66:	2402      	movs	r4, #2
 8003d68:	e056      	b.n	8003e18 <load_xdir+0xd0>
	memcpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
 8003d6a:	2220      	movs	r2, #32
 8003d6c:	4604      	mov	r4, r0
 8003d6e:	4630      	mov	r0, r6
 8003d70:	f7fe ffcc 	bl	8002d0c <mem_cpy>
	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 8003d74:	7873      	ldrb	r3, [r6, #1]
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 8003d76:	f06f 025f 	mvn.w	r2, #95	@ 0x5f
	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 8003d7a:	3301      	adds	r3, #1
 8003d7c:	ea4f 1843 	mov.w	r8, r3, lsl #5
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 8003d80:	eb02 1343 	add.w	r3, r2, r3, lsl #5
 8003d84:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8003d88:	d8ed      	bhi.n	8003d66 <load_xdir+0x1e>
	res = dir_next(dp, 0);
 8003d8a:	4621      	mov	r1, r4
 8003d8c:	4628      	mov	r0, r5
 8003d8e:	f7ff ff7d 	bl	8003c8c <dir_next>
	if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003d92:	2804      	cmp	r0, #4
	res = dir_next(dp, 0);
 8003d94:	4604      	mov	r4, r0
	if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003d96:	d0e6      	beq.n	8003d66 <load_xdir+0x1e>
	if (res != FR_OK) return res;
 8003d98:	2800      	cmp	r0, #0
 8003d9a:	d13d      	bne.n	8003e18 <load_xdir+0xd0>
	res = move_window(dp->obj.fs, dp->sect);
 8003d9c:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
 8003d9e:	6828      	ldr	r0, [r5, #0]
 8003da0:	f7ff f8be 	bl	8002f20 <move_window>
	if (res != FR_OK) return res;
 8003da4:	2800      	cmp	r0, #0
 8003da6:	d1d8      	bne.n	8003d5a <load_xdir+0x12>
	if (dp->dir[XDIR_Type] != ET_STREAM) return FR_INT_ERR;	/* Invalid order */
 8003da8:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8003daa:	780b      	ldrb	r3, [r1, #0]
 8003dac:	2bc0      	cmp	r3, #192	@ 0xc0
 8003dae:	d1da      	bne.n	8003d66 <load_xdir+0x1e>
	memcpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
 8003db0:	2220      	movs	r2, #32
 8003db2:	18b0      	adds	r0, r6, r2
 8003db4:	f7fe ffaa 	bl	8002d0c <mem_cpy>
	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
 8003db8:	f896 3023 	ldrb.w	r3, [r6, #35]	@ 0x23
 8003dbc:	220f      	movs	r2, #15
 8003dbe:	332c      	adds	r3, #44	@ 0x2c
 8003dc0:	fbb3 f3f2 	udiv	r3, r3, r2
 8003dc4:	ebb8 1f43 	cmp.w	r8, r3, lsl #5
 8003dc8:	d3cd      	bcc.n	8003d66 <load_xdir+0x1e>
	i = 2 * SZDIRE;	/* Name offset to load */
 8003dca:	2740      	movs	r7, #64	@ 0x40
		res = dir_next(dp, 0);
 8003dcc:	2100      	movs	r1, #0
 8003dce:	4628      	mov	r0, r5
 8003dd0:	f7ff ff5c 	bl	8003c8c <dir_next>
		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003dd4:	2804      	cmp	r0, #4
		res = dir_next(dp, 0);
 8003dd6:	4604      	mov	r4, r0
		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003dd8:	d0c5      	beq.n	8003d66 <load_xdir+0x1e>
		if (res != FR_OK) return res;
 8003dda:	b9e8      	cbnz	r0, 8003e18 <load_xdir+0xd0>
		res = move_window(dp->obj.fs, dp->sect);
 8003ddc:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
 8003dde:	6828      	ldr	r0, [r5, #0]
 8003de0:	f7ff f89e 	bl	8002f20 <move_window>
		if (res != FR_OK) return res;
 8003de4:	4604      	mov	r4, r0
 8003de6:	2800      	cmp	r0, #0
 8003de8:	d1b7      	bne.n	8003d5a <load_xdir+0x12>
		if (dp->dir[XDIR_Type] != ET_FILENAME) return FR_INT_ERR;	/* Invalid order */
 8003dea:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8003dec:	780b      	ldrb	r3, [r1, #0]
 8003dee:	2bc1      	cmp	r3, #193	@ 0xc1
 8003df0:	d1b9      	bne.n	8003d66 <load_xdir+0x1e>
		if (i < MAXDIRB(FF_MAX_LFN)) memcpy(dirb + i, dp->dir, SZDIRE);
 8003df2:	2f7f      	cmp	r7, #127	@ 0x7f
 8003df4:	d803      	bhi.n	8003dfe <load_xdir+0xb6>
 8003df6:	2220      	movs	r2, #32
 8003df8:	19f0      	adds	r0, r6, r7
 8003dfa:	f7fe ff87 	bl	8002d0c <mem_cpy>
	} while ((i += SZDIRE) < sz_ent);
 8003dfe:	3720      	adds	r7, #32
 8003e00:	45b8      	cmp	r8, r7
 8003e02:	d8e3      	bhi.n	8003dcc <load_xdir+0x84>
	if (i <= MAXDIRB(FF_MAX_LFN)) {
 8003e04:	2f80      	cmp	r7, #128	@ 0x80
 8003e06:	d807      	bhi.n	8003e18 <load_xdir+0xd0>
		if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
 8003e08:	4630      	mov	r0, r6
 8003e0a:	f7fe ffb9 	bl	8002d80 <xdir_sum>
 8003e0e:	8874      	ldrh	r4, [r6, #2]
 8003e10:	1a24      	subs	r4, r4, r0
 8003e12:	bf18      	it	ne
 8003e14:	2401      	movne	r4, #1
 8003e16:	0064      	lsls	r4, r4, #1
}
 8003e18:	4620      	mov	r0, r4
 8003e1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08003e20 <dir_alloc>:
{
 8003e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e22:	460e      	mov	r6, r1
	res = dir_sdi(dp, 0);
 8003e24:	2100      	movs	r1, #0
	FATFS *fs = dp->obj.fs;
 8003e26:	6807      	ldr	r7, [r0, #0]
{
 8003e28:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);
 8003e2a:	f7ff fa65 	bl	80032f8 <dir_sdi>
	if (res == FR_OK) {
 8003e2e:	b9f0      	cbnz	r0, 8003e6e <dir_alloc+0x4e>
		n = 0;
 8003e30:	4605      	mov	r5, r0
			res = move_window(fs, dp->sect);
 8003e32:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003e34:	4638      	mov	r0, r7
 8003e36:	f7ff f873 	bl	8002f20 <move_window>
			if (res != FR_OK) break;
 8003e3a:	b9c0      	cbnz	r0, 8003e6e <dir_alloc+0x4e>
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {	/* Is the entry free? */
 8003e3c:	783a      	ldrb	r2, [r7, #0]
 8003e3e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003e40:	2a04      	cmp	r2, #4
 8003e42:	781b      	ldrb	r3, [r3, #0]
 8003e44:	d102      	bne.n	8003e4c <dir_alloc+0x2c>
 8003e46:	061b      	lsls	r3, r3, #24
 8003e48:	d503      	bpl.n	8003e52 <dir_alloc+0x32>
 8003e4a:	e006      	b.n	8003e5a <dir_alloc+0x3a>
 8003e4c:	2be5      	cmp	r3, #229	@ 0xe5
 8003e4e:	d000      	beq.n	8003e52 <dir_alloc+0x32>
 8003e50:	b91b      	cbnz	r3, 8003e5a <dir_alloc+0x3a>
				if (++n == n_ent) break;	/* Is a block of contiguous free entries found? */
 8003e52:	3501      	adds	r5, #1
 8003e54:	42b5      	cmp	r5, r6
 8003e56:	d101      	bne.n	8003e5c <dir_alloc+0x3c>
 8003e58:	e009      	b.n	8003e6e <dir_alloc+0x4e>
				n = 0;				/* Not a free entry, restart to search */
 8003e5a:	4605      	mov	r5, r0
			res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
 8003e5c:	2101      	movs	r1, #1
 8003e5e:	4620      	mov	r0, r4
 8003e60:	f7ff ff14 	bl	8003c8c <dir_next>
		} while (res == FR_OK);
 8003e64:	2800      	cmp	r0, #0
 8003e66:	d0e4      	beq.n	8003e32 <dir_alloc+0x12>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8003e68:	2804      	cmp	r0, #4
 8003e6a:	bf08      	it	eq
 8003e6c:	2007      	moveq	r0, #7
}
 8003e6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003e70 <store_xdir>:
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
 8003e70:	6803      	ldr	r3, [r0, #0]
{
 8003e72:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
 8003e76:	691e      	ldr	r6, [r3, #16]
{
 8003e78:	4605      	mov	r5, r0
	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
 8003e7a:	4630      	mov	r0, r6
 8003e7c:	f7fe ff80 	bl	8002d80 <xdir_sum>
	res = dir_sdi(dp, dp->blk_ofs);
 8003e80:	6ce9      	ldr	r1, [r5, #76]	@ 0x4c
	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
 8003e82:	8070      	strh	r0, [r6, #2]
	res = dir_sdi(dp, dp->blk_ofs);
 8003e84:	4628      	mov	r0, r5
	nent = dirb[XDIR_NumSec] + 1;
 8003e86:	7877      	ldrb	r7, [r6, #1]
	res = dir_sdi(dp, dp->blk_ofs);
 8003e88:	f7ff fa36 	bl	80032f8 <dir_sdi>
		dp->obj.fs->wflag = 1;
 8003e8c:	f04f 0801 	mov.w	r8, #1
	res = dir_sdi(dp, dp->blk_ofs);
 8003e90:	4604      	mov	r4, r0
	while (res == FR_OK) {
 8003e92:	b9b4      	cbnz	r4, 8003ec2 <store_xdir+0x52>
		res = move_window(dp->obj.fs, dp->sect);
 8003e94:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
 8003e96:	6828      	ldr	r0, [r5, #0]
 8003e98:	f7ff f842 	bl	8002f20 <move_window>
		if (res != FR_OK) break;
 8003e9c:	4604      	mov	r4, r0
 8003e9e:	b980      	cbnz	r0, 8003ec2 <store_xdir+0x52>
		memcpy(dp->dir, dirb, SZDIRE);
 8003ea0:	6be8      	ldr	r0, [r5, #60]	@ 0x3c
 8003ea2:	2220      	movs	r2, #32
 8003ea4:	4631      	mov	r1, r6
 8003ea6:	f7fe ff31 	bl	8002d0c <mem_cpy>
		dp->obj.fs->wflag = 1;
 8003eaa:	682b      	ldr	r3, [r5, #0]
 8003eac:	f883 8003 	strb.w	r8, [r3, #3]
		if (--nent == 0) break;
 8003eb0:	b13f      	cbz	r7, 8003ec2 <store_xdir+0x52>
		res = dir_next(dp, 0);
 8003eb2:	4621      	mov	r1, r4
 8003eb4:	4628      	mov	r0, r5
 8003eb6:	f7ff fee9 	bl	8003c8c <dir_next>
		dirb += SZDIRE;
 8003eba:	3620      	adds	r6, #32
		res = dir_next(dp, 0);
 8003ebc:	4604      	mov	r4, r0
 8003ebe:	3f01      	subs	r7, #1
 8003ec0:	e7e7      	b.n	8003e92 <store_xdir+0x22>
	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
 8003ec2:	2c02      	cmp	r4, #2
 8003ec4:	bf28      	it	cs
 8003ec6:	2402      	movcs	r4, #2
}
 8003ec8:	b2e0      	uxtb	r0, r4
 8003eca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08003ed0 <dir_remove>:
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003ed0:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
{
 8003ed2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003ed4:	1c4b      	adds	r3, r1, #1
	FATFS *fs = dp->obj.fs;
 8003ed6:	6805      	ldr	r5, [r0, #0]
	DWORD last = dp->dptr;
 8003ed8:	6b06      	ldr	r6, [r0, #48]	@ 0x30
{
 8003eda:	4604      	mov	r4, r0
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003edc:	d101      	bne.n	8003ee2 <dir_remove+0x12>
			fs->wflag = 1;
 8003ede:	2701      	movs	r7, #1
 8003ee0:	e003      	b.n	8003eea <dir_remove+0x1a>
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003ee2:	f7ff fa09 	bl	80032f8 <dir_sdi>
	if (res == FR_OK) {
 8003ee6:	b9d8      	cbnz	r0, 8003f20 <dir_remove+0x50>
 8003ee8:	e7f9      	b.n	8003ede <dir_remove+0xe>
			res = move_window(fs, dp->sect);
 8003eea:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003eec:	4628      	mov	r0, r5
 8003eee:	f7ff f817 	bl	8002f20 <move_window>
			if (res != FR_OK) break;
 8003ef2:	b9a8      	cbnz	r0, 8003f20 <dir_remove+0x50>
			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003ef4:	782b      	ldrb	r3, [r5, #0]
				dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
 8003ef6:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003ef8:	2b04      	cmp	r3, #4
				dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
 8003efa:	bf0a      	itet	eq
 8003efc:	7813      	ldrbeq	r3, [r2, #0]
 8003efe:	23e5      	movne	r3, #229	@ 0xe5
 8003f00:	f003 037f 	andeq.w	r3, r3, #127	@ 0x7f
 8003f04:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 8003f06:	70ef      	strb	r7, [r5, #3]
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 8003f08:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003f0a:	42b3      	cmp	r3, r6
 8003f0c:	d208      	bcs.n	8003f20 <dir_remove+0x50>
			res = dir_next(dp, 0);	/* Next entry */
 8003f0e:	2100      	movs	r1, #0
 8003f10:	4620      	mov	r0, r4
 8003f12:	f7ff febb 	bl	8003c8c <dir_next>
		} while (res == FR_OK);
 8003f16:	2800      	cmp	r0, #0
 8003f18:	d0e7      	beq.n	8003eea <dir_remove+0x1a>
		if (res == FR_NO_FILE) res = FR_INT_ERR;
 8003f1a:	2804      	cmp	r0, #4
 8003f1c:	bf08      	it	eq
 8003f1e:	2002      	moveq	r0, #2
}
 8003f20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003f24 <dir_read.constprop.0>:
static FRESULT dir_read (
 8003f24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	BYTE ord = 0xFF, sum = 0xFF;
 8003f28:	27ff      	movs	r7, #255	@ 0xff
	FATFS *fs = dp->obj.fs;
 8003f2a:	6806      	ldr	r6, [r0, #0]
static FRESULT dir_read (
 8003f2c:	4604      	mov	r4, r0
	BYTE ord = 0xFF, sum = 0xFF;
 8003f2e:	463d      	mov	r5, r7
	FRESULT res = FR_NO_FILE;
 8003f30:	2004      	movs	r0, #4
	while (dp->sect) {
 8003f32:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003f34:	2900      	cmp	r1, #0
 8003f36:	d074      	beq.n	8004022 <dir_read.constprop.0+0xfe>
		res = move_window(fs, dp->sect);
 8003f38:	4630      	mov	r0, r6
 8003f3a:	f7fe fff1 	bl	8002f20 <move_window>
		if (res != FR_OK) break;
 8003f3e:	2800      	cmp	r0, #0
 8003f40:	d172      	bne.n	8004028 <dir_read.constprop.0+0x104>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
 8003f42:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8003f44:	7803      	ldrb	r3, [r0, #0]
		if (b == 0) {
 8003f46:	2b00      	cmp	r3, #0
 8003f48:	d06d      	beq.n	8004026 <dir_read.constprop.0+0x102>
		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003f4a:	7832      	ldrb	r2, [r6, #0]
 8003f4c:	2a04      	cmp	r2, #4
 8003f4e:	d10e      	bne.n	8003f6e <dir_read.constprop.0+0x4a>
				if (b == ET_FILEDIR) {		/* Start of the file entry block? */
 8003f50:	2b85      	cmp	r3, #133	@ 0x85
 8003f52:	d15f      	bne.n	8004014 <dir_read.constprop.0+0xf0>
					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 8003f54:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003f56:	64e3      	str	r3, [r4, #76]	@ 0x4c
					res = load_xdir(dp);	/* Load the entry block */
 8003f58:	4620      	mov	r0, r4
 8003f5a:	f7ff fef5 	bl	8003d48 <load_xdir>
					if (res == FR_OK) {
 8003f5e:	2800      	cmp	r0, #0
 8003f60:	d162      	bne.n	8004028 <dir_read.constprop.0+0x104>
						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
 8003f62:	6933      	ldr	r3, [r6, #16]
 8003f64:	791b      	ldrb	r3, [r3, #4]
 8003f66:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8003f6a:	71a3      	strb	r3, [r4, #6]
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 8003f6c:	e04b      	b.n	8004006 <dir_read.constprop.0+0xe2>
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8003f6e:	7ac2      	ldrb	r2, [r0, #11]
			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 8003f70:	2be5      	cmp	r3, #229	@ 0xe5
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8003f72:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
 8003f76:	71a2      	strb	r2, [r4, #6]
			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 8003f78:	d04b      	beq.n	8004012 <dir_read.constprop.0+0xee>
 8003f7a:	2b2e      	cmp	r3, #46	@ 0x2e
 8003f7c:	d049      	beq.n	8004012 <dir_read.constprop.0+0xee>
 8003f7e:	f022 0120 	bic.w	r1, r2, #32
 8003f82:	2908      	cmp	r1, #8
 8003f84:	d045      	beq.n	8004012 <dir_read.constprop.0+0xee>
				if (attr == AM_LFN) {	/* An LFN entry is found */
 8003f86:	2a0f      	cmp	r2, #15
 8003f88:	d138      	bne.n	8003ffc <dir_read.constprop.0+0xd8>
					if (b & LLEF) {		/* Is it start of an LFN sequence? */
 8003f8a:	0659      	lsls	r1, r3, #25
 8003f8c:	d505      	bpl.n	8003f9a <dir_read.constprop.0+0x76>
						b &= (BYTE)~LLEF; ord = b;
 8003f8e:	f003 05bf 	and.w	r5, r3, #191	@ 0xbf
						dp->blk_ofs = dp->dptr;
 8003f92:	6b23      	ldr	r3, [r4, #48]	@ 0x30
						sum = dp->dir[LDIR_Chksum];
 8003f94:	7b47      	ldrb	r7, [r0, #13]
						dp->blk_ofs = dp->dptr;
 8003f96:	64e3      	str	r3, [r4, #76]	@ 0x4c
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8003f98:	e001      	b.n	8003f9e <dir_read.constprop.0+0x7a>
 8003f9a:	42ab      	cmp	r3, r5
 8003f9c:	d139      	bne.n	8004012 <dir_read.constprop.0+0xee>
 8003f9e:	7b43      	ldrb	r3, [r0, #13]
 8003fa0:	42bb      	cmp	r3, r7
 8003fa2:	d136      	bne.n	8004012 <dir_read.constprop.0+0xee>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 8003fa4:	8b42      	ldrh	r2, [r0, #26]
 8003fa6:	bba2      	cbnz	r2, 8004012 <dir_read.constprop.0+0xee>
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 8003fa8:	7803      	ldrb	r3, [r0, #0]
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8003faa:	f8d6 e00c 	ldr.w	lr, [r6, #12]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 8003fae:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 8004030 <dir_read.constprop.0+0x10c>
 8003fb2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8003fb6:	210d      	movs	r1, #13
 8003fb8:	3b01      	subs	r3, #1
 8003fba:	434b      	muls	r3, r1
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8003fbc:	f64f 79ff 	movw	r9, #65535	@ 0xffff
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8003fc0:	2101      	movs	r1, #1
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8003fc2:	f818 cb01 	ldrb.w	ip, [r8], #1
 8003fc6:	f830 c00c 	ldrh.w	ip, [r0, ip]
		if (wc != 0) {
 8003fca:	b131      	cbz	r1, 8003fda <dir_read.constprop.0+0xb6>
			if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 8003fcc:	2b16      	cmp	r3, #22
 8003fce:	d820      	bhi.n	8004012 <dir_read.constprop.0+0xee>
			lfnbuf[i++] = wc = uc;			/* Store it */
 8003fd0:	f82e c013 	strh.w	ip, [lr, r3, lsl #1]
 8003fd4:	4661      	mov	r1, ip
 8003fd6:	3301      	adds	r3, #1
 8003fd8:	e001      	b.n	8003fde <dir_read.constprop.0+0xba>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8003fda:	45cc      	cmp	ip, r9
 8003fdc:	d119      	bne.n	8004012 <dir_read.constprop.0+0xee>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8003fde:	3201      	adds	r2, #1
 8003fe0:	2a0d      	cmp	r2, #13
 8003fe2:	d1ee      	bne.n	8003fc2 <dir_read.constprop.0+0x9e>
	if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put terminator if it is the last LFN part and not terminated */
 8003fe4:	7802      	ldrb	r2, [r0, #0]
 8003fe6:	0652      	lsls	r2, r2, #25
 8003fe8:	d505      	bpl.n	8003ff6 <dir_read.constprop.0+0xd2>
 8003fea:	b121      	cbz	r1, 8003ff6 <dir_read.constprop.0+0xd2>
		if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 8003fec:	2b16      	cmp	r3, #22
 8003fee:	d810      	bhi.n	8004012 <dir_read.constprop.0+0xee>
		lfnbuf[i] = 0;
 8003ff0:	2200      	movs	r2, #0
 8003ff2:	f82e 2013 	strh.w	r2, [lr, r3, lsl #1]
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8003ff6:	3d01      	subs	r5, #1
 8003ff8:	b2ed      	uxtb	r5, r5
 8003ffa:	e00b      	b.n	8004014 <dir_read.constprop.0+0xf0>
					if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 8003ffc:	b92d      	cbnz	r5, 800400a <dir_read.constprop.0+0xe6>
 8003ffe:	f7fe feaf 	bl	8002d60 <sum_sfn>
 8004002:	42b8      	cmp	r0, r7
 8004004:	d101      	bne.n	800400a <dir_read.constprop.0+0xe6>
 8004006:	2000      	movs	r0, #0
 8004008:	e010      	b.n	800402c <dir_read.constprop.0+0x108>
						dp->blk_ofs = 0xFFFFFFFF;	/* It has no LFN. */
 800400a:	f04f 33ff 	mov.w	r3, #4294967295
 800400e:	64e3      	str	r3, [r4, #76]	@ 0x4c
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 8004010:	e7f9      	b.n	8004006 <dir_read.constprop.0+0xe2>
				ord = 0xFF;
 8004012:	25ff      	movs	r5, #255	@ 0xff
		res = dir_next(dp, 0);		/* Next entry */
 8004014:	2100      	movs	r1, #0
 8004016:	4620      	mov	r0, r4
 8004018:	f7ff fe38 	bl	8003c8c <dir_next>
		if (res != FR_OK) break;
 800401c:	2800      	cmp	r0, #0
 800401e:	d088      	beq.n	8003f32 <dir_read.constprop.0+0xe>
 8004020:	e002      	b.n	8004028 <dir_read.constprop.0+0x104>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 8004022:	2800      	cmp	r0, #0
 8004024:	d0ef      	beq.n	8004006 <dir_read.constprop.0+0xe2>
 8004026:	2004      	movs	r0, #4
 8004028:	2300      	movs	r3, #0
 800402a:	63a3      	str	r3, [r4, #56]	@ 0x38
}
 800402c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004030:	08012db8 	.word	0x08012db8

08004034 <dir_find>:
{
 8004034:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004038:	2100      	movs	r1, #0
{
 800403a:	b087      	sub	sp, #28
	FATFS *fs = dp->obj.fs;
 800403c:	f8d0 8000 	ldr.w	r8, [r0]
{
 8004040:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8004042:	f7ff f959 	bl	80032f8 <dir_sdi>
	if (res != FR_OK) return res;
 8004046:	4607      	mov	r7, r0
 8004048:	2800      	cmp	r0, #0
 800404a:	f040 80dc 	bne.w	8004206 <dir_find+0x1d2>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800404e:	f898 3000 	ldrb.w	r3, [r8]
 8004052:	2b04      	cmp	r3, #4
 8004054:	d13b      	bne.n	80040ce <dir_find+0x9a>
		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
 8004056:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800405a:	f7ff fb2b 	bl	80036b4 <xname_sum>
 800405e:	4681      	mov	r9, r0
		while ((res = DIR_READ_FILE(dp)) == FR_OK) {	/* Read an item */
 8004060:	4620      	mov	r0, r4
 8004062:	f7ff ff5f 	bl	8003f24 <dir_read.constprop.0>
 8004066:	4605      	mov	r5, r0
 8004068:	bb78      	cbnz	r0, 80040ca <dir_find+0x96>
			if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;		/* Skip comparison if inaccessible object name */
 800406a:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800406e:	f893 6023 	ldrb.w	r6, [r3, #35]	@ 0x23
 8004072:	2e16      	cmp	r6, #22
 8004074:	d8f4      	bhi.n	8004060 <dir_find+0x2c>
			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
 8004076:	8c9b      	ldrh	r3, [r3, #36]	@ 0x24
 8004078:	454b      	cmp	r3, r9
 800407a:	d1f1      	bne.n	8004060 <dir_find+0x2c>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 800407c:	f04f 0a40 	mov.w	sl, #64	@ 0x40
 8004080:	42b5      	cmp	r5, r6
 8004082:	d013      	beq.n	80040ac <dir_find+0x78>
				if ((di % SZDIRE) == 0) di += 2;
 8004084:	f01a 0f1f 	tst.w	sl, #31
 8004088:	bf08      	it	eq
 800408a:	f10a 0a02 	addeq.w	sl, sl, #2
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800408e:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8004092:	f833 000a 	ldrh.w	r0, [r3, sl]
 8004096:	f001 f8d1 	bl	800523c <ff_wtoupper>
 800409a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800409e:	4683      	mov	fp, r0
 80040a0:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 80040a4:	f001 f8ca 	bl	800523c <ff_wtoupper>
 80040a8:	4583      	cmp	fp, r0
 80040aa:	d003      	beq.n	80040b4 <dir_find+0x80>
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 80040ac:	1b76      	subs	r6, r6, r5
 80040ae:	b2f6      	uxtb	r6, r6
 80040b0:	b126      	cbz	r6, 80040bc <dir_find+0x88>
 80040b2:	e7d5      	b.n	8004060 <dir_find+0x2c>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 80040b4:	f10a 0a02 	add.w	sl, sl, #2
 80040b8:	3501      	adds	r5, #1
 80040ba:	e7e1      	b.n	8004080 <dir_find+0x4c>
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 80040bc:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80040c0:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
 80040c4:	2b00      	cmp	r3, #0
 80040c6:	d1cb      	bne.n	8004060 <dir_find+0x2c>
 80040c8:	e09d      	b.n	8004206 <dir_find+0x1d2>
		return res;
 80040ca:	4607      	mov	r7, r0
 80040cc:	e09b      	b.n	8004206 <dir_find+0x1d2>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80040ce:	f04f 33ff 	mov.w	r3, #4294967295
 80040d2:	64e3      	str	r3, [r4, #76]	@ 0x4c
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !memcmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 80040d4:	f104 0340 	add.w	r3, r4, #64	@ 0x40
 80040d8:	e9cd 0303 	strd	r0, r3, [sp, #12]
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80040dc:	f04f 0aff 	mov.w	sl, #255	@ 0xff
 80040e0:	4655      	mov	r5, sl
		res = move_window(fs, dp->sect);
 80040e2:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 80040e4:	4640      	mov	r0, r8
 80040e6:	f7fe ff1b 	bl	8002f20 <move_window>
		if (res != FR_OK) break;
 80040ea:	2800      	cmp	r0, #0
 80040ec:	f040 8086 	bne.w	80041fc <dir_find+0x1c8>
		c = dp->dir[DIR_Name];
 80040f0:	6be6      	ldr	r6, [r4, #60]	@ 0x3c
 80040f2:	7831      	ldrb	r1, [r6, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80040f4:	2900      	cmp	r1, #0
 80040f6:	f000 8083 	beq.w	8004200 <dir_find+0x1cc>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 80040fa:	7af2      	ldrb	r2, [r6, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 80040fc:	29e5      	cmp	r1, #229	@ 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 80040fe:	f002 033f 	and.w	r3, r2, #63	@ 0x3f
 8004102:	71a3      	strb	r3, [r4, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8004104:	d06a      	beq.n	80041dc <dir_find+0x1a8>
 8004106:	0712      	lsls	r2, r2, #28
 8004108:	d558      	bpl.n	80041bc <dir_find+0x188>
 800410a:	2b0f      	cmp	r3, #15
 800410c:	d166      	bne.n	80041dc <dir_find+0x1a8>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800410e:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 8004112:	065f      	lsls	r7, r3, #25
 8004114:	d46b      	bmi.n	80041ee <dir_find+0x1ba>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 8004116:	0648      	lsls	r0, r1, #25
 8004118:	d506      	bpl.n	8004128 <dir_find+0xf4>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800411a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
						sum = dp->dir[LDIR_Chksum];
 800411c:	f896 a00d 	ldrb.w	sl, [r6, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8004120:	64e3      	str	r3, [r4, #76]	@ 0x4c
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 8004122:	f001 01bf 	and.w	r1, r1, #191	@ 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8004126:	e001      	b.n	800412c <dir_find+0xf8>
 8004128:	428d      	cmp	r5, r1
 800412a:	d15f      	bne.n	80041ec <dir_find+0x1b8>
 800412c:	7b73      	ldrb	r3, [r6, #13]
 800412e:	4553      	cmp	r3, sl
 8004130:	d15c      	bne.n	80041ec <dir_find+0x1b8>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 8004132:	8b73      	ldrh	r3, [r6, #26]
 8004134:	2b00      	cmp	r3, #0
 8004136:	d159      	bne.n	80041ec <dir_find+0x1b8>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8004138:	7835      	ldrb	r5, [r6, #0]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800413a:	f8d8 700c 	ldr.w	r7, [r8, #12]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 800413e:	f8df 90d4 	ldr.w	r9, [pc, #212]	@ 8004214 <dir_find+0x1e0>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004142:	f8cd a004 	str.w	sl, [sp, #4]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8004146:	f005 053f 	and.w	r5, r5, #63	@ 0x3f
 800414a:	230d      	movs	r3, #13
 800414c:	3d01      	subs	r5, #1
 800414e:	435d      	muls	r5, r3
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8004150:	eb09 0203 	add.w	r2, r9, r3
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004154:	46c3      	mov	fp, r8
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8004156:	2301      	movs	r3, #1
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004158:	46b8      	mov	r8, r7
 800415a:	9105      	str	r1, [sp, #20]
 800415c:	4637      	mov	r7, r6
 800415e:	9402      	str	r4, [sp, #8]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8004160:	f819 0b01 	ldrb.w	r0, [r9], #1
 8004164:	f837 a000 	ldrh.w	sl, [r7, r0]
		if (wc != 0) {
 8004168:	b18b      	cbz	r3, 800418e <dir_find+0x15a>
			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800416a:	2d16      	cmp	r5, #22
 800416c:	d83a      	bhi.n	80041e4 <dir_find+0x1b0>
 800416e:	4650      	mov	r0, sl
 8004170:	f001 f864 	bl	800523c <ff_wtoupper>
 8004174:	4604      	mov	r4, r0
 8004176:	f838 0015 	ldrh.w	r0, [r8, r5, lsl #1]
 800417a:	f001 f85f 	bl	800523c <ff_wtoupper>
 800417e:	4284      	cmp	r4, r0
 8004180:	f105 0601 	add.w	r6, r5, #1
 8004184:	d12e      	bne.n	80041e4 <dir_find+0x1b0>
 8004186:	4a22      	ldr	r2, [pc, #136]	@ (8004210 <dir_find+0x1dc>)
			wc = uc;
 8004188:	4653      	mov	r3, sl
			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 800418a:	4635      	mov	r5, r6
 800418c:	e003      	b.n	8004196 <dir_find+0x162>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800418e:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8004192:	458a      	cmp	sl, r1
 8004194:	d126      	bne.n	80041e4 <dir_find+0x1b0>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8004196:	4591      	cmp	r9, r2
 8004198:	d1e2      	bne.n	8004160 <dir_find+0x12c>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 800419a:	463e      	mov	r6, r7
 800419c:	f8dd a004 	ldr.w	sl, [sp, #4]
 80041a0:	7832      	ldrb	r2, [r6, #0]
 80041a2:	9905      	ldr	r1, [sp, #20]
 80041a4:	9c02      	ldr	r4, [sp, #8]
 80041a6:	0652      	lsls	r2, r2, #25
 80041a8:	4647      	mov	r7, r8
 80041aa:	46d8      	mov	r8, fp
 80041ac:	d503      	bpl.n	80041b6 <dir_find+0x182>
 80041ae:	b113      	cbz	r3, 80041b6 <dir_find+0x182>
 80041b0:	f837 3015 	ldrh.w	r3, [r7, r5, lsl #1]
 80041b4:	b9d3      	cbnz	r3, 80041ec <dir_find+0x1b8>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80041b6:	3901      	subs	r1, #1
 80041b8:	b2cd      	uxtb	r5, r1
 80041ba:	e018      	b.n	80041ee <dir_find+0x1ba>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 80041bc:	b925      	cbnz	r5, 80041c8 <dir_find+0x194>
 80041be:	4630      	mov	r0, r6
 80041c0:	f7fe fdce 	bl	8002d60 <sum_sfn>
 80041c4:	4550      	cmp	r0, sl
 80041c6:	d01d      	beq.n	8004204 <dir_find+0x1d0>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !memcmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 80041c8:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 80041cc:	07db      	lsls	r3, r3, #31
 80041ce:	d405      	bmi.n	80041dc <dir_find+0x1a8>
 80041d0:	9904      	ldr	r1, [sp, #16]
 80041d2:	220b      	movs	r2, #11
 80041d4:	4630      	mov	r0, r6
 80041d6:	f7fe fda9 	bl	8002d2c <mem_cmp>
 80041da:	b198      	cbz	r0, 8004204 <dir_find+0x1d0>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80041dc:	f04f 33ff 	mov.w	r3, #4294967295
 80041e0:	64e3      	str	r3, [r4, #76]	@ 0x4c
 80041e2:	e003      	b.n	80041ec <dir_find+0x1b8>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80041e4:	f8dd a004 	ldr.w	sl, [sp, #4]
 80041e8:	9c02      	ldr	r4, [sp, #8]
 80041ea:	46d8      	mov	r8, fp
 80041ec:	25ff      	movs	r5, #255	@ 0xff
		res = dir_next(dp, 0);	/* Next entry */
 80041ee:	2100      	movs	r1, #0
 80041f0:	4620      	mov	r0, r4
 80041f2:	f7ff fd4b 	bl	8003c8c <dir_next>
	} while (res == FR_OK);
 80041f6:	2800      	cmp	r0, #0
 80041f8:	f43f af73 	beq.w	80040e2 <dir_find+0xae>
		res = move_window(fs, dp->sect);
 80041fc:	4607      	mov	r7, r0
 80041fe:	e002      	b.n	8004206 <dir_find+0x1d2>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8004200:	2704      	movs	r7, #4
 8004202:	e000      	b.n	8004206 <dir_find+0x1d2>
 8004204:	9f03      	ldr	r7, [sp, #12]
}
 8004206:	4638      	mov	r0, r7
 8004208:	b007      	add	sp, #28
 800420a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800420e:	bf00      	nop
 8004210:	08012dc5 	.word	0x08012dc5
 8004214:	08012db8 	.word	0x08012db8

08004218 <dir_register>:
{
 8004218:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800421c:	f890 804b 	ldrb.w	r8, [r0, #75]	@ 0x4b
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8004220:	f018 08a0 	ands.w	r8, r8, #160	@ 0xa0
{
 8004224:	b099      	sub	sp, #100	@ 0x64
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8004226:	f040 818e 	bne.w	8004546 <dir_register+0x32e>
	FATFS *fs = dp->obj.fs;
 800422a:	6806      	ldr	r6, [r0, #0]
	for (len = 0; fs->lfnbuf[len]; len++) ;	/* Get lfn length */
 800422c:	68f3      	ldr	r3, [r6, #12]
 800422e:	4604      	mov	r4, r0
 8004230:	f833 2018 	ldrh.w	r2, [r3, r8, lsl #1]
 8004234:	b112      	cbz	r2, 800423c <dir_register+0x24>
 8004236:	f108 0801 	add.w	r8, r8, #1
 800423a:	e7f9      	b.n	8004230 <dir_register+0x18>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 800423c:	7833      	ldrb	r3, [r6, #0]
 800423e:	2b04      	cmp	r3, #4
 8004240:	f040 808f 	bne.w	8004362 <dir_register+0x14a>
		n_ent = (len + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
 8004244:	230f      	movs	r3, #15
 8004246:	f108 080e 	add.w	r8, r8, #14
		res = dir_alloc(dp, n_ent);		/* Allocate directory entries */
 800424a:	4620      	mov	r0, r4
		n_ent = (len + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
 800424c:	fbb8 f8f3 	udiv	r8, r8, r3
		res = dir_alloc(dp, n_ent);		/* Allocate directory entries */
 8004250:	f108 0102 	add.w	r1, r8, #2
 8004254:	f7ff fde4 	bl	8003e20 <dir_alloc>
		if (res != FR_OK) return res;
 8004258:	4605      	mov	r5, r0
 800425a:	2800      	cmp	r0, #0
 800425c:	f040 8174 	bne.w	8004548 <dir_register+0x330>
		dp->blk_ofs = dp->dptr - SZDIRE * (n_ent - 1);	/* Set the allocated entry block offset */
 8004260:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8004262:	f108 0801 	add.w	r8, r8, #1
 8004266:	eba3 1348 	sub.w	r3, r3, r8, lsl #5
 800426a:	64e3      	str	r3, [r4, #76]	@ 0x4c
		if (dp->obj.stat & 4) {			/* Has the directory been stretched by new allocation? */
 800426c:	79e3      	ldrb	r3, [r4, #7]
 800426e:	075f      	lsls	r7, r3, #29
 8004270:	d547      	bpl.n	8004302 <dir_register+0xea>
			dp->obj.stat &= ~4;
 8004272:	f023 0304 	bic.w	r3, r3, #4
 8004276:	71e3      	strb	r3, [r4, #7]
			res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
 8004278:	4620      	mov	r0, r4
 800427a:	f7fe ff93 	bl	80031a4 <fill_first_frag>
			if (res != FR_OK) return res;
 800427e:	2800      	cmp	r0, #0
 8004280:	f040 8162 	bne.w	8004548 <dir_register+0x330>
			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
 8004284:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8004286:	f04f 32ff 	mov.w	r2, #4294967295
 800428a:	4620      	mov	r0, r4
 800428c:	f7fe ff72 	bl	8003174 <fill_last_frag>
			if (res != FR_OK) return res;
 8004290:	2800      	cmp	r0, #0
 8004292:	f040 8159 	bne.w	8004548 <dir_register+0x330>
			if (dp->obj.sclust != 0) {		/* Is it a sub-directory? */
 8004296:	68a3      	ldr	r3, [r4, #8]
 8004298:	2b00      	cmp	r3, #0
 800429a:	d032      	beq.n	8004302 <dir_register+0xea>
	dp->obj.fs = obj->fs;
 800429c:	6823      	ldr	r3, [r4, #0]
 800429e:	9302      	str	r3, [sp, #8]
	dp->obj.sclust = obj->c_scl;
 80042a0:	6a23      	ldr	r3, [r4, #32]
 80042a2:	9304      	str	r3, [sp, #16]
	dp->obj.stat = (BYTE)obj->c_size;
 80042a4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80042a6:	f88d 300f 	strb.w	r3, [sp, #15]
	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 80042aa:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80042ae:	e9cd 3006 	strd	r3, r0, [sp, #24]
	dp->blk_ofs = obj->c_ofs;
 80042b2:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
	dp->obj.n_frag = 0;
 80042b4:	9009      	str	r0, [sp, #36]	@ 0x24
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 80042b6:	a802      	add	r0, sp, #8
	dp->blk_ofs = obj->c_ofs;
 80042b8:	9115      	str	r1, [sp, #84]	@ 0x54
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 80042ba:	f7ff f81d 	bl	80032f8 <dir_sdi>
	if (res == FR_OK) {
 80042be:	2800      	cmp	r0, #0
 80042c0:	f040 8142 	bne.w	8004548 <dir_register+0x330>
		res = load_xdir(dp);		/* Load the object's entry block */
 80042c4:	a802      	add	r0, sp, #8
 80042c6:	f7ff fd3f 	bl	8003d48 <load_xdir>
				if (res != FR_OK) return res;
 80042ca:	2800      	cmp	r0, #0
 80042cc:	f040 813c 	bne.w	8004548 <dir_register+0x330>
				dp->obj.objsize += (DWORD)fs->csize * SS(fs);		/* Increase the directory size by cluster size */
 80042d0:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
 80042d4:	8970      	ldrh	r0, [r6, #10]
 80042d6:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80042da:	fbe0 3102 	umlal	r3, r1, r0, r2
				st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);
 80042de:	6932      	ldr	r2, [r6, #16]
				dp->obj.objsize += (DWORD)fs->csize * SS(fs);		/* Increase the directory size by cluster size */
 80042e0:	e9c4 3104 	strd	r3, r1, [r4, #16]
				st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);
 80042e4:	e9c2 310e 	strd	r3, r1, [r2, #56]	@ 0x38
				st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
 80042e8:	e9c2 310a 	strd	r3, r1, [r2, #40]	@ 0x28
				fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;		/* Update the allocation status */
 80042ec:	79e3      	ldrb	r3, [r4, #7]
 80042ee:	f043 0301 	orr.w	r3, r3, #1
 80042f2:	f882 3021 	strb.w	r3, [r2, #33]	@ 0x21
				res = store_xdir(&dj);				/* Store the object status */
 80042f6:	a802      	add	r0, sp, #8
 80042f8:	f7ff fdba 	bl	8003e70 <store_xdir>
				if (res != FR_OK) return res;
 80042fc:	2800      	cmp	r0, #0
 80042fe:	f040 8123 	bne.w	8004548 <dir_register+0x330>
		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
 8004302:	e9d6 6403 	ldrd	r6, r4, [r6, #12]
	memset(dirb, 0, 2 * SZDIRE);
 8004306:	2240      	movs	r2, #64	@ 0x40
 8004308:	2100      	movs	r1, #0
	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
 800430a:	2385      	movs	r3, #133	@ 0x85
	memset(dirb, 0, 2 * SZDIRE);
 800430c:	4620      	mov	r0, r4
 800430e:	f7fe fd07 	bl	8002d20 <mem_set>
	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
 8004312:	7023      	strb	r3, [r4, #0]
	dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;
 8004314:	23c0      	movs	r3, #192	@ 0xc0
 8004316:	f884 3020 	strb.w	r3, [r4, #32]
	nlen = nc1 = 0; wc = 1;
 800431a:	2201      	movs	r2, #1
	i = SZDIRE * 2;	/* Top of file_name entries */
 800431c:	2340      	movs	r3, #64	@ 0x40
		dirb[i++] = ET_FILENAME; dirb[i++] = 0;
 800431e:	f04f 0cc1 	mov.w	ip, #193	@ 0xc1
 8004322:	460f      	mov	r7, r1
 8004324:	1c58      	adds	r0, r3, #1
 8004326:	f804 c003 	strb.w	ip, [r4, r3]
 800432a:	5427      	strb	r7, [r4, r0]
 800432c:	3302      	adds	r3, #2
			if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
 800432e:	b122      	cbz	r2, 800433a <dir_register+0x122>
 8004330:	f836 2015 	ldrh.w	r2, [r6, r5, lsl #1]
 8004334:	b10a      	cbz	r2, 800433a <dir_register+0x122>
 8004336:	3501      	adds	r5, #1
 8004338:	b2ed      	uxtb	r5, r5
			st_word(dirb + i, wc); 	/* Store it */
 800433a:	52e2      	strh	r2, [r4, r3]
			i += 2;
 800433c:	3302      	adds	r3, #2
		} while (i % SZDIRE != 0);
 800433e:	06d8      	lsls	r0, r3, #27
 8004340:	d1f5      	bne.n	800432e <dir_register+0x116>
	} while (lfn[nlen]);	/* Fill next entry if any char follows */
 8004342:	f836 0015 	ldrh.w	r0, [r6, r5, lsl #1]
 8004346:	f101 0e01 	add.w	lr, r1, #1
 800434a:	b108      	cbz	r0, 8004350 <dir_register+0x138>
 800434c:	4671      	mov	r1, lr
 800434e:	e7e9      	b.n	8004324 <dir_register+0x10c>
	dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
 8004350:	3102      	adds	r1, #2
	dirb[XDIR_NumName] = nlen;		/* Set name length */
 8004352:	f884 5023 	strb.w	r5, [r4, #35]	@ 0x23
	dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
 8004356:	7061      	strb	r1, [r4, #1]
	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
 8004358:	4630      	mov	r0, r6
 800435a:	f7ff f9ab 	bl	80036b4 <xname_sum>
 800435e:	84a0      	strh	r0, [r4, #36]	@ 0x24
}
 8004360:	e0ef      	b.n	8004542 <dir_register+0x32a>
	memcpy(sn, dp->fn, 12);
 8004362:	f104 0740 	add.w	r7, r4, #64	@ 0x40
 8004366:	220c      	movs	r2, #12
 8004368:	4639      	mov	r1, r7
 800436a:	a802      	add	r0, sp, #8
 800436c:	f7fe fcce 	bl	8002d0c <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 8004370:	f89d a013 	ldrb.w	sl, [sp, #19]
 8004374:	f01a 0f01 	tst.w	sl, #1
 8004378:	d06c      	beq.n	8004454 <dir_register+0x23c>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800437a:	2340      	movs	r3, #64	@ 0x40
				if (sreg & 0x10000) sreg ^= 0x11021;
 800437c:	4d74      	ldr	r5, [pc, #464]	@ (8004550 <dir_register+0x338>)
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800437e:	f884 304b 	strb.w	r3, [r4, #75]	@ 0x4b
		for (n = 1; n < 100; n++) {
 8004382:	f04f 0901 	mov.w	r9, #1
	memcpy(dst, src, 11);	/* Prepare the SFN to be modified */
 8004386:	220b      	movs	r2, #11
 8004388:	a902      	add	r1, sp, #8
 800438a:	4638      	mov	r0, r7
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 800438c:	f8d6 b00c 	ldr.w	fp, [r6, #12]
	memcpy(dst, src, 11);	/* Prepare the SFN to be modified */
 8004390:	f7fe fcbc 	bl	8002d0c <mem_cpy>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8004394:	f1b9 0f05 	cmp.w	r9, #5
 8004398:	d913      	bls.n	80043c2 <dir_register+0x1aa>
 800439a:	f1ab 0202 	sub.w	r2, fp, #2
		sreg = seq;
 800439e:	464b      	mov	r3, r9
		while (*lfn) {	/* Create a CRC as hash value */
 80043a0:	f832 1f02 	ldrh.w	r1, [r2, #2]!
 80043a4:	b171      	cbz	r1, 80043c4 <dir_register+0x1ac>
 80043a6:	2010      	movs	r0, #16
				sreg = (sreg << 1) + (wc & 1);
 80043a8:	f001 0c01 	and.w	ip, r1, #1
 80043ac:	eb0c 0343 	add.w	r3, ip, r3, lsl #1
				if (sreg & 0x10000) sreg ^= 0x11021;
 80043b0:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 80043b4:	bf18      	it	ne
 80043b6:	406b      	eorne	r3, r5
			for (i = 0; i < 16; i++) {
 80043b8:	3801      	subs	r0, #1
				wc >>= 1;
 80043ba:	ea4f 0151 	mov.w	r1, r1, lsr #1
			for (i = 0; i < 16; i++) {
 80043be:	d1f3      	bne.n	80043a8 <dir_register+0x190>
 80043c0:	e7ee      	b.n	80043a0 <dir_register+0x188>
 80043c2:	464b      	mov	r3, r9
 80043c4:	a802      	add	r0, sp, #8
 80043c6:	2207      	movs	r2, #7
		c = (BYTE)((seq % 16) + '0'); seq /= 16;
 80043c8:	f003 0c0f 	and.w	ip, r3, #15
 80043cc:	f10c 0130 	add.w	r1, ip, #48	@ 0x30
		if (c > '9') c += 7;
 80043d0:	2939      	cmp	r1, #57	@ 0x39
 80043d2:	bf88      	it	hi
 80043d4:	f10c 0137 	addhi.w	r1, ip, #55	@ 0x37
	} while (i && seq);
 80043d8:	3a01      	subs	r2, #1
 80043da:	469e      	mov	lr, r3
		ns[i--] = c;
 80043dc:	f800 1d01 	strb.w	r1, [r0, #-1]!
		c = (BYTE)((seq % 16) + '0'); seq /= 16;
 80043e0:	ea4f 1313 	mov.w	r3, r3, lsr #4
	} while (i && seq);
 80043e4:	d002      	beq.n	80043ec <dir_register+0x1d4>
 80043e6:	f1be 0f0f 	cmp.w	lr, #15
 80043ea:	d8ed      	bhi.n	80043c8 <dir_register+0x1b0>
	ns[i] = '~';
 80043ec:	f102 0360 	add.w	r3, r2, #96	@ 0x60
 80043f0:	446b      	add	r3, sp
 80043f2:	217e      	movs	r1, #126	@ 0x7e
 80043f4:	f803 1c60 	strb.w	r1, [r3, #-96]
	for (j = 0; j < i && dst[j] != ' '; j++) {	/* Find the offset to append */
 80043f8:	f104 013f 	add.w	r1, r4, #63	@ 0x3f
 80043fc:	2300      	movs	r3, #0
 80043fe:	4293      	cmp	r3, r2
 8004400:	d007      	beq.n	8004412 <dir_register+0x1fa>
 8004402:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8004406:	2820      	cmp	r0, #32
 8004408:	f103 0c01 	add.w	ip, r3, #1
 800440c:	d001      	beq.n	8004412 <dir_register+0x1fa>
 800440e:	4663      	mov	r3, ip
 8004410:	e7f5      	b.n	80043fe <dir_register+0x1e6>
 8004412:	333f      	adds	r3, #63	@ 0x3f
 8004414:	4423      	add	r3, r4
 8004416:	f104 0047 	add.w	r0, r4, #71	@ 0x47
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 800441a:	2a07      	cmp	r2, #7
 800441c:	d806      	bhi.n	800442c <dir_register+0x214>
 800441e:	f102 0160 	add.w	r1, r2, #96	@ 0x60
 8004422:	4469      	add	r1, sp
 8004424:	3201      	adds	r2, #1
 8004426:	f811 1c60 	ldrb.w	r1, [r1, #-96]
 800442a:	e000      	b.n	800442e <dir_register+0x216>
 800442c:	2120      	movs	r1, #32
 800442e:	f803 1f01 	strb.w	r1, [r3, #1]!
	} while (j < 8);
 8004432:	4298      	cmp	r0, r3
 8004434:	d1f1      	bne.n	800441a <dir_register+0x202>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 8004436:	4620      	mov	r0, r4
 8004438:	f7ff fdfc 	bl	8004034 <dir_find>
			if (res != FR_OK) break;
 800443c:	b930      	cbnz	r0, 800444c <dir_register+0x234>
		for (n = 1; n < 100; n++) {
 800443e:	f109 0901 	add.w	r9, r9, #1
 8004442:	f1b9 0f64 	cmp.w	r9, #100	@ 0x64
 8004446:	d19e      	bne.n	8004386 <dir_register+0x16e>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8004448:	2007      	movs	r0, #7
 800444a:	e07d      	b.n	8004548 <dir_register+0x330>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 800444c:	2804      	cmp	r0, #4
 800444e:	d17b      	bne.n	8004548 <dir_register+0x330>
		dp->fn[NSFLAG] = sn[NSFLAG];
 8004450:	f884 a04b 	strb.w	sl, [r4, #75]	@ 0x4b
	n_ent = (sn[NSFLAG] & NS_LFN) ? (len + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8004454:	f01a 0f02 	tst.w	sl, #2
 8004458:	d006      	beq.n	8004468 <dir_register+0x250>
 800445a:	f108 050c 	add.w	r5, r8, #12
 800445e:	230d      	movs	r3, #13
 8004460:	fbb5 f5f3 	udiv	r5, r5, r3
 8004464:	3501      	adds	r5, #1
 8004466:	e000      	b.n	800446a <dir_register+0x252>
 8004468:	2501      	movs	r5, #1
	res = dir_alloc(dp, n_ent);		/* Allocate entries */
 800446a:	4629      	mov	r1, r5
 800446c:	4620      	mov	r0, r4
 800446e:	f7ff fcd7 	bl	8003e20 <dir_alloc>
	if (res == FR_OK && --n_ent) {	/* Set LFN entry if needed */
 8004472:	2800      	cmp	r0, #0
 8004474:	d168      	bne.n	8004548 <dir_register+0x330>
 8004476:	3d01      	subs	r5, #1
 8004478:	d118      	bne.n	80044ac <dir_register+0x294>
		res = move_window(fs, dp->sect);
 800447a:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 800447c:	4630      	mov	r0, r6
 800447e:	f7fe fd4f 	bl	8002f20 <move_window>
		if (res == FR_OK) {
 8004482:	2800      	cmp	r0, #0
 8004484:	d160      	bne.n	8004548 <dir_register+0x330>
			memset(dp->dir, 0, SZDIRE);	/* Clean the entry */
 8004486:	4601      	mov	r1, r0
 8004488:	2220      	movs	r2, #32
 800448a:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 800448c:	f7fe fc48 	bl	8002d20 <mem_set>
			memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 8004490:	220b      	movs	r2, #11
 8004492:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8004494:	4639      	mov	r1, r7
 8004496:	f7fe fc39 	bl	8002d0c <mem_cpy>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 800449a:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 800449e:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 80044a0:	f003 0318 	and.w	r3, r3, #24
 80044a4:	7313      	strb	r3, [r2, #12]
			fs->wflag = 1;
 80044a6:	2301      	movs	r3, #1
 80044a8:	70f3      	strb	r3, [r6, #3]
 80044aa:	e04a      	b.n	8004542 <dir_register+0x32a>
		res = dir_sdi(dp, dp->dptr - n_ent * SZDIRE);
 80044ac:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 80044ae:	4620      	mov	r0, r4
 80044b0:	eba1 1145 	sub.w	r1, r1, r5, lsl #5
 80044b4:	f7fe ff20 	bl	80032f8 <dir_sdi>
		if (res == FR_OK) {
 80044b8:	2800      	cmp	r0, #0
 80044ba:	d145      	bne.n	8004548 <dir_register+0x330>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 80044bc:	4638      	mov	r0, r7
 80044be:	f7fe fc4f 	bl	8002d60 <sum_sfn>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80044c2:	f64f 79ff 	movw	r9, #65535	@ 0xffff
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 80044c6:	4680      	mov	r8, r0
				res = move_window(fs, dp->sect);
 80044c8:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 80044ca:	4630      	mov	r0, r6
 80044cc:	f7fe fd28 	bl	8002f20 <move_window>
 80044d0:	4603      	mov	r3, r0
				if (res != FR_OK) break;
 80044d2:	bbc8      	cbnz	r0, 8004548 <dir_register+0x330>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)n_ent, sum);
 80044d4:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 80044d6:	f8d6 e00c 	ldr.w	lr, [r6, #12]
 80044da:	f8df a078 	ldr.w	sl, [pc, #120]	@ 8004554 <dir_register+0x33c>
	dir[LDIR_Type] = 0;
 80044de:	7310      	strb	r0, [r2, #12]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80044e0:	f04f 010f 	mov.w	r1, #15
 80044e4:	fa5f fc85 	uxtb.w	ip, r5
 80044e8:	72d1      	strb	r1, [r2, #11]
	st_word(dir + LDIR_FstClusLO, 0);
 80044ea:	8350      	strh	r0, [r2, #26]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80044ec:	f10c 31ff 	add.w	r1, ip, #4294967295
 80044f0:	200d      	movs	r0, #13
 80044f2:	4341      	muls	r1, r0
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 80044f4:	f882 800d 	strb.w	r8, [r2, #13]
	s = wc = 0;
 80044f8:	4618      	mov	r0, r3
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80044fa:	4548      	cmp	r0, r9
 80044fc:	bf18      	it	ne
 80044fe:	f83e 0011 	ldrhne.w	r0, [lr, r1, lsl #1]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 8004502:	f81a bb01 	ldrb.w	fp, [sl], #1
	} while (++s < 13);
 8004506:	f103 0301 	add.w	r3, r3, #1
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800450a:	bf18      	it	ne
 800450c:	3101      	addne	r1, #1
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 800450e:	f822 000b 	strh.w	r0, [r2, fp]
		if (wc == 0) wc = 0xFFFF;			/* Padding characters for following items */
 8004512:	2800      	cmp	r0, #0
 8004514:	bf08      	it	eq
 8004516:	4648      	moveq	r0, r9
	} while (++s < 13);
 8004518:	2b0d      	cmp	r3, #13
 800451a:	d1ee      	bne.n	80044fa <dir_register+0x2e2>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 800451c:	4548      	cmp	r0, r9
 800451e:	d002      	beq.n	8004526 <dir_register+0x30e>
 8004520:	f83e 3011 	ldrh.w	r3, [lr, r1, lsl #1]
 8004524:	b90b      	cbnz	r3, 800452a <dir_register+0x312>
 8004526:	f04c 0c40 	orr.w	ip, ip, #64	@ 0x40
				fs->wflag = 1;
 800452a:	2301      	movs	r3, #1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 800452c:	f882 c000 	strb.w	ip, [r2]
				res = dir_next(dp, 0);	/* Next entry */
 8004530:	2100      	movs	r1, #0
				fs->wflag = 1;
 8004532:	70f3      	strb	r3, [r6, #3]
				res = dir_next(dp, 0);	/* Next entry */
 8004534:	4620      	mov	r0, r4
 8004536:	f7ff fba9 	bl	8003c8c <dir_next>
			} while (res == FR_OK && --n_ent);
 800453a:	b928      	cbnz	r0, 8004548 <dir_register+0x330>
 800453c:	3d01      	subs	r5, #1
 800453e:	d1c3      	bne.n	80044c8 <dir_register+0x2b0>
 8004540:	e79b      	b.n	800447a <dir_register+0x262>
		return FR_OK;
 8004542:	2000      	movs	r0, #0
 8004544:	e000      	b.n	8004548 <dir_register+0x330>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8004546:	2006      	movs	r0, #6
}
 8004548:	b019      	add	sp, #100	@ 0x64
 800454a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800454e:	bf00      	nop
 8004550:	00011021 	.word	0x00011021
 8004554:	08012db8 	.word	0x08012db8

08004558 <init_alloc_info.isra.0>:
	obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Start cluster */
 8004558:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 800455a:	608b      	str	r3, [r1, #8]
	obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 800455c:	e9d0 230e 	ldrd	r2, r3, [r0, #56]	@ 0x38
 8004560:	e9c1 2304 	strd	r2, r3, [r1, #16]
	obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;				/* Allocation status */
 8004564:	f890 3021 	ldrb.w	r3, [r0, #33]	@ 0x21
 8004568:	f003 0302 	and.w	r3, r3, #2
 800456c:	71cb      	strb	r3, [r1, #7]
	obj->n_frag = 0;										/* No last fragment info */
 800456e:	2300      	movs	r3, #0
 8004570:	61cb      	str	r3, [r1, #28]
}
 8004572:	4770      	bx	lr

08004574 <ld_clust.isra.0>:
	if (fs->fs_type == FS_FAT32) {
 8004574:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004576:	8b4b      	ldrh	r3, [r1, #26]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8004578:	bf04      	itt	eq
 800457a:	8a8a      	ldrheq	r2, [r1, #20]
 800457c:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16
}
 8004580:	4618      	mov	r0, r3
 8004582:	4770      	bx	lr

08004584 <follow_path>:
{
 8004584:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004588:	b085      	sub	sp, #20
	FATFS *fs = dp->obj.fs;
 800458a:	6803      	ldr	r3, [r0, #0]
 800458c:	9302      	str	r3, [sp, #8]
{
 800458e:	4605      	mov	r5, r0
 8004590:	468b      	mov	fp, r1
		while (IsSeparator(*path)) path++;	/* Strip separators */
 8004592:	f811 3b01 	ldrb.w	r3, [r1], #1
 8004596:	2b2f      	cmp	r3, #47	@ 0x2f
 8004598:	d0fa      	beq.n	8004590 <follow_path+0xc>
 800459a:	2b5c      	cmp	r3, #92	@ 0x5c
 800459c:	d0f8      	beq.n	8004590 <follow_path+0xc>
		dp->obj.sclust = 0;					/* Start from the root directory */
 800459e:	2300      	movs	r3, #0
 80045a0:	60ab      	str	r3, [r5, #8]
	dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
 80045a2:	61eb      	str	r3, [r5, #28]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 80045a4:	f89b 3000 	ldrb.w	r3, [fp]
 80045a8:	2b1f      	cmp	r3, #31
 80045aa:	f200 80b3 	bhi.w	8004714 <follow_path+0x190>
		dp->fn[NSFLAG] = NS_NONAME;
 80045ae:	2380      	movs	r3, #128	@ 0x80
		res = dir_sdi(dp, 0);
 80045b0:	2100      	movs	r1, #0
 80045b2:	4628      	mov	r0, r5
		dp->fn[NSFLAG] = NS_NONAME;
 80045b4:	f885 304b 	strb.w	r3, [r5, #75]	@ 0x4b
}
 80045b8:	b005      	add	sp, #20
 80045ba:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 80045be:	f7fe be9b 	b.w	80032f8 <dir_sdi>
		wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
 80045c2:	f240 3162 	movw	r1, #866	@ 0x362
 80045c6:	f000 fe25 	bl	8005214 <ff_oem2uni>
		if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
 80045ca:	2800      	cmp	r0, #0
 80045cc:	f000 813f 	beq.w	800484e <follow_path+0x2ca>
		if (wc < ' ' || IsSeparator(wc)) break;	/* Break if end of the path or a separator is found */
 80045d0:	281f      	cmp	r0, #31
 80045d2:	d917      	bls.n	8004604 <follow_path+0x80>
 80045d4:	282f      	cmp	r0, #47	@ 0x2f
 80045d6:	f000 8146 	beq.w	8004866 <follow_path+0x2e2>
 80045da:	285c      	cmp	r0, #92	@ 0x5c
 80045dc:	f000 8143 	beq.w	8004866 <follow_path+0x2e2>
		if (wc < 0x80 && strchr("*:<>|\"\?\x7F", (int)wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 80045e0:	287f      	cmp	r0, #127	@ 0x7f
 80045e2:	d805      	bhi.n	80045f0 <follow_path+0x6c>
 80045e4:	4ba9      	ldr	r3, [pc, #676]	@ (800488c <follow_path+0x308>)
	while (*str && *str != chr) str++;
 80045e6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80045ea:	2a00      	cmp	r2, #0
 80045ec:	f040 8097 	bne.w	800471e <follow_path+0x19a>
		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 80045f0:	2e16      	cmp	r6, #22
 80045f2:	f000 812c 	beq.w	800484e <follow_path+0x2ca>
		lfn[di++] = wc;				/* Store the Unicode character */
 80045f6:	f829 0016 	strh.w	r0, [r9, r6, lsl #1]
		uc = tchar2uni(&p);			/* Get a character */
 80045fa:	3601      	adds	r6, #1
	wc = (BYTE)*p++;			/* Get a byte */
 80045fc:	f81b 0b01 	ldrb.w	r0, [fp], #1
	if (wc != 0) {
 8004600:	2800      	cmp	r0, #0
 8004602:	d1de      	bne.n	80045c2 <follow_path+0x3e>
		cf = NS_LAST;			/* Last segment */
 8004604:	2404      	movs	r4, #4
	while (di) {					/* Snip off trailing spaces and dots if exist */
 8004606:	eb09 0346 	add.w	r3, r9, r6, lsl #1
 800460a:	b13e      	cbz	r6, 800461c <follow_path+0x98>
		wc = lfn[di - 1];
 800460c:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
		if (wc != ' ' && wc != '.') break;
 8004610:	2a20      	cmp	r2, #32
 8004612:	f000 8088 	beq.w	8004726 <follow_path+0x1a2>
 8004616:	2a2e      	cmp	r2, #46	@ 0x2e
 8004618:	f000 8085 	beq.w	8004726 <follow_path+0x1a2>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 800461c:	f04f 0300 	mov.w	r3, #0
 8004620:	f829 3016 	strh.w	r3, [r9, r6, lsl #1]
 8004624:	eb09 0246 	add.w	r2, r9, r6, lsl #1
	if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
 8004628:	2e00      	cmp	r6, #0
 800462a:	f000 8110 	beq.w	800484e <follow_path+0x2ca>
	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 800462e:	2100      	movs	r1, #0
 8004630:	f839 0011 	ldrh.w	r0, [r9, r1, lsl #1]
 8004634:	2820      	cmp	r0, #32
 8004636:	460b      	mov	r3, r1
 8004638:	f101 0101 	add.w	r1, r1, #1
 800463c:	d0f8      	beq.n	8004630 <follow_path+0xac>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 800463e:	2b00      	cmp	r3, #0
 8004640:	d173      	bne.n	800472a <follow_path+0x1a6>
 8004642:	282e      	cmp	r0, #46	@ 0x2e
 8004644:	d071      	beq.n	800472a <follow_path+0x1a6>
	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
 8004646:	f832 1d02 	ldrh.w	r1, [r2, #-2]!
 800464a:	292e      	cmp	r1, #46	@ 0x2e
 800464c:	d001      	beq.n	8004652 <follow_path+0xce>
 800464e:	3e01      	subs	r6, #1
 8004650:	d1f9      	bne.n	8004646 <follow_path+0xc2>
	memset(dp->fn, ' ', 11);
 8004652:	220b      	movs	r2, #11
 8004654:	2120      	movs	r1, #32
 8004656:	f105 0040 	add.w	r0, r5, #64	@ 0x40
	i = b = 0; ni = 8;
 800465a:	2700      	movs	r7, #0
	memset(dp->fn, ' ', 11);
 800465c:	f7fe fb60 	bl	8002d20 <mem_set>
	i = b = 0; ni = 8;
 8004660:	f04f 0808 	mov.w	r8, #8
 8004664:	464a      	mov	r2, r9
 8004666:	f8cd b004 	str.w	fp, [sp, #4]
 800466a:	46ba      	mov	sl, r7
 800466c:	46b1      	mov	r9, r6
 800466e:	46ab      	mov	fp, r5
		wc = lfn[si++];					/* Get an LFN character */
 8004670:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
 8004674:	1c5e      	adds	r6, r3, #1
		if (wc == 0) break;				/* Break on end of the LFN */
 8004676:	2800      	cmp	r0, #0
 8004678:	f000 80c0 	beq.w	80047fc <follow_path+0x278>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 800467c:	2820      	cmp	r0, #32
 800467e:	d05b      	beq.n	8004738 <follow_path+0x1b4>
 8004680:	282e      	cmp	r0, #46	@ 0x2e
 8004682:	d056      	beq.n	8004732 <follow_path+0x1ae>
		if (i >= ni || si == di) {		/* End of field? */
 8004684:	4547      	cmp	r7, r8
 8004686:	d35c      	bcc.n	8004742 <follow_path+0x1be>
			if (ni == 11) {				/* Name extension overflow? */
 8004688:	f1b8 0f0b 	cmp.w	r8, #11
 800468c:	d15c      	bne.n	8004748 <follow_path+0x1c4>
 800468e:	465d      	mov	r5, fp
				cf |= NS_LOSS | NS_LFN;
 8004690:	f044 0403 	orr.w	r4, r4, #3
 8004694:	f8dd b004 	ldr.w	fp, [sp, #4]
 8004698:	b2e4      	uxtb	r4, r4
				break;
 800469a:	f04f 080b 	mov.w	r8, #11
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800469e:	f895 3040 	ldrb.w	r3, [r5, #64]	@ 0x40
 80046a2:	2be5      	cmp	r3, #229	@ 0xe5
 80046a4:	bf04      	itt	eq
 80046a6:	2305      	moveq	r3, #5
 80046a8:	f885 3040 	strbeq.w	r3, [r5, #64]	@ 0x40
	if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
 80046ac:	f1b8 0f08 	cmp.w	r8, #8
 80046b0:	bf04      	itt	eq
 80046b2:	ea4f 018a 	moveq.w	r1, sl, lsl #2
 80046b6:	fa5f fa81 	uxtbeq.w	sl, r1
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 80046ba:	f00a 030c 	and.w	r3, sl, #12
 80046be:	2b0c      	cmp	r3, #12
 80046c0:	f040 80a0 	bne.w	8004804 <follow_path+0x280>
 80046c4:	f044 0402 	orr.w	r4, r4, #2
 80046c8:	b2e4      	uxtb	r4, r4
	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
 80046ca:	f885 404b 	strb.w	r4, [r5, #75]	@ 0x4b
			res = dir_find(dp);				/* Find an object with the segment name */
 80046ce:	4628      	mov	r0, r5
 80046d0:	f7ff fcb0 	bl	8004034 <dir_find>
			ns = dp->fn[NSFLAG];
 80046d4:	f895 304b 	ldrb.w	r3, [r5, #75]	@ 0x4b
			if (res != FR_OK) {				/* Failed to find the object */
 80046d8:	2800      	cmp	r0, #0
 80046da:	f040 80a6 	bne.w	800482a <follow_path+0x2a6>
			if (ns & NS_LAST) break;		/* Last segment matched. Function completed. */
 80046de:	075a      	lsls	r2, r3, #29
 80046e0:	f100 80d0 	bmi.w	8004884 <follow_path+0x300>
			if (!(dp->obj.attr & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 80046e4:	79ab      	ldrb	r3, [r5, #6]
 80046e6:	06db      	lsls	r3, r3, #27
 80046e8:	f140 80b3 	bpl.w	8004852 <follow_path+0x2ce>
			if (fs->fs_type == FS_EXFAT) {	/* Save containing directory information for next dir */
 80046ec:	9b02      	ldr	r3, [sp, #8]
 80046ee:	7818      	ldrb	r0, [r3, #0]
 80046f0:	2804      	cmp	r0, #4
 80046f2:	f040 80a1 	bne.w	8004838 <follow_path+0x2b4>
				dp->obj.c_scl = dp->obj.sclust;
 80046f6:	68ab      	ldr	r3, [r5, #8]
 80046f8:	622b      	str	r3, [r5, #32]
				dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 80046fa:	692b      	ldr	r3, [r5, #16]
 80046fc:	79ea      	ldrb	r2, [r5, #7]
 80046fe:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8004702:	4313      	orrs	r3, r2
 8004704:	626b      	str	r3, [r5, #36]	@ 0x24
				dp->obj.c_ofs = dp->blk_ofs;
 8004706:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 8004708:	62ab      	str	r3, [r5, #40]	@ 0x28
				init_alloc_info(fs, &dp->obj);	/* Open next directory */
 800470a:	9b02      	ldr	r3, [sp, #8]
 800470c:	4629      	mov	r1, r5
 800470e:	6918      	ldr	r0, [r3, #16]
 8004710:	f7ff ff22 	bl	8004558 <init_alloc_info.isra.0>
	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 8004714:	682b      	ldr	r3, [r5, #0]
 8004716:	2600      	movs	r6, #0
 8004718:	f8d3 900c 	ldr.w	r9, [r3, #12]
 800471c:	e76e      	b.n	80045fc <follow_path+0x78>
	while (*str && *str != chr) str++;
 800471e:	4290      	cmp	r0, r2
 8004720:	f47f af61 	bne.w	80045e6 <follow_path+0x62>
 8004724:	e093      	b.n	800484e <follow_path+0x2ca>
		di--;
 8004726:	3e01      	subs	r6, #1
 8004728:	e76f      	b.n	800460a <follow_path+0x86>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 800472a:	f044 0403 	orr.w	r4, r4, #3
 800472e:	b2e4      	uxtb	r4, r4
 8004730:	e789      	b.n	8004646 <follow_path+0xc2>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 8004732:	454e      	cmp	r6, r9
 8004734:	f000 808f 	beq.w	8004856 <follow_path+0x2d2>
			cf |= NS_LOSS | NS_LFN;
 8004738:	f044 0403 	orr.w	r4, r4, #3
 800473c:	b2e4      	uxtb	r4, r4
		dp->fn[i++] = (BYTE)wc;
 800473e:	4633      	mov	r3, r6
 8004740:	e796      	b.n	8004670 <follow_path+0xec>
		if (i >= ni || si == di) {		/* End of field? */
 8004742:	454e      	cmp	r6, r9
 8004744:	d10f      	bne.n	8004766 <follow_path+0x1e2>
 8004746:	e089      	b.n	800485c <follow_path+0x2d8>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
 8004748:	454e      	cmp	r6, r9
 800474a:	d003      	beq.n	8004754 <follow_path+0x1d0>
 800474c:	f044 0403 	orr.w	r4, r4, #3
 8004750:	b2e4      	uxtb	r4, r4
			if (si > di) break;						/* No name extension? */
 8004752:	d853      	bhi.n	80047fc <follow_path+0x278>
			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
 8004754:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8004758:	fa5f fa8a 	uxtb.w	sl, sl
 800475c:	464e      	mov	r6, r9
 800475e:	f04f 080b 	mov.w	r8, #11
 8004762:	2708      	movs	r7, #8
			continue;
 8004764:	e7eb      	b.n	800473e <follow_path+0x1ba>
		if (wc >= 0x80) {	/* Is this an extended character? */
 8004766:	287f      	cmp	r0, #127	@ 0x7f
 8004768:	d924      	bls.n	80047b4 <follow_path+0x230>
			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
 800476a:	f240 3162 	movw	r1, #866	@ 0x362
 800476e:	9203      	str	r2, [sp, #12]
 8004770:	f000 fd34 	bl	80051dc <ff_uni2oem>
			cf |= NS_LFN;	/* LFN entry needs to be created */
 8004774:	f044 0502 	orr.w	r5, r4, #2
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 8004778:	f010 0f80 	tst.w	r0, #128	@ 0x80
 800477c:	9a03      	ldr	r2, [sp, #12]
			cf |= NS_LFN;	/* LFN entry needs to be created */
 800477e:	b2ed      	uxtb	r5, r5
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 8004780:	d004      	beq.n	800478c <follow_path+0x208>
 8004782:	4b43      	ldr	r3, [pc, #268]	@ (8004890 <follow_path+0x30c>)
 8004784:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8004788:	5c18      	ldrb	r0, [r3, r0]
		if (wc >= 0x100) {				/* Is this a DBC? */
 800478a:	e011      	b.n	80047b0 <follow_path+0x22c>
 800478c:	28ff      	cmp	r0, #255	@ 0xff
 800478e:	d90f      	bls.n	80047b0 <follow_path+0x22c>
			if (i >= ni - 1) {			/* Field overflow? */
 8004790:	f108 33ff 	add.w	r3, r8, #4294967295
 8004794:	429f      	cmp	r7, r3
 8004796:	d304      	bcc.n	80047a2 <follow_path+0x21e>
				cf |= NS_LOSS | NS_LFN;
 8004798:	f044 0403 	orr.w	r4, r4, #3
 800479c:	b2e4      	uxtb	r4, r4
				i = ni; continue;		/* Next field */
 800479e:	4647      	mov	r7, r8
 80047a0:	e7cd      	b.n	800473e <follow_path+0x1ba>
			dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
 80047a2:	eb0b 0307 	add.w	r3, fp, r7
 80047a6:	0a01      	lsrs	r1, r0, #8
 80047a8:	f883 1040 	strb.w	r1, [r3, #64]	@ 0x40
 80047ac:	3701      	adds	r7, #1
 80047ae:	e01e      	b.n	80047ee <follow_path+0x26a>
			if (wc == 0 || strchr("+,;=[]", (int)wc)) {	/* Replace illegal characters for SFN */
 80047b0:	b138      	cbz	r0, 80047c2 <follow_path+0x23e>
 80047b2:	e000      	b.n	80047b6 <follow_path+0x232>
 80047b4:	4625      	mov	r5, r4
 80047b6:	4b37      	ldr	r3, [pc, #220]	@ (8004894 <follow_path+0x310>)
	while (*str && *str != chr) str++;
 80047b8:	f813 1b01 	ldrb.w	r1, [r3], #1
 80047bc:	b131      	cbz	r1, 80047cc <follow_path+0x248>
 80047be:	4288      	cmp	r0, r1
 80047c0:	d1fa      	bne.n	80047b8 <follow_path+0x234>
				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 80047c2:	f045 0503 	orr.w	r5, r5, #3
 80047c6:	b2ed      	uxtb	r5, r5
 80047c8:	205f      	movs	r0, #95	@ 0x5f
 80047ca:	e010      	b.n	80047ee <follow_path+0x26a>
				if (IsUpper(wc)) {		/* ASCII upper case? */
 80047cc:	f1a0 0341 	sub.w	r3, r0, #65	@ 0x41
 80047d0:	b29b      	uxth	r3, r3
 80047d2:	2b19      	cmp	r3, #25
 80047d4:	d802      	bhi.n	80047dc <follow_path+0x258>
					b |= 2;
 80047d6:	f04a 0a02 	orr.w	sl, sl, #2
				if (IsLower(wc)) {		/* ASCII lower case? */
 80047da:	e008      	b.n	80047ee <follow_path+0x26a>
 80047dc:	f1a0 0361 	sub.w	r3, r0, #97	@ 0x61
 80047e0:	b29b      	uxth	r3, r3
 80047e2:	2b19      	cmp	r3, #25
 80047e4:	d803      	bhi.n	80047ee <follow_path+0x26a>
					b |= 1; wc -= 0x20;
 80047e6:	3820      	subs	r0, #32
 80047e8:	f04a 0a01 	orr.w	sl, sl, #1
 80047ec:	b280      	uxth	r0, r0
		dp->fn[i++] = (BYTE)wc;
 80047ee:	eb0b 0307 	add.w	r3, fp, r7
 80047f2:	462c      	mov	r4, r5
 80047f4:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
 80047f8:	3701      	adds	r7, #1
 80047fa:	e7a0      	b.n	800473e <follow_path+0x1ba>
 80047fc:	465d      	mov	r5, fp
 80047fe:	f8dd b004 	ldr.w	fp, [sp, #4]
 8004802:	e74c      	b.n	800469e <follow_path+0x11a>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 8004804:	f00a 0303 	and.w	r3, sl, #3
 8004808:	2b03      	cmp	r3, #3
 800480a:	f43f af5b 	beq.w	80046c4 <follow_path+0x140>
	if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
 800480e:	07a1      	lsls	r1, r4, #30
 8004810:	f53f af5b 	bmi.w	80046ca <follow_path+0x146>
		if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
 8004814:	f00a 0301 	and.w	r3, sl, #1
 8004818:	ea44 1303 	orr.w	r3, r4, r3, lsl #4
 800481c:	b2dc      	uxtb	r4, r3
		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
 800481e:	f01a 0f04 	tst.w	sl, #4
 8004822:	bf18      	it	ne
 8004824:	f044 0408 	orrne.w	r4, r4, #8
 8004828:	e74f      	b.n	80046ca <follow_path+0x146>
				if (res == FR_NO_FILE) {	/* Object is not found */
 800482a:	2804      	cmp	r0, #4
 800482c:	d12a      	bne.n	8004884 <follow_path+0x300>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800482e:	f013 0f04 	tst.w	r3, #4
 8004832:	bf08      	it	eq
 8004834:	2005      	moveq	r0, #5
 8004836:	e025      	b.n	8004884 <follow_path+0x300>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8004838:	9b02      	ldr	r3, [sp, #8]
 800483a:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 800483e:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 8004840:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004844:	4419      	add	r1, r3
 8004846:	f7ff fe95 	bl	8004574 <ld_clust.isra.0>
 800484a:	60a8      	str	r0, [r5, #8]
 800484c:	e762      	b.n	8004714 <follow_path+0x190>
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800484e:	2006      	movs	r0, #6
 8004850:	e018      	b.n	8004884 <follow_path+0x300>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8004852:	2005      	movs	r0, #5
	return res;
 8004854:	e016      	b.n	8004884 <follow_path+0x300>
		if (i >= ni || si == di) {		/* End of field? */
 8004856:	4547      	cmp	r7, r8
 8004858:	f4bf af16 	bcs.w	8004688 <follow_path+0x104>
			if (ni == 11) {				/* Name extension overflow? */
 800485c:	f1b8 0f0b 	cmp.w	r8, #11
 8004860:	f47f af78 	bne.w	8004754 <follow_path+0x1d0>
 8004864:	e713      	b.n	800468e <follow_path+0x10a>
	if (wc < ' ') {				/* Stopped at end of the path? */
 8004866:	465b      	mov	r3, fp
		while (IsSeparator(*p)) p++;	/* Skip duplicated separators if exist */
 8004868:	781c      	ldrb	r4, [r3, #0]
 800486a:	2c2f      	cmp	r4, #47	@ 0x2f
 800486c:	469b      	mov	fp, r3
 800486e:	f103 0301 	add.w	r3, r3, #1
 8004872:	d0f9      	beq.n	8004868 <follow_path+0x2e4>
 8004874:	2c5c      	cmp	r4, #92	@ 0x5c
 8004876:	d0f7      	beq.n	8004868 <follow_path+0x2e4>
		if (IsTerminator(*p)) cf = NS_LAST;	/* Ignore terminating separator */
 8004878:	2c1f      	cmp	r4, #31
 800487a:	bf8c      	ite	hi
 800487c:	2400      	movhi	r4, #0
 800487e:	2401      	movls	r4, #1
 8004880:	00a4      	lsls	r4, r4, #2
 8004882:	e6c0      	b.n	8004606 <follow_path+0x82>
}
 8004884:	b005      	add	sp, #20
 8004886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800488a:	bf00      	nop
 800488c:	0801290d 	.word	0x0801290d
 8004890:	08012d38 	.word	0x08012d38
 8004894:	08012916 	.word	0x08012916

08004898 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object to be registered (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mount option: 0=Do not mount (delayed mount), 1=Mount immediately */
)
{
 8004898:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800489a:	e9cd 1000 	strd	r1, r0, [sp]
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 800489e:	a803      	add	r0, sp, #12
{
 80048a0:	4614      	mov	r4, r2
	const TCHAR *rp = path;
 80048a2:	9103      	str	r1, [sp, #12]
	vol = get_ldnumber(&rp);
 80048a4:	f7fe faea 	bl	8002e7c <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 80048a8:	3001      	adds	r0, #1
 80048aa:	d011      	beq.n	80048d0 <f_mount+0x38>
	cfs = FatFs[vol];					/* Pointer to fs object */
 80048ac:	4a0a      	ldr	r2, [pc, #40]	@ (80048d8 <f_mount+0x40>)
 80048ae:	6813      	ldr	r3, [r2, #0]

	if (cfs) {
 80048b0:	b10b      	cbz	r3, 80048b6 <f_mount+0x1e>
		clear_lock(cfs);
#endif
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80048b2:	2100      	movs	r1, #0
 80048b4:	7019      	strb	r1, [r3, #0]
	}

	if (fs) {
 80048b6:	9b01      	ldr	r3, [sp, #4]
 80048b8:	b10b      	cbz	r3, 80048be <f_mount+0x26>
		fs->fs_type = 0;				/* Clear new fs object */
 80048ba:	2100      	movs	r1, #0
 80048bc:	7019      	strb	r1, [r3, #0]
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 80048be:	6013      	str	r3, [r2, #0]

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 80048c0:	b13c      	cbz	r4, 80048d2 <f_mount+0x3a>

	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume */
 80048c2:	2200      	movs	r2, #0
 80048c4:	a901      	add	r1, sp, #4
 80048c6:	4668      	mov	r0, sp
 80048c8:	f7fe ff48 	bl	800375c <mount_volume>
 80048cc:	4604      	mov	r4, r0
	LEAVE_FF(fs, res);
 80048ce:	e000      	b.n	80048d2 <f_mount+0x3a>
	if (vol < 0) return FR_INVALID_DRIVE;
 80048d0:	240b      	movs	r4, #11
}
 80048d2:	4620      	mov	r0, r4
 80048d4:	b004      	add	sp, #16
 80048d6:	bd10      	pop	{r4, pc}
 80048d8:	20000788 	.word	0x20000788

080048dc <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and open mode flags */
)
{
 80048dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80048e0:	b09b      	sub	sp, #108	@ 0x6c
 80048e2:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 80048e4:	2800      	cmp	r0, #0
 80048e6:	f000 8123 	beq.w	8004b30 <f_open+0x254>

	/* Get logical drive number */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
 80048ea:	f002 093f 	and.w	r9, r2, #63	@ 0x3f
 80048ee:	4617      	mov	r7, r2
 80048f0:	4604      	mov	r4, r0
	res = mount_volume(&path, &fs, mode);
 80048f2:	464a      	mov	r2, r9
 80048f4:	a903      	add	r1, sp, #12
 80048f6:	a801      	add	r0, sp, #4
 80048f8:	f7fe ff30 	bl	800375c <mount_volume>
	if (res == FR_OK) {
 80048fc:	4680      	mov	r8, r0
 80048fe:	2800      	cmp	r0, #0
 8004900:	f040 8112 	bne.w	8004b28 <f_open+0x24c>
		dj.obj.fs = fs;
 8004904:	9d03      	ldr	r5, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 8004906:	f88d 0016 	strb.w	r0, [sp, #22]
 800490a:	2300      	movs	r3, #0
 800490c:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 800490e:	9504      	str	r5, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the file path */
 8004910:	a804      	add	r0, sp, #16
 8004912:	9313      	str	r3, [sp, #76]	@ 0x4c
 8004914:	f7ff fe36 	bl	8004584 <follow_path>
 8004918:	f89d b016 	ldrb.w	fp, [sp, #22]
 800491c:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
#if !FF_FS_READONLY	/* Read/Write configuration */
		if (res == FR_OK) {
 800491e:	b920      	cbnz	r0, 800492a <f_open+0x4e>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 8004920:	f99d 305b 	ldrsb.w	r3, [sp, #91]	@ 0x5b
				res = FR_INVALID_NAME;
 8004924:	2b00      	cmp	r3, #0
 8004926:	bfb8      	it	lt
 8004928:	2006      	movlt	r0, #6
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 800492a:	f017 0f1c 	tst.w	r7, #28
 800492e:	d077      	beq.n	8004a20 <f_open+0x144>
			if (res != FR_OK) {					/* No file, create new */
 8004930:	b170      	cbz	r0, 8004950 <f_open+0x74>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 8004932:	2804      	cmp	r0, #4
 8004934:	f040 80f8 	bne.w	8004b28 <f_open+0x24c>
#if FF_FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
 8004938:	a804      	add	r0, sp, #16
 800493a:	f7ff fc6d 	bl	8004218 <dir_register>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 800493e:	2800      	cmp	r0, #0
 8004940:	f040 80f2 	bne.w	8004b28 <f_open+0x24c>
					res = dir_register(&dj);
 8004944:	f89d b016 	ldrb.w	fp, [sp, #22]
 8004948:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 800494a:	f049 0908 	orr.w	r9, r9, #8
 800494e:	e008      	b.n	8004962 <f_open+0x86>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8004950:	f01b 0f11 	tst.w	fp, #17
 8004954:	f040 80e5 	bne.w	8004b22 <f_open+0x246>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8004958:	0778      	lsls	r0, r7, #29
 800495a:	f100 80de 	bmi.w	8004b1a <f_open+0x23e>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 800495e:	0739      	lsls	r1, r7, #28
 8004960:	d56c      	bpl.n	8004a3c <f_open+0x160>
#if FF_FS_EXFAT
				if (fs->fs_type == FS_EXFAT) {
 8004962:	782b      	ldrb	r3, [r5, #0]
 8004964:	2b04      	cmp	r3, #4
 8004966:	d12c      	bne.n	80049c2 <f_open+0xe6>
					/* Get current allocation info */
					fp->obj.fs = fs;
 8004968:	6928      	ldr	r0, [r5, #16]
 800496a:	6025      	str	r5, [r4, #0]
					init_alloc_info(fs, &fp->obj);
 800496c:	4621      	mov	r1, r4
 800496e:	f7ff fdf3 	bl	8004558 <init_alloc_info.isra.0>
					/* Set directory entry block initial state */
					memset(fs->dirbuf + 2, 0, 30);	/* Clear 85 entry except for NumSec */
 8004972:	2100      	movs	r1, #0
 8004974:	221e      	movs	r2, #30
 8004976:	3002      	adds	r0, #2
 8004978:	f7fe f9d2 	bl	8002d20 <mem_set>
					memset(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
 800497c:	6928      	ldr	r0, [r5, #16]
 800497e:	221a      	movs	r2, #26
 8004980:	3026      	adds	r0, #38	@ 0x26
 8004982:	f7fe f9cd 	bl	8002d20 <mem_set>
					fs->dirbuf[XDIR_Attr] = AM_ARC;
 8004986:	692b      	ldr	r3, [r5, #16]
 8004988:	2220      	movs	r2, #32
 800498a:	711a      	strb	r2, [r3, #4]
					st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
 800498c:	692f      	ldr	r7, [r5, #16]
 800498e:	f00b fd7b 	bl	8010488 <get_fattime>
					fs->dirbuf[XDIR_GenFlags] = 1;
 8004992:	692b      	ldr	r3, [r5, #16]
					st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
 8004994:	60b8      	str	r0, [r7, #8]
					fs->dirbuf[XDIR_GenFlags] = 1;
 8004996:	2201      	movs	r2, #1
 8004998:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
					res = store_xdir(&dj);
 800499c:	a804      	add	r0, sp, #16
 800499e:	f88d b016 	strb.w	fp, [sp, #22]
 80049a2:	9613      	str	r6, [sp, #76]	@ 0x4c
 80049a4:	f7ff fa64 	bl	8003e70 <store_xdir>
					if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
 80049a8:	2800      	cmp	r0, #0
 80049aa:	f040 80bd 	bne.w	8004b28 <f_open+0x24c>
 80049ae:	68a1      	ldr	r1, [r4, #8]
					res = store_xdir(&dj);
 80049b0:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
					if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
 80049b2:	2900      	cmp	r1, #0
 80049b4:	d040      	beq.n	8004a38 <f_open+0x15c>
						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
 80049b6:	4602      	mov	r2, r0
 80049b8:	4620      	mov	r0, r4
 80049ba:	f7fe fce5 	bl	8003388 <remove_chain>
						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
 80049be:	68a7      	ldr	r7, [r4, #8]
 80049c0:	e028      	b.n	8004a14 <f_open+0x138>
					}
				} else
#endif
				{
					/* Set directory entry initial state */
					tm = GET_FATTIME();					/* Set created time */
 80049c2:	f00b fd61 	bl	8010488 <get_fattime>
					st_dword(dj.dir + DIR_CrtTime, tm);
 80049c6:	f8c6 000e 	str.w	r0, [r6, #14]
					st_dword(dj.dir + DIR_ModTime, tm);
 80049ca:	f8c6 0016 	str.w	r0, [r6, #22]
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 80049ce:	7828      	ldrb	r0, [r5, #0]
 80049d0:	4631      	mov	r1, r6
 80049d2:	f7ff fdcf 	bl	8004574 <ld_clust.isra.0>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 80049d6:	2320      	movs	r3, #32
 80049d8:	72f3      	strb	r3, [r6, #11]
 80049da:	782a      	ldrb	r2, [r5, #0]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 80049dc:	2300      	movs	r3, #0
	if (fs->fs_type == FS_FAT32) {
 80049de:	2a03      	cmp	r2, #3
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 80049e0:	8373      	strh	r3, [r6, #26]
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 80049e2:	bf08      	it	eq
 80049e4:	82b3      	strheq	r3, [r6, #20]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
					st_dword(dj.dir + DIR_FileSize, 0);
 80049e6:	61f3      	str	r3, [r6, #28]
					fs->wflag = 1;
 80049e8:	2301      	movs	r3, #1
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 80049ea:	4607      	mov	r7, r0
					fs->wflag = 1;
 80049ec:	70eb      	strb	r3, [r5, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 80049ee:	b318      	cbz	r0, 8004a38 <f_open+0x15c>
						sc = fs->winsect;
						res = remove_chain(&dj.obj, cl, 0);
 80049f0:	4601      	mov	r1, r0
 80049f2:	2200      	movs	r2, #0
 80049f4:	a804      	add	r0, sp, #16
						sc = fs->winsect;
 80049f6:	f8d5 a038 	ldr.w	sl, [r5, #56]	@ 0x38
						res = remove_chain(&dj.obj, cl, 0);
 80049fa:	f88d b016 	strb.w	fp, [sp, #22]
 80049fe:	9613      	str	r6, [sp, #76]	@ 0x4c
 8004a00:	f7fe fcc2 	bl	8003388 <remove_chain>
						if (res == FR_OK) {
 8004a04:	2800      	cmp	r0, #0
 8004a06:	f040 808f 	bne.w	8004b28 <f_open+0x24c>
							res = move_window(fs, sc);
 8004a0a:	4651      	mov	r1, sl
 8004a0c:	4628      	mov	r0, r5
						res = remove_chain(&dj.obj, cl, 0);
 8004a0e:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
							res = move_window(fs, sc);
 8004a10:	f7fe fa86 	bl	8002f20 <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8004a14:	3f01      	subs	r7, #1
 8004a16:	616f      	str	r7, [r5, #20]
						res = FR_DENIED;
					}
				}
			}
		}
		if (res == FR_OK) {
 8004a18:	2800      	cmp	r0, #0
 8004a1a:	f040 8085 	bne.w	8004b28 <f_open+0x24c>
 8004a1e:	e00b      	b.n	8004a38 <f_open+0x15c>
			if (res == FR_OK) {					/* Is the object exsiting? */
 8004a20:	2800      	cmp	r0, #0
 8004a22:	f040 8081 	bne.w	8004b28 <f_open+0x24c>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 8004a26:	f01b 0f10 	tst.w	fp, #16
 8004a2a:	d178      	bne.n	8004b1e <f_open+0x242>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 8004a2c:	07ba      	lsls	r2, r7, #30
 8004a2e:	d505      	bpl.n	8004a3c <f_open+0x160>
 8004a30:	f01b 0f01 	tst.w	fp, #1
 8004a34:	d175      	bne.n	8004b22 <f_open+0x246>
 8004a36:	e001      	b.n	8004a3c <f_open+0x160>
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 8004a38:	f049 0940 	orr.w	r9, r9, #64	@ 0x40
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8004a3c:	6bab      	ldr	r3, [r5, #56]	@ 0x38
			fp->dir_ptr = dj.dir;
 8004a3e:	e9c4 3612 	strd	r3, r6, [r4, #72]	@ 0x48
		}
#endif

		if (res == FR_OK) {
#if FF_FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 8004a42:	7828      	ldrb	r0, [r5, #0]
 8004a44:	2804      	cmp	r0, #4
 8004a46:	d10f      	bne.n	8004a68 <f_open+0x18c>
				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
 8004a48:	9b06      	ldr	r3, [sp, #24]
 8004a4a:	6223      	str	r3, [r4, #32]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 8004a4c:	9b08      	ldr	r3, [sp, #32]
 8004a4e:	f89d 2017 	ldrb.w	r2, [sp, #23]
				fp->obj.c_ofs = dj.blk_ofs;
				init_alloc_info(fs, &fp->obj);
 8004a52:	6928      	ldr	r0, [r5, #16]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 8004a54:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8004a58:	4313      	orrs	r3, r2
 8004a5a:	6263      	str	r3, [r4, #36]	@ 0x24
				fp->obj.c_ofs = dj.blk_ofs;
 8004a5c:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004a5e:	62a3      	str	r3, [r4, #40]	@ 0x28
				init_alloc_info(fs, &fp->obj);
 8004a60:	4621      	mov	r1, r4
 8004a62:	f7ff fd79 	bl	8004558 <init_alloc_info.isra.0>
 8004a66:	e007      	b.n	8004a78 <f_open+0x19c>
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8004a68:	4631      	mov	r1, r6
 8004a6a:	f7ff fd83 	bl	8004574 <ld_clust.isra.0>
 8004a6e:	60a0      	str	r0, [r4, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8004a70:	69f3      	ldr	r3, [r6, #28]
 8004a72:	6123      	str	r3, [r4, #16]
 8004a74:	2300      	movs	r3, #0
 8004a76:	6163      	str	r3, [r4, #20]
			}
#if FF_USE_FASTSEEK
			fp->cltbl = 0;		/* Disable fast seek mode */
#endif
			fp->obj.fs = fs;	/* Validate the file object */
			fp->obj.id = fs->id;
 8004a78:	88eb      	ldrh	r3, [r5, #6]
 8004a7a:	80a3      	strh	r3, [r4, #4]
			fp->flag = mode;	/* Set file access mode */
			fp->err = 0;		/* Clear error flag */
 8004a7c:	f04f 0a00 	mov.w	sl, #0
			fp->sect = 0;		/* Invalidate current data sector */
			fp->fptr = 0;		/* Set file pointer top of the file */
 8004a80:	2200      	movs	r2, #0
 8004a82:	2300      	movs	r3, #0
#if !FF_FS_READONLY
#if !FF_FS_TINY
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 8004a84:	f104 0750 	add.w	r7, r4, #80	@ 0x50
			fp->fptr = 0;		/* Set file pointer top of the file */
 8004a88:	e9c4 230e 	strd	r2, r3, [r4, #56]	@ 0x38
			fp->obj.fs = fs;	/* Validate the file object */
 8004a8c:	6025      	str	r5, [r4, #0]
			fp->flag = mode;	/* Set file access mode */
 8004a8e:	f884 9030 	strb.w	r9, [r4, #48]	@ 0x30
			fp->err = 0;		/* Clear error flag */
 8004a92:	f884 a031 	strb.w	sl, [r4, #49]	@ 0x31
			fp->sect = 0;		/* Invalidate current data sector */
 8004a96:	f8c4 a044 	str.w	sl, [r4, #68]	@ 0x44
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 8004a9a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004a9e:	4651      	mov	r1, sl
 8004aa0:	4638      	mov	r0, r7
 8004aa2:	f7fe f93d 	bl	8002d20 <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 8004aa6:	f019 0f20 	tst.w	r9, #32
 8004aaa:	d043      	beq.n	8004b34 <f_open+0x258>
 8004aac:	e9d4 6904 	ldrd	r6, r9, [r4, #16]
 8004ab0:	ea56 0309 	orrs.w	r3, r6, r9
 8004ab4:	d03e      	beq.n	8004b34 <f_open+0x258>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8004ab6:	f8b5 b00a 	ldrh.w	fp, [r5, #10]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8004aba:	68a1      	ldr	r1, [r4, #8]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8004abc:	e9c4 690e 	strd	r6, r9, [r4, #56]	@ 0x38
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8004ac0:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8004ac4:	45b3      	cmp	fp, r6
 8004ac6:	eb7a 0309 	sbcs.w	r3, sl, r9
 8004aca:	d20d      	bcs.n	8004ae8 <f_open+0x20c>
					clst = get_fat(&fp->obj, clst);
 8004acc:	4620      	mov	r0, r4
 8004ace:	f7fe fb81 	bl	80031d4 <get_fat>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8004ad2:	ebb6 060b 	subs.w	r6, r6, fp
 8004ad6:	f169 0900 	sbc.w	r9, r9, #0
					if (clst <= 1) res = FR_INT_ERR;
 8004ada:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 8004adc:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
 8004ade:	d905      	bls.n	8004aec <f_open+0x210>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8004ae0:	1c43      	adds	r3, r0, #1
 8004ae2:	d1ef      	bne.n	8004ac4 <f_open+0x1e8>
 8004ae4:	2001      	movs	r0, #1
 8004ae6:	e002      	b.n	8004aee <f_open+0x212>
 8004ae8:	2000      	movs	r0, #0
 8004aea:	e000      	b.n	8004aee <f_open+0x212>
					if (clst <= 1) res = FR_INT_ERR;
 8004aec:	2002      	movs	r0, #2
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
				}
				fp->clust = clst;
 8004aee:	6421      	str	r1, [r4, #64]	@ 0x40
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8004af0:	b9d0      	cbnz	r0, 8004b28 <f_open+0x24c>
 8004af2:	f3c6 0308 	ubfx	r3, r6, #0, #9
 8004af6:	b1eb      	cbz	r3, 8004b34 <f_open+0x258>
					sc = clst2sect(fs, clst);
 8004af8:	4628      	mov	r0, r5
 8004afa:	f7fe f925 	bl	8002d48 <clst2sect>
					if (sc == 0) {
 8004afe:	b190      	cbz	r0, 8004b26 <f_open+0x24a>
						res = FR_INT_ERR;
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 8004b00:	0a76      	lsrs	r6, r6, #9
 8004b02:	ea46 56c9 	orr.w	r6, r6, r9, lsl #23
 8004b06:	1982      	adds	r2, r0, r6
 8004b08:	6462      	str	r2, [r4, #68]	@ 0x44
#if !FF_FS_TINY
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8004b0a:	7868      	ldrb	r0, [r5, #1]
 8004b0c:	2301      	movs	r3, #1
 8004b0e:	4639      	mov	r1, r7
 8004b10:	f00b fd4c 	bl	80105ac <disk_read>
 8004b14:	b170      	cbz	r0, 8004b34 <f_open+0x258>
 8004b16:	2001      	movs	r0, #1
 8004b18:	e006      	b.n	8004b28 <f_open+0x24c>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8004b1a:	2008      	movs	r0, #8
 8004b1c:	e004      	b.n	8004b28 <f_open+0x24c>
					res = FR_NO_FILE;
 8004b1e:	2004      	movs	r0, #4
 8004b20:	e002      	b.n	8004b28 <f_open+0x24c>
					res = FR_DENIED;
 8004b22:	2007      	movs	r0, #7
 8004b24:	e000      	b.n	8004b28 <f_open+0x24c>
						res = FR_INT_ERR;
 8004b26:	2002      	movs	r0, #2
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8004b28:	2300      	movs	r3, #0
 8004b2a:	6023      	str	r3, [r4, #0]
 8004b2c:	4680      	mov	r8, r0
 8004b2e:	e001      	b.n	8004b34 <f_open+0x258>
	if (!fp) return FR_INVALID_OBJECT;
 8004b30:	f04f 0809 	mov.w	r8, #9

	LEAVE_FF(fs, res);
}
 8004b34:	4640      	mov	r0, r8
 8004b36:	b01b      	add	sp, #108	@ 0x6c
 8004b38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004b3c <f_read>:
	FIL* fp, 	/* Open file to be read */
	void* buff,	/* Data buffer to store the read data */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Number of bytes read */
)
{
 8004b3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004b40:	469a      	mov	sl, r3
 8004b42:	b087      	sub	sp, #28
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 8004b44:	2300      	movs	r3, #0
{
 8004b46:	4688      	mov	r8, r1
	*br = 0;	/* Clear read byte counter */
 8004b48:	f8ca 3000 	str.w	r3, [sl]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004b4c:	a905      	add	r1, sp, #20
{
 8004b4e:	4604      	mov	r4, r0
 8004b50:	4616      	mov	r6, r2
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004b52:	f7fe f9a9 	bl	8002ea8 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8004b56:	2800      	cmp	r0, #0
 8004b58:	f040 80bb 	bne.w	8004cd2 <f_read+0x196>
 8004b5c:	f894 9031 	ldrb.w	r9, [r4, #49]	@ 0x31
 8004b60:	f1b9 0f00 	cmp.w	r9, #0
 8004b64:	f040 80ba 	bne.w	8004cdc <f_read+0x1a0>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8004b68:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004b6c:	f013 0501 	ands.w	r5, r3, #1
 8004b70:	f000 80b2 	beq.w	8004cd8 <f_read+0x19c>
	remain = fp->obj.objsize - fp->fptr;
 8004b74:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8004b78:	e9d4 100e 	ldrd	r1, r0, [r4, #56]	@ 0x38
 8004b7c:	1a5b      	subs	r3, r3, r1
 8004b7e:	eb62 0200 	sbc.w	r2, r2, r0
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8004b82:	42b3      	cmp	r3, r6
 8004b84:	f172 0200 	sbcs.w	r2, r2, #0
 8004b88:	bf38      	it	cc
 8004b8a:	461e      	movcc	r6, r3
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		memcpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8004b8c:	f104 0350 	add.w	r3, r4, #80	@ 0x50
 8004b90:	e9cd 3500 	strd	r3, r5, [sp]
 8004b94:	f8cd 9008 	str.w	r9, [sp, #8]
	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
 8004b98:	2e00      	cmp	r6, #0
 8004b9a:	f000 8097 	beq.w	8004ccc <f_read+0x190>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8004b9e:	e9d4 300e 	ldrd	r3, r0, [r4, #56]	@ 0x38
 8004ba2:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004ba6:	2a00      	cmp	r2, #0
 8004ba8:	d173      	bne.n	8004c92 <f_read+0x156>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8004baa:	f8dd b014 	ldr.w	fp, [sp, #20]
 8004bae:	f8bb 200a 	ldrh.w	r2, [fp, #10]
 8004bb2:	0a59      	lsrs	r1, r3, #9
 8004bb4:	3a01      	subs	r2, #1
 8004bb6:	ea41 51c0 	orr.w	r1, r1, r0, lsl #23
			if (csect == 0) {					/* On the cluster boundary? */
 8004bba:	ea12 0901 	ands.w	r9, r2, r1
 8004bbe:	d117      	bne.n	8004bf0 <f_read+0xb4>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8004bc0:	4303      	orrs	r3, r0
 8004bc2:	d101      	bne.n	8004bc8 <f_read+0x8c>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8004bc4:	68a0      	ldr	r0, [r4, #8]
 8004bc6:	e003      	b.n	8004bd0 <f_read+0x94>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8004bc8:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004bca:	4620      	mov	r0, r4
 8004bcc:	f7fe fb02 	bl	80031d4 <get_fat>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8004bd0:	2801      	cmp	r0, #1
 8004bd2:	d804      	bhi.n	8004bde <f_read+0xa2>
 8004bd4:	f04f 0902 	mov.w	r9, #2
 8004bd8:	f884 9031 	strb.w	r9, [r4, #49]	@ 0x31
 8004bdc:	e07e      	b.n	8004cdc <f_read+0x1a0>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004bde:	1c43      	adds	r3, r0, #1
 8004be0:	d105      	bne.n	8004bee <f_read+0xb2>
 8004be2:	9d01      	ldr	r5, [sp, #4]
 8004be4:	2301      	movs	r3, #1
 8004be6:	f884 3031 	strb.w	r3, [r4, #49]	@ 0x31
 8004bea:	46a9      	mov	r9, r5
 8004bec:	e076      	b.n	8004cdc <f_read+0x1a0>
				fp->clust = clst;				/* Update current cluster */
 8004bee:	6420      	str	r0, [r4, #64]	@ 0x40
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 8004bf0:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004bf2:	4658      	mov	r0, fp
 8004bf4:	f7fe f8a8 	bl	8002d48 <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 8004bf8:	2800      	cmp	r0, #0
 8004bfa:	d0eb      	beq.n	8004bd4 <f_read+0x98>
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8004bfc:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
			sect += csect;
 8004c00:	eb09 0700 	add.w	r7, r9, r0
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8004c04:	d324      	bcc.n	8004c50 <f_read+0x114>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004c06:	f8bb 100a 	ldrh.w	r1, [fp, #10]
 8004c0a:	eb09 2056 	add.w	r0, r9, r6, lsr #9
 8004c0e:	4288      	cmp	r0, r1
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8004c10:	ea4f 2556 	mov.w	r5, r6, lsr #9
					cc = fs->csize - csect;
 8004c14:	bf88      	it	hi
 8004c16:	eba1 0509 	subhi.w	r5, r1, r9
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004c1a:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004c1e:	462b      	mov	r3, r5
 8004c20:	463a      	mov	r2, r7
 8004c22:	4641      	mov	r1, r8
 8004c24:	f00b fcc2 	bl	80105ac <disk_read>
 8004c28:	2800      	cmp	r0, #0
 8004c2a:	d1da      	bne.n	8004be2 <f_read+0xa6>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8004c2c:	f994 2030 	ldrsb.w	r2, [r4, #48]	@ 0x30
 8004c30:	2a00      	cmp	r2, #0
 8004c32:	da0b      	bge.n	8004c4c <f_read+0x110>
 8004c34:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8004c36:	1bc0      	subs	r0, r0, r7
 8004c38:	42a8      	cmp	r0, r5
 8004c3a:	d207      	bcs.n	8004c4c <f_read+0x110>
					memcpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8004c3c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004c40:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004c44:	eb08 2040 	add.w	r0, r8, r0, lsl #9
 8004c48:	f7fe f860 	bl	8002d0c <mem_cpy>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8004c4c:	026f      	lsls	r7, r5, #9
				continue;
 8004c4e:	e02e      	b.n	8004cae <f_read+0x172>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8004c50:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8004c52:	42ba      	cmp	r2, r7
 8004c54:	d01c      	beq.n	8004c90 <f_read+0x154>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8004c56:	f994 3030 	ldrsb.w	r3, [r4, #48]	@ 0x30
 8004c5a:	2b00      	cmp	r3, #0
 8004c5c:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004c60:	da0e      	bge.n	8004c80 <f_read+0x144>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004c62:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004c66:	9103      	str	r1, [sp, #12]
 8004c68:	2301      	movs	r3, #1
 8004c6a:	f00b fce1 	bl	8010630 <disk_write>
 8004c6e:	2800      	cmp	r0, #0
 8004c70:	d1b7      	bne.n	8004be2 <f_read+0xa6>
					fp->flag &= (BYTE)~FA_DIRTY;
 8004c72:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004c76:	9903      	ldr	r1, [sp, #12]
 8004c78:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004c7c:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8004c80:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004c84:	2301      	movs	r3, #1
 8004c86:	463a      	mov	r2, r7
 8004c88:	f00b fc90 	bl	80105ac <disk_read>
 8004c8c:	2800      	cmp	r0, #0
 8004c8e:	d1a8      	bne.n	8004be2 <f_read+0xa6>
			fp->sect = sect;
 8004c90:	6467      	str	r7, [r4, #68]	@ 0x44
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004c92:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8004c94:	9b00      	ldr	r3, [sp, #0]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004c96:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8004c9a:	f5c1 7700 	rsb	r7, r1, #512	@ 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 8004c9e:	42b7      	cmp	r7, r6
 8004ca0:	bf28      	it	cs
 8004ca2:	4637      	movcs	r7, r6
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8004ca4:	463a      	mov	r2, r7
 8004ca6:	4419      	add	r1, r3
 8004ca8:	4640      	mov	r0, r8
 8004caa:	f7fe f82f 	bl	8002d0c <mem_cpy>
	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
 8004cae:	f8da 3000 	ldr.w	r3, [sl]
 8004cb2:	443b      	add	r3, r7
 8004cb4:	f8ca 3000 	str.w	r3, [sl]
 8004cb8:	e9d4 320e 	ldrd	r3, r2, [r4, #56]	@ 0x38
 8004cbc:	19db      	adds	r3, r3, r7
 8004cbe:	f142 0200 	adc.w	r2, r2, #0
 8004cc2:	e9c4 320e 	strd	r3, r2, [r4, #56]	@ 0x38
 8004cc6:	1bf6      	subs	r6, r6, r7
 8004cc8:	44b8      	add	r8, r7
 8004cca:	e765      	b.n	8004b98 <f_read+0x5c>
 8004ccc:	f8dd 9008 	ldr.w	r9, [sp, #8]
 8004cd0:	e004      	b.n	8004cdc <f_read+0x1a0>
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004cd2:	f04f 0909 	mov.w	r9, #9
 8004cd6:	e001      	b.n	8004cdc <f_read+0x1a0>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8004cd8:	f04f 0907 	mov.w	r9, #7
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 8004cdc:	4648      	mov	r0, r9
 8004cde:	b007      	add	sp, #28
 8004ce0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004ce4 <f_write>:
	FIL* fp,			/* Open file to be written */
	const void* buff,	/* Data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Number of bytes written */
)
{
 8004ce4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004ce8:	461f      	mov	r7, r3
 8004cea:	b085      	sub	sp, #20
	LBA_t sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 8004cec:	2300      	movs	r3, #0
{
 8004cee:	460e      	mov	r6, r1
	*bw = 0;	/* Clear write byte counter */
 8004cf0:	603b      	str	r3, [r7, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8004cf2:	a903      	add	r1, sp, #12
{
 8004cf4:	4604      	mov	r4, r0
 8004cf6:	4615      	mov	r5, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8004cf8:	f7fe f8d6 	bl	8002ea8 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8004cfc:	2800      	cmp	r0, #0
 8004cfe:	f040 80db 	bne.w	8004eb8 <f_write+0x1d4>
 8004d02:	f894 b031 	ldrb.w	fp, [r4, #49]	@ 0x31
 8004d06:	f1bb 0f00 	cmp.w	fp, #0
 8004d0a:	f040 80da 	bne.w	8004ec2 <f_write+0x1de>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8004d0e:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004d12:	079a      	lsls	r2, r3, #30
 8004d14:	f140 80d3 	bpl.w	8004ebe <f_write+0x1da>

	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8004d18:	f8dd a00c 	ldr.w	sl, [sp, #12]
 8004d1c:	f89a 3000 	ldrb.w	r3, [sl]
 8004d20:	2b04      	cmp	r3, #4
 8004d22:	d003      	beq.n	8004d2c <f_write+0x48>
 8004d24:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8004d26:	42eb      	cmn	r3, r5
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8004d28:	bf28      	it	cs
 8004d2a:	43dd      	mvncs	r5, r3
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		memcpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8004d2c:	f104 0350 	add.w	r3, r4, #80	@ 0x50
 8004d30:	e9cd b300 	strd	fp, r3, [sp]
	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
 8004d34:	b1dd      	cbz	r5, 8004d6e <f_write+0x8a>
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8004d36:	e9d4 310e 	ldrd	r3, r1, [r4, #56]	@ 0x38
 8004d3a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004d3e:	2a00      	cmp	r2, #0
 8004d40:	f040 808d 	bne.w	8004e5e <f_write+0x17a>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8004d44:	f8ba 900a 	ldrh.w	r9, [sl, #10]
 8004d48:	0a5a      	lsrs	r2, r3, #9
 8004d4a:	f109 39ff 	add.w	r9, r9, #4294967295
 8004d4e:	ea42 52c1 	orr.w	r2, r2, r1, lsl #23
			if (csect == 0) {				/* On the cluster boundary? */
 8004d52:	ea19 0902 	ands.w	r9, r9, r2
 8004d56:	d123      	bne.n	8004da0 <f_write+0xbc>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8004d58:	430b      	orrs	r3, r1
 8004d5a:	d102      	bne.n	8004d62 <f_write+0x7e>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8004d5c:	68a1      	ldr	r1, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 8004d5e:	b979      	cbnz	r1, 8004d80 <f_write+0x9c>
 8004d60:	e000      	b.n	8004d64 <f_write+0x80>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8004d62:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004d64:	4620      	mov	r0, r4
 8004d66:	f7fe fea1 	bl	8003aac <create_chain>
 8004d6a:	4601      	mov	r1, r0
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8004d6c:	b940      	cbnz	r0, 8004d80 <f_write+0x9c>
		fp->flag |= FA_DIRTY;
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8004d6e:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004d72:	f8dd b000 	ldr.w	fp, [sp]
 8004d76:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8004d7a:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30

	LEAVE_FF(fs, FR_OK);
 8004d7e:	e0a0      	b.n	8004ec2 <f_write+0x1de>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8004d80:	2901      	cmp	r1, #1
 8004d82:	d102      	bne.n	8004d8a <f_write+0xa6>
 8004d84:	f04f 0b02 	mov.w	fp, #2
 8004d88:	e003      	b.n	8004d92 <f_write+0xae>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004d8a:	1c4b      	adds	r3, r1, #1
 8004d8c:	d104      	bne.n	8004d98 <f_write+0xb4>
 8004d8e:	f04f 0b01 	mov.w	fp, #1
 8004d92:	f884 b031 	strb.w	fp, [r4, #49]	@ 0x31
 8004d96:	e094      	b.n	8004ec2 <f_write+0x1de>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8004d98:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 8004d9a:	6421      	str	r1, [r4, #64]	@ 0x40
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8004d9c:	b903      	cbnz	r3, 8004da0 <f_write+0xbc>
 8004d9e:	60a1      	str	r1, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8004da0:	f994 3030 	ldrsb.w	r3, [r4, #48]	@ 0x30
 8004da4:	2b00      	cmp	r3, #0
 8004da6:	da0f      	bge.n	8004dc8 <f_write+0xe4>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004da8:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8004daa:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8004dae:	2301      	movs	r3, #1
 8004db0:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004db4:	f00b fc3c 	bl	8010630 <disk_write>
 8004db8:	2800      	cmp	r0, #0
 8004dba:	d1e8      	bne.n	8004d8e <f_write+0xaa>
				fp->flag &= (BYTE)~FA_DIRTY;
 8004dbc:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004dc0:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004dc4:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 8004dc8:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004dca:	4650      	mov	r0, sl
 8004dcc:	f7fd ffbc 	bl	8002d48 <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 8004dd0:	2800      	cmp	r0, #0
 8004dd2:	d0d7      	beq.n	8004d84 <f_write+0xa0>
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 8004dd4:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
			sect += csect;
 8004dd8:	eb09 0800 	add.w	r8, r9, r0
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 8004ddc:	d328      	bcc.n	8004e30 <f_write+0x14c>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004dde:	f8ba 200a 	ldrh.w	r2, [sl, #10]
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004de2:	f89a 0001 	ldrb.w	r0, [sl, #1]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004de6:	eb09 2155 	add.w	r1, r9, r5, lsr #9
 8004dea:	4291      	cmp	r1, r2
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 8004dec:	ea4f 2b55 	mov.w	fp, r5, lsr #9
					cc = fs->csize - csect;
 8004df0:	bf88      	it	hi
 8004df2:	eba2 0b09 	subhi.w	fp, r2, r9
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004df6:	465b      	mov	r3, fp
 8004df8:	4642      	mov	r2, r8
 8004dfa:	4631      	mov	r1, r6
 8004dfc:	f00b fc18 	bl	8010630 <disk_write>
 8004e00:	2800      	cmp	r0, #0
 8004e02:	d1c4      	bne.n	8004d8e <f_write+0xaa>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8004e04:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 8004e06:	eba1 0108 	sub.w	r1, r1, r8
 8004e0a:	4559      	cmp	r1, fp
 8004e0c:	d20d      	bcs.n	8004e2a <f_write+0x146>
					memcpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 8004e0e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004e12:	eb06 2141 	add.w	r1, r6, r1, lsl #9
 8004e16:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 8004e1a:	f7fd ff77 	bl	8002d0c <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 8004e1e:	f894 2030 	ldrb.w	r2, [r4, #48]	@ 0x30
 8004e22:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 8004e26:	f884 2030 	strb.w	r2, [r4, #48]	@ 0x30
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 8004e2a:	ea4f 284b 	mov.w	r8, fp, lsl #9
				continue;
 8004e2e:	e02a      	b.n	8004e86 <f_write+0x1a2>
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8004e30:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8004e32:	4543      	cmp	r3, r8
 8004e34:	d011      	beq.n	8004e5a <f_write+0x176>
 8004e36:	e9d4 1304 	ldrd	r1, r3, [r4, #16]
 8004e3a:	e9d4 020e 	ldrd	r0, r2, [r4, #56]	@ 0x38
 8004e3e:	4288      	cmp	r0, r1
 8004e40:	eb72 0303 	sbcs.w	r3, r2, r3
 8004e44:	d209      	bcs.n	8004e5a <f_write+0x176>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 8004e46:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8004e4a:	2301      	movs	r3, #1
 8004e4c:	4642      	mov	r2, r8
 8004e4e:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004e52:	f00b fbab 	bl	80105ac <disk_read>
				fp->fptr < fp->obj.objsize &&
 8004e56:	2800      	cmp	r0, #0
 8004e58:	d199      	bne.n	8004d8e <f_write+0xaa>
			fp->sect = sect;
 8004e5a:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004e5e:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8004e60:	9b01      	ldr	r3, [sp, #4]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004e62:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8004e66:	f5c0 7800 	rsb	r8, r0, #512	@ 0x200
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 8004e6a:	45a8      	cmp	r8, r5
 8004e6c:	bf28      	it	cs
 8004e6e:	46a8      	movcs	r8, r5
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8004e70:	4418      	add	r0, r3
 8004e72:	4642      	mov	r2, r8
 8004e74:	4631      	mov	r1, r6
 8004e76:	f7fd ff49 	bl	8002d0c <mem_cpy>
		fp->flag |= FA_DIRTY;
 8004e7a:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004e7e:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8004e82:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
 8004e86:	683b      	ldr	r3, [r7, #0]
 8004e88:	4443      	add	r3, r8
 8004e8a:	603b      	str	r3, [r7, #0]
 8004e8c:	e9d4 320e 	ldrd	r3, r2, [r4, #56]	@ 0x38
 8004e90:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 8004e94:	eb18 0303 	adds.w	r3, r8, r3
 8004e98:	f142 0200 	adc.w	r2, r2, #0
 8004e9c:	4298      	cmp	r0, r3
 8004e9e:	eb71 0c02 	sbcs.w	ip, r1, r2
 8004ea2:	bf3c      	itt	cc
 8004ea4:	4618      	movcc	r0, r3
 8004ea6:	4611      	movcc	r1, r2
 8004ea8:	e9c4 320e 	strd	r3, r2, [r4, #56]	@ 0x38
 8004eac:	e9c4 0104 	strd	r0, r1, [r4, #16]
 8004eb0:	eba5 0508 	sub.w	r5, r5, r8
 8004eb4:	4446      	add	r6, r8
 8004eb6:	e73d      	b.n	8004d34 <f_write+0x50>
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8004eb8:	f04f 0b09 	mov.w	fp, #9
 8004ebc:	e001      	b.n	8004ec2 <f_write+0x1de>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8004ebe:	f04f 0b07 	mov.w	fp, #7
}
 8004ec2:	4658      	mov	r0, fp
 8004ec4:	b005      	add	sp, #20
 8004ec6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004ecc <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Open file to be synced */
)
{
 8004ecc:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8004ed0:	b098      	sub	sp, #96	@ 0x60
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8004ed2:	a901      	add	r1, sp, #4
{
 8004ed4:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8004ed6:	f7fd ffe7 	bl	8002ea8 <validate>
	if (res == FR_OK) {
 8004eda:	2800      	cmp	r0, #0
 8004edc:	f040 8086 	bne.w	8004fec <f_sync+0x120>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8004ee0:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004ee4:	f013 0040 	ands.w	r0, r3, #64	@ 0x40
 8004ee8:	f000 8081 	beq.w	8004fee <f_sync+0x122>
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8004eec:	061b      	lsls	r3, r3, #24
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8004eee:	9d01      	ldr	r5, [sp, #4]
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8004ef0:	d50f      	bpl.n	8004f12 <f_sync+0x46>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8004ef2:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8004ef4:	7868      	ldrb	r0, [r5, #1]
 8004ef6:	2301      	movs	r3, #1
 8004ef8:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004efc:	f00b fb98 	bl	8010630 <disk_write>
 8004f00:	b108      	cbz	r0, 8004f06 <f_sync+0x3a>
 8004f02:	2001      	movs	r0, #1
 8004f04:	e073      	b.n	8004fee <f_sync+0x122>
				fp->flag &= (BYTE)~FA_DIRTY;
 8004f06:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004f0a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004f0e:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 8004f12:	f00b fab9 	bl	8010488 <get_fattime>
#if FF_FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 8004f16:	782b      	ldrb	r3, [r5, #0]
 8004f18:	2b04      	cmp	r3, #4
			tm = GET_FATTIME();				/* Modified time */
 8004f1a:	4606      	mov	r6, r0
			if (fs->fs_type == FS_EXFAT) {
 8004f1c:	d141      	bne.n	8004fa2 <f_sync+0xd6>
				res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
 8004f1e:	4620      	mov	r0, r4
 8004f20:	f7fe f940 	bl	80031a4 <fill_first_frag>
				if (res == FR_OK) {
 8004f24:	2800      	cmp	r0, #0
 8004f26:	d162      	bne.n	8004fee <f_sync+0x122>
					res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 8004f28:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004f2a:	f04f 32ff 	mov.w	r2, #4294967295
 8004f2e:	4620      	mov	r0, r4
 8004f30:	f7fe f920 	bl	8003174 <fill_last_frag>
				}
				if (res == FR_OK) {
 8004f34:	2800      	cmp	r0, #0
 8004f36:	d15a      	bne.n	8004fee <f_sync+0x122>
	dp->obj.fs = obj->fs;
 8004f38:	6823      	ldr	r3, [r4, #0]
 8004f3a:	9302      	str	r3, [sp, #8]
	dp->obj.sclust = obj->c_scl;
 8004f3c:	6a23      	ldr	r3, [r4, #32]
 8004f3e:	9304      	str	r3, [sp, #16]
	dp->obj.stat = (BYTE)obj->c_size;
 8004f40:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8004f42:	f88d 300f 	strb.w	r3, [sp, #15]
	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 8004f46:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8004f4a:	e9cd 3006 	strd	r3, r0, [sp, #24]
	dp->blk_ofs = obj->c_ofs;
 8004f4e:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
	dp->obj.n_frag = 0;
 8004f50:	9009      	str	r0, [sp, #36]	@ 0x24
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 8004f52:	a802      	add	r0, sp, #8
	dp->blk_ofs = obj->c_ofs;
 8004f54:	9115      	str	r1, [sp, #84]	@ 0x54
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 8004f56:	f7fe f9cf 	bl	80032f8 <dir_sdi>
	if (res == FR_OK) {
 8004f5a:	2800      	cmp	r0, #0
 8004f5c:	d147      	bne.n	8004fee <f_sync+0x122>
		res = load_xdir(dp);		/* Load the object's entry block */
 8004f5e:	a802      	add	r0, sp, #8
 8004f60:	f7fe fef2 	bl	8003d48 <load_xdir>
					DIR dj;
					DEF_NAMBUF

					INIT_NAMBUF(fs);
					res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
					if (res == FR_OK) {
 8004f64:	2800      	cmp	r0, #0
 8004f66:	d142      	bne.n	8004fee <f_sync+0x122>
						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has been changed */
 8004f68:	692a      	ldr	r2, [r5, #16]
 8004f6a:	7913      	ldrb	r3, [r2, #4]
 8004f6c:	f043 0320 	orr.w	r3, r3, #32
 8004f70:	7113      	strb	r3, [r2, #4]
						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
 8004f72:	79e3      	ldrb	r3, [r4, #7]
 8004f74:	692a      	ldr	r2, [r5, #16]
 8004f76:	f043 0301 	orr.w	r3, r3, #1
 8004f7a:	f882 3021 	strb.w	r3, [r2, #33]	@ 0x21
						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);		/* Update start cluster */
 8004f7e:	692b      	ldr	r3, [r5, #16]
 8004f80:	68a2      	ldr	r2, [r4, #8]
 8004f82:	635a      	str	r2, [r3, #52]	@ 0x34
						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		/* Update file size */
 8004f84:	e9d4 8904 	ldrd	r8, r9, [r4, #16]
						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatFs does not support Valid File Size feature) */
						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
						fs->dirbuf[XDIR_ModTime10] = 0;
 8004f88:	7558      	strb	r0, [r3, #21]
						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		/* Update file size */
 8004f8a:	e9c3 890e 	strd	r8, r9, [r3, #56]	@ 0x38
						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatFs does not support Valid File Size feature) */
 8004f8e:	e9c3 890a 	strd	r8, r9, [r3, #40]	@ 0x28
						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
 8004f92:	60de      	str	r6, [r3, #12]
						st_dword(fs->dirbuf + XDIR_AccTime, 0);
 8004f94:	692b      	ldr	r3, [r5, #16]
 8004f96:	6118      	str	r0, [r3, #16]
						res = store_xdir(&dj);	/* Restore it to the directory */
 8004f98:	a802      	add	r0, sp, #8
 8004f9a:	f7fe ff69 	bl	8003e70 <store_xdir>
						if (res == FR_OK) {
 8004f9e:	bb30      	cbnz	r0, 8004fee <f_sync+0x122>
 8004fa0:	e01a      	b.n	8004fd8 <f_sync+0x10c>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 8004fa2:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 8004fa4:	4628      	mov	r0, r5
 8004fa6:	f7fd ffbb 	bl	8002f20 <move_window>
				if (res == FR_OK) {
 8004faa:	2800      	cmp	r0, #0
 8004fac:	d1a9      	bne.n	8004f02 <f_sync+0x36>
					dir = fp->dir_ptr;
 8004fae:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 8004fb0:	7ada      	ldrb	r2, [r3, #11]
 8004fb2:	f042 0220 	orr.w	r2, r2, #32
 8004fb6:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 8004fb8:	6821      	ldr	r1, [r4, #0]
 8004fba:	68a2      	ldr	r2, [r4, #8]
 8004fbc:	7809      	ldrb	r1, [r1, #0]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 8004fbe:	835a      	strh	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 8004fc0:	2903      	cmp	r1, #3
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8004fc2:	bf04      	itt	eq
 8004fc4:	0c12      	lsreq	r2, r2, #16
 8004fc6:	829a      	strheq	r2, [r3, #20]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8004fc8:	6922      	ldr	r2, [r4, #16]
 8004fca:	61da      	str	r2, [r3, #28]
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
					st_word(dir + DIR_LstAccDate, 0);
 8004fcc:	2200      	movs	r2, #0
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 8004fce:	f8c3 6016 	str.w	r6, [r3, #22]
					st_word(dir + DIR_LstAccDate, 0);
 8004fd2:	825a      	strh	r2, [r3, #18]
					fs->wflag = 1;
 8004fd4:	2301      	movs	r3, #1
 8004fd6:	70eb      	strb	r3, [r5, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8004fd8:	4628      	mov	r0, r5
 8004fda:	f7fe fb85 	bl	80036e8 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 8004fde:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004fe2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8004fe6:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
 8004fea:	e000      	b.n	8004fee <f_sync+0x122>
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8004fec:	2009      	movs	r0, #9
			}
		}
	}

	LEAVE_FF(fs, res);
}
 8004fee:	b018      	add	sp, #96	@ 0x60
 8004ff0:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

08004ff4 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Open file to be closed */
)
{
 8004ff4:	b513      	push	{r0, r1, r4, lr}
 8004ff6:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8004ff8:	f7ff ff68 	bl	8004ecc <f_sync>
	if (res == FR_OK)
 8004ffc:	b938      	cbnz	r0, 800500e <f_close+0x1a>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8004ffe:	a901      	add	r1, sp, #4
 8005000:	4620      	mov	r0, r4
 8005002:	f7fd ff51 	bl	8002ea8 <validate>
		if (res == FR_OK) {
 8005006:	b908      	cbnz	r0, 800500c <f_close+0x18>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
 8005008:	6020      	str	r0, [r4, #0]
 800500a:	e000      	b.n	800500e <f_close+0x1a>
		res = validate(&fp->obj, &fs);	/* Lock volume */
 800500c:	2009      	movs	r0, #9
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 800500e:	b002      	add	sp, #8
 8005010:	bd10      	pop	{r4, pc}
	...

08005014 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8005014:	b530      	push	{r4, r5, lr}
 8005016:	b085      	sub	sp, #20
 8005018:	9101      	str	r1, [sp, #4]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 800501a:	2800      	cmp	r0, #0
 800501c:	d03b      	beq.n	8005096 <f_opendir+0x82>
 800501e:	4604      	mov	r4, r0

	/* Get logical drive */
	res = mount_volume(&path, &fs, 0);
 8005020:	2200      	movs	r2, #0
 8005022:	a903      	add	r1, sp, #12
 8005024:	a801      	add	r0, sp, #4
 8005026:	f7fe fb99 	bl	800375c <mount_volume>
	if (res == FR_OK) {
 800502a:	2800      	cmp	r0, #0
 800502c:	d130      	bne.n	8005090 <f_opendir+0x7c>
		dp->obj.fs = fs;
 800502e:	9d03      	ldr	r5, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8005030:	9901      	ldr	r1, [sp, #4]
		dp->obj.fs = fs;
 8005032:	6025      	str	r5, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8005034:	4620      	mov	r0, r4
 8005036:	f7ff faa5 	bl	8004584 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 800503a:	bb20      	cbnz	r0, 8005086 <f_opendir+0x72>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 800503c:	f994 304b 	ldrsb.w	r3, [r4, #75]	@ 0x4b
 8005040:	2b00      	cmp	r3, #0
 8005042:	db18      	blt.n	8005076 <f_opendir+0x62>
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
 8005044:	79a3      	ldrb	r3, [r4, #6]
 8005046:	06db      	lsls	r3, r3, #27
 8005048:	d521      	bpl.n	800508e <f_opendir+0x7a>
#if FF_FS_EXFAT
					if (fs->fs_type == FS_EXFAT) {
 800504a:	7828      	ldrb	r0, [r5, #0]
 800504c:	2804      	cmp	r0, #4
 800504e:	d10e      	bne.n	800506e <f_opendir+0x5a>
						dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
 8005050:	68a3      	ldr	r3, [r4, #8]
 8005052:	6223      	str	r3, [r4, #32]
						dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 8005054:	6923      	ldr	r3, [r4, #16]
 8005056:	79e2      	ldrb	r2, [r4, #7]
						dp->obj.c_ofs = dp->blk_ofs;
						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
 8005058:	6928      	ldr	r0, [r5, #16]
						dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 800505a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800505e:	4313      	orrs	r3, r2
 8005060:	6263      	str	r3, [r4, #36]	@ 0x24
						dp->obj.c_ofs = dp->blk_ofs;
 8005062:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8005064:	62a3      	str	r3, [r4, #40]	@ 0x28
						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
 8005066:	4621      	mov	r1, r4
 8005068:	f7ff fa76 	bl	8004558 <init_alloc_info.isra.0>
 800506c:	e003      	b.n	8005076 <f_opendir+0x62>
					} else
#endif
					{
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800506e:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8005070:	f7ff fa80 	bl	8004574 <ld_clust.isra.0>
 8005074:	60a0      	str	r0, [r4, #8]
				} else {						/* This object is a file */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dp->obj.id = fs->id;
 8005076:	88eb      	ldrh	r3, [r5, #6]
 8005078:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 800507a:	2100      	movs	r1, #0
 800507c:	4620      	mov	r0, r4
 800507e:	f7fe f93b 	bl	80032f8 <dir_sdi>
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 8005082:	b148      	cbz	r0, 8005098 <f_opendir+0x84>
 8005084:	e004      	b.n	8005090 <f_opendir+0x7c>
					res = FR_NO_PATH;
 8005086:	2804      	cmp	r0, #4
 8005088:	bf08      	it	eq
 800508a:	2005      	moveq	r0, #5
 800508c:	e000      	b.n	8005090 <f_opendir+0x7c>
 800508e:	2005      	movs	r0, #5
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 8005090:	2300      	movs	r3, #0
 8005092:	6023      	str	r3, [r4, #0]
 8005094:	e000      	b.n	8005098 <f_opendir+0x84>
	if (!dp) return FR_INVALID_OBJECT;
 8005096:	2009      	movs	r0, #9

	LEAVE_FF(fs, res);
}
 8005098:	b005      	add	sp, #20
 800509a:	bd30      	pop	{r4, r5, pc}

0800509c <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 800509c:	b513      	push	{r0, r1, r4, lr}
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
 800509e:	a901      	add	r1, sp, #4
{
 80050a0:	4604      	mov	r4, r0
	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
 80050a2:	f7fd ff01 	bl	8002ea8 <validate>
	if (res == FR_OK) {
 80050a6:	b900      	cbnz	r0, 80050aa <f_closedir+0xe>
#if FF_FS_LOCK != 0
		if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
		if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
#else
		dp->obj.fs = 0;	/* Invalidate directory object */
 80050a8:	6020      	str	r0, [r4, #0]
#if FF_FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 80050aa:	b002      	add	sp, #8
 80050ac:	bd10      	pop	{r4, pc}
	...

080050b0 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 80050b0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80050b2:	460d      	mov	r5, r1
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 80050b4:	a901      	add	r1, sp, #4
{
 80050b6:	4604      	mov	r4, r0
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 80050b8:	f7fd fef6 	bl	8002ea8 <validate>
	if (res == FR_OK) {
 80050bc:	b9c8      	cbnz	r0, 80050f2 <f_readdir+0x42>
		if (!fno) {
 80050be:	b935      	cbnz	r5, 80050ce <f_readdir+0x1e>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80050c0:	4629      	mov	r1, r5
 80050c2:	4620      	mov	r0, r4
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 80050c4:	b002      	add	sp, #8
 80050c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 80050ca:	f7fe b915 	b.w	80032f8 <dir_sdi>
			res = DIR_READ_FILE(dp);		/* Read an item */
 80050ce:	4620      	mov	r0, r4
 80050d0:	f7fe ff28 	bl	8003f24 <dir_read.constprop.0>
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 80050d4:	f010 06fb 	ands.w	r6, r0, #251	@ 0xfb
 80050d8:	d10c      	bne.n	80050f4 <f_readdir+0x44>
				get_fileinfo(dp, fno);		/* Get the object information */
 80050da:	4629      	mov	r1, r5
 80050dc:	4620      	mov	r0, r4
 80050de:	f7fe fa1b 	bl	8003518 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 80050e2:	4631      	mov	r1, r6
 80050e4:	4620      	mov	r0, r4
 80050e6:	f7fe fdd1 	bl	8003c8c <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 80050ea:	2804      	cmp	r0, #4
 80050ec:	bf08      	it	eq
 80050ee:	2000      	moveq	r0, #0
 80050f0:	e000      	b.n	80050f4 <f_readdir+0x44>
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 80050f2:	2009      	movs	r0, #9
}
 80050f4:	b002      	add	sp, #8
 80050f6:	bd70      	pop	{r4, r5, r6, pc}

080050f8 <f_findnext>:

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
 80050f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80050fa:	4606      	mov	r6, r0
 80050fc:	460c      	mov	r4, r1


	for (;;) {
		res = f_readdir(dp, fno);		/* Get a directory item */
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
 80050fe:	f101 071a 	add.w	r7, r1, #26
		res = f_readdir(dp, fno);		/* Get a directory item */
 8005102:	4621      	mov	r1, r4
 8005104:	4630      	mov	r0, r6
 8005106:	f7ff ffd3 	bl	80050b0 <f_readdir>
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 800510a:	4605      	mov	r5, r0
 800510c:	b950      	cbnz	r0, 8005124 <f_findnext+0x2c>
 800510e:	b14c      	cbz	r4, 8005124 <f_findnext+0x2c>
 8005110:	7ea3      	ldrb	r3, [r4, #26]
 8005112:	b13b      	cbz	r3, 8005124 <f_findnext+0x2c>
		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
 8005114:	4602      	mov	r2, r0
 8005116:	2304      	movs	r3, #4
 8005118:	6d30      	ldr	r0, [r6, #80]	@ 0x50
 800511a:	4639      	mov	r1, r7
 800511c:	f7fd fe5a 	bl	8002dd4 <pattern_match>
 8005120:	2800      	cmp	r0, #0
 8005122:	d0ee      	beq.n	8005102 <f_findnext+0xa>
#if FF_USE_LFN && FF_USE_FIND == 2
		if (pattern_match(dp->pat, fno->altname, 0, FIND_RECURS)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
}
 8005124:	4628      	mov	r0, r5
 8005126:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005128 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 8005128:	b5f0      	push	{r4, r5, r6, r7, lr}
 800512a:	b0bd      	sub	sp, #244	@ 0xf4
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = mount_volume(&path, &fs, FA_WRITE);
 800512c:	2202      	movs	r2, #2
{
 800512e:	9001      	str	r0, [sp, #4]
	res = mount_volume(&path, &fs, FA_WRITE);
 8005130:	a903      	add	r1, sp, #12
 8005132:	a801      	add	r0, sp, #4
 8005134:	f7fe fb12 	bl	800375c <mount_volume>
	if (res == FR_OK) {
 8005138:	2800      	cmp	r0, #0
 800513a:	d14d      	bne.n	80051d8 <f_unlink+0xb0>
		dj.obj.fs = fs;
 800513c:	9c03      	ldr	r4, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
 800513e:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 8005140:	9410      	str	r4, [sp, #64]	@ 0x40
		res = follow_path(&dj, path);		/* Follow the file path */
 8005142:	a810      	add	r0, sp, #64	@ 0x40
 8005144:	f7ff fa1e 	bl	8004584 <follow_path>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
		}
#if FF_FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
#endif
		if (res == FR_OK) {					/* The object is accessible */
 8005148:	2800      	cmp	r0, #0
 800514a:	d145      	bne.n	80051d8 <f_unlink+0xb0>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 800514c:	f99d 308b 	ldrsb.w	r3, [sp, #139]	@ 0x8b
 8005150:	2b00      	cmp	r3, #0
 8005152:	db40      	blt.n	80051d6 <f_unlink+0xae>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
			} else {
				if (dj.obj.attr & AM_RDO) {
 8005154:	f89d 7046 	ldrb.w	r7, [sp, #70]	@ 0x46
 8005158:	07fa      	lsls	r2, r7, #31
 800515a:	d501      	bpl.n	8005160 <f_unlink+0x38>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 800515c:	2007      	movs	r0, #7
 800515e:	e03b      	b.n	80051d8 <f_unlink+0xb0>
				}
			}
			if (res == FR_OK) {
#if FF_FS_EXFAT
				obj.fs = fs;
				if (fs->fs_type == FS_EXFAT) {
 8005160:	7826      	ldrb	r6, [r4, #0]
				obj.fs = fs;
 8005162:	9404      	str	r4, [sp, #16]
				if (fs->fs_type == FS_EXFAT) {
 8005164:	2e04      	cmp	r6, #4
 8005166:	d105      	bne.n	8005174 <f_unlink+0x4c>
					init_alloc_info(fs, &obj);
 8005168:	6920      	ldr	r0, [r4, #16]
 800516a:	a904      	add	r1, sp, #16
 800516c:	f7ff f9f4 	bl	8004558 <init_alloc_info.isra.0>
					dclst = obj.sclust;
 8005170:	9d06      	ldr	r5, [sp, #24]
 8005172:	e004      	b.n	800517e <f_unlink+0x56>
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
 8005174:	991f      	ldr	r1, [sp, #124]	@ 0x7c
 8005176:	4630      	mov	r0, r6
 8005178:	f7ff f9fc 	bl	8004574 <ld_clust.isra.0>
 800517c:	4605      	mov	r5, r0
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 800517e:	06fb      	lsls	r3, r7, #27
 8005180:	d404      	bmi.n	800518c <f_unlink+0x64>
						}
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);			/* Remove the directory entry */
 8005182:	a810      	add	r0, sp, #64	@ 0x40
 8005184:	f7fe fea4 	bl	8003ed0 <dir_remove>
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 8005188:	b1c8      	cbz	r0, 80051be <f_unlink+0x96>
 800518a:	e025      	b.n	80051d8 <f_unlink+0xb0>
						if (fs->fs_type == FS_EXFAT) {
 800518c:	2e04      	cmp	r6, #4
						sdj.obj.fs = fs;			/* Open the sub-directory */
 800518e:	9426      	str	r4, [sp, #152]	@ 0x98
						sdj.obj.sclust = dclst;
 8005190:	9528      	str	r5, [sp, #160]	@ 0xa0
						if (fs->fs_type == FS_EXFAT) {
 8005192:	d107      	bne.n	80051a4 <f_unlink+0x7c>
							sdj.obj.objsize = obj.objsize;
 8005194:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8005198:	e9cd 232a 	strd	r2, r3, [sp, #168]	@ 0xa8
							sdj.obj.stat = obj.stat;
 800519c:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80051a0:	f88d 309f 	strb.w	r3, [sp, #159]	@ 0x9f
						res = dir_sdi(&sdj, 0);
 80051a4:	2100      	movs	r1, #0
 80051a6:	a826      	add	r0, sp, #152	@ 0x98
 80051a8:	f7fe f8a6 	bl	80032f8 <dir_sdi>
						if (res == FR_OK) {
 80051ac:	b9a0      	cbnz	r0, 80051d8 <f_unlink+0xb0>
							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
 80051ae:	a826      	add	r0, sp, #152	@ 0x98
 80051b0:	f7fe feb8 	bl	8003f24 <dir_read.constprop.0>
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 80051b4:	2800      	cmp	r0, #0
 80051b6:	d0d1      	beq.n	800515c <f_unlink+0x34>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 80051b8:	2804      	cmp	r0, #4
 80051ba:	d10d      	bne.n	80051d8 <f_unlink+0xb0>
 80051bc:	e7e1      	b.n	8005182 <f_unlink+0x5a>
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 80051be:	b91d      	cbnz	r5, 80051c8 <f_unlink+0xa0>
					res = remove_chain(&obj, dclst, 0);
#else
					res = remove_chain(&dj.obj, dclst, 0);
#endif
				}
				if (res == FR_OK) res = sync_fs(fs);
 80051c0:	4620      	mov	r0, r4
 80051c2:	f7fe fa91 	bl	80036e8 <sync_fs>
 80051c6:	e007      	b.n	80051d8 <f_unlink+0xb0>
					res = remove_chain(&obj, dclst, 0);
 80051c8:	4602      	mov	r2, r0
 80051ca:	4629      	mov	r1, r5
 80051cc:	a804      	add	r0, sp, #16
 80051ce:	f7fe f8db 	bl	8003388 <remove_chain>
				if (res == FR_OK) res = sync_fs(fs);
 80051d2:	b908      	cbnz	r0, 80051d8 <f_unlink+0xb0>
 80051d4:	e7f4      	b.n	80051c0 <f_unlink+0x98>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 80051d6:	2006      	movs	r0, #6
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 80051d8:	b03d      	add	sp, #244	@ 0xf4
 80051da:	bdf0      	pop	{r4, r5, r6, r7, pc}

080051dc <ff_uni2oem>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (uni < 0x80) {	/* ASCII? */
 80051dc:	287f      	cmp	r0, #127	@ 0x7f
 80051de:	d801      	bhi.n	80051e4 <ff_uni2oem+0x8>
		c = (WCHAR)uni;
 80051e0:	b280      	uxth	r0, r0
 80051e2:	4770      	bx	lr

	} else {			/* Non-ASCII */
		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 80051e4:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 80051e8:	d203      	bcs.n	80051f2 <ff_uni2oem+0x16>
 80051ea:	f240 3362 	movw	r3, #866	@ 0x362
 80051ee:	4299      	cmp	r1, r3
 80051f0:	d001      	beq.n	80051f6 <ff_uni2oem+0x1a>
	WCHAR c = 0;
 80051f2:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 80051f4:	4770      	bx	lr
 80051f6:	4a06      	ldr	r2, [pc, #24]	@ (8005210 <ff_uni2oem+0x34>)
		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 80051f8:	2300      	movs	r3, #0
 80051fa:	e002      	b.n	8005202 <ff_uni2oem+0x26>
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 80051fc:	3301      	adds	r3, #1
 80051fe:	2b80      	cmp	r3, #128	@ 0x80
 8005200:	d0f7      	beq.n	80051f2 <ff_uni2oem+0x16>
 8005202:	f832 1b02 	ldrh.w	r1, [r2], #2
 8005206:	4281      	cmp	r1, r0
 8005208:	d1f8      	bne.n	80051fc <ff_uni2oem+0x20>
			c = (c + 0x80) & 0xFF;
 800520a:	3380      	adds	r3, #128	@ 0x80
 800520c:	b298      	uxth	r0, r3
 800520e:	4770      	bx	lr
 8005210:	08013078 	.word	0x08013078

08005214 <ff_oem2uni>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (oem < 0x80) {	/* ASCII? */
 8005214:	287f      	cmp	r0, #127	@ 0x7f
 8005216:	d904      	bls.n	8005222 <ff_oem2uni+0xe>
		c = oem;

	} else {			/* Extended char */
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
 8005218:	f240 3362 	movw	r3, #866	@ 0x362
 800521c:	4299      	cmp	r1, r3
 800521e:	d001      	beq.n	8005224 <ff_oem2uni+0x10>
	WCHAR c = 0;
 8005220:	2000      	movs	r0, #0
			if (oem < 0x100) c = p[oem - 0x80];
		}
	}

	return c;
}
 8005222:	4770      	bx	lr
			if (oem < 0x100) c = p[oem - 0x80];
 8005224:	28ff      	cmp	r0, #255	@ 0xff
 8005226:	d8fb      	bhi.n	8005220 <ff_oem2uni+0xc>
 8005228:	f100 4000 	add.w	r0, r0, #2147483648	@ 0x80000000
 800522c:	4b02      	ldr	r3, [pc, #8]	@ (8005238 <ff_oem2uni+0x24>)
 800522e:	3880      	subs	r0, #128	@ 0x80
 8005230:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8005234:	4770      	bx	lr
 8005236:	bf00      	nop
 8005238:	08013078 	.word	0x08013078

0800523c <ff_wtoupper>:

		0x0000	/* EOT */
	};


	if (uni < 0x10000) {	/* Is it in BMP? */
 800523c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 8005240:	d21d      	bcs.n	800527e <ff_wtoupper+0x42>
{
 8005242:	b530      	push	{r4, r5, lr}
		uc = (WORD)uni;
 8005244:	b284      	uxth	r4, r0
		p = uc < 0x1000 ? cvt1 : cvt2;
 8005246:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
 800524a:	bf34      	ite	cc
 800524c:	4b22      	ldrcc	r3, [pc, #136]	@ (80052d8 <ff_wtoupper+0x9c>)
 800524e:	4b23      	ldrcs	r3, [pc, #140]	@ (80052dc <ff_wtoupper+0xa0>)
 8005250:	3304      	adds	r3, #4
 8005252:	e00d      	b.n	8005270 <ff_wtoupper+0x34>
		for (;;) {
			bc = *p++;								/* Get the block base */
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 8005254:	428c      	cmp	r4, r1
 8005256:	d310      	bcc.n	800527a <ff_wtoupper+0x3e>
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8005258:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 800525c:	fa5f fc82 	uxtb.w	ip, r2
			if (uc < bc + nc) {	/* In the block? */
 8005260:	eb0c 0e01 	add.w	lr, ip, r1
 8005264:	4570      	cmp	r0, lr
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8005266:	ea4f 2212 	mov.w	r2, r2, lsr #8
			if (uc < bc + nc) {	/* In the block? */
 800526a:	db09      	blt.n	8005280 <ff_wtoupper+0x44>
				case 7: uc -= 80; break;			/* Shift -80 */
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
				}
				break;
			}
			if (cmd == 0) p += nc;	/* Skip table if needed */
 800526c:	3304      	adds	r3, #4
 800526e:	b182      	cbz	r2, 8005292 <ff_wtoupper+0x56>
			bc = *p++;								/* Get the block base */
 8005270:	f833 1c04 	ldrh.w	r1, [r3, #-4]
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 8005274:	461d      	mov	r5, r3
 8005276:	2900      	cmp	r1, #0
 8005278:	d1ec      	bne.n	8005254 <ff_wtoupper+0x18>
		}
		uni = uc;
 800527a:	4620      	mov	r0, r4
	}

	return uni;
}
 800527c:	bd30      	pop	{r4, r5, pc}
 800527e:	4770      	bx	lr
				switch (cmd) {
 8005280:	2a08      	cmp	r2, #8
 8005282:	d8fa      	bhi.n	800527a <ff_wtoupper+0x3e>
 8005284:	e8df f002 	tbb	[pc, r2]
 8005288:	181b1e24 	.word	0x181b1e24
 800528c:	0c0f1215 	.word	0x0c0f1215
 8005290:	08          	.byte	0x08
 8005291:	00          	.byte	0x00
			if (cmd == 0) p += nc;	/* Skip table if needed */
 8005292:	eb05 034c 	add.w	r3, r5, ip, lsl #1
 8005296:	e7db      	b.n	8005250 <ff_wtoupper+0x14>
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
 8005298:	f5a4 54e3 	sub.w	r4, r4, #7264	@ 0x1c60
 800529c:	b2a4      	uxth	r4, r4
 800529e:	e7ec      	b.n	800527a <ff_wtoupper+0x3e>
				case 7: uc -= 80; break;			/* Shift -80 */
 80052a0:	3c50      	subs	r4, #80	@ 0x50
 80052a2:	b2a4      	uxth	r4, r4
 80052a4:	e7e9      	b.n	800527a <ff_wtoupper+0x3e>
				case 6:	uc += 8; break;				/* Shift +8 */
 80052a6:	3408      	adds	r4, #8
 80052a8:	b2a4      	uxth	r4, r4
 80052aa:	e7e6      	b.n	800527a <ff_wtoupper+0x3e>
				case 5:	uc -= 26; break;			/* Shift -26 */
 80052ac:	3c1a      	subs	r4, #26
 80052ae:	b2a4      	uxth	r4, r4
 80052b0:	e7e3      	b.n	800527a <ff_wtoupper+0x3e>
				case 4:	uc -= 48; break;			/* Shift -48 */
 80052b2:	3c30      	subs	r4, #48	@ 0x30
 80052b4:	b2a4      	uxth	r4, r4
 80052b6:	e7e0      	b.n	800527a <ff_wtoupper+0x3e>
				case 3:	uc -= 32; break;			/* Shift -32 */
 80052b8:	3c20      	subs	r4, #32
 80052ba:	b2a4      	uxth	r4, r4
 80052bc:	e7dd      	b.n	800527a <ff_wtoupper+0x3e>
				case 2: uc -= 16; break;			/* Shift -16 */
 80052be:	3c10      	subs	r4, #16
 80052c0:	b2a4      	uxth	r4, r4
 80052c2:	e7da      	b.n	800527a <ff_wtoupper+0x3e>
				case 1:	uc -= (uc - bc) & 1; break;	/* Case pairs */
 80052c4:	1a63      	subs	r3, r4, r1
 80052c6:	f003 0301 	and.w	r3, r3, #1
 80052ca:	1ae4      	subs	r4, r4, r3
 80052cc:	b2a4      	uxth	r4, r4
 80052ce:	e7d4      	b.n	800527a <ff_wtoupper+0x3e>
				case 0:	uc = p[uc - bc]; break;		/* Table conversion */
 80052d0:	1a40      	subs	r0, r0, r1
 80052d2:	f833 4010 	ldrh.w	r4, [r3, r0, lsl #1]
 80052d6:	e7d0      	b.n	800527a <ff_wtoupper+0x3e>
 80052d8:	08012e84 	.word	0x08012e84
 80052dc:	08012dc8 	.word	0x08012dc8

080052e0 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 80052e0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80052e2:	2320      	movs	r3, #32
 80052e4:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;
  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
 80052e8:	4803      	ldr	r0, [pc, #12]	@ (80052f8 <sof_handler+0x18>)
 80052ea:	f7fc fa4f 	bl	800178c <sduSOFHookI>
 80052ee:	2300      	movs	r3, #0
 80052f0:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlockFromISR();
}
 80052f4:	bd08      	pop	{r3, pc}
 80052f6:	bf00      	nop
 80052f8:	200007b0 	.word	0x200007b0

080052fc <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80052fc:	b538      	push	{r3, r4, r5, lr}
 80052fe:	460c      	mov	r4, r1
 8005300:	2320      	movs	r3, #32
 8005302:	f383 8811 	msr	BASEPRI, r3
  switch (event) {
 8005306:	2902      	cmp	r1, #2
 8005308:	d00c      	beq.n	8005324 <usb_event+0x28>
 800530a:	2903      	cmp	r1, #3
 800530c:	d003      	beq.n	8005316 <usb_event+0x1a>
 800530e:	2300      	movs	r3, #0
 8005310:	f383 8811 	msr	BASEPRI, r3
}
 8005314:	bd38      	pop	{r3, r4, r5, pc}
    sduDisconnectI(&SDU1);
 8005316:	480c      	ldr	r0, [pc, #48]	@ (8005348 <usb_event+0x4c>)
 8005318:	f7fc fa02 	bl	8001720 <sduDisconnectI>
 800531c:	2300      	movs	r3, #0
 800531e:	f383 8811 	msr	BASEPRI, r3
}
 8005322:	bd38      	pop	{r3, r4, r5, pc}
 8005324:	4605      	mov	r5, r0
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8005326:	4a09      	ldr	r2, [pc, #36]	@ (800534c <usb_event+0x50>)
 8005328:	2101      	movs	r1, #1
 800532a:	f7fc faf5 	bl	8001918 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 800532e:	4a08      	ldr	r2, [pc, #32]	@ (8005350 <usb_event+0x54>)
 8005330:	4621      	mov	r1, r4
 8005332:	4628      	mov	r0, r5
 8005334:	f7fc faf0 	bl	8001918 <usbInitEndpointI>
    sduConfigureHookI(&SDU1);
 8005338:	4803      	ldr	r0, [pc, #12]	@ (8005348 <usb_event+0x4c>)
 800533a:	f7fc f9fd 	bl	8001738 <sduConfigureHookI>
 800533e:	2300      	movs	r3, #0
 8005340:	f383 8811 	msr	BASEPRI, r3
}
 8005344:	bd38      	pop	{r3, r4, r5, pc}
 8005346:	bf00      	nop
 8005348:	200007b0 	.word	0x200007b0
 800534c:	08013a24 	.word	0x08013a24
 8005350:	08013a08 	.word	0x08013a08

08005354 <getSerialStringDescriptor>:
  uint32_t id0 = *(uint32_t *)0x1FFFF7AC; // MCU id0 address
 8005354:	4a17      	ldr	r2, [pc, #92]	@ (80053b4 <getSerialStringDescriptor+0x60>)
  id0+= id2;
 8005356:	f8d2 07b4 	ldr.w	r0, [r2, #1972]	@ 0x7b4
  uint32_t id0 = *(uint32_t *)0x1FFFF7AC; // MCU id0 address
 800535a:	f8d2 37ac 	ldr.w	r3, [r2, #1964]	@ 0x7ac
  uint64_t uid = id1;
 800535e:	f8d2 17b0 	ldr.w	r1, [r2, #1968]	@ 0x7b0
USBDescriptor *getSerialStringDescriptor(void) {
 8005362:	b510      	push	{r4, lr}
 8005364:	4c14      	ldr	r4, [pc, #80]	@ (80053b8 <getSerialStringDescriptor+0x64>)
  id0+= id2;
 8005366:	4403      	add	r3, r0
  uid|= id0 | (uid<<32);                  // generate unique 64bit ID
 8005368:	430b      	orrs	r3, r1
  for(i = 1; i < USB_SERIAL_STRING_SIZE + 1; i++) {
 800536a:	4620      	mov	r0, r4
 800536c:	f104 0e18 	add.w	lr, r4, #24
    uint16_t c = uid & ((1<<UID_RADIX) - 1);
 8005370:	f003 021f 	and.w	r2, r3, #31
    buf[i] = c + (c < 0x0A ? '0' : 'A' - 0x0A);
 8005374:	2a0a      	cmp	r2, #10
 8005376:	bf34      	ite	cc
 8005378:	f04f 0c30 	movcc.w	ip, #48	@ 0x30
 800537c:	f04f 0c37 	movcs.w	ip, #55	@ 0x37
 8005380:	4462      	add	r2, ip
 8005382:	f820 2f02 	strh.w	r2, [r0, #2]!
    uid>>= UID_RADIX;
 8005386:	095b      	lsrs	r3, r3, #5
  for(i = 1; i < USB_SERIAL_STRING_SIZE + 1; i++) {
 8005388:	4586      	cmp	lr, r0
    uid>>= UID_RADIX;
 800538a:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 800538e:	ea4f 1151 	mov.w	r1, r1, lsr #5
  for(i = 1; i < USB_SERIAL_STRING_SIZE + 1; i++) {
 8005392:	d1ed      	bne.n	8005370 <getSerialStringDescriptor+0x1c>
  buf[0] = size | (USB_DESCRIPTOR_STRING << 8);
 8005394:	4809      	ldr	r0, [pc, #36]	@ (80053bc <getSerialStringDescriptor+0x68>)
 8005396:	f240 311a 	movw	r1, #794	@ 0x31a
  d->ud_size   = size;
 800539a:	2300      	movs	r3, #0
 800539c:	221a      	movs	r2, #26
  buf[0] = size | (USB_DESCRIPTOR_STRING << 8);
 800539e:	f8a0 1fe0 	strh.w	r1, [r0, #4064]	@ 0xfe0
  d->ud_size   = size;
 80053a2:	f8a0 2fd8 	strh.w	r2, [r0, #4056]	@ 0xfd8
 80053a6:	f8a0 3fda 	strh.w	r3, [r0, #4058]	@ 0xfda
  d->ud_string = (uint8_t *)buf;
 80053aa:	f8c0 4fdc 	str.w	r4, [r0, #4060]	@ 0xfdc
}
 80053ae:	f600 70d8 	addw	r0, r0, #4056	@ 0xfd8
 80053b2:	bd10      	pop	{r4, pc}
 80053b4:	1ffff000 	.word	0x1ffff000
 80053b8:	200099d4 	.word	0x200099d4
 80053bc:	200089f4 	.word	0x200089f4

080053c0 <get_descriptor>:
  switch (dtype) {
 80053c0:	2902      	cmp	r1, #2
 80053c2:	d00e      	beq.n	80053e2 <get_descriptor+0x22>
 80053c4:	2903      	cmp	r1, #3
 80053c6:	d003      	beq.n	80053d0 <get_descriptor+0x10>
 80053c8:	2901      	cmp	r1, #1
 80053ca:	d108      	bne.n	80053de <get_descriptor+0x1e>
    return &vcom_device_descriptor;
 80053cc:	4809      	ldr	r0, [pc, #36]	@ (80053f4 <get_descriptor+0x34>)
 80053ce:	4770      	bx	lr
    if (dindex == STR_SERIAL && VNA_MODE(VNA_MODE_USB_UID))
 80053d0:	2a03      	cmp	r2, #3
 80053d2:	d008      	beq.n	80053e6 <get_descriptor+0x26>
    if (dindex < 4)
 80053d4:	d803      	bhi.n	80053de <get_descriptor+0x1e>
      return &vcom_strings[dindex];
 80053d6:	4808      	ldr	r0, [pc, #32]	@ (80053f8 <get_descriptor+0x38>)
 80053d8:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 80053dc:	4770      	bx	lr
  return NULL;
 80053de:	2000      	movs	r0, #0
}
 80053e0:	4770      	bx	lr
  switch (dtype) {
 80053e2:	4806      	ldr	r0, [pc, #24]	@ (80053fc <get_descriptor+0x3c>)
 80053e4:	4770      	bx	lr
    if (dindex == STR_SERIAL && VNA_MODE(VNA_MODE_USB_UID))
 80053e6:	4b06      	ldr	r3, [pc, #24]	@ (8005400 <get_descriptor+0x40>)
 80053e8:	8a9b      	ldrh	r3, [r3, #20]
 80053ea:	05db      	lsls	r3, r3, #23
 80053ec:	d5f3      	bpl.n	80053d6 <get_descriptor+0x16>
      return getSerialStringDescriptor();
 80053ee:	f7ff bfb1 	b.w	8005354 <getSerialStringDescriptor>
 80053f2:	bf00      	nop
 80053f4:	08013ae8 	.word	0x08013ae8
 80053f8:	08013a40 	.word	0x08013a40
 80053fc:	08013a9c 	.word	0x08013a9c
 8005400:	20000318 	.word	0x20000318

08005404 <getSWRfromIndex>:
// SWR = (1 + ||) / (1 - ||),    = S11
// If || is invalid or >= 1, return a very large SWR.
// ---------------------------------------------------------------------------
static float getSWRfromIndex(uint16_t i)
{
  if (i >= sweep_points)
 8005404:	4b14      	ldr	r3, [pc, #80]	@ (8005458 <getSWRfromIndex+0x54>)
 8005406:	8b5b      	ldrh	r3, [r3, #26]
 8005408:	4283      	cmp	r3, r0
 800540a:	d921      	bls.n	8005450 <getSWRfromIndex+0x4c>
    return 9999.0f;

  float re = measured[0][i][0];
 800540c:	4b13      	ldr	r3, [pc, #76]	@ (800545c <getSWRfromIndex+0x58>)
 800540e:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
  float im = measured[0][i][1];
 8005412:	edd3 7a01 	vldr	s15, [r3, #4]
  float re = measured[0][i][0];
 8005416:	ed93 7a00 	vldr	s14, [r3]
  float mag2 = re * re + im * im;
 800541a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800541e:	eee7 7a07 	vfma.f32	s15, s14, s14

  if (mag2 <= 0.0f)
 8005422:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8005426:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800542a:	d911      	bls.n	8005450 <getSWRfromIndex+0x4c>
// VNA math used library
#ifdef __USE_VNA_MATH__
// Some functions implemented in hardware FPU
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800542c:	eef1 7ae7 	vsqrt.f32	s15, s15
    return 9999.0f;

  float mag = vna_sqrtf(mag2); // ||

  if (mag >= 0.9999f)
 8005430:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 8005460 <getSWRfromIndex+0x5c>
 8005434:	eef4 7ac7 	vcmpe.f32	s15, s14
 8005438:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800543c:	da08      	bge.n	8005450 <getSWRfromIndex+0x4c>
    return 9999.0f;

  return (1.0f + mag) / (1.0f - mag);
 800543e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8005442:	ee77 6a87 	vadd.f32	s13, s15, s14
 8005446:	ee37 7a67 	vsub.f32	s14, s14, s15
 800544a:	ee86 0a87 	vdiv.f32	s0, s13, s14
 800544e:	4770      	bx	lr
    return 9999.0f;
 8005450:	ed9f 0a04 	vldr	s0, [pc, #16]	@ 8005464 <getSWRfromIndex+0x60>
}
 8005454:	4770      	bx	lr
 8005456:	bf00      	nop
 8005458:	20000aa8 	.word	0x20000aa8
 800545c:	20004f54 	.word	0x20004f54
 8005460:	3f7ff972 	.word	0x3f7ff972
 8005464:	461c3c00 	.word	0x461c3c00

08005468 <shell_write>:
  formatted_bytes = chvprintf(shell_stream, fmt, ap);
  va_end(ap);
  return formatted_bytes;
}

static void shell_write(const void *buf, uint32_t size) { streamWrite(shell_stream, buf, size); }
 8005468:	4b05      	ldr	r3, [pc, #20]	@ (8005480 <shell_write+0x18>)
 800546a:	681b      	ldr	r3, [r3, #0]
 800546c:	b410      	push	{r4}
 800546e:	681c      	ldr	r4, [r3, #0]
 8005470:	6824      	ldr	r4, [r4, #0]
 8005472:	460a      	mov	r2, r1
 8005474:	4601      	mov	r1, r0
 8005476:	4618      	mov	r0, r3
 8005478:	4623      	mov	r3, r4
 800547a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800547e:	4718      	bx	r3
 8005480:	200068a4 	.word	0x200068a4

08005484 <cmd_reson>:
  }

  shell_printf("MLA resonance: f = %u Hz (idx=%u)" VNA_SHELL_NEWLINE_STR,
               (unsigned)mla_res_freq,
               (unsigned)mla_res_idx);
}
 8005484:	4770      	bx	lr
 8005486:	bf00      	nop

08005488 <eterm_calc_er>:
  cal_status |= CALSTAT_ES;
}

static void
eterm_calc_er(int sign)
{
 8005488:	b410      	push	{r4}
  int i;
  for (i = 0; i < sweep_points; i++)
 800548a:	4c27      	ldr	r4, [pc, #156]	@ (8005528 <eterm_calc_er+0xa0>)
 800548c:	8b63      	ldrh	r3, [r4, #26]
 800548e:	2b00      	cmp	r3, #0
 8005490:	d041      	beq.n	8005516 <eterm_calc_er+0x8e>
 8005492:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
 8005496:	4622      	mov	r2, r4
 8005498:	f604 5158 	addw	r1, r4, #3416	@ 0xd58
 800549c:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 80054a0:	f504 53cf 	add.w	r3, r4, #6624	@ 0x19e0
  {
    // Er = sign*(1-sign*Es)S11ms'
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 80054a4:	edd2 4a35 	vldr	s9, [r2, #212]	@ 0xd4
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 80054a8:	ed92 4a34 	vldr	s8, [r2, #208]	@ 0xd0
 80054ac:	edd3 5a00 	vldr	s11, [r3]
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 80054b0:	edd3 7a01 	vldr	s15, [r3, #4]
    float esr = cal_data[ETERM_ES][i][0];
    float esi = cal_data[ETERM_ES][i][1];
 80054b4:	ed91 6a01 	vldr	s12, [r1, #4]
    float esr = cal_data[ETERM_ES][i][0];
 80054b8:	ed91 5a00 	vldr	s10, [r1]
    {
      esr = -esr;
      esi = -esi;
    }
    esr = 1 + esr;
    float err = esr * s11sr - esi * s11si;
 80054bc:	ee74 6ae7 	vsub.f32	s13, s9, s15
    float eri = esr * s11si + esi * s11sr;
 80054c0:	ee34 7a65 	vsub.f32	s14, s8, s11
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 80054c4:	ee75 5ac4 	vsub.f32	s11, s11, s8
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 80054c8:	ee77 7ae4 	vsub.f32	s15, s15, s9
    float err = esr * s11sr - esi * s11si;
 80054cc:	ee66 6a66 	vnmul.f32	s13, s12, s13
    esr = 1 + esr;
 80054d0:	ee75 3a03 	vadd.f32	s7, s10, s6
    float eri = esr * s11si + esi * s11sr;
 80054d4:	ee27 7a06 	vmul.f32	s14, s14, s12
 80054d8:	ee33 5a45 	vsub.f32	s10, s6, s10
 80054dc:	ee65 4a86 	vmul.f32	s9, s11, s12
    if (sign > 0)
 80054e0:	2801      	cmp	r0, #1
    float eri = esr * s11si + esi * s11sr;
 80054e2:	eee7 4aa3 	vfma.f32	s9, s15, s7
    float err = esr * s11sr - esi * s11si;
 80054e6:	eee5 6a85 	vfma.f32	s13, s11, s10
    float eri = esr * s11si + esi * s11sr;
 80054ea:	eea7 7a85 	vfma.f32	s14, s15, s10
    float err = esr * s11sr - esi * s11si;
 80054ee:	ee27 6a86 	vmul.f32	s12, s15, s12
    if (sign > 0)
 80054f2:	d005      	beq.n	8005500 <eterm_calc_er+0x78>
    if (sign < 0)
    {
      err = -err;
 80054f4:	eef0 6a46 	vmov.f32	s13, s12
 80054f8:	eee5 6ae3 	vfms.f32	s13, s11, s7
      eri = -eri;
 80054fc:	eeb1 7a64 	vneg.f32	s14, s9
  for (i = 0; i < sweep_points; i++)
 8005500:	3208      	adds	r2, #8
 8005502:	4562      	cmp	r2, ip
    }
    cal_data[ETERM_ER][i][0] = err;
 8005504:	edc3 6a00 	vstr	s13, [r3]
    cal_data[ETERM_ER][i][1] = eri;
 8005508:	ed83 7a01 	vstr	s14, [r3, #4]
  for (i = 0; i < sweep_points; i++)
 800550c:	f101 0108 	add.w	r1, r1, #8
 8005510:	f103 0308 	add.w	r3, r3, #8
 8005514:	d1c6      	bne.n	80054a4 <eterm_calc_er+0x1c>
  }
  cal_status &= ~CALSTAT_SHORT;
 8005516:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
 8005518:	f023 0304 	bic.w	r3, r3, #4
  cal_status |= CALSTAT_ER;
 800551c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8005520:	84a3      	strh	r3, [r4, #36]	@ 0x24
}
 8005522:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005526:	4770      	bx	lr
 8005528:	20000aa8 	.word	0x20000aa8

0800552c <cmd_help>:

VNA_SHELL_FUNCTION(cmd_help)
{
  (void)argc;
  (void)argv;
  const VNAShellCommand *scp = commands;
 800552c:	4b02      	ldr	r3, [pc, #8]	@ (8005538 <cmd_help+0xc>)
  shell_printf("Commands:");
  while (scp->sc_name != NULL)
 800552e:	f853 2f0a 	ldr.w	r2, [r3, #10]!
 8005532:	2a00      	cmp	r2, #0
 8005534:	d1fb      	bne.n	800552e <cmd_help+0x2>
    shell_printf(" %s", scp->sc_name);
    scp++;
  }
  shell_printf(VNA_SHELL_NEWLINE_STR);
  return;
}
 8005536:	4770      	bx	lr
 8005538:	08013d30 	.word	0x08013d30

0800553c <set_domain_mode>:
  if (mode != (props_mode & DOMAIN_MODE))
 800553c:	4a09      	ldr	r2, [pc, #36]	@ (8005564 <set_domain_mode+0x28>)
{
 800553e:	b508      	push	{r3, lr}
  if (mode != (props_mode & DOMAIN_MODE))
 8005540:	8b13      	ldrh	r3, [r2, #24]
 8005542:	f003 0101 	and.w	r1, r3, #1
 8005546:	4281      	cmp	r1, r0
 8005548:	d100      	bne.n	800554c <set_domain_mode+0x10>
}
 800554a:	bd08      	pop	{r3, pc}
    props_mode = (props_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
 800554c:	f023 0301 	bic.w	r3, r3, #1
 8005550:	4303      	orrs	r3, r0
    request_to_redraw(REDRAW_FREQUENCY | REDRAW_MARKER);
 8005552:	2028      	movs	r0, #40	@ 0x28
    props_mode = (props_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
 8005554:	8313      	strh	r3, [r2, #24]
    request_to_redraw(REDRAW_FREQUENCY | REDRAW_MARKER);
 8005556:	f006 f94b 	bl	800b7f0 <request_to_redraw>
    lever_mode = LM_MARKER;
 800555a:	4b03      	ldr	r3, [pc, #12]	@ (8005568 <set_domain_mode+0x2c>)
 800555c:	2200      	movs	r2, #0
 800555e:	771a      	strb	r2, [r3, #28]
}
 8005560:	bd08      	pop	{r3, pc}
 8005562:	bf00      	nop
 8005564:	20000aa8 	.word	0x20000aa8
 8005568:	20000318 	.word	0x20000318

0800556c <cal_interpolate>:
{
 800556c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005570:	ed2d 8b02 	vpush	{d8}
  if (idx >= 0)
 8005574:	1e06      	subs	r6, r0, #0
{
 8005576:	b083      	sub	sp, #12
 8005578:	4615      	mov	r5, r2
  if (idx >= 0)
 800557a:	da7e      	bge.n	800567a <cal_interpolate+0x10e>
  if (f <= cal_frequency0)
 800557c:	4c59      	ldr	r4, [pc, #356]	@ (80056e4 <cal_interpolate+0x178>)
 800557e:	f8d4 a00c 	ldr.w	sl, [r4, #12]
 8005582:	458a      	cmp	sl, r1
 8005584:	460f      	mov	r7, r1
 8005586:	f080 808e 	bcs.w	80056a6 <cal_interpolate+0x13a>
  uint16_t src_points = cal_sweep_points - 1;
 800558a:	f8b4 9022 	ldrh.w	r9, [r4, #34]	@ 0x22
  if (f >= cal_frequency1)
 800558e:	6920      	ldr	r0, [r4, #16]
  uint16_t src_points = cal_sweep_points - 1;
 8005590:	f109 39ff 	add.w	r9, r9, #4294967295
  if (f >= cal_frequency1)
 8005594:	4288      	cmp	r0, r1
  uint16_t src_points = cal_sweep_points - 1;
 8005596:	fa1f f989 	uxth.w	r9, r9
  if (f >= cal_frequency1)
 800559a:	f240 8086 	bls.w	80056aa <cal_interpolate+0x13e>
  freq_t span = cal_frequency1 - cal_frequency0;
 800559e:	eba0 080a 	sub.w	r8, r0, sl
  idx = (uint64_t)(f - cal_frequency0) * (uint64_t)src_points / span;
 80055a2:	eba1 000a 	sub.w	r0, r1, sl
 80055a6:	4642      	mov	r2, r8
 80055a8:	2300      	movs	r3, #0
 80055aa:	fba0 0109 	umull	r0, r1, r0, r9
 80055ae:	f7fb f9ad 	bl	800090c <__aeabi_uldivmod>
 80055b2:	4606      	mov	r6, r0
  uint64_t v = (uint64_t)span * idx + src_points / 2;
 80055b4:	fba6 cb08 	umull	ip, fp, r6, r8
 80055b8:	17c0      	asrs	r0, r0, #31
 80055ba:	ea4f 0159 	mov.w	r1, r9, lsr #1
 80055be:	eb1c 0101 	adds.w	r1, ip, r1
 80055c2:	fb08 bb00 	mla	fp, r8, r0, fp
 80055c6:	f14b 0b00 	adc.w	fp, fp, #0
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 80055ca:	464a      	mov	r2, r9
 80055cc:	2300      	movs	r3, #0
 80055ce:	9101      	str	r1, [sp, #4]
 80055d0:	4608      	mov	r0, r1
 80055d2:	4659      	mov	r1, fp
 80055d4:	f7fb f99a 	bl	800090c <__aeabi_uldivmod>
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 80055d8:	9901      	ldr	r1, [sp, #4]
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 80055da:	4603      	mov	r3, r0
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 80055dc:	eb18 0001 	adds.w	r0, r8, r1
 80055e0:	f14b 0100 	adc.w	r1, fp, #0
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 80055e4:	4698      	mov	r8, r3
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 80055e6:	464a      	mov	r2, r9
 80055e8:	2300      	movs	r3, #0
 80055ea:	f7fb f98f 	bl	800090c <__aeabi_uldivmod>
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 80055ee:	eb0a 0b08 	add.w	fp, sl, r8
  if (f == src_f0)
 80055f2:	455f      	cmp	r7, fp
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 80055f4:	4482      	add	sl, r0
  freq_t delta = src_f1 - src_f0;
 80055f6:	eba0 0008 	sub.w	r0, r0, r8
  if (f == src_f0)
 80055fa:	d03f      	beq.n	800567c <cal_interpolate+0x110>
  float k = (delta == 0) ? 0.0f : (float)(f - src_f0) / delta;
 80055fc:	2800      	cmp	r0, #0
 80055fe:	d056      	beq.n	80056ae <cal_interpolate+0x142>
 8005600:	eba7 030b 	sub.w	r3, r7, fp
 8005604:	ee07 0a90 	vmov	s15, r0
 8005608:	ee07 3a10 	vmov	s14, r3
 800560c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005610:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8005614:	ee87 8a27 	vdiv.f32	s16, s14, s15
  uint32_t hf0 = si5351_get_harmonic_lvl(src_f0);
 8005618:	4658      	mov	r0, fp
 800561a:	f003 fc9b 	bl	8008f54 <si5351_get_harmonic_lvl>
 800561e:	4680      	mov	r8, r0
  if (hf0 != si5351_get_harmonic_lvl(src_f1))
 8005620:	4650      	mov	r0, sl
 8005622:	f003 fc97 	bl	8008f54 <si5351_get_harmonic_lvl>
 8005626:	4540      	cmp	r0, r8
 8005628:	d144      	bne.n	80056b4 <cal_interpolate+0x148>
      idx++;
 800562a:	1c73      	adds	r3, r6, #1
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 800562c:	1d2a      	adds	r2, r5, #4
 800562e:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
 8005632:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8005636:	352c      	adds	r5, #44	@ 0x2c
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 8005638:	edd6 7a34 	vldr	s15, [r6, #208]	@ 0xd0
 800563c:	ed93 7a34 	vldr	s14, [r3, #208]	@ 0xd0
 8005640:	ee37 7a67 	vsub.f32	s14, s14, s15
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 8005644:	4611      	mov	r1, r2
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 8005646:	eee7 7a08 	vfma.f32	s15, s14, s16
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 800564a:	3208      	adds	r2, #8
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 800564c:	ed42 7a03 	vstr	s15, [r2, #-12]
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 8005650:	edd6 7a35 	vldr	s15, [r6, #212]	@ 0xd4
 8005654:	ed93 7a35 	vldr	s14, [r3, #212]	@ 0xd4
 8005658:	ee37 7a67 	vsub.f32	s14, s14, s15
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 800565c:	4295      	cmp	r5, r2
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 800565e:	eee7 7a08 	vfma.f32	s15, s14, s16
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 8005662:	f606 4688 	addw	r6, r6, #3208	@ 0xc88
 8005666:	f603 4388 	addw	r3, r3, #3208	@ 0xc88
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 800566a:	edc1 7a00 	vstr	s15, [r1]
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 800566e:	d1e3      	bne.n	8005638 <cal_interpolate+0xcc>
}
 8005670:	b003      	add	sp, #12
 8005672:	ecbd 8b02 	vpop	{d8}
 8005676:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800567a:	4c1a      	ldr	r4, [pc, #104]	@ (80056e4 <cal_interpolate+0x178>)
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 800567c:	1d2b      	adds	r3, r5, #4
 800567e:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 8005682:	352c      	adds	r5, #44	@ 0x2c
    data[eterm][0] = cal_data[eterm][idx][0];
 8005684:	f8d4 20d0 	ldr.w	r2, [r4, #208]	@ 0xd0
 8005688:	f843 2c04 	str.w	r2, [r3, #-4]
    data[eterm][1] = cal_data[eterm][idx][1];
 800568c:	f8d4 20d4 	ldr.w	r2, [r4, #212]	@ 0xd4
 8005690:	f843 2b08 	str.w	r2, [r3], #8
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 8005694:	429d      	cmp	r5, r3
 8005696:	f604 4488 	addw	r4, r4, #3208	@ 0xc88
 800569a:	d1f3      	bne.n	8005684 <cal_interpolate+0x118>
}
 800569c:	b003      	add	sp, #12
 800569e:	ecbd 8b02 	vpop	{d8}
 80056a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    idx = 0;
 80056a6:	2600      	movs	r6, #0
 80056a8:	e7e8      	b.n	800567c <cal_interpolate+0x110>
    idx = src_points;
 80056aa:	464e      	mov	r6, r9
    goto copy_point;
 80056ac:	e7e6      	b.n	800567c <cal_interpolate+0x110>
  float k = (delta == 0) ? 0.0f : (float)(f - src_f0) / delta;
 80056ae:	ed9f 8a0e 	vldr	s16, [pc, #56]	@ 80056e8 <cal_interpolate+0x17c>
 80056b2:	e7b1      	b.n	8005618 <cal_interpolate+0xac>
    if (hf0 == si5351_get_harmonic_lvl(f))
 80056b4:	4638      	mov	r0, r7
 80056b6:	f003 fc4d 	bl	8008f54 <si5351_get_harmonic_lvl>
 80056ba:	4540      	cmp	r0, r8
 80056bc:	d008      	beq.n	80056d0 <cal_interpolate+0x164>
      if (idx >= src_points)
 80056be:	45b1      	cmp	r9, r6
 80056c0:	dddc      	ble.n	800567c <cal_interpolate+0x110>
      k -= 1.0f;
 80056c2:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 80056c6:	1cb3      	adds	r3, r6, #2
      k -= 1.0f;
 80056c8:	ee38 8a67 	vsub.f32	s16, s16, s15
      idx++;
 80056cc:	3601      	adds	r6, #1
 80056ce:	e7ad      	b.n	800562c <cal_interpolate+0xc0>
      if (idx < 1)
 80056d0:	2e00      	cmp	r6, #0
 80056d2:	ddd3      	ble.n	800567c <cal_interpolate+0x110>
      k += 1.0f;
 80056d4:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80056d8:	4633      	mov	r3, r6
 80056da:	ee38 8a27 	vadd.f32	s16, s16, s15
      idx--;
 80056de:	3e01      	subs	r6, #1
 80056e0:	e7a4      	b.n	800562c <cal_interpolate+0xc0>
 80056e2:	bf00      	nop
 80056e4:	20000aa8 	.word	0x20000aa8
 80056e8:	00000000 	.word	0x00000000

080056ec <cmd_refresh>:
  if (argc != 1)
 80056ec:	2801      	cmp	r0, #1
 80056ee:	d000      	beq.n	80056f2 <cmd_refresh+0x6>
 80056f0:	4770      	bx	lr
{
 80056f2:	b508      	push	{r3, lr}
 80056f4:	460b      	mov	r3, r1
  int enable = get_str_index(argv[0], cmd_enable_list);
 80056f6:	490e      	ldr	r1, [pc, #56]	@ (8005730 <cmd_refresh+0x44>)
 80056f8:	6818      	ldr	r0, [r3, #0]
 80056fa:	f003 fa1b 	bl	8008b34 <get_str_index>
  if (enable == 0)
 80056fe:	b160      	cbz	r0, 800571a <cmd_refresh+0x2e>
  else if (enable == 1)
 8005700:	2801      	cmp	r0, #1
 8005702:	d104      	bne.n	800570e <cmd_refresh+0x22>
    sweep_mode &= ~SWEEP_REMOTE;
 8005704:	4a0b      	ldr	r2, [pc, #44]	@ (8005734 <cmd_refresh+0x48>)
 8005706:	7813      	ldrb	r3, [r2, #0]
 8005708:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800570c:	7013      	strb	r3, [r2, #0]
}
 800570e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_FREQUENCY | REDRAW_CAL_STATUS | REDRAW_AREA | REDRAW_BATTERY);
 8005712:	f44f 708d 	mov.w	r0, #282	@ 0x11a
 8005716:	f006 b86b 	b.w	800b7f0 <request_to_redraw>
    sweep_mode |= SWEEP_REMOTE;
 800571a:	4a06      	ldr	r2, [pc, #24]	@ (8005734 <cmd_refresh+0x48>)
 800571c:	7813      	ldrb	r3, [r2, #0]
 800571e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8005722:	7013      	strb	r3, [r2, #0]
}
 8005724:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_FREQUENCY | REDRAW_CAL_STATUS | REDRAW_AREA | REDRAW_BATTERY);
 8005728:	f44f 708d 	mov.w	r0, #282	@ 0x11a
 800572c:	f006 b860 	b.w	800b7f0 <request_to_redraw>
 8005730:	08013ca0 	.word	0x08013ca0
 8005734:	200003c4 	.word	0x200003c4

08005738 <VNAShell_parceLine>:
  PREPARE_STREAM;
}
#endif

static const VNAShellCommand *VNAShell_parceLine(char *line)
{
 8005738:	b538      	push	{r3, r4, r5, lr}
  // Parse and execute line
  shell_nargs = parse_line(line, shell_args, ARRAY_COUNT(shell_args));
 800573a:	2205      	movs	r2, #5
 800573c:	490c      	ldr	r1, [pc, #48]	@ (8005770 <VNAShell_parceLine+0x38>)
 800573e:	f003 fa15 	bl	8008b6c <parse_line>
 8005742:	b280      	uxth	r0, r0
 8005744:	4a0b      	ldr	r2, [pc, #44]	@ (8005774 <VNAShell_parceLine+0x3c>)
  if (shell_nargs > ARRAY_COUNT(shell_args))
 8005746:	1e43      	subs	r3, r0, #1
 8005748:	2b04      	cmp	r3, #4
  shell_nargs = parse_line(line, shell_args, ARRAY_COUNT(shell_args));
 800574a:	8010      	strh	r0, [r2, #0]
  if (shell_nargs > ARRAY_COUNT(shell_args))
 800574c:	d80d      	bhi.n	800576a <VNAShell_parceLine+0x32>
    return NULL;
  }
  if (shell_nargs > 0)
  {
    const VNAShellCommand *scp;
    for (scp = commands; scp->sc_name != NULL; scp++)
 800574e:	4c0a      	ldr	r4, [pc, #40]	@ (8005778 <VNAShell_parceLine+0x40>)
 8005750:	480a      	ldr	r0, [pc, #40]	@ (800577c <VNAShell_parceLine+0x44>)
 8005752:	4d07      	ldr	r5, [pc, #28]	@ (8005770 <VNAShell_parceLine+0x38>)
 8005754:	e002      	b.n	800575c <VNAShell_parceLine+0x24>
 8005756:	f854 0f0a 	ldr.w	r0, [r4, #10]!
 800575a:	b130      	cbz	r0, 800576a <VNAShell_parceLine+0x32>
      if (get_str_index(scp->sc_name, shell_args[0]) == 0)
 800575c:	6829      	ldr	r1, [r5, #0]
 800575e:	f003 f9e9 	bl	8008b34 <get_str_index>
 8005762:	2800      	cmp	r0, #0
 8005764:	d1f7      	bne.n	8005756 <VNAShell_parceLine+0x1e>
        return scp;
  }
  return NULL;
}
 8005766:	4620      	mov	r0, r4
 8005768:	bd38      	pop	{r3, r4, r5, pc}
    return NULL;
 800576a:	2400      	movs	r4, #0
}
 800576c:	4620      	mov	r0, r4
 800576e:	bd38      	pop	{r3, r4, r5, pc}
 8005770:	20006888 	.word	0x20006888
 8005774:	20006884 	.word	0x20006884
 8005778:	08013d30 	.word	0x08013d30
 800577c:	08011980 	.word	0x08011980

08005780 <cmd_transform>:
{
 8005780:	b570      	push	{r4, r5, r6, lr}
  if (argc == 0)
 8005782:	1e06      	subs	r6, r0, #0
 8005784:	dd18      	ble.n	80057b8 <cmd_transform+0x38>
 8005786:	1f0c      	subs	r4, r1, #4
  for (i = 0; i < argc; i++)
 8005788:	2500      	movs	r5, #0
    switch (get_str_index(argv[i], cmd_transform_list))
 800578a:	f854 0f04 	ldr.w	r0, [r4, #4]!
 800578e:	4921      	ldr	r1, [pc, #132]	@ (8005814 <cmd_transform+0x94>)
 8005790:	f003 f9d0 	bl	8008b34 <get_str_index>
 8005794:	2807      	cmp	r0, #7
 8005796:	d80f      	bhi.n	80057b8 <cmd_transform+0x38>
 8005798:	e8df f000 	tbb	[pc, r0]
 800579c:	232b3337 	.word	0x232b3337
 80057a0:	040f151d 	.word	0x040f151d
  props_mode = (props_mode & ~TD_WINDOW) | func;
 80057a4:	4a1c      	ldr	r2, [pc, #112]	@ (8005818 <cmd_transform+0x98>)
 80057a6:	8b13      	ldrh	r3, [r2, #24]
 80057a8:	f023 0318 	bic.w	r3, r3, #24
 80057ac:	f043 0310 	orr.w	r3, r3, #16
 80057b0:	8313      	strh	r3, [r2, #24]
  for (i = 0; i < argc; i++)
 80057b2:	3501      	adds	r5, #1
 80057b4:	42ae      	cmp	r6, r5
 80057b6:	d1e8      	bne.n	800578a <cmd_transform+0xa>
}
 80057b8:	bd70      	pop	{r4, r5, r6, pc}
  props_mode = (props_mode & ~TD_WINDOW) | func;
 80057ba:	4a17      	ldr	r2, [pc, #92]	@ (8005818 <cmd_transform+0x98>)
 80057bc:	8b13      	ldrh	r3, [r2, #24]
 80057be:	f023 0318 	bic.w	r3, r3, #24
 80057c2:	8313      	strh	r3, [r2, #24]
}
 80057c4:	e7f5      	b.n	80057b2 <cmd_transform+0x32>
  props_mode = (props_mode & ~TD_WINDOW) | func;
 80057c6:	4a14      	ldr	r2, [pc, #80]	@ (8005818 <cmd_transform+0x98>)
 80057c8:	8b13      	ldrh	r3, [r2, #24]
 80057ca:	f023 0318 	bic.w	r3, r3, #24
 80057ce:	f043 0308 	orr.w	r3, r3, #8
 80057d2:	8313      	strh	r3, [r2, #24]
}
 80057d4:	e7ed      	b.n	80057b2 <cmd_transform+0x32>
  props_mode = (props_mode & ~TD_FUNC) | func;
 80057d6:	4a10      	ldr	r2, [pc, #64]	@ (8005818 <cmd_transform+0x98>)
 80057d8:	8b13      	ldrh	r3, [r2, #24]
 80057da:	f023 0306 	bic.w	r3, r3, #6
 80057de:	8313      	strh	r3, [r2, #24]
}
 80057e0:	e7e7      	b.n	80057b2 <cmd_transform+0x32>
  props_mode = (props_mode & ~TD_FUNC) | func;
 80057e2:	4a0d      	ldr	r2, [pc, #52]	@ (8005818 <cmd_transform+0x98>)
 80057e4:	8b13      	ldrh	r3, [r2, #24]
 80057e6:	f023 0306 	bic.w	r3, r3, #6
 80057ea:	f043 0304 	orr.w	r3, r3, #4
 80057ee:	8313      	strh	r3, [r2, #24]
}
 80057f0:	e7df      	b.n	80057b2 <cmd_transform+0x32>
  props_mode = (props_mode & ~TD_FUNC) | func;
 80057f2:	4a09      	ldr	r2, [pc, #36]	@ (8005818 <cmd_transform+0x98>)
 80057f4:	8b13      	ldrh	r3, [r2, #24]
 80057f6:	f023 0306 	bic.w	r3, r3, #6
 80057fa:	f043 0302 	orr.w	r3, r3, #2
 80057fe:	8313      	strh	r3, [r2, #24]
}
 8005800:	e7d7      	b.n	80057b2 <cmd_transform+0x32>
      set_domain_mode(DOMAIN_FREQ);
 8005802:	2000      	movs	r0, #0
 8005804:	f7ff fe9a 	bl	800553c <set_domain_mode>
      break;
 8005808:	e7d3      	b.n	80057b2 <cmd_transform+0x32>
      set_domain_mode(DOMAIN_TIME);
 800580a:	2001      	movs	r0, #1
 800580c:	f7ff fe96 	bl	800553c <set_domain_mode>
      break;
 8005810:	e7cf      	b.n	80057b2 <cmd_transform+0x32>
 8005812:	bf00      	nop
 8005814:	08013cd4 	.word	0x08013cd4
 8005818:	20000aa8 	.word	0x20000aa8

0800581c <cmd_measure>:
  if (argc == 1 && (idx = get_str_index(argv[0], cmd_measure_list)) >= 0)
 800581c:	2801      	cmp	r0, #1
 800581e:	d000      	beq.n	8005822 <cmd_measure+0x6>
 8005820:	4770      	bx	lr
{
 8005822:	b508      	push	{r3, lr}
 8005824:	460b      	mov	r3, r1
  if (argc == 1 && (idx = get_str_index(argv[0], cmd_measure_list)) >= 0)
 8005826:	4906      	ldr	r1, [pc, #24]	@ (8005840 <cmd_measure+0x24>)
 8005828:	6818      	ldr	r0, [r3, #0]
 800582a:	f003 f983 	bl	8008b34 <get_str_index>
 800582e:	2800      	cmp	r0, #0
 8005830:	da00      	bge.n	8005834 <cmd_measure+0x18>
}
 8005832:	bd08      	pop	{r3, pc}
 8005834:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    plot_set_measure_mode(idx);
 8005838:	b2c0      	uxtb	r0, r0
 800583a:	f005 bfed 	b.w	800b818 <plot_set_measure_mode>
 800583e:	bf00      	nop
 8005840:	08013c68 	.word	0x08013c68

08005844 <cmd_color>:
  if (argc != 2)
 8005844:	2802      	cmp	r0, #2
 8005846:	d000      	beq.n	800584a <cmd_color+0x6>
 8005848:	4770      	bx	lr
{
 800584a:	b570      	push	{r4, r5, r6, lr}
  i = my_atoui(argv[0]);
 800584c:	6808      	ldr	r0, [r1, #0]
 800584e:	460c      	mov	r4, r1
 8005850:	f003 f8b0 	bl	80089b4 <my_atoui>
  if (i >= MAX_PALETTE)
 8005854:	b283      	uxth	r3, r0
 8005856:	2b1f      	cmp	r3, #31
  i = my_atoui(argv[0]);
 8005858:	4605      	mov	r5, r0
  if (i >= MAX_PALETTE)
 800585a:	d900      	bls.n	800585e <cmd_color+0x1a>
}
 800585c:	bd70      	pop	{r4, r5, r6, pc}
  color = RGBHEX(my_atoui(argv[1]));
 800585e:	6860      	ldr	r0, [r4, #4]
 8005860:	f003 f8a8 	bl	80089b4 <my_atoui>
 8005864:	4606      	mov	r6, r0
 8005866:	6860      	ldr	r0, [r4, #4]
 8005868:	f003 f8a4 	bl	80089b4 <my_atoui>
 800586c:	00f6      	lsls	r6, r6, #3
 800586e:	0143      	lsls	r3, r0, #5
 8005870:	f403 53f8 	and.w	r3, r3, #7936	@ 0x1f00
 8005874:	6860      	ldr	r0, [r4, #4]
 8005876:	f406 4660 	and.w	r6, r6, #57344	@ 0xe000
 800587a:	431e      	orrs	r6, r3
 800587c:	f003 f89a 	bl	80089b4 <my_atoui>
 8005880:	0c03      	lsrs	r3, r0, #16
 8005882:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 8005886:	6860      	ldr	r0, [r4, #4]
 8005888:	431e      	orrs	r6, r3
 800588a:	f003 f893 	bl	80089b4 <my_atoui>
  config._lcd_palette[i] = color;
 800588e:	4a07      	ldr	r2, [pc, #28]	@ (80058ac <cmd_color+0x68>)
 8005890:	b2ad      	uxth	r5, r5
 8005892:	eb02 0245 	add.w	r2, r2, r5, lsl #1
  color = RGBHEX(my_atoui(argv[1]));
 8005896:	f3c0 3342 	ubfx	r3, r0, #13, #3
 800589a:	4333      	orrs	r3, r6
  request_to_redraw(REDRAW_ALL);
 800589c:	f240 301a 	movw	r0, #794	@ 0x31a
}
 80058a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  config._lcd_palette[i] = color;
 80058a4:	83d3      	strh	r3, [r2, #30]
  request_to_redraw(REDRAW_ALL);
 80058a6:	f005 bfa3 	b.w	800b7f0 <request_to_redraw>
 80058aa:	bf00      	nop
 80058ac:	20000318 	.word	0x20000318

080058b0 <cmd_threshold>:
  if (argc != 1)
 80058b0:	2801      	cmp	r0, #1
 80058b2:	d000      	beq.n	80058b6 <cmd_threshold+0x6>
 80058b4:	4770      	bx	lr
{
 80058b6:	b508      	push	{r3, lr}
  value = my_atoui(argv[0]);
 80058b8:	6808      	ldr	r0, [r1, #0]
 80058ba:	f003 f87b 	bl	80089b4 <my_atoui>
  config._harmonic_freq_threshold = value;
 80058be:	4b01      	ldr	r3, [pc, #4]	@ (80058c4 <cmd_threshold+0x14>)
 80058c0:	6058      	str	r0, [r3, #4]
}
 80058c2:	bd08      	pop	{r3, pc}
 80058c4:	20000318 	.word	0x20000318

080058c8 <cmd_vbat_offset>:
  if (argc != 1)
 80058c8:	2801      	cmp	r0, #1
 80058ca:	d000      	beq.n	80058ce <cmd_vbat_offset+0x6>
 80058cc:	4770      	bx	lr
{
 80058ce:	b508      	push	{r3, lr}
  config._vbat_offset = (int16_t)my_atoi(argv[0]);
 80058d0:	6808      	ldr	r0, [r1, #0]
 80058d2:	f003 f855 	bl	8008980 <my_atoi>
 80058d6:	4b01      	ldr	r3, [pc, #4]	@ (80058dc <cmd_vbat_offset+0x14>)
 80058d8:	8318      	strh	r0, [r3, #24]
}
 80058da:	bd08      	pop	{r3, pc}
 80058dc:	20000318 	.word	0x20000318

080058e0 <cmd_dump>:
{
 80058e0:	b510      	push	{r4, lr}
  dump_buffer = dump;
 80058e2:	4b16      	ldr	r3, [pc, #88]	@ (800593c <cmd_dump+0x5c>)
  dump_len = ARRAY_COUNT(dump);
 80058e4:	4c16      	ldr	r4, [pc, #88]	@ (8005940 <cmd_dump+0x60>)
{
 80058e6:	b0e0      	sub	sp, #384	@ 0x180
  dump_buffer = dump;
 80058e8:	f8c3 d000 	str.w	sp, [r3]
  dump_len = ARRAY_COUNT(dump);
 80058ec:	23c0      	movs	r3, #192	@ 0xc0
 80058ee:	8023      	strh	r3, [r4, #0]
  if (argc == 1)
 80058f0:	2801      	cmp	r0, #1
  int len = dump_len;
 80058f2:	8823      	ldrh	r3, [r4, #0]
  if (argc == 1)
 80058f4:	d019      	beq.n	800592a <cmd_dump+0x4a>
  tlv320aic3204_select(0);
 80058f6:	2000      	movs	r0, #0
 80058f8:	f003 fcce 	bl	8009298 <tlv320aic3204_select>
  DSP_START(DELAY_SWEEP_START);
 80058fc:	4b11      	ldr	r3, [pc, #68]	@ (8005944 <cmd_dump+0x64>)
 80058fe:	4912      	ldr	r1, [pc, #72]	@ (8005948 <cmd_dump+0x68>)
 8005900:	8b5b      	ldrh	r3, [r3, #26]
  return (systime_t)STM32_ST_TIM->CNT;
 8005902:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8005906:	3302      	adds	r3, #2
 8005908:	b29b      	uxth	r3, r3
 800590a:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 800590c:	800b      	strh	r3, [r1, #0]
  while (dump_len > 0)
 800590e:	8823      	ldrh	r3, [r4, #0]
  DSP_START(DELAY_SWEEP_START);
 8005910:	490e      	ldr	r1, [pc, #56]	@ (800594c <cmd_dump+0x6c>)
  while (dump_len > 0)
 8005912:	b21b      	sxth	r3, r3
  DSP_START(DELAY_SWEEP_START);
 8005914:	32c8      	adds	r2, #200	@ 0xc8
  while (dump_len > 0)
 8005916:	2b00      	cmp	r3, #0
  DSP_START(DELAY_SWEEP_START);
 8005918:	600a      	str	r2, [r1, #0]
  while (dump_len > 0)
 800591a:	dd04      	ble.n	8005926 <cmd_dump+0x46>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 800591c:	bf30      	wfi
 800591e:	8823      	ldrh	r3, [r4, #0]
 8005920:	b21b      	sxth	r3, r3
 8005922:	2b00      	cmp	r3, #0
 8005924:	dcfa      	bgt.n	800591c <cmd_dump+0x3c>
}
 8005926:	b060      	add	sp, #384	@ 0x180
 8005928:	bd10      	pop	{r4, pc}
    dump_selection = my_atoi(argv[0]) == 1 ? 0 : 1;
 800592a:	6808      	ldr	r0, [r1, #0]
 800592c:	f003 f828 	bl	8008980 <my_atoi>
 8005930:	4b07      	ldr	r3, [pc, #28]	@ (8005950 <cmd_dump+0x70>)
 8005932:	3801      	subs	r0, #1
 8005934:	bf18      	it	ne
 8005936:	2001      	movne	r0, #1
 8005938:	8018      	strh	r0, [r3, #0]
 800593a:	e7dc      	b.n	80058f6 <cmd_dump+0x16>
 800593c:	20000aa4 	.word	0x20000aa4
 8005940:	20000aa2 	.word	0x20000aa2
 8005944:	20000318 	.word	0x20000318
 8005948:	20000a98 	.word	0x20000a98
 800594c:	20000a9c 	.word	0x20000a9c
 8005950:	20000aa0 	.word	0x20000aa0

08005954 <cmd_data>:
  if (argc == 1)
 8005954:	2801      	cmp	r0, #1
 8005956:	d000      	beq.n	800595a <cmd_data+0x6>
}
 8005958:	4770      	bx	lr
    sel = my_atoi(argv[0]);
 800595a:	6808      	ldr	r0, [r1, #0]
 800595c:	f003 b810 	b.w	8008980 <my_atoi>

08005960 <cmd_config>:
  if (argc == 2 && (idx = get_str_index(argv[0], cmd_mode_list)) >= 0)
 8005960:	2802      	cmp	r0, #2
 8005962:	d000      	beq.n	8005966 <cmd_config+0x6>
 8005964:	4770      	bx	lr
{
 8005966:	b538      	push	{r3, r4, r5, lr}
 8005968:	460c      	mov	r4, r1
  if (argc == 2 && (idx = get_str_index(argv[0], cmd_mode_list)) >= 0)
 800596a:	4908      	ldr	r1, [pc, #32]	@ (800598c <cmd_config+0x2c>)
 800596c:	6820      	ldr	r0, [r4, #0]
 800596e:	f003 f8e1 	bl	8008b34 <get_str_index>
 8005972:	1e05      	subs	r5, r0, #0
 8005974:	da00      	bge.n	8005978 <cmd_config+0x18>
}
 8005976:	bd38      	pop	{r3, r4, r5, pc}
    apply_VNA_mode(idx, my_atoui(argv[1]));
 8005978:	6860      	ldr	r0, [r4, #4]
 800597a:	f003 f81b 	bl	80089b4 <my_atoui>
 800597e:	b2c1      	uxtb	r1, r0
 8005980:	b2a8      	uxth	r0, r5
}
 8005982:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    apply_VNA_mode(idx, my_atoui(argv[1]));
 8005986:	f009 bd3d 	b.w	800f404 <apply_VNA_mode>
 800598a:	bf00      	nop
 800598c:	08013ca8 	.word	0x08013ca8

08005990 <cmd_reset>:
  if (argc == 1)
 8005990:	2801      	cmp	r0, #1
{
 8005992:	b508      	push	{r3, lr}
  if (argc == 1)
 8005994:	d109      	bne.n	80059aa <cmd_reset+0x1a>
    if (get_str_index(argv[0], "dfu") == 0)
 8005996:	460b      	mov	r3, r1
 8005998:	490a      	ldr	r1, [pc, #40]	@ (80059c4 <cmd_reset+0x34>)
 800599a:	6818      	ldr	r0, [r3, #0]
 800599c:	f003 f8ca 	bl	8008b34 <get_str_index>
 80059a0:	b918      	cbnz	r0, 80059aa <cmd_reset+0x1a>
}
 80059a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      ui_enter_dfu();
 80059a6:	f009 bd17 	b.w	800f3d8 <ui_enter_dfu>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80059aa:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80059ae:	4906      	ldr	r1, [pc, #24]	@ (80059c8 <cmd_reset+0x38>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80059b0:	4b06      	ldr	r3, [pc, #24]	@ (80059cc <cmd_reset+0x3c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80059b2:	68ca      	ldr	r2, [r1, #12]
 80059b4:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80059b8:	4313      	orrs	r3, r2
 80059ba:	60cb      	str	r3, [r1, #12]
 80059bc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 80059c0:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */
  while(1) { __NOP(); }                                             /* wait until reset */
 80059c2:	e7fd      	b.n	80059c0 <cmd_reset+0x30>
 80059c4:	08011988 	.word	0x08011988
 80059c8:	e000ed00 	.word	0xe000ed00
 80059cc:	05fa0004 	.word	0x05fa0004

080059d0 <cmd_tcxo>:
  if (argc != 1)
 80059d0:	2801      	cmp	r0, #1
 80059d2:	d000      	beq.n	80059d6 <cmd_tcxo+0x6>
 80059d4:	4770      	bx	lr
{
 80059d6:	b508      	push	{r3, lr}
  si5351_set_tcxo(my_atoui(argv[0]));
 80059d8:	6808      	ldr	r0, [r1, #0]
 80059da:	f002 ffeb 	bl	80089b4 <my_atoui>
}
 80059de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  si5351_set_tcxo(my_atoui(argv[0]));
 80059e2:	f003 ba8f 	b.w	8008f04 <si5351_set_tcxo>
 80059e6:	bf00      	nop

080059e8 <cmd_vbat>:
  shell_printf("%d m" S_VOLT VNA_SHELL_NEWLINE_STR, adc_vbat_read());
 80059e8:	f00b b870 	b.w	8010acc <adc_vbat_read>

080059ec <cmd_release>:
  if (argc == 2)
 80059ec:	2802      	cmp	r0, #2
{
 80059ee:	b538      	push	{r3, r4, r5, lr}
  if (argc == 2)
 80059f0:	d008      	beq.n	8005a04 <cmd_release+0x18>
  int16_t x = -1, y = -1;
 80059f2:	f04f 32ff 	mov.w	r2, #4294967295
 80059f6:	4615      	mov	r5, r2
  remote_touch_set(REMOTE_RELEASE, x, y);
 80059f8:	4629      	mov	r1, r5
 80059fa:	2002      	movs	r0, #2
}
 80059fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  remote_touch_set(REMOTE_RELEASE, x, y);
 8005a00:	f009 bfc2 	b.w	800f988 <remote_touch_set>
    x = my_atoi(argv[0]);
 8005a04:	6808      	ldr	r0, [r1, #0]
 8005a06:	460c      	mov	r4, r1
 8005a08:	f002 ffba 	bl	8008980 <my_atoi>
 8005a0c:	b205      	sxth	r5, r0
    y = my_atoi(argv[1]);
 8005a0e:	6860      	ldr	r0, [r4, #4]
 8005a10:	f002 ffb6 	bl	8008980 <my_atoi>
  remote_touch_set(REMOTE_RELEASE, x, y);
 8005a14:	4629      	mov	r1, r5
    y = my_atoi(argv[1]);
 8005a16:	b202      	sxth	r2, r0
}
 8005a18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  remote_touch_set(REMOTE_RELEASE, x, y);
 8005a1c:	2002      	movs	r0, #2
 8005a1e:	f009 bfb3 	b.w	800f988 <remote_touch_set>
 8005a22:	bf00      	nop

08005a24 <cmd_touch>:
  if (argc != 2)
 8005a24:	2802      	cmp	r0, #2
 8005a26:	d000      	beq.n	8005a2a <cmd_touch+0x6>
 8005a28:	4770      	bx	lr
{
 8005a2a:	b538      	push	{r3, r4, r5, lr}
  remote_touch_set(REMOTE_PRESS, my_atoi(argv[0]), my_atoi(argv[1]));
 8005a2c:	6808      	ldr	r0, [r1, #0]
 8005a2e:	460c      	mov	r4, r1
 8005a30:	f002 ffa6 	bl	8008980 <my_atoi>
 8005a34:	4605      	mov	r5, r0
 8005a36:	6860      	ldr	r0, [r4, #4]
 8005a38:	f002 ffa2 	bl	8008980 <my_atoi>
 8005a3c:	b229      	sxth	r1, r5
 8005a3e:	b202      	sxth	r2, r0
}
 8005a40:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  remote_touch_set(REMOTE_PRESS, my_atoi(argv[0]), my_atoi(argv[1]));
 8005a44:	2001      	movs	r0, #1
 8005a46:	f009 bf9f 	b.w	800f988 <remote_touch_set>
 8005a4a:	bf00      	nop

08005a4c <cmd_save>:
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 8005a4c:	2801      	cmp	r0, #1
 8005a4e:	d000      	beq.n	8005a52 <cmd_save+0x6>
 8005a50:	4770      	bx	lr
{
 8005a52:	b508      	push	{r3, lr}
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 8005a54:	6808      	ldr	r0, [r1, #0]
 8005a56:	f002 ffad 	bl	80089b4 <my_atoui>
 8005a5a:	2806      	cmp	r0, #6
 8005a5c:	d900      	bls.n	8005a60 <cmd_save+0x14>
}
 8005a5e:	bd08      	pop	{r3, pc}
    caldata_save(id);
 8005a60:	f00a feda 	bl	8010818 <caldata_save>
}
 8005a64:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    request_to_redraw(REDRAW_CAL_STATUS);
 8005a68:	2010      	movs	r0, #16
 8005a6a:	f005 bec1 	b.w	800b7f0 <request_to_redraw>
 8005a6e:	bf00      	nop

08005a70 <cmd_msg>:
  if (argc == 0)
 8005a70:	b900      	cbnz	r0, 8005a74 <cmd_msg+0x4>
 8005a72:	4770      	bx	lr
{
 8005a74:	b538      	push	{r3, r4, r5, lr}
 8005a76:	4604      	mov	r4, r0
  uint32_t delay = my_atoui(argv[0]);
 8005a78:	6808      	ldr	r0, [r1, #0]
 8005a7a:	460d      	mov	r5, r1
 8005a7c:	f002 ff9a 	bl	80089b4 <my_atoui>
  if (argc > 1)
 8005a80:	2c01      	cmp	r4, #1
  uint32_t delay = my_atoui(argv[0]);
 8005a82:	4602      	mov	r2, r0
  if (argc > 1)
 8005a84:	dd07      	ble.n	8005a96 <cmd_msg+0x26>
  if (argc > 2)
 8005a86:	2c02      	cmp	r4, #2
    text = argv[1];
 8005a88:	6869      	ldr	r1, [r5, #4]
  if (argc > 2)
 8005a8a:	d00a      	beq.n	8005aa2 <cmd_msg+0x32>
    header = argv[2];
 8005a8c:	68a8      	ldr	r0, [r5, #8]
}
 8005a8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ui_message_box(header, text, delay);
 8005a92:	f008 bf77 	b.w	800e984 <ui_message_box>
  char *header = 0, *text = 0;
 8005a96:	2100      	movs	r1, #0
 8005a98:	4608      	mov	r0, r1
}
 8005a9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ui_message_box(header, text, delay);
 8005a9e:	f008 bf71 	b.w	800e984 <ui_message_box>
  char *header = 0, *text = 0;
 8005aa2:	2000      	movs	r0, #0
 8005aa4:	e7f9      	b.n	8005a9a <cmd_msg+0x2a>
 8005aa6:	bf00      	nop

08005aa8 <cmd_touchtest>:
  ui_touch_draw_test();
 8005aa8:	f009 bbc6 	b.w	800f238 <ui_touch_draw_test>

08005aac <cmd_touchcal>:
{
 8005aac:	b508      	push	{r3, lr}
  ui_touch_cal_exec();
 8005aae:	f009 fb9d 	bl	800f1ec <ui_touch_cal_exec>
}
 8005ab2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_ALL);
 8005ab6:	f240 301a 	movw	r0, #794	@ 0x31a
 8005aba:	f005 be99 	b.w	800b7f0 <request_to_redraw>
 8005abe:	bf00      	nop

08005ac0 <cmd_clearconfig>:
  if (argc != 1)
 8005ac0:	2801      	cmp	r0, #1
 8005ac2:	d000      	beq.n	8005ac6 <cmd_clearconfig+0x6>
 8005ac4:	4770      	bx	lr
{
 8005ac6:	b508      	push	{r3, lr}
 8005ac8:	460b      	mov	r3, r1
  if (get_str_index(argv[0], "1234") != 0)
 8005aca:	4905      	ldr	r1, [pc, #20]	@ (8005ae0 <cmd_clearconfig+0x20>)
 8005acc:	6818      	ldr	r0, [r3, #0]
 8005ace:	f003 f831 	bl	8008b34 <get_str_index>
 8005ad2:	b100      	cbz	r0, 8005ad6 <cmd_clearconfig+0x16>
}
 8005ad4:	bd08      	pop	{r3, pc}
 8005ad6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  clear_all_config_prop_data();
 8005ada:	f00a bf1f 	b.w	801091c <clear_all_config_prop_data>
 8005ade:	bf00      	nop
 8005ae0:	0801198c 	.word	0x0801198c

08005ae4 <cmd_saveconfig>:
  config_save();
 8005ae4:	f00a be58 	b.w	8010798 <config_save>

08005ae8 <cmd_sd_card_mount>:
  const FRESULT res = f_mount(fs_volume, "", 1);
 8005ae8:	4902      	ldr	r1, [pc, #8]	@ (8005af4 <cmd_sd_card_mount+0xc>)
 8005aea:	4803      	ldr	r0, [pc, #12]	@ (8005af8 <cmd_sd_card_mount+0x10>)
 8005aec:	2201      	movs	r2, #1
 8005aee:	f7fe bed3 	b.w	8004898 <f_mount>
 8005af2:	bf00      	nop
 8005af4:	0801220c 	.word	0x0801220c
 8005af8:	200097b8 	.word	0x200097b8

08005afc <cmd_sd_delete>:
  if (argc != 1)
 8005afc:	2801      	cmp	r0, #1
 8005afe:	d000      	beq.n	8005b02 <cmd_sd_delete+0x6>
 8005b00:	4770      	bx	lr
{
 8005b02:	b510      	push	{r4, lr}
 8005b04:	460c      	mov	r4, r1
  if (cmd_sd_card_mount() != FR_OK)
 8005b06:	f7ff ffef 	bl	8005ae8 <cmd_sd_card_mount>
 8005b0a:	b100      	cbz	r0, 8005b0e <cmd_sd_delete+0x12>
}
 8005b0c:	bd10      	pop	{r4, pc}
  res = f_unlink(filename);
 8005b0e:	6820      	ldr	r0, [r4, #0]
}
 8005b10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  res = f_unlink(filename);
 8005b14:	f7ff bb08 	b.w	8005128 <f_unlink>

08005b18 <cmd_sd_read>:
  if (argc != 1)
 8005b18:	2801      	cmp	r0, #1
 8005b1a:	d000      	beq.n	8005b1e <cmd_sd_read+0x6>
 8005b1c:	4770      	bx	lr
{
 8005b1e:	b530      	push	{r4, r5, lr}
 8005b20:	b083      	sub	sp, #12
  const char *filename = argv[0];
 8005b22:	680d      	ldr	r5, [r1, #0]
  if (cmd_sd_card_mount() != FR_OK)
 8005b24:	4604      	mov	r4, r0
 8005b26:	f7ff ffdf 	bl	8005ae8 <cmd_sd_card_mount>
 8005b2a:	b108      	cbz	r0, 8005b30 <cmd_sd_read+0x18>
}
 8005b2c:	b003      	add	sp, #12
 8005b2e:	bd30      	pop	{r4, r5, pc}
  if (f_open(fs_file, filename, FA_OPEN_EXISTING | FA_READ) != FR_OK)
 8005b30:	4629      	mov	r1, r5
 8005b32:	4811      	ldr	r0, [pc, #68]	@ (8005b78 <cmd_sd_read+0x60>)
 8005b34:	4622      	mov	r2, r4
 8005b36:	f7fe fed1 	bl	80048dc <f_open>
 8005b3a:	4605      	mov	r5, r0
 8005b3c:	2800      	cmp	r0, #0
 8005b3e:	d1f5      	bne.n	8005b2c <cmd_sd_read+0x14>
  uint32_t filesize = f_size(fs_file);
 8005b40:	4c0e      	ldr	r4, [pc, #56]	@ (8005b7c <cmd_sd_read+0x64>)
  shell_write(&filesize, 4);
 8005b42:	2104      	movs	r1, #4
  uint32_t filesize = f_size(fs_file);
 8005b44:	f8d4 3b84 	ldr.w	r3, [r4, #2948]	@ 0xb84
 8005b48:	9300      	str	r3, [sp, #0]
  shell_write(&filesize, 4);
 8005b4a:	4668      	mov	r0, sp
 8005b4c:	f7ff fc8c 	bl	8005468 <shell_write>
  UINT size = 0;
 8005b50:	9501      	str	r5, [sp, #4]
  while (f_read(fs_file, buf, 512, &size) == FR_OK && size > 0)
 8005b52:	e004      	b.n	8005b5e <cmd_sd_read+0x46>
 8005b54:	9901      	ldr	r1, [sp, #4]
    shell_write(buf, size);
 8005b56:	4620      	mov	r0, r4
  while (f_read(fs_file, buf, 512, &size) == FR_OK && size > 0)
 8005b58:	b151      	cbz	r1, 8005b70 <cmd_sd_read+0x58>
    shell_write(buf, size);
 8005b5a:	f7ff fc85 	bl	8005468 <shell_write>
  while (f_read(fs_file, buf, 512, &size) == FR_OK && size > 0)
 8005b5e:	4806      	ldr	r0, [pc, #24]	@ (8005b78 <cmd_sd_read+0x60>)
 8005b60:	ab01      	add	r3, sp, #4
 8005b62:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8005b66:	4621      	mov	r1, r4
 8005b68:	f7fe ffe8 	bl	8004b3c <f_read>
 8005b6c:	2800      	cmp	r0, #0
 8005b6e:	d0f1      	beq.n	8005b54 <cmd_sd_read+0x3c>
  f_close(fs_file);
 8005b70:	4801      	ldr	r0, [pc, #4]	@ (8005b78 <cmd_sd_read+0x60>)
 8005b72:	f7ff fa3f 	bl	8004ff4 <f_close>
  return;
 8005b76:	e7d9      	b.n	8005b2c <cmd_sd_read+0x14>
 8005b78:	20009568 	.word	0x20009568
 8005b7c:	200089f4 	.word	0x200089f4

08005b80 <cmd_sd_list>:
{
 8005b80:	b530      	push	{r4, r5, lr}
 8005b82:	b0a7      	sub	sp, #156	@ 0x9c
 8005b84:	4604      	mov	r4, r0
 8005b86:	460d      	mov	r5, r1
  if (cmd_sd_card_mount() != FR_OK)
 8005b88:	f7ff ffae 	bl	8005ae8 <cmd_sd_card_mount>
 8005b8c:	b960      	cbnz	r0, 8005ba8 <cmd_sd_list+0x28>
  switch (argc)
 8005b8e:	b1c4      	cbz	r4, 8005bc2 <cmd_sd_list+0x42>
 8005b90:	2c01      	cmp	r4, #1
 8005b92:	d109      	bne.n	8005ba8 <cmd_sd_list+0x28>
    dj.pat = argv[0];
 8005b94:	682b      	ldr	r3, [r5, #0]
  if (f_opendir(&dj, "") == FR_OK)
 8005b96:	490c      	ldr	r1, [pc, #48]	@ (8005bc8 <cmd_sd_list+0x48>)
    dj.pat = "*.*";
 8005b98:	9324      	str	r3, [sp, #144]	@ 0x90
  if (f_opendir(&dj, "") == FR_OK)
 8005b9a:	a810      	add	r0, sp, #64	@ 0x40
 8005b9c:	f7ff fa3a 	bl	8005014 <f_opendir>
 8005ba0:	b140      	cbz	r0, 8005bb4 <cmd_sd_list+0x34>
  f_closedir(&dj);
 8005ba2:	a810      	add	r0, sp, #64	@ 0x40
 8005ba4:	f7ff fa7a 	bl	800509c <f_closedir>
}
 8005ba8:	b027      	add	sp, #156	@ 0x9c
 8005baa:	bd30      	pop	{r4, r5, pc}
    while (f_findnext(&dj, &fno) == FR_OK && fno.fname[0])
 8005bac:	f89d 301a 	ldrb.w	r3, [sp, #26]
 8005bb0:	2b00      	cmp	r3, #0
 8005bb2:	d0f6      	beq.n	8005ba2 <cmd_sd_list+0x22>
 8005bb4:	4669      	mov	r1, sp
 8005bb6:	a810      	add	r0, sp, #64	@ 0x40
 8005bb8:	f7ff fa9e 	bl	80050f8 <f_findnext>
 8005bbc:	2800      	cmp	r0, #0
 8005bbe:	d0f5      	beq.n	8005bac <cmd_sd_list+0x2c>
 8005bc0:	e7ef      	b.n	8005ba2 <cmd_sd_list+0x22>
  switch (argc)
 8005bc2:	4b02      	ldr	r3, [pc, #8]	@ (8005bcc <cmd_sd_list+0x4c>)
 8005bc4:	e7e7      	b.n	8005b96 <cmd_sd_list+0x16>
 8005bc6:	bf00      	nop
 8005bc8:	0801220c 	.word	0x0801220c
 8005bcc:	08011994 	.word	0x08011994

08005bd0 <cmd_time>:
{
 8005bd0:	b530      	push	{r4, r5, lr}
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 8005bd2:	4c27      	ldr	r4, [pc, #156]	@ (8005c70 <cmd_time+0xa0>)
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 8005bd4:	4a27      	ldr	r2, [pc, #156]	@ (8005c74 <cmd_time+0xa4>)
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 8005bd6:	6823      	ldr	r3, [r4, #0]
{
 8005bd8:	b083      	sub	sp, #12
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 8005bda:	f003 337f 	and.w	r3, r3, #2139062143	@ 0x7f7f7f7f
 8005bde:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8005be2:	9300      	str	r3, [sp, #0]
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 8005be4:	6863      	ldr	r3, [r4, #4]
  if (argc == 3 && get_str_index(argv[0], "b") == 0)
 8005be6:	2803      	cmp	r0, #3
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 8005be8:	ea02 0203 	and.w	r2, r2, r3
 8005bec:	9201      	str	r2, [sp, #4]
{
 8005bee:	460c      	mov	r4, r1
  if (argc == 3 && get_str_index(argv[0], "b") == 0)
 8005bf0:	d026      	beq.n	8005c40 <cmd_time+0x70>
  if (argc != 2)
 8005bf2:	2802      	cmp	r0, #2
 8005bf4:	d001      	beq.n	8005bfa <cmd_time+0x2a>
}
 8005bf6:	b003      	add	sp, #12
 8005bf8:	bd30      	pop	{r4, r5, pc}
  int idx = get_str_index(argv[0], time_cmd);
 8005bfa:	491f      	ldr	r1, [pc, #124]	@ (8005c78 <cmd_time+0xa8>)
 8005bfc:	6820      	ldr	r0, [r4, #0]
 8005bfe:	f002 ff99 	bl	8008b34 <get_str_index>
 8005c02:	4605      	mov	r5, r0
  if (idx == 6)
 8005c04:	2d06      	cmp	r5, #6
    rtc_set_cal(my_atof(argv[1]));
 8005c06:	6860      	ldr	r0, [r4, #4]
  if (idx == 6)
 8005c08:	d02a      	beq.n	8005c60 <cmd_time+0x90>
  uint32_t val = my_atoui(argv[1]);
 8005c0a:	f002 fed3 	bl	80089b4 <my_atoui>
  if (idx < 0 || val > 99)
 8005c0e:	2d00      	cmp	r5, #0
 8005c10:	dbf1      	blt.n	8005bf6 <cmd_time+0x26>
 8005c12:	2863      	cmp	r0, #99	@ 0x63
 8005c14:	d8ef      	bhi.n	8005bf6 <cmd_time+0x26>
  time[idx_to_time[idx]] = ((val / 10) << 4) | (val % 10); // value in bcd format
 8005c16:	4b19      	ldr	r3, [pc, #100]	@ (8005c7c <cmd_time+0xac>)
 8005c18:	4a19      	ldr	r2, [pc, #100]	@ (8005c80 <cmd_time+0xb0>)
 8005c1a:	fba3 1300 	umull	r1, r3, r3, r0
 8005c1e:	08db      	lsrs	r3, r3, #3
 8005c20:	5d52      	ldrb	r2, [r2, r5]
 8005c22:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8005c26:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 8005c2a:	446a      	add	r2, sp
 8005c2c:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 8005c30:	7010      	strb	r0, [r2, #0]
  rtc_set_time(dt_buf[1], dt_buf[0]);
 8005c32:	e9dd 1000 	ldrd	r1, r0, [sp]
}
 8005c36:	b003      	add	sp, #12
 8005c38:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  rtc_set_time(dt_buf[1], dt_buf[0]);
 8005c3c:	f00b b85e 	b.w	8010cfc <rtc_set_time>
  if (argc == 3 && get_str_index(argv[0], "b") == 0)
 8005c40:	4910      	ldr	r1, [pc, #64]	@ (8005c84 <cmd_time+0xb4>)
 8005c42:	6820      	ldr	r0, [r4, #0]
 8005c44:	f002 ff76 	bl	8008b34 <get_str_index>
 8005c48:	2800      	cmp	r0, #0
 8005c4a:	d1d4      	bne.n	8005bf6 <cmd_time+0x26>
    rtc_set_time(my_atoui(argv[1]), my_atoui(argv[2]));
 8005c4c:	6860      	ldr	r0, [r4, #4]
 8005c4e:	f002 feb1 	bl	80089b4 <my_atoui>
 8005c52:	4605      	mov	r5, r0
 8005c54:	68a0      	ldr	r0, [r4, #8]
 8005c56:	f002 fead 	bl	80089b4 <my_atoui>
 8005c5a:	4601      	mov	r1, r0
 8005c5c:	4628      	mov	r0, r5
 8005c5e:	e7ea      	b.n	8005c36 <cmd_time+0x66>
    rtc_set_cal(my_atof(argv[1]));
 8005c60:	f002 fece 	bl	8008a00 <my_atof>
}
 8005c64:	b003      	add	sp, #12
 8005c66:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    rtc_set_cal(my_atof(argv[1]));
 8005c6a:	f00b b8b5 	b.w	8010dd8 <rtc_set_cal>
 8005c6e:	bf00      	nop
 8005c70:	40002800 	.word	0x40002800
 8005c74:	00ff1f3f 	.word	0x00ff1f3f
 8005c78:	08013b50 	.word	0x08013b50
 8005c7c:	cccccccd 	.word	0xcccccccd
 8005c80:	08013b48 	.word	0x08013b48
 8005c84:	08011998 	.word	0x08011998

08005c88 <cmd_offset>:
  if (argc != 1)
 8005c88:	2801      	cmp	r0, #1
 8005c8a:	d000      	beq.n	8005c8e <cmd_offset+0x6>
 8005c8c:	4770      	bx	lr
{
 8005c8e:	b508      	push	{r3, lr}
  si5351_set_frequency_offset(my_atoi(argv[0]));
 8005c90:	6808      	ldr	r0, [r1, #0]
 8005c92:	f002 fe75 	bl	8008980 <my_atoi>
}
 8005c96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  si5351_set_frequency_offset(my_atoi(argv[0]));
 8005c9a:	f002 bfe9 	b.w	8008c70 <si5351_set_frequency_offset>
 8005c9e:	bf00      	nop

08005ca0 <get_sweep_mask>:
{
 8005ca0:	b508      	push	{r3, lr}
  ch_mask |= plot_get_measure_channels();
 8005ca2:	f005 fd8d 	bl	800b7c0 <plot_get_measure_channels>
  if (cal_status & CALSTAT_APPLY)
 8005ca6:	4b14      	ldr	r3, [pc, #80]	@ (8005cf8 <get_sweep_mask+0x58>)
 8005ca8:	8c9a      	ldrh	r2, [r3, #36]	@ 0x24
  if (electrical_delayS11)
 8005caa:	edd3 7a27 	vldr	s15, [r3, #156]	@ 0x9c
  if (cal_status & CALSTAT_APPLY)
 8005cae:	05d1      	lsls	r1, r2, #23
  ch_mask |= plot_get_measure_channels();
 8005cb0:	bf54      	ite	pl
 8005cb2:	f040 0003 	orrpl.w	r0, r0, #3
    ch_mask |= SWEEP_APPLY_CALIBRATION;
 8005cb6:	f040 0023 	orrmi.w	r0, r0, #35	@ 0x23
  if (electrical_delayS11)
 8005cba:	eef5 7a40 	vcmp.f32	s15, #0.0
  if (electrical_delayS21)
 8005cbe:	edd3 7a28 	vldr	s15, [r3, #160]	@ 0xa0
    ch_mask |= SWEEP_APPLY_CALIBRATION;
 8005cc2:	b280      	uxth	r0, r0
  if (cal_status & CALSTAT_INTERPOLATED)
 8005cc4:	0592      	lsls	r2, r2, #22
    ch_mask |= SWEEP_USE_INTERPOLATION;
 8005cc6:	bf48      	it	mi
 8005cc8:	f040 0040 	orrmi.w	r0, r0, #64	@ 0x40
  if (electrical_delayS11)
 8005ccc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (electrical_delayS21)
 8005cd0:	eef5 7a40 	vcmp.f32	s15, #0.0
  if (s21_offset)
 8005cd4:	edd3 7a2a 	vldr	s15, [r3, #168]	@ 0xa8
    ch_mask |= SWEEP_APPLY_EDELAY_S11;
 8005cd8:	bf18      	it	ne
 8005cda:	f040 0004 	orrne.w	r0, r0, #4
  if (electrical_delayS21)
 8005cde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (s21_offset)
 8005ce2:	eef5 7a40 	vcmp.f32	s15, #0.0
    ch_mask |= SWEEP_APPLY_EDELAY_S21;
 8005ce6:	bf18      	it	ne
 8005ce8:	f040 0008 	orrne.w	r0, r0, #8
  if (s21_offset)
 8005cec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ch_mask |= SWEEP_APPLY_S21_OFFSET;
 8005cf0:	bf18      	it	ne
 8005cf2:	f040 0010 	orrne.w	r0, r0, #16
}
 8005cf6:	bd08      	pop	{r3, pc}
 8005cf8:	20000aa8 	.word	0x20000aa8

08005cfc <eterm_set.constprop.0>:
  for (i = 0; i < sweep_points; i++)
 8005cfc:	4b0a      	ldr	r3, [pc, #40]	@ (8005d28 <eterm_set.constprop.0+0x2c>)
 8005cfe:	8b5a      	ldrh	r2, [r3, #26]
 8005d00:	b18a      	cbz	r2, 8005d26 <eterm_set.constprop.0+0x2a>
 8005d02:	f240 1191 	movw	r1, #401	@ 0x191
 8005d06:	fb01 2100 	mla	r1, r1, r0, r2
 8005d0a:	f640 4c88 	movw	ip, #3208	@ 0xc88
 8005d0e:	fb0c 3000 	mla	r0, ip, r0, r3
    cal_data[term][i][1] = im;
 8005d12:	2200      	movs	r2, #0
 8005d14:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    cal_data[term][i][0] = re;
 8005d18:	ed80 0a34 	vstr	s0, [r0, #208]	@ 0xd0
    cal_data[term][i][1] = im;
 8005d1c:	f8c0 20d4 	str.w	r2, [r0, #212]	@ 0xd4
  for (i = 0; i < sweep_points; i++)
 8005d20:	3008      	adds	r0, #8
 8005d22:	4298      	cmp	r0, r3
 8005d24:	d1f8      	bne.n	8005d18 <eterm_set.constprop.0+0x1c>
}
 8005d26:	4770      	bx	lr
 8005d28:	20000aa8 	.word	0x20000aa8

08005d2c <cmd_info>:
VNA_SHELL_FUNCTION(cmd_info)
 8005d2c:	4770      	bx	lr
 8005d2e:	bf00      	nop

08005d30 <cmd_frequencies>:
VNA_SHELL_FUNCTION(cmd_frequencies)
 8005d30:	4770      	bx	lr
 8005d32:	bf00      	nop

08005d34 <cmd_version>:
VNA_SHELL_FUNCTION(cmd_version)
 8005d34:	4770      	bx	lr
 8005d36:	bf00      	nop

08005d38 <mla_is_resonance_centered>:
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005d38:	4b0a      	ldr	r3, [pc, #40]	@ (8005d64 <mla_is_resonance_centered+0x2c>)
      (mla_res_idx > EDGE_POINTS) &&
 8005d3a:	490b      	ldr	r1, [pc, #44]	@ (8005d68 <mla_is_resonance_centered+0x30>)
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005d3c:	8b5a      	ldrh	r2, [r3, #26]
 8005d3e:	4b0b      	ldr	r3, [pc, #44]	@ (8005d6c <mla_is_resonance_centered+0x34>)
      (mla_res_idx > EDGE_POINTS) &&
 8005d40:	f9b1 0000 	ldrsh.w	r0, [r1]
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005d44:	fba3 1302 	umull	r1, r3, r3, r2
      (mla_res_idx > EDGE_POINTS) &&
 8005d48:	ebb0 0f93 	cmp.w	r0, r3, lsr #2
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005d4c:	ea4f 0193 	mov.w	r1, r3, lsr #2
      (mla_res_idx > EDGE_POINTS) &&
 8005d50:	dd05      	ble.n	8005d5e <mla_is_resonance_centered+0x26>
      (mla_res_idx < (sweep_points - EDGE_POINTS));
 8005d52:	1a52      	subs	r2, r2, r1
      (mla_res_idx > EDGE_POINTS) &&
 8005d54:	4290      	cmp	r0, r2
 8005d56:	bfac      	ite	ge
 8005d58:	2000      	movge	r0, #0
 8005d5a:	2001      	movlt	r0, #1
 8005d5c:	4770      	bx	lr
 8005d5e:	2000      	movs	r0, #0
}
 8005d60:	4770      	bx	lr
 8005d62:	bf00      	nop
 8005d64:	20000aa8 	.word	0x20000aa8
 8005d68:	200003d4 	.word	0x200003d4
 8005d6c:	cccccccd 	.word	0xcccccccd

08005d70 <set_smooth_factor>:
  if (factor > 8)
 8005d70:	2808      	cmp	r0, #8
  smooth_factor = factor;
 8005d72:	4a04      	ldr	r2, [pc, #16]	@ (8005d84 <set_smooth_factor+0x14>)
  if (factor > 8)
 8005d74:	4603      	mov	r3, r0
 8005d76:	bf28      	it	cs
 8005d78:	2308      	movcs	r3, #8
  request_to_redraw(REDRAW_CAL_STATUS);
 8005d7a:	2010      	movs	r0, #16
  smooth_factor = factor;
 8005d7c:	7013      	strb	r3, [r2, #0]
  request_to_redraw(REDRAW_CAL_STATUS);
 8005d7e:	f005 bd37 	b.w	800b7f0 <request_to_redraw>
 8005d82:	bf00      	nop
 8005d84:	20004f50 	.word	0x20004f50

08005d88 <cmd_smooth>:
  if (argc != 1)
 8005d88:	2801      	cmp	r0, #1
 8005d8a:	d000      	beq.n	8005d8e <cmd_smooth+0x6>
 8005d8c:	4770      	bx	lr
{
 8005d8e:	b508      	push	{r3, lr}
  set_smooth_factor(my_atoui(argv[0]));
 8005d90:	6808      	ldr	r0, [r1, #0]
 8005d92:	f002 fe0f 	bl	80089b4 <my_atoui>
}
 8005d96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_smooth_factor(my_atoui(argv[0]));
 8005d9a:	b2c0      	uxtb	r0, r0
 8005d9c:	f7ff bfe8 	b.w	8005d70 <set_smooth_factor>

08005da0 <get_smooth_factor>:
  return smooth_factor;
 8005da0:	4b01      	ldr	r3, [pc, #4]	@ (8005da8 <get_smooth_factor+0x8>)
}
 8005da2:	7818      	ldrb	r0, [r3, #0]
 8005da4:	4770      	bx	lr
 8005da6:	bf00      	nop
 8005da8:	20004f50 	.word	0x20004f50

08005dac <drawBarGraph>:
  if (value > SWR_MAX)
 8005dac:	eeb0 7a0c 	vmov.f32	s14, #12	@ 0x40600000  3.5
 8005db0:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8005db4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (value < SWR_MIN)
 8005db8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
  if (value > SWR_MAX)
 8005dbc:	bf88      	it	hi
 8005dbe:	eeb0 0a47 	vmovhi.f32	s0, s14
  if (value < SWR_MIN)
 8005dc2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005dc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005dca:	bfb8      	it	lt
 8005dcc:	eeb0 0a67 	vmovlt.f32	s0, s15
  float norm = (value - SWR_MIN) / (SWR_MAX - SWR_MIN);
 8005dd0:	ee30 0a67 	vsub.f32	s0, s0, s15
  int active = (int)(norm * BAR_SEGMENTS + 0.5f);
 8005dd4:	eeb3 7a00 	vmov.f32	s14, #48	@ 0x41800000  16.0
 8005dd8:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8005ddc:	eee0 7a07 	vfma.f32	s15, s0, s14
{
 8005de0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int active = (int)(norm * BAR_SEGMENTS + 0.5f);
 8005de2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  if (doOnceOnly_In_Mode2 == true)
 8005de6:	4b45      	ldr	r3, [pc, #276]	@ (8005efc <drawBarGraph+0x150>)
    prevActive = -1;
 8005de8:	4f45      	ldr	r7, [pc, #276]	@ (8005f00 <drawBarGraph+0x154>)
  if (doOnceOnly_In_Mode2 == true)
 8005dea:	781b      	ldrb	r3, [r3, #0]
  int active = (int)(norm * BAR_SEGMENTS + 0.5f);
 8005dec:	ee17 5a90 	vmov	r5, s15
  if (active > BAR_SEGMENTS)
 8005df0:	2d28      	cmp	r5, #40	@ 0x28
 8005df2:	462e      	mov	r6, r5
 8005df4:	bfa8      	it	ge
 8005df6:	2628      	movge	r6, #40	@ 0x28
{
 8005df8:	ed2d 8b02 	vpush	{d8}
  if (active < 0)
 8005dfc:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
  if (doOnceOnly_In_Mode2 == true)
 8005e00:	2b00      	cmp	r3, #0
 8005e02:	d05c      	beq.n	8005ebe <drawBarGraph+0x112>
    prevActive = -1;
 8005e04:	f04f 33ff 	mov.w	r3, #4294967295
 8005e08:	603b      	str	r3, [r7, #0]
    lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8005e0a:	2100      	movs	r1, #0
 8005e0c:	4608      	mov	r0, r1
 8005e0e:	f00a f977 	bl	8010100 <lcd_set_colors>
    lcd_fill(x0, y0, barWidth, BAR_HEIGHT_PX);
 8005e12:	232d      	movs	r3, #45	@ 0x2d
 8005e14:	f44f 72dc 	mov.w	r2, #440	@ 0x1b8
 8005e18:	21f0      	movs	r1, #240	@ 0xf0
 8005e1a:	2014      	movs	r0, #20
 8005e1c:	f00a f86a 	bl	800fef4 <lcd_fill>
    lcd_set_colors(LCD_BG_COLOR, LCD_GRID_COLOR);
 8005e20:	2102      	movs	r1, #2
 8005e22:	2000      	movs	r0, #0
 8005e24:	f00a f96c 	bl	8010100 <lcd_set_colors>
    lcd_fill(x0 - 1, y0 - 1, barWidth + 2, 1);
 8005e28:	2301      	movs	r3, #1
 8005e2a:	f44f 72dd 	mov.w	r2, #442	@ 0x1ba
 8005e2e:	21ef      	movs	r1, #239	@ 0xef
 8005e30:	2013      	movs	r0, #19
 8005e32:	f00a f85f 	bl	800fef4 <lcd_fill>
    lcd_fill(x0 - 1, y0 + BAR_HEIGHT_PX, barWidth + 2, 1);
 8005e36:	2301      	movs	r3, #1
 8005e38:	f44f 72dd 	mov.w	r2, #442	@ 0x1ba
 8005e3c:	f240 111d 	movw	r1, #285	@ 0x11d
 8005e40:	2013      	movs	r0, #19
 8005e42:	f00a f857 	bl	800fef4 <lcd_fill>
    lcd_fill(x0 - 1, y0 - 1, 1, BAR_HEIGHT_PX + 2);
 8005e46:	232f      	movs	r3, #47	@ 0x2f
 8005e48:	2201      	movs	r2, #1
 8005e4a:	21ef      	movs	r1, #239	@ 0xef
 8005e4c:	2013      	movs	r0, #19
 8005e4e:	f00a f851 	bl	800fef4 <lcd_fill>
    prevActive = 0;
 8005e52:	2400      	movs	r4, #0
    lcd_fill(x0 + barWidth, y0 - 1, 1, BAR_HEIGHT_PX + 2);
 8005e54:	232f      	movs	r3, #47	@ 0x2f
 8005e56:	2201      	movs	r2, #1
 8005e58:	21ef      	movs	r1, #239	@ 0xef
 8005e5a:	f44f 70e6 	mov.w	r0, #460	@ 0x1cc
 8005e5e:	f00a f849 	bl	800fef4 <lcd_fill>
  if (active > prevActive)
 8005e62:	42a5      	cmp	r5, r4
    prevActive = 0;
 8005e64:	603c      	str	r4, [r7, #0]
  if (active > prevActive)
 8005e66:	dd26      	ble.n	8005eb6 <drawBarGraph+0x10a>
    for (int i = prevActive; i < active; i++)
 8005e68:	250b      	movs	r5, #11
 8005e6a:	2314      	movs	r3, #20
      else if (segValue <= 3.0f)
 8005e6c:	eddf 8a25 	vldr	s17, [pc, #148]	@ 8005f04 <drawBarGraph+0x158>
 8005e70:	fb14 3505 	smlabb	r5, r4, r5, r3
      if (segValue <= 1.5f)
 8005e74:	eeb2 8a00 	vmov.f32	s16, #32	@ 0x41000000  8.0
          ((float)(i + 1) / BAR_SEGMENTS) * (SWR_MAX - SWR_MIN);
 8005e78:	3401      	adds	r4, #1
 8005e7a:	ee07 4a90 	vmov	s15, r4
 8005e7e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        color = LCD_TRACE_3_COLOR; // green
 8005e82:	2108      	movs	r1, #8
      if (segValue <= 1.5f)
 8005e84:	eef4 7ac8 	vcmpe.f32	s15, s16
 8005e88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        color = LCD_TRACE_5_COLOR; // red
 8005e8c:	eef4 7ae8 	vcmpe.f32	s15, s17
      if (segValue <= 1.5f)
 8005e90:	d904      	bls.n	8005e9c <drawBarGraph+0xf0>
        color = LCD_TRACE_5_COLOR; // red
 8005e92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005e96:	bf94      	ite	ls
 8005e98:	2106      	movls	r1, #6
 8005e9a:	210a      	movhi	r1, #10
      lcd_set_colors(LCD_BG_COLOR, color);
 8005e9c:	2000      	movs	r0, #0
 8005e9e:	f00a f92f 	bl	8010100 <lcd_set_colors>
      lcd_fill(x, y0, segmentWidth, BAR_HEIGHT_PX);
 8005ea2:	4628      	mov	r0, r5
 8005ea4:	232d      	movs	r3, #45	@ 0x2d
 8005ea6:	2209      	movs	r2, #9
 8005ea8:	21f0      	movs	r1, #240	@ 0xf0
 8005eaa:	f00a f823 	bl	800fef4 <lcd_fill>
    for (int i = prevActive; i < active; i++)
 8005eae:	42b4      	cmp	r4, r6
 8005eb0:	f105 050b 	add.w	r5, r5, #11
 8005eb4:	dbe0      	blt.n	8005e78 <drawBarGraph+0xcc>
}
 8005eb6:	ecbd 8b02 	vpop	{d8}
  prevActive = active;
 8005eba:	603e      	str	r6, [r7, #0]
}
 8005ebc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (prevActive < 0)
 8005ebe:	683c      	ldr	r4, [r7, #0]
 8005ec0:	2c00      	cmp	r4, #0
 8005ec2:	dba2      	blt.n	8005e0a <drawBarGraph+0x5e>
  if (active > prevActive)
 8005ec4:	42b4      	cmp	r4, r6
 8005ec6:	dbcf      	blt.n	8005e68 <drawBarGraph+0xbc>
  else if (active < prevActive)
 8005ec8:	ddf5      	ble.n	8005eb6 <drawBarGraph+0x10a>
 8005eca:	240b      	movs	r4, #11
 8005ecc:	2314      	movs	r3, #20
 8005ece:	fb16 3404 	smlabb	r4, r6, r4, r3
    for (int i = active; i < prevActive; i++)
 8005ed2:	4635      	mov	r5, r6
      lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8005ed4:	2100      	movs	r1, #0
 8005ed6:	4608      	mov	r0, r1
 8005ed8:	f00a f912 	bl	8010100 <lcd_set_colors>
      lcd_fill(x, y0, segmentWidth, BAR_HEIGHT_PX);
 8005edc:	232d      	movs	r3, #45	@ 0x2d
 8005ede:	4620      	mov	r0, r4
 8005ee0:	2209      	movs	r2, #9
 8005ee2:	21f0      	movs	r1, #240	@ 0xf0
 8005ee4:	f00a f806 	bl	800fef4 <lcd_fill>
    for (int i = active; i < prevActive; i++)
 8005ee8:	683b      	ldr	r3, [r7, #0]
 8005eea:	3501      	adds	r5, #1
 8005eec:	42ab      	cmp	r3, r5
 8005eee:	f104 040b 	add.w	r4, r4, #11
 8005ef2:	dcef      	bgt.n	8005ed4 <drawBarGraph+0x128>
}
 8005ef4:	ecbd 8b02 	vpop	{d8}
  prevActive = active;
 8005ef8:	603e      	str	r6, [r7, #0]
}
 8005efa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005efc:	200068b0 	.word	0x200068b0
 8005f00:	20000310 	.word	0x20000310
 8005f04:	42000000 	.word	0x42000000

08005f08 <displaySWR>:
{
 8005f08:	b570      	push	{r4, r5, r6, lr}
  if (doOnceOnly_In_Mode2)
 8005f0a:	4b71      	ldr	r3, [pc, #452]	@ (80060d0 <displaySWR+0x1c8>)
{
 8005f0c:	ed2d 8b02 	vpush	{d8}
  if (doOnceOnly_In_Mode2)
 8005f10:	781b      	ldrb	r3, [r3, #0]
{
 8005f12:	b082      	sub	sp, #8
  if (doOnceOnly_In_Mode2)
 8005f14:	b113      	cbz	r3, 8005f1c <displaySWR+0x14>
    label_drawn = 0;
 8005f16:	4b6f      	ldr	r3, [pc, #444]	@ (80060d4 <displaySWR+0x1cc>)
 8005f18:	2200      	movs	r2, #0
 8005f1a:	601a      	str	r2, [r3, #0]
  if (t0 == 0)
 8005f1c:	4a6e      	ldr	r2, [pc, #440]	@ (80060d8 <displaySWR+0x1d0>)
 8005f1e:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8005f22:	6813      	ldr	r3, [r2, #0]
 8005f24:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8005f26:	2b00      	cmp	r3, #0
 8005f28:	d07e      	beq.n	8006028 <displaySWR+0x120>
  acc += swr;
 8005f2a:	4d6c      	ldr	r5, [pc, #432]	@ (80060dc <displaySWR+0x1d4>)
  if (n != 0xFFFF)
 8005f2c:	4c6c      	ldr	r4, [pc, #432]	@ (80060e0 <displaySWR+0x1d8>)
  acc += swr;
 8005f2e:	edd5 7a00 	vldr	s15, [r5]
  if (n != 0xFFFF)
 8005f32:	8820      	ldrh	r0, [r4, #0]
  acc += swr;
 8005f34:	ee30 0a27 	vadd.f32	s0, s0, s15
  if (n != 0xFFFF)
 8005f38:	f64f 76ff 	movw	r6, #65535	@ 0xffff
 8005f3c:	42b0      	cmp	r0, r6
  if ((systime_t)(now - t0) < (systime_t)250)
 8005f3e:	eba1 0303 	sub.w	r3, r1, r3
  acc += swr;
 8005f42:	ed85 0a00 	vstr	s0, [r5]
  if (n != 0xFFFF)
 8005f46:	d001      	beq.n	8005f4c <displaySWR+0x44>
    n++;
 8005f48:	3001      	adds	r0, #1
 8005f4a:	8020      	strh	r0, [r4, #0]
  if ((systime_t)(now - t0) < (systime_t)250)
 8005f4c:	2bf9      	cmp	r3, #249	@ 0xf9
 8005f4e:	d967      	bls.n	8006020 <displaySWR+0x118>
  float avg = (n ? (acc / (float)n) : swr);
 8005f50:	8823      	ldrh	r3, [r4, #0]
  if (!label_drawn)
 8005f52:	4e60      	ldr	r6, [pc, #384]	@ (80060d4 <displaySWR+0x1cc>)
  t0 = now;
 8005f54:	6011      	str	r1, [r2, #0]
  float avg = (n ? (acc / (float)n) : swr);
 8005f56:	ee07 3a90 	vmov	s15, r3
  if (!label_drawn)
 8005f5a:	6830      	ldr	r0, [r6, #0]
  float avg = (n ? (acc / (float)n) : swr);
 8005f5c:	eef8 7a67 	vcvt.f32.u32	s15, s15
  acc = 0.0f;
 8005f60:	2300      	movs	r3, #0
  n = 0;
 8005f62:	2200      	movs	r2, #0
  float avg = (n ? (acc / (float)n) : swr);
 8005f64:	ee80 8a27 	vdiv.f32	s16, s0, s15
  n = 0;
 8005f68:	8022      	strh	r2, [r4, #0]
  acc = 0.0f;
 8005f6a:	602b      	str	r3, [r5, #0]
  if (!label_drawn)
 8005f6c:	2800      	cmp	r0, #0
 8005f6e:	f000 8090 	beq.w	8006092 <displaySWR+0x18a>
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 8005f72:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8005f76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f7a:	d969      	bls.n	8006050 <displaySWR+0x148>
 8005f7c:	eddf 7a59 	vldr	s15, [pc, #356]	@ 80060e4 <displaySWR+0x1dc>
 8005f80:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8005f84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f88:	dc62      	bgt.n	8006050 <displaySWR+0x148>
  else if (avg <= 1.5f)
 8005f8a:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 8005f8e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8005f92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005f96:	f240 8094 	bls.w	80060c2 <displaySWR+0x1ba>
  else if (avg <= 3.0f)
 8005f9a:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
    color = LCD_TRACE_5_COLOR; // red
 8005f9e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8005fa2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005fa6:	bf94      	ite	ls
 8005fa8:	2506      	movls	r5, #6
 8005faa:	250a      	movhi	r5, #10
  int swr_int = overflow ? -9999 : (int)(avg * 10.0f + 0.5f);
 8005fac:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8005fb0:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8005fb4:	eee8 7a07 	vfma.f32	s15, s16, s14
    if ((swr_int == last_swr_int) && (color == last_color))
 8005fb8:	4b4b      	ldr	r3, [pc, #300]	@ (80060e8 <displaySWR+0x1e0>)
 8005fba:	681a      	ldr	r2, [r3, #0]
  int swr_int = overflow ? -9999 : (int)(avg * 10.0f + 0.5f);
 8005fbc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005fc0:	ee17 4a90 	vmov	r4, s15
    if ((swr_int == last_swr_int) && (color == last_color))
 8005fc4:	42a2      	cmp	r2, r4
 8005fc6:	4a49      	ldr	r2, [pc, #292]	@ (80060ec <displaySWR+0x1e4>)
 8005fc8:	d07d      	beq.n	80060c6 <displaySWR+0x1be>
  lcd_set_background(LCD_BG_COLOR);
 8005fca:	2000      	movs	r0, #0
  last_swr_int = swr_int;
 8005fcc:	601c      	str	r4, [r3, #0]
  last_color = color;
 8005fce:	8015      	strh	r5, [r2, #0]
  lcd_set_background(LCD_BG_COLOR);
 8005fd0:	f00a f88a 	bl	80100e8 <lcd_set_background>
  lcd_fill(250, (LCD_HEIGHT / 2) - 30, 140, 50);
 8005fd4:	2332      	movs	r3, #50	@ 0x32
 8005fd6:	228c      	movs	r2, #140	@ 0x8c
 8005fd8:	2182      	movs	r1, #130	@ 0x82
 8005fda:	20fa      	movs	r0, #250	@ 0xfa
 8005fdc:	f009 ff8a 	bl	800fef4 <lcd_fill>
  lcd_set_foreground(color);
 8005fe0:	4628      	mov	r0, r5
 8005fe2:	f00a f875 	bl	80100d0 <lcd_set_foreground>
  int swr_whole = swr_int / 10; /* 0..9 */
 8005fe6:	4a42      	ldr	r2, [pc, #264]	@ (80060f0 <displaySWR+0x1e8>)
 8005fe8:	fb82 3204 	smull	r3, r2, r2, r4
 8005fec:	17e3      	asrs	r3, r4, #31
 8005fee:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
  int swr_frac = swr_int % 10;  /* 0..9 */
 8005ff2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
  buf[1] = '.';
 8005ff6:	212e      	movs	r1, #46	@ 0x2e
  int swr_frac = swr_int % 10;  /* 0..9 */
 8005ff8:	eba4 0442 	sub.w	r4, r4, r2, lsl #1
  buf[0] = '0' + swr_whole;
 8005ffc:	f103 0230 	add.w	r2, r3, #48	@ 0x30
  buf[2] = '0' + swr_frac;
 8006000:	3430      	adds	r4, #48	@ 0x30
  buf[3] = 0;
 8006002:	2500      	movs	r5, #0
  buf[0] = '0' + swr_whole;
 8006004:	f88d 2004 	strb.w	r2, [sp, #4]
  buf[1] = '.';
 8006008:	f88d 1005 	strb.w	r1, [sp, #5]
  lcd_drawstring_size(buf, 240, (LCD_HEIGHT / 2) - 20, 3);
 800600c:	2303      	movs	r3, #3
 800600e:	228c      	movs	r2, #140	@ 0x8c
 8006010:	21f0      	movs	r1, #240	@ 0xf0
 8006012:	a801      	add	r0, sp, #4
  buf[2] = '0' + swr_frac;
 8006014:	f88d 4006 	strb.w	r4, [sp, #6]
  buf[3] = 0;
 8006018:	f88d 5007 	strb.w	r5, [sp, #7]
  lcd_drawstring_size(buf, 240, (LCD_HEIGHT / 2) - 20, 3);
 800601c:	f00a fa1e 	bl	801045c <lcd_drawstring_size>
}
 8006020:	b002      	add	sp, #8
 8006022:	ecbd 8b02 	vpop	{d8}
 8006026:	bd70      	pop	{r4, r5, r6, pc}
  acc += swr;
 8006028:	482c      	ldr	r0, [pc, #176]	@ (80060dc <displaySWR+0x1d4>)
  if (n != 0xFFFF)
 800602a:	4c2d      	ldr	r4, [pc, #180]	@ (80060e0 <displaySWR+0x1d8>)
  acc += swr;
 800602c:	edd0 7a00 	vldr	s15, [r0]
  if (n != 0xFFFF)
 8006030:	8823      	ldrh	r3, [r4, #0]
    t0 = now;
 8006032:	6011      	str	r1, [r2, #0]
  acc += swr;
 8006034:	ee77 7a80 	vadd.f32	s15, s15, s0
  if (n != 0xFFFF)
 8006038:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800603c:	4293      	cmp	r3, r2
  acc += swr;
 800603e:	edc0 7a00 	vstr	s15, [r0]
  if (n != 0xFFFF)
 8006042:	d0ed      	beq.n	8006020 <displaySWR+0x118>
    n++;
 8006044:	3301      	adds	r3, #1
 8006046:	8023      	strh	r3, [r4, #0]
}
 8006048:	b002      	add	sp, #8
 800604a:	ecbd 8b02 	vpop	{d8}
 800604e:	bd70      	pop	{r4, r5, r6, pc}
    if ((last_swr_int == -9999) && (last_color == color))
 8006050:	4b25      	ldr	r3, [pc, #148]	@ (80060e8 <displaySWR+0x1e0>)
 8006052:	4a28      	ldr	r2, [pc, #160]	@ (80060f4 <displaySWR+0x1ec>)
 8006054:	6819      	ldr	r1, [r3, #0]
 8006056:	4291      	cmp	r1, r2
 8006058:	4a24      	ldr	r2, [pc, #144]	@ (80060ec <displaySWR+0x1e4>)
 800605a:	d02e      	beq.n	80060ba <displaySWR+0x1b2>
  last_swr_int = swr_int;
 800605c:	4925      	ldr	r1, [pc, #148]	@ (80060f4 <displaySWR+0x1ec>)
 800605e:	6019      	str	r1, [r3, #0]
  last_color = color;
 8006060:	240a      	movs	r4, #10
  lcd_set_background(LCD_BG_COLOR);
 8006062:	2000      	movs	r0, #0
  last_color = color;
 8006064:	8014      	strh	r4, [r2, #0]
  lcd_set_background(LCD_BG_COLOR);
 8006066:	f00a f83f 	bl	80100e8 <lcd_set_background>
  lcd_fill(250, (LCD_HEIGHT / 2) - 30, 140, 50);
 800606a:	2332      	movs	r3, #50	@ 0x32
 800606c:	228c      	movs	r2, #140	@ 0x8c
 800606e:	2182      	movs	r1, #130	@ 0x82
 8006070:	20fa      	movs	r0, #250	@ 0xfa
 8006072:	f009 ff3f 	bl	800fef4 <lcd_fill>
  lcd_set_foreground(color);
 8006076:	4620      	mov	r0, r4
 8006078:	f00a f82a 	bl	80100d0 <lcd_set_foreground>
    lcd_drawstring_size("!!!", 240, (LCD_HEIGHT / 2) - 20, 3);
 800607c:	481e      	ldr	r0, [pc, #120]	@ (80060f8 <displaySWR+0x1f0>)
 800607e:	2303      	movs	r3, #3
 8006080:	228c      	movs	r2, #140	@ 0x8c
 8006082:	21f0      	movs	r1, #240	@ 0xf0
}
 8006084:	b002      	add	sp, #8
 8006086:	ecbd 8b02 	vpop	{d8}
 800608a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lcd_drawstring_size("!!!", 240, (LCD_HEIGHT / 2) - 20, 3);
 800608e:	f00a b9e5 	b.w	801045c <lcd_drawstring_size>
    lcd_set_background(LCD_BG_COLOR);
 8006092:	f00a f829 	bl	80100e8 <lcd_set_background>
    lcd_set_foreground(LCD_FG_COLOR);
 8006096:	2001      	movs	r0, #1
 8006098:	f00a f81a 	bl	80100d0 <lcd_set_foreground>
    lcd_drawstring_size("SWR", 140, (LCD_HEIGHT / 2) - 20, 3);
 800609c:	228c      	movs	r2, #140	@ 0x8c
 800609e:	2303      	movs	r3, #3
 80060a0:	4816      	ldr	r0, [pc, #88]	@ (80060fc <displaySWR+0x1f4>)
 80060a2:	4611      	mov	r1, r2
 80060a4:	f00a f9da 	bl	801045c <lcd_drawstring_size>
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 80060a8:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
    label_drawn = 1;
 80060ac:	2301      	movs	r3, #1
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 80060ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    label_drawn = 1;
 80060b2:	6033      	str	r3, [r6, #0]
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 80060b4:	f63f af62 	bhi.w	8005f7c <displaySWR+0x74>
 80060b8:	e7ca      	b.n	8006050 <displaySWR+0x148>
    if ((last_swr_int == -9999) && (last_color == color))
 80060ba:	8811      	ldrh	r1, [r2, #0]
 80060bc:	290a      	cmp	r1, #10
 80060be:	d1cd      	bne.n	800605c <displaySWR+0x154>
 80060c0:	e7ae      	b.n	8006020 <displaySWR+0x118>
    color = LCD_TRACE_3_COLOR; // green
 80060c2:	2508      	movs	r5, #8
 80060c4:	e772      	b.n	8005fac <displaySWR+0xa4>
    if ((swr_int == last_swr_int) && (color == last_color))
 80060c6:	8811      	ldrh	r1, [r2, #0]
 80060c8:	42a9      	cmp	r1, r5
 80060ca:	f47f af7e 	bne.w	8005fca <displaySWR+0xc2>
 80060ce:	e7a7      	b.n	8006020 <displaySWR+0x118>
 80060d0:	200068b0 	.word	0x200068b0
 80060d4:	20000904 	.word	0x20000904
 80060d8:	20000900 	.word	0x20000900
 80060dc:	200008fc 	.word	0x200008fc
 80060e0:	200008f8 	.word	0x200008f8
 80060e4:	411e6666 	.word	0x411e6666
 80060e8:	2000030c 	.word	0x2000030c
 80060ec:	20000308 	.word	0x20000308
 80060f0:	66666667 	.word	0x66666667
 80060f4:	ffffd8f1 	.word	0xffffd8f1
 80060f8:	080119a0 	.word	0x080119a0
 80060fc:	0801199c 	.word	0x0801199c

08006100 <displayTargetFrequency>:
{
 8006100:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (doOnceOnly_In_Mode2 == true)
 8006104:	4b78      	ldr	r3, [pc, #480]	@ (80062e8 <displayTargetFrequency+0x1e8>)
    label_drawn = 0;
 8006106:	4d79      	ldr	r5, [pc, #484]	@ (80062ec <displayTargetFrequency+0x1ec>)
  if (doOnceOnly_In_Mode2 == true)
 8006108:	781b      	ldrb	r3, [r3, #0]
{
 800610a:	b085      	sub	sp, #20
 800610c:	4604      	mov	r4, r0
  if (doOnceOnly_In_Mode2 == true)
 800610e:	2b00      	cmp	r3, #0
 8006110:	f000 80e5 	beq.w	80062de <displayTargetFrequency+0x1de>
    label_drawn = 0;
 8006114:	2300      	movs	r3, #0
 8006116:	602b      	str	r3, [r5, #0]
    lcd_set_background(LCD_BG_COLOR);
 8006118:	2000      	movs	r0, #0
 800611a:	f009 ffe5 	bl	80100e8 <lcd_set_background>
    lcd_set_foreground(LCD_FG_COLOR);
 800611e:	2001      	movs	r0, #1
 8006120:	f009 ffd6 	bl	80100d0 <lcd_set_foreground>
    char label[16] = "Target  "; // 2 spaces after Target
 8006124:	4b72      	ldr	r3, [pc, #456]	@ (80062f0 <displayTargetFrequency+0x1f0>)
 8006126:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800612a:	466b      	mov	r3, sp
 800612c:	c303      	stmia	r3!, {r0, r1}
 800612e:	2200      	movs	r2, #0
    label[8] = 0x18;             // put glyph AFTER the spaces
 8006130:	2118      	movs	r1, #24
    char label[16] = "Target  "; // 2 spaces after Target
 8006132:	f8cd 2009 	str.w	r2, [sp, #9]
    lcd_drawstring_size(label, 10, yp, 3);
 8006136:	2303      	movs	r3, #3
    label[8] = 0x18;             // put glyph AFTER the spaces
 8006138:	f88d 1008 	strb.w	r1, [sp, #8]
    char label[16] = "Target  "; // 2 spaces after Target
 800613c:	9203      	str	r2, [sp, #12]
    lcd_drawstring_size(label, 10, yp, 3);
 800613e:	210a      	movs	r1, #10
 8006140:	2223      	movs	r2, #35	@ 0x23
 8006142:	4668      	mov	r0, sp
 8006144:	f00a f98a 	bl	801045c <lcd_drawstring_size>
    label_drawn = 1;
 8006148:	2301      	movs	r3, #1
 800614a:	602b      	str	r3, [r5, #0]
  if (target_frequency == last_freq)
 800614c:	4969      	ldr	r1, [pc, #420]	@ (80062f4 <displayTargetFrequency+0x1f4>)
 800614e:	680b      	ldr	r3, [r1, #0]
 8006150:	42a3      	cmp	r3, r4
 8006152:	f000 80c1 	beq.w	80062d8 <displayTargetFrequency+0x1d8>
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 8006156:	4b68      	ldr	r3, [pc, #416]	@ (80062f8 <displayTargetFrequency+0x1f8>)
  uint32_t mhz = target_frequency / 1000000UL;
 8006158:	4d68      	ldr	r5, [pc, #416]	@ (80062fc <displayTargetFrequency+0x1fc>)
  last_freq = target_frequency;
 800615a:	600c      	str	r4, [r1, #0]
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 800615c:	fba3 0204 	umull	r0, r2, r3, r4
 8006160:	0992      	lsrs	r2, r2, #6
 8006162:	fba3 0302 	umull	r0, r3, r3, r2
  uint32_t mhz = target_frequency / 1000000UL;
 8006166:	fba5 0504 	umull	r0, r5, r5, r4
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 800616a:	099e      	lsrs	r6, r3, #6
  lcd_set_background(LCD_BG_COLOR);
 800616c:	2000      	movs	r0, #0
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 800616e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8006172:	fb03 2616 	mls	r6, r3, r6, r2
  uint32_t hz = target_frequency % 1000UL;
 8006176:	fb03 4412 	mls	r4, r3, r2, r4
  lcd_set_background(LCD_BG_COLOR);
 800617a:	f009 ffb5 	bl	80100e8 <lcd_set_background>
  lcd_fill(200, 30 - 5, 260, yp);
 800617e:	2119      	movs	r1, #25
 8006180:	f44f 7282 	mov.w	r2, #260	@ 0x104
 8006184:	2323      	movs	r3, #35	@ 0x23
 8006186:	20c8      	movs	r0, #200	@ 0xc8
 8006188:	f009 feb4 	bl	800fef4 <lcd_fill>
  lcd_set_foreground(LCD_FG_COLOR);
 800618c:	2001      	movs	r0, #1
 800618e:	f009 ff9f 	bl	80100d0 <lcd_set_foreground>
  buf[0] = '0' + (mhz / 10);
 8006192:	4b5b      	ldr	r3, [pc, #364]	@ (8006300 <displayTargetFrequency+0x200>)
  buf[3] = '0' + (khz / 100);
 8006194:	f8df e16c 	ldr.w	lr, [pc, #364]	@ 8006304 <displayTargetFrequency+0x204>
  uint32_t mhz = target_frequency / 1000000UL;
 8006198:	0cad      	lsrs	r5, r5, #18
  buf[0] = '0' + (mhz / 10);
 800619a:	fba3 2005 	umull	r2, r0, r3, r5
  buf[4] = '0' + ((khz / 10) % 10);
 800619e:	fba3 1206 	umull	r1, r2, r3, r6
 80061a2:	08d2      	lsrs	r2, r2, #3
  buf[8] = '0' + ((hz / 10) % 10);
 80061a4:	fba3 1c04 	umull	r1, ip, r3, r4
  buf[4] = '0' + ((khz / 10) % 10);
 80061a8:	fba3 1702 	umull	r1, r7, r3, r2
  buf[8] = '0' + ((hz / 10) % 10);
 80061ac:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
  buf[4] = '0' + ((khz / 10) % 10);
 80061b0:	08ff      	lsrs	r7, r7, #3
  buf[8] = '0' + ((hz / 10) % 10);
 80061b2:	fba3 130c 	umull	r1, r3, r3, ip
  buf[4] = '0' + ((khz / 10) % 10);
 80061b6:	eb07 0787 	add.w	r7, r7, r7, lsl #2
  buf[8] = '0' + ((hz / 10) % 10);
 80061ba:	08db      	lsrs	r3, r3, #3
  buf[4] = '0' + ((khz / 10) % 10);
 80061bc:	eba2 0747 	sub.w	r7, r2, r7, lsl #1
  buf[5] = '0' + (khz % 10);
 80061c0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80061c4:	eba6 0242 	sub.w	r2, r6, r2, lsl #1
  buf[8] = '0' + ((hz / 10) % 10);
 80061c8:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  buf[3] = '0' + (khz / 100);
 80061cc:	fbae 6306 	umull	r6, r3, lr, r6
  buf[5] = '0' + (khz % 10);
 80061d0:	3230      	adds	r2, #48	@ 0x30
  buf[3] = '0' + (khz / 100);
 80061d2:	095b      	lsrs	r3, r3, #5
  buf[8] = '0' + ((hz / 10) % 10);
 80061d4:	ebac 0141 	sub.w	r1, ip, r1, lsl #1
  buf[0] = '0' + (mhz / 10);
 80061d8:	08c0      	lsrs	r0, r0, #3
  buf[3] = '0' + (khz / 100);
 80061da:	3330      	adds	r3, #48	@ 0x30
  buf[5] = '0' + (khz % 10);
 80061dc:	f88d 2005 	strb.w	r2, [sp, #5]
  buf[12] = 'z';
 80061e0:	227a      	movs	r2, #122	@ 0x7a
  buf[7] = '0' + (hz / 100);
 80061e2:	fbae 6e04 	umull	r6, lr, lr, r4
  buf[9] = '0' + (hz % 10);
 80061e6:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
  buf[3] = '0' + (khz / 100);
 80061ea:	f88d 3003 	strb.w	r3, [sp, #3]
  buf[12] = 'z';
 80061ee:	f8ad 200c 	strh.w	r2, [sp, #12]
  buf[8] = '0' + ((hz / 10) % 10);
 80061f2:	f101 0330 	add.w	r3, r1, #48	@ 0x30
  buf[1] = '0' + (mhz % 10);
 80061f6:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  buf[9] = '0' + (hz % 10);
 80061fa:	eba4 044c 	sub.w	r4, r4, ip, lsl #1
  buf[8] = '0' + ((hz / 10) % 10);
 80061fe:	f88d 3008 	strb.w	r3, [sp, #8]
  buf[1] = '0' + (mhz % 10);
 8006202:	eba5 0542 	sub.w	r5, r5, r2, lsl #1
  buf[10] = ' ';
 8006206:	f644 0320 	movw	r3, #18464	@ 0x4820
  buf[2] = '.';
 800620a:	222e      	movs	r2, #46	@ 0x2e
  buf[0] = '0' + (mhz / 10);
 800620c:	3030      	adds	r0, #48	@ 0x30
  buf[7] = '0' + (hz / 100);
 800620e:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8006212:	f10e 0e30 	add.w	lr, lr, #48	@ 0x30
  buf[10] = ' ';
 8006216:	f8ad 300a 	strh.w	r3, [sp, #10]
  buf[0] = '0' + (mhz / 10);
 800621a:	f88d 0000 	strb.w	r0, [sp]
  lcd_drawstring_size(buf, 200, yp, 3);
 800621e:	2303      	movs	r3, #3
  buf[2] = '.';
 8006220:	f88d 2002 	strb.w	r2, [sp, #2]
  buf[6] = '.';
 8006224:	f88d 2006 	strb.w	r2, [sp, #6]
  buf[4] = '0' + ((khz / 10) % 10);
 8006228:	3730      	adds	r7, #48	@ 0x30
  buf[9] = '0' + (hz % 10);
 800622a:	3430      	adds	r4, #48	@ 0x30
  buf[1] = '0' + (mhz % 10);
 800622c:	3530      	adds	r5, #48	@ 0x30
  lcd_drawstring_size(buf, 200, yp, 3);
 800622e:	2223      	movs	r2, #35	@ 0x23
 8006230:	21c8      	movs	r1, #200	@ 0xc8
 8006232:	4668      	mov	r0, sp
  buf[4] = '0' + ((khz / 10) % 10);
 8006234:	f88d 7004 	strb.w	r7, [sp, #4]
  buf[7] = '0' + (hz / 100);
 8006238:	f88d e007 	strb.w	lr, [sp, #7]
  buf[9] = '0' + (hz % 10);
 800623c:	f88d 4009 	strb.w	r4, [sp, #9]
  buf[1] = '0' + (mhz % 10);
 8006240:	f88d 5001 	strb.w	r5, [sp, #1]
  lcd_drawstring_size(buf, 200, yp, 3);
 8006244:	f00a f90a 	bl	801045c <lcd_drawstring_size>
  while (*s && *s != ' ')
 8006248:	f89d 3000 	ldrb.w	r3, [sp]
 800624c:	2b00      	cmp	r3, #0
 800624e:	d043      	beq.n	80062d8 <displayTargetFrequency+0x1d8>
        int half = (triW * i) / (2 * triH); // grows from 0 to triW/2
 8006250:	f8df 80b4 	ldr.w	r8, [pc, #180]	@ 8006308 <displayTargetFrequency+0x208>
  while (*s && *s != ' ')
 8006254:	466d      	mov	r5, sp
  int x = xBase;
 8006256:	26c8      	movs	r6, #200	@ 0xc8
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8006258:	2702      	movs	r7, #2
 800625a:	e007      	b.n	800626c <displayTargetFrequency+0x16c>
    if (*s == '.')
 800625c:	782b      	ldrb	r3, [r5, #0]
 800625e:	2b2e      	cmp	r3, #46	@ 0x2e
  while (*s && *s != ' ')
 8006260:	f815 3f01 	ldrb.w	r3, [r5, #1]!
      x += (cw / 2);
 8006264:	bf0c      	ite	eq
 8006266:	360a      	addeq	r6, #10
      x += cw;
 8006268:	3615      	addne	r6, #21
  while (*s && *s != ' ')
 800626a:	b3ab      	cbz	r3, 80062d8 <displayTargetFrequency+0x1d8>
 800626c:	2b20      	cmp	r3, #32
 800626e:	d033      	beq.n	80062d8 <displayTargetFrequency+0x1d8>
    if (*s >= '0' && *s <= '9')
 8006270:	3b30      	subs	r3, #48	@ 0x30
 8006272:	2b09      	cmp	r3, #9
 8006274:	d8f2      	bhi.n	800625c <displayTargetFrequency+0x15c>
      lcd_set_colors(LCD_MENU_ACTIVE_COLOR, LCD_MENU_ACTIVE_COLOR);
 8006276:	2105      	movs	r1, #5
 8006278:	4608      	mov	r0, r1
 800627a:	f009 ff41 	bl	8010100 <lcd_set_colors>
      int cx = x + (cw / 2);
 800627e:	f106 090a 	add.w	r9, r6, #10
 8006282:	f04f 0b0d 	mov.w	fp, #13
 8006286:	2400      	movs	r4, #0
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8006288:	f04f 0a01 	mov.w	sl, #1
        int half = (triW * i) / (2 * triH); // grows from 0 to triW/2
 800628c:	fba8 3004 	umull	r3, r0, r8, r4
 8006290:	08c0      	lsrs	r0, r0, #3
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8006292:	fb10 a207 	smlabb	r2, r0, r7, sl
 8006296:	4659      	mov	r1, fp
 8006298:	2301      	movs	r3, #1
 800629a:	eba9 0000 	sub.w	r0, r9, r0
      for (int i = 0; i < triH; i++)
 800629e:	340a      	adds	r4, #10
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 80062a0:	f009 fe28 	bl	800fef4 <lcd_fill>
      for (int i = 0; i < triH; i++)
 80062a4:	2c3c      	cmp	r4, #60	@ 0x3c
 80062a6:	f10b 0b01 	add.w	fp, fp, #1
 80062aa:	d1ef      	bne.n	800628c <displayTargetFrequency+0x18c>
 80062ac:	f04f 0b5a 	mov.w	fp, #90	@ 0x5a
 80062b0:	2400      	movs	r4, #0
        lcd_fill(cx - half, triDnY - i, 2 * half + 1, 1);
 80062b2:	f04f 0a01 	mov.w	sl, #1
        int half = (triW * i) / (2 * triH);
 80062b6:	fba8 3004 	umull	r3, r0, r8, r4
 80062ba:	08c0      	lsrs	r0, r0, #3
        lcd_fill(cx - half, triDnY - i, 2 * half + 1, 1);
 80062bc:	fb10 a207 	smlabb	r2, r0, r7, sl
 80062c0:	4659      	mov	r1, fp
 80062c2:	2301      	movs	r3, #1
 80062c4:	eba9 0000 	sub.w	r0, r9, r0
      for (int i = 0; i < triH; i++)
 80062c8:	340a      	adds	r4, #10
        lcd_fill(cx - half, triDnY - i, 2 * half + 1, 1);
 80062ca:	f009 fe13 	bl	800fef4 <lcd_fill>
      for (int i = 0; i < triH; i++)
 80062ce:	2c3c      	cmp	r4, #60	@ 0x3c
 80062d0:	f10b 3bff 	add.w	fp, fp, #4294967295
 80062d4:	d1ef      	bne.n	80062b6 <displayTargetFrequency+0x1b6>
 80062d6:	e7c1      	b.n	800625c <displayTargetFrequency+0x15c>
}
 80062d8:	b005      	add	sp, #20
 80062da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!label_drawn)
 80062de:	682b      	ldr	r3, [r5, #0]
 80062e0:	2b00      	cmp	r3, #0
 80062e2:	f47f af33 	bne.w	800614c <displayTargetFrequency+0x4c>
 80062e6:	e717      	b.n	8006118 <displayTargetFrequency+0x18>
 80062e8:	200068b0 	.word	0x200068b0
 80062ec:	200008f4 	.word	0x200008f4
 80062f0:	08011880 	.word	0x08011880
 80062f4:	200008f0 	.word	0x200008f0
 80062f8:	10624dd3 	.word	0x10624dd3
 80062fc:	431bde83 	.word	0x431bde83
 8006300:	cccccccd 	.word	0xcccccccd
 8006304:	51eb851f 	.word	0x51eb851f
 8006308:	aaaaaaab 	.word	0xaaaaaaab

0800630c <pause_sweep>:
  sweep_mode &= ~SWEEP_ENABLE;
 800630c:	4a02      	ldr	r2, [pc, #8]	@ (8006318 <pause_sweep+0xc>)
 800630e:	7813      	ldrb	r3, [r2, #0]
 8006310:	f023 0301 	bic.w	r3, r3, #1
 8006314:	7013      	strb	r3, [r2, #0]
}
 8006316:	4770      	bx	lr
 8006318:	200003c4 	.word	0x200003c4

0800631c <cmd_pause>:
  pause_sweep();
 800631c:	f7ff bff6 	b.w	800630c <pause_sweep>

08006320 <cmd_freq>:
  if (argc != 1)
 8006320:	2801      	cmp	r0, #1
 8006322:	d000      	beq.n	8006326 <cmd_freq+0x6>
 8006324:	4770      	bx	lr
{
 8006326:	b508      	push	{r3, lr}
  uint32_t freq = my_atoui(argv[0]);
 8006328:	6808      	ldr	r0, [r1, #0]
 800632a:	f002 fb43 	bl	80089b4 <my_atoui>
  pause_sweep();
 800632e:	f7ff ffed 	bl	800630c <pause_sweep>
  return si5351_set_frequency(freq, current_props._power);
 8006332:	4b03      	ldr	r3, [pc, #12]	@ (8006340 <cmd_freq+0x20>)
 8006334:	7fd9      	ldrb	r1, [r3, #31]
}
 8006336:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return si5351_set_frequency(freq, current_props._power);
 800633a:	f002 be23 	b.w	8008f84 <si5351_set_frequency>
 800633e:	bf00      	nop
 8006340:	20000aa8 	.word	0x20000aa8

08006344 <toggle_sweep>:
  sweep_mode ^= SWEEP_ENABLE;
 8006344:	4a02      	ldr	r2, [pc, #8]	@ (8006350 <toggle_sweep+0xc>)
 8006346:	7813      	ldrb	r3, [r2, #0]
 8006348:	f083 0301 	eor.w	r3, r3, #1
 800634c:	7013      	strb	r3, [r2, #0]
}
 800634e:	4770      	bx	lr
 8006350:	200003c4 	.word	0x200003c4

08006354 <set_power>:
{
 8006354:	b510      	push	{r4, lr}
 8006356:	4604      	mov	r4, r0
  request_to_redraw(REDRAW_CAL_STATUS);
 8006358:	2010      	movs	r0, #16
 800635a:	f005 fa49 	bl	800b7f0 <request_to_redraw>
  if (current_props._power == value)
 800635e:	4b09      	ldr	r3, [pc, #36]	@ (8006384 <set_power+0x30>)
    value = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 8006360:	2c04      	cmp	r4, #4
  if (current_props._power == value)
 8006362:	7fda      	ldrb	r2, [r3, #31]
    value = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 8006364:	bf28      	it	cs
 8006366:	24ff      	movcs	r4, #255	@ 0xff
  if (current_props._power == value)
 8006368:	42a2      	cmp	r2, r4
 800636a:	d004      	beq.n	8006376 <set_power+0x22>
  if (!(sweep_mode & SWEEP_ENABLE))
 800636c:	4a06      	ldr	r2, [pc, #24]	@ (8006388 <set_power+0x34>)
  current_props._power = value;
 800636e:	77dc      	strb	r4, [r3, #31]
  if (!(sweep_mode & SWEEP_ENABLE))
 8006370:	7813      	ldrb	r3, [r2, #0]
 8006372:	07db      	lsls	r3, r3, #31
 8006374:	d500      	bpl.n	8006378 <set_power+0x24>
}
 8006376:	bd10      	pop	{r4, pc}
    si5351_set_power(value);
 8006378:	4620      	mov	r0, r4
}
 800637a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    si5351_set_power(value);
 800637e:	f002 bf41 	b.w	8009204 <si5351_set_power>
 8006382:	bf00      	nop
 8006384:	20000aa8 	.word	0x20000aa8
 8006388:	200003c4 	.word	0x200003c4

0800638c <cmd_power>:
  if (argc != 1)
 800638c:	2801      	cmp	r0, #1
 800638e:	d000      	beq.n	8006392 <cmd_power+0x6>
 8006390:	4770      	bx	lr
{
 8006392:	b508      	push	{r3, lr}
  set_power(my_atoi(argv[0]));
 8006394:	6808      	ldr	r0, [r1, #0]
 8006396:	f002 faf3 	bl	8008980 <my_atoi>
}
 800639a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_power(my_atoi(argv[0]));
 800639e:	b2c0      	uxtb	r0, r0
 80063a0:	f7ff bfd8 	b.w	8006354 <set_power>

080063a4 <capture_rle8>:
{
 80063a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80063a8:	b085      	sub	sp, #20
  uint16_t size = sizeof(config._lcd_palette);
 80063aa:	2340      	movs	r3, #64	@ 0x40
  shell_write(&screenshot_header, sizeof(screenshot_header)); // write header
 80063ac:	482b      	ldr	r0, [pc, #172]	@ (800645c <capture_rle8+0xb8>)
  uint16_t size = sizeof(config._lcd_palette);
 80063ae:	f8ad 300e 	strh.w	r3, [sp, #14]
  shell_write(&screenshot_header, sizeof(screenshot_header)); // write header
 80063b2:	2108      	movs	r1, #8
 80063b4:	f7ff f858 	bl	8005468 <shell_write>
  shell_write(&size, sizeof(uint16_t));                       // write palette block size
 80063b8:	2102      	movs	r1, #2
 80063ba:	f10d 000e 	add.w	r0, sp, #14
 80063be:	f7ff f853 	bl	8005468 <shell_write>
  shell_write(config._lcd_palette, size);                     // write palette block
 80063c2:	4827      	ldr	r0, [pc, #156]	@ (8006460 <capture_rle8+0xbc>)
 80063c4:	f8bd 100e 	ldrh.w	r1, [sp, #14]
 80063c8:	f8df 80a4 	ldr.w	r8, [pc, #164]	@ 8006470 <capture_rle8+0xcc>
 80063cc:	4e25      	ldr	r6, [pc, #148]	@ (8006464 <capture_rle8+0xc0>)
 80063ce:	f7ff f84b 	bl	8005468 <shell_write>
  for (int y = 0, idx = 0; y < LCD_HEIGHT; y++)
 80063d2:	2400      	movs	r4, #0
 80063d4:	4627      	mov	r7, r4
 80063d6:	f208 35be 	addw	r5, r8, #958	@ 0x3be
 80063da:	f1a8 0940 	sub.w	r9, r8, #64	@ 0x40
    lcd_read_memory(0, y, LCD_WIDTH, 1, data); // read in 16bpp format
 80063de:	2000      	movs	r0, #0
 80063e0:	f8cd 8000 	str.w	r8, [sp]
 80063e4:	2301      	movs	r3, #1
 80063e6:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 80063ea:	4639      	mov	r1, r7
 80063ec:	f009 fd16 	bl	800fe1c <lcd_read_memory>
    for (int x = 0; x < LCD_WIDTH; x++)
 80063f0:	481d      	ldr	r0, [pc, #116]	@ (8006468 <capture_rle8+0xc4>)
 80063f2:	f100 0c01 	add.w	ip, r0, #1
 80063f6:	e004      	b.n	8006402 <capture_rle8+0x5e>
      ((uint8_t *)data)[x] = idx; // put palette index
 80063f8:	b2e3      	uxtb	r3, r4
    for (int x = 0; x < LCD_WIDTH; x++)
 80063fa:	42a8      	cmp	r0, r5
      ((uint8_t *)data)[x] = idx; // put palette index
 80063fc:	f80c 3f01 	strb.w	r3, [ip, #1]!
    for (int x = 0; x < LCD_WIDTH; x++)
 8006400:	d015      	beq.n	800642e <capture_rle8+0x8a>
      if (config._lcd_palette[idx] != data[x])
 8006402:	eb06 0344 	add.w	r3, r6, r4, lsl #1
 8006406:	f830 1f02 	ldrh.w	r1, [r0, #2]!
 800640a:	8bdb      	ldrh	r3, [r3, #30]
 800640c:	428b      	cmp	r3, r1
 800640e:	d0f3      	beq.n	80063f8 <capture_rle8+0x54>
 8006410:	4b16      	ldr	r3, [pc, #88]	@ (800646c <capture_rle8+0xc8>)
        for (idx = 0; idx < MAX_PALETTE && config._lcd_palette[idx] != data[x]; idx++)
 8006412:	2400      	movs	r4, #0
 8006414:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 8006418:	428a      	cmp	r2, r1
 800641a:	d0ed      	beq.n	80063f8 <capture_rle8+0x54>
 800641c:	3401      	adds	r4, #1
 800641e:	2c20      	cmp	r4, #32
 8006420:	d1f8      	bne.n	8006414 <capture_rle8+0x70>
 8006422:	2400      	movs	r4, #0
          idx = 0;
 8006424:	4623      	mov	r3, r4
    for (int x = 0; x < LCD_WIDTH; x++)
 8006426:	42a8      	cmp	r0, r5
      ((uint8_t *)data)[x] = idx; // put palette index
 8006428:	f80c 3f01 	strb.w	r3, [ip, #1]!
    for (int x = 0; x < LCD_WIDTH; x++)
 800642c:	d1e9      	bne.n	8006402 <capture_rle8+0x5e>
    spi_buffer[0] = packbits((char *)data, (char *)&spi_buffer[1], LCD_WIDTH); // pack
 800642e:	4810      	ldr	r0, [pc, #64]	@ (8006470 <capture_rle8+0xcc>)
 8006430:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8006434:	f1a0 013e 	sub.w	r1, r0, #62	@ 0x3e
 8006438:	f002 fbd6 	bl	8008be8 <packbits>
    shell_write(spi_buffer, spi_buffer[0] + sizeof(uint16_t));
 800643c:	b281      	uxth	r1, r0
    spi_buffer[0] = packbits((char *)data, (char *)&spi_buffer[1], LCD_WIDTH); // pack
 800643e:	4603      	mov	r3, r0
    shell_write(spi_buffer, spi_buffer[0] + sizeof(uint16_t));
 8006440:	3102      	adds	r1, #2
 8006442:	4648      	mov	r0, r9
  for (int y = 0, idx = 0; y < LCD_HEIGHT; y++)
 8006444:	3701      	adds	r7, #1
    spi_buffer[0] = packbits((char *)data, (char *)&spi_buffer[1], LCD_WIDTH); // pack
 8006446:	f8a9 3000 	strh.w	r3, [r9]
    shell_write(spi_buffer, spi_buffer[0] + sizeof(uint16_t));
 800644a:	f7ff f80d 	bl	8005468 <shell_write>
  for (int y = 0, idx = 0; y < LCD_HEIGHT; y++)
 800644e:	f5b7 7fa0 	cmp.w	r7, #320	@ 0x140
 8006452:	d1c4      	bne.n	80063de <capture_rle8+0x3a>
}
 8006454:	b005      	add	sp, #20
 8006456:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800645a:	bf00      	nop
 800645c:	08013d28 	.word	0x08013d28
 8006460:	20000336 	.word	0x20000336
 8006464:	20000318 	.word	0x20000318
 8006468:	20008a32 	.word	0x20008a32
 800646c:	20000334 	.word	0x20000334
 8006470:	20008a34 	.word	0x20008a34

08006474 <cmd_capture>:
  if (argc > 0)
 8006474:	2800      	cmp	r0, #0
 8006476:	dc16      	bgt.n	80064a6 <cmd_capture+0x32>
{
 8006478:	b530      	push	{r4, r5, lr}
 800647a:	4d0c      	ldr	r5, [pc, #48]	@ (80064ac <cmd_capture+0x38>)
 800647c:	b083      	sub	sp, #12
  for (int y = 0; y < LCD_HEIGHT; y += READ_ROWS)
 800647e:	2400      	movs	r4, #0
    lcd_read_memory(0, y, LCD_WIDTH, READ_ROWS, (uint16_t *)spi_buffer);
 8006480:	4621      	mov	r1, r4
 8006482:	2302      	movs	r3, #2
 8006484:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8006488:	2000      	movs	r0, #0
 800648a:	9500      	str	r5, [sp, #0]
 800648c:	f009 fcc6 	bl	800fe1c <lcd_read_memory>
  for (int y = 0; y < LCD_HEIGHT; y += READ_ROWS)
 8006490:	3402      	adds	r4, #2
    shell_write(spi_buffer, READ_ROWS * LCD_WIDTH * sizeof(uint16_t));
 8006492:	f44f 61f0 	mov.w	r1, #1920	@ 0x780
 8006496:	4628      	mov	r0, r5
 8006498:	f7fe ffe6 	bl	8005468 <shell_write>
  for (int y = 0; y < LCD_HEIGHT; y += READ_ROWS)
 800649c:	f5b4 7fa0 	cmp.w	r4, #320	@ 0x140
 80064a0:	d1ee      	bne.n	8006480 <cmd_capture+0xc>
}
 80064a2:	b003      	add	sp, #12
 80064a4:	bd30      	pop	{r4, r5, pc}
    capture_rle8();
 80064a6:	f7ff bf7d 	b.w	80063a4 <capture_rle8>
 80064aa:	bf00      	nop
 80064ac:	200089f4 	.word	0x200089f4

080064b0 <i2s_lld_serve_rx_interrupt>:
{
 80064b0:	b570      	push	{r4, r5, r6, lr}
  uint16_t wait = wait_count;
 80064b2:	4d1f      	ldr	r5, [pc, #124]	@ (8006530 <i2s_lld_serve_rx_interrupt+0x80>)
 80064b4:	882b      	ldrh	r3, [r5, #0]
 80064b6:	b29b      	uxth	r3, r3
  if (wait == 0 || chVTGetSystemTimeX() < ready_time)
 80064b8:	2b00      	cmp	r3, #0
 80064ba:	d032      	beq.n	8006522 <i2s_lld_serve_rx_interrupt+0x72>
 80064bc:	491d      	ldr	r1, [pc, #116]	@ (8006534 <i2s_lld_serve_rx_interrupt+0x84>)
 80064be:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 80064c2:	6809      	ldr	r1, [r1, #0]
 80064c4:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80064c6:	4291      	cmp	r1, r2
 80064c8:	d82b      	bhi.n	8006522 <i2s_lld_serve_rx_interrupt+0x72>
  audio_sample_t *p = (flags & STM32_DMA_ISR_TCIF) ? rx_buffer + AUDIO_BUFFER_LEN : rx_buffer; // Full or Half transfer complete
 80064ca:	0782      	lsls	r2, r0, #30
  if (wait >= config._bandwidth + 2)                                                           // At this moment in buffer exist noise data, reset and wait next clean buffer
 80064cc:	4a1a      	ldr	r2, [pc, #104]	@ (8006538 <i2s_lld_serve_rx_interrupt+0x88>)
  audio_sample_t *p = (flags & STM32_DMA_ISR_TCIF) ? rx_buffer + AUDIO_BUFFER_LEN : rx_buffer; // Full or Half transfer complete
 80064ce:	bf48      	it	mi
 80064d0:	4e1a      	ldrmi	r6, [pc, #104]	@ (800653c <i2s_lld_serve_rx_interrupt+0x8c>)
  if (wait >= config._bandwidth + 2)                                                           // At this moment in buffer exist noise data, reset and wait next clean buffer
 80064d2:	8b52      	ldrh	r2, [r2, #26]
  audio_sample_t *p = (flags & STM32_DMA_ISR_TCIF) ? rx_buffer + AUDIO_BUFFER_LEN : rx_buffer; // Full or Half transfer complete
 80064d4:	bf58      	it	pl
 80064d6:	4e1a      	ldrpl	r6, [pc, #104]	@ (8006540 <i2s_lld_serve_rx_interrupt+0x90>)
  if (wait >= config._bandwidth + 2)                                                           // At this moment in buffer exist noise data, reset and wait next clean buffer
 80064d8:	3201      	adds	r2, #1
 80064da:	429a      	cmp	r2, r3
 80064dc:	da22      	bge.n	8006524 <i2s_lld_serve_rx_interrupt+0x74>
    reset_dsp_accumerator();
 80064de:	f002 ffd3 	bl	8009488 <reset_dsp_accumerator>
  p += dump_selection;
 80064e2:	4b18      	ldr	r3, [pc, #96]	@ (8006544 <i2s_lld_serve_rx_interrupt+0x94>)
 80064e4:	4918      	ldr	r1, [pc, #96]	@ (8006548 <i2s_lld_serve_rx_interrupt+0x98>)
 80064e6:	f9b3 3000 	ldrsh.w	r3, [r3]
    *dump_buffer++ = *p;
 80064ea:	4c18      	ldr	r4, [pc, #96]	@ (800654c <i2s_lld_serve_rx_interrupt+0x9c>)
  p += dump_selection;
 80064ec:	eb06 0e43 	add.w	lr, r6, r3, lsl #1
  while (n)
 80064f0:	f10e 0204 	add.w	r2, lr, #4
 80064f4:	f10e 0ec4 	add.w	lr, lr, #196	@ 0xc4
    if (dump_len == 0)
 80064f8:	880b      	ldrh	r3, [r1, #0]
 80064fa:	b21b      	sxth	r3, r3
 80064fc:	b16b      	cbz	r3, 800651a <i2s_lld_serve_rx_interrupt+0x6a>
    dump_len--;
 80064fe:	880b      	ldrh	r3, [r1, #0]
    *dump_buffer++ = *p;
 8006500:	6820      	ldr	r0, [r4, #0]
 8006502:	f932 cc04 	ldrsh.w	ip, [r2, #-4]
    dump_len--;
 8006506:	3b01      	subs	r3, #1
  while (n)
 8006508:	3204      	adds	r2, #4
    dump_len--;
 800650a:	b21b      	sxth	r3, r3
    *dump_buffer++ = *p;
 800650c:	1c86      	adds	r6, r0, #2
  while (n)
 800650e:	4596      	cmp	lr, r2
    dump_len--;
 8006510:	800b      	strh	r3, [r1, #0]
    *dump_buffer++ = *p;
 8006512:	6026      	str	r6, [r4, #0]
 8006514:	f8a0 c000 	strh.w	ip, [r0]
  while (n)
 8006518:	d1ee      	bne.n	80064f8 <i2s_lld_serve_rx_interrupt+0x48>
  --wait_count;
 800651a:	882b      	ldrh	r3, [r5, #0]
 800651c:	3b01      	subs	r3, #1
 800651e:	b29b      	uxth	r3, r3
 8006520:	802b      	strh	r3, [r5, #0]
}
 8006522:	bd70      	pop	{r4, r5, r6, pc}
    dsp_process(p, count);
 8006524:	2160      	movs	r1, #96	@ 0x60
 8006526:	4630      	mov	r0, r6
 8006528:	f002 ff18 	bl	800935c <dsp_process>
 800652c:	e7d9      	b.n	80064e2 <i2s_lld_serve_rx_interrupt+0x32>
 800652e:	bf00      	nop
 8006530:	20000a98 	.word	0x20000a98
 8006534:	20000a9c 	.word	0x20000a9c
 8006538:	20000318 	.word	0x20000318
 800653c:	200009d8 	.word	0x200009d8
 8006540:	20000918 	.word	0x20000918
 8006544:	20000aa0 	.word	0x20000aa0
 8006548:	20000aa2 	.word	0x20000aa2
 800654c:	20000aa4 	.word	0x20000aa4

08006550 <set_bandwidth>:
  config._bandwidth = bw_count & 0x1FF;
 8006550:	4a03      	ldr	r2, [pc, #12]	@ (8006560 <set_bandwidth+0x10>)
 8006552:	f3c0 0308 	ubfx	r3, r0, #0, #9
  request_to_redraw(REDRAW_BACKUP | REDRAW_FREQUENCY);
 8006556:	f44f 6081 	mov.w	r0, #1032	@ 0x408
  config._bandwidth = bw_count & 0x1FF;
 800655a:	8353      	strh	r3, [r2, #26]
  request_to_redraw(REDRAW_BACKUP | REDRAW_FREQUENCY);
 800655c:	f005 b948 	b.w	800b7f0 <request_to_redraw>
 8006560:	20000318 	.word	0x20000318

08006564 <cmd_bandwidth>:
  if (argc == 1)
 8006564:	2801      	cmp	r0, #1
{
 8006566:	b508      	push	{r3, lr}
  if (argc == 1)
 8006568:	d012      	beq.n	8006590 <cmd_bandwidth+0x2c>
  else if (argc == 2)
 800656a:	2802      	cmp	r0, #2
 800656c:	d000      	beq.n	8006570 <cmd_bandwidth+0xc>
}
 800656e:	bd08      	pop	{r3, pc}
    uint16_t f = my_atoui(argv[0]);
 8006570:	6808      	ldr	r0, [r1, #0]
 8006572:	f002 fa1f 	bl	80089b4 <my_atoui>
 8006576:	b283      	uxth	r3, r0
    if (f > MAX_BANDWIDTH)
 8006578:	f5b3 6f7a 	cmp.w	r3, #4000	@ 0xfa0
 800657c:	d810      	bhi.n	80065a0 <cmd_bandwidth+0x3c>
    else if (f < MIN_BANDWIDTH)
 800657e:	2b07      	cmp	r3, #7
 8006580:	d913      	bls.n	80065aa <cmd_bandwidth+0x46>
      user_bw = ((AUDIO_ADC_FREQ + AUDIO_SAMPLES_COUNT / 2) / AUDIO_SAMPLES_COUNT) / f - 1;
 8006582:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 8006586:	fbb0 f0f3 	udiv	r0, r0, r3
 800658a:	3801      	subs	r0, #1
 800658c:	b280      	uxth	r0, r0
 800658e:	e003      	b.n	8006598 <cmd_bandwidth+0x34>
    user_bw = my_atoui(argv[0]);
 8006590:	6808      	ldr	r0, [r1, #0]
 8006592:	f002 fa0f 	bl	80089b4 <my_atoui>
 8006596:	b280      	uxth	r0, r0
}
 8006598:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_bandwidth(user_bw);
 800659c:	f7ff bfd8 	b.w	8006550 <set_bandwidth>
}
 80065a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      user_bw = 0;
 80065a4:	2000      	movs	r0, #0
  set_bandwidth(user_bw);
 80065a6:	f7ff bfd3 	b.w	8006550 <set_bandwidth>
      user_bw = 511;
 80065aa:	f240 10ff 	movw	r0, #511	@ 0x1ff
 80065ae:	e7f3      	b.n	8006598 <cmd_bandwidth+0x34>

080065b0 <get_bandwidth_frequency>:
  return (AUDIO_ADC_FREQ / AUDIO_SAMPLES_COUNT) / (bw_freq + 1);
 80065b0:	f44f 637a 	mov.w	r3, #4000	@ 0xfa0
 80065b4:	3001      	adds	r0, #1
}
 80065b6:	fbb3 f0f0 	udiv	r0, r3, r0
 80065ba:	4770      	bx	lr

080065bc <getFrequency>:
freq_t getFrequency(uint16_t idx) { return _f_start + _f_delta * idx + (_f_points / 2 + _f_error * idx) / _f_points; }
 80065bc:	4909      	ldr	r1, [pc, #36]	@ (80065e4 <getFrequency+0x28>)
 80065be:	4a0a      	ldr	r2, [pc, #40]	@ (80065e8 <getFrequency+0x2c>)
 80065c0:	4b0a      	ldr	r3, [pc, #40]	@ (80065ec <getFrequency+0x30>)
 80065c2:	8809      	ldrh	r1, [r1, #0]
 80065c4:	681b      	ldr	r3, [r3, #0]
 80065c6:	6812      	ldr	r2, [r2, #0]
 80065c8:	b410      	push	{r4}
 80065ca:	4c09      	ldr	r4, [pc, #36]	@ (80065f0 <getFrequency+0x34>)
 80065cc:	6824      	ldr	r4, [r4, #0]
 80065ce:	fb02 3200 	mla	r2, r2, r0, r3
 80065d2:	084b      	lsrs	r3, r1, #1
 80065d4:	fb04 3300 	mla	r3, r4, r0, r3
 80065d8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80065dc:	fbb3 f3f1 	udiv	r3, r3, r1
 80065e0:	1898      	adds	r0, r3, r2
 80065e2:	4770      	bx	lr
 80065e4:	20000908 	.word	0x20000908
 80065e8:	20000910 	.word	0x20000910
 80065ec:	20000914 	.word	0x20000914
 80065f0:	2000090c 	.word	0x2000090c

080065f4 <sweep>:
{
 80065f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (p_sweep >= sweep_points || break_on_operation == false)
 80065f8:	4d8f      	ldr	r5, [pc, #572]	@ (8006838 <sweep+0x244>)
 80065fa:	4c90      	ldr	r4, [pc, #576]	@ (800683c <sweep+0x248>)
 80065fc:	8b6a      	ldrh	r2, [r5, #26]
 80065fe:	8823      	ldrh	r3, [r4, #0]
{
 8006600:	ed2d 8b08 	vpush	{d8-d11}
 8006604:	b099      	sub	sp, #100	@ 0x64
  if (p_sweep >= sweep_points || break_on_operation == false)
 8006606:	429a      	cmp	r2, r3
{
 8006608:	9002      	str	r0, [sp, #8]
 800660a:	460f      	mov	r7, r1
  if (p_sweep >= sweep_points || break_on_operation == false)
 800660c:	d966      	bls.n	80066dc <sweep+0xe8>
 800660e:	2800      	cmp	r0, #0
 8006610:	d064      	beq.n	80066dc <sweep+0xe8>
  palClearPad(GPIOC, GPIOC_LED);
 8006612:	4b8b      	ldr	r3, [pc, #556]	@ (8006840 <sweep+0x24c>)
  float offset = vna_expf(s21_offset * (logf(10.0f) / 20.0f));
 8006614:	ed95 0a2a 	vldr	s0, [r5, #168]	@ 0xa8
 8006618:	eddf 7a8a 	vldr	s15, [pc, #552]	@ 8006844 <sweep+0x250>
  palClearPad(GPIOC, GPIOC_LED);
 800661c:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 8006620:	619a      	str	r2, [r3, #24]
  float offset = vna_expf(s21_offset * (logf(10.0f) / 20.0f));
 8006622:	ee20 0a27 	vmul.f32	s0, s0, s15
 8006626:	f00a ff3d 	bl	80114a4 <vna_expf>
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 800662a:	2011      	movs	r0, #17
  float offset = vna_expf(s21_offset * (logf(10.0f) / 20.0f));
 800662c:	eeb0 9a40 	vmov.f32	s18, s0
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 8006630:	f009 fd5a 	bl	80100e8 <lcd_set_background>
  for (; p_sweep < sweep_points; p_sweep++)
 8006634:	8b6b      	ldrh	r3, [r5, #26]
 8006636:	8820      	ldrh	r0, [r4, #0]
 8006638:	4283      	cmp	r3, r0
 800663a:	d942      	bls.n	80066c2 <sweep+0xce>
 800663c:	f007 0303 	and.w	r3, r7, #3
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006640:	f007 0240 	and.w	r2, r7, #64	@ 0x40
 8006644:	f8df a20c 	ldr.w	sl, [pc, #524]	@ 8006854 <sweep+0x260>
 8006648:	9203      	str	r2, [sp, #12]
  int bar_start = 0;
 800664a:	f04f 0b00 	mov.w	fp, #0
  int st_delay = DELAY_SWEEP_START;
 800664e:	f04f 09c8 	mov.w	r9, #200	@ 0xc8
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006652:	4698      	mov	r8, r3
    if (mask & (SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE))
 8006654:	f1b8 0f00 	cmp.w	r8, #0
 8006658:	d143      	bne.n	80066e2 <sweep+0xee>
    if (operation_requested && break_on_operation)
 800665a:	f89a 3000 	ldrb.w	r3, [sl]
 800665e:	b10b      	cbz	r3, 8006664 <sweep+0x70>
 8006660:	9b02      	ldr	r3, [sp, #8]
 8006662:	bb03      	cbnz	r3, 80066a6 <sweep+0xb2>
    if (config._bandwidth >= BANDWIDTH_100)
 8006664:	4b78      	ldr	r3, [pc, #480]	@ (8006848 <sweep+0x254>)
      int current_bar = (p_sweep * WIDTH) / (sweep_points - 1);
 8006666:	8820      	ldrh	r0, [r4, #0]
    if (config._bandwidth >= BANDWIDTH_100)
 8006668:	8b5a      	ldrh	r2, [r3, #26]
      int current_bar = (p_sweep * WIDTH) / (sweep_points - 1);
 800666a:	8b6b      	ldrh	r3, [r5, #26]
    if (config._bandwidth >= BANDWIDTH_100)
 800666c:	2a26      	cmp	r2, #38	@ 0x26
 800666e:	d913      	bls.n	8006698 <sweep+0xa4>
      int current_bar = (p_sweep * WIDTH) / (sweep_points - 1);
 8006670:	ebc0 06c0 	rsb	r6, r0, r0, lsl #3
 8006674:	1e5a      	subs	r2, r3, #1
 8006676:	eb06 1686 	add.w	r6, r6, r6, lsl #6
 800667a:	fb96 f6f2 	sdiv	r6, r6, r2
      if (current_bar - bar_start > 0)
 800667e:	eba6 020b 	sub.w	r2, r6, fp
 8006682:	2a00      	cmp	r2, #0
 8006684:	dd08      	ble.n	8006698 <sweep+0xa4>
        lcd_fill(OFFSETX + CELLOFFSETX + bar_start, OFFSETY, current_bar - bar_start, 1);
 8006686:	f10b 0014 	add.w	r0, fp, #20
 800668a:	2301      	movs	r3, #1
 800668c:	2100      	movs	r1, #0
 800668e:	f009 fc31 	bl	800fef4 <lcd_fill>
  for (; p_sweep < sweep_points; p_sweep++)
 8006692:	8820      	ldrh	r0, [r4, #0]
 8006694:	8b6b      	ldrh	r3, [r5, #26]
        bar_start = current_bar;
 8006696:	46b3      	mov	fp, r6
  for (; p_sweep < sweep_points; p_sweep++)
 8006698:	3001      	adds	r0, #1
 800669a:	b280      	uxth	r0, r0
 800669c:	4298      	cmp	r0, r3
 800669e:	8020      	strh	r0, [r4, #0]
 80066a0:	f04f 0900 	mov.w	r9, #0
 80066a4:	d3d6      	bcc.n	8006654 <sweep+0x60>
  if (bar_start)
 80066a6:	f1bb 0f00 	cmp.w	fp, #0
 80066aa:	d008      	beq.n	80066be <sweep+0xca>
    lcd_set_background(LCD_GRID_COLOR);
 80066ac:	2002      	movs	r0, #2
 80066ae:	f009 fd1b 	bl	80100e8 <lcd_set_background>
    lcd_fill(OFFSETX + CELLOFFSETX, OFFSETY, bar_start, 1);
 80066b2:	2301      	movs	r3, #1
 80066b4:	2100      	movs	r1, #0
 80066b6:	465a      	mov	r2, fp
 80066b8:	2014      	movs	r0, #20
 80066ba:	f009 fc1b 	bl	800fef4 <lcd_fill>
  return p_sweep == sweep_points;
 80066be:	8b6b      	ldrh	r3, [r5, #26]
 80066c0:	8820      	ldrh	r0, [r4, #0]
  palSetPad(GPIOC, GPIOC_LED);
 80066c2:	4a5f      	ldr	r2, [pc, #380]	@ (8006840 <sweep+0x24c>)
}
 80066c4:	1a18      	subs	r0, r3, r0
 80066c6:	fab0 f080 	clz	r0, r0
  palSetPad(GPIOC, GPIOC_LED);
 80066ca:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
}
 80066ce:	0940      	lsrs	r0, r0, #5
  palSetPad(GPIOC, GPIOC_LED);
 80066d0:	6191      	str	r1, [r2, #24]
}
 80066d2:	b019      	add	sp, #100	@ 0x64
 80066d4:	ecbd 8b08 	vpop	{d8-d11}
 80066d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    RESET_SWEEP;
 80066dc:	2300      	movs	r3, #0
 80066de:	8023      	strh	r3, [r4, #0]
  if (break_on_operation && mask == 0)
 80066e0:	e797      	b.n	8006612 <sweep+0x1e>
    freq_t frequency = getFrequency(p_sweep);
 80066e2:	f7ff ff6b 	bl	80065bc <getFrequency>
  return si5351_set_frequency(freq, current_props._power);
 80066e6:	7fe9      	ldrb	r1, [r5, #31]
    freq_t frequency = getFrequency(p_sweep);
 80066e8:	9001      	str	r0, [sp, #4]
  return si5351_set_frequency(freq, current_props._power);
 80066ea:	f002 fc4b 	bl	8008f84 <si5351_set_frequency>
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 80066ee:	9b03      	ldr	r3, [sp, #12]
  return si5351_set_frequency(freq, current_props._power);
 80066f0:	4606      	mov	r6, r0
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 80066f2:	2b00      	cmp	r3, #0
 80066f4:	d154      	bne.n	80067a0 <sweep+0x1ac>
    if (mask & SWEEP_CH0_MEASURE)
 80066f6:	f017 0101 	ands.w	r1, r7, #1
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 80066fa:	8822      	ldrh	r2, [r4, #0]
    if (mask & SWEEP_CH0_MEASURE)
 80066fc:	9104      	str	r1, [sp, #16]
 80066fe:	f007 0302 	and.w	r3, r7, #2
 8006702:	d155      	bne.n	80067b0 <sweep+0x1bc>
    if (mask & SWEEP_CH1_MEASURE)
 8006704:	2b00      	cmp	r3, #0
 8006706:	d0a8      	beq.n	800665a <sweep+0x66>
      tlv320aic3204_select(1);
 8006708:	2001      	movs	r0, #1
 800670a:	9205      	str	r2, [sp, #20]
 800670c:	f002 fdc4 	bl	8009298 <tlv320aic3204_select>
 8006710:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
      DSP_START(delay + st_delay);
 8006714:	4b4c      	ldr	r3, [pc, #304]	@ (8006848 <sweep+0x254>)
 8006716:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8006718:	8b5b      	ldrh	r3, [r3, #26]
 800671a:	484c      	ldr	r0, [pc, #304]	@ (800684c <sweep+0x258>)
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 800671c:	9a05      	ldr	r2, [sp, #20]
      DSP_START(delay + st_delay);
 800671e:	4449      	add	r1, r9
 8006720:	4431      	add	r1, r6
 8006722:	3302      	adds	r3, #2
 8006724:	4e4a      	ldr	r6, [pc, #296]	@ (8006850 <sweep+0x25c>)
 8006726:	6001      	str	r1, [r0, #0]
 8006728:	b29b      	uxth	r3, r3
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 800672a:	f017 0f20 	tst.w	r7, #32
      DSP_START(delay + st_delay);
 800672e:	8033      	strh	r3, [r6, #0]
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8006730:	f040 8175 	bne.w	8006a1e <sweep+0x42a>
      DSP_WAIT;
 8006734:	8833      	ldrh	r3, [r6, #0]
 8006736:	b29b      	uxth	r3, r3
 8006738:	f04f 0900 	mov.w	r9, #0
 800673c:	2b00      	cmp	r3, #0
 800673e:	f000 81db 	beq.w	8006af8 <sweep+0x504>
  __ASM volatile ("wfi");
 8006742:	bf30      	wfi
 8006744:	8833      	ldrh	r3, [r6, #0]
 8006746:	b29b      	uxth	r3, r3
 8006748:	2b00      	cmp	r3, #0
 800674a:	d1fa      	bne.n	8006742 <sweep+0x14e>
      (*sample_func)(&data[2]);           // Measure transmission coefficient
 800674c:	a80c      	add	r0, sp, #48	@ 0x30
 800674e:	f002 fe53 	bl	80093f8 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8006752:	f1b9 0f00 	cmp.w	r9, #0
 8006756:	f040 8084 	bne.w	8006862 <sweep+0x26e>
    if (p_sweep < SWEEP_POINTS_MAX)
 800675a:	8823      	ldrh	r3, [r4, #0]
 800675c:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 8006760:	f63f af7b 	bhi.w	800665a <sweep+0x66>
      if (mask & SWEEP_CH0_MEASURE)
 8006764:	9a04      	ldr	r2, [sp, #16]
 8006766:	2a00      	cmp	r2, #0
 8006768:	f040 80d8 	bne.w	800691c <sweep+0x328>
  float real = data[0];
 800676c:	eddd 8a0c 	vldr	s17, [sp, #48]	@ 0x30
  float imag = data[1];
 8006770:	ed9d 8a0d 	vldr	s16, [sp, #52]	@ 0x34
        if (mask & SWEEP_APPLY_EDELAY_S21)
 8006774:	f8df 90e0 	ldr.w	r9, [pc, #224]	@ 8006858 <sweep+0x264>
 8006778:	073a      	lsls	r2, r7, #28
 800677a:	f100 80e8 	bmi.w	800694e <sweep+0x35a>
        if (mask & SWEEP_APPLY_S21_OFFSET)
 800677e:	06fb      	lsls	r3, r7, #27
 8006780:	f100 8108 	bmi.w	8006994 <sweep+0x3a0>
        measured[1][p_sweep][0] = data[2];
 8006784:	8823      	ldrh	r3, [r4, #0]
 8006786:	f203 1291 	addw	r2, r3, #401	@ 0x191
        measured[1][p_sweep][1] = data[3];
 800678a:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 800678e:	f603 438c 	addw	r3, r3, #3212	@ 0xc8c
        measured[1][p_sweep][0] = data[2];
 8006792:	eb09 09c2 	add.w	r9, r9, r2, lsl #3
 8006796:	edc9 8a00 	vstr	s17, [r9]
        measured[1][p_sweep][1] = data[3];
 800679a:	ed83 8a00 	vstr	s16, [r3]
 800679e:	e75c      	b.n	800665a <sweep+0x66>
    if (mask & SWEEP_CH0_MEASURE)
 80067a0:	f017 0101 	ands.w	r1, r7, #1
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 80067a4:	f04f 32ff 	mov.w	r2, #4294967295
    if (mask & SWEEP_CH0_MEASURE)
 80067a8:	f007 0302 	and.w	r3, r7, #2
 80067ac:	9104      	str	r1, [sp, #16]
 80067ae:	d0a9      	beq.n	8006704 <sweep+0x110>
      tlv320aic3204_select(0);
 80067b0:	2000      	movs	r0, #0
 80067b2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80067b6:	f002 fd6f 	bl	8009298 <tlv320aic3204_select>
 80067ba:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
      DSP_START(delay + st_delay);
 80067be:	4b22      	ldr	r3, [pc, #136]	@ (8006848 <sweep+0x254>)
 80067c0:	6a48      	ldr	r0, [r1, #36]	@ 0x24
 80067c2:	8b59      	ldrh	r1, [r3, #26]
 80067c4:	4b21      	ldr	r3, [pc, #132]	@ (800684c <sweep+0x258>)
 80067c6:	4448      	add	r0, r9
 80067c8:	4430      	add	r0, r6
 80067ca:	3102      	adds	r1, #2
 80067cc:	4e20      	ldr	r6, [pc, #128]	@ (8006850 <sweep+0x25c>)
 80067ce:	6018      	str	r0, [r3, #0]
 80067d0:	b289      	uxth	r1, r1
      if (mask & SWEEP_APPLY_CALIBRATION)
 80067d2:	f017 0320 	ands.w	r3, r7, #32
 80067d6:	9307      	str	r3, [sp, #28]
      DSP_START(delay + st_delay);
 80067d8:	8031      	strh	r1, [r6, #0]
      if (mask & SWEEP_APPLY_CALIBRATION)
 80067da:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
 80067de:	f040 8133 	bne.w	8006a48 <sweep+0x454>
      DSP_WAIT;
 80067e2:	8832      	ldrh	r2, [r6, #0]
 80067e4:	b292      	uxth	r2, r2
 80067e6:	2a00      	cmp	r2, #0
 80067e8:	f000 818c 	beq.w	8006b04 <sweep+0x510>
 80067ec:	bf30      	wfi
 80067ee:	8832      	ldrh	r2, [r6, #0]
 80067f0:	b292      	uxth	r2, r2
 80067f2:	2a00      	cmp	r2, #0
 80067f4:	d1fa      	bne.n	80067ec <sweep+0x1f8>
      (*sample_func)(&data[0]);           // calculate reflection coefficient
 80067f6:	a80a      	add	r0, sp, #40	@ 0x28
 80067f8:	9305      	str	r3, [sp, #20]
 80067fa:	f002 fdfd 	bl	80093f8 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 80067fe:	9a07      	ldr	r2, [sp, #28]
 8006800:	9b05      	ldr	r3, [sp, #20]
 8006802:	2a00      	cmp	r2, #0
 8006804:	f040 8139 	bne.w	8006a7a <sweep+0x486>
    if (mask & SWEEP_CH1_MEASURE)
 8006808:	2b00      	cmp	r3, #0
 800680a:	f040 8181 	bne.w	8006b10 <sweep+0x51c>
    if (p_sweep < SWEEP_POINTS_MAX)
 800680e:	8823      	ldrh	r3, [r4, #0]
 8006810:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 8006814:	f63f af21 	bhi.w	800665a <sweep+0x66>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006818:	077e      	lsls	r6, r7, #29
  float real = data[0];
 800681a:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
  float imag = data[1];
 800681e:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006822:	f100 816d 	bmi.w	8006b00 <sweep+0x50c>
        measured[0][p_sweep][0] = data[0];
 8006826:	f8df 9030 	ldr.w	r9, [pc, #48]	@ 8006858 <sweep+0x264>
 800682a:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 800682e:	ed83 ba00 	vstr	s22, [r3]
        measured[0][p_sweep][1] = data[1];
 8006832:	edc3 aa01 	vstr	s21, [r3, #4]
      if (mask & SWEEP_CH1_MEASURE)
 8006836:	e710      	b.n	800665a <sweep+0x66>
 8006838:	20000aa8 	.word	0x20000aa8
 800683c:	20006864 	.word	0x20006864
 8006840:	48000800 	.word	0x48000800
 8006844:	3debc8e3 	.word	0x3debc8e3
 8006848:	20000318 	.word	0x20000318
 800684c:	20000a9c 	.word	0x20000a9c
 8006850:	20000a98 	.word	0x20000a98
 8006854:	200089db 	.word	0x200089db
 8006858:	20004f54 	.word	0x20004f54
      (*sample_func)(&data[2]);           // Measure transmission coefficient
 800685c:	a80c      	add	r0, sp, #48	@ 0x30
 800685e:	f002 fdcb 	bl	80093f8 <calculate_gamma>
  float s21mr = data[2] - c_data[ETERM_EX][0];
 8006862:	ed9d 7a0c 	vldr	s14, [sp, #48]	@ 0x30
 8006866:	eddd 6a16 	vldr	s13, [sp, #88]	@ 0x58
  float s21mi = data[3] - c_data[ETERM_EX][1];
 800686a:	eddd 7a0d 	vldr	s15, [sp, #52]	@ 0x34
 800686e:	eddd 5a17 	vldr	s11, [sp, #92]	@ 0x5c
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006872:	ed9d 6a14 	vldr	s12, [sp, #80]	@ 0x50
  if (cal_status & CALSTAT_ENHANCED_RESPONSE)
 8006876:	8caa      	ldrh	r2, [r5, #36]	@ 0x24
    if (p_sweep < SWEEP_POINTS_MAX)
 8006878:	8823      	ldrh	r3, [r4, #0]
  float s21mr = data[2] - c_data[ETERM_EX][0];
 800687a:	ee37 7a66 	vsub.f32	s14, s14, s13
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 800687e:	eddd 6a15 	vldr	s13, [sp, #84]	@ 0x54
  float s21mi = data[3] - c_data[ETERM_EX][1];
 8006882:	ee77 7ae5 	vsub.f32	s15, s15, s11
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 8006886:	ee27 8a26 	vmul.f32	s16, s14, s13
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 800688a:	ee67 5a06 	vmul.f32	s11, s14, s12
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 800688e:	eea7 8a86 	vfma.f32	s16, s15, s12
  if (cal_status & CALSTAT_ENHANCED_RESPONSE)
 8006892:	0551      	lsls	r1, r2, #21
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006894:	ee67 6aa6 	vmul.f32	s13, s15, s13
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 8006898:	ed8d 8a0d 	vstr	s16, [sp, #52]	@ 0x34
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 800689c:	ee75 8ae6 	vsub.f32	s17, s11, s13
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 80068a0:	eef0 7a48 	vmov.f32	s15, s16
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 80068a4:	edcd 8a0c 	vstr	s17, [sp, #48]	@ 0x30
 80068a8:	eeb0 7a68 	vmov.f32	s14, s17
  if (cal_status & CALSTAT_ENHANCED_RESPONSE)
 80068ac:	d57b      	bpl.n	80069a6 <sweep+0x3b2>
    float esr = 1.0f - (c_data[ETERM_ES][0] * data[0] - c_data[ETERM_ES][1] * data[1]);
 80068ae:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
 80068b2:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
 80068b6:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80068ba:	eeea 7aa9 	vfma.f32	s15, s21, s19
    if (p_sweep < SWEEP_POINTS_MAX)
 80068be:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
    float esi = 0.0f - (c_data[ETERM_ES][1] * data[0] + c_data[ETERM_ES][0] * data[1]);
 80068c2:	ee2a 7a8a 	vmul.f32	s14, s21, s20
    float esr = 1.0f - (c_data[ETERM_ES][0] * data[0] - c_data[ETERM_ES][1] * data[1]);
 80068c6:	eeeb 7a4a 	vfms.f32	s15, s22, s20
    float esi = 0.0f - (c_data[ETERM_ES][1] * data[0] + c_data[ETERM_ES][0] * data[1]);
 80068ca:	eeab 7a29 	vfma.f32	s14, s22, s19
    data[3] = esi * re + esr * im;
 80068ce:	ee76 6ae5 	vsub.f32	s13, s13, s11
    data[2] = esr * re - esi * im;
 80068d2:	ee28 6a07 	vmul.f32	s12, s16, s14
    data[3] = esi * re + esr * im;
 80068d6:	ee68 5a27 	vmul.f32	s11, s16, s15
    data[2] = esr * re - esi * im;
 80068da:	eea8 6aa7 	vfma.f32	s12, s17, s15
    data[3] = esi * re + esr * im;
 80068de:	eee7 5a26 	vfma.f32	s11, s14, s13
    data[2] = esr * re - esi * im;
 80068e2:	eef0 8a46 	vmov.f32	s17, s12
    data[3] = esi * re + esr * im;
 80068e6:	eeb0 8a65 	vmov.f32	s16, s11
 80068ea:	edcd 5a0d 	vstr	s11, [sp, #52]	@ 0x34
    data[2] = esr * re - esi * im;
 80068ee:	ed8d 6a0c 	vstr	s12, [sp, #48]	@ 0x30
    if (p_sweep < SWEEP_POINTS_MAX)
 80068f2:	f63f aeb2 	bhi.w	800665a <sweep+0x66>
      if (mask & SWEEP_CH0_MEASURE)
 80068f6:	9a04      	ldr	r2, [sp, #16]
 80068f8:	2a00      	cmp	r2, #0
 80068fa:	f43f af3b 	beq.w	8006774 <sweep+0x180>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 80068fe:	0779      	lsls	r1, r7, #29
 8006900:	d45f      	bmi.n	80069c2 <sweep+0x3ce>
        measured[0][p_sweep][0] = data[0];
 8006902:	f8df 922c 	ldr.w	r9, [pc, #556]	@ 8006b30 <sweep+0x53c>
 8006906:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 800690a:	eeb0 7a46 	vmov.f32	s14, s12
 800690e:	eef0 7a65 	vmov.f32	s15, s11
 8006912:	ed83 ba00 	vstr	s22, [r3]
        measured[0][p_sweep][1] = data[1];
 8006916:	edc3 aa01 	vstr	s21, [r3, #4]
      if (mask & SWEEP_CH1_MEASURE)
 800691a:	e011      	b.n	8006940 <sweep+0x34c>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 800691c:	077a      	lsls	r2, r7, #29
  float real = data[0];
 800691e:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
  float imag = data[1];
 8006922:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006926:	d44c      	bmi.n	80069c2 <sweep+0x3ce>
        measured[0][p_sweep][0] = data[0];
 8006928:	ed9d 7a0c 	vldr	s14, [sp, #48]	@ 0x30
 800692c:	eddd 7a0d 	vldr	s15, [sp, #52]	@ 0x34
 8006930:	f8df 91fc 	ldr.w	r9, [pc, #508]	@ 8006b30 <sweep+0x53c>
 8006934:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 8006938:	ed83 ba00 	vstr	s22, [r3]
        measured[0][p_sweep][1] = data[1];
 800693c:	edc3 aa01 	vstr	s21, [r3, #4]
        if (mask & SWEEP_APPLY_EDELAY_S21)
 8006940:	073a      	lsls	r2, r7, #28
  float real = data[0];
 8006942:	eef0 8a47 	vmov.f32	s17, s14
  float imag = data[1];
 8006946:	eeb0 8a67 	vmov.f32	s16, s15
        if (mask & SWEEP_APPLY_EDELAY_S21)
 800694a:	f57f af18 	bpl.w	800677e <sweep+0x18a>
          applyEDelay(electrical_delayS21 * frequency, &data[2]); // Apply e-delay
 800694e:	eddd 7a01 	vldr	s15, [sp, #4]
 8006952:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8006956:	edd5 7a28 	vldr	s15, [r5, #160]	@ 0xa0
  vna_sincosf(w, &s, &c);
 800695a:	a909      	add	r1, sp, #36	@ 0x24
 800695c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8006960:	a808      	add	r0, sp, #32
 8006962:	f00a fc47 	bl	80111f4 <vna_sincosf>
  data[0] = real * c - imag * s;
 8006966:	ed9d 7a08 	vldr	s14, [sp, #32]
 800696a:	eddd 6a09 	vldr	s13, [sp, #36]	@ 0x24
 800696e:	ee68 7a47 	vnmul.f32	s15, s16, s14
  data[1] = imag * c + real * s;
 8006972:	ee27 7a28 	vmul.f32	s14, s14, s17
  data[0] = real * c - imag * s;
 8006976:	eee6 7aa8 	vfma.f32	s15, s13, s17
        if (mask & SWEEP_APPLY_S21_OFFSET)
 800697a:	06fb      	lsls	r3, r7, #27
  data[1] = imag * c + real * s;
 800697c:	eea6 7a88 	vfma.f32	s14, s13, s16
}
 8006980:	eef0 8a67 	vmov.f32	s17, s15
  data[1] = imag * c + real * s;
 8006984:	eeb0 8a47 	vmov.f32	s16, s14
  data[0] = real * c - imag * s;
 8006988:	edcd 7a0c 	vstr	s15, [sp, #48]	@ 0x30
  data[1] = imag * c + real * s;
 800698c:	ed8d 7a0d 	vstr	s14, [sp, #52]	@ 0x34
        if (mask & SWEEP_APPLY_S21_OFFSET)
 8006990:	f57f aef8 	bpl.w	8006784 <sweep+0x190>
  data[0] *= offset;
 8006994:	ee68 8a89 	vmul.f32	s17, s17, s18
  data[1] *= offset;
 8006998:	ee28 8a09 	vmul.f32	s16, s16, s18
  data[0] *= offset;
 800699c:	edcd 8a0c 	vstr	s17, [sp, #48]	@ 0x30
  data[1] *= offset;
 80069a0:	ed8d 8a0d 	vstr	s16, [sp, #52]	@ 0x34
}
 80069a4:	e6ee      	b.n	8006784 <sweep+0x190>
    if (p_sweep < SWEEP_POINTS_MAX)
 80069a6:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 80069aa:	f63f ae56 	bhi.w	800665a <sweep+0x66>
      if (mask & SWEEP_CH0_MEASURE)
 80069ae:	9a04      	ldr	r2, [sp, #16]
 80069b0:	2a00      	cmp	r2, #0
 80069b2:	f43f aedf 	beq.w	8006774 <sweep+0x180>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 80069b6:	0778      	lsls	r0, r7, #29
    float esr = 1.0f - (c_data[ETERM_ES][0] * data[0] - c_data[ETERM_ES][1] * data[1]);
 80069b8:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
 80069bc:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
        if (mask & SWEEP_APPLY_EDELAY_S11)
 80069c0:	d5b6      	bpl.n	8006930 <sweep+0x33c>
 80069c2:	2602      	movs	r6, #2
  vna_sincosf(w, &s, &c);
 80069c4:	eddd 7a01 	vldr	s15, [sp, #4]
          applyEDelay(electrical_delayS11 * frequency, &data[0]); // Apply e-delay
 80069c8:	ed95 0a27 	vldr	s0, [r5, #156]	@ 0x9c
  vna_sincosf(w, &s, &c);
 80069cc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80069d0:	a909      	add	r1, sp, #36	@ 0x24
 80069d2:	ee27 0a80 	vmul.f32	s0, s15, s0
 80069d6:	a808      	add	r0, sp, #32
 80069d8:	f00a fc0c 	bl	80111f4 <vna_sincosf>
  data[0] = real * c - imag * s;
 80069dc:	eddd 7a08 	vldr	s15, [sp, #32]
 80069e0:	eddd 6a09 	vldr	s13, [sp, #36]	@ 0x24
        measured[0][p_sweep][0] = data[0];
 80069e4:	4a52      	ldr	r2, [pc, #328]	@ (8006b30 <sweep+0x53c>)
 80069e6:	8823      	ldrh	r3, [r4, #0]
  data[0] = real * c - imag * s;
 80069e8:	ee27 7aea 	vnmul.f32	s14, s15, s21
  data[1] = imag * c + real * s;
 80069ec:	ee6b 7a27 	vmul.f32	s15, s22, s15
  data[0] = real * c - imag * s;
 80069f0:	eeab 7a26 	vfma.f32	s14, s22, s13
        measured[0][p_sweep][0] = data[0];
 80069f4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80069f8:	4691      	mov	r9, r2
  data[1] = imag * c + real * s;
 80069fa:	eeea 7aa6 	vfma.f32	s15, s21, s13
  data[0] = real * c - imag * s;
 80069fe:	ed8d 7a0a 	vstr	s14, [sp, #40]	@ 0x28
  data[1] = imag * c + real * s;
 8006a02:	edcd 7a0b 	vstr	s15, [sp, #44]	@ 0x2c
        measured[0][p_sweep][0] = data[0];
 8006a06:	ed83 7a00 	vstr	s14, [r3]
        measured[0][p_sweep][1] = data[1];
 8006a0a:	edc3 7a01 	vstr	s15, [r3, #4]
      if (mask & SWEEP_CH1_MEASURE)
 8006a0e:	2e00      	cmp	r6, #0
 8006a10:	f43f ae23 	beq.w	800665a <sweep+0x66>
 8006a14:	ed9d 7a0c 	vldr	s14, [sp, #48]	@ 0x30
 8006a18:	eddd 7a0d 	vldr	s15, [sp, #52]	@ 0x34
 8006a1c:	e790      	b.n	8006940 <sweep+0x34c>
        cal_interpolate(interpolation_idx, frequency, c_data);
 8006a1e:	4610      	mov	r0, r2
 8006a20:	9901      	ldr	r1, [sp, #4]
 8006a22:	ed8d aa10 	vstr	s20, [sp, #64]	@ 0x40
 8006a26:	aa0e      	add	r2, sp, #56	@ 0x38
 8006a28:	edcd 9a11 	vstr	s19, [sp, #68]	@ 0x44
 8006a2c:	f7fe fd9e 	bl	800556c <cal_interpolate>
 8006a30:	ed9d aa10 	vldr	s20, [sp, #64]	@ 0x40
 8006a34:	eddd 9a11 	vldr	s19, [sp, #68]	@ 0x44
      DSP_WAIT;
 8006a38:	8833      	ldrh	r3, [r6, #0]
 8006a3a:	b29b      	uxth	r3, r3
 8006a3c:	2b00      	cmp	r3, #0
 8006a3e:	f43f af0d 	beq.w	800685c <sweep+0x268>
 8006a42:	f04f 0920 	mov.w	r9, #32
 8006a46:	e67c      	b.n	8006742 <sweep+0x14e>
        cal_interpolate(interpolation_idx, frequency, c_data);
 8006a48:	4610      	mov	r0, r2
 8006a4a:	9901      	ldr	r1, [sp, #4]
 8006a4c:	9305      	str	r3, [sp, #20]
 8006a4e:	aa0e      	add	r2, sp, #56	@ 0x38
 8006a50:	ed8d aa10 	vstr	s20, [sp, #64]	@ 0x40
 8006a54:	edcd 9a11 	vstr	s19, [sp, #68]	@ 0x44
 8006a58:	f7fe fd88 	bl	800556c <cal_interpolate>
      DSP_WAIT;
 8006a5c:	8832      	ldrh	r2, [r6, #0]
        cal_interpolate(interpolation_idx, frequency, c_data);
 8006a5e:	ed9d aa10 	vldr	s20, [sp, #64]	@ 0x40
 8006a62:	eddd 9a11 	vldr	s19, [sp, #68]	@ 0x44
      DSP_WAIT;
 8006a66:	9b05      	ldr	r3, [sp, #20]
 8006a68:	b292      	uxth	r2, r2
 8006a6a:	2a00      	cmp	r2, #0
 8006a6c:	f47f aebe 	bne.w	80067ec <sweep+0x1f8>
      (*sample_func)(&data[0]);           // calculate reflection coefficient
 8006a70:	a80a      	add	r0, sp, #40	@ 0x28
 8006a72:	9305      	str	r3, [sp, #20]
 8006a74:	f002 fcc0 	bl	80093f8 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8006a78:	9b05      	ldr	r3, [sp, #20]
  float s11mr = data[0] - c_data[ETERM_ED][0];
 8006a7a:	ed9d 6a0a 	vldr	s12, [sp, #40]	@ 0x28
 8006a7e:	ed9d 7a0e 	vldr	s14, [sp, #56]	@ 0x38
  float eri = c_data[ETERM_ER][1] + s11mr * c_data[ETERM_ES][1] + s11mi * c_data[ETERM_ES][0];
 8006a82:	eddd 7a13 	vldr	s15, [sp, #76]	@ 0x4c
  float s11mi = data[1] - c_data[ETERM_ED][1];
 8006a86:	eddd 6a0b 	vldr	s13, [sp, #44]	@ 0x2c
 8006a8a:	eddd 5a0f 	vldr	s11, [sp, #60]	@ 0x3c
  float s11mr = data[0] - c_data[ETERM_ED][0];
 8006a8e:	ee36 6a47 	vsub.f32	s12, s12, s14
  float err = c_data[ETERM_ER][0] + s11mr * c_data[ETERM_ES][0] - s11mi * c_data[ETERM_ES][1];
 8006a92:	ed9d 7a12 	vldr	s14, [sp, #72]	@ 0x48
  float eri = c_data[ETERM_ER][1] + s11mr * c_data[ETERM_ES][1] + s11mi * c_data[ETERM_ES][0];
 8006a96:	eee6 7a29 	vfma.f32	s15, s12, s19
  float s11mi = data[1] - c_data[ETERM_ED][1];
 8006a9a:	ee76 6ae5 	vsub.f32	s13, s13, s11
  float err = c_data[ETERM_ER][0] + s11mr * c_data[ETERM_ES][0] - s11mi * c_data[ETERM_ES][1];
 8006a9e:	eea6 7a0a 	vfma.f32	s14, s12, s20
  float eri = c_data[ETERM_ER][1] + s11mr * c_data[ETERM_ES][1] + s11mi * c_data[ETERM_ES][0];
 8006aa2:	eee6 7a8a 	vfma.f32	s15, s13, s20
  float err = c_data[ETERM_ER][0] + s11mr * c_data[ETERM_ES][0] - s11mi * c_data[ETERM_ES][1];
 8006aa6:	eea6 7ae9 	vfms.f32	s14, s13, s19
  data[0] = (s11mr * err + s11mi * eri) / sq;
 8006aaa:	ee26 5aa7 	vmul.f32	s10, s13, s15
  float sq = err * err + eri * eri;
 8006aae:	ee67 5aa7 	vmul.f32	s11, s15, s15
  data[1] = (s11mi * err - s11mr * eri) / sq;
 8006ab2:	ee67 7ac6 	vnmul.f32	s15, s15, s12
  float sq = err * err + eri * eri;
 8006ab6:	eee7 5a07 	vfma.f32	s11, s14, s14
  data[0] = (s11mr * err + s11mi * eri) / sq;
 8006aba:	eea6 5a07 	vfma.f32	s10, s12, s14
  data[1] = (s11mi * err - s11mr * eri) / sq;
 8006abe:	eee6 7a87 	vfma.f32	s15, s13, s14
  data[0] = (s11mr * err + s11mi * eri) / sq;
 8006ac2:	eec5 6a25 	vdiv.f32	s13, s10, s11
  data[1] = (s11mi * err - s11mr * eri) / sq;
 8006ac6:	ee87 7aa5 	vdiv.f32	s14, s15, s11
  data[0] = (s11mr * err + s11mi * eri) / sq;
 8006aca:	edcd 6a0a 	vstr	s13, [sp, #40]	@ 0x28
  data[1] = (s11mi * err - s11mr * eri) / sq;
 8006ace:	ed8d 7a0b 	vstr	s14, [sp, #44]	@ 0x2c
    if (mask & SWEEP_CH1_MEASURE)
 8006ad2:	2b00      	cmp	r3, #0
 8006ad4:	f43f ae9b 	beq.w	800680e <sweep+0x21a>
      tlv320aic3204_select(1);
 8006ad8:	2001      	movs	r0, #1
 8006ada:	f002 fbdd 	bl	8009298 <tlv320aic3204_select>
      DSP_START(delay + st_delay);
 8006ade:	4b15      	ldr	r3, [pc, #84]	@ (8006b34 <sweep+0x540>)
 8006ae0:	8b5a      	ldrh	r2, [r3, #26]
 8006ae2:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8006ae6:	3202      	adds	r2, #2
 8006ae8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006aea:	b292      	uxth	r2, r2
 8006aec:	8032      	strh	r2, [r6, #0]
 8006aee:	330a      	adds	r3, #10
 8006af0:	4a11      	ldr	r2, [pc, #68]	@ (8006b38 <sweep+0x544>)
 8006af2:	444b      	add	r3, r9
 8006af4:	6013      	str	r3, [r2, #0]
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8006af6:	e79f      	b.n	8006a38 <sweep+0x444>
      (*sample_func)(&data[2]);           // Measure transmission coefficient
 8006af8:	a80c      	add	r0, sp, #48	@ 0x30
 8006afa:	f002 fc7d 	bl	80093f8 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8006afe:	e62c      	b.n	800675a <sweep+0x166>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006b00:	2600      	movs	r6, #0
 8006b02:	e75f      	b.n	80069c4 <sweep+0x3d0>
      (*sample_func)(&data[0]);           // calculate reflection coefficient
 8006b04:	a80a      	add	r0, sp, #40	@ 0x28
 8006b06:	9305      	str	r3, [sp, #20]
 8006b08:	f002 fc76 	bl	80093f8 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8006b0c:	9b05      	ldr	r3, [sp, #20]
 8006b0e:	e67b      	b.n	8006808 <sweep+0x214>
      tlv320aic3204_select(1);
 8006b10:	2001      	movs	r0, #1
 8006b12:	f002 fbc1 	bl	8009298 <tlv320aic3204_select>
      DSP_START(delay + st_delay);
 8006b16:	4b07      	ldr	r3, [pc, #28]	@ (8006b34 <sweep+0x540>)
 8006b18:	8b5a      	ldrh	r2, [r3, #26]
 8006b1a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8006b1e:	3202      	adds	r2, #2
 8006b20:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006b22:	b292      	uxth	r2, r2
 8006b24:	8032      	strh	r2, [r6, #0]
 8006b26:	330a      	adds	r3, #10
 8006b28:	4a03      	ldr	r2, [pc, #12]	@ (8006b38 <sweep+0x544>)
 8006b2a:	444b      	add	r3, r9
 8006b2c:	6013      	str	r3, [r2, #0]
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8006b2e:	e601      	b.n	8006734 <sweep+0x140>
 8006b30:	20004f54 	.word	0x20004f54
 8006b34:	20000318 	.word	0x20000318
 8006b38:	20000a9c 	.word	0x20000a9c

08006b3c <cmd_scan>:
{
 8006b3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t points = sweep_points;
 8006b40:	4f7b      	ldr	r7, [pc, #492]	@ (8006d30 <cmd_scan+0x1f4>)
{
 8006b42:	b082      	sub	sp, #8
  if (argc < 2 || argc > 4)
 8006b44:	1e83      	subs	r3, r0, #2
  uint16_t points = sweep_points;
 8006b46:	8b7a      	ldrh	r2, [r7, #26]
 8006b48:	f8ad 2000 	strh.w	r2, [sp]
  if (argc < 2 || argc > 4)
 8006b4c:	2b02      	cmp	r3, #2
 8006b4e:	d902      	bls.n	8006b56 <cmd_scan+0x1a>
}
 8006b50:	b002      	add	sp, #8
 8006b52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  start = my_atoui(argv[0]);
 8006b56:	4604      	mov	r4, r0
 8006b58:	6808      	ldr	r0, [r1, #0]
 8006b5a:	460d      	mov	r5, r1
 8006b5c:	f001 ff2a 	bl	80089b4 <my_atoui>
 8006b60:	4680      	mov	r8, r0
  stop = my_atoui(argv[1]);
 8006b62:	6868      	ldr	r0, [r5, #4]
 8006b64:	f001 ff26 	bl	80089b4 <my_atoui>
 8006b68:	4606      	mov	r6, r0
  if (start == 0 || stop == 0 || start > stop)
 8006b6a:	f1b8 0f00 	cmp.w	r8, #0
 8006b6e:	d0ef      	beq.n	8006b50 <cmd_scan+0x14>
 8006b70:	2800      	cmp	r0, #0
 8006b72:	d0ed      	beq.n	8006b50 <cmd_scan+0x14>
 8006b74:	4580      	cmp	r8, r0
 8006b76:	d8eb      	bhi.n	8006b50 <cmd_scan+0x14>
  if (argc >= 3)
 8006b78:	2c02      	cmp	r4, #2
 8006b7a:	d17c      	bne.n	8006c76 <cmd_scan+0x13a>
  sweep_mode &= ~(SWEEP_BINARY);
 8006b7c:	4c6d      	ldr	r4, [pc, #436]	@ (8006d34 <cmd_scan+0x1f8>)
  sweep_points = points;
 8006b7e:	f8bd 5000 	ldrh.w	r5, [sp]
  sweep_mode &= ~(SWEEP_BINARY);
 8006b82:	7822      	ldrb	r2, [r4, #0]
  if (needInterpolate(start, stop, sweep_points))
 8006b84:	8b78      	ldrh	r0, [r7, #26]
  uint16_t mask = 0;
 8006b86:	2300      	movs	r3, #0
 8006b88:	f8ad 3002 	strh.w	r3, [sp, #2]
  _f_points = (points - 1);
 8006b8c:	1e6b      	subs	r3, r5, #1
 8006b8e:	b29b      	uxth	r3, r3
  uint16_t sweep_ch = SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE;
 8006b90:	2103      	movs	r1, #3
  sweep_mode &= ~(SWEEP_BINARY);
 8006b92:	f022 0208 	bic.w	r2, r2, #8
 8006b96:	7022      	strb	r2, [r4, #0]
  if ((cal_status & CALSTAT_APPLY) && !(mask & SCAN_MASK_NO_CALIBRATION))
 8006b98:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8006b9a:	05d2      	lsls	r2, r2, #23
 8006b9c:	d505      	bpl.n	8006baa <cmd_scan+0x6e>
 8006b9e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8006ba2:	0714      	lsls	r4, r2, #28
    sweep_ch |= SWEEP_APPLY_CALIBRATION;
 8006ba4:	bf58      	it	pl
 8006ba6:	f041 0120 	orrpl.w	r1, r1, #32
  if (electrical_delayS11 && !(mask & SCAN_MASK_NO_EDELAY))
 8006baa:	edd7 7a27 	vldr	s15, [r7, #156]	@ 0x9c
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 8006bae:	ed97 7a28 	vldr	s14, [r7, #160]	@ 0xa0
  if (electrical_delayS11 && !(mask & SCAN_MASK_NO_EDELAY))
 8006bb2:	eef5 7a40 	vcmp.f32	s15, #0.0
 8006bb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006bba:	d073      	beq.n	8006ca4 <cmd_scan+0x168>
 8006bbc:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8006bc0:	06d2      	lsls	r2, r2, #27
 8006bc2:	d579      	bpl.n	8006cb8 <cmd_scan+0x17c>
  if (s21_offset && !(mask & SCAN_MASK_NO_S21OFFS))
 8006bc4:	edd7 7a2a 	vldr	s15, [r7, #168]	@ 0xa8
 8006bc8:	eef5 7a40 	vcmp.f32	s15, #0.0
 8006bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006bd0:	d005      	beq.n	8006bde <cmd_scan+0xa2>
 8006bd2:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8006bd6:	0692      	lsls	r2, r2, #26
    sweep_ch |= SWEEP_APPLY_S21_OFFSET;
 8006bd8:	bf58      	it	pl
 8006bda:	f041 0110 	orrpl.w	r1, r1, #16
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8006bde:	68fa      	ldr	r2, [r7, #12]
 8006be0:	4590      	cmp	r8, r2
 8006be2:	f000 8081 	beq.w	8006ce8 <cmd_scan+0x1ac>
    sweep_ch |= SWEEP_USE_INTERPOLATION;
 8006be6:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
  _f_start = start;
 8006bea:	4a53      	ldr	r2, [pc, #332]	@ (8006d38 <cmd_scan+0x1fc>)
  _f_delta = span / _f_points;
 8006bec:	4c53      	ldr	r4, [pc, #332]	@ (8006d3c <cmd_scan+0x200>)
  _f_start = start;
 8006bee:	f8c2 8000 	str.w	r8, [r2]
  _f_points = (points - 1);
 8006bf2:	4a53      	ldr	r2, [pc, #332]	@ (8006d40 <cmd_scan+0x204>)
  _f_error = span % _f_points;
 8006bf4:	4853      	ldr	r0, [pc, #332]	@ (8006d44 <cmd_scan+0x208>)
  _f_points = (points - 1);
 8006bf6:	8013      	strh	r3, [r2, #0]
  freq_t span = stop - start;
 8006bf8:	eba6 0608 	sub.w	r6, r6, r8
  _f_delta = span / _f_points;
 8006bfc:	fbb6 f2f3 	udiv	r2, r6, r3
 8006c00:	6022      	str	r2, [r4, #0]
  _f_error = span % _f_points;
 8006c02:	fb03 6612 	mls	r6, r3, r2, r6
  if (sweep_ch & (SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE))
 8006c06:	078c      	lsls	r4, r1, #30
  sweep_points = points;
 8006c08:	837d      	strh	r5, [r7, #26]
  _f_error = span % _f_points;
 8006c0a:	6006      	str	r6, [r0, #0]
  if (sweep_ch & (SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE))
 8006c0c:	d175      	bne.n	8006cfa <cmd_scan+0x1be>
  pause_sweep();
 8006c0e:	f7ff fb7d 	bl	800630c <pause_sweep>
  if (mask)
 8006c12:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006c16:	2b00      	cmp	r3, #0
 8006c18:	d09a      	beq.n	8006b50 <cmd_scan+0x14>
    if (mask & SCAN_MASK_BINARY)
 8006c1a:	0618      	lsls	r0, r3, #24
 8006c1c:	d598      	bpl.n	8006b50 <cmd_scan+0x14>
      shell_write(&mask, sizeof(uint16_t));
 8006c1e:	2102      	movs	r1, #2
 8006c20:	eb0d 0001 	add.w	r0, sp, r1
 8006c24:	f7fe fc20 	bl	8005468 <shell_write>
      shell_write(&points, sizeof(uint16_t));
 8006c28:	2102      	movs	r1, #2
 8006c2a:	4668      	mov	r0, sp
 8006c2c:	f7fe fc1c 	bl	8005468 <shell_write>
      for (int i = 0; i < points; i++)
 8006c30:	f8bd 3000 	ldrh.w	r3, [sp]
 8006c34:	2b00      	cmp	r3, #0
 8006c36:	d08b      	beq.n	8006b50 <cmd_scan+0x14>
 8006c38:	4d43      	ldr	r5, [pc, #268]	@ (8006d48 <cmd_scan+0x20c>)
 8006c3a:	2400      	movs	r4, #0
 8006c3c:	e00b      	b.n	8006c56 <cmd_scan+0x11a>
        if (mask & SCAN_MASK_OUT_DATA0)
 8006c3e:	079a      	lsls	r2, r3, #30
 8006c40:	d44b      	bmi.n	8006cda <cmd_scan+0x19e>
        if (mask & SCAN_MASK_OUT_DATA1)
 8006c42:	075b      	lsls	r3, r3, #29
 8006c44:	d443      	bmi.n	8006cce <cmd_scan+0x192>
      for (int i = 0; i < points; i++)
 8006c46:	f8bd 3000 	ldrh.w	r3, [sp]
 8006c4a:	3401      	adds	r4, #1
 8006c4c:	42a3      	cmp	r3, r4
 8006c4e:	f105 0508 	add.w	r5, r5, #8
 8006c52:	f77f af7d 	ble.w	8006b50 <cmd_scan+0x14>
        if (mask & SCAN_MASK_OUT_FREQ)
 8006c56:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006c5a:	07d9      	lsls	r1, r3, #31
 8006c5c:	d5ef      	bpl.n	8006c3e <cmd_scan+0x102>
          freq_t f = getFrequency(i);
 8006c5e:	b2a0      	uxth	r0, r4
 8006c60:	f7ff fcac 	bl	80065bc <getFrequency>
          shell_write(&f, sizeof(freq_t));
 8006c64:	2104      	movs	r1, #4
          freq_t f = getFrequency(i);
 8006c66:	9001      	str	r0, [sp, #4]
          shell_write(&f, sizeof(freq_t));
 8006c68:	eb0d 0001 	add.w	r0, sp, r1
 8006c6c:	f7fe fbfc 	bl	8005468 <shell_write>
        if (mask & SCAN_MASK_OUT_DATA0)
 8006c70:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006c74:	e7e3      	b.n	8006c3e <cmd_scan+0x102>
    points = my_atoui(argv[2]);
 8006c76:	68a8      	ldr	r0, [r5, #8]
 8006c78:	f001 fe9c 	bl	80089b4 <my_atoui>
 8006c7c:	b280      	uxth	r0, r0
    if (points == 0 || points > SWEEP_POINTS_MAX)
 8006c7e:	1e43      	subs	r3, r0, #1
 8006c80:	b29b      	uxth	r3, r3
 8006c82:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
    points = my_atoui(argv[2]);
 8006c86:	f8ad 0000 	strh.w	r0, [sp]
    if (points == 0 || points > SWEEP_POINTS_MAX)
 8006c8a:	f63f af61 	bhi.w	8006b50 <cmd_scan+0x14>
  uint16_t mask = 0;
 8006c8e:	2200      	movs	r2, #0
  if (argc == 4)
 8006c90:	2c04      	cmp	r4, #4
    sweep_points = points;
 8006c92:	8378      	strh	r0, [r7, #26]
  uint16_t mask = 0;
 8006c94:	f8ad 2002 	strh.w	r2, [sp, #2]
  if (argc == 4)
 8006c98:	d033      	beq.n	8006d02 <cmd_scan+0x1c6>
  sweep_mode &= ~(SWEEP_BINARY);
 8006c9a:	4c26      	ldr	r4, [pc, #152]	@ (8006d34 <cmd_scan+0x1f8>)
 8006c9c:	4605      	mov	r5, r0
 8006c9e:	7822      	ldrb	r2, [r4, #0]
  uint16_t sweep_ch = SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE;
 8006ca0:	2103      	movs	r1, #3
 8006ca2:	e776      	b.n	8006b92 <cmd_scan+0x56>
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 8006ca4:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8006ca8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006cac:	d08a      	beq.n	8006bc4 <cmd_scan+0x88>
 8006cae:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8006cb2:	06d4      	lsls	r4, r2, #27
 8006cb4:	d486      	bmi.n	8006bc4 <cmd_scan+0x88>
 8006cb6:	e007      	b.n	8006cc8 <cmd_scan+0x18c>
 8006cb8:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8006cbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    sweep_ch |= SWEEP_APPLY_EDELAY_S11;
 8006cc0:	f041 0104 	orr.w	r1, r1, #4
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 8006cc4:	f43f af7e 	beq.w	8006bc4 <cmd_scan+0x88>
    sweep_ch |= SWEEP_APPLY_EDELAY_S21;
 8006cc8:	f041 0108 	orr.w	r1, r1, #8
 8006ccc:	e77a      	b.n	8006bc4 <cmd_scan+0x88>
          shell_write(&measured[1][i][0], sizeof(float) * 2); // 4+4 bytes .. S21 real/imag
 8006cce:	2108      	movs	r1, #8
 8006cd0:	f605 4088 	addw	r0, r5, #3208	@ 0xc88
 8006cd4:	f7fe fbc8 	bl	8005468 <shell_write>
 8006cd8:	e7b5      	b.n	8006c46 <cmd_scan+0x10a>
          shell_write(&measured[0][i][0], sizeof(float) * 2); // 4+4 bytes .. S11 real/imag
 8006cda:	2108      	movs	r1, #8
 8006cdc:	4628      	mov	r0, r5
 8006cde:	f7fe fbc3 	bl	8005468 <shell_write>
        if (mask & SCAN_MASK_OUT_DATA1)
 8006ce2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006ce6:	e7ac      	b.n	8006c42 <cmd_scan+0x106>
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8006ce8:	693a      	ldr	r2, [r7, #16]
 8006cea:	4296      	cmp	r6, r2
 8006cec:	f47f af7b 	bne.w	8006be6 <cmd_scan+0xaa>
 8006cf0:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 8006cf2:	4282      	cmp	r2, r0
 8006cf4:	f47f af77 	bne.w	8006be6 <cmd_scan+0xaa>
 8006cf8:	e777      	b.n	8006bea <cmd_scan+0xae>
    sweep(false, sweep_ch);
 8006cfa:	2000      	movs	r0, #0
 8006cfc:	f7ff fc7a 	bl	80065f4 <sweep>
 8006d00:	e785      	b.n	8006c0e <cmd_scan+0xd2>
    mask = my_atoui(argv[3]);
 8006d02:	68e8      	ldr	r0, [r5, #12]
    if (sweep_mode & SWEEP_BINARY)
 8006d04:	4c0b      	ldr	r4, [pc, #44]	@ (8006d34 <cmd_scan+0x1f8>)
    mask = my_atoui(argv[3]);
 8006d06:	f001 fe55 	bl	80089b4 <my_atoui>
    if (sweep_mode & SWEEP_BINARY)
 8006d0a:	7822      	ldrb	r2, [r4, #0]
  sweep_points = points;
 8006d0c:	f8bd 5000 	ldrh.w	r5, [sp]
    mask = my_atoui(argv[3]);
 8006d10:	b281      	uxth	r1, r0
    if (sweep_mode & SWEEP_BINARY)
 8006d12:	0710      	lsls	r0, r2, #28
    mask = my_atoui(argv[3]);
 8006d14:	f8ad 1002 	strh.w	r1, [sp, #2]
  _f_points = (points - 1);
 8006d18:	f105 33ff 	add.w	r3, r5, #4294967295
      mask |= SCAN_MASK_BINARY;
 8006d1c:	bf44      	itt	mi
 8006d1e:	f041 0180 	orrmi.w	r1, r1, #128	@ 0x80
 8006d22:	f8ad 1002 	strhmi.w	r1, [sp, #2]
  if (needInterpolate(start, stop, sweep_points))
 8006d26:	8b78      	ldrh	r0, [r7, #26]
    sweep_ch = (mask >> 1) & 3;
 8006d28:	f3c1 0141 	ubfx	r1, r1, #1, #2
  _f_points = (points - 1);
 8006d2c:	b29b      	uxth	r3, r3
 8006d2e:	e730      	b.n	8006b92 <cmd_scan+0x56>
 8006d30:	20000aa8 	.word	0x20000aa8
 8006d34:	200003c4 	.word	0x200003c4
 8006d38:	20000914 	.word	0x20000914
 8006d3c:	20000910 	.word	0x20000910
 8006d40:	20000908 	.word	0x20000908
 8006d44:	2000090c 	.word	0x2000090c
 8006d48:	20004f54 	.word	0x20004f54

08006d4c <cmd_scan_bin>:
{
 8006d4c:	b510      	push	{r4, lr}
  sweep_mode |= SWEEP_BINARY;
 8006d4e:	4c06      	ldr	r4, [pc, #24]	@ (8006d68 <cmd_scan_bin+0x1c>)
 8006d50:	7823      	ldrb	r3, [r4, #0]
 8006d52:	f043 0308 	orr.w	r3, r3, #8
 8006d56:	7023      	strb	r3, [r4, #0]
  cmd_scan(argc, argv);
 8006d58:	f7ff fef0 	bl	8006b3c <cmd_scan>
  sweep_mode &= ~(SWEEP_BINARY);
 8006d5c:	7823      	ldrb	r3, [r4, #0]
 8006d5e:	f023 0308 	bic.w	r3, r3, #8
 8006d62:	7023      	strb	r3, [r4, #0]
}
 8006d64:	bd10      	pop	{r4, pc}
 8006d66:	bf00      	nop
 8006d68:	200003c4 	.word	0x200003c4

08006d6c <mla_update_bandwidth_swr2>:
  if (!mla_resonance_locked)
 8006d6c:	4b7f      	ldr	r3, [pc, #508]	@ (8006f6c <mla_update_bandwidth_swr2+0x200>)
{
 8006d6e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (!mla_resonance_locked)
 8006d72:	781b      	ldrb	r3, [r3, #0]
  mla_bw_swr2 = 0;
 8006d74:	4c7e      	ldr	r4, [pc, #504]	@ (8006f70 <mla_update_bandwidth_swr2+0x204>)
 8006d76:	2200      	movs	r2, #0
 8006d78:	6022      	str	r2, [r4, #0]
  if (!mla_resonance_locked)
 8006d7a:	2b00      	cmp	r3, #0
 8006d7c:	f000 80e7 	beq.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
  if (sweep_points < 3)
 8006d80:	4b7c      	ldr	r3, [pc, #496]	@ (8006f74 <mla_update_bandwidth_swr2+0x208>)
 8006d82:	8b5f      	ldrh	r7, [r3, #26]
 8006d84:	2f02      	cmp	r7, #2
 8006d86:	f240 80e2 	bls.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
  uint16_t center = (uint16_t)mla_res_idx;
 8006d8a:	4b7b      	ldr	r3, [pc, #492]	@ (8006f78 <mla_update_bandwidth_swr2+0x20c>)
 8006d8c:	f9b3 5000 	ldrsh.w	r5, [r3]
 8006d90:	b2a8      	uxth	r0, r5
  if (center >= sweep_points)
 8006d92:	4287      	cmp	r7, r0
 8006d94:	f240 80db 	bls.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
  float swr_center = getSWRfromIndex(center);
 8006d98:	f7fe fb34 	bl	8005404 <getSWRfromIndex>
  if (swr_center <= 0.0f || swr_center > 50.0f)
 8006d9c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8006da0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float swr_center = getSWRfromIndex(center);
 8006da4:	eeb0 6a40 	vmov.f32	s12, s0
  if (swr_center <= 0.0f || swr_center > 50.0f)
 8006da8:	f240 80d1 	bls.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
 8006dac:	eddf 7a73 	vldr	s15, [pc, #460]	@ 8006f7c <mla_update_bandwidth_swr2+0x210>
 8006db0:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8006db4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006db8:	f300 80c9 	bgt.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
  while (left_idx >= 0)
 8006dbc:	4295      	cmp	r5, r2
  while (right_idx < (int16_t)sweep_points)
 8006dbe:	b23f      	sxth	r7, r7
  while (left_idx >= 0)
 8006dc0:	f2c0 80cd 	blt.w	8006f5e <mla_update_bandwidth_swr2+0x1f2>
  int16_t left_idx = (int16_t)center;
 8006dc4:	462e      	mov	r6, r5
  int16_t last_good_left = -1;
 8006dc6:	f04f 33ff 	mov.w	r3, #4294967295
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006dca:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 8006dce:	e000      	b.n	8006dd2 <mla_update_bandwidth_swr2+0x66>
 8006dd0:	4616      	mov	r6, r2
 8006dd2:	eeb4 0ae5 	vcmpe.f32	s0, s11
 8006dd6:	1e70      	subs	r0, r6, #1
 8006dd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      left_idx--;
 8006ddc:	b202      	sxth	r2, r0
  while (left_idx >= 0)
 8006dde:	b280      	uxth	r0, r0
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006de0:	f200 80b9 	bhi.w	8006f56 <mla_update_bandwidth_swr2+0x1ea>
  while (left_idx >= 0)
 8006de4:	1c51      	adds	r1, r2, #1
 8006de6:	f000 80b8 	beq.w	8006f5a <mla_update_bandwidth_swr2+0x1ee>
    float swr = getSWRfromIndex((uint16_t)left_idx);
 8006dea:	f7fe fb0b 	bl	8005404 <getSWRfromIndex>
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006dee:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8006df2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006df6:	4633      	mov	r3, r6
 8006df8:	dcea      	bgt.n	8006dd0 <mla_update_bandwidth_swr2+0x64>
  while (right_idx < (int16_t)sweep_points)
 8006dfa:	42bd      	cmp	r5, r7
 8006dfc:	f280 80a7 	bge.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006e00:	f04f 33ff 	mov.w	r3, #4294967295
 8006e04:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 8006e08:	e000      	b.n	8006e0c <mla_update_bandwidth_swr2+0xa0>
 8006e0a:	4615      	mov	r5, r2
 8006e0c:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8006e10:	1c68      	adds	r0, r5, #1
 8006e12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      right_idx++;
 8006e16:	b202      	sxth	r2, r0
  while (right_idx < (int16_t)sweep_points)
 8006e18:	b280      	uxth	r0, r0
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006e1a:	f200 809a 	bhi.w	8006f52 <mla_update_bandwidth_swr2+0x1e6>
  while (right_idx < (int16_t)sweep_points)
 8006e1e:	42ba      	cmp	r2, r7
 8006e20:	da09      	bge.n	8006e36 <mla_update_bandwidth_swr2+0xca>
    float swr = getSWRfromIndex((uint16_t)right_idx);
 8006e22:	f7fe faef 	bl	8005404 <getSWRfromIndex>
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006e26:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8006e2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float swr = getSWRfromIndex((uint16_t)right_idx);
 8006e2e:	eeb0 6a40 	vmov.f32	s12, s0
    if (swr > 0.0f && swr <= swr_bw_limit)
 8006e32:	462b      	mov	r3, r5
 8006e34:	dce9      	bgt.n	8006e0a <mla_update_bandwidth_swr2+0x9e>
  if (last_good_left < 0 || last_good_right < 0 || last_good_right <= last_good_left)
 8006e36:	1c73      	adds	r3, r6, #1
 8006e38:	f000 8089 	beq.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
 8006e3c:	2d00      	cmp	r5, #0
 8006e3e:	f2c0 8086 	blt.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
 8006e42:	42b5      	cmp	r5, r6
 8006e44:	f340 8083 	ble.w	8006f4e <mla_update_bandwidth_swr2+0x1e2>
  float f_low_f = (float)getFrequency((uint16_t)last_good_left);
 8006e48:	fa1f f886 	uxth.w	r8, r6
 8006e4c:	4640      	mov	r0, r8
 8006e4e:	f7ff fbb5 	bl	80065bc <getFrequency>
 8006e52:	ee05 0a90 	vmov	s11, r0
 8006e56:	eef8 5a65 	vcvt.f32.u32	s11, s11
  if (last_good_left > 0)
 8006e5a:	b376      	cbz	r6, 8006eba <mla_update_bandwidth_swr2+0x14e>
    int16_t bad_i = last_good_left - 1;
 8006e5c:	f108 32ff 	add.w	r2, r8, #4294967295
 8006e60:	b292      	uxth	r2, r2
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 8006e62:	4610      	mov	r0, r2
 8006e64:	f7fe face 	bl	8005404 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8006e68:	eeb0 5a00 	vmov.f32	s10, #0	@ 0x40000000  2.0
 8006e6c:	eeb4 0ac5 	vcmpe.f32	s0, s10
 8006e70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 8006e74:	eeb0 6a40 	vmov.f32	s12, s0
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8006e78:	dd1f      	ble.n	8006eba <mla_update_bandwidth_swr2+0x14e>
    float swr_good = getSWRfromIndex((uint16_t)last_good_left);
 8006e7a:	4640      	mov	r0, r8
 8006e7c:	f7fe fac2 	bl	8005404 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8006e80:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8006e84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e88:	dd17      	ble.n	8006eba <mla_update_bandwidth_swr2+0x14e>
 8006e8a:	eeb4 0ac5 	vcmpe.f32	s0, s10
 8006e8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e92:	d812      	bhi.n	8006eba <mla_update_bandwidth_swr2+0x14e>
      float t = (swr_bw_limit - swr_bad) / (swr_good - swr_bad); // 0..1
 8006e94:	ee35 5a46 	vsub.f32	s10, s10, s12
 8006e98:	ee30 0a46 	vsub.f32	s0, s0, s12
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 8006e9c:	4610      	mov	r0, r2
      float t = (swr_bw_limit - swr_bad) / (swr_good - swr_bad); // 0..1
 8006e9e:	ee85 7a00 	vdiv.f32	s14, s10, s0
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 8006ea2:	f7ff fb8b 	bl	80065bc <getFrequency>
 8006ea6:	ee07 0a90 	vmov	s15, r0
 8006eaa:	eef8 7a67 	vcvt.f32.u32	s15, s15
      f_low_f = f_bad + t * (f_good - f_bad);
 8006eae:	ee75 6ae7 	vsub.f32	s13, s11, s15
 8006eb2:	eee6 7a87 	vfma.f32	s15, s13, s14
 8006eb6:	eef0 5a67 	vmov.f32	s11, s15
  float f_high_f = (float)getFrequency((uint16_t)last_good_right);
 8006eba:	b2ae      	uxth	r6, r5
 8006ebc:	4630      	mov	r0, r6
 8006ebe:	f7ff fb7d 	bl	80065bc <getFrequency>
  if (last_good_right < (int16_t)sweep_points - 1)
 8006ec2:	3f01      	subs	r7, #1
  float f_high_f = (float)getFrequency((uint16_t)last_good_right);
 8006ec4:	ee06 0a10 	vmov	s12, r0
  if (last_good_right < (int16_t)sweep_points - 1)
 8006ec8:	b23f      	sxth	r7, r7
 8006eca:	42bd      	cmp	r5, r7
  float f_high_f = (float)getFrequency((uint16_t)last_good_right);
 8006ecc:	eeb8 6a46 	vcvt.f32.u32	s12, s12
  if (last_good_right < (int16_t)sweep_points - 1)
 8006ed0:	da2b      	bge.n	8006f2a <mla_update_bandwidth_swr2+0x1be>
    int16_t bad_i = last_good_right + 1;
 8006ed2:	1c72      	adds	r2, r6, #1
 8006ed4:	b292      	uxth	r2, r2
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 8006ed6:	4610      	mov	r0, r2
 8006ed8:	f7fe fa94 	bl	8005404 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8006edc:	eef0 4a00 	vmov.f32	s9, #0	@ 0x40000000  2.0
 8006ee0:	eeb4 0ae4 	vcmpe.f32	s0, s9
 8006ee4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 8006ee8:	eeb0 5a40 	vmov.f32	s10, s0
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8006eec:	dd1d      	ble.n	8006f2a <mla_update_bandwidth_swr2+0x1be>
    float swr_good = getSWRfromIndex((uint16_t)last_good_right);
 8006eee:	4630      	mov	r0, r6
 8006ef0:	f7fe fa88 	bl	8005404 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8006ef4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8006ef8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006efc:	dd15      	ble.n	8006f2a <mla_update_bandwidth_swr2+0x1be>
 8006efe:	eeb4 0ae4 	vcmpe.f32	s0, s9
 8006f02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006f06:	d810      	bhi.n	8006f2a <mla_update_bandwidth_swr2+0x1be>
      float t = (swr_bw_limit - swr_good) / (swr_bad - swr_good); // 0..1
 8006f08:	ee74 4ac0 	vsub.f32	s9, s9, s0
 8006f0c:	ee35 5a40 	vsub.f32	s10, s10, s0
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 8006f10:	4610      	mov	r0, r2
      float t = (swr_bw_limit - swr_good) / (swr_bad - swr_good); // 0..1
 8006f12:	ee84 7a85 	vdiv.f32	s14, s9, s10
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 8006f16:	f7ff fb51 	bl	80065bc <getFrequency>
 8006f1a:	ee07 0a90 	vmov	s15, r0
 8006f1e:	eef8 7a67 	vcvt.f32.u32	s15, s15
      f_high_f = f_good + t * (f_bad - f_good);
 8006f22:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8006f26:	eea7 6a87 	vfma.f32	s12, s15, s14
  mla_bw_low = (freq_t)(f_low_f + 0.5f);
 8006f2a:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8006f2e:	ee75 5aa7 	vadd.f32	s11, s11, s15
  mla_bw_high = (freq_t)(f_high_f + 0.5f);
 8006f32:	ee36 6a27 	vadd.f32	s12, s12, s15
  mla_bw_low = (freq_t)(f_low_f + 0.5f);
 8006f36:	eefc 7ae5 	vcvt.u32.f32	s15, s11
 8006f3a:	ee17 2a90 	vmov	r2, s15
  mla_bw_high = (freq_t)(f_high_f + 0.5f);
 8006f3e:	eefc 7ac6 	vcvt.u32.f32	s15, s12
 8006f42:	ee17 3a90 	vmov	r3, s15
  if (mla_bw_high <= mla_bw_low)
 8006f46:	429a      	cmp	r2, r3
  mla_bw_swr2 = mla_bw_high - mla_bw_low;
 8006f48:	bf3c      	itt	cc
 8006f4a:	1a9b      	subcc	r3, r3, r2
 8006f4c:	6023      	strcc	r3, [r4, #0]
}
 8006f4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006f52:	461d      	mov	r5, r3
 8006f54:	e76f      	b.n	8006e36 <mla_update_bandwidth_swr2+0xca>
 8006f56:	461e      	mov	r6, r3
 8006f58:	e74f      	b.n	8006dfa <mla_update_bandwidth_swr2+0x8e>
 8006f5a:	2600      	movs	r6, #0
 8006f5c:	e74d      	b.n	8006dfa <mla_update_bandwidth_swr2+0x8e>
  while (right_idx < (int16_t)sweep_points)
 8006f5e:	42bd      	cmp	r5, r7
  int16_t last_good_left = -1;
 8006f60:	bfb8      	it	lt
 8006f62:	f04f 36ff 	movlt.w	r6, #4294967295
  while (right_idx < (int16_t)sweep_points)
 8006f66:	f6ff af4b 	blt.w	8006e00 <mla_update_bandwidth_swr2+0x94>
 8006f6a:	e7f0      	b.n	8006f4e <mla_update_bandwidth_swr2+0x1e2>
 8006f6c:	20006875 	.word	0x20006875
 8006f70:	20006868 	.word	0x20006868
 8006f74:	20000aa8 	.word	0x20000aa8
 8006f78:	200003d4 	.word	0x200003d4
 8006f7c:	42480000 	.word	0x42480000

08006f80 <getFrequencyStep>:
freq_t getFrequencyStep(void) { return _f_delta; }
 8006f80:	4b01      	ldr	r3, [pc, #4]	@ (8006f88 <getFrequencyStep+0x8>)
 8006f82:	6818      	ldr	r0, [r3, #0]
 8006f84:	4770      	bx	lr
 8006f86:	bf00      	nop
 8006f88:	20000910 	.word	0x20000910

08006f8c <set_marker_index>:
  if (m == MARKER_INVALID || (uint32_t)idx >= sweep_points)
 8006f8c:	1c42      	adds	r2, r0, #1
 8006f8e:	d01b      	beq.n	8006fc8 <set_marker_index+0x3c>
{
 8006f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (m == MARKER_INVALID || (uint32_t)idx >= sweep_points)
 8006f92:	4e0e      	ldr	r6, [pc, #56]	@ (8006fcc <set_marker_index+0x40>)
 8006f94:	8b73      	ldrh	r3, [r6, #26]
 8006f96:	428b      	cmp	r3, r1
 8006f98:	460d      	mov	r5, r1
 8006f9a:	d914      	bls.n	8006fc6 <set_marker_index+0x3a>
  markers[m].frequency = getFrequency(idx);
 8006f9c:	4604      	mov	r4, r0
 8006f9e:	340b      	adds	r4, #11
 8006fa0:	b28f      	uxth	r7, r1
 8006fa2:	eb06 06c4 	add.w	r6, r6, r4, lsl #3
 8006fa6:	4638      	mov	r0, r7
 8006fa8:	f7ff fb08 	bl	80065bc <getFrequency>
  if (markers[m].index == idx)
 8006fac:	8873      	ldrh	r3, [r6, #2]
  markers[m].frequency = getFrequency(idx);
 8006fae:	6070      	str	r0, [r6, #4]
  if (markers[m].index == idx)
 8006fb0:	42ab      	cmp	r3, r5
 8006fb2:	d008      	beq.n	8006fc6 <set_marker_index+0x3a>
  request_to_draw_marker(markers[m].index); // Mark old marker position for erase
 8006fb4:	4618      	mov	r0, r3
 8006fb6:	f004 f953 	bl	800b260 <request_to_draw_marker>
  markers[m].index = idx;                   // Set new position
 8006fba:	8077      	strh	r7, [r6, #2]
  request_to_redraw(REDRAW_MARKER);
 8006fbc:	2020      	movs	r0, #32
}
 8006fbe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  request_to_redraw(REDRAW_MARKER);
 8006fc2:	f004 bc15 	b.w	800b7f0 <request_to_redraw>
}
 8006fc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006fc8:	4770      	bx	lr
 8006fca:	bf00      	nop
 8006fcc:	20000aa8 	.word	0x20000aa8

08006fd0 <update_frequencies>:
{
 8006fd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

inline freq_t
get_sweep_frequency(uint16_t type)
{
  switch (type) {
    case ST_START:  return frequency0;
 8006fd4:	f8df 80e8 	ldr.w	r8, [pc, #232]	@ 80070c0 <update_frequencies+0xf0>
  _f_start = start;
 8006fd8:	4a34      	ldr	r2, [pc, #208]	@ (80070ac <update_frequencies+0xdc>)
  set_frequencies(start, stop, sweep_points);
 8006fda:	f8b8 701a 	ldrh.w	r7, [r8, #26]
  _f_delta = span / _f_points;
 8006fde:	4934      	ldr	r1, [pc, #208]	@ (80070b0 <update_frequencies+0xe0>)
    case ST_STOP:   return frequency1;
 8006fe0:	e9d8 6901 	ldrd	r6, r9, [r8, #4]
  _f_points = (points - 1);
 8006fe4:	3f01      	subs	r7, #1
  freq_t span = stop - start;
 8006fe6:	eba9 0306 	sub.w	r3, r9, r6
{
 8006fea:	ed2d 8b02 	vpush	{d8}
      float r = ((float)(f - fstart)) / (fstop - fstart);
 8006fee:	ee07 3a90 	vmov	s15, r3
  _f_start = start;
 8006ff2:	6016      	str	r6, [r2, #0]
      idx = r * (points - 1);
 8006ff4:	ee07 7a10 	vmov	s14, r7
  _f_points = (points - 1);
 8006ff8:	4a2e      	ldr	r2, [pc, #184]	@ (80070b4 <update_frequencies+0xe4>)
 8006ffa:	b2b8      	uxth	r0, r7
 8006ffc:	8010      	strh	r0, [r2, #0]
      float r = ((float)(f - fstart)) / (fstop - fstart);
 8006ffe:	eef8 7a67 	vcvt.f32.u32	s15, s15
      idx = r * (points - 1);
 8007002:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  _f_error = span % _f_points;
 8007006:	4a2c      	ldr	r2, [pc, #176]	@ (80070b8 <update_frequencies+0xe8>)
  _f_delta = span / _f_points;
 8007008:	fbb3 f4f0 	udiv	r4, r3, r0
  _f_error = span % _f_points;
 800700c:	fb00 3314 	mls	r3, r0, r4, r3
  _f_delta = span / _f_points;
 8007010:	600c      	str	r4, [r1, #0]
      idx = r * (points - 1);
 8007012:	ee87 8a27 	vdiv.f32	s16, s14, s15
  _f_error = span % _f_points;
 8007016:	6013      	str	r3, [r2, #0]
  for (m = 0; m < MARKERS_MAX; m++)
 8007018:	4645      	mov	r5, r8
 800701a:	2400      	movs	r4, #0
 800701c:	e009      	b.n	8007032 <update_frequencies+0x62>
      idx = markers[m].index; // Not need update index in no freq
 800701e:	f8b5 105a 	ldrh.w	r1, [r5, #90]	@ 0x5a
    set_marker_index(m, idx);
 8007022:	4620      	mov	r0, r4
  for (m = 0; m < MARKERS_MAX; m++)
 8007024:	3401      	adds	r4, #1
    set_marker_index(m, idx);
 8007026:	f7ff ffb1 	bl	8006f8c <set_marker_index>
  for (m = 0; m < MARKERS_MAX; m++)
 800702a:	2c08      	cmp	r4, #8
 800702c:	f105 0508 	add.w	r5, r5, #8
 8007030:	d015      	beq.n	800705e <update_frequencies+0x8e>
    freq_t f = markers[m].frequency;
 8007032:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
    if (f == 0)
 8007034:	2b00      	cmp	r3, #0
 8007036:	d0f2      	beq.n	800701e <update_frequencies+0x4e>
    else if (f <= fstart)
 8007038:	429e      	cmp	r6, r3
      idx = points - 1;
 800703a:	4639      	mov	r1, r7
    else if (f <= fstart)
 800703c:	d20d      	bcs.n	800705a <update_frequencies+0x8a>
      float r = ((float)(f - fstart)) / (fstop - fstart);
 800703e:	1b9a      	subs	r2, r3, r6
 8007040:	ee07 2a90 	vmov	s15, r2
 8007044:	eef8 7a67 	vcvt.f32.u32	s15, s15
    else if (f >= fstop)
 8007048:	4599      	cmp	r9, r3
      idx = r * (points - 1);
 800704a:	ee68 7a27 	vmul.f32	s15, s16, s15
    else if (f >= fstop)
 800704e:	d9e8      	bls.n	8007022 <update_frequencies+0x52>
      idx = r * (points - 1);
 8007050:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007054:	ee17 1a90 	vmov	r1, s15
 8007058:	e7e3      	b.n	8007022 <update_frequencies+0x52>
      idx = 0;
 800705a:	2100      	movs	r1, #0
 800705c:	e7e1      	b.n	8007022 <update_frequencies+0x52>
  update_grid(start, stop);
 800705e:	4649      	mov	r1, r9
 8007060:	4630      	mov	r0, r6
 8007062:	f004 f8a7 	bl	800b1b4 <update_grid>
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8007066:	f8d8 200c 	ldr.w	r2, [r8, #12]
    cal_status &= ~CALSTAT_INTERPOLATED;
 800706a:	f8b8 3024 	ldrh.w	r3, [r8, #36]	@ 0x24
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 800706e:	4296      	cmp	r6, r2
 8007070:	d00e      	beq.n	8007090 <update_frequencies+0xc0>
    cal_status |= CALSTAT_INTERPOLATED;
 8007072:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
  request_to_redraw(REDRAW_BACKUP | REDRAW_PLOT | REDRAW_CAL_STATUS | REDRAW_FREQUENCY | REDRAW_AREA);
 8007076:	f240 401b 	movw	r0, #1051	@ 0x41b
 800707a:	f8a8 3024 	strh.w	r3, [r8, #36]	@ 0x24
 800707e:	f004 fbb7 	bl	800b7f0 <request_to_redraw>
}
 8007082:	ecbd 8b02 	vpop	{d8}
  RESET_SWEEP;
 8007086:	4b0d      	ldr	r3, [pc, #52]	@ (80070bc <update_frequencies+0xec>)
 8007088:	2200      	movs	r2, #0
 800708a:	801a      	strh	r2, [r3, #0]
}
 800708c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8007090:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8007094:	4591      	cmp	r9, r2
 8007096:	d1ec      	bne.n	8007072 <update_frequencies+0xa2>
 8007098:	f8b8 101a 	ldrh.w	r1, [r8, #26]
 800709c:	f8b8 2022 	ldrh.w	r2, [r8, #34]	@ 0x22
 80070a0:	4291      	cmp	r1, r2
 80070a2:	d1e6      	bne.n	8007072 <update_frequencies+0xa2>
    cal_status &= ~CALSTAT_INTERPOLATED;
 80070a4:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 80070a8:	b29b      	uxth	r3, r3
 80070aa:	e7e4      	b.n	8007076 <update_frequencies+0xa6>
 80070ac:	20000914 	.word	0x20000914
 80070b0:	20000910 	.word	0x20000910
 80070b4:	20000908 	.word	0x20000908
 80070b8:	2000090c 	.word	0x2000090c
 80070bc:	20006864 	.word	0x20006864
 80070c0:	20000aa8 	.word	0x20000aa8

080070c4 <load_properties>:
{
 80070c4:	b510      	push	{r4, lr}
  int r = caldata_recall(id);
 80070c6:	f009 fc0f 	bl	80108e8 <caldata_recall>
 80070ca:	4604      	mov	r4, r0
  update_frequencies();
 80070cc:	f7ff ff80 	bl	8006fd0 <update_frequencies>
  plot_set_measure_mode(current_props._measure);
 80070d0:	4b03      	ldr	r3, [pc, #12]	@ (80070e0 <load_properties+0x1c>)
 80070d2:	f893 0021 	ldrb.w	r0, [r3, #33]	@ 0x21
 80070d6:	f004 fb9f 	bl	800b818 <plot_set_measure_mode>
}
 80070da:	4620      	mov	r0, r4
 80070dc:	bd10      	pop	{r4, pc}
 80070de:	bf00      	nop
 80070e0:	20000aa8 	.word	0x20000aa8

080070e4 <cmd_recall>:
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 80070e4:	2801      	cmp	r0, #1
 80070e6:	d000      	beq.n	80070ea <cmd_recall+0x6>
 80070e8:	4770      	bx	lr
{
 80070ea:	b508      	push	{r3, lr}
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 80070ec:	6808      	ldr	r0, [r1, #0]
 80070ee:	f001 fc61 	bl	80089b4 <my_atoui>
 80070f2:	2806      	cmp	r0, #6
 80070f4:	d900      	bls.n	80070f8 <cmd_recall+0x14>
}
 80070f6:	bd08      	pop	{r3, pc}
 80070f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (load_properties(id)) // Check for success
 80070fc:	f7ff bfe2 	b.w	80070c4 <load_properties>

08007100 <set_sweep_points>:
  if (points > SWEEP_POINTS_MAX)
 8007100:	2815      	cmp	r0, #21
  if (points == sweep_points)
 8007102:	4b07      	ldr	r3, [pc, #28]	@ (8007120 <set_sweep_points+0x20>)
  if (points > SWEEP_POINTS_MAX)
 8007104:	bf38      	it	cc
 8007106:	2015      	movcc	r0, #21
 8007108:	f240 1191 	movw	r1, #401	@ 0x191
 800710c:	4288      	cmp	r0, r1
  if (points == sweep_points)
 800710e:	8b5a      	ldrh	r2, [r3, #26]
  if (points > SWEEP_POINTS_MAX)
 8007110:	bf28      	it	cs
 8007112:	4608      	movcs	r0, r1
  if (points == sweep_points)
 8007114:	4282      	cmp	r2, r0
 8007116:	d002      	beq.n	800711e <set_sweep_points+0x1e>
  sweep_points = points;
 8007118:	8358      	strh	r0, [r3, #26]
  update_frequencies();
 800711a:	f7ff bf59 	b.w	8006fd0 <update_frequencies>
}
 800711e:	4770      	bx	lr
 8007120:	20000aa8 	.word	0x20000aa8

08007124 <cmd_resume>:
{
 8007124:	b508      	push	{r3, lr}
  update_frequencies();
 8007126:	f7ff ff53 	bl	8006fd0 <update_frequencies>
  sweep_mode |= SWEEP_ENABLE;
 800712a:	4a03      	ldr	r2, [pc, #12]	@ (8007138 <cmd_resume+0x14>)
 800712c:	7813      	ldrb	r3, [r2, #0]
 800712e:	f043 0301 	orr.w	r3, r3, #1
 8007132:	7013      	strb	r3, [r2, #0]
}
 8007134:	bd08      	pop	{r3, pc}
 8007136:	bf00      	nop
 8007138:	200003c4 	.word	0x200003c4

0800713c <cmd_marker>:
  if (argc == 0)
 800713c:	b900      	cbnz	r0, 8007140 <cmd_marker+0x4>
 800713e:	4770      	bx	lr
{
 8007140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007142:	460d      	mov	r5, r1
 8007144:	4604      	mov	r4, r0
  request_to_redraw(REDRAW_MARKER | REDRAW_AREA);
 8007146:	2022      	movs	r0, #34	@ 0x22
 8007148:	f004 fb52 	bl	800b7f0 <request_to_redraw>
  int enable = get_str_index(argv[0], cmd_marker_list);
 800714c:	492c      	ldr	r1, [pc, #176]	@ (8007200 <cmd_marker+0xc4>)
 800714e:	6828      	ldr	r0, [r5, #0]
 8007150:	f001 fcf0 	bl	8008b34 <get_str_index>
  if (enable >= 0)
 8007154:	2800      	cmp	r0, #0
 8007156:	db1b      	blt.n	8007190 <cmd_marker+0x54>
    active_marker = enable == 1 ? MARKER_INVALID : 0;
 8007158:	4a2a      	ldr	r2, [pc, #168]	@ (8007204 <cmd_marker+0xc8>)
      markers[t].enabled = enable == 0;
 800715a:	fab0 f380 	clz	r3, r0
    active_marker = enable == 1 ? MARKER_INVALID : 0;
 800715e:	2801      	cmp	r0, #1
      markers[t].enabled = enable == 0;
 8007160:	ea4f 1353 	mov.w	r3, r3, lsr #5
    active_marker = enable == 1 ? MARKER_INVALID : 0;
 8007164:	f04f 30ff 	mov.w	r0, #4294967295
 8007168:	bf18      	it	ne
 800716a:	2000      	movne	r0, #0
 800716c:	7750      	strb	r0, [r2, #29]
      markers[t].enabled = enable == 0;
 800716e:	f882 3058 	strb.w	r3, [r2, #88]	@ 0x58
 8007172:	f882 3060 	strb.w	r3, [r2, #96]	@ 0x60
 8007176:	f882 3068 	strb.w	r3, [r2, #104]	@ 0x68
 800717a:	f882 3070 	strb.w	r3, [r2, #112]	@ 0x70
 800717e:	f882 3078 	strb.w	r3, [r2, #120]	@ 0x78
 8007182:	f882 3080 	strb.w	r3, [r2, #128]	@ 0x80
 8007186:	f882 3088 	strb.w	r3, [r2, #136]	@ 0x88
 800718a:	f882 3090 	strb.w	r3, [r2, #144]	@ 0x90
}
 800718e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  t = my_atoi(argv[0]) - 1;
 8007190:	6828      	ldr	r0, [r5, #0]
 8007192:	f001 fbf5 	bl	8008980 <my_atoi>
 8007196:	1e47      	subs	r7, r0, #1
  if (t < 0 || t >= MARKERS_MAX)
 8007198:	2f07      	cmp	r7, #7
  t = my_atoi(argv[0]) - 1;
 800719a:	4606      	mov	r6, r0
  if (t < 0 || t >= MARKERS_MAX)
 800719c:	d8f7      	bhi.n	800718e <cmd_marker+0x52>
  if (argc == 1)
 800719e:	2c01      	cmp	r4, #1
 80071a0:	d020      	beq.n	80071e4 <cmd_marker+0xa8>
  switch (get_str_index(argv[1], cmd_marker_list))
 80071a2:	4917      	ldr	r1, [pc, #92]	@ (8007200 <cmd_marker+0xc4>)
 80071a4:	6868      	ldr	r0, [r5, #4]
 80071a6:	f001 fcc5 	bl	8008b34 <get_str_index>
 80071aa:	b308      	cbz	r0, 80071f0 <cmd_marker+0xb4>
 80071ac:	2801      	cmp	r0, #1
 80071ae:	d10b      	bne.n	80071c8 <cmd_marker+0x8c>
    markers[t].enabled = FALSE;
 80071b0:	4b14      	ldr	r3, [pc, #80]	@ (8007204 <cmd_marker+0xc8>)
    if (active_marker == t)
 80071b2:	f993 201d 	ldrsb.w	r2, [r3, #29]
    markers[t].enabled = FALSE;
 80071b6:	360a      	adds	r6, #10
 80071b8:	2100      	movs	r1, #0
    if (active_marker == t)
 80071ba:	42ba      	cmp	r2, r7
    markers[t].enabled = FALSE;
 80071bc:	f803 1036 	strb.w	r1, [r3, r6, lsl #3]
    if (active_marker == t)
 80071c0:	d1e5      	bne.n	800718e <cmd_marker+0x52>
      active_marker = MARKER_INVALID;
 80071c2:	22ff      	movs	r2, #255	@ 0xff
 80071c4:	775a      	strb	r2, [r3, #29]
}
 80071c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    markers[t].enabled = TRUE;
 80071c8:	4c0e      	ldr	r4, [pc, #56]	@ (8007204 <cmd_marker+0xc8>)
 80071ca:	360a      	adds	r6, #10
 80071cc:	2301      	movs	r3, #1
 80071ce:	f804 3036 	strb.w	r3, [r4, r6, lsl #3]
    int index = my_atoi(argv[1]);
 80071d2:	6868      	ldr	r0, [r5, #4]
 80071d4:	f001 fbd4 	bl	8008980 <my_atoi>
 80071d8:	4601      	mov	r1, r0
    set_marker_index(t, index);
 80071da:	4638      	mov	r0, r7
 80071dc:	f7ff fed6 	bl	8006f8c <set_marker_index>
    active_marker = t;
 80071e0:	7767      	strb	r7, [r4, #29]
}
 80071e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    active_marker = t;
 80071e4:	4b07      	ldr	r3, [pc, #28]	@ (8007204 <cmd_marker+0xc8>)
    markers[t].enabled = TRUE;
 80071e6:	360a      	adds	r6, #10
    active_marker = t;
 80071e8:	775f      	strb	r7, [r3, #29]
    markers[t].enabled = TRUE;
 80071ea:	f803 4036 	strb.w	r4, [r3, r6, lsl #3]
}
 80071ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    markers[t].enabled = TRUE;
 80071f0:	4b04      	ldr	r3, [pc, #16]	@ (8007204 <cmd_marker+0xc8>)
 80071f2:	360a      	adds	r6, #10
 80071f4:	2201      	movs	r2, #1
 80071f6:	f803 2036 	strb.w	r2, [r3, r6, lsl #3]
    active_marker = t;
 80071fa:	775f      	strb	r7, [r3, #29]
}
 80071fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80071fe:	bf00      	nop
 8007200:	08013c58 	.word	0x08013c58
 8007204:	20000aa8 	.word	0x20000aa8

08007208 <get_marker_frequency>:
  if ((uint32_t)marker >= MARKERS_MAX)
 8007208:	2807      	cmp	r0, #7
  return markers[marker].frequency;
 800720a:	bf9d      	ittte	ls
 800720c:	4b02      	ldrls	r3, [pc, #8]	@ (8007218 <get_marker_frequency+0x10>)
 800720e:	eb03 03c0 	addls.w	r3, r3, r0, lsl #3
 8007212:	6dd8      	ldrls	r0, [r3, #92]	@ 0x5c
    return 0;
 8007214:	2000      	movhi	r0, #0
}
 8007216:	4770      	bx	lr
 8007218:	20000aa8 	.word	0x20000aa8

0800721c <set_sweep_frequency>:
  if (type < ST_SPAN && freq < FREQUENCY_MIN)
 800721c:	2803      	cmp	r0, #3
{
 800721e:	b430      	push	{r4, r5}
  if (type < ST_SPAN && freq < FREQUENCY_MIN)
 8007220:	d81d      	bhi.n	800725e <set_sweep_frequency+0x42>
 8007222:	f5b1 7f16 	cmp.w	r1, #600	@ 0x258
 8007226:	bf38      	it	cc
 8007228:	f44f 7116 	movcc.w	r1, #600	@ 0x258
  if (freq > FREQUENCY_MAX)
 800722c:	4b41      	ldr	r3, [pc, #260]	@ (8007334 <set_sweep_frequency+0x118>)
 800722e:	4299      	cmp	r1, r3
 8007230:	bf28      	it	cs
 8007232:	4619      	movcs	r1, r3
  switch (type)
 8007234:	2806      	cmp	r0, #6
 8007236:	d80f      	bhi.n	8007258 <set_sweep_frequency+0x3c>
 8007238:	e8df f000 	tbb	[pc, r0]
 800723c:	674a7504 	.word	0x674a7504
 8007240:	0e79      	.short	0x0e79
 8007242:	6e          	.byte	0x6e
 8007243:	00          	.byte	0x00
    FREQ_STARTSTOP();
 8007244:	4b3c      	ldr	r3, [pc, #240]	@ (8007338 <set_sweep_frequency+0x11c>)
 8007246:	8b1a      	ldrh	r2, [r3, #24]
    if (frequency1 < freq)
 8007248:	6898      	ldr	r0, [r3, #8]
    frequency0 = freq;
 800724a:	6059      	str	r1, [r3, #4]
    FREQ_STARTSTOP();
 800724c:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
    if (frequency1 < freq)
 8007250:	4288      	cmp	r0, r1
    FREQ_STARTSTOP();
 8007252:	831a      	strh	r2, [r3, #24]
    if (frequency1 < freq)
 8007254:	d200      	bcs.n	8007258 <set_sweep_frequency+0x3c>
    frequency0 = freq;
 8007256:	6099      	str	r1, [r3, #8]
}
 8007258:	bc30      	pop	{r4, r5}
  update_frequencies();
 800725a:	f7ff beb9 	b.w	8006fd0 <update_frequencies>
  if (type == ST_STEP)
 800725e:	2805      	cmp	r0, #5
 8007260:	d1e4      	bne.n	800722c <set_sweep_frequency+0x10>
    freq *= (sweep_points - 1);
 8007262:	4b35      	ldr	r3, [pc, #212]	@ (8007338 <set_sweep_frequency+0x11c>)
 8007264:	8b5a      	ldrh	r2, [r3, #26]
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 8007266:	8b18      	ldrh	r0, [r3, #24]
    freq *= (sweep_points - 1);
 8007268:	3a01      	subs	r2, #1
 800726a:	fb01 f202 	mul.w	r2, r1, r2
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 800726e:	0641      	lsls	r1, r0, #25
 8007270:	d40d      	bmi.n	800728e <set_sweep_frequency+0x72>
      freq += frequency0;
 8007272:	685c      	ldr	r4, [r3, #4]
  if (freq > FREQUENCY_MAX)
 8007274:	4d2f      	ldr	r5, [pc, #188]	@ (8007334 <set_sweep_frequency+0x118>)
      freq += frequency0;
 8007276:	1911      	adds	r1, r2, r4
  if (freq > FREQUENCY_MAX)
 8007278:	42a9      	cmp	r1, r5
 800727a:	bf28      	it	cs
 800727c:	4629      	movcs	r1, r5
    FREQ_STARTSTOP()
 800727e:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
    if (frequency0 > freq)
 8007282:	42a1      	cmp	r1, r4
    FREQ_STARTSTOP()
 8007284:	8318      	strh	r0, [r3, #24]
    frequency1 = freq;
 8007286:	6099      	str	r1, [r3, #8]
    if (frequency0 > freq)
 8007288:	d2e6      	bcs.n	8007258 <set_sweep_frequency+0x3c>
      frequency0 = freq;
 800728a:	6059      	str	r1, [r3, #4]
 800728c:	e7e4      	b.n	8007258 <set_sweep_frequency+0x3c>
  if (freq > FREQUENCY_MAX)
 800728e:	4929      	ldr	r1, [pc, #164]	@ (8007334 <set_sweep_frequency+0x118>)
 8007290:	4291      	cmp	r1, r2
 8007292:	bf28      	it	cs
 8007294:	4611      	movcs	r1, r2
    case ST_CENTER: return (frequency0>>1) + (frequency1>>1) + (frequency0&1);
 8007296:	e9d3 4501 	ldrd	r4, r5, [r3, #4]
 800729a:	0862      	lsrs	r2, r4, #1
    span = freq >> 1;
 800729c:	0849      	lsrs	r1, r1, #1
    FREQ_CENTERSPAN();
 800729e:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 80072a2:	eb02 0255 	add.w	r2, r2, r5, lsr #1
 80072a6:	f004 0401 	and.w	r4, r4, #1
 80072aa:	4422      	add	r2, r4
 80072ac:	8318      	strh	r0, [r3, #24]
    if (center < FREQUENCY_MIN + span)
 80072ae:	f501 7416 	add.w	r4, r1, #600	@ 0x258
    if (center > FREQUENCY_MAX - span)
 80072b2:	4820      	ldr	r0, [pc, #128]	@ (8007334 <set_sweep_frequency+0x118>)
    if (center < FREQUENCY_MIN + span)
 80072b4:	42a2      	cmp	r2, r4
 80072b6:	bf38      	it	cc
 80072b8:	4622      	movcc	r2, r4
    if (center > FREQUENCY_MAX - span)
 80072ba:	1a40      	subs	r0, r0, r1
 80072bc:	4282      	cmp	r2, r0
 80072be:	bf28      	it	cs
 80072c0:	4602      	movcs	r2, r0
    frequency0 = center - span;
 80072c2:	1a50      	subs	r0, r2, r1
}
 80072c4:	bc30      	pop	{r4, r5}
    frequency1 = center + span;
 80072c6:	440a      	add	r2, r1
 80072c8:	e9c3 0201 	strd	r0, r2, [r3, #4]
  update_frequencies();
 80072cc:	f7ff be80 	b.w	8006fd0 <update_frequencies>
    FREQ_CENTERSPAN();
 80072d0:	4a19      	ldr	r2, [pc, #100]	@ (8007338 <set_sweep_frequency+0x11c>)
    if (span > FREQUENCY_MAX - center)
 80072d2:	4d18      	ldr	r5, [pc, #96]	@ (8007334 <set_sweep_frequency+0x118>)
    span = (frequency1 - frequency0 + 1) >> 1;
 80072d4:	e9d2 0301 	ldrd	r0, r3, [r2, #4]
    if (span > center - FREQUENCY_MIN)
 80072d8:	f5a1 7416 	sub.w	r4, r1, #600	@ 0x258
    if (span > FREQUENCY_MAX - center)
 80072dc:	1a6d      	subs	r5, r5, r1
    span = (frequency1 - frequency0 + 1) >> 1;
 80072de:	3301      	adds	r3, #1
    if (span > FREQUENCY_MAX - center)
 80072e0:	42ac      	cmp	r4, r5
    span = (frequency1 - frequency0 + 1) >> 1;
 80072e2:	eba3 0300 	sub.w	r3, r3, r0
 80072e6:	ea4f 0353 	mov.w	r3, r3, lsr #1
    if (span > FREQUENCY_MAX - center)
 80072ea:	bf28      	it	cs
 80072ec:	462c      	movcs	r4, r5
    FREQ_CENTERSPAN();
 80072ee:	8b10      	ldrh	r0, [r2, #24]
    if (span > FREQUENCY_MAX - center)
 80072f0:	42a3      	cmp	r3, r4
 80072f2:	bf28      	it	cs
 80072f4:	4623      	movcs	r3, r4
    FREQ_CENTERSPAN();
 80072f6:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 80072fa:	8310      	strh	r0, [r2, #24]
}
 80072fc:	bc30      	pop	{r4, r5}
    frequency0 = center - span;
 80072fe:	1ac8      	subs	r0, r1, r3
    frequency1 = center + span;
 8007300:	440b      	add	r3, r1
 8007302:	e9c2 0301 	strd	r0, r3, [r2, #4]
  update_frequencies();
 8007306:	f7ff be63 	b.w	8006fd0 <update_frequencies>
    FREQ_CENTERSPAN();
 800730a:	4b0b      	ldr	r3, [pc, #44]	@ (8007338 <set_sweep_frequency+0x11c>)
 800730c:	8b1a      	ldrh	r2, [r3, #24]
    frequency0 = freq;
 800730e:	6059      	str	r1, [r3, #4]
    FREQ_CENTERSPAN();
 8007310:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8007314:	831a      	strh	r2, [r3, #24]
 8007316:	e79e      	b.n	8007256 <set_sweep_frequency+0x3a>
    var_freq = freq;
 8007318:	4b07      	ldr	r3, [pc, #28]	@ (8007338 <set_sweep_frequency+0x11c>)
}
 800731a:	bc30      	pop	{r4, r5}
    request_to_redraw(REDRAW_BACKUP);
 800731c:	f44f 6080 	mov.w	r0, #1024	@ 0x400
    var_freq = freq;
 8007320:	6159      	str	r1, [r3, #20]
    request_to_redraw(REDRAW_BACKUP);
 8007322:	f004 ba65 	b.w	800b7f0 <request_to_redraw>
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 8007326:	4b04      	ldr	r3, [pc, #16]	@ (8007338 <set_sweep_frequency+0x11c>)
 8007328:	8b18      	ldrh	r0, [r3, #24]
      freq += frequency0;
 800732a:	685c      	ldr	r4, [r3, #4]
 800732c:	e7a7      	b.n	800727e <set_sweep_frequency+0x62>
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 800732e:	4b02      	ldr	r3, [pc, #8]	@ (8007338 <set_sweep_frequency+0x11c>)
 8007330:	8b18      	ldrh	r0, [r3, #24]
 8007332:	e7b0      	b.n	8007296 <set_sweep_frequency+0x7a>
 8007334:	a0eebb00 	.word	0xa0eebb00
 8007338:	20000aa8 	.word	0x20000aa8

0800733c <cmd_sweep>:
  if (argc == 0)
 800733c:	b130      	cbz	r0, 800734c <cmd_sweep+0x10>
  else if (argc > 3)
 800733e:	2803      	cmp	r0, #3
{
 8007340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007342:	4604      	mov	r4, r0
  else if (argc > 3)
 8007344:	dc01      	bgt.n	800734a <cmd_sweep+0xe>
  if (argc >= 1)
 8007346:	2800      	cmp	r0, #0
 8007348:	dc01      	bgt.n	800734e <cmd_sweep+0x12>
}
 800734a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800734c:	4770      	bx	lr
    value0 = my_atoui(argv[0]);
 800734e:	6808      	ldr	r0, [r1, #0]
 8007350:	460d      	mov	r5, r1
 8007352:	f001 fb2f 	bl	80089b4 <my_atoui>
  if (argc >= 2)
 8007356:	2c01      	cmp	r4, #1
    value0 = my_atoui(argv[0]);
 8007358:	4606      	mov	r6, r0
  if (argc >= 2)
 800735a:	d107      	bne.n	800736c <cmd_sweep+0x30>
  if (value0)
 800735c:	2800      	cmp	r0, #0
 800735e:	d0f4      	beq.n	800734a <cmd_sweep+0xe>
    set_sweep_frequency(ST_START, value0);
 8007360:	4601      	mov	r1, r0
}
 8007362:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    set_sweep_frequency(ST_START, value0);
 8007366:	2000      	movs	r0, #0
 8007368:	f7ff bf58 	b.w	800721c <set_sweep_frequency>
    value1 = my_atoui(argv[1]);
 800736c:	6868      	ldr	r0, [r5, #4]
 800736e:	f001 fb21 	bl	80089b4 <my_atoui>
  if (argc >= 3)
 8007372:	2c03      	cmp	r4, #3
    value1 = my_atoui(argv[1]);
 8007374:	4607      	mov	r7, r0
  if (argc >= 3)
 8007376:	d115      	bne.n	80073a4 <cmd_sweep+0x68>
    value2 = my_atoui(argv[2]);
 8007378:	68a8      	ldr	r0, [r5, #8]
 800737a:	f001 fb1b 	bl	80089b4 <my_atoui>
 800737e:	4604      	mov	r4, r0
  if (value0)
 8007380:	b95e      	cbnz	r6, 800739a <cmd_sweep+0x5e>
  if (value1)
 8007382:	b11f      	cbz	r7, 800738c <cmd_sweep+0x50>
    set_sweep_frequency(ST_STOP, value1);
 8007384:	4639      	mov	r1, r7
 8007386:	2001      	movs	r0, #1
 8007388:	f7ff ff48 	bl	800721c <set_sweep_frequency>
  if (value2)
 800738c:	2c00      	cmp	r4, #0
 800738e:	d0dc      	beq.n	800734a <cmd_sweep+0xe>
    set_sweep_points(value2);
 8007390:	b2a0      	uxth	r0, r4
}
 8007392:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    set_sweep_points(value2);
 8007396:	f7ff beb3 	b.w	8007100 <set_sweep_points>
    set_sweep_frequency(ST_START, value0);
 800739a:	4631      	mov	r1, r6
 800739c:	2000      	movs	r0, #0
 800739e:	f7ff ff3d 	bl	800721c <set_sweep_frequency>
 80073a2:	e7ee      	b.n	8007382 <cmd_sweep+0x46>
  if (argc == 2 && value0 == 0)
 80073a4:	b15e      	cbz	r6, 80073be <cmd_sweep+0x82>
    set_sweep_frequency(ST_START, value0);
 80073a6:	4631      	mov	r1, r6
 80073a8:	2000      	movs	r0, #0
 80073aa:	f7ff ff37 	bl	800721c <set_sweep_frequency>
  if (value1)
 80073ae:	2f00      	cmp	r7, #0
 80073b0:	d0cb      	beq.n	800734a <cmd_sweep+0xe>
    set_sweep_frequency(ST_STOP, value1);
 80073b2:	4639      	mov	r1, r7
 80073b4:	2001      	movs	r0, #1
}
 80073b6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    set_sweep_frequency(ST_STOP, value1);
 80073ba:	f7ff bf2f 	b.w	800721c <set_sweep_frequency>
    int type = get_str_index(argv[0], sweep_cmd);
 80073be:	4906      	ldr	r1, [pc, #24]	@ (80073d8 <cmd_sweep+0x9c>)
 80073c0:	6828      	ldr	r0, [r5, #0]
 80073c2:	f001 fbb7 	bl	8008b34 <get_str_index>
    if (type == -1)
 80073c6:	1c43      	adds	r3, r0, #1
 80073c8:	d0bf      	beq.n	800734a <cmd_sweep+0xe>
    set_sweep_frequency(type, value1);
 80073ca:	4639      	mov	r1, r7
 80073cc:	b280      	uxth	r0, r0
}
 80073ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    set_sweep_frequency(type, value1);
 80073d2:	f7ff bf23 	b.w	800721c <set_sweep_frequency>
 80073d6:	bf00      	nop
 80073d8:	08013b24 	.word	0x08013b24

080073dc <cal_collect>:
  if (type >= ARRAY_COUNT(calibration_set))
 80073dc:	2804      	cmp	r0, #4
 80073de:	d843      	bhi.n	8007468 <cal_collect+0x8c>
{
 80073e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (needInterpolate(frequency0, frequency1, sweep_points))
 80073e4:	4c21      	ldr	r4, [pc, #132]	@ (800746c <cal_collect+0x90>)
 80073e6:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 80073ea:	68e5      	ldr	r5, [r4, #12]
  if (needInterpolate(frequency0, frequency1, sweep_points))
 80073ec:	8b61      	ldrh	r1, [r4, #26]
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 80073ee:	429d      	cmp	r5, r3
 80073f0:	d032      	beq.n	8007458 <cal_collect+0x7c>
    cal_frequency0 = frequency0;
 80073f2:	e9c4 3203 	strd	r3, r2, [r4, #12]
    cal_sweep_points = sweep_points;
 80073f6:	8461      	strh	r1, [r4, #34]	@ 0x22
 80073f8:	2300      	movs	r3, #0
  cal_status &= calibration_set[type].clr_flag;
 80073fa:	491d      	ldr	r1, [pc, #116]	@ (8007470 <cal_collect+0x94>)
  uint8_t bw = config._bandwidth; // store current setting
 80073fc:	4d1d      	ldr	r5, [pc, #116]	@ (8007474 <cal_collect+0x98>)
  cal_status &= calibration_set[type].clr_flag;
 80073fe:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8007402:	eb01 0240 	add.w	r2, r1, r0, lsl #1
  cal_status |= calibration_set[type].set_flag;
 8007406:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
  cal_power = current_props._power;
 800740a:	7fe0      	ldrb	r0, [r4, #31]
 800740c:	f884 0020 	strb.w	r0, [r4, #32]
  cal_status &= calibration_set[type].clr_flag;
 8007410:	8850      	ldrh	r0, [r2, #2]
  if (bw < BANDWIDTH_100)
 8007412:	7eae      	ldrb	r6, [r5, #26]
  src = calibration_set[type].src;
 8007414:	7957      	ldrb	r7, [r2, #5]
  dst = calibration_set[type].dst;
 8007416:	f892 8004 	ldrb.w	r8, [r2, #4]
  cal_status &= calibration_set[type].clr_flag;
 800741a:	4003      	ands	r3, r0
  cal_status |= calibration_set[type].set_flag;
 800741c:	430b      	orrs	r3, r1
  if (bw < BANDWIDTH_100)
 800741e:	2e26      	cmp	r6, #38	@ 0x26
  cal_status |= calibration_set[type].set_flag;
 8007420:	84a3      	strh	r3, [r4, #36]	@ 0x24
    config._bandwidth = BANDWIDTH_100;
 8007422:	bf9c      	itt	ls
 8007424:	2327      	movls	r3, #39	@ 0x27
 8007426:	836b      	strhls	r3, [r5, #26]
  uint16_t mask = (src == 0) ? SWEEP_CH0_MEASURE : SWEEP_CH1_MEASURE;
 8007428:	2f00      	cmp	r7, #0
  sweep(false, mask);
 800742a:	bf14      	ite	ne
 800742c:	2102      	movne	r1, #2
 800742e:	2101      	moveq	r1, #1
 8007430:	2000      	movs	r0, #0
 8007432:	f7ff f8df 	bl	80065f4 <sweep>
  memcpy(cal_data[dst], measured[src], sizeof measured[0]);
 8007436:	f640 4388 	movw	r3, #3208	@ 0xc88
 800743a:	490f      	ldr	r1, [pc, #60]	@ (8007478 <cal_collect+0x9c>)
 800743c:	fb03 4008 	mla	r0, r3, r8, r4
 8007440:	fb03 1107 	mla	r1, r3, r7, r1
 8007444:	30d0      	adds	r0, #208	@ 0xd0
 8007446:	461a      	mov	r2, r3
 8007448:	f00a fa0c 	bl	8011864 <memcpy>
  config._bandwidth = bw; // restore
 800744c:	836e      	strh	r6, [r5, #26]
  request_to_redraw(REDRAW_CAL_STATUS);
 800744e:	2010      	movs	r0, #16
}
 8007450:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  request_to_redraw(REDRAW_CAL_STATUS);
 8007454:	f004 b9cc 	b.w	800b7f0 <request_to_redraw>
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8007458:	6925      	ldr	r5, [r4, #16]
 800745a:	4295      	cmp	r5, r2
 800745c:	d1c9      	bne.n	80073f2 <cal_collect+0x16>
 800745e:	8c65      	ldrh	r5, [r4, #34]	@ 0x22
 8007460:	428d      	cmp	r5, r1
 8007462:	d1c6      	bne.n	80073f2 <cal_collect+0x16>
  cal_status &= calibration_set[type].clr_flag;
 8007464:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
 8007466:	e7c8      	b.n	80073fa <cal_collect+0x1e>
 8007468:	4770      	bx	lr
 800746a:	bf00      	nop
 800746c:	20000aa8 	.word	0x20000aa8
 8007470:	08013d08 	.word	0x08013d08
 8007474:	20000318 	.word	0x20000318
 8007478:	20004f54 	.word	0x20004f54

0800747c <cal_done>:
{
 800747c:	b538      	push	{r3, r4, r5, lr}
  if (!(cal_status & CALSTAT_LOAD))
 800747e:	4d6c      	ldr	r5, [pc, #432]	@ (8007630 <cal_done+0x1b4>)
 8007480:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 8007482:	f014 0001 	ands.w	r0, r4, #1
 8007486:	f000 8083 	beq.w	8007590 <cal_done+0x114>
  if (!(cal_status & CALSTAT_ISOLN))
 800748a:	06e1      	lsls	r1, r4, #27
 800748c:	d57a      	bpl.n	8007584 <cal_done+0x108>
  if ((cal_status & CALSTAT_SHORT) && (cal_status & CALSTAT_OPEN))
 800748e:	0762      	lsls	r2, r4, #29
 8007490:	f004 0302 	and.w	r3, r4, #2
 8007494:	d520      	bpl.n	80074d8 <cal_done+0x5c>
 8007496:	2b00      	cmp	r3, #0
 8007498:	d17f      	bne.n	800759a <cal_done+0x11e>
    eterm_set(ETERM_ES, 0.0, 0.0);
 800749a:	2001      	movs	r0, #1
 800749c:	ed9f 0a65 	vldr	s0, [pc, #404]	@ 8007634 <cal_done+0x1b8>
 80074a0:	f7fe fc2c 	bl	8005cfc <eterm_set.constprop.0>
    eterm_calc_er(-1);
 80074a4:	f04f 30ff 	mov.w	r0, #4294967295
 80074a8:	f7fd ffee 	bl	8005488 <eterm_calc_er>
  if (cal_status & CALSTAT_THRU)
 80074ac:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 80074ae:	0720      	lsls	r0, r4, #28
 80074b0:	d428      	bmi.n	8007504 <cal_done+0x88>
  if (!(cal_status & CALSTAT_ET))
 80074b2:	0621      	lsls	r1, r4, #24
 80074b4:	d560      	bpl.n	8007578 <cal_done+0xfc>
  if (!(cal_status & CALSTAT_ER))
 80074b6:	0662      	lsls	r2, r4, #25
 80074b8:	d551      	bpl.n	800755e <cal_done+0xe2>
  if (!(cal_status & CALSTAT_ES))
 80074ba:	06a3      	lsls	r3, r4, #26
 80074bc:	d556      	bpl.n	800756c <cal_done+0xf0>
  lastsaveid = NO_SAVE_SLOT;
 80074be:	4b5e      	ldr	r3, [pc, #376]	@ (8007638 <cal_done+0x1bc>)
  cal_status |= CALSTAT_APPLY;
 80074c0:	f444 7480 	orr.w	r4, r4, #256	@ 0x100
  lastsaveid = NO_SAVE_SLOT;
 80074c4:	f64f 72ff 	movw	r2, #65535	@ 0xffff
  cal_status |= CALSTAT_APPLY;
 80074c8:	84ac      	strh	r4, [r5, #36]	@ 0x24
  lastsaveid = NO_SAVE_SLOT;
 80074ca:	801a      	strh	r2, [r3, #0]
  request_to_redraw(REDRAW_BACKUP | REDRAW_CAL_STATUS);
 80074cc:	f44f 6082 	mov.w	r0, #1040	@ 0x410
}
 80074d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  request_to_redraw(REDRAW_BACKUP | REDRAW_CAL_STATUS);
 80074d4:	f004 b98c 	b.w	800b7f0 <request_to_redraw>
  else if (cal_status & CALSTAT_OPEN)
 80074d8:	2b00      	cmp	r3, #0
 80074da:	d0e8      	beq.n	80074ae <cal_done+0x32>
  memcpy(cal_data[dst], cal_data[src], sizeof cal_data[dst]);
 80074dc:	4957      	ldr	r1, [pc, #348]	@ (800763c <cal_done+0x1c0>)
 80074de:	f640 4288 	movw	r2, #3208	@ 0xc88
 80074e2:	1888      	adds	r0, r1, r2
 80074e4:	f00a f9be 	bl	8011864 <memcpy>
    cal_status &= ~CALSTAT_OPEN;
 80074e8:	f024 0402 	bic.w	r4, r4, #2
    eterm_set(ETERM_ES, 0.0, 0.0);
 80074ec:	2001      	movs	r0, #1
 80074ee:	ed9f 0a51 	vldr	s0, [pc, #324]	@ 8007634 <cal_done+0x1b8>
    cal_status &= ~CALSTAT_OPEN;
 80074f2:	84ac      	strh	r4, [r5, #36]	@ 0x24
    eterm_set(ETERM_ES, 0.0, 0.0);
 80074f4:	f7fe fc02 	bl	8005cfc <eterm_set.constprop.0>
    eterm_calc_er(1);
 80074f8:	2001      	movs	r0, #1
 80074fa:	f7fd ffc5 	bl	8005488 <eterm_calc_er>
  if (cal_status & CALSTAT_THRU)
 80074fe:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 8007500:	0720      	lsls	r0, r4, #28
 8007502:	d5d6      	bpl.n	80074b2 <cal_done+0x36>
  for (i = 0; i < sweep_points; i++)
 8007504:	8b69      	ldrh	r1, [r5, #26]
 8007506:	b319      	cbz	r1, 8007550 <cal_done+0xd4>
 8007508:	4b4d      	ldr	r3, [pc, #308]	@ (8007640 <cal_done+0x1c4>)
 800750a:	f603 4288 	addw	r2, r3, #3208	@ 0xc88
 800750e:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8007512:	ed93 6a01 	vldr	s12, [r3, #4]
 8007516:	edd2 6a01 	vldr	s13, [r2, #4]
    float etr = cal_data[CAL_THRU][i][0] - cal_data[CAL_ISOLN][i][0];
 800751a:	ed93 7a00 	vldr	s14, [r3]
 800751e:	edd2 5a00 	vldr	s11, [r2]
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8007522:	ee76 7a66 	vsub.f32	s15, s12, s13
    float etr = cal_data[CAL_THRU][i][0] - cal_data[CAL_ISOLN][i][0];
 8007526:	ee37 7a65 	vsub.f32	s14, s14, s11
    float sq = etr * etr + eti * eti;
 800752a:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float invi = -eti / sq;
 800752e:	ee76 6ac6 	vsub.f32	s13, s13, s12
    float sq = etr * etr + eti * eti;
 8007532:	eee7 7a07 	vfma.f32	s15, s14, s14
  for (i = 0; i < sweep_points; i++)
 8007536:	3308      	adds	r3, #8
 8007538:	4299      	cmp	r1, r3
 800753a:	f102 0208 	add.w	r2, r2, #8
    float invr = etr / sq;
 800753e:	ee87 6a27 	vdiv.f32	s12, s14, s15
    float invi = -eti / sq;
 8007542:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    cal_data[ETERM_ET][i][0] = invr;
 8007546:	ed03 6a02 	vstr	s12, [r3, #-8]
    cal_data[ETERM_ET][i][1] = invi;
 800754a:	ed03 7a01 	vstr	s14, [r3, #-4]
  for (i = 0; i < sweep_points; i++)
 800754e:	d1e0      	bne.n	8007512 <cal_done+0x96>
  cal_status &= ~CALSTAT_THRU;
 8007550:	f024 0408 	bic.w	r4, r4, #8
  cal_status |= CALSTAT_ET;
 8007554:	f044 0480 	orr.w	r4, r4, #128	@ 0x80
  if (!(cal_status & CALSTAT_ER))
 8007558:	0662      	lsls	r2, r4, #25
  cal_status |= CALSTAT_ET;
 800755a:	84ac      	strh	r4, [r5, #36]	@ 0x24
  if (!(cal_status & CALSTAT_ER))
 800755c:	d4ad      	bmi.n	80074ba <cal_done+0x3e>
    eterm_set(ETERM_ER, 1.0, 0.0);
 800755e:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 8007562:	2002      	movs	r0, #2
 8007564:	f7fe fbca 	bl	8005cfc <eterm_set.constprop.0>
  if (!(cal_status & CALSTAT_ES))
 8007568:	06a3      	lsls	r3, r4, #26
 800756a:	d4a8      	bmi.n	80074be <cal_done+0x42>
    eterm_set(ETERM_ES, 0.0, 0.0);
 800756c:	ed9f 0a31 	vldr	s0, [pc, #196]	@ 8007634 <cal_done+0x1b8>
 8007570:	2001      	movs	r0, #1
 8007572:	f7fe fbc3 	bl	8005cfc <eterm_set.constprop.0>
 8007576:	e7a2      	b.n	80074be <cal_done+0x42>
    eterm_set(ETERM_ET, 1.0, 0.0);
 8007578:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 800757c:	2003      	movs	r0, #3
 800757e:	f7fe fbbd 	bl	8005cfc <eterm_set.constprop.0>
 8007582:	e798      	b.n	80074b6 <cal_done+0x3a>
    eterm_set(ETERM_EX, 0.0, 0.0);
 8007584:	ed9f 0a2b 	vldr	s0, [pc, #172]	@ 8007634 <cal_done+0x1b8>
 8007588:	2004      	movs	r0, #4
 800758a:	f7fe fbb7 	bl	8005cfc <eterm_set.constprop.0>
 800758e:	e77e      	b.n	800748e <cal_done+0x12>
    eterm_set(ETERM_ED, 0.0, 0.0);
 8007590:	ed9f 0a28 	vldr	s0, [pc, #160]	@ 8007634 <cal_done+0x1b8>
 8007594:	f7fe fbb2 	bl	8005cfc <eterm_set.constprop.0>
 8007598:	e777      	b.n	800748a <cal_done+0xe>
  for (i = 0; i < sweep_points; i++)
 800759a:	8b68      	ldrh	r0, [r5, #26]
 800759c:	b3e0      	cbz	r0, 8007618 <cal_done+0x19c>
 800759e:	4a24      	ldr	r2, [pc, #144]	@ (8007630 <cal_done+0x1b4>)
 80075a0:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 80075a4:	f602 5358 	addw	r3, r2, #3416	@ 0xd58
 80075a8:	f502 51cf 	add.w	r1, r2, #6624	@ 0x19e0
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 80075ac:	edd1 5a00 	vldr	s11, [r1]
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 80075b0:	ed91 4a01 	vldr	s8, [r1, #4]
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 80075b4:	ed93 7a00 	vldr	s14, [r3]
    float s11oi = cal_data[CAL_OPEN][i][1] - cal_data[ETERM_ED][i][1];
 80075b8:	edd3 7a01 	vldr	s15, [r3, #4]
 80075bc:	ed92 5a35 	vldr	s10, [r2, #212]	@ 0xd4
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 80075c0:	edd2 4a34 	vldr	s9, [r2, #208]	@ 0xd0
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 80075c4:	ee37 6a25 	vadd.f32	s12, s14, s11
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 80075c8:	ee77 6a84 	vadd.f32	s13, s15, s8
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 80075cc:	ee36 6a64 	vsub.f32	s12, s12, s9
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 80075d0:	ee76 6ac5 	vsub.f32	s13, s13, s10
    float denomi = s11oi - s11si;
 80075d4:	ee77 7ac4 	vsub.f32	s15, s15, s8
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 80075d8:	ee76 6ac5 	vsub.f32	s13, s13, s10
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 80075dc:	ee36 6a64 	vsub.f32	s12, s12, s9
    float denomr = s11or - s11sr;
 80075e0:	ee37 7a65 	vsub.f32	s14, s14, s11
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 80075e4:	ee26 5aa7 	vmul.f32	s10, s13, s15
    float d = denomr * denomr + denomi * denomi;
 80075e8:	ee67 5aa7 	vmul.f32	s11, s15, s15
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 80075ec:	ee67 7ac6 	vnmul.f32	s15, s15, s12
    float d = denomr * denomr + denomi * denomi;
 80075f0:	eee7 5a07 	vfma.f32	s11, s14, s14
  for (i = 0; i < sweep_points; i++)
 80075f4:	3208      	adds	r2, #8
 80075f6:	3308      	adds	r3, #8
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 80075f8:	eea6 5a07 	vfma.f32	s10, s12, s14
  for (i = 0; i < sweep_points; i++)
 80075fc:	4290      	cmp	r0, r2
 80075fe:	f101 0108 	add.w	r1, r1, #8
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 8007602:	eee6 7a87 	vfma.f32	s15, s13, s14
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 8007606:	eec5 6a25 	vdiv.f32	s13, s10, s11
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 800760a:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 800760e:	ed43 6a02 	vstr	s13, [r3, #-8]
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 8007612:	ed03 7a01 	vstr	s14, [r3, #-4]
  for (i = 0; i < sweep_points; i++)
 8007616:	d1c9      	bne.n	80075ac <cal_done+0x130>
  cal_status &= ~CALSTAT_OPEN;
 8007618:	f024 0402 	bic.w	r4, r4, #2
  cal_status |= CALSTAT_ES;
 800761c:	f044 0420 	orr.w	r4, r4, #32
    eterm_calc_er(-1);
 8007620:	f04f 30ff 	mov.w	r0, #4294967295
  cal_status |= CALSTAT_ES;
 8007624:	84ac      	strh	r4, [r5, #36]	@ 0x24
    eterm_calc_er(-1);
 8007626:	f7fd ff2f 	bl	8005488 <eterm_calc_er>
  if (cal_status & CALSTAT_THRU)
 800762a:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
    eterm_calc_er(-1);
 800762c:	e73f      	b.n	80074ae <cal_done+0x32>
 800762e:	bf00      	nop
 8007630:	20000aa8 	.word	0x20000aa8
 8007634:	00000000 	.word	0x00000000
 8007638:	200099f6 	.word	0x200099f6
 800763c:	20001800 	.word	0x20001800
 8007640:	20003110 	.word	0x20003110

08007644 <cmd_cal>:
  if (argc == 0)
 8007644:	b900      	cbnz	r0, 8007648 <cmd_cal+0x4>
 8007646:	4770      	bx	lr
{
 8007648:	b510      	push	{r4, lr}
 800764a:	460c      	mov	r4, r1
  request_to_redraw(REDRAW_CAL_STATUS);
 800764c:	2010      	movs	r0, #16
 800764e:	f004 f8cf 	bl	800b7f0 <request_to_redraw>
  switch (get_str_index(argv[0], cmd_cal_list))
 8007652:	491d      	ldr	r1, [pc, #116]	@ (80076c8 <cmd_cal+0x84>)
 8007654:	6820      	ldr	r0, [r4, #0]
 8007656:	f001 fa6d 	bl	8008b34 <get_str_index>
 800765a:	2808      	cmp	r0, #8
 800765c:	d80b      	bhi.n	8007676 <cmd_cal+0x32>
 800765e:	e8df f000 	tbb	[pc, r0]
 8007662:	140f      	.short	0x140f
 8007664:	28231e19 	.word	0x28231e19
 8007668:	052c      	.short	0x052c
 800766a:	0b          	.byte	0x0b
 800766b:	00          	.byte	0x00
    cal_status &= ~CALSTAT_APPLY;
 800766c:	4a17      	ldr	r2, [pc, #92]	@ (80076cc <cmd_cal+0x88>)
 800766e:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 8007670:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8007674:	8493      	strh	r3, [r2, #36]	@ 0x24
}
 8007676:	bd10      	pop	{r4, pc}
    cal_status = 0;
 8007678:	4b14      	ldr	r3, [pc, #80]	@ (80076cc <cmd_cal+0x88>)
 800767a:	2200      	movs	r2, #0
 800767c:	849a      	strh	r2, [r3, #36]	@ 0x24
}
 800767e:	bd10      	pop	{r4, pc}
 8007680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cal_collect(CAL_LOAD);
 8007684:	2000      	movs	r0, #0
 8007686:	f7ff bea9 	b.w	80073dc <cal_collect>
}
 800768a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cal_collect(CAL_OPEN);
 800768e:	2001      	movs	r0, #1
 8007690:	f7ff bea4 	b.w	80073dc <cal_collect>
}
 8007694:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cal_collect(CAL_SHORT);
 8007698:	2002      	movs	r0, #2
 800769a:	f7ff be9f 	b.w	80073dc <cal_collect>
}
 800769e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cal_collect(CAL_THRU);
 80076a2:	2003      	movs	r0, #3
 80076a4:	f7ff be9a 	b.w	80073dc <cal_collect>
}
 80076a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cal_collect(CAL_ISOLN);
 80076ac:	2004      	movs	r0, #4
 80076ae:	f7ff be95 	b.w	80073dc <cal_collect>
}
 80076b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cal_done();
 80076b6:	f7ff bee1 	b.w	800747c <cal_done>
    cal_status |= CALSTAT_APPLY;
 80076ba:	4a04      	ldr	r2, [pc, #16]	@ (80076cc <cmd_cal+0x88>)
 80076bc:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 80076be:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80076c2:	8493      	strh	r3, [r2, #36]	@ 0x24
}
 80076c4:	bd10      	pop	{r4, pc}
 80076c6:	bf00      	nop
 80076c8:	08013b64 	.word	0x08013b64
 80076cc:	20000aa8 	.word	0x20000aa8

080076d0 <get_trace_chname>:
  return trc_channel_name[trace[t].channel & 1];
 80076d0:	4b06      	ldr	r3, [pc, #24]	@ (80076ec <get_trace_chname+0x1c>)
 80076d2:	4a07      	ldr	r2, [pc, #28]	@ (80076f0 <get_trace_chname+0x20>)
 80076d4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80076d8:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80076dc:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 80076e0:	f003 0301 	and.w	r3, r3, #1
}
 80076e4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 80076e8:	4770      	bx	lr
 80076ea:	bf00      	nop
 80076ec:	20000aa8 	.word	0x20000aa8
 80076f0:	08013f08 	.word	0x08013f08

080076f4 <set_trace_channel>:
  if (trace[t].channel != channel)
 80076f4:	4b08      	ldr	r3, [pc, #32]	@ (8007718 <set_trace_channel+0x24>)
 80076f6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80076fa:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  channel &= 1;
 80076fe:	f001 0101 	and.w	r1, r1, #1
  if (trace[t].channel != channel)
 8007702:	f893 202a 	ldrb.w	r2, [r3, #42]	@ 0x2a
 8007706:	428a      	cmp	r2, r1
 8007708:	d100      	bne.n	800770c <set_trace_channel+0x18>
}
 800770a:	4770      	bx	lr
    request_to_redraw(REDRAW_MARKER | REDRAW_PLOT);
 800770c:	2021      	movs	r0, #33	@ 0x21
    trace[t].channel = channel;
 800770e:	f883 102a 	strb.w	r1, [r3, #42]	@ 0x2a
    request_to_redraw(REDRAW_MARKER | REDRAW_PLOT);
 8007712:	f004 b86d 	b.w	800b7f0 <request_to_redraw>
 8007716:	bf00      	nop
 8007718:	20000aa8 	.word	0x20000aa8

0800771c <set_active_trace>:
  if (current_trace == t)
 800771c:	4a05      	ldr	r2, [pc, #20]	@ (8007734 <set_active_trace+0x18>)
 800771e:	f992 101c 	ldrsb.w	r1, [r2, #28]
 8007722:	4281      	cmp	r1, r0
{
 8007724:	4603      	mov	r3, r0
  if (current_trace == t)
 8007726:	d003      	beq.n	8007730 <set_active_trace+0x14>
  request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE);
 8007728:	20a0      	movs	r0, #160	@ 0xa0
  current_trace = t;
 800772a:	7713      	strb	r3, [r2, #28]
  request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE);
 800772c:	f004 b860 	b.w	800b7f0 <request_to_redraw>
}
 8007730:	4770      	bx	lr
 8007732:	bf00      	nop
 8007734:	20000aa8 	.word	0x20000aa8

08007738 <set_trace_scale>:
  if (trace[t].scale != scale)
 8007738:	4b08      	ldr	r3, [pc, #32]	@ (800775c <set_trace_scale+0x24>)
 800773a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800773e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8007742:	edd3 7a0b 	vldr	s15, [r3, #44]	@ 0x2c
 8007746:	eef4 7a40 	vcmp.f32	s15, s0
 800774a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800774e:	d100      	bne.n	8007752 <set_trace_scale+0x1a>
}
 8007750:	4770      	bx	lr
    request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_PLOT);
 8007752:	20a1      	movs	r0, #161	@ 0xa1
    trace[t].scale = scale;
 8007754:	ed83 0a0b 	vstr	s0, [r3, #44]	@ 0x2c
    request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_PLOT);
 8007758:	f004 b84a 	b.w	800b7f0 <request_to_redraw>
 800775c:	20000aa8 	.word	0x20000aa8

08007760 <set_trace_refpos>:
  if (trace[t].refpos != refpos)
 8007760:	4b08      	ldr	r3, [pc, #32]	@ (8007784 <set_trace_refpos+0x24>)
 8007762:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8007766:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800776a:	edd3 7a0c 	vldr	s15, [r3, #48]	@ 0x30
 800776e:	eef4 7a40 	vcmp.f32	s15, s0
 8007772:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007776:	d100      	bne.n	800777a <set_trace_refpos+0x1a>
}
 8007778:	4770      	bx	lr
    request_to_redraw(REDRAW_REFERENCE | REDRAW_GRID_VALUE | REDRAW_PLOT);
 800777a:	20c1      	movs	r0, #193	@ 0xc1
    trace[t].refpos = refpos;
 800777c:	ed83 0a0c 	vstr	s0, [r3, #48]	@ 0x30
    request_to_redraw(REDRAW_REFERENCE | REDRAW_GRID_VALUE | REDRAW_PLOT);
 8007780:	f004 b836 	b.w	800b7f0 <request_to_redraw>
 8007784:	20000aa8 	.word	0x20000aa8

08007788 <set_trace_type>:
{
 8007788:	b570      	push	{r4, r5, r6, lr}
  bool update = trace[t].type != type || trace[t].channel != channel;
 800778a:	4d15      	ldr	r5, [pc, #84]	@ (80077e0 <set_trace_type+0x58>)
  channel &= 1;
 800778c:	f002 0601 	and.w	r6, r2, #1
  bool update = trace[t].type != type || trace[t].channel != channel;
 8007790:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8007794:	eb05 0c82 	add.w	ip, r5, r2, lsl #2
{
 8007798:	4604      	mov	r4, r0
  bool update = trace[t].type != type || trace[t].channel != channel;
 800779a:	f89c 2029 	ldrb.w	r2, [ip, #41]	@ 0x29
 800779e:	428a      	cmp	r2, r1
 80077a0:	d019      	beq.n	80077d6 <set_trace_type+0x4e>
    set_trace_refpos(t, trace_info_list[type].refpos);
 80077a2:	4d10      	ldr	r5, [pc, #64]	@ (80077e4 <set_trace_type+0x5c>)
    trace[t].type = type;
 80077a4:	f88c 1029 	strb.w	r1, [ip, #41]	@ 0x29
    set_trace_refpos(t, trace_info_list[type].refpos);
 80077a8:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80077ac:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 80077b0:	ed95 0a04 	vldr	s0, [r5, #16]
 80077b4:	f7ff ffd4 	bl	8007760 <set_trace_refpos>
    set_trace_scale(t, trace_info_list[type].scale_unit);
 80077b8:	4620      	mov	r0, r4
 80077ba:	ed95 0a05 	vldr	s0, [r5, #20]
 80077be:	f7ff ffbb 	bl	8007738 <set_trace_scale>
    request_to_redraw(REDRAW_AREA | REDRAW_PLOT | REDRAW_BACKUP); // need for update grid
 80077c2:	f240 4003 	movw	r0, #1027	@ 0x403
 80077c6:	f004 f813 	bl	800b7f0 <request_to_redraw>
  set_trace_channel(t, channel);
 80077ca:	4631      	mov	r1, r6
 80077cc:	4620      	mov	r0, r4
}
 80077ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  set_trace_channel(t, channel);
 80077d2:	f7ff bf8f 	b.w	80076f4 <set_trace_channel>
  bool update = trace[t].type != type || trace[t].channel != channel;
 80077d6:	f89c 302a 	ldrb.w	r3, [ip, #42]	@ 0x2a
 80077da:	429e      	cmp	r6, r3
 80077dc:	d1f5      	bne.n	80077ca <set_trace_type+0x42>
}
 80077de:	bd70      	pop	{r4, r5, r6, pc}
 80077e0:	20000aa8 	.word	0x20000aa8
 80077e4:	08014540 	.word	0x08014540

080077e8 <Thread1>:
{
 80077e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80077ec:	ed2d 8b0a 	vpush	{d8-d12}
 80077f0:	b083      	sub	sp, #12
  ui_init();
 80077f2:	f008 f8db 	bl	800f9ac <ui_init>
  lcd_show_logo();
 80077f6:	f008 ff8b 	bl	8010710 <lcd_show_logo>
  redraw_request |= REDRAW_ALL;
 80077fa:	4a9e      	ldr	r2, [pc, #632]	@ (8007a74 <Thread1+0x28c>)
    markers[m].enabled = FALSE;
 80077fc:	f8df 82e4 	ldr.w	r8, [pc, #740]	@ 8007ae4 <Thread1+0x2fc>
  redraw_request |= REDRAW_ALL;
 8007800:	7813      	ldrb	r3, [r2, #0]
            float refpos = y_max - (max_p / scale);
 8007802:	eddf 9a9d 	vldr	s19, [pc, #628]	@ 8007a78 <Thread1+0x290>
            if (vna_fabsf(refpos - trace[t].refpos) > 0.02f)
 8007806:	ed9f 9a9d 	vldr	s18, [pc, #628]	@ 8007a7c <Thread1+0x294>
                vna_fabsf(scale - trace[t].scale) > trace[t].scale * 0.03f)
 800780a:	ed9f aa9d 	vldr	s20, [pc, #628]	@ 8007a80 <Thread1+0x298>
            float min_p = 0.0f, max_p = 0.0f;
 800780e:	eddf aa9d 	vldr	s21, [pc, #628]	@ 8007a84 <Thread1+0x29c>
    if (swr > 0.0f && swr < 9999.0f && swr > max_swr)
 8007812:	eddf 8a9d 	vldr	s17, [pc, #628]	@ 8007a88 <Thread1+0x2a0>
 8007816:	4f9d      	ldr	r7, [pc, #628]	@ (8007a8c <Thread1+0x2a4>)
 8007818:	4e9d      	ldr	r6, [pc, #628]	@ (8007a90 <Thread1+0x2a8>)
  redraw_request |= REDRAW_ALL;
 800781a:	f043 031a 	orr.w	r3, r3, #26
    markers[m].enabled = FALSE;
 800781e:	2400      	movs	r4, #0
  redraw_request |= REDRAW_ALL;
 8007820:	7013      	strb	r3, [r2, #0]
  plot_init();
 8007822:	f005 fcd1 	bl	800d1c8 <plot_init>
  active_marker = MARKER_INVALID;
 8007826:	23ff      	movs	r3, #255	@ 0xff
  request_to_redraw(REDRAW_MARKER | REDRAW_AREA);
 8007828:	2022      	movs	r0, #34	@ 0x22
    markers[m].enabled = FALSE;
 800782a:	f888 4058 	strb.w	r4, [r8, #88]	@ 0x58
 800782e:	f888 4060 	strb.w	r4, [r8, #96]	@ 0x60
 8007832:	f888 4068 	strb.w	r4, [r8, #104]	@ 0x68
 8007836:	f888 4070 	strb.w	r4, [r8, #112]	@ 0x70
 800783a:	f888 4078 	strb.w	r4, [r8, #120]	@ 0x78
 800783e:	f888 4080 	strb.w	r4, [r8, #128]	@ 0x80
 8007842:	f888 4088 	strb.w	r4, [r8, #136]	@ 0x88
 8007846:	f888 4090 	strb.w	r4, [r8, #144]	@ 0x90
  active_marker = MARKER_INVALID;
 800784a:	f888 301d 	strb.w	r3, [r8, #29]
  request_to_redraw(REDRAW_MARKER | REDRAW_AREA);
 800784e:	f003 ffcf 	bl	800b7f0 <request_to_redraw>
  HB9II_mode = 1;
 8007852:	4a90      	ldr	r2, [pc, #576]	@ (8007a94 <Thread1+0x2ac>)
 8007854:	2301      	movs	r3, #1
 8007856:	6013      	str	r3, [r2, #0]
  targetting_mode = false; // to ignore screen touch on mode 2 , double usage, could be replaced by HB9II_mode
 8007858:	4a8f      	ldr	r2, [pc, #572]	@ (8007a98 <Thread1+0x2b0>)
 800785a:	7014      	strb	r4, [r2, #0]
  doOnceOnly_In_Mode2 = true;
 800785c:	4a8f      	ldr	r2, [pc, #572]	@ (8007a9c <Thread1+0x2b4>)
 800785e:	4c90      	ldr	r4, [pc, #576]	@ (8007aa0 <Thread1+0x2b8>)
 8007860:	7013      	strb	r3, [r2, #0]
 8007862:	e07e      	b.n	8007962 <Thread1+0x17a>
      if (doOnceOnly_In_Mode2 == true)
 8007864:	4b8d      	ldr	r3, [pc, #564]	@ (8007a9c <Thread1+0x2b4>)
 8007866:	781b      	ldrb	r3, [r3, #0]
 8007868:	2b00      	cmp	r3, #0
 800786a:	f040 80d4 	bne.w	8007a16 <Thread1+0x22e>
      uint16_t mask = get_sweep_mask();
 800786e:	f7fe fa17 	bl	8005ca0 <get_sweep_mask>
 8007872:	4601      	mov	r1, r0
      completed = sweep(true, mask);
 8007874:	2001      	movs	r0, #1
 8007876:	f7fe febd 	bl	80065f4 <sweep>
      displayTargetFrequency(target_frequency);
 800787a:	4b8a      	ldr	r3, [pc, #552]	@ (8007aa4 <Thread1+0x2bc>)
      completed = sweep(true, mask);
 800787c:	4605      	mov	r5, r0
      displayTargetFrequency(target_frequency);
 800787e:	6818      	ldr	r0, [r3, #0]
 8007880:	f7fe fc3e 	bl	8006100 <displayTargetFrequency>
      if (completed)
 8007884:	b32d      	cbz	r5, 80078d2 <Thread1+0xea>
        float im = measured[0][0][1];
 8007886:	4b88      	ldr	r3, [pc, #544]	@ (8007aa8 <Thread1+0x2c0>)
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 8007888:	eddf 6a88 	vldr	s13, [pc, #544]	@ 8007aac <Thread1+0x2c4>
        float im = measured[0][0][1];
 800788c:	edd3 7a01 	vldr	s15, [r3, #4]
        float re = measured[0][0][0];
 8007890:	ed93 7a00 	vldr	s14, [r3]
        float mag = sqrtf(re * re + im * im);
 8007894:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8007898:	eee7 7a07 	vfma.f32	s15, s14, s14
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 800789c:	eef4 7ae6 	vcmpe.f32	s15, s13
 80078a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80078a4:	f140 81d7 	bpl.w	8007c56 <Thread1+0x46e>
        float mag = sqrtf(re * re + im * im);
 80078a8:	eeb1 7ae7 	vsqrt.f32	s14, s15
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 80078ac:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80078b0:	ee77 6a27 	vadd.f32	s13, s14, s15
 80078b4:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80078b8:	ee86 8aa7 	vdiv.f32	s16, s13, s15
        drawBarGraph(swr);
 80078bc:	eeb0 0a48 	vmov.f32	s0, s16
 80078c0:	f7fe fa74 	bl	8005dac <drawBarGraph>
        displaySWR(swr);
 80078c4:	eeb0 0a48 	vmov.f32	s0, s16
 80078c8:	f7fe fb1e 	bl	8005f08 <displaySWR>
        doOnceOnly_In_Mode2 = false;
 80078cc:	4a73      	ldr	r2, [pc, #460]	@ (8007a9c <Thread1+0x2b4>)
 80078ce:	2300      	movs	r3, #0
 80078d0:	7013      	strb	r3, [r2, #0]
      int evt = touch_checkHB9IIU();
 80078d2:	f007 f819 	bl	800e908 <touch_checkHB9IIU>
      if (evt == 2) // PRESSED
 80078d6:	2802      	cmp	r0, #2
 80078d8:	d13d      	bne.n	8007956 <Thread1+0x16e>
        int px = g_touch_px;
 80078da:	4b75      	ldr	r3, [pc, #468]	@ (8007ab0 <Thread1+0x2c8>)
 80078dc:	681d      	ldr	r5, [r3, #0]
        int py = g_touch_py;
 80078de:	4b75      	ldr	r3, [pc, #468]	@ (8007ab4 <Thread1+0x2cc>)
        if (px >= SWR_TOUCH_X0 && px < (SWR_TOUCH_X0 + SWR_TOUCH_W) &&
 80078e0:	f5b5 7ff0 	cmp.w	r5, #480	@ 0x1e0
        int py = g_touch_py;
 80078e4:	681b      	ldr	r3, [r3, #0]
        if (px >= SWR_TOUCH_X0 && px < (SWR_TOUCH_X0 + SWR_TOUCH_W) &&
 80078e6:	d271      	bcs.n	80079cc <Thread1+0x1e4>
 80078e8:	2b81      	cmp	r3, #129	@ 0x81
 80078ea:	dd6f      	ble.n	80079cc <Thread1+0x1e4>
            py >= SWR_TOUCH_Y0 && py < (SWR_TOUCH_Y0 + SWR_TOUCH_H))
 80078ec:	2bb3      	cmp	r3, #179	@ 0xb3
 80078ee:	dc32      	bgt.n	8007956 <Thread1+0x16e>
          targetting_mode = false;
 80078f0:	4b69      	ldr	r3, [pc, #420]	@ (8007a98 <Thread1+0x2b0>)
          redraw_request = REDRAW_ALL; // <-- critical: don't OR with old redraw bits
 80078f2:	4a60      	ldr	r2, [pc, #384]	@ (8007a74 <Thread1+0x28c>)
          targetting_mode = false;
 80078f4:	2500      	movs	r5, #0
 80078f6:	701d      	strb	r5, [r3, #0]
          drawTheSWRLines = false;
 80078f8:	4b6f      	ldr	r3, [pc, #444]	@ (8007ab8 <Thread1+0x2d0>)
          sweep_mode = 0; // <-- critical: purge stale sweep flags
 80078fa:	703d      	strb	r5, [r7, #0]
          drawTheSWRLines = false;
 80078fc:	701d      	strb	r5, [r3, #0]
          mla_resonance_locked = false;
 80078fe:	4b6f      	ldr	r3, [pc, #444]	@ (8007abc <Thread1+0x2d4>)
 8007900:	701d      	strb	r5, [r3, #0]
          mla_res_ref_freq = 0;
 8007902:	4b6f      	ldr	r3, [pc, #444]	@ (8007ac0 <Thread1+0x2d8>)
 8007904:	601d      	str	r5, [r3, #0]
          mla_res_stable_count = 0;
 8007906:	4b6f      	ldr	r3, [pc, #444]	@ (8007ac4 <Thread1+0x2dc>)
 8007908:	701d      	strb	r5, [r3, #0]
          mla_no_dip_count = 0;
 800790a:	4b6f      	ldr	r3, [pc, #444]	@ (8007ac8 <Thread1+0x2e0>)
 800790c:	701d      	strb	r5, [r3, #0]
          mla_autozone_stage = 0;
 800790e:	4b6f      	ldr	r3, [pc, #444]	@ (8007acc <Thread1+0x2e4>)
 8007910:	701d      	strb	r5, [r3, #0]
          HB9II_mode = 1;
 8007912:	4b60      	ldr	r3, [pc, #384]	@ (8007a94 <Thread1+0x2ac>)
 8007914:	f04f 0901 	mov.w	r9, #1
          sweep_points = 401;
 8007918:	f240 1091 	movw	r0, #401	@ 0x191
          HB9II_mode = 1;
 800791c:	f8c3 9000 	str.w	r9, [r3]
          redraw_request = REDRAW_ALL; // <-- critical: don't OR with old redraw bits
 8007920:	231a      	movs	r3, #26
 8007922:	7013      	strb	r3, [r2, #0]
          sweep_points = 401;
 8007924:	f8a8 001a 	strh.w	r0, [r8, #26]
          set_sweep_points(401);
 8007928:	f7ff fbea 	bl	8007100 <set_sweep_points>
          set_sweep_frequency(ST_START, 3000000); // 3 MHz
 800792c:	4968      	ldr	r1, [pc, #416]	@ (8007ad0 <Thread1+0x2e8>)
 800792e:	4628      	mov	r0, r5
 8007930:	f7ff fc74 	bl	800721c <set_sweep_frequency>
          set_sweep_frequency(ST_STOP, 30000000); // 30 MHz
 8007934:	4967      	ldr	r1, [pc, #412]	@ (8007ad4 <Thread1+0x2ec>)
 8007936:	4648      	mov	r0, r9
 8007938:	f7ff fc70 	bl	800721c <set_sweep_frequency>
          lcd_clear_screen();
 800793c:	f008 fb7a 	bl	8010034 <lcd_clear_screen>
          ui_close_all();
 8007940:	f008 f85e 	bl	800fa00 <ui_close_all>
          plot_init();
 8007944:	f005 fc40 	bl	800d1c8 <plot_init>
          redraw_request |= REDRAW_ALL;
 8007948:	4a4a      	ldr	r2, [pc, #296]	@ (8007a74 <Thread1+0x28c>)
          sweep_mode = (SWEEP_ENABLE | SWEEP_ONCE);
 800794a:	2303      	movs	r3, #3
 800794c:	703b      	strb	r3, [r7, #0]
          redraw_request |= REDRAW_ALL;
 800794e:	7813      	ldrb	r3, [r2, #0]
 8007950:	f043 031a 	orr.w	r3, r3, #26
 8007954:	7013      	strb	r3, [r2, #0]
      chThdSleepMilliseconds(40);
 8007956:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 800795a:	f7f9 fa99 	bl	8000e90 <chThdSleep>
    if (HB9II_mode == 1)
 800795e:	4b4d      	ldr	r3, [pc, #308]	@ (8007a94 <Thread1+0x2ac>)
 8007960:	681b      	ldr	r3, [r3, #0]
 8007962:	2b01      	cmp	r3, #1
 8007964:	d004      	beq.n	8007970 <Thread1+0x188>
    if (HB9II_mode == 2)
 8007966:	2b02      	cmp	r3, #2
 8007968:	f43f af7c 	beq.w	8007864 <Thread1+0x7c>
    if (HB9II_mode == 1)
 800796c:	2b01      	cmp	r3, #1
 800796e:	d1fd      	bne.n	800796c <Thread1+0x184>
      doOnceOnly_In_Mode2 = true;
 8007970:	4b4a      	ldr	r3, [pc, #296]	@ (8007a9c <Thread1+0x2b4>)
 8007972:	f04f 0901 	mov.w	r9, #1
 8007976:	f883 9000 	strb.w	r9, [r3]
      uint16_t mask = get_sweep_mask();
 800797a:	f7fe f991 	bl	8005ca0 <get_sweep_mask>
      if (sweep_mode & (SWEEP_ENABLE | SWEEP_ONCE))
 800797e:	783d      	ldrb	r5, [r7, #0]
 8007980:	f015 0503 	ands.w	r5, r5, #3
 8007984:	f040 815d 	bne.w	8007c42 <Thread1+0x45a>
 8007988:	bf30      	wfi
      while (shell_function)
 800798a:	6823      	ldr	r3, [r4, #0]
 800798c:	b17b      	cbz	r3, 80079ae <Thread1+0x1c6>
        shell_function = 0;
 800798e:	f04f 0900 	mov.w	r9, #0
        shell_function(shell_nargs - 1, &shell_args[1]);
 8007992:	8830      	ldrh	r0, [r6, #0]
 8007994:	6823      	ldr	r3, [r4, #0]
 8007996:	4950      	ldr	r1, [pc, #320]	@ (8007ad8 <Thread1+0x2f0>)
 8007998:	3801      	subs	r0, #1
 800799a:	4798      	blx	r3
  chThdDequeueNextI(tqp, msg);
 800799c:	484f      	ldr	r0, [pc, #316]	@ (8007adc <Thread1+0x2f4>)
        shell_function = 0;
 800799e:	f8c4 9000 	str.w	r9, [r4]
 80079a2:	2100      	movs	r1, #0
 80079a4:	f7f9 fa94 	bl	8000ed0 <chThdDequeueNextI>
      while (shell_function)
 80079a8:	6823      	ldr	r3, [r4, #0]
 80079aa:	2b00      	cmp	r3, #0
 80079ac:	d1f1      	bne.n	8007992 <Thread1+0x1aa>
      sweep_mode |= SWEEP_UI_MODE;
 80079ae:	783b      	ldrb	r3, [r7, #0]
 80079b0:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 80079b4:	703b      	strb	r3, [r7, #0]
      ui_process();
 80079b6:	f007 ffa1 	bl	800f8fc <ui_process>
      sweep_mode &= ~SWEEP_UI_MODE;
 80079ba:	783b      	ldrb	r3, [r7, #0]
 80079bc:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80079c0:	703b      	strb	r3, [r7, #0]
      if (completed)
 80079c2:	2d00      	cmp	r5, #0
 80079c4:	d143      	bne.n	8007a4e <Thread1+0x266>
    if (HB9II_mode == 2)
 80079c6:	4b33      	ldr	r3, [pc, #204]	@ (8007a94 <Thread1+0x2ac>)
 80079c8:	681b      	ldr	r3, [r3, #0]
 80079ca:	e7cc      	b.n	8007966 <Thread1+0x17e>
  if (py >= topY && py < topY + boxH)
 80079cc:	2b0a      	cmp	r3, #10
 80079ce:	ddc2      	ble.n	8007956 <Thread1+0x16e>
 80079d0:	2b20      	cmp	r3, #32
 80079d2:	f300 81e8 	bgt.w	8007da6 <Thread1+0x5be>
    dir = +1; // upper = increment
 80079d6:	f04f 0c01 	mov.w	ip, #1
  int x = xBase;
 80079da:	22c8      	movs	r2, #200	@ 0xc8
  int digitIdx = -1;
 80079dc:	f04f 30ff 	mov.w	r0, #4294967295
  for (int sym = 0; sym < 10; sym++)
 80079e0:	2300      	movs	r3, #0
    const int isDot = (sym == 2) || (sym == 6);
 80079e2:	f023 0104 	bic.w	r1, r3, #4
 80079e6:	2902      	cmp	r1, #2
 80079e8:	d012      	beq.n	8007a10 <Thread1+0x228>
      if (px >= bx0 && px < bx1)
 80079ea:	4295      	cmp	r5, r2
      int bx1 = bx0 + boxW;
 80079ec:	f102 0114 	add.w	r1, r2, #20
  for (int sym = 0; sym < 10; sym++)
 80079f0:	f103 0301 	add.w	r3, r3, #1
      digitIdx++;
 80079f4:	f100 0001 	add.w	r0, r0, #1
      x += cw;
 80079f8:	f102 0215 	add.w	r2, r2, #21
      if (px >= bx0 && px < bx1)
 80079fc:	dd02      	ble.n	8007a04 <Thread1+0x21c>
 80079fe:	428d      	cmp	r5, r1
 8007a00:	f2c0 83d0 	blt.w	80081a4 <Thread1+0x9bc>
  for (int sym = 0; sym < 10; sym++)
 8007a04:	2b0a      	cmp	r3, #10
 8007a06:	d0a6      	beq.n	8007956 <Thread1+0x16e>
    const int isDot = (sym == 2) || (sym == 6);
 8007a08:	f023 0104 	bic.w	r1, r3, #4
 8007a0c:	2902      	cmp	r1, #2
 8007a0e:	d1ec      	bne.n	80079ea <Thread1+0x202>
      x += (cw / 2); // '.' is narrower (same as your working hitbox code)
 8007a10:	320a      	adds	r2, #10
  for (int sym = 0; sym < 10; sym++)
 8007a12:	3301      	adds	r3, #1
 8007a14:	e7e5      	b.n	80079e2 <Thread1+0x1fa>
        targetting_mode = true;
 8007a16:	4b20      	ldr	r3, [pc, #128]	@ (8007a98 <Thread1+0x2b0>)
 8007a18:	2501      	movs	r5, #1
 8007a1a:	701d      	strb	r5, [r3, #0]
        set_sweep_frequency(ST_START, target_frequency);
 8007a1c:	4b21      	ldr	r3, [pc, #132]	@ (8007aa4 <Thread1+0x2bc>)
 8007a1e:	2000      	movs	r0, #0
 8007a20:	6819      	ldr	r1, [r3, #0]
 8007a22:	f7ff fbfb 	bl	800721c <set_sweep_frequency>
        set_sweep_frequency(ST_STOP, target_frequency);
 8007a26:	4b1f      	ldr	r3, [pc, #124]	@ (8007aa4 <Thread1+0x2bc>)
 8007a28:	4628      	mov	r0, r5
 8007a2a:	6819      	ldr	r1, [r3, #0]
 8007a2c:	f7ff fbf6 	bl	800721c <set_sweep_frequency>
        lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8007a30:	2100      	movs	r1, #0
 8007a32:	4608      	mov	r0, r1
        sweep_points = 1;
 8007a34:	f8a8 501a 	strh.w	r5, [r8, #26]
        lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8007a38:	f008 fb62 	bl	8010100 <lcd_set_colors>
        lcd_fill(0, 0, LCD_WIDTH, LCD_HEIGHT);
 8007a3c:	2100      	movs	r1, #0
 8007a3e:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 8007a42:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8007a46:	4608      	mov	r0, r1
 8007a48:	f008 fa54 	bl	800fef4 <lcd_fill>
 8007a4c:	e70f      	b.n	800786e <Thread1+0x86>
  for (int i = 0; i < sweep_points; i++)
 8007a4e:	f8b8 301a 	ldrh.w	r3, [r8, #26]
 8007a52:	9300      	str	r3, [sp, #0]
 8007a54:	2b00      	cmp	r3, #0
 8007a56:	f000 8101 	beq.w	8007c5c <Thread1+0x474>
 8007a5a:	f8df a04c 	ldr.w	sl, [pc, #76]	@ 8007aa8 <Thread1+0x2c0>
 8007a5e:	9501      	str	r5, [sp, #4]
  float best_mag2 = 0.0f;
 8007a60:	eddf 6a1f 	vldr	s13, [pc, #124]	@ 8007ae0 <Thread1+0x2f8>
  for (int i = 0; i < sweep_points; i++)
 8007a64:	4655      	mov	r5, sl
  int best = -1;
 8007a66:	f04f 3bff 	mov.w	fp, #4294967295
  for (int i = 0; i < sweep_points; i++)
 8007a6a:	f04f 0900 	mov.w	r9, #0
 8007a6e:	469a      	mov	sl, r3
 8007a70:	e049      	b.n	8007b06 <Thread1+0x31e>
 8007a72:	bf00      	nop
 8007a74:	20004f51 	.word	0x20004f51
 8007a78:	40e66666 	.word	0x40e66666
 8007a7c:	3ca3d70a 	.word	0x3ca3d70a
 8007a80:	3cf5c28f 	.word	0x3cf5c28f
 8007a84:	3d969697 	.word	0x3d969697
 8007a88:	461c3c00 	.word	0x461c3c00
 8007a8c:	200003c4 	.word	0x200003c4
 8007a90:	20006884 	.word	0x20006884
 8007a94:	200068ac 	.word	0x200068ac
 8007a98:	200003d6 	.word	0x200003d6
 8007a9c:	200068b0 	.word	0x200068b0
 8007aa0:	20006880 	.word	0x20006880
 8007aa4:	200068a8 	.word	0x200068a8
 8007aa8:	20004f54 	.word	0x20004f54
 8007aac:	3f7f7cfe 	.word	0x3f7f7cfe
 8007ab0:	200089b8 	.word	0x200089b8
 8007ab4:	200089b4 	.word	0x200089b4
 8007ab8:	2000686c 	.word	0x2000686c
 8007abc:	20006875 	.word	0x20006875
 8007ac0:	20006870 	.word	0x20006870
 8007ac4:	20006874 	.word	0x20006874
 8007ac8:	2000686e 	.word	0x2000686e
 8007acc:	2000686d 	.word	0x2000686d
 8007ad0:	002dc6c0 	.word	0x002dc6c0
 8007ad4:	01c9c380 	.word	0x01c9c380
 8007ad8:	2000688c 	.word	0x2000688c
 8007adc:	2000689c 	.word	0x2000689c
 8007ae0:	00000000 	.word	0x00000000
 8007ae4:	20000aa8 	.word	0x20000aa8
      best = i;
 8007ae8:	eef4 7ae6 	vcmpe.f32	s15, s13
 8007aec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007af0:	bf48      	it	mi
 8007af2:	46cb      	movmi	fp, r9
 8007af4:	bf48      	it	mi
 8007af6:	eef0 6a67 	vmovmi.f32	s13, s15
  for (int i = 0; i < sweep_points; i++)
 8007afa:	f109 0901 	add.w	r9, r9, #1
 8007afe:	45d1      	cmp	r9, sl
 8007b00:	f105 0508 	add.w	r5, r5, #8
 8007b04:	d019      	beq.n	8007b3a <Thread1+0x352>
    const freq_t f = getFrequency((uint16_t)i);
 8007b06:	fa1f f089 	uxth.w	r0, r9
 8007b0a:	f7fe fd57 	bl	80065bc <getFrequency>
    if (f == 0)
 8007b0e:	2800      	cmp	r0, #0
 8007b10:	d0f3      	beq.n	8007afa <Thread1+0x312>
    const float im = measured[0][i][1];
 8007b12:	edd5 7a01 	vldr	s15, [r5, #4]
    const float re = measured[0][i][0];
 8007b16:	ed95 7a00 	vldr	s14, [r5]
    const float mag2 = (re * re) + (im * im);
 8007b1a:	ee67 7aa7 	vmul.f32	s15, s15, s15
    if (best < 0 || mag2 < best_mag2)
 8007b1e:	f1bb 3fff 	cmp.w	fp, #4294967295
    const float mag2 = (re * re) + (im * im);
 8007b22:	eee7 7a07 	vfma.f32	s15, s14, s14
    if (best < 0 || mag2 < best_mag2)
 8007b26:	d1df      	bne.n	8007ae8 <Thread1+0x300>
      best = i;
 8007b28:	46cb      	mov	fp, r9
  for (int i = 0; i < sweep_points; i++)
 8007b2a:	f109 0901 	add.w	r9, r9, #1
 8007b2e:	45d1      	cmp	r9, sl
      best_mag2 = mag2;
 8007b30:	eef0 6a67 	vmov.f32	s13, s15
  for (int i = 0; i < sweep_points; i++)
 8007b34:	f105 0508 	add.w	r5, r5, #8
 8007b38:	d1e5      	bne.n	8007b06 <Thread1+0x31e>
  if (best >= 0)
 8007b3a:	f1bb 3fff 	cmp.w	fp, #4294967295
 8007b3e:	9d01      	ldr	r5, [sp, #4]
 8007b40:	f000 808c 	beq.w	8007c5c <Thread1+0x474>
    mla_res_idx = (int16_t)best;
 8007b44:	4bb0      	ldr	r3, [pc, #704]	@ (8007e08 <Thread1+0x620>)
    mla_res_freq = getFrequency((uint16_t)best);
 8007b46:	fa1f fa8b 	uxth.w	sl, fp
    mla_res_idx = (int16_t)best;
 8007b4a:	fa0f f98b 	sxth.w	r9, fp
    mla_res_freq = getFrequency((uint16_t)best);
 8007b4e:	4650      	mov	r0, sl
    mla_res_idx = (int16_t)best;
 8007b50:	f8a3 9000 	strh.w	r9, [r3]
    mla_res_freq = getFrequency((uint16_t)best);
 8007b54:	f7fe fd32 	bl	80065bc <getFrequency>
 8007b58:	4bac      	ldr	r3, [pc, #688]	@ (8007e0c <Thread1+0x624>)
 8007b5a:	6018      	str	r0, [r3, #0]
        target_frequency = mla_res_freq;
 8007b5c:	4bac      	ldr	r3, [pc, #688]	@ (8007e10 <Thread1+0x628>)
  if (mla_res_idx < 0 || mla_res_idx >= (int16_t)sweep_points)
 8007b5e:	f1b9 0f00 	cmp.w	r9, #0
        target_frequency = mla_res_freq;
 8007b62:	6018      	str	r0, [r3, #0]
  if (mla_res_idx < 0 || mla_res_idx >= (int16_t)sweep_points)
 8007b64:	f2c0 8083 	blt.w	8007c6e <Thread1+0x486>
 8007b68:	f9bd 3000 	ldrsh.w	r3, [sp]
 8007b6c:	454b      	cmp	r3, r9
 8007b6e:	dd7e      	ble.n	8007c6e <Thread1+0x486>
  float swr = getSWRfromIndex((uint16_t)mla_res_idx);
 8007b70:	4650      	mov	r0, sl
 8007b72:	f7fd fc47 	bl	8005404 <getSWRfromIndex>
  if (swr <= 0.0f || swr > 50.0f)
 8007b76:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007b7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007b7e:	d976      	bls.n	8007c6e <Thread1+0x486>
 8007b80:	eddf 7aa4 	vldr	s15, [pc, #656]	@ 8007e14 <Thread1+0x62c>
 8007b84:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8007b88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007b8c:	dc6f      	bgt.n	8007c6e <Thread1+0x486>
        mla_res_swr = mla_calc_swr_at_resonance_after_sweep();
 8007b8e:	4ba2      	ldr	r3, [pc, #648]	@ (8007e18 <Thread1+0x630>)
 8007b90:	ed83 0a00 	vstr	s0, [r3]
        mla_update_bandwidth_swr2();
 8007b94:	f7ff f8ea 	bl	8006d6c <mla_update_bandwidth_swr2>
        if (!mla_resonance_locked)
 8007b98:	4ba0      	ldr	r3, [pc, #640]	@ (8007e1c <Thread1+0x634>)
 8007b9a:	7818      	ldrb	r0, [r3, #0]
 8007b9c:	2800      	cmp	r0, #0
 8007b9e:	d069      	beq.n	8007c74 <Thread1+0x48c>
        if (mla_resonance_locked && mla_autozone_stage < 3)
 8007ba0:	4b9f      	ldr	r3, [pc, #636]	@ (8007e20 <Thread1+0x638>)
 8007ba2:	f893 9000 	ldrb.w	r9, [r3]
 8007ba6:	f1b9 0f02 	cmp.w	r9, #2
 8007baa:	f240 824b 	bls.w	8008044 <Thread1+0x85c>
          int type = trace[t].type;
 8007bae:	f898 3029 	ldrb.w	r3, [r8, #41]	@ 0x29
          get_value_cb_t cb = trace_info_list[type].get_value_cb;
 8007bb2:	4a9c      	ldr	r2, [pc, #624]	@ (8007e24 <Thread1+0x63c>)
 8007bb4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8007bb8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8007bbc:	699a      	ldr	r2, [r3, #24]
          if (cb)
 8007bbe:	2a00      	cmp	r2, #0
 8007bc0:	f040 817a 	bne.w	8007eb8 <Thread1+0x6d0>
          int type = trace[t].type;
 8007bc4:	f898 304d 	ldrb.w	r3, [r8, #77]	@ 0x4d
          get_value_cb_t cb = trace_info_list[type].get_value_cb;
 8007bc8:	4a96      	ldr	r2, [pc, #600]	@ (8007e24 <Thread1+0x63c>)
 8007bca:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8007bce:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8007bd2:	f8d3 b018 	ldr.w	fp, [r3, #24]
          if (cb)
 8007bd6:	f1bb 0f00 	cmp.w	fp, #0
 8007bda:	f040 80ff 	bne.w	8007ddc <Thread1+0x5f4>
          drawTheSWRLines = false;
 8007bde:	4a92      	ldr	r2, [pc, #584]	@ (8007e28 <Thread1+0x640>)
 8007be0:	2300      	movs	r3, #0
        request_to_redraw(REDRAW_BACKUP | REDRAW_AREA);
 8007be2:	f240 4002 	movw	r0, #1026	@ 0x402
          drawTheSWRLines = false;
 8007be6:	7013      	strb	r3, [r2, #0]
        request_to_redraw(REDRAW_BACKUP | REDRAW_AREA);
 8007be8:	f003 fe02 	bl	800b7f0 <request_to_redraw>
             (mla_res_stable_count > 0) &&
 8007bec:	4b8b      	ldr	r3, [pc, #556]	@ (8007e1c <Thread1+0x634>)
 8007bee:	781b      	ldrb	r3, [r3, #0]
 8007bf0:	b92b      	cbnz	r3, 8007bfe <Thread1+0x416>
            (!mla_resonance_locked &&
 8007bf2:	4b8e      	ldr	r3, [pc, #568]	@ (8007e2c <Thread1+0x644>)
 8007bf4:	781b      	ldrb	r3, [r3, #0]
 8007bf6:	3b01      	subs	r3, #1
 8007bf8:	2b01      	cmp	r3, #1
 8007bfa:	f67f aee4 	bls.w	80079c6 <Thread1+0x1de>
        if (!in_mla_stability_phase && (mla_no_dip_count == 0))
 8007bfe:	4b8c      	ldr	r3, [pc, #560]	@ (8007e30 <Thread1+0x648>)
 8007c00:	781b      	ldrb	r3, [r3, #0]
 8007c02:	2b00      	cmp	r3, #0
 8007c04:	f47f aedf 	bne.w	80079c6 <Thread1+0x1de>
          request_to_redraw(REDRAW_PLOT);
 8007c08:	2001      	movs	r0, #1
 8007c0a:	f003 fdf1 	bl	800b7f0 <request_to_redraw>
          draw_all();
 8007c0e:	f003 fe17 	bl	800b840 <draw_all>
          bool centered = mla_is_resonance_centered();
 8007c12:	f7fe f891 	bl	8005d38 <mla_is_resonance_centered>
          if (!centered)
 8007c16:	2800      	cmp	r0, #0
 8007c18:	f47f aed5 	bne.w	80079c6 <Thread1+0x1de>
            start = mla_res_freq - (SPAN_HZ / 2);
 8007c1c:	4b7b      	ldr	r3, [pc, #492]	@ (8007e0c <Thread1+0x624>)
 8007c1e:	681d      	ldr	r5, [r3, #0]
            set_sweep_frequency(ST_START, start);
 8007c20:	f5a5 21f4 	sub.w	r1, r5, #499712	@ 0x7a000
 8007c24:	f5a1 7190 	sub.w	r1, r1, #288	@ 0x120
 8007c28:	f7ff faf8 	bl	800721c <set_sweep_frequency>
            set_sweep_frequency(ST_STOP, stop);
 8007c2c:	f505 21f4 	add.w	r1, r5, #499712	@ 0x7a000
 8007c30:	f501 7190 	add.w	r1, r1, #288	@ 0x120
 8007c34:	2001      	movs	r0, #1
 8007c36:	f7ff faf1 	bl	800721c <set_sweep_frequency>
            mla_autozone_stage = 1;
 8007c3a:	4a79      	ldr	r2, [pc, #484]	@ (8007e20 <Thread1+0x638>)
 8007c3c:	2301      	movs	r3, #1
 8007c3e:	7013      	strb	r3, [r2, #0]
 8007c40:	e6c1      	b.n	80079c6 <Thread1+0x1de>
        completed = sweep(true, mask);
 8007c42:	4601      	mov	r1, r0
 8007c44:	4648      	mov	r0, r9
 8007c46:	f7fe fcd5 	bl	80065f4 <sweep>
        sweep_mode &= ~SWEEP_ONCE;
 8007c4a:	783b      	ldrb	r3, [r7, #0]
 8007c4c:	f023 0302 	bic.w	r3, r3, #2
        completed = sweep(true, mask);
 8007c50:	4605      	mov	r5, r0
        sweep_mode &= ~SWEEP_ONCE;
 8007c52:	703b      	strb	r3, [r7, #0]
 8007c54:	e699      	b.n	800798a <Thread1+0x1a2>
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 8007c56:	eeb0 8a68 	vmov.f32	s16, s17
 8007c5a:	e62f      	b.n	80078bc <Thread1+0xd4>
    mla_res_freq = getFrequency((uint16_t)best);
 8007c5c:	4a6b      	ldr	r2, [pc, #428]	@ (8007e0c <Thread1+0x624>)
 8007c5e:	2300      	movs	r3, #0
 8007c60:	6013      	str	r3, [r2, #0]
        target_frequency = mla_res_freq;
 8007c62:	4a6b      	ldr	r2, [pc, #428]	@ (8007e10 <Thread1+0x628>)
 8007c64:	6013      	str	r3, [r2, #0]
    mla_res_idx = -1;
 8007c66:	4a68      	ldr	r2, [pc, #416]	@ (8007e08 <Thread1+0x620>)
 8007c68:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8007c6c:	8013      	strh	r3, [r2, #0]
    return 0.0f;
 8007c6e:	ed9f 0a71 	vldr	s0, [pc, #452]	@ 8007e34 <Thread1+0x64c>
 8007c72:	e78c      	b.n	8007b8e <Thread1+0x3a6>
          if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8007c74:	4b6e      	ldr	r3, [pc, #440]	@ (8007e30 <Thread1+0x648>)
 8007c76:	781b      	ldrb	r3, [r3, #0]
 8007c78:	2b01      	cmp	r3, #1
 8007c7a:	f240 82e1 	bls.w	8008240 <Thread1+0xa58>
  if (sweep_points < 3)
 8007c7e:	9b00      	ldr	r3, [sp, #0]
 8007c80:	2b02      	cmp	r3, #2
 8007c82:	f240 8097 	bls.w	8007db4 <Thread1+0x5cc>
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8007c86:	2201      	movs	r2, #1
 8007c88:	f1a3 0c02 	sub.w	ip, r3, #2
  float best_mag2 = 1e30f;
 8007c8c:	eddf 6a6a 	vldr	s13, [pc, #424]	@ 8007e38 <Thread1+0x650>
 8007c90:	4b6a      	ldr	r3, [pc, #424]	@ (8007e3c <Thread1+0x654>)
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8007c92:	fa1f fc8c 	uxth.w	ip, ip
  uint16_t best_idx = i_start;
 8007c96:	4696      	mov	lr, r2
 8007c98:	4611      	mov	r1, r2
 8007c9a:	e00d      	b.n	8007cb8 <Thread1+0x4d0>
      best_mag2 = mag2;
 8007c9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ca0:	bf44      	itt	mi
 8007ca2:	4628      	movmi	r0, r5
 8007ca4:	468e      	movmi	lr, r1
 8007ca6:	bf48      	it	mi
 8007ca8:	eef0 6a67 	vmovmi.f32	s13, s15
  for (uint16_t i = i_start; i <= i_end; i++)
 8007cac:	3201      	adds	r2, #1
 8007cae:	b291      	uxth	r1, r2
 8007cb0:	458c      	cmp	ip, r1
 8007cb2:	f103 0308 	add.w	r3, r3, #8
 8007cb6:	d31a      	bcc.n	8007cee <Thread1+0x506>
    float im = measured[0][i][1];
 8007cb8:	edd3 7a03 	vldr	s15, [r3, #12]
    float re = measured[0][i][0];
 8007cbc:	ed93 7a02 	vldr	s14, [r3, #8]
    float mag2 = re * re + im * im;
 8007cc0:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8007cc4:	eee7 7a07 	vfma.f32	s15, s14, s14
    if (mag2 == 0.0f)
 8007cc8:	eef5 7a40 	vcmp.f32	s15, #0.0
 8007ccc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007cd0:	d0ec      	beq.n	8007cac <Thread1+0x4c4>
      best_mag2 = mag2;
 8007cd2:	eef4 7ae6 	vcmpe.f32	s15, s13
    if (!found || mag2 < best_mag2)
 8007cd6:	2800      	cmp	r0, #0
 8007cd8:	d1e0      	bne.n	8007c9c <Thread1+0x4b4>
  for (uint16_t i = i_start; i <= i_end; i++)
 8007cda:	3201      	adds	r2, #1
      best_idx = i;
 8007cdc:	468e      	mov	lr, r1
  for (uint16_t i = i_start; i <= i_end; i++)
 8007cde:	b291      	uxth	r1, r2
 8007ce0:	458c      	cmp	ip, r1
      best_mag2 = mag2;
 8007ce2:	eef0 6a67 	vmov.f32	s13, s15
      found = true;
 8007ce6:	4628      	mov	r0, r5
  for (uint16_t i = i_start; i <= i_end; i++)
 8007ce8:	f103 0308 	add.w	r3, r3, #8
 8007cec:	d2e4      	bcs.n	8007cb8 <Thread1+0x4d0>
  if (!found)
 8007cee:	2800      	cmp	r0, #0
 8007cf0:	d060      	beq.n	8007db4 <Thread1+0x5cc>
  float swr_min = getSWRfromIndex(idx);
 8007cf2:	4670      	mov	r0, lr
 8007cf4:	f7fd fb86 	bl	8005404 <getSWRfromIndex>
  if (swr_min <= 0.0f || swr_min > 50.0f)
 8007cf8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007cfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float swr_min = getSWRfromIndex(idx);
 8007d00:	eeb0 6a40 	vmov.f32	s12, s0
  if (swr_min <= 0.0f || swr_min > 50.0f)
 8007d04:	d956      	bls.n	8007db4 <Thread1+0x5cc>
 8007d06:	eddf 7a43 	vldr	s15, [pc, #268]	@ 8007e14 <Thread1+0x62c>
 8007d0a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8007d0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d12:	dc4f      	bgt.n	8007db4 <Thread1+0x5cc>
  float max_swr = 0.0f;
 8007d14:	eddf 5a47 	vldr	s11, [pc, #284]	@ 8007e34 <Thread1+0x64c>
  if (swr_min <= 0.0f || swr_min > 50.0f)
 8007d18:	9900      	ldr	r1, [sp, #0]
 8007d1a:	2200      	movs	r2, #0
    float swr = getSWRfromIndex(i);
 8007d1c:	b290      	uxth	r0, r2
 8007d1e:	f7fd fb71 	bl	8005404 <getSWRfromIndex>
    if (swr > 0.0f && swr < 9999.0f && swr > max_swr)
 8007d22:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007d26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  for (uint16_t i = 0; i < sweep_points; i++)
 8007d2a:	f102 0201 	add.w	r2, r2, #1
    if (swr > 0.0f && swr < 9999.0f && swr > max_swr)
 8007d2e:	dd0b      	ble.n	8007d48 <Thread1+0x560>
 8007d30:	eeb4 0ae8 	vcmpe.f32	s0, s17
 8007d34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d38:	d506      	bpl.n	8007d48 <Thread1+0x560>
 8007d3a:	eef4 5ac0 	vcmpe.f32	s11, s0
 8007d3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d42:	bfb8      	it	lt
 8007d44:	eef0 5a40 	vmovlt.f32	s11, s0
  for (uint16_t i = 0; i < sweep_points; i++)
 8007d48:	428a      	cmp	r2, r1
 8007d4a:	d1e7      	bne.n	8007d1c <Thread1+0x534>
  if (max_swr <= 0.0f)
 8007d4c:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 8007d50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d54:	d92e      	bls.n	8007db4 <Thread1+0x5cc>
  float ratio = max_swr / swr_min;
 8007d56:	ee85 7a86 	vdiv.f32	s14, s11, s12
  if (ratio < 1.5f || swr_min > 10.0f)
 8007d5a:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 8007d5e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8007d62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d66:	d425      	bmi.n	8007db4 <Thread1+0x5cc>
 8007d68:	eef2 7a04 	vmov.f32	s15, #36	@ 0x41200000  10.0
 8007d6c:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8007d70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007d74:	dc1e      	bgt.n	8007db4 <Thread1+0x5cc>
    mla_has_good_resonance = true;
 8007d76:	4b32      	ldr	r3, [pc, #200]	@ (8007e40 <Thread1+0x658>)
            mla_no_dip_count = 0;
 8007d78:	4a2d      	ldr	r2, [pc, #180]	@ (8007e30 <Thread1+0x648>)
    mla_has_good_resonance = true;
 8007d7a:	f04f 0a01 	mov.w	sl, #1
 8007d7e:	f883 a000 	strb.w	sl, [r3]
            mla_no_dip_count = 0;
 8007d82:	2300      	movs	r3, #0
 8007d84:	7013      	strb	r3, [r2, #0]
            uint32_t f = mla_res_freq;
 8007d86:	4b21      	ldr	r3, [pc, #132]	@ (8007e0c <Thread1+0x624>)
 8007d88:	f8d3 9000 	ldr.w	r9, [r3]
            ui_hide_no_resonance_hint();
 8007d8c:	f007 fbd8 	bl	800f540 <ui_hide_no_resonance_hint>
            if (mla_res_stable_count == 0)
 8007d90:	4a26      	ldr	r2, [pc, #152]	@ (8007e2c <Thread1+0x644>)
 8007d92:	7813      	ldrb	r3, [r2, #0]
 8007d94:	2b00      	cmp	r3, #0
 8007d96:	f040 825b 	bne.w	8008250 <Thread1+0xa68>
              mla_res_ref_freq = f;
 8007d9a:	4b2a      	ldr	r3, [pc, #168]	@ (8007e44 <Thread1+0x65c>)
              mla_res_stable_count = 1;
 8007d9c:	f882 a000 	strb.w	sl, [r2]
              mla_res_ref_freq = f;
 8007da0:	f8c3 9000 	str.w	r9, [r3]
              mla_res_stable_count = 1;
 8007da4:	e014      	b.n	8007dd0 <Thread1+0x5e8>
  else if (py >= botY && py < botY + boxH)
 8007da6:	3b46      	subs	r3, #70	@ 0x46
 8007da8:	2b15      	cmp	r3, #21
 8007daa:	f63f add4 	bhi.w	8007956 <Thread1+0x16e>
    dir = -1; // lower = decrement
 8007dae:	f04f 3cff 	mov.w	ip, #4294967295
 8007db2:	e612      	b.n	80079da <Thread1+0x1f2>
            if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8007db4:	4b1e      	ldr	r3, [pc, #120]	@ (8007e30 <Thread1+0x648>)
    mla_has_good_resonance = false;
 8007db6:	4922      	ldr	r1, [pc, #136]	@ (8007e40 <Thread1+0x658>)
            if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8007db8:	781b      	ldrb	r3, [r3, #0]
    mla_has_good_resonance = false;
 8007dba:	2200      	movs	r2, #0
 8007dbc:	700a      	strb	r2, [r1, #0]
            mla_res_stable_count = 0;
 8007dbe:	491b      	ldr	r1, [pc, #108]	@ (8007e2c <Thread1+0x644>)
            if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8007dc0:	2b01      	cmp	r3, #1
            mla_res_stable_count = 0;
 8007dc2:	700a      	strb	r2, [r1, #0]
            if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8007dc4:	f240 8136 	bls.w	8008034 <Thread1+0x84c>
              ui_hide_check_amtenna_hint();
 8007dc8:	f007 fb78 	bl	800f4bc <ui_hide_check_amtenna_hint>
              ui_show_no_resonance_hint();
 8007dcc:	f007 fb4a 	bl	800f464 <ui_show_no_resonance_hint>
        if (mla_resonance_locked && mla_autozone_stage < 3)
 8007dd0:	4b12      	ldr	r3, [pc, #72]	@ (8007e1c <Thread1+0x634>)
 8007dd2:	781b      	ldrb	r3, [r3, #0]
 8007dd4:	2b00      	cmp	r3, #0
 8007dd6:	f43f aeea 	beq.w	8007bae <Thread1+0x3c6>
 8007dda:	e6e1      	b.n	8007ba0 <Thread1+0x3b8>
            float (*array)[2] = measured[ch];
 8007ddc:	f898 304e 	ldrb.w	r3, [r8, #78]	@ 0x4e
 8007de0:	4816      	ldr	r0, [pc, #88]	@ (8007e3c <Thread1+0x654>)
            for (int i = 0; i < sweep_points; i++)
 8007de2:	f8b8 201a 	ldrh.w	r2, [r8, #26]
            float min_p = 0.0f, max_p = 0.0f;
 8007de6:	eddf ba13 	vldr	s23, [pc, #76]	@ 8007e34 <Thread1+0x64c>
            float (*array)[2] = measured[ch];
 8007dea:	f640 4188 	movw	r1, #3208	@ 0xc88
 8007dee:	fb01 0a03 	mla	sl, r1, r3, r0
            for (int i = 0; i < sweep_points; i++)
 8007df2:	2a00      	cmp	r2, #0
 8007df4:	f000 8116 	beq.w	8008024 <Thread1+0x83c>
            float min_p = 0.0f, max_p = 0.0f;
 8007df8:	eeb0 ca6b 	vmov.f32	s24, s23
              if (swr < 1.0f)
 8007dfc:	eeb7 ba00 	vmov.f32	s22, #112	@ 0x3f800000  1.0
            for (int i = 0; i < sweep_points; i++)
 8007e00:	f04f 0900 	mov.w	r9, #0
 8007e04:	e039      	b.n	8007e7a <Thread1+0x692>
 8007e06:	bf00      	nop
 8007e08:	200003d4 	.word	0x200003d4
 8007e0c:	2000687c 	.word	0x2000687c
 8007e10:	200068a8 	.word	0x200068a8
 8007e14:	42480000 	.word	0x42480000
 8007e18:	20006878 	.word	0x20006878
 8007e1c:	20006875 	.word	0x20006875
 8007e20:	2000686d 	.word	0x2000686d
 8007e24:	08014540 	.word	0x08014540
 8007e28:	2000686c 	.word	0x2000686c
 8007e2c:	20006874 	.word	0x20006874
 8007e30:	2000686e 	.word	0x2000686e
 8007e34:	00000000 	.word	0x00000000
 8007e38:	7149f2ca 	.word	0x7149f2ca
 8007e3c:	20004f54 	.word	0x20004f54
 8007e40:	20006876 	.word	0x20006876
 8007e44:	20006870 	.word	0x20006870
                if (p < min_p)
 8007e48:	eeb4 cac8 	vcmpe.f32	s24, s16
 8007e4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (p > max_p)
 8007e50:	eef4 bac8 	vcmpe.f32	s23, s16
                if (p < min_p)
 8007e54:	bf88      	it	hi
 8007e56:	eeb0 ca48 	vmovhi.f32	s24, s16
                if (p > max_p)
 8007e5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e5e:	bfb8      	it	lt
 8007e60:	eef0 ba48 	vmovlt.f32	s23, s16
            for (int i = 0; i < sweep_points; i++)
 8007e64:	f8b8 301a 	ldrh.w	r3, [r8, #26]
 8007e68:	f109 0901 	add.w	r9, r9, #1
 8007e6c:	454b      	cmp	r3, r9
 8007e6e:	f04f 0500 	mov.w	r5, #0
 8007e72:	f10a 0a08 	add.w	sl, sl, #8
 8007e76:	f340 809d 	ble.w	8007fb4 <Thread1+0x7cc>
              float swr = cb(i, array[i]);
 8007e7a:	4651      	mov	r1, sl
 8007e7c:	4648      	mov	r0, r9
 8007e7e:	47d8      	blx	fp
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 8007e80:	eef0 cac0 	vabs.f32	s25, s0
 8007e84:	eeb0 8a40 	vmov.f32	s16, s0
              if (vna_fabsf(swr) == infinityf())
 8007e88:	f009 fb34 	bl	80114f4 <infinityf>
 8007e8c:	eeb4 0a6c 	vcmp.f32	s0, s25
 8007e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
              if (swr < 1.0f)
 8007e94:	eeb4 8acb 	vcmpe.f32	s16, s22
              if (vna_fabsf(swr) == infinityf())
 8007e98:	f000 808c 	beq.w	8007fb4 <Thread1+0x7cc>
              if (swr < 1.0f)
 8007e9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ea0:	bfb8      	it	lt
 8007ea2:	eeb0 8a4b 	vmovlt.f32	s16, s22
              float p = swr - 1.0f;
 8007ea6:	ee38 8a4b 	vsub.f32	s16, s16, s22
              if (first)
 8007eaa:	2d00      	cmp	r5, #0
 8007eac:	d0cc      	beq.n	8007e48 <Thread1+0x660>
                min_p = max_p = p;
 8007eae:	eef0 ba48 	vmov.f32	s23, s16
 8007eb2:	eeb0 ca48 	vmov.f32	s24, s16
 8007eb6:	e7d5      	b.n	8007e64 <Thread1+0x67c>
            float (*array)[2] = measured[ch];
 8007eb8:	f898 302a 	ldrb.w	r3, [r8, #42]	@ 0x2a
 8007ebc:	49d0      	ldr	r1, [pc, #832]	@ (8008200 <Thread1+0xa18>)
            for (int i = 0; i < sweep_points; i++)
 8007ebe:	f8b8 c01a 	ldrh.w	ip, [r8, #26]
            float (*array)[2] = measured[ch];
 8007ec2:	f640 4088 	movw	r0, #3208	@ 0xc88
 8007ec6:	fb00 1a03 	mla	sl, r0, r3, r1
            for (int i = 0; i < sweep_points; i++)
 8007eca:	f1bc 0f00 	cmp.w	ip, #0
 8007ece:	f000 80ac 	beq.w	800802a <Thread1+0x842>
            float min_v = 0.0f, max_v = 0.0f;
 8007ed2:	ed9f bacc 	vldr	s22, [pc, #816]	@ 8008204 <Thread1+0xa1c>
            for (int i = 0; i < sweep_points; i++)
 8007ed6:	9500      	str	r5, [sp, #0]
            bool first = true;
 8007ed8:	46ab      	mov	fp, r5
            float min_v = 0.0f, max_v = 0.0f;
 8007eda:	eef0 ba4b 	vmov.f32	s23, s22
            for (int i = 0; i < sweep_points; i++)
 8007ede:	f04f 0900 	mov.w	r9, #0
 8007ee2:	4615      	mov	r5, r2
 8007ee4:	e015      	b.n	8007f12 <Thread1+0x72a>
                if (v < min_v)
 8007ee6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (v > max_v)
 8007eea:	eef4 bac8 	vcmpe.f32	s23, s16
                if (v < min_v)
 8007eee:	bf88      	it	hi
 8007ef0:	eeb0 ba48 	vmovhi.f32	s22, s16
                if (v > max_v)
 8007ef4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ef8:	bfb8      	it	lt
 8007efa:	eef0 ba48 	vmovlt.f32	s23, s16
            for (int i = 0; i < sweep_points; i++)
 8007efe:	f8b8 201a 	ldrh.w	r2, [r8, #26]
 8007f02:	f109 0901 	add.w	r9, r9, #1
 8007f06:	454a      	cmp	r2, r9
 8007f08:	f04f 0b00 	mov.w	fp, #0
 8007f0c:	f10a 0a08 	add.w	sl, sl, #8
 8007f10:	dd17      	ble.n	8007f42 <Thread1+0x75a>
              float v = cb(i, array[i]);
 8007f12:	4651      	mov	r1, sl
 8007f14:	4648      	mov	r0, r9
 8007f16:	47a8      	blx	r5
 8007f18:	eeb0 cac0 	vabs.f32	s24, s0
 8007f1c:	eeb0 8a40 	vmov.f32	s16, s0
              if (vna_fabsf(v) == infinityf())
 8007f20:	f009 fae8 	bl	80114f4 <infinityf>
 8007f24:	eeb4 0a4c 	vcmp.f32	s0, s24
 8007f28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (v < min_v)
 8007f2c:	eeb4 bac8 	vcmpe.f32	s22, s16
              if (vna_fabsf(v) == infinityf())
 8007f30:	d007      	beq.n	8007f42 <Thread1+0x75a>
              if (first)
 8007f32:	f1bb 0f00 	cmp.w	fp, #0
 8007f36:	d0d6      	beq.n	8007ee6 <Thread1+0x6fe>
                min_v = max_v = v;
 8007f38:	eef0 ba48 	vmov.f32	s23, s16
 8007f3c:	eeb0 ba48 	vmov.f32	s22, s16
 8007f40:	e7dd      	b.n	8007efe <Thread1+0x716>
            float span = max_v - min_v;
 8007f42:	ee3b 0acb 	vsub.f32	s0, s23, s22
            if (span < 1e-6f)
 8007f46:	eddf 7ab0 	vldr	s15, [pc, #704]	@ 8008208 <Thread1+0xa20>
            float span = max_v - min_v;
 8007f4a:	9d00      	ldr	r5, [sp, #0]
            if (span < 1e-6f)
 8007f4c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8007f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007f54:	d46b      	bmi.n	800802e <Thread1+0x846>
            float scale = span / dy;
 8007f56:	eddf 7aad 	vldr	s15, [pc, #692]	@ 800820c <Thread1+0xa24>
 8007f5a:	ee20 0a27 	vmul.f32	s0, s0, s15
            float refpos = y_max - (max_v / scale);
 8007f5e:	ee8b 8a80 	vdiv.f32	s16, s23, s0
            if (trace[t].scale <= 0.0f ||
 8007f62:	edd8 7a0b 	vldr	s15, [r8, #44]	@ 0x2c
 8007f66:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8007f6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            float refpos = y_max - (max_v / scale);
 8007f6e:	ee39 8ac8 	vsub.f32	s16, s19, s16
            if (trace[t].scale <= 0.0f ||
 8007f72:	d90a      	bls.n	8007f8a <Thread1+0x7a2>
                vna_fabsf(scale - trace[t].scale) > trace[t].scale * 0.03f)
 8007f74:	ee27 7a8a 	vmul.f32	s14, s15, s20
 8007f78:	ee70 7a67 	vsub.f32	s15, s0, s15
 8007f7c:	eef0 7ae7 	vabs.f32	s15, s15
            if (trace[t].scale <= 0.0f ||
 8007f80:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8007f84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007f88:	d502      	bpl.n	8007f90 <Thread1+0x7a8>
              set_trace_scale(t, scale);
 8007f8a:	2000      	movs	r0, #0
 8007f8c:	f7ff fbd4 	bl	8007738 <set_trace_scale>
            if (vna_fabsf(refpos - trace[t].refpos) > 0.02f)
 8007f90:	edd8 7a0c 	vldr	s15, [r8, #48]	@ 0x30
 8007f94:	ee78 7a67 	vsub.f32	s15, s16, s15
 8007f98:	eef0 7ae7 	vabs.f32	s15, s15
 8007f9c:	eef4 7ac9 	vcmpe.f32	s15, s18
 8007fa0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007fa4:	f77f ae0e 	ble.w	8007bc4 <Thread1+0x3dc>
              set_trace_refpos(t, refpos);
 8007fa8:	eeb0 0a48 	vmov.f32	s0, s16
 8007fac:	2000      	movs	r0, #0
 8007fae:	f7ff fbd7 	bl	8007760 <set_trace_refpos>
 8007fb2:	e607      	b.n	8007bc4 <Thread1+0x3dc>
            float span = max_p - min_p;
 8007fb4:	ee3b 0acc 	vsub.f32	s0, s23, s24
            if (span < 1e-6f)
 8007fb8:	eddf 7a93 	vldr	s15, [pc, #588]	@ 8008208 <Thread1+0xa20>
 8007fbc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8007fc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007fc4:	d42e      	bmi.n	8008024 <Thread1+0x83c>
            float scale = span / dy;
 8007fc6:	eddf 7a92 	vldr	s15, [pc, #584]	@ 8008210 <Thread1+0xa28>
 8007fca:	ee20 0a27 	vmul.f32	s0, s0, s15
            float refpos = y_max - (max_p / scale);
 8007fce:	ee8b 8a80 	vdiv.f32	s16, s23, s0
            if (trace[t].scale <= 0.0f ||
 8007fd2:	edd8 7a14 	vldr	s15, [r8, #80]	@ 0x50
 8007fd6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8007fda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            float refpos = y_max - (max_p / scale);
 8007fde:	ee39 8ac8 	vsub.f32	s16, s19, s16
            if (trace[t].scale <= 0.0f ||
 8007fe2:	d90a      	bls.n	8007ffa <Thread1+0x812>
                vna_fabsf(scale - trace[t].scale) > trace[t].scale * 0.03f)
 8007fe4:	ee27 7a8a 	vmul.f32	s14, s15, s20
 8007fe8:	ee70 7a67 	vsub.f32	s15, s0, s15
 8007fec:	eef0 7ae7 	vabs.f32	s15, s15
            if (trace[t].scale <= 0.0f ||
 8007ff0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8007ff4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007ff8:	d502      	bpl.n	8008000 <Thread1+0x818>
              set_trace_scale(t, scale);
 8007ffa:	2003      	movs	r0, #3
 8007ffc:	f7ff fb9c 	bl	8007738 <set_trace_scale>
            if (vna_fabsf(refpos - trace[t].refpos) > 0.02f)
 8008000:	edd8 7a15 	vldr	s15, [r8, #84]	@ 0x54
 8008004:	ee78 7a67 	vsub.f32	s15, s16, s15
 8008008:	eef0 7ae7 	vabs.f32	s15, s15
 800800c:	eef4 7ac9 	vcmpe.f32	s15, s18
 8008010:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008014:	f77f ade3 	ble.w	8007bde <Thread1+0x3f6>
              set_trace_refpos(t, refpos);
 8008018:	eeb0 0a48 	vmov.f32	s0, s16
 800801c:	2003      	movs	r0, #3
 800801e:	f7ff fb9f 	bl	8007760 <set_trace_refpos>
 8008022:	e5dc      	b.n	8007bde <Thread1+0x3f6>
            float min_p = 0.0f, max_p = 0.0f;
 8008024:	eeb0 0a6a 	vmov.f32	s0, s21
 8008028:	e7d1      	b.n	8007fce <Thread1+0x7e6>
            float min_v = 0.0f, max_v = 0.0f;
 800802a:	eddf ba76 	vldr	s23, [pc, #472]	@ 8008204 <Thread1+0xa1c>
 800802e:	ed9f 0a79 	vldr	s0, [pc, #484]	@ 8008214 <Thread1+0xa2c>
 8008032:	e794      	b.n	8007f5e <Thread1+0x776>
              mla_no_dip_count++;
 8008034:	3301      	adds	r3, #1
 8008036:	b2db      	uxtb	r3, r3
 8008038:	4a77      	ldr	r2, [pc, #476]	@ (8008218 <Thread1+0xa30>)
            if (mla_no_dip_count >= MLA_NO_DIP_LIMIT)
 800803a:	2b02      	cmp	r3, #2
              mla_no_dip_count++;
 800803c:	7013      	strb	r3, [r2, #0]
            if (mla_no_dip_count >= MLA_NO_DIP_LIMIT)
 800803e:	f47f aec7 	bne.w	8007dd0 <Thread1+0x5e8>
 8008042:	e6c1      	b.n	8007dc8 <Thread1+0x5e0>
  if (mla_autozone_stage == 2)
 8008044:	f000 8147 	beq.w	80082d6 <Thread1+0xaee>
  if (sweep_points < 3)
 8008048:	f8b8 a01a 	ldrh.w	sl, [r8, #26]
 800804c:	f1ba 0f02 	cmp.w	sl, #2
 8008050:	f67f adad 	bls.w	8007bae <Thread1+0x3c6>
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8008054:	2201      	movs	r2, #1
 8008056:	f1aa 0c02 	sub.w	ip, sl, #2
  float best_mag2 = 1e30f;
 800805a:	eddf 6a70 	vldr	s13, [pc, #448]	@ 800821c <Thread1+0xa34>
 800805e:	4b68      	ldr	r3, [pc, #416]	@ (8008200 <Thread1+0xa18>)
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8008060:	fa1f fc8c 	uxth.w	ip, ip
  uint16_t best_idx = i_start;
 8008064:	4693      	mov	fp, r2
  bool found = false;
 8008066:	2000      	movs	r0, #0
 8008068:	4611      	mov	r1, r2
 800806a:	e00d      	b.n	8008088 <Thread1+0x8a0>
      best_mag2 = mag2;
 800806c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008070:	bf44      	itt	mi
 8008072:	4628      	movmi	r0, r5
 8008074:	468b      	movmi	fp, r1
 8008076:	bf48      	it	mi
 8008078:	eef0 6a67 	vmovmi.f32	s13, s15
  for (uint16_t i = i_start; i <= i_end; i++)
 800807c:	3201      	adds	r2, #1
 800807e:	b291      	uxth	r1, r2
 8008080:	4561      	cmp	r1, ip
 8008082:	f103 0308 	add.w	r3, r3, #8
 8008086:	d81a      	bhi.n	80080be <Thread1+0x8d6>
    float im = measured[0][i][1];
 8008088:	edd3 7a03 	vldr	s15, [r3, #12]
    float re = measured[0][i][0];
 800808c:	ed93 7a02 	vldr	s14, [r3, #8]
    float mag2 = re * re + im * im;
 8008090:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8008094:	eee7 7a07 	vfma.f32	s15, s14, s14
    if (mag2 == 0.0f)
 8008098:	eef5 7a40 	vcmp.f32	s15, #0.0
 800809c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80080a0:	d0ec      	beq.n	800807c <Thread1+0x894>
      best_mag2 = mag2;
 80080a2:	eef4 7ae6 	vcmpe.f32	s15, s13
    if (!found || mag2 < best_mag2)
 80080a6:	2800      	cmp	r0, #0
 80080a8:	d1e0      	bne.n	800806c <Thread1+0x884>
  for (uint16_t i = i_start; i <= i_end; i++)
 80080aa:	3201      	adds	r2, #1
      best_idx = i;
 80080ac:	468b      	mov	fp, r1
  for (uint16_t i = i_start; i <= i_end; i++)
 80080ae:	b291      	uxth	r1, r2
 80080b0:	4561      	cmp	r1, ip
      best_mag2 = mag2;
 80080b2:	eef0 6a67 	vmov.f32	s13, s15
      found = true;
 80080b6:	4628      	mov	r0, r5
  for (uint16_t i = i_start; i <= i_end; i++)
 80080b8:	f103 0308 	add.w	r3, r3, #8
 80080bc:	d9e4      	bls.n	8008088 <Thread1+0x8a0>
  if (!found)
 80080be:	2800      	cmp	r0, #0
 80080c0:	f43f ad75 	beq.w	8007bae <Thread1+0x3c6>
    *out_freq = getFrequency(best_idx);
 80080c4:	4658      	mov	r0, fp
 80080c6:	f7fe fa79 	bl	80065bc <getFrequency>
  mla_res_freq = f_res;
 80080ca:	4b55      	ldr	r3, [pc, #340]	@ (8008220 <Thread1+0xa38>)
  mla_resonance_locked = true;
 80080cc:	4a55      	ldr	r2, [pc, #340]	@ (8008224 <Thread1+0xa3c>)
  mla_res_freq = f_res;
 80080ce:	6018      	str	r0, [r3, #0]
  mla_res_idx = idx;
 80080d0:	4b55      	ldr	r3, [pc, #340]	@ (8008228 <Thread1+0xa40>)
 80080d2:	f8a3 b000 	strh.w	fp, [r3]
  mla_resonance_locked = true;
 80080d6:	2301      	movs	r3, #1
 80080d8:	7013      	strb	r3, [r2, #0]
  if (mla_autozone_stage == 0)
 80080da:	f1b9 0f00 	cmp.w	r9, #0
 80080de:	f000 80dd 	beq.w	800829c <Thread1+0xab4>
      if (swr > swr_limit)
 80080e2:	eeb0 6a08 	vmov.f32	s12, #8	@ 0x40400000  3.0
    uint16_t left = idx;
 80080e6:	465a      	mov	r2, fp
 80080e8:	e007      	b.n	80080fa <Thread1+0x912>
      float swr = getSWRfromIndex(left - 1);
 80080ea:	f7fd f98b 	bl	8005404 <getSWRfromIndex>
      if (swr > swr_limit)
 80080ee:	eeb4 0ac6 	vcmpe.f32	s0, s12
 80080f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80080f6:	dc05      	bgt.n	8008104 <Thread1+0x91c>
      left--;
 80080f8:	460a      	mov	r2, r1
      float swr = getSWRfromIndex(left - 1);
 80080fa:	1e51      	subs	r1, r2, #1
 80080fc:	b289      	uxth	r1, r1
 80080fe:	4608      	mov	r0, r1
    while (left > 0)
 8008100:	2a00      	cmp	r2, #0
 8008102:	d1f2      	bne.n	80080ea <Thread1+0x902>
    while (right + 1 < sweep_points)
 8008104:	9200      	str	r2, [sp, #0]
      if (swr > swr_limit)
 8008106:	eeb0 6a08 	vmov.f32	s12, #8	@ 0x40400000  3.0
    while (right + 1 < sweep_points)
 800810a:	465a      	mov	r2, fp
 800810c:	e008      	b.n	8008120 <Thread1+0x938>
      float swr = getSWRfromIndex(right + 1);
 800810e:	f7fd f979 	bl	8005404 <getSWRfromIndex>
      if (swr > swr_limit)
 8008112:	eeb4 0ac6 	vcmpe.f32	s0, s12
 8008116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800811a:	f300 8143 	bgt.w	80083a4 <Thread1+0xbbc>
      right++;
 800811e:	464a      	mov	r2, r9
    while (right + 1 < sweep_points)
 8008120:	1c51      	adds	r1, r2, #1
      float swr = getSWRfromIndex(right + 1);
 8008122:	fa1f f981 	uxth.w	r9, r1
    while (right + 1 < sweep_points)
 8008126:	458a      	cmp	sl, r1
      float swr = getSWRfromIndex(right + 1);
 8008128:	4648      	mov	r0, r9
    while (right + 1 < sweep_points)
 800812a:	dcf0      	bgt.n	800810e <Thread1+0x926>
    if (left > 0)
 800812c:	4613      	mov	r3, r2
 800812e:	9a00      	ldr	r2, [sp, #0]
 8008130:	b122      	cbz	r2, 800813c <Thread1+0x954>
      left--;
 8008132:	3a01      	subs	r2, #1
    if (right + 1 < sweep_points)
 8008134:	458a      	cmp	sl, r1
      left--;
 8008136:	b292      	uxth	r2, r2
    if (right + 1 < sweep_points)
 8008138:	dd00      	ble.n	800813c <Thread1+0x954>
      right++;
 800813a:	b28b      	uxth	r3, r1
    int left_span = (int)idx - (int)left;
 800813c:	ebab 0902 	sub.w	r9, fp, r2
    int right_span = (int)right - (int)idx;
 8008140:	eba3 030b 	sub.w	r3, r3, fp
    int half_span = (left_span > right_span) ? left_span : right_span;
 8008144:	4599      	cmp	r9, r3
 8008146:	bfb8      	it	lt
 8008148:	4699      	movlt	r9, r3
    int sym_left = (int)idx - half_span;
 800814a:	ebab 0009 	sub.w	r0, fp, r9
    int sym_right = (int)idx + half_span;
 800814e:	44d9      	add	r9, fp
    if (sym_right >= (int)sweep_points)
 8008150:	45ca      	cmp	sl, r9
    if (sym_left < 0)
 8008152:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
      sym_right = (int)sweep_points - 1;
 8008156:	bfd8      	it	le
 8008158:	f10a 39ff 	addle.w	r9, sl, #4294967295
    if (sym_left >= sym_right)
 800815c:	4548      	cmp	r0, r9
 800815e:	f6bf ad26 	bge.w	8007bae <Thread1+0x3c6>
    freq_t start = getFrequency((uint16_t)sym_left);
 8008162:	b280      	uxth	r0, r0
 8008164:	f7fe fa2a 	bl	80065bc <getFrequency>
 8008168:	4682      	mov	sl, r0
    freq_t stop = getFrequency((uint16_t)sym_right);
 800816a:	fa1f f089 	uxth.w	r0, r9
 800816e:	f7fe fa25 	bl	80065bc <getFrequency>
    if (stop > FREQUENCY_MAX)
 8008172:	4b2e      	ldr	r3, [pc, #184]	@ (800822c <Thread1+0xa44>)
    if (start < FREQUENCY_MIN)
 8008174:	f5ba 7f16 	cmp.w	sl, #600	@ 0x258
 8008178:	4651      	mov	r1, sl
 800817a:	bf38      	it	cc
 800817c:	f44f 7116 	movcc.w	r1, #600	@ 0x258
    if (stop > FREQUENCY_MAX)
 8008180:	4298      	cmp	r0, r3
 8008182:	bf28      	it	cs
 8008184:	4618      	movcs	r0, r3
    if (start >= stop)
 8008186:	4281      	cmp	r1, r0
    if (stop > FREQUENCY_MAX)
 8008188:	4681      	mov	r9, r0
    if (start >= stop)
 800818a:	f4bf ad10 	bcs.w	8007bae <Thread1+0x3c6>
    set_sweep_frequency(ST_START, start);
 800818e:	2000      	movs	r0, #0
 8008190:	f7ff f844 	bl	800721c <set_sweep_frequency>
    set_sweep_frequency(ST_STOP, stop);
 8008194:	4649      	mov	r1, r9
 8008196:	2001      	movs	r0, #1
 8008198:	f7ff f840 	bl	800721c <set_sweep_frequency>
    mla_autozone_stage = 2;
 800819c:	4a24      	ldr	r2, [pc, #144]	@ (8008230 <Thread1+0xa48>)
 800819e:	2302      	movs	r3, #2
 80081a0:	7013      	strb	r3, [r2, #0]
    return;
 80081a2:	e504      	b.n	8007bae <Thread1+0x3c6>
        if (digitIdx >= 0 && digitIdx < 8)
 80081a4:	2807      	cmp	r0, #7
 80081a6:	f73f abd6 	bgt.w	8007956 <Thread1+0x16e>
          return dir * stepHz[digitIdx];
 80081aa:	4b22      	ldr	r3, [pc, #136]	@ (8008234 <Thread1+0xa4c>)
 80081ac:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80081b0:	fb03 f30c 	mul.w	r3, r3, ip
          if (dHz != 0)
 80081b4:	2b00      	cmp	r3, #0
 80081b6:	f43f abce 	beq.w	8007956 <Thread1+0x16e>
            int64_t nf = (int64_t)target_frequency + dHz;
 80081ba:	4a1f      	ldr	r2, [pc, #124]	@ (8008238 <Thread1+0xa50>)
            if (nf > 160000000)
 80081bc:	481f      	ldr	r0, [pc, #124]	@ (800823c <Thread1+0xa54>)
            int64_t nf = (int64_t)target_frequency + dHz;
 80081be:	6811      	ldr	r1, [r2, #0]
 80081c0:	18c9      	adds	r1, r1, r3
 80081c2:	ea4f 73e3 	mov.w	r3, r3, asr #31
 80081c6:	f143 0300 	adc.w	r3, r3, #0
 80081ca:	2200      	movs	r2, #0
            if (nf > 160000000)
 80081cc:	4288      	cmp	r0, r1
 80081ce:	eb72 0503 	sbcs.w	r5, r2, r3
 80081d2:	bfbc      	itt	lt
 80081d4:	4601      	movlt	r1, r0
 80081d6:	4613      	movlt	r3, r2
            if (nf < 8000)
 80081d8:	f5b1 5ffa 	cmp.w	r1, #8000	@ 0x1f40
 80081dc:	f173 0300 	sbcs.w	r3, r3, #0
            target_frequency = (uint32_t)nf;
 80081e0:	4b15      	ldr	r3, [pc, #84]	@ (8008238 <Thread1+0xa50>)
 80081e2:	461d      	mov	r5, r3
            if (nf < 8000)
 80081e4:	bfb8      	it	lt
 80081e6:	f44f 51fa 	movlt.w	r1, #8000	@ 0x1f40
            set_sweep_frequency(ST_START, target_frequency);
 80081ea:	2000      	movs	r0, #0
            target_frequency = (uint32_t)nf;
 80081ec:	6019      	str	r1, [r3, #0]
            set_sweep_frequency(ST_START, target_frequency);
 80081ee:	f7ff f815 	bl	800721c <set_sweep_frequency>
            set_sweep_frequency(ST_STOP, target_frequency);
 80081f2:	6829      	ldr	r1, [r5, #0]
 80081f4:	2001      	movs	r0, #1
 80081f6:	f7ff f811 	bl	800721c <set_sweep_frequency>
 80081fa:	f7ff bbac 	b.w	8007956 <Thread1+0x16e>
 80081fe:	bf00      	nop
 8008200:	20004f54 	.word	0x20004f54
 8008204:	00000000 	.word	0x00000000
 8008208:	358637bd 	.word	0x358637bd
 800820c:	3e11745d 	.word	0x3e11745d
 8008210:	3e169697 	.word	0x3e169697
 8008214:	3e91745d 	.word	0x3e91745d
 8008218:	2000686e 	.word	0x2000686e
 800821c:	7149f2ca 	.word	0x7149f2ca
 8008220:	2000687c 	.word	0x2000687c
 8008224:	20006875 	.word	0x20006875
 8008228:	200003d4 	.word	0x200003d4
 800822c:	a0eebb00 	.word	0xa0eebb00
 8008230:	2000686d 	.word	0x2000686d
 8008234:	08013b04 	.word	0x08013b04
 8008238:	200068a8 	.word	0x200068a8
 800823c:	09896800 	.word	0x09896800
 8008240:	9001      	str	r0, [sp, #4]
            ui_show_check_amtenna_hint();
 8008242:	f007 f953 	bl	800f4ec <ui_show_check_amtenna_hint>
  if (sweep_points < 3)
 8008246:	f8b8 301a 	ldrh.w	r3, [r8, #26]
 800824a:	9801      	ldr	r0, [sp, #4]
 800824c:	9300      	str	r3, [sp, #0]
 800824e:	e516      	b.n	8007c7e <Thread1+0x496>
                  (f > mla_res_ref_freq) ? (f - mla_res_ref_freq) : (mla_res_ref_freq - f);
 8008250:	4a69      	ldr	r2, [pc, #420]	@ (80083f8 <Thread1+0xc10>)
 8008252:	6812      	ldr	r2, [r2, #0]
 8008254:	454a      	cmp	r2, r9
 8008256:	bf34      	ite	cc
 8008258:	eba9 0002 	subcc.w	r0, r9, r2
 800825c:	eba2 0009 	subcs.w	r0, r2, r9
              if (delta <= MLA_RESONANCE_STABILITY_HZ)
 8008260:	f644 6120 	movw	r1, #20000	@ 0x4e20
 8008264:	4288      	cmp	r0, r1
 8008266:	d812      	bhi.n	800828e <Thread1+0xaa6>
                if (mla_res_stable_count < MLA_STABLE_SWEEPS_REQUIRED)
 8008268:	2b02      	cmp	r3, #2
 800826a:	d806      	bhi.n	800827a <Thread1+0xa92>
                  mla_res_stable_count++;
 800826c:	3301      	adds	r3, #1
 800826e:	b2db      	uxtb	r3, r3
 8008270:	4962      	ldr	r1, [pc, #392]	@ (80083fc <Thread1+0xc14>)
            if (mla_res_stable_count >= MLA_STABLE_SWEEPS_REQUIRED)
 8008272:	2b03      	cmp	r3, #3
                  mla_res_stable_count++;
 8008274:	700b      	strb	r3, [r1, #0]
            if (mla_res_stable_count >= MLA_STABLE_SWEEPS_REQUIRED)
 8008276:	f47f adab 	bne.w	8007dd0 <Thread1+0x5e8>
              mla_res_freq = mla_res_ref_freq;
 800827a:	4b61      	ldr	r3, [pc, #388]	@ (8008400 <Thread1+0xc18>)
 800827c:	601a      	str	r2, [r3, #0]
              mla_resonance_locked = true;
 800827e:	4a61      	ldr	r2, [pc, #388]	@ (8008404 <Thread1+0xc1c>)
 8008280:	2301      	movs	r3, #1
 8008282:	7013      	strb	r3, [r2, #0]
              ui_hide_check_amtenna_hint();
 8008284:	f007 f91a 	bl	800f4bc <ui_hide_check_amtenna_hint>
              ui_hide_no_resonance_hint();
 8008288:	f007 f95a 	bl	800f540 <ui_hide_no_resonance_hint>
 800828c:	e5a0      	b.n	8007dd0 <Thread1+0x5e8>
                mla_res_ref_freq = f;
 800828e:	4b5a      	ldr	r3, [pc, #360]	@ (80083f8 <Thread1+0xc10>)
                mla_res_stable_count = 1;
 8008290:	4a5a      	ldr	r2, [pc, #360]	@ (80083fc <Thread1+0xc14>)
                mla_res_ref_freq = f;
 8008292:	f8c3 9000 	str.w	r9, [r3]
                mla_res_stable_count = 1;
 8008296:	2301      	movs	r3, #1
 8008298:	7013      	strb	r3, [r2, #0]
 800829a:	e599      	b.n	8007dd0 <Thread1+0x5e8>
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 800829c:	4b5a      	ldr	r3, [pc, #360]	@ (8008408 <Thread1+0xc20>)
 800829e:	4298      	cmp	r0, r3
 80082a0:	f240 8098 	bls.w	80083d4 <Thread1+0xbec>
    if (stop > FREQUENCY_MAX)
 80082a4:	4b59      	ldr	r3, [pc, #356]	@ (800840c <Thread1+0xc24>)
    freq_t stop = start + span;
 80082a6:	f500 3974 	add.w	r9, r0, #249856	@ 0x3d000
 80082aa:	f109 0990 	add.w	r9, r9, #144	@ 0x90
    if (stop > FREQUENCY_MAX)
 80082ae:	4599      	cmp	r9, r3
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 80082b0:	f5a0 3174 	sub.w	r1, r0, #249856	@ 0x3d000
    if (stop > FREQUENCY_MAX)
 80082b4:	bf28      	it	cs
 80082b6:	4699      	movcs	r9, r3
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 80082b8:	3990      	subs	r1, #144	@ 0x90
    if (start >= stop)
 80082ba:	4549      	cmp	r1, r9
 80082bc:	f4bf ac77 	bcs.w	8007bae <Thread1+0x3c6>
    set_sweep_frequency(ST_START, start);
 80082c0:	2000      	movs	r0, #0
 80082c2:	f7fe ffab 	bl	800721c <set_sweep_frequency>
    set_sweep_frequency(ST_STOP, stop);
 80082c6:	4649      	mov	r1, r9
 80082c8:	2001      	movs	r0, #1
 80082ca:	f7fe ffa7 	bl	800721c <set_sweep_frequency>
    mla_autozone_stage = 1;
 80082ce:	4a50      	ldr	r2, [pc, #320]	@ (8008410 <Thread1+0xc28>)
 80082d0:	2301      	movs	r3, #1
 80082d2:	7013      	strb	r3, [r2, #0]
    return;
 80082d4:	e46b      	b.n	8007bae <Thread1+0x3c6>
    mla_update_bandwidth_swr2();
 80082d6:	f7fe fd49 	bl	8006d6c <mla_update_bandwidth_swr2>
  strncpy(mla_band_name, "n/a", sizeof(mla_band_name));
 80082da:	220c      	movs	r2, #12
 80082dc:	494d      	ldr	r1, [pc, #308]	@ (8008414 <Thread1+0xc2c>)
 80082de:	484e      	ldr	r0, [pc, #312]	@ (8008418 <Thread1+0xc30>)
 80082e0:	f009 faac 	bl	801183c <strncpy>
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 80082e4:	4a4c      	ldr	r2, [pc, #304]	@ (8008418 <Thread1+0xc30>)
 80082e6:	2300      	movs	r3, #0
 80082e8:	72d3      	strb	r3, [r2, #11]
  if (!mla_resonance_locked || mla_res_freq == 0 || mla_bw_swr2 == 0)
 80082ea:	4b45      	ldr	r3, [pc, #276]	@ (8008400 <Thread1+0xc18>)
 80082ec:	681b      	ldr	r3, [r3, #0]
 80082ee:	2b00      	cmp	r3, #0
 80082f0:	d050      	beq.n	8008394 <Thread1+0xbac>
 80082f2:	4a4a      	ldr	r2, [pc, #296]	@ (800841c <Thread1+0xc34>)
 80082f4:	6812      	ldr	r2, [r2, #0]
 80082f6:	2a00      	cmp	r2, #0
 80082f8:	d04c      	beq.n	8008394 <Thread1+0xbac>
  if (f0_hz >= 1800000 && f0_hz <= 2000000)
 80082fa:	4949      	ldr	r1, [pc, #292]	@ (8008420 <Thread1+0xc38>)
 80082fc:	f5a3 12db 	sub.w	r2, r3, #1794048	@ 0x1b6000
 8008300:	f5a2 52ba 	sub.w	r2, r2, #5952	@ 0x1740
 8008304:	428a      	cmp	r2, r1
 8008306:	d955      	bls.n	80083b4 <Thread1+0xbcc>
  else if (f0_hz >= 3500000 && f0_hz <= 4000000)
 8008308:	4a46      	ldr	r2, [pc, #280]	@ (8008424 <Thread1+0xc3c>)
 800830a:	4847      	ldr	r0, [pc, #284]	@ (8008428 <Thread1+0xc40>)
 800830c:	441a      	add	r2, r3
 800830e:	4282      	cmp	r2, r0
 8008310:	d94e      	bls.n	80083b0 <Thread1+0xbc8>
  else if (f0_hz >= 5300000 && f0_hz <= 5500000)
 8008312:	4a46      	ldr	r2, [pc, #280]	@ (800842c <Thread1+0xc44>)
 8008314:	441a      	add	r2, r3
 8008316:	428a      	cmp	r2, r1
 8008318:	d963      	bls.n	80083e2 <Thread1+0xbfa>
  else if (f0_hz >= 7000000 && f0_hz <= 7300000)
 800831a:	4a45      	ldr	r2, [pc, #276]	@ (8008430 <Thread1+0xc48>)
 800831c:	4945      	ldr	r1, [pc, #276]	@ (8008434 <Thread1+0xc4c>)
 800831e:	441a      	add	r2, r3
 8008320:	428a      	cmp	r2, r1
 8008322:	d95c      	bls.n	80083de <Thread1+0xbf6>
  else if (f0_hz >= 10100000 && f0_hz <= 10150000)
 8008324:	f5a3 021a 	sub.w	r2, r3, #10092544	@ 0x9a0000
 8008328:	f5a2 52e9 	sub.w	r2, r2, #7456	@ 0x1d20
 800832c:	f24c 3150 	movw	r1, #50000	@ 0xc350
 8008330:	428a      	cmp	r2, r1
 8008332:	d95e      	bls.n	80083f2 <Thread1+0xc0a>
  else if (f0_hz >= 13900000 && f0_hz <= 14350000)
 8008334:	4940      	ldr	r1, [pc, #256]	@ (8008438 <Thread1+0xc50>)
 8008336:	f5a3 0254 	sub.w	r2, r3, #13893632	@ 0xd40000
 800833a:	f5a2 52c7 	sub.w	r2, r2, #6368	@ 0x18e0
 800833e:	428a      	cmp	r2, r1
 8008340:	d955      	bls.n	80083ee <Thread1+0xc06>
  else if (f0_hz >= 18068000 && f0_hz <= 18168000)
 8008342:	4a3e      	ldr	r2, [pc, #248]	@ (800843c <Thread1+0xc54>)
 8008344:	493e      	ldr	r1, [pc, #248]	@ (8008440 <Thread1+0xc58>)
 8008346:	441a      	add	r2, r3
 8008348:	428a      	cmp	r2, r1
 800834a:	d94e      	bls.n	80083ea <Thread1+0xc02>
  else if (f0_hz >= 21000000 && f0_hz <= 21450000)
 800834c:	4a3d      	ldr	r2, [pc, #244]	@ (8008444 <Thread1+0xc5c>)
 800834e:	483a      	ldr	r0, [pc, #232]	@ (8008438 <Thread1+0xc50>)
 8008350:	441a      	add	r2, r3
 8008352:	4282      	cmp	r2, r0
 8008354:	d947      	bls.n	80083e6 <Thread1+0xbfe>
  else if (f0_hz >= 24890000 && f0_hz <= 24990000)
 8008356:	4a3c      	ldr	r2, [pc, #240]	@ (8008448 <Thread1+0xc60>)
 8008358:	441a      	add	r2, r3
 800835a:	428a      	cmp	r2, r1
 800835c:	d932      	bls.n	80083c4 <Thread1+0xbdc>
  else if (f0_hz >= 28000000 && f0_hz <= 29700000)
 800835e:	4a3b      	ldr	r2, [pc, #236]	@ (800844c <Thread1+0xc64>)
 8008360:	493b      	ldr	r1, [pc, #236]	@ (8008450 <Thread1+0xc68>)
 8008362:	441a      	add	r2, r3
 8008364:	428a      	cmp	r2, r1
 8008366:	d92b      	bls.n	80083c0 <Thread1+0xbd8>
  else if (f0_hz >= 50000000 && f0_hz <= 54000000)
 8008368:	4a3a      	ldr	r2, [pc, #232]	@ (8008454 <Thread1+0xc6c>)
 800836a:	493b      	ldr	r1, [pc, #236]	@ (8008458 <Thread1+0xc70>)
 800836c:	441a      	add	r2, r3
 800836e:	428a      	cmp	r2, r1
 8008370:	d924      	bls.n	80083bc <Thread1+0xbd4>
  else if (f0_hz >= 144000000 && f0_hz <= 148000000)
 8008372:	4a3a      	ldr	r2, [pc, #232]	@ (800845c <Thread1+0xc74>)
 8008374:	441a      	add	r2, r3
 8008376:	428a      	cmp	r2, r1
 8008378:	d91e      	bls.n	80083b8 <Thread1+0xbd0>
  else if (f0_hz >= 430000000 && f0_hz <= 440000000)
 800837a:	4a39      	ldr	r2, [pc, #228]	@ (8008460 <Thread1+0xc78>)
 800837c:	441a      	add	r2, r3
 800837e:	4b39      	ldr	r3, [pc, #228]	@ (8008464 <Thread1+0xc7c>)
 8008380:	429a      	cmp	r2, r3
 8008382:	d821      	bhi.n	80083c8 <Thread1+0xbe0>
    name = "70cm";
 8008384:	4938      	ldr	r1, [pc, #224]	@ (8008468 <Thread1+0xc80>)
    strncpy(mla_band_name, name, sizeof(mla_band_name));
 8008386:	4824      	ldr	r0, [pc, #144]	@ (8008418 <Thread1+0xc30>)
 8008388:	220c      	movs	r2, #12
 800838a:	f009 fa57 	bl	801183c <strncpy>
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 800838e:	4a22      	ldr	r2, [pc, #136]	@ (8008418 <Thread1+0xc30>)
 8008390:	2300      	movs	r3, #0
 8008392:	72d3      	strb	r3, [r2, #11]
    request_to_redraw(REDRAW_BACKUP | REDRAW_AREA); // ensure full screen refresh
 8008394:	f240 4002 	movw	r0, #1026	@ 0x402
 8008398:	f003 fa2a 	bl	800b7f0 <request_to_redraw>
    mla_autozone_stage = 3; // fully done
 800839c:	4a1c      	ldr	r2, [pc, #112]	@ (8008410 <Thread1+0xc28>)
 800839e:	2303      	movs	r3, #3
 80083a0:	7013      	strb	r3, [r2, #0]
    return;
 80083a2:	e404      	b.n	8007bae <Thread1+0x3c6>
    if (left > 0)
 80083a4:	4613      	mov	r3, r2
 80083a6:	9a00      	ldr	r2, [sp, #0]
 80083a8:	2a00      	cmp	r2, #0
 80083aa:	f43f aec6 	beq.w	800813a <Thread1+0x952>
 80083ae:	e6c0      	b.n	8008132 <Thread1+0x94a>
    name = "80m";
 80083b0:	492e      	ldr	r1, [pc, #184]	@ (800846c <Thread1+0xc84>)
 80083b2:	e7e8      	b.n	8008386 <Thread1+0xb9e>
    name = "160m";
 80083b4:	492e      	ldr	r1, [pc, #184]	@ (8008470 <Thread1+0xc88>)
 80083b6:	e7e6      	b.n	8008386 <Thread1+0xb9e>
    name = "2m";
 80083b8:	492e      	ldr	r1, [pc, #184]	@ (8008474 <Thread1+0xc8c>)
 80083ba:	e7e4      	b.n	8008386 <Thread1+0xb9e>
    name = "6m";
 80083bc:	492e      	ldr	r1, [pc, #184]	@ (8008478 <Thread1+0xc90>)
 80083be:	e7e2      	b.n	8008386 <Thread1+0xb9e>
    name = "10m";
 80083c0:	492e      	ldr	r1, [pc, #184]	@ (800847c <Thread1+0xc94>)
 80083c2:	e7e0      	b.n	8008386 <Thread1+0xb9e>
    name = "12m";
 80083c4:	492e      	ldr	r1, [pc, #184]	@ (8008480 <Thread1+0xc98>)
 80083c6:	e7de      	b.n	8008386 <Thread1+0xb9e>
    strncpy(mla_band_name, "outside", sizeof(mla_band_name));
 80083c8:	492e      	ldr	r1, [pc, #184]	@ (8008484 <Thread1+0xc9c>)
 80083ca:	4813      	ldr	r0, [pc, #76]	@ (8008418 <Thread1+0xc30>)
 80083cc:	220c      	movs	r2, #12
 80083ce:	f009 fa35 	bl	801183c <strncpy>
    outside_band = true;
 80083d2:	e7dc      	b.n	800838e <Thread1+0xba6>
 80083d4:	f8df 90c8 	ldr.w	r9, [pc, #200]	@ 80084a0 <Thread1+0xcb8>
 80083d8:	f44f 7116 	mov.w	r1, #600	@ 0x258
 80083dc:	e770      	b.n	80082c0 <Thread1+0xad8>
    name = "40m";
 80083de:	492a      	ldr	r1, [pc, #168]	@ (8008488 <Thread1+0xca0>)
 80083e0:	e7d1      	b.n	8008386 <Thread1+0xb9e>
    name = "60m";
 80083e2:	492a      	ldr	r1, [pc, #168]	@ (800848c <Thread1+0xca4>)
 80083e4:	e7cf      	b.n	8008386 <Thread1+0xb9e>
    name = "15m";
 80083e6:	492a      	ldr	r1, [pc, #168]	@ (8008490 <Thread1+0xca8>)
 80083e8:	e7cd      	b.n	8008386 <Thread1+0xb9e>
    name = "17m";
 80083ea:	492a      	ldr	r1, [pc, #168]	@ (8008494 <Thread1+0xcac>)
 80083ec:	e7cb      	b.n	8008386 <Thread1+0xb9e>
    name = "20m"; // extended range
 80083ee:	492a      	ldr	r1, [pc, #168]	@ (8008498 <Thread1+0xcb0>)
 80083f0:	e7c9      	b.n	8008386 <Thread1+0xb9e>
    name = "30m";
 80083f2:	492a      	ldr	r1, [pc, #168]	@ (800849c <Thread1+0xcb4>)
 80083f4:	e7c7      	b.n	8008386 <Thread1+0xb9e>
 80083f6:	bf00      	nop
 80083f8:	20006870 	.word	0x20006870
 80083fc:	20006874 	.word	0x20006874
 8008400:	2000687c 	.word	0x2000687c
 8008404:	20006875 	.word	0x20006875
 8008408:	0003d090 	.word	0x0003d090
 800840c:	a0eebb00 	.word	0xa0eebb00
 8008410:	2000686d 	.word	0x2000686d
 8008414:	080119e0 	.word	0x080119e0
 8008418:	200003c8 	.word	0x200003c8
 800841c:	20006868 	.word	0x20006868
 8008420:	00030d40 	.word	0x00030d40
 8008424:	ffca9820 	.word	0xffca9820
 8008428:	0007a120 	.word	0x0007a120
 800842c:	ffaf20e0 	.word	0xffaf20e0
 8008430:	ff953040 	.word	0xff953040
 8008434:	000493e0 	.word	0x000493e0
 8008438:	0006ddd0 	.word	0x0006ddd0
 800843c:	feec4de0 	.word	0xfeec4de0
 8008440:	000186a0 	.word	0x000186a0
 8008444:	febf90c0 	.word	0xfebf90c0
 8008448:	fe843570 	.word	0xfe843570
 800844c:	fe54c100 	.word	0xfe54c100
 8008450:	0019f0a0 	.word	0x0019f0a0
 8008454:	fd050f80 	.word	0xfd050f80
 8008458:	003d0900 	.word	0x003d0900
 800845c:	f76abc00 	.word	0xf76abc00
 8008460:	e65eb880 	.word	0xe65eb880
 8008464:	00989680 	.word	0x00989680
 8008468:	080119d8 	.word	0x080119d8
 800846c:	080119ac 	.word	0x080119ac
 8008470:	080119a4 	.word	0x080119a4
 8008474:	080119d4 	.word	0x080119d4
 8008478:	080119d0 	.word	0x080119d0
 800847c:	080119cc 	.word	0x080119cc
 8008480:	080119c8 	.word	0x080119c8
 8008484:	080119e4 	.word	0x080119e4
 8008488:	080119b4 	.word	0x080119b4
 800848c:	080119b0 	.word	0x080119b0
 8008490:	080119c4 	.word	0x080119c4
 8008494:	080119c0 	.word	0x080119c0
 8008498:	080119bc 	.word	0x080119bc
 800849c:	080119b8 	.word	0x080119b8
 80084a0:	0007a378 	.word	0x0007a378

080084a4 <set_trace_enable>:
{
 80084a4:	b508      	push	{r3, lr}
  trace[t].enabled = enable;
 80084a6:	4b10      	ldr	r3, [pc, #64]	@ (80084e8 <set_trace_enable+0x44>)
 80084a8:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80084ac:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80084b0:	f882 1028 	strb.w	r1, [r2, #40]	@ 0x28
  current_trace = enable ? t : TRACE_INVALID;
 80084b4:	b129      	cbz	r1, 80084c2 <set_trace_enable+0x1e>
 80084b6:	7718      	strb	r0, [r3, #28]
}
 80084b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_AREA);
 80084bc:	2002      	movs	r0, #2
 80084be:	f003 b997 	b.w	800b7f0 <request_to_redraw>
  current_trace = enable ? t : TRACE_INVALID;
 80084c2:	22ff      	movs	r2, #255	@ 0xff
 80084c4:	771a      	strb	r2, [r3, #28]
      if (trace[i].enabled)
 80084c6:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
    for (int i = 0; i < TRACES_MAX; i++) // set first enabled as current trace
 80084ca:	330c      	adds	r3, #12
      if (trace[i].enabled)
 80084cc:	b93a      	cbnz	r2, 80084de <set_trace_enable+0x3a>
    for (int i = 0; i < TRACES_MAX; i++) // set first enabled as current trace
 80084ce:	3101      	adds	r1, #1
 80084d0:	2904      	cmp	r1, #4
 80084d2:	d1f8      	bne.n	80084c6 <set_trace_enable+0x22>
}
 80084d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_AREA);
 80084d8:	2002      	movs	r0, #2
 80084da:	f003 b989 	b.w	800b7f0 <request_to_redraw>
        set_active_trace(i);
 80084de:	4608      	mov	r0, r1
 80084e0:	f7ff f91c 	bl	800771c <set_active_trace>
        break;
 80084e4:	e7e8      	b.n	80084b8 <set_trace_enable+0x14>
 80084e6:	bf00      	nop
 80084e8:	20000aa8 	.word	0x20000aa8

080084ec <cmd_trace>:
{
 80084ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (argc == 0)
 80084ee:	b978      	cbnz	r0, 8008510 <cmd_trace+0x24>
 80084f0:	4c49      	ldr	r4, [pc, #292]	@ (8008618 <cmd_trace+0x12c>)
 80084f2:	f104 0530 	add.w	r5, r4, #48	@ 0x30
      if (trace[t].enabled)
 80084f6:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 80084fa:	b91b      	cbnz	r3, 8008504 <cmd_trace+0x18>
    for (t = 0; t < TRACES_MAX; t++)
 80084fc:	340c      	adds	r4, #12
 80084fe:	42ac      	cmp	r4, r5
 8008500:	d1f9      	bne.n	80084f6 <cmd_trace+0xa>
}
 8008502:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        const char *type = get_trace_typename(trace[t].type, 0);
 8008504:	f894 0029 	ldrb.w	r0, [r4, #41]	@ 0x29
 8008508:	2100      	movs	r1, #0
 800850a:	f002 fe95 	bl	800b238 <get_trace_typename>
        shell_printf("%d %s %s %f %f" VNA_SHELL_NEWLINE_STR, t, type, channel, scale, refpos);
 800850e:	e7f5      	b.n	80084fc <cmd_trace+0x10>
  if (get_str_index(argv[0], "all") == 0 &&
 8008510:	460e      	mov	r6, r1
 8008512:	4604      	mov	r4, r0
 8008514:	4941      	ldr	r1, [pc, #260]	@ (800861c <cmd_trace+0x130>)
 8008516:	6830      	ldr	r0, [r6, #0]
 8008518:	f000 fb0c 	bl	8008b34 <get_str_index>
 800851c:	b908      	cbnz	r0, 8008522 <cmd_trace+0x36>
 800851e:	2c01      	cmp	r4, #1
 8008520:	dc24      	bgt.n	800856c <cmd_trace+0x80>
  t = (uint32_t)my_atoi(argv[0]);
 8008522:	6830      	ldr	r0, [r6, #0]
 8008524:	f000 fa2c 	bl	8008980 <my_atoi>
  if (t >= TRACES_MAX)
 8008528:	2803      	cmp	r0, #3
  t = (uint32_t)my_atoi(argv[0]);
 800852a:	4605      	mov	r5, r0
  if (t >= TRACES_MAX)
 800852c:	d8e9      	bhi.n	8008502 <cmd_trace+0x16>
  if (argc == 1)
 800852e:	2c01      	cmp	r4, #1
 8008530:	d02e      	beq.n	8008590 <cmd_trace+0xa4>
  if (get_str_index(argv[1], "off") == 0)
 8008532:	493b      	ldr	r1, [pc, #236]	@ (8008620 <cmd_trace+0x134>)
 8008534:	6870      	ldr	r0, [r6, #4]
 8008536:	f000 fafd 	bl	8008b34 <get_str_index>
 800853a:	b318      	cbz	r0, 8008584 <cmd_trace+0x98>
  int type = get_str_index(argv[1], cmd_type_list);
 800853c:	4939      	ldr	r1, [pc, #228]	@ (8008624 <cmd_trace+0x138>)
 800853e:	6870      	ldr	r0, [r6, #4]
 8008540:	f000 faf8 	bl	8008b34 <get_str_index>
  if (type >= 0)
 8008544:	1e07      	subs	r7, r0, #0
 8008546:	db38      	blt.n	80085ba <cmd_trace+0xce>
    if (argc > 2)
 8008548:	2c02      	cmp	r4, #2
 800854a:	dd4d      	ble.n	80085e8 <cmd_trace+0xfc>
      src = my_atoi(argv[2]);
 800854c:	68b0      	ldr	r0, [r6, #8]
 800854e:	f000 fa17 	bl	8008980 <my_atoi>
      if ((uint32_t)src > 1)
 8008552:	2801      	cmp	r0, #1
      src = my_atoi(argv[2]);
 8008554:	4602      	mov	r2, r0
      if ((uint32_t)src > 1)
 8008556:	d8d4      	bhi.n	8008502 <cmd_trace+0x16>
    set_trace_type(t, type, src);
 8008558:	4639      	mov	r1, r7
 800855a:	4628      	mov	r0, r5
 800855c:	f7ff f914 	bl	8007788 <set_trace_type>
    set_trace_enable(t, true);
 8008560:	4628      	mov	r0, r5
 8008562:	2101      	movs	r1, #1
}
 8008564:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    set_trace_enable(t, true);
 8008568:	f7ff bf9c 	b.w	80084a4 <set_trace_enable>
      argc > 1 && get_str_index(argv[1], "off") == 0)
 800856c:	492c      	ldr	r1, [pc, #176]	@ (8008620 <cmd_trace+0x134>)
 800856e:	6870      	ldr	r0, [r6, #4]
 8008570:	f000 fae0 	bl	8008b34 <get_str_index>
 8008574:	b1c0      	cbz	r0, 80085a8 <cmd_trace+0xbc>
  t = (uint32_t)my_atoi(argv[0]);
 8008576:	6830      	ldr	r0, [r6, #0]
 8008578:	f000 fa02 	bl	8008980 <my_atoi>
  if (t >= TRACES_MAX)
 800857c:	2803      	cmp	r0, #3
  t = (uint32_t)my_atoi(argv[0]);
 800857e:	4605      	mov	r5, r0
  if (t >= TRACES_MAX)
 8008580:	d9d7      	bls.n	8008532 <cmd_trace+0x46>
 8008582:	e7be      	b.n	8008502 <cmd_trace+0x16>
    set_trace_enable(t, false);
 8008584:	4601      	mov	r1, r0
 8008586:	4628      	mov	r0, r5
}
 8008588:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    set_trace_enable(t, false);
 800858c:	f7ff bf8a 	b.w	80084a4 <set_trace_enable>
    const char *type = get_trace_typename(trace[t].type, 0);
 8008590:	4b21      	ldr	r3, [pc, #132]	@ (8008618 <cmd_trace+0x12c>)
 8008592:	eb00 0540 	add.w	r5, r0, r0, lsl #1
 8008596:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 800859a:	2100      	movs	r1, #0
 800859c:	f893 0029 	ldrb.w	r0, [r3, #41]	@ 0x29
}
 80085a0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    const char *type = get_trace_typename(trace[t].type, 0);
 80085a4:	f002 be48 	b.w	800b238 <get_trace_typename>
    for (t = 0; t < TRACES_MAX; t++)
 80085a8:	4604      	mov	r4, r0
      set_trace_enable(t, false);
 80085aa:	4620      	mov	r0, r4
 80085ac:	2100      	movs	r1, #0
    for (t = 0; t < TRACES_MAX; t++)
 80085ae:	3401      	adds	r4, #1
      set_trace_enable(t, false);
 80085b0:	f7ff ff78 	bl	80084a4 <set_trace_enable>
    for (t = 0; t < TRACES_MAX; t++)
 80085b4:	2c04      	cmp	r4, #4
 80085b6:	d1f8      	bne.n	80085aa <cmd_trace+0xbe>
}
 80085b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  int format = get_str_index(argv[1], cmd_marker_smith);
 80085ba:	491b      	ldr	r1, [pc, #108]	@ (8008628 <cmd_trace+0x13c>)
 80085bc:	6870      	ldr	r0, [r6, #4]
 80085be:	f000 fab9 	bl	8008b34 <get_str_index>
  if (format >= 0)
 80085c2:	2800      	cmp	r0, #0
 80085c4:	da18      	bge.n	80085f8 <cmd_trace+0x10c>
  if (argc >= 3)
 80085c6:	2c02      	cmp	r4, #2
 80085c8:	dd9b      	ble.n	8008502 <cmd_trace+0x16>
    switch (get_str_index(argv[1], cmd_scale_ref_list))
 80085ca:	4918      	ldr	r1, [pc, #96]	@ (800862c <cmd_trace+0x140>)
 80085cc:	6870      	ldr	r0, [r6, #4]
 80085ce:	f000 fab1 	bl	8008b34 <get_str_index>
 80085d2:	b1c8      	cbz	r0, 8008608 <cmd_trace+0x11c>
 80085d4:	2801      	cmp	r0, #1
 80085d6:	d194      	bne.n	8008502 <cmd_trace+0x16>
      set_trace_refpos(t, my_atof(argv[2]));
 80085d8:	68b0      	ldr	r0, [r6, #8]
 80085da:	f000 fa11 	bl	8008a00 <my_atof>
 80085de:	4628      	mov	r0, r5
}
 80085e0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      set_trace_refpos(t, my_atof(argv[2]));
 80085e4:	f7ff b8bc 	b.w	8007760 <set_trace_refpos>
    int src = trace[t].channel;
 80085e8:	4b0b      	ldr	r3, [pc, #44]	@ (8008618 <cmd_trace+0x12c>)
 80085ea:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 80085ee:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80085f2:	f893 202a 	ldrb.w	r2, [r3, #42]	@ 0x2a
 80085f6:	e7af      	b.n	8008558 <cmd_trace+0x6c>
    trace[t].smith_format = format;
 80085f8:	4b07      	ldr	r3, [pc, #28]	@ (8008618 <cmd_trace+0x12c>)
 80085fa:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80085fe:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8008602:	f883 002b 	strb.w	r0, [r3, #43]	@ 0x2b
}
 8008606:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      set_trace_scale(t, my_atof(argv[2]));
 8008608:	68b0      	ldr	r0, [r6, #8]
 800860a:	f000 f9f9 	bl	8008a00 <my_atof>
 800860e:	4628      	mov	r0, r5
}
 8008610:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      set_trace_scale(t, my_atof(argv[2]));
 8008614:	f7ff b890 	b.w	8007738 <set_trace_scale>
 8008618:	20000aa8 	.word	0x20000aa8
 800861c:	080119ec 	.word	0x080119ec
 8008620:	080119f0 	.word	0x080119f0
 8008624:	08013be0 	.word	0x08013be0
 8008628:	08013ba4 	.word	0x08013ba4
 800862c:	08013b94 	.word	0x08013b94

08008630 <set_electrical_delay>:
  if (current_props._electrical_delay[ch] == seconds)
 8008630:	4b08      	ldr	r3, [pc, #32]	@ (8008654 <set_electrical_delay+0x24>)
 8008632:	3026      	adds	r0, #38	@ 0x26
 8008634:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8008638:	edd3 7a01 	vldr	s15, [r3, #4]
 800863c:	eef4 7a40 	vcmp.f32	s15, s0
 8008640:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008644:	d100      	bne.n	8008648 <set_electrical_delay+0x18>
}
 8008646:	4770      	bx	lr
  request_to_redraw(REDRAW_MARKER);
 8008648:	2020      	movs	r0, #32
  current_props._electrical_delay[ch] = seconds;
 800864a:	ed83 0a01 	vstr	s0, [r3, #4]
  request_to_redraw(REDRAW_MARKER);
 800864e:	f003 b8cf 	b.w	800b7f0 <request_to_redraw>
 8008652:	bf00      	nop
 8008654:	20000aa8 	.word	0x20000aa8

08008658 <cmd_edelay>:
{
 8008658:	b570      	push	{r4, r5, r6, lr}
  if (argc >= 1)
 800865a:	1e04      	subs	r4, r0, #0
 800865c:	dc00      	bgt.n	8008660 <cmd_edelay+0x8>
}
 800865e:	bd70      	pop	{r4, r5, r6, pc}
    int idx = get_str_index(argv[0], cmd_edelay_list);
 8008660:	460d      	mov	r5, r1
 8008662:	490d      	ldr	r1, [pc, #52]	@ (8008698 <cmd_edelay+0x40>)
 8008664:	6828      	ldr	r0, [r5, #0]
 8008666:	f000 fa65 	bl	8008b34 <get_str_index>
    if (idx == -1)
 800866a:	1c43      	adds	r3, r0, #1
    int idx = get_str_index(argv[0], cmd_edelay_list);
 800866c:	4606      	mov	r6, r0
    if (idx == -1)
 800866e:	d00d      	beq.n	800868c <cmd_edelay+0x34>
      if (argc != 2)
 8008670:	2c02      	cmp	r4, #2
 8008672:	d1f4      	bne.n	800865e <cmd_edelay+0x6>
      value = my_atof(argv[0]);
 8008674:	6828      	ldr	r0, [r5, #0]
 8008676:	f000 f9c3 	bl	8008a00 <my_atof>
    set_electrical_delay(ch, value * 1e-12); // input value in seconds
 800867a:	eddf 7a08 	vldr	s15, [pc, #32]	@ 800869c <cmd_edelay+0x44>
 800867e:	4630      	mov	r0, r6
 8008680:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 8008684:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    set_electrical_delay(ch, value * 1e-12); // input value in seconds
 8008688:	f7ff bfd2 	b.w	8008630 <set_electrical_delay>
      value = my_atof(argv[0]);
 800868c:	6828      	ldr	r0, [r5, #0]
 800868e:	f000 f9b7 	bl	8008a00 <my_atof>
  int ch = 0;
 8008692:	2600      	movs	r6, #0
 8008694:	e7f1      	b.n	800867a <cmd_edelay+0x22>
 8008696:	bf00      	nop
 8008698:	08013c60 	.word	0x08013c60
 800869c:	2b8cbccc 	.word	0x2b8cbccc

080086a0 <get_electrical_delay>:
  if (current_trace == TRACE_INVALID)
 80086a0:	4a09      	ldr	r2, [pc, #36]	@ (80086c8 <get_electrical_delay+0x28>)
 80086a2:	f992 301c 	ldrsb.w	r3, [r2, #28]
 80086a6:	1c59      	adds	r1, r3, #1
 80086a8:	d00a      	beq.n	80086c0 <get_electrical_delay+0x20>
  int ch = trace[current_trace].channel;
 80086aa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80086ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80086b2:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
  return current_props._electrical_delay[ch];
 80086b6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80086ba:	ed92 0a27 	vldr	s0, [r2, #156]	@ 0x9c
 80086be:	4770      	bx	lr
    return 0.0f;
 80086c0:	ed9f 0a02 	vldr	s0, [pc, #8]	@ 80086cc <get_electrical_delay+0x2c>
}
 80086c4:	4770      	bx	lr
 80086c6:	bf00      	nop
 80086c8:	20000aa8 	.word	0x20000aa8
 80086cc:	00000000 	.word	0x00000000

080086d0 <set_s21_offset>:
  if (s21_offset != offset)
 80086d0:	4b06      	ldr	r3, [pc, #24]	@ (80086ec <set_s21_offset+0x1c>)
 80086d2:	edd3 7a2a 	vldr	s15, [r3, #168]	@ 0xa8
 80086d6:	eef4 7a40 	vcmp.f32	s15, s0
 80086da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086de:	d100      	bne.n	80086e2 <set_s21_offset+0x12>
}
 80086e0:	4770      	bx	lr
    request_to_redraw(REDRAW_MARKER);
 80086e2:	2020      	movs	r0, #32
    s21_offset = offset;
 80086e4:	ed83 0a2a 	vstr	s0, [r3, #168]	@ 0xa8
    request_to_redraw(REDRAW_MARKER);
 80086e8:	f003 b882 	b.w	800b7f0 <request_to_redraw>
 80086ec:	20000aa8 	.word	0x20000aa8

080086f0 <cmd_s21offset>:
  if (argc != 1)
 80086f0:	2801      	cmp	r0, #1
 80086f2:	d000      	beq.n	80086f6 <cmd_s21offset+0x6>
 80086f4:	4770      	bx	lr
{
 80086f6:	b508      	push	{r3, lr}
  set_s21_offset(my_atof(argv[0])); // input value in dB
 80086f8:	6808      	ldr	r0, [r1, #0]
 80086fa:	f000 f981 	bl	8008a00 <my_atof>
}
 80086fe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_s21_offset(my_atof(argv[0])); // input value in dB
 8008702:	f7ff bfe5 	b.w	80086d0 <set_s21_offset>
 8008706:	bf00      	nop

08008708 <send_region>:
{
 8008708:	b538      	push	{r3, r4, r5, lr}
  if (SDU1.config->usbp->state == USB_ACTIVE)
 800870a:	4b0e      	ldr	r3, [pc, #56]	@ (8008744 <send_region+0x3c>)
 800870c:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 8008710:	681b      	ldr	r3, [r3, #0]
 8008712:	781b      	ldrb	r3, [r3, #0]
 8008714:	2b04      	cmp	r3, #4
 8008716:	d005      	beq.n	8008724 <send_region+0x1c>
    sweep_mode &= ~SWEEP_REMOTE;
 8008718:	4a0b      	ldr	r2, [pc, #44]	@ (8008748 <send_region+0x40>)
 800871a:	7813      	ldrb	r3, [r2, #0]
 800871c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8008720:	7013      	strb	r3, [r2, #0]
}
 8008722:	bd38      	pop	{r3, r4, r5, pc}
 8008724:	4615      	mov	r5, r2
    shell_write(rd, sizeof(remote_region_t));
 8008726:	460c      	mov	r4, r1
 8008728:	210e      	movs	r1, #14
 800872a:	f7fc fe9d 	bl	8005468 <shell_write>
    shell_write(buf, size);
 800872e:	4629      	mov	r1, r5
 8008730:	4620      	mov	r0, r4
 8008732:	f7fc fe99 	bl	8005468 <shell_write>
}
 8008736:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    shell_write(VNA_SHELL_PROMPT_STR VNA_SHELL_NEWLINE_STR, 6);
 800873a:	4804      	ldr	r0, [pc, #16]	@ (800874c <send_region+0x44>)
 800873c:	2106      	movs	r1, #6
 800873e:	f7fc be93 	b.w	8005468 <shell_write>
 8008742:	bf00      	nop
 8008744:	200007b0 	.word	0x200007b0
 8008748:	200003c4 	.word	0x200003c4
 800874c:	080119f4 	.word	0x080119f4

08008750 <VNAShell_executeCMDLine>:
  else if (**shell_args) // unknown command (not empty), ignore <CR>
    shell_printf("%s?" VNA_SHELL_NEWLINE_STR, shell_args[0]);
}

void VNAShell_executeCMDLine(char *line)
{
 8008750:	b510      	push	{r4, lr}
  // Disable shell output (not allow shell_printf write, but not block other output!!)
  shell_stream = NULL;
 8008752:	4c09      	ldr	r4, [pc, #36]	@ (8008778 <VNAShell_executeCMDLine+0x28>)
 8008754:	2300      	movs	r3, #0
 8008756:	6023      	str	r3, [r4, #0]
  const VNAShellCommand *scp = VNAShell_parceLine(line);
 8008758:	f7fc ffee 	bl	8005738 <VNAShell_parceLine>
  if (scp && (scp->flags & CMD_RUN_IN_LOAD))
 800875c:	b140      	cbz	r0, 8008770 <VNAShell_executeCMDLine+0x20>
 800875e:	8903      	ldrh	r3, [r0, #8]
 8008760:	071b      	lsls	r3, r3, #28
 8008762:	d505      	bpl.n	8008770 <VNAShell_executeCMDLine+0x20>
    scp->sc_function(shell_nargs - 1, &shell_args[1]);
 8008764:	4a05      	ldr	r2, [pc, #20]	@ (800877c <VNAShell_executeCMDLine+0x2c>)
 8008766:	6843      	ldr	r3, [r0, #4]
 8008768:	8810      	ldrh	r0, [r2, #0]
 800876a:	4905      	ldr	r1, [pc, #20]	@ (8008780 <VNAShell_executeCMDLine+0x30>)
 800876c:	3801      	subs	r0, #1
 800876e:	4798      	blx	r3
  PREPARE_STREAM;
 8008770:	4b04      	ldr	r3, [pc, #16]	@ (8008784 <VNAShell_executeCMDLine+0x34>)
 8008772:	6023      	str	r3, [r4, #0]
}
 8008774:	bd10      	pop	{r4, pc}
 8008776:	bf00      	nop
 8008778:	200068a4 	.word	0x200068a4
 800877c:	20006884 	.word	0x20006884
 8008780:	2000688c 	.word	0x2000688c
 8008784:	200007b0 	.word	0x200007b0

08008788 <main>:
// Main thread stack size defined in makefile USE_PROCESS_STACKSIZE = 0x200
// Profile stack usage (enable threads command by def ENABLE_THREADS_COMMAND) show:
// Stack maximum usage = 472 bytes (need test more and run all commands), free stack = 40 bytes
//
int main(void)
{
 8008788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800878c:	b083      	sub	sp, #12
  /*
   * Initialize ChibiOS systems
   */
  halInit();
 800878e:	f7f8 fc01 	bl	8000f94 <halInit>
  chSysInit();
 8008792:	f7f8 f911 	bl	80009b8 <chSysInit>
   * Init used hardware
   */
  /*
   *  Init DMA channels (used for direct send data, used for i2s and spi)
   */
  rccEnableDMA1(false);
 8008796:	4a64      	ldr	r2, [pc, #400]	@ (8008928 <main+0x1a0>)
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 8008798:	4e64      	ldr	r6, [pc, #400]	@ (800892c <main+0x1a4>)
  rccEnableDMA1(false);
 800879a:	6953      	ldr	r3, [r2, #20]
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 800879c:	4c64      	ldr	r4, [pc, #400]	@ (8008930 <main+0x1a8>)
  current_props._frequency1 = 900000000; // end   = 900MHz
 800879e:	f8df 81d8 	ldr.w	r8, [pc, #472]	@ 8008978 <main+0x1f0>
  rccEnableDMA1(false);
 80087a2:	f043 0301 	orr.w	r3, r3, #1
 80087a6:	6153      	str	r3, [r2, #20]

/*
 * Init GPIO (pin control)
 */
#if HAL_USE_PAL == FALSE
  initPal();
 80087a8:	f008 fbda 	bl	8010f60 <initPal>

/*
 * Initialize RTC library (not used ChibiOS RTC module)
 */
#ifdef __USE_RTC__
  rtc_init();
 80087ac:	f008 fadc 	bl	8010d68 <rtc_init>

/*
 * Starting DAC1 driver, setting up the output pin as analog as suggested by the Reference Manual.
 */
#if defined(__VNA_ENABLE_DAC__) || defined(__LCD_BRIGHTNESS__)
  dac_init();
 80087b0:	f008 fb4a 	bl	8010e48 <dac_init>
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 80087b4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80087b6:	f104 0528 	add.w	r5, r4, #40	@ 0x28
 80087ba:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80087bc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80087be:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80087c0:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 80087c4:	f8df e1b4 	ldr.w	lr, [pc, #436]	@ 800897c <main+0x1f4>
  current_props._electrical_delay[0] = 0.0f;
 80087c8:	eddf 7a5a 	vldr	s15, [pc, #360]	@ 8008934 <main+0x1ac>
  current_props._portz = 50.0f;
 80087cc:	ed9f 7a5a 	vldr	s14, [pc, #360]	@ 8008938 <main+0x1b0>
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 80087d0:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 80087d4:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80087d8:	f104 0c58 	add.w	ip, r4, #88	@ 0x58
 80087dc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80087e0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80087e4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  current_props.magic = PROPERTIES_MAGIC;
 80087e8:	4b54      	ldr	r3, [pc, #336]	@ (800893c <main+0x1b4>)
 80087ea:	6023      	str	r3, [r4, #0]
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 80087ec:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80087f0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80087f4:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
 80087f8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  current_props._mode = 0;
 80087fc:	4b50      	ldr	r3, [pc, #320]	@ (8008940 <main+0x1b8>)
  current_props._electrical_delay[0] = 0.0f;
 80087fe:	edc4 7a27 	vstr	s15, [r4, #156]	@ 0x9c
  current_props._frequency0 = 50000;     // start =  50kHz
 8008802:	f24c 3950 	movw	r9, #50000	@ 0xc350
  current_props._reserved = 0;
 8008806:	f44f 4a8c 	mov.w	sl, #17920	@ 0x4600
  current_props._electrical_delay[1] = 0.0f;
 800880a:	edc4 7a28 	vstr	s15, [r4, #160]	@ 0xa0
  current_props._var_delay = 0.0f;
 800880e:	edc4 7a29 	vstr	s15, [r4, #164]	@ 0xa4
  current_props._s21_offset = 0.0f;
 8008812:	edc4 7a2a 	vstr	s15, [r4, #168]	@ 0xa8
  current_props._portz = 50.0f;
 8008816:	ed84 7a2b 	vstr	s14, [r4, #172]	@ 0xac
  current_props._cal_load_r = 50.0f;
 800881a:	ed84 7a2c 	vstr	s14, [r4, #176]	@ 0xb0
  current_props._var_freq = 0;
 800881e:	2700      	movs	r7, #0
  current_props._reserved = 0;
 8008820:	f8a4 a098 	strh.w	sl, [r4, #152]	@ 0x98
  current_props._current_trace = 0;
 8008824:	f06f 0bff 	mvn.w	fp, #255	@ 0xff
  current_props._frequency0 = 50000;     // start =  50kHz
 8008828:	f8c4 9004 	str.w	r9, [r4, #4]
  current_props._mode = 0;
 800882c:	61a3      	str	r3, [r4, #24]
  current_props._power = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 800882e:	33ff      	adds	r3, #255	@ 0xff
 8008830:	6223      	str	r3, [r4, #32]
  current_props._var_freq = 0;
 8008832:	e9c4 8704 	strd	r8, r7, [r4, #16]
  current_props._cal_frequency0 = 50000;     // calibration start =  50kHz
 8008836:	f8c4 900c 	str.w	r9, [r4, #12]
  current_props._frequency1 = 900000000; // end   = 900MHz
 800883a:	f8c4 8008 	str.w	r8, [r4, #8]
  current_props._current_trace = 0;
 800883e:	f8c4 b01c 	str.w	fp, [r4, #28]
  current_props._cal_sweep_points = 401;     // Set calibration default points count
 8008842:	84a7      	strh	r7, [r4, #36]	@ 0x24
  config_recall();
 8008844:	f007 ffc4 	bl	80107d0 <config_recall>
  load_properties(0);
 8008848:	4638      	mov	r0, r7
 800884a:	f7fe fc3b 	bl	80070c4 <load_properties>
  load_settings();

  /*
   * MLA Toolbox: force startup sweep range to 330 MHz
   */
  set_sweep_frequency(ST_START, 3000000); // 3 MHz
 800884e:	493d      	ldr	r1, [pc, #244]	@ (8008944 <main+0x1bc>)
  sduObjectInit(&SDU1);
 8008850:	4d3d      	ldr	r5, [pc, #244]	@ (8008948 <main+0x1c0>)
  set_sweep_frequency(ST_START, 3000000); // 3 MHz
 8008852:	4638      	mov	r0, r7
 8008854:	f7fe fce2 	bl	800721c <set_sweep_frequency>
  set_sweep_frequency(ST_STOP, 30000000); // 30 MHz
 8008858:	493c      	ldr	r1, [pc, #240]	@ (800894c <main+0x1c4>)
 800885a:	2001      	movs	r0, #1
 800885c:	f7fe fcde 	bl	800721c <set_sweep_frequency>
  set_sweep_points(401);
 8008860:	f240 1091 	movw	r0, #401	@ 0x191
 8008864:	f7fe fc4c 	bl	8007100 <set_sweep_points>
   * trace 0: S11 logmag (keep enabled)
   * trace 1: S21 logmag (disable)
   * trace 2: S11 smith  (disable)
   * trace 3: S21 phase  (keep enabled)
   */
  set_trace_enable(1, false); // disable S21 logmag
 8008868:	4639      	mov	r1, r7
 800886a:	2001      	movs	r0, #1
 800886c:	f7ff fe1a 	bl	80084a4 <set_trace_enable>
  set_trace_enable(2, false); // disable S11 smith
 8008870:	4639      	mov	r1, r7
 8008872:	2002      	movs	r0, #2
 8008874:	f7ff fe16 	bl	80084a4 <set_trace_enable>
  set_active_trace(0);        // make sure S11 logmag is the active trace
 8008878:	4638      	mov	r0, r7
 800887a:	f7fe ff4f 	bl	800771c <set_active_trace>

  /*
   * MLA Toolbox: purple trace (trace 3) = SWR of S11
   */
  set_trace_type(3, TRC_SWR, 0); // TRC_SWR on channel 0 (S11)
 800887e:	463a      	mov	r2, r7
 8008880:	2106      	movs	r1, #6
 8008882:	2003      	movs	r0, #3
 8008884:	f7fe ff80 	bl	8007788 <set_trace_type>

  /*
   * I2C bus
   */
  i2c_start();
 8008888:	f008 f9b6 	bl	8010bf8 <i2c_start>

  /*
   * Start si5351
   */
  si5351_init();
 800888c:	f000 fcc8 	bl	8009220 <si5351_init>

/*
 * Set frequency offset
 */
#ifdef USE_VARIABLE_OFFSET
  si5351_set_frequency_offset(IF_OFFSET);
 8008890:	4b2f      	ldr	r3, [pc, #188]	@ (8008950 <main+0x1c8>)
 8008892:	6898      	ldr	r0, [r3, #8]
 8008894:	f000 f9ec 	bl	8008c70 <si5351_set_frequency_offset>
  sduObjectInit(&SDU1);
 8008898:	4628      	mov	r0, r5
 800889a:	f7f8 ff03 	bl	80016a4 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 800889e:	492d      	ldr	r1, [pc, #180]	@ (8008954 <main+0x1cc>)
 80088a0:	4628      	mov	r0, r5
 80088a2:	f7f8 ff23 	bl	80016ec <sduStart>
  usbDisconnectBus(&USBD1);
 80088a6:	210c      	movs	r1, #12
 80088a8:	2201      	movs	r2, #1
 80088aa:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80088ae:	f008 fbb1 	bl	8011014 <palSetPadMode>
 80088b2:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
 80088b6:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 80088ba:	6193      	str	r3, [r2, #24]
  chThdSleepMilliseconds(100);
 80088bc:	f242 7010 	movw	r0, #10000	@ 0x2710
 80088c0:	f7f8 fae6 	bl	8000e90 <chThdSleep>
  usbStart(&USBD1, &usbcfg);
 80088c4:	4924      	ldr	r1, [pc, #144]	@ (8008958 <main+0x1d0>)
 80088c6:	4825      	ldr	r0, [pc, #148]	@ (800895c <main+0x1d4>)
 80088c8:	f7f9 f812 	bl	80018f0 <usbStart>
  usbConnectBus(&USBD1);
 80088cc:	f240 7202 	movw	r2, #1794	@ 0x702
 80088d0:	210c      	movs	r1, #12
 80088d2:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80088d6:	f008 fb9d 	bl	8011014 <palSetPadMode>
  PREPARE_STREAM;
 80088da:	4b21      	ldr	r3, [pc, #132]	@ (8008960 <main+0x1d8>)
 80088dc:	2405      	movs	r4, #5
 80088de:	601d      	str	r5, [r3, #0]



for (int i = 0; i < 5; i++) {
  shell_printf("hello world %d\r\n", i + 1);
  chThdSleepMilliseconds(10);
 80088e0:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 80088e4:	f7f8 fad4 	bl	8000e90 <chThdSleep>
for (int i = 0; i < 5; i++) {
 80088e8:	3c01      	subs	r4, #1
 80088ea:	d1f9      	bne.n	80088e0 <main+0x158>
#endif

  /*
   * SPI bus and LCD Initialize
   */
  lcd_init();
 80088ec:	f007 fbaa 	bl	8010044 <lcd_init>



   * tlv320aic Initialize (audio codec)
   */
  tlv320aic3204_init();
 80088f0:	f000 fcc2 	bl	8009278 <tlv320aic3204_init>
  chThdSleepMilliseconds(200); // Wait for aic codec start
 80088f4:	f644 6020 	movw	r0, #20000	@ 0x4e20
 80088f8:	f7f8 faca 	bl	8000e90 <chThdSleep>
                               /*
                                * I2S Initialize
                                */
  initI2S(rx_buffer, ARRAY_COUNT(rx_buffer) * sizeof(audio_sample_t) / sizeof(int16_t));
 80088fc:	21c0      	movs	r1, #192	@ 0xc0
 80088fe:	4819      	ldr	r0, [pc, #100]	@ (8008964 <main+0x1dc>)
 8008900:	f008 fab8 	bl	8010e74 <initI2S>
/*
 * SD Card init (if inserted) allow fix issues
 * Some card after insert work in SDIO mode and can corrupt SPI exchange (need switch it to SPI)
 */
#ifdef __USE_SD_CARD__
  disk_initialize(0);
 8008904:	4620      	mov	r0, r4
 8008906:	f007 fdc1 	bl	801048c <disk_initialize>
#endif

  /*
   * I2C bus run on work speed
   */
  i2c_set_timings(STM32_I2C_TIMINGR);
 800890a:	4817      	ldr	r0, [pc, #92]	@ (8008968 <main+0x1e0>)
 800890c:	f008 f966 	bl	8010bdc <i2c_set_timings>

  /*
   * Startup sweep thread
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO - 1, Thread1, NULL);
 8008910:	4b16      	ldr	r3, [pc, #88]	@ (800896c <main+0x1e4>)
 8008912:	4817      	ldr	r0, [pc, #92]	@ (8008970 <main+0x1e8>)
 8008914:	9400      	str	r4, [sp, #0]
 8008916:	227f      	movs	r2, #127	@ 0x7f
 8008918:	f44f 61a5 	mov.w	r1, #1320	@ 0x528
 800891c:	f7f8 fa7c 	bl	8000e18 <chThdCreateStatic>
    chThdSleepMilliseconds(1000);
  }
*/
  while (1)
  {
    chThdSleepMilliseconds(1000);
 8008920:	4814      	ldr	r0, [pc, #80]	@ (8008974 <main+0x1ec>)
 8008922:	f7f8 fab5 	bl	8000e90 <chThdSleep>
  while (1)
 8008926:	e7fb      	b.n	8008920 <main+0x198>
 8008928:	40021000 	.word	0x40021000
 800892c:	08013f50 	.word	0x08013f50
 8008930:	20000aa8 	.word	0x20000aa8
 8008934:	00000000 	.word	0x00000000
 8008938:	42480000 	.word	0x42480000
 800893c:	434f4e54 	.word	0x434f4e54
 8008940:	01910000 	.word	0x01910000
 8008944:	002dc6c0 	.word	0x002dc6c0
 8008948:	200007b0 	.word	0x200007b0
 800894c:	01c9c380 	.word	0x01c9c380
 8008950:	20000318 	.word	0x20000318
 8008954:	080139f0 	.word	0x080139f0
 8008958:	080139f8 	.word	0x080139f8
 800895c:	20000650 	.word	0x20000650
 8008960:	200068a4 	.word	0x200068a4
 8008964:	20000918 	.word	0x20000918
 8008968:	00aa2841 	.word	0x00aa2841
 800896c:	080077e9 	.word	0x080077e9
 8008970:	20004a28 	.word	0x20004a28
 8008974:	000186a0 	.word	0x000186a0
 8008978:	35a4e900 	.word	0x35a4e900
 800897c:	08013f10 	.word	0x08013f10

08008980 <my_atoi>:
// Use macro, std isdigit more big
#define _isdigit(c) (c >= '0' && c <= '9')
// Rewrite universal standart str to value functions to more compact
//
// Convert string to int32
int32_t my_atoi(const char *p) {
 8008980:	b510      	push	{r4, lr}
  int32_t value = 0;
  uint32_t c;
  bool neg = false;

  if (*p == '-') {neg = true; p++;}
 8008982:	7802      	ldrb	r2, [r0, #0]
int32_t my_atoi(const char *p) {
 8008984:	4603      	mov	r3, r0
  if (*p == '-') {neg = true; p++;}
 8008986:	2a2d      	cmp	r2, #45	@ 0x2d
 8008988:	bf04      	itt	eq
 800898a:	3301      	addeq	r3, #1
 800898c:	2101      	moveq	r1, #1
  if (*p == '+') p++;
 800898e:	781a      	ldrb	r2, [r3, #0]
  bool neg = false;
 8008990:	bf18      	it	ne
 8008992:	2100      	movne	r1, #0
  if (*p == '+') p++;
 8008994:	2a2b      	cmp	r2, #43	@ 0x2b
 8008996:	bf08      	it	eq
 8008998:	3301      	addeq	r3, #1
  if (*p == '-') {neg = true; p++;}
 800899a:	2000      	movs	r0, #0
  while ((c = *p++ - '0') < 10)
    value = value * 10 + c;
 800899c:	240a      	movs	r4, #10
  while ((c = *p++ - '0') < 10)
 800899e:	f813 2b01 	ldrb.w	r2, [r3], #1
 80089a2:	3a30      	subs	r2, #48	@ 0x30
 80089a4:	2a09      	cmp	r2, #9
 80089a6:	d802      	bhi.n	80089ae <my_atoi+0x2e>
    value = value * 10 + c;
 80089a8:	fb04 2000 	mla	r0, r4, r0, r2
 80089ac:	e7f7      	b.n	800899e <my_atoi+0x1e>
  return neg ? -value : value;
 80089ae:	b101      	cbz	r1, 80089b2 <my_atoi+0x32>
 80089b0:	4240      	negs	r0, r0
}
 80089b2:	bd10      	pop	{r4, pc}

080089b4 <my_atoui>:
//  0o - for oct radix
//  0b - for bin radix
//  default dec radix
uint32_t my_atoui(const char *p) {
  uint32_t value = 0, radix = 10, c;
  if (*p == '+') p++;
 80089b4:	7802      	ldrb	r2, [r0, #0]
uint32_t my_atoui(const char *p) {
 80089b6:	4603      	mov	r3, r0
  if (*p == '+') p++;
 80089b8:	2a2b      	cmp	r2, #43	@ 0x2b
 80089ba:	bf08      	it	eq
 80089bc:	3301      	addeq	r3, #1
  if (*p == '0') {
 80089be:	781a      	ldrb	r2, [r3, #0]
 80089c0:	2a30      	cmp	r2, #48	@ 0x30
 80089c2:	d10d      	bne.n	80089e0 <my_atoui+0x2c>
    switch (p[1]) {
 80089c4:	785a      	ldrb	r2, [r3, #1]
 80089c6:	2a6f      	cmp	r2, #111	@ 0x6f
 80089c8:	d005      	beq.n	80089d6 <my_atoui+0x22>
 80089ca:	2a78      	cmp	r2, #120	@ 0x78
 80089cc:	d005      	beq.n	80089da <my_atoui+0x26>
 80089ce:	2a62      	cmp	r2, #98	@ 0x62
 80089d0:	d106      	bne.n	80089e0 <my_atoui+0x2c>
      case 'x': radix = 16; break;
      case 'o': radix =  8; break;
      case 'b': radix =  2; break;
 80089d2:	2102      	movs	r1, #2
 80089d4:	e002      	b.n	80089dc <my_atoui+0x28>
    switch (p[1]) {
 80089d6:	2108      	movs	r1, #8
 80089d8:	e000      	b.n	80089dc <my_atoui+0x28>
      case 'x': radix = 16; break;
 80089da:	2110      	movs	r1, #16
      default:  goto calculate;
    }
    p+=2;
 80089dc:	3302      	adds	r3, #2
 80089de:	e000      	b.n	80089e2 <my_atoui+0x2e>
    switch (p[1]) {
 80089e0:	210a      	movs	r1, #10
  }
calculate:
 80089e2:	2000      	movs	r0, #0
  while (1) {
    c = *p++ - '0';
 80089e4:	f813 2b01 	ldrb.w	r2, [r3], #1
 80089e8:	3a30      	subs	r2, #48	@ 0x30
    // c = to_upper(*p) - 'A' + 10
    if (c >= 'A' - '0') c = (c&(~0x20)) - ('A' - '0') + 10;
 80089ea:	2a10      	cmp	r2, #16
 80089ec:	bf84      	itt	hi
 80089ee:	f022 0220 	bichi.w	r2, r2, #32
 80089f2:	3a07      	subhi	r2, #7
    if (c >= radix) return value;
 80089f4:	428a      	cmp	r2, r1
 80089f6:	d202      	bcs.n	80089fe <my_atoui+0x4a>
    value = value * radix + c;
 80089f8:	fb01 2000 	mla	r0, r1, r0, r2
    c = *p++ - '0';
 80089fc:	e7f2      	b.n	80089e4 <my_atoui+0x30>
  }
}
 80089fe:	4770      	bx	lr

08008a00 <my_atof>:

float my_atof(const char *p) {
 8008a00:	b538      	push	{r3, r4, r5, lr}
  int neg = false;
  if (*p == '-')
 8008a02:	7803      	ldrb	r3, [r0, #0]
 8008a04:	2b2d      	cmp	r3, #45	@ 0x2d
float my_atof(const char *p) {
 8008a06:	4604      	mov	r4, r0
  if (*p == '-')
 8008a08:	d004      	beq.n	8008a14 <my_atof+0x14>
    neg = true;
  if (*p == '-' || *p == '+')
 8008a0a:	2b2b      	cmp	r3, #43	@ 0x2b
  int neg = false;
 8008a0c:	f04f 0500 	mov.w	r5, #0
  if (*p == '-' || *p == '+')
 8008a10:	d102      	bne.n	8008a18 <my_atof+0x18>
 8008a12:	e000      	b.n	8008a16 <my_atof+0x16>
    neg = true;
 8008a14:	2501      	movs	r5, #1
    p++;
 8008a16:	3401      	adds	r4, #1
  float x = my_atoi(p);
 8008a18:	4620      	mov	r0, r4
 8008a1a:	f7ff ffb1 	bl	8008980 <my_atoi>
 8008a1e:	ee00 0a10 	vmov	s0, r0
 8008a22:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  while (_isdigit((int)*p))
 8008a26:	4620      	mov	r0, r4
 8008a28:	f814 3b01 	ldrb.w	r3, [r4], #1
 8008a2c:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8008a30:	2a09      	cmp	r2, #9
 8008a32:	d9f8      	bls.n	8008a26 <my_atof+0x26>
    p++;
  if (*p == '.' || *p == ',') {
 8008a34:	f003 02fd 	and.w	r2, r3, #253	@ 0xfd
 8008a38:	2a2c      	cmp	r2, #44	@ 0x2c
 8008a3a:	d115      	bne.n	8008a68 <my_atof+0x68>
    float d = 1.0f;
    p++;
    while (_isdigit((int)*p)) {
      d *= 1e-1f;
 8008a3c:	eddf 6a2c 	vldr	s13, [pc, #176]	@ 8008af0 <my_atof+0xf0>
    p++;
 8008a40:	4621      	mov	r1, r4
    float d = 1.0f;
 8008a42:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8008a46:	4608      	mov	r0, r1
    while (_isdigit((int)*p)) {
 8008a48:	f811 3b01 	ldrb.w	r3, [r1], #1
 8008a4c:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8008a50:	b2d4      	uxtb	r4, r2
 8008a52:	2c09      	cmp	r4, #9
 8008a54:	d808      	bhi.n	8008a68 <my_atof+0x68>
      x += d * (*p - '0');
 8008a56:	ee07 2a90 	vmov	s15, r2
      d *= 1e-1f;
 8008a5a:	ee27 7a26 	vmul.f32	s14, s14, s13
      x += d * (*p - '0');
 8008a5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008a62:	eea7 0a87 	vfma.f32	s0, s15, s14
      p++;
 8008a66:	e7ee      	b.n	8008a46 <my_atof+0x46>
    }
  }
  if (*p) {
 8008a68:	1e5a      	subs	r2, r3, #1
 8008a6a:	2a74      	cmp	r2, #116	@ 0x74
 8008a6c:	d83b      	bhi.n	8008ae6 <my_atof+0xe6>
    int exp = 0;
    if (*p == 'e' || *p == 'E') exp = my_atoi(&p[1]);
 8008a6e:	2b64      	cmp	r3, #100	@ 0x64
 8008a70:	d806      	bhi.n	8008a80 <my_atof+0x80>
 8008a72:	2b47      	cmp	r3, #71	@ 0x47
 8008a74:	d01b      	beq.n	8008aae <my_atof+0xae>
 8008a76:	2b4d      	cmp	r3, #77	@ 0x4d
 8008a78:	d01b      	beq.n	8008ab2 <my_atof+0xb2>
 8008a7a:	2b45      	cmp	r3, #69	@ 0x45
 8008a7c:	d011      	beq.n	8008aa2 <my_atof+0xa2>
 8008a7e:	e032      	b.n	8008ae6 <my_atof+0xe6>
 8008a80:	3b65      	subs	r3, #101	@ 0x65
 8008a82:	2b10      	cmp	r3, #16
 8008a84:	d82f      	bhi.n	8008ae6 <my_atof+0xe6>
 8008a86:	e8df f003 	tbb	[pc, r3]
 8008a8a:	2e0c      	.short	0x2e0c
 8008a8c:	2e2e2e2e 	.word	0x2e2e2e2e
 8008a90:	09212e16 	.word	0x09212e16
 8008a94:	2e2e1e2e 	.word	0x2e2e1e2e
 8008a98:	2e2e      	.short	0x2e2e
 8008a9a:	26          	.byte	0x26
 8008a9b:	00          	.byte	0x00
  if (*p) {
 8008a9c:	f06f 0008 	mvn.w	r0, #8
 8008aa0:	e01b      	b.n	8008ada <my_atof+0xda>
    if (*p == 'e' || *p == 'E') exp = my_atoi(&p[1]);
 8008aa2:	3001      	adds	r0, #1
 8008aa4:	f7ff ff6c 	bl	8008980 <my_atoi>
    else if (*p == 'k') exp =  3; // kilo
    else if (*p == 'm') exp = -3; // milli
    else if (*p == 'u') exp = -6; // micro
    else if (*p == 'n') exp = -9; // nano
    else if (*p == 'p') exp =-12; // pico
    if (exp > 0) do {x*= 1e+1f;} while (--exp);
 8008aa8:	2800      	cmp	r0, #0
 8008aaa:	dd12      	ble.n	8008ad2 <my_atof+0xd2>
 8008aac:	e004      	b.n	8008ab8 <my_atof+0xb8>
  if (*p) {
 8008aae:	2009      	movs	r0, #9
 8008ab0:	e002      	b.n	8008ab8 <my_atof+0xb8>
 8008ab2:	2006      	movs	r0, #6
 8008ab4:	e000      	b.n	8008ab8 <my_atof+0xb8>
 8008ab6:	2003      	movs	r0, #3
    if (exp > 0) do {x*= 1e+1f;} while (--exp);
 8008ab8:	eef2 7a04 	vmov.f32	s15, #36	@ 0x41200000  10.0
 8008abc:	3801      	subs	r0, #1
 8008abe:	ee20 0a27 	vmul.f32	s0, s0, s15
 8008ac2:	d1fb      	bne.n	8008abc <my_atof+0xbc>
 8008ac4:	e00f      	b.n	8008ae6 <my_atof+0xe6>
    else if (*p == 'p') exp =-12; // pico
 8008ac6:	f06f 000b 	mvn.w	r0, #11
 8008aca:	e006      	b.n	8008ada <my_atof+0xda>
  if (*p) {
 8008acc:	f06f 0002 	mvn.w	r0, #2
 8008ad0:	e003      	b.n	8008ada <my_atof+0xda>
    if (exp < 0) do {x*= 1e-1f;} while (++exp);
 8008ad2:	d008      	beq.n	8008ae6 <my_atof+0xe6>
 8008ad4:	e001      	b.n	8008ada <my_atof+0xda>
  if (*p) {
 8008ad6:	f06f 0005 	mvn.w	r0, #5
    if (exp < 0) do {x*= 1e-1f;} while (++exp);
 8008ada:	eddf 7a05 	vldr	s15, [pc, #20]	@ 8008af0 <my_atof+0xf0>
 8008ade:	3001      	adds	r0, #1
 8008ae0:	ee20 0a27 	vmul.f32	s0, s0, s15
 8008ae4:	d1fb      	bne.n	8008ade <my_atof+0xde>
  }
  return neg ? -x : x;
 8008ae6:	b10d      	cbz	r5, 8008aec <my_atof+0xec>
 8008ae8:	eeb1 0a40 	vneg.f32	s0, s0
}
 8008aec:	bd38      	pop	{r3, r4, r5, pc}
 8008aee:	bf00      	nop
 8008af0:	3dcccccd 	.word	0x3dcccccd

08008af4 <strcmpi>:

static char to_lower(char c) {return (c >='A' && c <= 'Z') ? c - 'A' + 'a' : c;}
bool strcmpi(const char *t1, const char *t2) {
 8008af4:	b510      	push	{r4, lr}
 8008af6:	3801      	subs	r0, #1
 8008af8:	3901      	subs	r1, #1
  int i = 0;
  while (1) {
    char ch1 = to_lower(t1[i]), ch2 = to_lower(t2[i]);
 8008afa:	f810 3f01 	ldrb.w	r3, [r0, #1]!
static char to_lower(char c) {return (c >='A' && c <= 'Z') ? c - 'A' + 'a' : c;}
 8008afe:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
 8008b02:	2a19      	cmp	r2, #25
    char ch1 = to_lower(t1[i]), ch2 = to_lower(t2[i]);
 8008b04:	f811 2f01 	ldrb.w	r2, [r1, #1]!
static char to_lower(char c) {return (c >='A' && c <= 'Z') ? c - 'A' + 'a' : c;}
 8008b08:	bf98      	it	ls
 8008b0a:	3320      	addls	r3, #32
 8008b0c:	f1a2 0441 	sub.w	r4, r2, #65	@ 0x41
 8008b10:	bf98      	it	ls
 8008b12:	b2db      	uxtbls	r3, r3
 8008b14:	2c19      	cmp	r4, #25
 8008b16:	d804      	bhi.n	8008b22 <strcmpi+0x2e>
 8008b18:	3220      	adds	r2, #32
    if (ch1 != ch2) return false;
 8008b1a:	b2d2      	uxtb	r2, r2
 8008b1c:	429a      	cmp	r2, r3
 8008b1e:	d0ec      	beq.n	8008afa <strcmpi+0x6>
 8008b20:	e005      	b.n	8008b2e <strcmpi+0x3a>
 8008b22:	429a      	cmp	r2, r3
 8008b24:	d103      	bne.n	8008b2e <strcmpi+0x3a>
    if (ch1 ==   0) return true;
 8008b26:	2b00      	cmp	r3, #0
 8008b28:	d1e7      	bne.n	8008afa <strcmpi+0x6>
 8008b2a:	2001      	movs	r0, #1
 8008b2c:	e000      	b.n	8008b30 <strcmpi+0x3c>
    if (ch1 != ch2) return false;
 8008b2e:	2000      	movs	r0, #0
    i++;
  }
}
 8008b30:	bd10      	pop	{r4, pc}
	...

08008b34 <get_str_index>:
//
// Function used for search substring v in list
// Example need search parameter "center" in "start|stop|center|span|cw" getStringIndex return 2
// If not found return -1
// Used for easy parse command arguments
int get_str_index(const char *v, const char *list) {
 8008b34:	b570      	push	{r4, r5, r6, lr}
 8008b36:	4604      	mov	r4, r0
  int i = 0;
 8008b38:	2000      	movs	r0, #0
  while (1) {
    const char *p = v;
 8008b3a:	460b      	mov	r3, r1
 8008b3c:	1e65      	subs	r5, r4, #1
    while (1) {
      char c = *list;
 8008b3e:	781a      	ldrb	r2, [r3, #0]
      if (c == '|') c = 0;
      if (c == *p++) {
 8008b40:	f815 6f01 	ldrb.w	r6, [r5, #1]!
      if (c == '|') c = 0;
 8008b44:	2a7c      	cmp	r2, #124	@ 0x7c
 8008b46:	bf08      	it	eq
 8008b48:	2200      	moveq	r2, #0
      if (c == *p++) {
 8008b4a:	4296      	cmp	r6, r2
 8008b4c:	4619      	mov	r1, r3
 8008b4e:	f103 0301 	add.w	r3, r3, #1
 8008b52:	d101      	bne.n	8008b58 <get_str_index+0x24>
        // Found, return index
        if (c == 0) return i;
 8008b54:	b14e      	cbz	r6, 8008b6a <get_str_index+0x36>
 8008b56:	e7f2      	b.n	8008b3e <get_str_index+0xa>
      break;  // Not equal, break
    }
    // Set new substring ptr
    while (1) {
      // End of string, not found
      if (*list == 0) return -1;
 8008b58:	f811 3b01 	ldrb.w	r3, [r1], #1
 8008b5c:	b11b      	cbz	r3, 8008b66 <get_str_index+0x32>
      if (*list++ == '|') break;
 8008b5e:	2b7c      	cmp	r3, #124	@ 0x7c
 8008b60:	d1fa      	bne.n	8008b58 <get_str_index+0x24>
    }
    i++;
 8008b62:	3001      	adds	r0, #1
  while (1) {
 8008b64:	e7e9      	b.n	8008b3a <get_str_index+0x6>
      if (*list == 0) return -1;
 8008b66:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return -1;
}
 8008b6a:	bd70      	pop	{r4, r5, r6, pc}

08008b6c <parse_line>:
}

/*
 * Split line by arguments, return arguments count
 */
int parse_line(char *line, char* args[], int max_cnt) {
 8008b6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008b70:	4603      	mov	r3, r0
  const char *brk;
  uint16_t nargs = 0;
  while ((c = *lp) != 0) {                   // While not end
    if (c != ' ' && c != '\t') {             // Skipping white space and tabs.
      if (c == '"') {lp++; brk = "\""; }     // string end is next quote or end
      else          {      brk = " \t";}     // string end is tab or space or end
 8008b72:	4e15      	ldr	r6, [pc, #84]	@ (8008bc8 <parse_line+0x5c>)
      if (c == '"') {lp++; brk = "\""; }     // string end is next quote or end
 8008b74:	4d15      	ldr	r5, [pc, #84]	@ (8008bcc <parse_line+0x60>)
  uint16_t nargs = 0;
 8008b76:	2000      	movs	r0, #0
      if (nargs < max_cnt) args[nargs] = lp; // Put pointer in args buffer (if possible)
      nargs++;                               // Substring count
      lp = _strpbrk(lp, brk);                // search end
      if (*lp == 0) break;                   // Stop, end of input string
      *lp = 0;                               // Set zero at the end of substring
 8008b78:	4686      	mov	lr, r0
  while ((c = *lp) != 0) {                   // While not end
 8008b7a:	781c      	ldrb	r4, [r3, #0]
 8008b7c:	b314      	cbz	r4, 8008bc4 <parse_line+0x58>
    if (c != ' ' && c != '\t') {             // Skipping white space and tabs.
 8008b7e:	2c20      	cmp	r4, #32
 8008b80:	d01e      	beq.n	8008bc0 <parse_line+0x54>
 8008b82:	2c09      	cmp	r4, #9
 8008b84:	d01c      	beq.n	8008bc0 <parse_line+0x54>
      if (c == '"') {lp++; brk = "\""; }     // string end is next quote or end
 8008b86:	2c22      	cmp	r4, #34	@ 0x22
 8008b88:	bf06      	itte	eq
 8008b8a:	3301      	addeq	r3, #1
 8008b8c:	462c      	moveq	r4, r5
      else          {      brk = " \t";}     // string end is tab or space or end
 8008b8e:	4634      	movne	r4, r6
      if (nargs < max_cnt) args[nargs] = lp; // Put pointer in args buffer (if possible)
 8008b90:	4290      	cmp	r0, r2
 8008b92:	bfb8      	it	lt
 8008b94:	f841 3020 	strlt.w	r3, [r1, r0, lsl #2]
      nargs++;                               // Substring count
 8008b98:	3001      	adds	r0, #1
 8008b9a:	b280      	uxth	r0, r0
    while(*s) if (*s++ == *s1) return s1;
 8008b9c:	1e67      	subs	r7, r4, #1
 8008b9e:	f817 cf01 	ldrb.w	ip, [r7, #1]!
 8008ba2:	f1bc 0f00 	cmp.w	ip, #0
 8008ba6:	d006      	beq.n	8008bb6 <parse_line+0x4a>
 8008ba8:	f893 8000 	ldrb.w	r8, [r3]
 8008bac:	45e0      	cmp	r8, ip
 8008bae:	d1f6      	bne.n	8008b9e <parse_line+0x32>
      *lp = 0;                               // Set zero at the end of substring
 8008bb0:	f883 e000 	strb.w	lr, [r3]
 8008bb4:	e004      	b.n	8008bc0 <parse_line+0x54>
  } while(*++s1);
 8008bb6:	f813 7f01 	ldrb.w	r7, [r3, #1]!
 8008bba:	2f00      	cmp	r7, #0
 8008bbc:	d1ee      	bne.n	8008b9c <parse_line+0x30>
 8008bbe:	e001      	b.n	8008bc4 <parse_line+0x58>
    }
    lp++;
 8008bc0:	3301      	adds	r3, #1
 8008bc2:	e7da      	b.n	8008b7a <parse_line+0xe>
  }
  return nargs;
}
 8008bc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008bc8:	0801291f 	.word	0x0801291f
 8008bcc:	0801291d 	.word	0x0801291d

08008bd0 <swap_bytes>:

/*
 * Swap byte order in uint16_t buffer
 */
void swap_bytes(uint16_t *buf, int size) {
  for (int i = 0; i < size; i++)
 8008bd0:	3802      	subs	r0, #2
 8008bd2:	2300      	movs	r3, #0
 8008bd4:	428b      	cmp	r3, r1
 8008bd6:	da05      	bge.n	8008be4 <swap_bytes+0x14>
    \return               Reversed value
 */
__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
{
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
  return (short)__builtin_bswap16(value);
 8008bd8:	f830 2f02 	ldrh.w	r2, [r0, #2]!
 8008bdc:	ba52      	rev16	r2, r2
    buf[i] = __REVSH(buf[i]); // swap byte order (example 0x10FF to 0xFF10)
 8008bde:	8002      	strh	r2, [r0, #0]
  for (int i = 0; i < size; i++)
 8008be0:	3301      	adds	r3, #1
 8008be2:	e7f7      	b.n	8008bd4 <swap_bytes+0x4>
}
 8008be4:	4770      	bx	lr
	...

08008be8 <packbits>:

/*
 * RLE packbits compression algorithm
 */
int packbits(char *source, char *dest, int size) {
 8008be8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  int i = 0, rle, l, pk = 0, sz = 0;
 8008bec:	2400      	movs	r4, #0
int packbits(char *source, char *dest, int size) {
 8008bee:	4605      	mov	r5, r0
  int i = 0, rle, l, pk = 0, sz = 0;
 8008bf0:	4623      	mov	r3, r4
 8008bf2:	4620      	mov	r0, r4
  while ((l = size - i) > 0) {
 8008bf4:	eba2 0e03 	sub.w	lr, r2, r3
 8008bf8:	f1be 0f00 	cmp.w	lr, #0
 8008bfc:	dd33      	ble.n	8008c66 <packbits+0x7e>
    if (l > 128) l = 128;                              // Limit search RLE block size to 128
 8008bfe:	f1be 0f80 	cmp.w	lr, #128	@ 0x80
    char c = source[i++];                              // Get next byte and write to block
 8008c02:	5cef      	ldrb	r7, [r5, r3]
 8008c04:	f103 0601 	add.w	r6, r3, #1
    for (rle = 0; c == source[i + rle] && --l; rle++); // Calculate this byte RLE sequence size = rle + 1
 8008c08:	eb05 0c03 	add.w	ip, r5, r3
    if (l > 128) l = 128;                              // Limit search RLE block size to 128
 8008c0c:	bfa8      	it	ge
 8008c0e:	f04f 0e80 	movge.w	lr, #128	@ 0x80
    for (rle = 0; c == source[i + rle] && --l; rle++); // Calculate this byte RLE sequence size = rle + 1
 8008c12:	2300      	movs	r3, #0
 8008c14:	f81c 8f01 	ldrb.w	r8, [ip, #1]!
 8008c18:	45b8      	cmp	r8, r7
 8008c1a:	d105      	bne.n	8008c28 <packbits+0x40>
 8008c1c:	f103 0801 	add.w	r8, r3, #1
 8008c20:	45c6      	cmp	lr, r8
 8008c22:	d001      	beq.n	8008c28 <packbits+0x40>
 8008c24:	4643      	mov	r3, r8
 8008c26:	e7f5      	b.n	8008c14 <packbits+0x2c>
    if (sz && rle < 2) rle = 0;                        // Ignore (rle + 1) < 3 sequence on run non RLE input
 8008c28:	b10c      	cbz	r4, 8008c2e <packbits+0x46>
 8008c2a:	2b01      	cmp	r3, #1
 8008c2c:	dd02      	ble.n	8008c34 <packbits+0x4c>
    else if (sz == 0 || rle > 0) sz = pk++;            // Reset state or RLE sequence found -> start new block
 8008c2e:	4604      	mov	r4, r0
 8008c30:	3001      	adds	r0, #1
 8008c32:	e000      	b.n	8008c36 <packbits+0x4e>
    if (sz && rle < 2) rle = 0;                        // Ignore (rle + 1) < 3 sequence on run non RLE input
 8008c34:	2300      	movs	r3, #0
    dest[pk++] = c;                                    // Write char to block
 8008c36:	f100 0c01 	add.w	ip, r0, #1
    if (rle > 0) {i+= rle; dest[sz] = -rle;}           // Write RLE sequence size and go to new block
 8008c3a:	eb01 0e04 	add.w	lr, r1, r4
    dest[pk++] = c;                                    // Write char to block
 8008c3e:	4408      	add	r0, r1
    if (rle > 0) {i+= rle; dest[sz] = -rle;}           // Write RLE sequence size and go to new block
 8008c40:	b123      	cbz	r3, 8008c4c <packbits+0x64>
 8008c42:	441e      	add	r6, r3
 8008c44:	425b      	negs	r3, r3
 8008c46:	b2db      	uxtb	r3, r3
    else if ((dest[sz] = pk - sz - 2) < 127)           // Continue write non RLE data while 1 + (non_rle + 1) < 127
      continue;
    sz = 0;                                            // Block complete
 8008c48:	2400      	movs	r4, #0
 8008c4a:	e006      	b.n	8008c5a <packbits+0x72>
    else if ((dest[sz] = pk - sz - 2) < 127)           // Continue write non RLE data while 1 + (non_rle + 1) < 127
 8008c4c:	ebac 0304 	sub.w	r3, ip, r4
 8008c50:	3b02      	subs	r3, #2
 8008c52:	b2db      	uxtb	r3, r3
    sz = 0;                                            // Block complete
 8008c54:	2b7f      	cmp	r3, #127	@ 0x7f
 8008c56:	bf28      	it	cs
 8008c58:	2400      	movcs	r4, #0
    dest[pk++] = c;                                    // Write char to block
 8008c5a:	7007      	strb	r7, [r0, #0]
    else if ((dest[sz] = pk - sz - 2) < 127)           // Continue write non RLE data while 1 + (non_rle + 1) < 127
 8008c5c:	f88e 3000 	strb.w	r3, [lr]
 8008c60:	4660      	mov	r0, ip
 8008c62:	4633      	mov	r3, r6
 8008c64:	e7c6      	b.n	8008bf4 <packbits+0xc>
  }
  return pk;
}
 8008c66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08008c6c <_delay_8t>:
    " bne  1b    \n"  // 2 if taken, 1 otherwise
   : [cyc] "+l" (cycles)
   : // no inputs
   : // No memory
  );
}
 8008c6c:	4770      	bx	lr
	...

08008c70 <si5351_set_frequency_offset>:
  return current_freq;
}

#ifdef USE_VARIABLE_OFFSET
void si5351_set_frequency_offset(int32_t offset)
{
 8008c70:	b510      	push	{r4, lr}
  current_band = 0;
 8008c72:	4905      	ldr	r1, [pc, #20]	@ (8008c88 <si5351_set_frequency_offset+0x18>)
  current_freq = 0;
 8008c74:	4a05      	ldr	r2, [pc, #20]	@ (8008c8c <si5351_set_frequency_offset+0x1c>)
  current_band = 0;
 8008c76:	2300      	movs	r3, #0
{
 8008c78:	4604      	mov	r4, r0
  current_band = 0;
 8008c7a:	700b      	strb	r3, [r1, #0]
  current_freq = 0;
 8008c7c:	6013      	str	r3, [r2, #0]
  si5351_reset_cache();
  generate_DSP_Table(offset);
 8008c7e:	f000 fb2f 	bl	80092e0 <generate_DSP_Table>
  IF_OFFSET = offset;
 8008c82:	4b03      	ldr	r3, [pc, #12]	@ (8008c90 <si5351_set_frequency_offset+0x20>)
 8008c84:	609c      	str	r4, [r3, #8]
}
 8008c86:	bd10      	pop	{r4, pc}
 8008c88:	200068c1 	.word	0x200068c1
 8008c8c:	200068bc 	.word	0x200068bc
 8008c90:	20000318 	.word	0x20000318

08008c94 <si5351_bulk_write>:
  if (drive_strength == current_power) return;
  si5351_set_frequency(current_freq, drive_strength);
}

void si5351_bulk_write(const uint8_t *buf, int len)
{
 8008c94:	460a      	mov	r2, r1
  i2c_transfer(SI5351_I2C_ADDR, buf, len);
 8008c96:	4601      	mov	r1, r0
 8008c98:	2060      	movs	r0, #96	@ 0x60
 8008c9a:	f007 bfb9 	b.w	8010c10 <i2c_transfer>
 8008c9e:	bf00      	nop

08008ca0 <si5351_setupPLL>:
// Set PLL freq = XTALFREQ * (mult + num/denom)
static void si5351_setupPLL(uint8_t   pllSource,  /* SI5351_REG_PLL_A or SI5351_REG_PLL_B */
                            uint32_t  mult,
                            uint32_t  num,
                            uint32_t  denom)
{
 8008ca0:	b510      	push	{r4, lr}
   *    P2[19:0] = (128 * num) % denom
   * P3 register is a 20-bit value using the following formula:
   *    P3[19:0] = denom
   */
  /* Set the main PLL config registers */
  mult <<= 7;
 8008ca2:	01c9      	lsls	r1, r1, #7
  num <<= 7;
  uint32_t P1 = mult - 512;  // Integer mode
  uint32_t P2 = 0;
  uint32_t P3 = 1;
  if (num) {                 // Fractional mode
 8008ca4:	01d2      	lsls	r2, r2, #7
{
 8008ca6:	b084      	sub	sp, #16
  uint32_t P1 = mult - 512;  // Integer mode
 8008ca8:	f5a1 7100 	sub.w	r1, r1, #512	@ 0x200
  if (num) {                 // Fractional mode
 8008cac:	d031      	beq.n	8008d12 <si5351_setupPLL+0x72>
    P1+= num / denom;
 8008cae:	fbb2 f4f3 	udiv	r4, r2, r3
  reg[1] = (P3 & 0x0FF00) >> 8;                             // MSN_P3[15: 8]
  reg[2] = (P3 & 0x000FF);                                  // MSN_P3[ 7: 0]
  reg[3] = (P1 & 0x30000) >> 16;                            // MSN_P1[17:16]
  reg[4] = (P1 & 0x0FF00) >> 8;                             // MSN_P1[15: 8]
  reg[5] = (P1 & 0x000FF);                                  // MSN_P1[ 7: 0]
  reg[6] = ((P3 & 0xF0000) >> 12) | ((P2 & 0xF0000) >> 16); // MSN_P3[19:16] | MSN_P2[19:16]
 8008cb2:	ea4f 3c13 	mov.w	ip, r3, lsr #12
    P2 = num % denom;
 8008cb6:	fb03 2214 	mls	r2, r3, r4, r2
  reg[6] = ((P3 & 0xF0000) >> 12) | ((P2 & 0xF0000) >> 16); // MSN_P3[19:16] | MSN_P2[19:16]
 8008cba:	f3c2 4e03 	ubfx	lr, r2, #16, #4
 8008cbe:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
    P1+= num / denom;
 8008cc2:	4421      	add	r1, r4
  reg[6] = ((P3 & 0xF0000) >> 12) | ((P2 & 0xF0000) >> 16); // MSN_P3[19:16] | MSN_P2[19:16]
 8008cc4:	ea4c 0c0e 	orr.w	ip, ip, lr
  reg[1] = (P3 & 0x0FF00) >> 8;                             // MSN_P3[15: 8]
 8008cc8:	f3c3 2407 	ubfx	r4, r3, #8, #8
  reg[7] = (P2 & 0x0FF00) >> 8;                             // MSN_P2[15: 8]
 8008ccc:	f3c2 2e07 	ubfx	lr, r2, #8, #8
  reg[2] = (P3 & 0x000FF);                                  // MSN_P3[ 7: 0]
 8008cd0:	b2db      	uxtb	r3, r3
  reg[8] = (P2 & 0x000FF);                                  // MSN_P2[ 7: 0]
 8008cd2:	b2d2      	uxtb	r2, r2
 8008cd4:	f88d 200c 	strb.w	r2, [sp, #12]
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8008cd8:	2200      	movs	r2, #0
 8008cda:	f360 0207 	bfi	r2, r0, #0, #8
 8008cde:	f364 220f 	bfi	r2, r4, #8, #8
 8008ce2:	f363 4217 	bfi	r2, r3, #16, #8
  reg[3] = (P1 & 0x30000) >> 16;                            // MSN_P1[17:16]
 8008ce6:	f3c1 4301 	ubfx	r3, r1, #16, #2
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8008cea:	f363 621f 	bfi	r2, r3, #24, #8
 8008cee:	9201      	str	r2, [sp, #4]
 8008cf0:	2300      	movs	r3, #0
  reg[4] = (P1 & 0x0FF00) >> 8;                             // MSN_P1[15: 8]
 8008cf2:	0a0a      	lsrs	r2, r1, #8
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8008cf4:	f362 0307 	bfi	r3, r2, #0, #8
 8008cf8:	f361 230f 	bfi	r3, r1, #8, #8
 8008cfc:	f36c 4317 	bfi	r3, ip, #16, #8
 8008d00:	f36e 631f 	bfi	r3, lr, #24, #8
  si5351_bulk_write(reg, 9);
 8008d04:	2109      	movs	r1, #9
 8008d06:	a801      	add	r0, sp, #4
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8008d08:	9302      	str	r3, [sp, #8]
  si5351_bulk_write(reg, 9);
 8008d0a:	f7ff ffc3 	bl	8008c94 <si5351_bulk_write>
}
 8008d0e:	b004      	add	sp, #16
 8008d10:	bd10      	pop	{r4, pc}
 8008d12:	4696      	mov	lr, r2
 8008d14:	4694      	mov	ip, r2
 8008d16:	2301      	movs	r3, #1
 8008d18:	4614      	mov	r4, r2
 8008d1a:	e7db      	b.n	8008cd4 <si5351_setupPLL+0x34>

08008d1c <si5351_setupPLL_freq>:

// Setup PLL freq if Multisynth divider fixed = div (need get output =  freq/mul)
static void
si5351_setupPLL_freq(uint32_t pllSource, uint64_t pllfreq, uint32_t div)
{
  uint32_t xtal  = config._xtal_freq * div;
 8008d1c:	491d      	ldr	r1, [pc, #116]	@ (8008d94 <si5351_setupPLL_freq+0x78>)
{
 8008d1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t xtal  = config._xtal_freq * div;
 8008d22:	6e49      	ldr	r1, [r1, #100]	@ 0x64
{
 8008d24:	9c06      	ldr	r4, [sp, #24]
 8008d26:	4616      	mov	r6, r2
  uint32_t xtal  = config._xtal_freq * div;
 8008d28:	fb01 f404 	mul.w	r4, r1, r4
{
 8008d2c:	4605      	mov	r5, r0
 8008d2e:	4619      	mov	r1, r3
 8008d30:	4622      	mov	r2, r4
 8008d32:	4630      	mov	r0, r6
 8008d34:	2300      	movs	r3, #0
 8008d36:	f7f7 fde9 	bl	800090c <__aeabi_uldivmod>
  if (denom > MAX_DENOMINATOR) {
 8008d3a:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
 8008d3e:	4601      	mov	r1, r0
 8008d40:	d31a      	bcc.n	8008d78 <si5351_setupPLL_freq+0x5c>
    uint32_t p0 = 0, q0 = 1, p1 = 1, q1 = 0;
 8008d42:	2700      	movs	r7, #0
 8008d44:	f04f 0c01 	mov.w	ip, #1
 8008d48:	46e0      	mov	r8, ip
 8008d4a:	46be      	mov	lr, r7
 8008d4c:	e001      	b.n	8008d52 <si5351_setupPLL_freq+0x36>
 8008d4e:	469c      	mov	ip, r3
 8008d50:	46b6      	mov	lr, r6
      uint32_t a = num / denom;
 8008d52:	fbb2 f3f4 	udiv	r3, r2, r4
      uint32_t q2 = q0 + a*q1;
 8008d56:	fb03 860e 	mla	r6, r3, lr, r8
      if (q2 > MAX_DENOMINATOR)
 8008d5a:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
 8008d5e:	4620      	mov	r0, r4
      uint32_t b = num % denom;
 8008d60:	fb04 2413 	mls	r4, r4, r3, r2
      if (q2 > MAX_DENOMINATOR)
 8008d64:	d20e      	bcs.n	8008d84 <si5351_setupPLL_freq+0x68>
      uint32_t p2 = p0 + a*p1;
 8008d66:	fb03 730c 	mla	r3, r3, ip, r7
    while (denom != 0) {
 8008d6a:	46f0      	mov	r8, lr
 8008d6c:	4667      	mov	r7, ip
 8008d6e:	4602      	mov	r2, r0
 8008d70:	2c00      	cmp	r4, #0
 8008d72:	d1ec      	bne.n	8008d4e <si5351_setupPLL_freq+0x32>
    *d = q1;
 8008d74:	4634      	mov	r4, r6
    *n = p1;
 8008d76:	461a      	mov	r2, r3
  uint32_t multi = pllfreq / xtal;
  uint32_t num   = pllfreq % xtal;
  uint32_t denom = xtal;
  approximate_fraction(&num, &denom);
  si5351_setupPLL(pllSource, multi, num, denom);
 8008d78:	4623      	mov	r3, r4
 8008d7a:	b2e8      	uxtb	r0, r5
}
 8008d7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  si5351_setupPLL(pllSource, multi, num, denom);
 8008d80:	f7ff bf8e 	b.w	8008ca0 <si5351_setupPLL>
    *d = q1;
 8008d84:	4674      	mov	r4, lr
  si5351_setupPLL(pllSource, multi, num, denom);
 8008d86:	4623      	mov	r3, r4
 8008d88:	b2e8      	uxtb	r0, r5
    *n = p1;
 8008d8a:	4662      	mov	r2, ip
}
 8008d8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  si5351_setupPLL(pllSource, multi, num, denom);
 8008d90:	f7ff bf86 	b.w	8008ca0 <si5351_setupPLL>
 8008d94:	20000318 	.word	0x20000318

08008d98 <si5351_setupMultisynth>:
{
 8008d98:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008d9c:	b085      	sub	sp, #20
  if (div == 4)
 8008d9e:	2904      	cmp	r1, #4
{
 8008da0:	9f0c      	ldr	r7, [sp, #48]	@ 0x30
 8008da2:	f89d 6034 	ldrb.w	r6, [sp, #52]	@ 0x34
 8008da6:	4605      	mov	r5, r0
 8008da8:	4614      	mov	r4, r2
  if (div == 4)
 8008daa:	d05c      	beq.n	8008e66 <si5351_setupMultisynth+0xce>
    div<<=7;
 8008dac:	01c9      	lsls	r1, r1, #7
    if (num) {       // Fractional mode
 8008dae:	01d4      	lsls	r4, r2, #7
    P1 = div - 512; // Integer mode
 8008db0:	f5a1 7100 	sub.w	r1, r1, #512	@ 0x200
    if (num) {       // Fractional mode
 8008db4:	d13b      	bne.n	8008e2e <si5351_setupMultisynth+0x96>
  reg[3] = ((P1 & 0x30000)>>16)| rdiv;                // Rx_DIV[2:0] | MSx_DIVBY4[1:0] | MSx_P1[17:16]
 8008db6:	f3c1 4001 	ubfx	r0, r1, #16, #2
  reg[4] = (P1 & 0x0FF00)>> 8;                        // MSx_P1[15: 8]
 8008dba:	f3c1 2e07 	ubfx	lr, r1, #8, #8
  reg[5] = (P1 & 0x000FF);                            // MSx_P1[ 7: 0]
 8008dbe:	4622      	mov	r2, r4
 8008dc0:	b2c9      	uxtb	r1, r1
 8008dc2:	46a0      	mov	r8, r4
 8008dc4:	46a4      	mov	ip, r4
 8008dc6:	2301      	movs	r3, #1
 8008dc8:	46a1      	mov	r9, r4
  reg[8] = (P2 & 0x000FF);                            // MSx_P2[ 7: 0]
 8008dca:	f88d 200c 	strb.w	r2, [sp, #12]
  reg[0] = msreg_base[channel];                       // SI5351_REG_42_MULTISYNTH0, SI5351_REG_50_MULTISYNTH1, SI5351_REG_58_MULTISYNTH2
 8008dce:	4a2b      	ldr	r2, [pc, #172]	@ (8008e7c <si5351_setupMultisynth+0xe4>)
  reg[3] = ((P1 & 0x30000)>>16)| rdiv;                // Rx_DIV[2:0] | MSx_DIVBY4[1:0] | MSx_P1[17:16]
 8008dd0:	4338      	orrs	r0, r7
  reg[0] = msreg_base[channel];                       // SI5351_REG_42_MULTISYNTH0, SI5351_REG_50_MULTISYNTH1, SI5351_REG_58_MULTISYNTH2
 8008dd2:	5d57      	ldrb	r7, [r2, r5]
 8008dd4:	2200      	movs	r2, #0
 8008dd6:	f367 0207 	bfi	r2, r7, #0, #8
 8008dda:	f369 220f 	bfi	r2, r9, #8, #8
 8008dde:	f363 4217 	bfi	r2, r3, #16, #8
 8008de2:	2300      	movs	r3, #0
 8008de4:	f36e 0307 	bfi	r3, lr, #0, #8
 8008de8:	f361 230f 	bfi	r3, r1, #8, #8
 8008dec:	f36c 4317 	bfi	r3, ip, #16, #8
 8008df0:	f360 621f 	bfi	r2, r0, #24, #8
 8008df4:	f368 631f 	bfi	r3, r8, #24, #8
  si5351_bulk_write(reg, 9);
 8008df8:	2109      	movs	r1, #9
 8008dfa:	a801      	add	r0, sp, #4
  reg[0] = msreg_base[channel];                       // SI5351_REG_42_MULTISYNTH0, SI5351_REG_50_MULTISYNTH1, SI5351_REG_58_MULTISYNTH2
 8008dfc:	9201      	str	r2, [sp, #4]
 8008dfe:	9302      	str	r3, [sp, #8]
  si5351_bulk_write(reg, 9);
 8008e00:	f7ff ff48 	bl	8008c94 <si5351_bulk_write>
  if (num == 0)
 8008e04:	b364      	cbz	r4, 8008e60 <si5351_setupMultisynth+0xc8>
  chctrl|= SI5351_CLK_INPUT_MULTISYNTH_N;
 8008e06:	f046 060c 	orr.w	r6, r6, #12
  if (clk_cache[channel] != chctrl) {
 8008e0a:	4c1d      	ldr	r4, [pc, #116]	@ (8008e80 <si5351_setupMultisynth+0xe8>)
 8008e0c:	5d63      	ldrb	r3, [r4, r5]
 8008e0e:	42b3      	cmp	r3, r6
 8008e10:	d00a      	beq.n	8008e28 <si5351_setupMultisynth+0x90>
    si5351_write(SI5351_REG_16_CLK0_CONTROL + channel, chctrl);
 8008e12:	f105 0310 	add.w	r3, r5, #16
  si5351_bulk_write(buf, 2);
 8008e16:	2102      	movs	r1, #2
 8008e18:	4668      	mov	r0, sp
  uint8_t buf[] = { reg, dat };
 8008e1a:	f88d 3000 	strb.w	r3, [sp]
 8008e1e:	f88d 6001 	strb.w	r6, [sp, #1]
  si5351_bulk_write(buf, 2);
 8008e22:	f7ff ff37 	bl	8008c94 <si5351_bulk_write>
    clk_cache[channel] = chctrl;
 8008e26:	5566      	strb	r6, [r4, r5]
}
 8008e28:	b005      	add	sp, #20
 8008e2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      P1+= num / denom;
 8008e2e:	fbb4 f2f3 	udiv	r2, r4, r3
  reg[6] = ((P3 & 0xF0000)>>12)|((P2 & 0xF0000)>>16); // MSx_P3[19:16] | MSx_P2[19:16]
 8008e32:	ea4f 3c13 	mov.w	ip, r3, lsr #12
      P1+= num / denom;
 8008e36:	4411      	add	r1, r2
      P2 = num % denom;
 8008e38:	fb03 4212 	mls	r2, r3, r2, r4
  reg[6] = ((P3 & 0xF0000)>>12)|((P2 & 0xF0000)>>16); // MSx_P3[19:16] | MSx_P2[19:16]
 8008e3c:	f3c2 4003 	ubfx	r0, r2, #16, #4
 8008e40:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
 8008e44:	ea4c 0c00 	orr.w	ip, ip, r0
  reg[1] = (P3 & 0x0FF00)>>8;                         // MSx_P3[15: 8]
 8008e48:	f3c3 2907 	ubfx	r9, r3, #8, #8
  reg[3] = ((P1 & 0x30000)>>16)| rdiv;                // Rx_DIV[2:0] | MSx_DIVBY4[1:0] | MSx_P1[17:16]
 8008e4c:	f3c1 4001 	ubfx	r0, r1, #16, #2
  reg[4] = (P1 & 0x0FF00)>> 8;                        // MSx_P1[15: 8]
 8008e50:	f3c1 2e07 	ubfx	lr, r1, #8, #8
  reg[7] = (P2 & 0x0FF00)>>8;                         // MSx_P2[15: 8]
 8008e54:	f3c2 2807 	ubfx	r8, r2, #8, #8
  reg[2] = (P3 & 0x000FF);                            // MSx_P3[ 7: 0]
 8008e58:	b2db      	uxtb	r3, r3
  reg[5] = (P1 & 0x000FF);                            // MSx_P1[ 7: 0]
 8008e5a:	b2c9      	uxtb	r1, r1
  reg[8] = (P2 & 0x000FF);                            // MSx_P2[ 7: 0]
 8008e5c:	b2d2      	uxtb	r2, r2
 8008e5e:	e7b4      	b.n	8008dca <si5351_setupMultisynth+0x32>
    chctrl|= SI5351_CLK_INTEGER_MODE;
 8008e60:	f046 064c 	orr.w	r6, r6, #76	@ 0x4c
 8008e64:	e7d1      	b.n	8008e0a <si5351_setupMultisynth+0x72>
    rdiv|= SI5351_DIVBY4;
 8008e66:	2200      	movs	r2, #0
 8008e68:	f047 070c 	orr.w	r7, r7, #12
 8008e6c:	4690      	mov	r8, r2
 8008e6e:	4694      	mov	ip, r2
 8008e70:	4611      	mov	r1, r2
 8008e72:	4696      	mov	lr, r2
 8008e74:	4610      	mov	r0, r2
 8008e76:	2301      	movs	r3, #1
 8008e78:	4691      	mov	r9, r2
 8008e7a:	e7a6      	b.n	8008dca <si5351_setupMultisynth+0x32>
 8008e7c:	08014148 	.word	0x08014148
 8008e80:	200068b8 	.word	0x200068b8

08008e84 <si5351_set_frequency_fixedpll>:
{
 8008e84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008e88:	9c08      	ldr	r4, [sp, #32]
 8008e8a:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 8008e8c:	f89d 7028 	ldrb.w	r7, [sp, #40]	@ 0x28
 8008e90:	4619      	mov	r1, r3
 8008e92:	4605      	mov	r5, r0
 8008e94:	2300      	movs	r3, #0
 8008e96:	4610      	mov	r0, r2
 8008e98:	4622      	mov	r2, r4
 8008e9a:	f7f7 fd37 	bl	800090c <__aeabi_uldivmod>
  if (denom > MAX_DENOMINATOR) {
 8008e9e:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
 8008ea2:	4601      	mov	r1, r0
 8008ea4:	d31b      	bcc.n	8008ede <si5351_set_frequency_fixedpll+0x5a>
    uint32_t p0 = 0, q0 = 1, p1 = 1, q1 = 0;
 8008ea6:	f04f 0900 	mov.w	r9, #0
 8008eaa:	f04f 0c01 	mov.w	ip, #1
 8008eae:	4660      	mov	r0, ip
 8008eb0:	46ce      	mov	lr, r9
 8008eb2:	e001      	b.n	8008eb8 <si5351_set_frequency_fixedpll+0x34>
 8008eb4:	469c      	mov	ip, r3
 8008eb6:	46c6      	mov	lr, r8
      uint32_t a = num / denom;
 8008eb8:	fbb2 f3f4 	udiv	r3, r2, r4
      uint32_t q2 = q0 + a*q1;
 8008ebc:	fb03 080e 	mla	r8, r3, lr, r0
      if (q2 > MAX_DENOMINATOR)
 8008ec0:	f5b8 1f80 	cmp.w	r8, #1048576	@ 0x100000
 8008ec4:	46a2      	mov	sl, r4
      uint32_t b = num % denom;
 8008ec6:	fb04 2413 	mls	r4, r4, r3, r2
      if (q2 > MAX_DENOMINATOR)
 8008eca:	d210      	bcs.n	8008eee <si5351_set_frequency_fixedpll+0x6a>
      uint32_t p2 = p0 + a*p1;
 8008ecc:	fb03 930c 	mla	r3, r3, ip, r9
    while (denom != 0) {
 8008ed0:	4670      	mov	r0, lr
 8008ed2:	46e1      	mov	r9, ip
 8008ed4:	4652      	mov	r2, sl
 8008ed6:	2c00      	cmp	r4, #0
 8008ed8:	d1ec      	bne.n	8008eb4 <si5351_set_frequency_fixedpll+0x30>
    *d = q1;
 8008eda:	4644      	mov	r4, r8
    *n = p1;
 8008edc:	461a      	mov	r2, r3
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8008ede:	e9cd 6708 	strd	r6, r7, [sp, #32]
 8008ee2:	4623      	mov	r3, r4
 8008ee4:	4628      	mov	r0, r5
}
 8008ee6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8008eea:	f7ff bf55 	b.w	8008d98 <si5351_setupMultisynth>
    *d = q1;
 8008eee:	4674      	mov	r4, lr
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8008ef0:	e9cd 6708 	strd	r6, r7, [sp, #32]
 8008ef4:	4623      	mov	r3, r4
 8008ef6:	4628      	mov	r0, r5
    *n = p1;
 8008ef8:	4662      	mov	r2, ip
}
 8008efa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8008efe:	f7ff bf4b 	b.w	8008d98 <si5351_setupMultisynth>
 8008f02:	bf00      	nop

08008f04 <si5351_set_tcxo>:
  if (xtal < XTALFREQ - 2000000 ||
 8008f04:	4a09      	ldr	r2, [pc, #36]	@ (8008f2c <si5351_set_tcxo+0x28>)
  current_band = 0;
 8008f06:	490a      	ldr	r1, [pc, #40]	@ (8008f30 <si5351_set_tcxo+0x2c>)
  if (xtal < XTALFREQ - 2000000 ||
 8008f08:	f1a0 73b7 	sub.w	r3, r0, #23986176	@ 0x16e0000
 8008f0c:	f5a3 5358 	sub.w	r3, r3, #13824	@ 0x3600
void si5351_set_tcxo(uint32_t xtal){
 8008f10:	b410      	push	{r4}
  if (xtal < XTALFREQ - 2000000 ||
 8008f12:	4293      	cmp	r3, r2
  config._xtal_freq = xtal;
 8008f14:	4c07      	ldr	r4, [pc, #28]	@ (8008f34 <si5351_set_tcxo+0x30>)
  current_freq = 0;
 8008f16:	4a08      	ldr	r2, [pc, #32]	@ (8008f38 <si5351_set_tcxo+0x34>)
      xtal > XTALFREQ + 2000000) xtal = XTALFREQ;
 8008f18:	bf88      	it	hi
 8008f1a:	4808      	ldrhi	r0, [pc, #32]	@ (8008f3c <si5351_set_tcxo+0x38>)
  config._xtal_freq = xtal;
 8008f1c:	6660      	str	r0, [r4, #100]	@ 0x64
  current_band = 0;
 8008f1e:	2300      	movs	r3, #0
 8008f20:	700b      	strb	r3, [r1, #0]
}
 8008f22:	f85d 4b04 	ldr.w	r4, [sp], #4
  current_freq = 0;
 8008f26:	6013      	str	r3, [r2, #0]
}
 8008f28:	4770      	bx	lr
 8008f2a:	bf00      	nop
 8008f2c:	003d0900 	.word	0x003d0900
 8008f30:	200068c1 	.word	0x200068c1
 8008f34:	20000318 	.word	0x20000318
 8008f38:	200068bc 	.word	0x200068bc
 8008f3c:	018cba80 	.word	0x018cba80

08008f40 <si5351_set_band_mode>:
    band_strategy_H4_SI5351,  band_strategy_36H_MS5351, band_strategy_SWC5351
#else
    band_strategy_33H_SI5351, band_strategy_36H_MS5351, band_strategy_SWC5351
#endif
  };
  band_s = bs[t];
 8008f40:	4a02      	ldr	r2, [pc, #8]	@ (8008f4c <si5351_set_band_mode+0xc>)
 8008f42:	4b03      	ldr	r3, [pc, #12]	@ (8008f50 <si5351_set_band_mode+0x10>)
 8008f44:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 8008f48:	601a      	str	r2, [r3, #0]
}
 8008f4a:	4770      	bx	lr
 8008f4c:	08013f80 	.word	0x08013f80
 8008f50:	200068b4 	.word	0x200068b4

08008f54 <si5351_get_harmonic_lvl>:

uint32_t
si5351_get_harmonic_lvl(uint32_t freq){
  uint16_t i;
  for (i = 0; ; i++){
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8008f54:	4b09      	ldr	r3, [pc, #36]	@ (8008f7c <si5351_get_harmonic_lvl+0x28>)
 8008f56:	4a0a      	ldr	r2, [pc, #40]	@ (8008f80 <si5351_get_harmonic_lvl+0x2c>)
si5351_get_harmonic_lvl(uint32_t freq){
 8008f58:	b430      	push	{r4, r5}
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8008f5a:	685d      	ldr	r5, [r3, #4]
 8008f5c:	6814      	ldr	r4, [r2, #0]
si5351_get_harmonic_lvl(uint32_t freq){
 8008f5e:	4601      	mov	r1, r0
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8008f60:	2200      	movs	r2, #0
 8008f62:	b290      	uxth	r0, r2
 8008f64:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    if (freq <= f)
 8008f68:	3201      	adds	r2, #1
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8008f6a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8008f6e:	2b13      	cmp	r3, #19
 8008f70:	bf98      	it	ls
 8008f72:	436b      	mulls	r3, r5
    if (freq <= f)
 8008f74:	428b      	cmp	r3, r1
 8008f76:	d3f4      	bcc.n	8008f62 <si5351_get_harmonic_lvl+0xe>
      return i;
  }
  return i;
}
 8008f78:	bc30      	pop	{r4, r5}
 8008f7a:	4770      	bx	lr
 8008f7c:	20000318 	.word	0x20000318
 8008f80:	200068b4 	.word	0x200068b4

08008f84 <si5351_set_frequency>:
#define FREQ_CHANNEL         1
#define AUDIO_CODEC_CHANNEL  2

int
si5351_set_frequency(uint32_t freq, uint8_t drive_strength)
{
 8008f84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t band;
  int delay = 0;
  if (freq == 0) return 0;
 8008f88:	4604      	mov	r4, r0
{
 8008f8a:	b08d      	sub	sp, #52	@ 0x34
  if (freq == 0) return 0;
 8008f8c:	2800      	cmp	r0, #0
 8008f8e:	d06f      	beq.n	8009070 <si5351_set_frequency+0xec>
  uint32_t rdiv = SI5351_R_DIV_1;
  uint32_t fdiv, pll_n;
  uint32_t ofreq = freq + IF_OFFSET;
 8008f90:	f8df 9264 	ldr.w	r9, [pc, #612]	@ 80091f8 <si5351_set_frequency+0x274>

  // Select optimal band for prepared freq
  if (freq < band_s[1].freq) {
 8008f94:	f8df 8264 	ldr.w	r8, [pc, #612]	@ 80091fc <si5351_set_frequency+0x278>
  uint32_t ofreq = freq + IF_OFFSET;
 8008f98:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8008f9c:	eb00 0a03 	add.w	sl, r0, r3
  if (freq < band_s[1].freq) {
 8008fa0:	f8d8 3000 	ldr.w	r3, [r8]
 8008fa4:	68da      	ldr	r2, [r3, #12]
 8008fa6:	4282      	cmp	r2, r0
 8008fa8:	d810      	bhi.n	8008fcc <si5351_set_frequency+0x48>
     rdiv = SI5351_R_DIV(7);
     drive_strength = SI5351_CLK_DRIVE_STRENGTH_2MA; // Always use 2ma
     freq<<= 7;
    ofreq<<= 7;
    band = 1;
  } else if (freq <= 1000000U) {
 8008faa:	4a8f      	ldr	r2, [pc, #572]	@ (80091e8 <si5351_set_frequency+0x264>)
 8008fac:	4290      	cmp	r0, r2
 8008fae:	460d      	mov	r5, r1
 8008fb0:	f200 8101 	bhi.w	80091b6 <si5351_set_frequency+0x232>
    freq*=align;
    ofreq = freq + current_offset;
  }
#endif
  // Check current power settings
  if (current_power != drive_strength){
 8008fb4:	4a8d      	ldr	r2, [pc, #564]	@ (80091ec <si5351_set_frequency+0x268>)
 8008fb6:	7811      	ldrb	r1, [r2, #0]
 8008fb8:	42a9      	cmp	r1, r5
     freq<<= 4;
 8008fba:	ea4f 1400 	mov.w	r4, r0, lsl #4
    ofreq<<= 4;
 8008fbe:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
  if (current_power != drive_strength){
 8008fc2:	d165      	bne.n	8009090 <si5351_set_frequency+0x10c>
    rdiv = SI5351_R_DIV(4);
 8008fc4:	2240      	movs	r2, #64	@ 0x40
 8008fc6:	9206      	str	r2, [sp, #24]
    band = 2;
 8008fc8:	2602      	movs	r6, #2
 8008fca:	e009      	b.n	8008fe0 <si5351_set_frequency+0x5c>
  if (current_power != drive_strength){
 8008fcc:	4a87      	ldr	r2, [pc, #540]	@ (80091ec <si5351_set_frequency+0x268>)
 8008fce:	7815      	ldrb	r5, [r2, #0]
     freq<<= 7;
 8008fd0:	01c4      	lsls	r4, r0, #7
    ofreq<<= 7;
 8008fd2:	ea4f 1aca 	mov.w	sl, sl, lsl #7
  if (current_power != drive_strength){
 8008fd6:	2d00      	cmp	r5, #0
 8008fd8:	d14d      	bne.n	8009076 <si5351_set_frequency+0xf2>
 8008fda:	2270      	movs	r2, #112	@ 0x70
 8008fdc:	9206      	str	r2, [sp, #24]
 8008fde:	2601      	movs	r6, #1
    si5351_reset_cache();
    current_power = drive_strength;
  }

  if (freq == current_freq)
 8008fe0:	f8df b21c 	ldr.w	fp, [pc, #540]	@ 8009200 <si5351_set_frequency+0x27c>
 8008fe4:	f8db 2000 	ldr.w	r2, [fp]
 8008fe8:	42a2      	cmp	r2, r4
 8008fea:	f000 80f7 	beq.w	80091dc <si5351_set_frequency+0x258>
 8008fee:	4f80      	ldr	r7, [pc, #512]	@ (80091f0 <si5351_set_frequency+0x26c>)
    return DELAY_CHANNEL_CHANGE;

  if (current_band != band) {
 8008ff0:	7839      	ldrb	r1, [r7, #0]
//   si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, SI5351_CLK0_EN|SI5351_CLK1_EN|SI5351_CLK2_EN);
    if (DELAY_RESET_PLL_BEFORE)
      si5351_reset_pll(SI5351_PLL_RESET_A | SI5351_PLL_RESET_B);
    // Set new gain values
    if (band_s[current_band].l_gain != band_s[band].l_gain || band_s[current_band].r_gain != band_s[band].r_gain)
 8008ff2:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 8008ff6:	0090      	lsls	r0, r2, #2
  if (current_band != band) {
 8008ff8:	42b1      	cmp	r1, r6
    if (band_s[current_band].l_gain != band_s[band].l_gain || band_s[current_band].r_gain != band_s[band].r_gain)
 8008ffa:	9008      	str	r0, [sp, #32]
 8008ffc:	eb03 0282 	add.w	r2, r3, r2, lsl #2
  if (current_band != band) {
 8009000:	d00f      	beq.n	8009022 <si5351_set_frequency+0x9e>
    if (band_s[current_band].l_gain != band_s[band].l_gain || band_s[current_band].r_gain != band_s[band].r_gain)
 8009002:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8009006:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800900a:	8919      	ldrh	r1, [r3, #8]
 800900c:	8913      	ldrh	r3, [r2, #8]
 800900e:	4299      	cmp	r1, r3
 8009010:	d007      	beq.n	8009022 <si5351_set_frequency+0x9e>
      tlv320aic3204_set_gain(band_s[band].l_gain, band_s[band].r_gain);
 8009012:	7a10      	ldrb	r0, [r2, #8]
 8009014:	7a51      	ldrb	r1, [r2, #9]
 8009016:	f000 f94f 	bl	80092b8 <tlv320aic3204_set_gain>
    // Add delay
    if (DELAY_RESET_PLL_BEFORE)
      chThdSleepMicroseconds(DELAY_RESET_PLL_BEFORE);
  }
  uint32_t mul  = band_s[band].mul;
 800901a:	f8d8 2000 	ldr.w	r2, [r8]
 800901e:	9808      	ldr	r0, [sp, #32]
 8009020:	4402      	add	r2, r0
 8009022:	7993      	ldrb	r3, [r2, #6]
  uint32_t omul = band_s[band].omul;
  uint8_t  ds   = drive_strength;
  uint8_t ods   = drive_strength;
  if (drive_strength > SI5351_CLK_DRIVE_STRENGTH_8MA) {ds = band_s[band].pow; ods = band_s[band].opow;}
 8009024:	2d03      	cmp	r5, #3
  uint32_t mul  = band_s[band].mul;
 8009026:	f003 010f 	and.w	r1, r3, #15
  uint32_t omul = band_s[band].omul;
 800902a:	ea4f 1313 	mov.w	r3, r3, lsr #4
  uint32_t mul  = band_s[band].mul;
 800902e:	9105      	str	r1, [sp, #20]
  uint32_t omul = band_s[band].omul;
 8009030:	9307      	str	r3, [sp, #28]
  if (drive_strength > SI5351_CLK_DRIVE_STRENGTH_8MA) {ds = band_s[band].pow; ods = band_s[band].opow;}
 8009032:	d939      	bls.n	80090a8 <si5351_set_frequency+0x124>
 8009034:	79d3      	ldrb	r3, [r2, #7]
 8009036:	f003 050f 	and.w	r5, r3, #15
 800903a:	091b      	lsrs	r3, r3, #4
 800903c:	9309      	str	r3, [sp, #36]	@ 0x24
  switch (band_s[band].mode) {
 800903e:	7913      	ldrb	r3, [r2, #4]
 8009040:	2b01      	cmp	r3, #1
 8009042:	d035      	beq.n	80090b0 <si5351_set_frequency+0x12c>
 8009044:	2b02      	cmp	r3, #2
 8009046:	d070      	beq.n	800912a <si5351_set_frequency+0x1a6>
 8009048:	2000      	movs	r0, #0
      // Calculate CH2 freq = CLK2_FREQUENCY, depend from calculated before CH1 PLLB = (freq/mul)*fdiv
      si5351_set_frequency_fixedpll(AUDIO_CODEC_CHANNEL, (uint64_t)freq * fdiv, CLK2_FREQUENCY * mul, SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA | SI5351_CLK_PLL_SELECT_B);
      delay= DELAY_BAND_3_4;
      break;
  }
  if (current_band != band) {
 800904a:	783b      	ldrb	r3, [r7, #0]
 800904c:	42b3      	cmp	r3, r6
 800904e:	d00d      	beq.n	800906c <si5351_set_frequency+0xe8>
//    si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, ~(SI5351_CLK0_EN|SI5351_CLK1_EN|SI5351_CLK2_EN));
    // Possibly not need add delay now
    if (DELAY_RESET_PLL_AFTER){
      chThdSleepMicroseconds(DELAY_RESET_PLL_AFTER);
 8009050:	f44f 70c8 	mov.w	r0, #400	@ 0x190
 8009054:	f7f7 ff1c 	bl	8000e90 <chThdSleep>
  uint8_t buf[] = { reg, dat };
 8009058:	f64a 43b1 	movw	r3, #44209	@ 0xacb1
  si5351_bulk_write(buf, 2);
 800905c:	a80b      	add	r0, sp, #44	@ 0x2c
 800905e:	2102      	movs	r1, #2
  uint8_t buf[] = { reg, dat };
 8009060:	f8ad 302c 	strh.w	r3, [sp, #44]	@ 0x2c
  si5351_bulk_write(buf, 2);
 8009064:	f7ff fe16 	bl	8008c94 <si5351_bulk_write>
      si5351_reset_pll(SI5351_PLL_RESET_A|SI5351_PLL_RESET_B);
    }
    current_band = band;
    delay = DELAY_BANDCHANGE;
 8009068:	20c8      	movs	r0, #200	@ 0xc8
    current_band = band;
 800906a:	703e      	strb	r6, [r7, #0]
  }
  current_freq = freq;
 800906c:	f8cb 4000 	str.w	r4, [fp]
  return delay;
}
 8009070:	b00d      	add	sp, #52	@ 0x34
 8009072:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  current_band = 0;
 8009076:	2500      	movs	r5, #0
 8009078:	4f5d      	ldr	r7, [pc, #372]	@ (80091f0 <si5351_set_frequency+0x26c>)
  current_freq = 0;
 800907a:	f8df b184 	ldr.w	fp, [pc, #388]	@ 8009200 <si5351_set_frequency+0x27c>
    current_power = drive_strength;
 800907e:	7015      	strb	r5, [r2, #0]
 8009080:	2270      	movs	r2, #112	@ 0x70
 8009082:	9206      	str	r2, [sp, #24]
  current_band = 0;
 8009084:	703d      	strb	r5, [r7, #0]
  current_freq = 0;
 8009086:	f8cb 5000 	str.w	r5, [fp]
    current_power = drive_strength;
 800908a:	2601      	movs	r6, #1
 800908c:	462a      	mov	r2, r5
 800908e:	e7ab      	b.n	8008fe8 <si5351_set_frequency+0x64>
  current_band = 0;
 8009090:	4f57      	ldr	r7, [pc, #348]	@ (80091f0 <si5351_set_frequency+0x26c>)
  current_freq = 0;
 8009092:	f8df b16c 	ldr.w	fp, [pc, #364]	@ 8009200 <si5351_set_frequency+0x27c>
    current_power = drive_strength;
 8009096:	7015      	strb	r5, [r2, #0]
  current_band = 0;
 8009098:	2200      	movs	r2, #0
 800909a:	703a      	strb	r2, [r7, #0]
  current_freq = 0;
 800909c:	f8cb 2000 	str.w	r2, [fp]
    rdiv = SI5351_R_DIV(4);
 80090a0:	2240      	movs	r2, #64	@ 0x40
 80090a2:	9206      	str	r2, [sp, #24]
    band = 2;
 80090a4:	2602      	movs	r6, #2
 80090a6:	e7a3      	b.n	8008ff0 <si5351_set_frequency+0x6c>
  switch (band_s[band].mode) {
 80090a8:	7913      	ldrb	r3, [r2, #4]
  uint8_t ods   = drive_strength;
 80090aa:	9509      	str	r5, [sp, #36]	@ 0x24
  switch (band_s[band].mode) {
 80090ac:	2b01      	cmp	r3, #1
 80090ae:	d1c9      	bne.n	8009044 <si5351_set_frequency+0xc0>
      pll_n = band_s[band].pll_n;
 80090b0:	f892 8005 	ldrb.w	r8, [r2, #5]
      if (current_band != band) {
 80090b4:	783a      	ldrb	r2, [r7, #0]
 80090b6:	42b2      	cmp	r2, r6
 80090b8:	d017      	beq.n	80090ea <si5351_set_frequency+0x166>
        si5351_setupPLL(SI5351_REG_PLL_A,   pll_n, 0, 1);
 80090ba:	2200      	movs	r2, #0
 80090bc:	4641      	mov	r1, r8
 80090be:	201a      	movs	r0, #26
 80090c0:	9308      	str	r3, [sp, #32]
 80090c2:	f7ff fded 	bl	8008ca0 <si5351_setupPLL>
        si5351_setupPLL(SI5351_REG_PLL_B, PLL_N_2, 0, 1);
 80090c6:	9b08      	ldr	r3, [sp, #32]
 80090c8:	2200      	movs	r2, #0
 80090ca:	2120      	movs	r1, #32
 80090cc:	2022      	movs	r0, #34	@ 0x22
 80090ce:	f7ff fde7 	bl	8008ca0 <si5351_setupPLL>
        si5351_set_frequency_fixedpll(AUDIO_CODEC_CHANNEL, config._xtal_freq * PLL_N_2, CLK2_FREQUENCY, SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA | SI5351_CLK_PLL_SELECT_B);
 80090d2:	2300      	movs	r3, #0
 80090d4:	9301      	str	r3, [sp, #4]
 80090d6:	f8d9 2064 	ldr.w	r2, [r9, #100]	@ 0x64
 80090da:	4946      	ldr	r1, [pc, #280]	@ (80091f4 <si5351_set_frequency+0x270>)
 80090dc:	9100      	str	r1, [sp, #0]
 80090de:	2120      	movs	r1, #32
 80090e0:	0152      	lsls	r2, r2, #5
 80090e2:	9102      	str	r1, [sp, #8]
 80090e4:	2002      	movs	r0, #2
 80090e6:	f7ff fecd 	bl	8008e84 <si5351_set_frequency_fixedpll>
      si5351_set_frequency_fixedpll(OFREQ_CHANNEL, (uint64_t)omul * config._xtal_freq * pll_n, ofreq, rdiv, ods | SI5351_CLK_PLL_SELECT_A);
 80090ea:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80090ec:	9302      	str	r3, [sp, #8]
 80090ee:	9b07      	ldr	r3, [sp, #28]
 80090f0:	f8cd a000 	str.w	sl, [sp]
 80090f4:	fba3 2308 	umull	r2, r3, r3, r8
 80090f8:	9b06      	ldr	r3, [sp, #24]
 80090fa:	9301      	str	r3, [sp, #4]
 80090fc:	f8d9 3064 	ldr.w	r3, [r9, #100]	@ 0x64
 8009100:	2000      	movs	r0, #0
 8009102:	fba3 2302 	umull	r2, r3, r3, r2
 8009106:	f7ff febd 	bl	8008e84 <si5351_set_frequency_fixedpll>
      si5351_set_frequency_fixedpll( FREQ_CHANNEL, (uint64_t) mul * config._xtal_freq * pll_n,  freq, rdiv,  ds | SI5351_CLK_PLL_SELECT_A);
 800910a:	9a05      	ldr	r2, [sp, #20]
 800910c:	9502      	str	r5, [sp, #8]
 800910e:	fba8 8302 	umull	r8, r3, r8, r2
 8009112:	9b06      	ldr	r3, [sp, #24]
 8009114:	9301      	str	r3, [sp, #4]
 8009116:	f8d9 2064 	ldr.w	r2, [r9, #100]	@ 0x64
 800911a:	9400      	str	r4, [sp, #0]
 800911c:	2001      	movs	r0, #1
 800911e:	fba2 2308 	umull	r2, r3, r2, r8
 8009122:	f7ff feaf 	bl	8008e84 <si5351_set_frequency_fixedpll>
      delay = DELAY_BAND_1_2;
 8009126:	200a      	movs	r0, #10
      break;
 8009128:	e78f      	b.n	800904a <si5351_set_frequency+0xc6>
      fdiv = band_s[band].div;
 800912a:	f892 9005 	ldrb.w	r9, [r2, #5]
  uint32_t omul = band_s[band].omul;
 800912e:	9b07      	ldr	r3, [sp, #28]
 8009130:	9300      	str	r3, [sp, #0]
      si5351_setupPLL_freq(SI5351_REG_PLL_A, (uint64_t)ofreq * fdiv, omul);  // set PLLA freq = (ofreq/omul)*fdiv
 8009132:	201a      	movs	r0, #26
 8009134:	fbaa 2309 	umull	r2, r3, sl, r9
 8009138:	f7ff fdf0 	bl	8008d1c <si5351_setupPLL_freq>
      si5351_setupPLL_freq(SI5351_REG_PLL_B, (uint64_t) freq * fdiv,  mul);  // set PLLB freq = ( freq/ mul)*fdiv
 800913c:	9b05      	ldr	r3, [sp, #20]
 800913e:	9300      	str	r3, [sp, #0]
 8009140:	fba9 3a04 	umull	r3, sl, r9, r4
 8009144:	461a      	mov	r2, r3
 8009146:	9306      	str	r3, [sp, #24]
 8009148:	2022      	movs	r0, #34	@ 0x22
 800914a:	4653      	mov	r3, sl
 800914c:	f7ff fde6 	bl	8008d1c <si5351_setupPLL_freq>
      if (band_s[current_band].div != band_s[band].div) {
 8009150:	f8d8 2000 	ldr.w	r2, [r8]
 8009154:	9b08      	ldr	r3, [sp, #32]
 8009156:	4413      	add	r3, r2
 8009158:	7959      	ldrb	r1, [r3, #5]
 800915a:	783b      	ldrb	r3, [r7, #0]
 800915c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8009160:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8009164:	7953      	ldrb	r3, [r2, #5]
 8009166:	428b      	cmp	r3, r1
 8009168:	d015      	beq.n	8009196 <si5351_set_frequency+0x212>
        si5351_setupMultisynth(OFREQ_CHANNEL, fdiv, 0, 1, SI5351_R_DIV_1, ods | SI5351_CLK_PLL_SELECT_A);
 800916a:	f04f 0800 	mov.w	r8, #0
 800916e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8009170:	9301      	str	r3, [sp, #4]
 8009172:	4642      	mov	r2, r8
 8009174:	2301      	movs	r3, #1
 8009176:	4649      	mov	r1, r9
 8009178:	4640      	mov	r0, r8
 800917a:	f8cd 8000 	str.w	r8, [sp]
 800917e:	f7ff fe0b 	bl	8008d98 <si5351_setupMultisynth>
        si5351_setupMultisynth( FREQ_CHANNEL, fdiv, 0, 1, SI5351_R_DIV_1,  ds | SI5351_CLK_PLL_SELECT_B);
 8009182:	f045 0520 	orr.w	r5, r5, #32
 8009186:	2301      	movs	r3, #1
 8009188:	e9cd 8500 	strd	r8, r5, [sp]
 800918c:	4642      	mov	r2, r8
 800918e:	4649      	mov	r1, r9
 8009190:	4618      	mov	r0, r3
 8009192:	f7ff fe01 	bl	8008d98 <si5351_setupMultisynth>
      si5351_set_frequency_fixedpll(AUDIO_CODEC_CHANNEL, (uint64_t)freq * fdiv, CLK2_FREQUENCY * mul, SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA | SI5351_CLK_PLL_SELECT_B);
 8009196:	4917      	ldr	r1, [pc, #92]	@ (80091f4 <si5351_set_frequency+0x270>)
 8009198:	9805      	ldr	r0, [sp, #20]
 800919a:	9a06      	ldr	r2, [sp, #24]
 800919c:	fb01 f000 	mul.w	r0, r1, r0
 80091a0:	9000      	str	r0, [sp, #0]
 80091a2:	2100      	movs	r1, #0
 80091a4:	2020      	movs	r0, #32
 80091a6:	e9cd 1001 	strd	r1, r0, [sp, #4]
 80091aa:	4653      	mov	r3, sl
 80091ac:	2002      	movs	r0, #2
 80091ae:	f7ff fe69 	bl	8008e84 <si5351_set_frequency_fixedpll>
      delay= DELAY_BAND_3_4;
 80091b2:	200c      	movs	r0, #12
      break;
 80091b4:	e749      	b.n	800904a <si5351_set_frequency+0xc6>
    band = si5351_get_harmonic_lvl(freq);
 80091b6:	9305      	str	r3, [sp, #20]
 80091b8:	f7ff fecc 	bl	8008f54 <si5351_get_harmonic_lvl>
  if (current_power != drive_strength){
 80091bc:	4a0b      	ldr	r2, [pc, #44]	@ (80091ec <si5351_set_frequency+0x268>)
 80091be:	9b05      	ldr	r3, [sp, #20]
 80091c0:	7811      	ldrb	r1, [r2, #0]
 80091c2:	42a9      	cmp	r1, r5
    band = si5351_get_harmonic_lvl(freq);
 80091c4:	b2c6      	uxtb	r6, r0
  if (current_power != drive_strength){
 80091c6:	d00b      	beq.n	80091e0 <si5351_set_frequency+0x25c>
  current_band = 0;
 80091c8:	4f09      	ldr	r7, [pc, #36]	@ (80091f0 <si5351_set_frequency+0x26c>)
  current_freq = 0;
 80091ca:	f8df b034 	ldr.w	fp, [pc, #52]	@ 8009200 <si5351_set_frequency+0x27c>
    current_power = drive_strength;
 80091ce:	7015      	strb	r5, [r2, #0]
  current_band = 0;
 80091d0:	2200      	movs	r2, #0
 80091d2:	703a      	strb	r2, [r7, #0]
  current_freq = 0;
 80091d4:	f8cb 2000 	str.w	r2, [fp]
  uint32_t rdiv = SI5351_R_DIV_1;
 80091d8:	9206      	str	r2, [sp, #24]
 80091da:	e709      	b.n	8008ff0 <si5351_set_frequency+0x6c>
    return DELAY_CHANNEL_CHANGE;
 80091dc:	200a      	movs	r0, #10
 80091de:	e747      	b.n	8009070 <si5351_set_frequency+0xec>
  uint32_t rdiv = SI5351_R_DIV_1;
 80091e0:	2200      	movs	r2, #0
 80091e2:	9206      	str	r2, [sp, #24]
 80091e4:	e6fc      	b.n	8008fe0 <si5351_set_frequency+0x5c>
 80091e6:	bf00      	nop
 80091e8:	000f4240 	.word	0x000f4240
 80091ec:	200068c0 	.word	0x200068c0
 80091f0:	200068c1 	.word	0x200068c1
 80091f4:	007a1200 	.word	0x007a1200
 80091f8:	20000318 	.word	0x20000318
 80091fc:	200068b4 	.word	0x200068b4
 8009200:	200068bc 	.word	0x200068bc

08009204 <si5351_set_power>:
  if (drive_strength == current_power) return;
 8009204:	4b04      	ldr	r3, [pc, #16]	@ (8009218 <si5351_set_power+0x14>)
 8009206:	781b      	ldrb	r3, [r3, #0]
 8009208:	4283      	cmp	r3, r0
void si5351_set_power(uint8_t drive_strength){
 800920a:	4601      	mov	r1, r0
  if (drive_strength == current_power) return;
 800920c:	d003      	beq.n	8009216 <si5351_set_power+0x12>
  si5351_set_frequency(current_freq, drive_strength);
 800920e:	4b03      	ldr	r3, [pc, #12]	@ (800921c <si5351_set_power+0x18>)
 8009210:	6818      	ldr	r0, [r3, #0]
 8009212:	f7ff beb7 	b.w	8008f84 <si5351_set_frequency>
}
 8009216:	4770      	bx	lr
 8009218:	200068c0 	.word	0x200068c0
 800921c:	200068bc 	.word	0x200068bc

08009220 <si5351_init>:
{
 8009220:	b538      	push	{r3, r4, r5, lr}
  const uint8_t *p = si5351_configs;
 8009222:	4b0b      	ldr	r3, [pc, #44]	@ (8009250 <si5351_init+0x30>)
  while (*p) {
 8009224:	2402      	movs	r4, #2
    uint8_t len = *p++;
 8009226:	1c5d      	adds	r5, r3, #1
    si5351_bulk_write(p, len);
 8009228:	4621      	mov	r1, r4
 800922a:	4628      	mov	r0, r5
 800922c:	f7ff fd32 	bl	8008c94 <si5351_bulk_write>
    p += len;
 8009230:	192b      	adds	r3, r5, r4
  while (*p) {
 8009232:	5d2c      	ldrb	r4, [r5, r4]
 8009234:	2c00      	cmp	r4, #0
 8009236:	d1f6      	bne.n	8009226 <si5351_init+0x6>
  si5351_set_band_mode(config._band_mode);
 8009238:	4b06      	ldr	r3, [pc, #24]	@ (8009254 <si5351_init+0x34>)
 800923a:	f893 006c 	ldrb.w	r0, [r3, #108]	@ 0x6c
 800923e:	f7ff fe7f 	bl	8008f40 <si5351_set_band_mode>
  si5351_set_frequency(XTALFREQ, 0);
 8009242:	4621      	mov	r1, r4
 8009244:	4804      	ldr	r0, [pc, #16]	@ (8009258 <si5351_init+0x38>)
}
 8009246:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  si5351_set_frequency(XTALFREQ, 0);
 800924a:	f7ff be9b 	b.w	8008f84 <si5351_set_frequency>
 800924e:	bf00      	nop
 8009250:	0801414c 	.word	0x0801414c
 8009254:	20000318 	.word	0x20000318
 8009258:	018cba80 	.word	0x018cba80

0800925c <tlv320aic3204_config>:
}
#endif

static void
tlv320aic3204_config(const uint8_t *data, int len)
{
 800925c:	b538      	push	{r3, r4, r5, lr}
 800925e:	4604      	mov	r4, r0
  for (; len--; data += 2)
 8009260:	eb00 0541 	add.w	r5, r0, r1, lsl #1
  i2c_transfer(AIC3204_ADDR, buf, len);
 8009264:	4621      	mov	r1, r4
 8009266:	2202      	movs	r2, #2
 8009268:	2018      	movs	r0, #24
  for (; len--; data += 2)
 800926a:	3402      	adds	r4, #2
  i2c_transfer(AIC3204_ADDR, buf, len);
 800926c:	f007 fcd0 	bl	8010c10 <i2c_transfer>
  for (; len--; data += 2)
 8009270:	42a5      	cmp	r5, r4
 8009272:	d1f7      	bne.n	8009264 <tlv320aic3204_config+0x8>
    tlv320aic3204_bulk_write(data, 2);
}
 8009274:	bd38      	pop	{r3, r4, r5, pc}
 8009276:	bf00      	nop

08009278 <tlv320aic3204_init>:

void tlv320aic3204_init(void)
{
 8009278:	b508      	push	{r3, lr}
  tlv320aic3204_config(conf_data, sizeof(conf_data)/2);
 800927a:	4805      	ldr	r0, [pc, #20]	@ (8009290 <tlv320aic3204_init+0x18>)
 800927c:	211b      	movs	r1, #27
 800927e:	f7ff ffed 	bl	800925c <tlv320aic3204_config>
//  wait_ms(40);
  tlv320aic3204_config(conf_data_unmute, sizeof(conf_data_unmute)/2);
}
 8009282:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  tlv320aic3204_config(conf_data_unmute, sizeof(conf_data_unmute)/2);
 8009286:	4803      	ldr	r0, [pc, #12]	@ (8009294 <tlv320aic3204_init+0x1c>)
 8009288:	2104      	movs	r1, #4
 800928a:	f7ff bfe7 	b.w	800925c <tlv320aic3204_config>
 800928e:	bf00      	nop
 8009290:	08014174 	.word	0x08014174
 8009294:	0801416c 	.word	0x0801416c

08009298 <tlv320aic3204_select>:
  static uint8_t current_channel = -1;
  if (current_channel == channel)
    return;
  current_channel = channel;
#endif
  tlv320aic3204_bulk_write(channel ? conf_data_ch1_select : conf_data_ch3_select, sizeof(conf_data_ch1_select));
 8009298:	b120      	cbz	r0, 80092a4 <tlv320aic3204_select+0xc>
 800929a:	4905      	ldr	r1, [pc, #20]	@ (80092b0 <tlv320aic3204_select+0x18>)
  i2c_transfer(AIC3204_ADDR, buf, len);
 800929c:	2205      	movs	r2, #5
 800929e:	2018      	movs	r0, #24
 80092a0:	f007 bcb6 	b.w	8010c10 <i2c_transfer>
  tlv320aic3204_bulk_write(channel ? conf_data_ch1_select : conf_data_ch3_select, sizeof(conf_data_ch1_select));
 80092a4:	4903      	ldr	r1, [pc, #12]	@ (80092b4 <tlv320aic3204_select+0x1c>)
  i2c_transfer(AIC3204_ADDR, buf, len);
 80092a6:	2205      	movs	r2, #5
 80092a8:	2018      	movs	r0, #24
 80092aa:	f007 bcb1 	b.w	8010c10 <i2c_transfer>
 80092ae:	bf00      	nop
 80092b0:	0801415c 	.word	0x0801415c
 80092b4:	08014164 	.word	0x08014164

080092b8 <tlv320aic3204_set_gain>:
//  tlv320aic3204_config(channel ? conf_data_ch1_select : conf_data_ch3_select, sizeof(conf_data_ch3_select)/2);
}

void tlv320aic3204_set_gain(uint8_t lgain, uint8_t rgain)
{
 80092b8:	b500      	push	{lr}
 80092ba:	b083      	sub	sp, #12
 80092bc:	460b      	mov	r3, r1
  uint8_t data[] = {
 80092be:	f04f 0c3b 	mov.w	ip, #59	@ 0x3b
 80092c2:	f88d 0005 	strb.w	r0, [sp, #5]
  i2c_transfer(AIC3204_ADDR, buf, len);
 80092c6:	2203      	movs	r2, #3
 80092c8:	a901      	add	r1, sp, #4
 80092ca:	2018      	movs	r0, #24
  uint8_t data[] = {
 80092cc:	f88d c004 	strb.w	ip, [sp, #4]
 80092d0:	f88d 3006 	strb.w	r3, [sp, #6]
  i2c_transfer(AIC3204_ADDR, buf, len);
 80092d4:	f007 fc9c 	bl	8010c10 <i2c_transfer>
    0x3b,   lgain, // Unmute Left MICPGA, set gain
  /*0x3c,*/ rgain  // Unmute Right MICPGA, set gain
  };
//  tlv320aic3204_config(data, sizeof(data)/2);
  tlv320aic3204_bulk_write(data, sizeof(data));
}
 80092d8:	b003      	add	sp, #12
 80092da:	f85d fb04 	ldr.w	pc, [sp], #4
 80092de:	bf00      	nop

080092e0 <generate_DSP_Table>:

#include "nanovna.h"

#ifdef USE_VARIABLE_OFFSET
static int16_t sincos_tbl[AUDIO_SAMPLES_COUNT][2];
void generate_DSP_Table(int offset){
 80092e0:	b530      	push	{r4, r5, lr}
 80092e2:	ed2d 8b04 	vpush	{d8-d9}
 80092e6:	ee09 0a10 	vmov	s18, r0
  float audio_freq  = AUDIO_ADC_FREQ;
  // N = offset * AUDIO_SAMPLES_COUNT / audio_freq; should be integer
  // AUDIO_SAMPLES_COUNT = N * audio_freq / offset; N - minimum integer value for get integer AUDIO_SAMPLES_COUNT
  // Bandwidth on one step = audio_freq / AUDIO_SAMPLES_COUNT
  float step = offset / audio_freq;
 80092ea:	eddf 7a19 	vldr	s15, [pc, #100]	@ 8009350 <generate_DSP_Table+0x70>
 80092ee:	4c19      	ldr	r4, [pc, #100]	@ (8009354 <generate_DSP_Table+0x74>)
  float w = step/2;
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
    float s, c;
    vna_sincosf(w, &s, &c);
    sincos_tbl[i][0] = s*32700.0f;
 80092f0:	eddf 8a19 	vldr	s17, [pc, #100]	@ 8009358 <generate_DSP_Table+0x78>
  float step = offset / audio_freq;
 80092f4:	eeb8 9ac9 	vcvt.f32.s32	s18, s18
  float w = step/2;
 80092f8:	eeb6 8a00 	vmov.f32	s16, #96	@ 0x3f000000  0.5
  float step = offset / audio_freq;
 80092fc:	ee29 9a27 	vmul.f32	s18, s18, s15
void generate_DSP_Table(int offset){
 8009300:	b083      	sub	sp, #12
  float w = step/2;
 8009302:	ee29 8a08 	vmul.f32	s16, s18, s16
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 8009306:	f104 05c0 	add.w	r5, r4, #192	@ 0xc0
    vna_sincosf(w, &s, &c);
 800930a:	eeb0 0a48 	vmov.f32	s0, s16
 800930e:	a901      	add	r1, sp, #4
 8009310:	4668      	mov	r0, sp
 8009312:	f007 ff6f 	bl	80111f4 <vna_sincosf>
    sincos_tbl[i][0] = s*32700.0f;
 8009316:	ed9d 7a00 	vldr	s14, [sp]
    sincos_tbl[i][1] = c*32700.0f;
 800931a:	eddd 7a01 	vldr	s15, [sp, #4]
    sincos_tbl[i][0] = s*32700.0f;
 800931e:	ee27 7a28 	vmul.f32	s14, s14, s17
    sincos_tbl[i][1] = c*32700.0f;
 8009322:	ee67 7aa8 	vmul.f32	s15, s15, s17
    sincos_tbl[i][0] = s*32700.0f;
 8009326:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    sincos_tbl[i][1] = c*32700.0f;
 800932a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    sincos_tbl[i][0] = s*32700.0f;
 800932e:	ee17 3a10 	vmov	r3, s14
 8009332:	8023      	strh	r3, [r4, #0]
    sincos_tbl[i][1] = c*32700.0f;
 8009334:	ee17 3a90 	vmov	r3, s15
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 8009338:	3404      	adds	r4, #4
    sincos_tbl[i][1] = c*32700.0f;
 800933a:	f824 3c02 	strh.w	r3, [r4, #-2]
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 800933e:	42ac      	cmp	r4, r5
    w+=step;
 8009340:	ee38 8a09 	vadd.f32	s16, s16, s18
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 8009344:	d1e1      	bne.n	800930a <generate_DSP_Table+0x2a>
  }
}
 8009346:	b003      	add	sp, #12
 8009348:	ecbd 8b04 	vpop	{d8-d9}
 800934c:	bd30      	pop	{r4, r5, pc}
 800934e:	bf00      	nop
 8009350:	36aec33e 	.word	0x36aec33e
 8009354:	200068e8 	.word	0x200068e8
 8009358:	46ff7800 	.word	0x46ff7800

0800935c <dsp_process>:
static acc_t acc_ref_c;
// Cortex M4 DSP instruction use
#include "dsp.h"
void
dsp_process(audio_sample_t *capture, size_t length)
{
 800935c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009360:	b087      	sub	sp, #28
 8009362:	4b20      	ldr	r3, [pc, #128]	@ (80093e4 <dsp_process+0x88>)
 8009364:	9303      	str	r3, [sp, #12]
    acc_samp_s= __smlaltb(acc_samp_s, sr, sc ); // samp_s+= smp * sin
    acc_samp_c= __smlaltt(acc_samp_c, sr, sc ); // samp_c+= smp * cos
    acc_ref_s = __smlalbb( acc_ref_s, sr, sc ); //  ref_s+= ref * sin
    acc_ref_c = __smlalbt( acc_ref_c, sr, sc ); //  ref_s+= ref * cos
    i++;
  } while (i < length/2);
 8009366:	084b      	lsrs	r3, r1, #1
 8009368:	9305      	str	r3, [sp, #20]
 800936a:	1f03      	subs	r3, r0, #4
 800936c:	9302      	str	r3, [sp, #8]
 800936e:	f8df b078 	ldr.w	fp, [pc, #120]	@ 80093e8 <dsp_process+0x8c>
 8009372:	f8df a078 	ldr.w	sl, [pc, #120]	@ 80093ec <dsp_process+0x90>
 8009376:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 80093f0 <dsp_process+0x94>
 800937a:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 80093f4 <dsp_process+0x98>
  uint32_t i = 0;
 800937e:	2300      	movs	r3, #0
 8009380:	9301      	str	r3, [sp, #4]
    i++;
 8009382:	9a01      	ldr	r2, [sp, #4]
    int32_t sc = ((int32_t *)sincos_tbl)[i];
 8009384:	9803      	ldr	r0, [sp, #12]
    acc_ref_s = __smlalbb( acc_ref_s, sr, sc ); //  ref_s+= ref * sin
 8009386:	f8d9 5000 	ldr.w	r5, [r9]
 800938a:	f8d9 4004 	ldr.w	r4, [r9, #4]
    acc_samp_s= __smlaltb(acc_samp_s, sr, sc ); // samp_s+= smp * sin
 800938e:	e9db 1300 	ldrd	r1, r3, [fp]
    i++;
 8009392:	3201      	adds	r2, #1
 8009394:	9201      	str	r2, [sp, #4]
    int32_t sc = ((int32_t *)sincos_tbl)[i];
 8009396:	f850 2b04 	ldr.w	r2, [r0], #4
 800939a:	9003      	str	r0, [sp, #12]
  register union {
    struct { uint32_t lo; uint32_t hi; } s_rep;
    int64_t i_rep;
  } r;
  r.i_rep = acc;
  __asm__ ("smlaltb %[r_lo], %[r_hi], %[x], %[y]"
 800939c:	468e      	mov	lr, r1
    acc_ref_c = __smlalbt( acc_ref_c, sr, sc ); //  ref_s+= ref * cos
 800939e:	e9d8 0100 	ldrd	r0, r1, [r8]
  __asm__ ("smlalbt %[r_lo], %[r_hi], %[x], %[y]"
 80093a2:	9104      	str	r1, [sp, #16]
    int32_t sr = ((int32_t *)capture)[i];
 80093a4:	9902      	ldr	r1, [sp, #8]
  __asm__ ("smlaltb %[r_lo], %[r_hi], %[x], %[y]"
 80093a6:	469c      	mov	ip, r3
 80093a8:	f851 3f04 	ldr.w	r3, [r1, #4]!
 80093ac:	9102      	str	r1, [sp, #8]
 80093ae:	fbc3 eca2 	smlaltb	lr, ip, r3, r2
  __asm__ ("smlalbb %[r_lo], %[r_hi], %[x], %[y]"
 80093b2:	fbc3 5482 	smlalbb	r5, r4, r3, r2
    acc_samp_c= __smlaltt(acc_samp_c, sr, sc ); // samp_c+= smp * cos
 80093b6:	e9da 7600 	ldrd	r7, r6, [sl]
  register union {
    struct { uint32_t lo; uint32_t hi; } s_rep;
    int64_t i_rep;
  } r;
  r.i_rep = acc;
  __asm__ ("smlaltt %[r_lo], %[r_hi], %[x], %[y]"
 80093ba:	fbc3 76b2 	smlaltt	r7, r6, r3, r2
  __asm__ ("smlalbt %[r_lo], %[r_hi], %[x], %[y]"
 80093be:	9904      	ldr	r1, [sp, #16]
 80093c0:	fbc3 0192 	smlalbt	r0, r1, r3, r2
  } while (i < length/2);
 80093c4:	9b05      	ldr	r3, [sp, #20]
 80093c6:	9a01      	ldr	r2, [sp, #4]
 80093c8:	4293      	cmp	r3, r2
    acc_samp_s= __smlaltb(acc_samp_s, sr, sc ); // samp_s+= smp * sin
 80093ca:	e9cb ec00 	strd	lr, ip, [fp]
    acc_samp_c= __smlaltt(acc_samp_c, sr, sc ); // samp_c+= smp * cos
 80093ce:	e9ca 7600 	strd	r7, r6, [sl]
    acc_ref_s = __smlalbb( acc_ref_s, sr, sc ); //  ref_s+= ref * sin
 80093d2:	e9c9 5400 	strd	r5, r4, [r9]
    acc_ref_c = __smlalbt( acc_ref_c, sr, sc ); //  ref_s+= ref * cos
 80093d6:	e9c8 0100 	strd	r0, r1, [r8]
  } while (i < length/2);
 80093da:	d8d2      	bhi.n	8009382 <dsp_process+0x26>
// Accumulate result, for faster calc and prevent overflow reduce size to int32_t
//  acc_samp_s+= (int32_t)(samp_s>>4);
//  acc_samp_c+= (int32_t)(samp_c>>4);
//  acc_ref_s += (int32_t)( ref_s>>4);
//  acc_ref_c += (int32_t)( ref_c>>4);
}
 80093dc:	b007      	add	sp, #28
 80093de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80093e2:	bf00      	nop
 80093e4:	200068e8 	.word	0x200068e8
 80093e8:	200068e0 	.word	0x200068e0
 80093ec:	200068d8 	.word	0x200068d8
 80093f0:	200068d0 	.word	0x200068d0
 80093f4:	200068c8 	.word	0x200068c8

080093f8 <calculate_gamma>:
#endif

void
calculate_gamma(float *gamma)
{
 80093f8:	b510      	push	{r4, lr}
  measure_t ss = acc_samp_s;
  measure_t sc = acc_samp_c;
  gamma[0] =  (sc * rc + ss * rs) / rr;
  gamma[1] =  (ss * rc - sc * rs) / rr;
#else
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 80093fa:	4b1f      	ldr	r3, [pc, #124]	@ (8009478 <calculate_gamma+0x80>)
{
 80093fc:	ed2d 8b04 	vpush	{d8-d9}
 8009400:	4604      	mov	r4, r0
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 8009402:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009406:	f7f7 fa43 	bl	8000890 <__aeabi_l2f>
 800940a:	ee07 0a90 	vmov	s15, r0
 800940e:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 8009412:	eec8 9aa7 	vdiv.f32	s19, s17, s15
 8009416:	4b19      	ldr	r3, [pc, #100]	@ (800947c <calculate_gamma+0x84>)
 8009418:	e9d3 0100 	ldrd	r0, r1, [r3]
 800941c:	f7f7 fa38 	bl	8000890 <__aeabi_l2f>
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 8009420:	4b17      	ldr	r3, [pc, #92]	@ (8009480 <calculate_gamma+0x88>)
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 8009422:	ee08 0a10 	vmov	s16, r0
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 8009426:	e9d3 0100 	ldrd	r0, r1, [r3]
 800942a:	f7f7 fa31 	bl	8000890 <__aeabi_l2f>
  measure_t ss_rc = (measure_t)acc_samp_s / acc_ref_c;
 800942e:	4b15      	ldr	r3, [pc, #84]	@ (8009484 <calculate_gamma+0x8c>)
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 8009430:	ee09 0a10 	vmov	s18, r0
  measure_t ss_rc = (measure_t)acc_samp_s / acc_ref_c;
 8009434:	e9d3 0100 	ldrd	r0, r1, [r3]
 8009438:	f7f7 fa2a 	bl	8000890 <__aeabi_l2f>
 800943c:	ee07 0a90 	vmov	s15, r0
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 8009440:	ee29 9a29 	vmul.f32	s18, s18, s19
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 8009444:	ee28 8a29 	vmul.f32	s16, s16, s19
  measure_t ss_rc = (measure_t)acc_samp_s / acc_ref_c;
 8009448:	ee67 7aa9 	vmul.f32	s15, s15, s19
  measure_t rr = rs_rc * rs_rc + 1.0f;
 800944c:	eeb0 7a68 	vmov.f32	s14, s17
  gamma[0] = (sc_rc + ss_rc * rs_rc) / rr;
 8009450:	eef0 6a49 	vmov.f32	s13, s18
 8009454:	eee8 6a27 	vfma.f32	s13, s16, s15
  measure_t rr = rs_rc * rs_rc + 1.0f;
 8009458:	eea8 7a08 	vfma.f32	s14, s16, s16
  gamma[1] = (ss_rc - sc_rc * rs_rc) / rr;
 800945c:	eee8 7a49 	vfms.f32	s15, s16, s18
#endif
}
 8009460:	ecbd 8b04 	vpop	{d8-d9}
  gamma[0] = (sc_rc + ss_rc * rs_rc) / rr;
 8009464:	ee86 6a87 	vdiv.f32	s12, s13, s14
  gamma[1] = (ss_rc - sc_rc * rs_rc) / rr;
 8009468:	eec7 6a87 	vdiv.f32	s13, s15, s14
  gamma[0] = (sc_rc + ss_rc * rs_rc) / rr;
 800946c:	ed84 6a00 	vstr	s12, [r4]
  gamma[1] = (ss_rc - sc_rc * rs_rc) / rr;
 8009470:	edc4 6a01 	vstr	s13, [r4, #4]
}
 8009474:	bd10      	pop	{r4, pc}
 8009476:	bf00      	nop
 8009478:	200068c8 	.word	0x200068c8
 800947c:	200068d0 	.word	0x200068d0
 8009480:	200068d8 	.word	0x200068d8
 8009484:	200068e0 	.word	0x200068e0

08009488 <reset_dsp_accumerator>:
  gamma[1] =  acc_ref_c * 1e-9;
}

void
reset_dsp_accumerator(void)
{
 8009488:	b430      	push	{r4, r5}
  acc_ref_s = 0;
  acc_ref_c = 0;
  acc_samp_s = 0;
 800948a:	4808      	ldr	r0, [pc, #32]	@ (80094ac <reset_dsp_accumerator+0x24>)
  acc_ref_s = 0;
 800948c:	4d08      	ldr	r5, [pc, #32]	@ (80094b0 <reset_dsp_accumerator+0x28>)
  acc_ref_c = 0;
 800948e:	4c09      	ldr	r4, [pc, #36]	@ (80094b4 <reset_dsp_accumerator+0x2c>)
  acc_samp_c = 0;
 8009490:	4909      	ldr	r1, [pc, #36]	@ (80094b8 <reset_dsp_accumerator+0x30>)
  acc_ref_s = 0;
 8009492:	2200      	movs	r2, #0
 8009494:	2300      	movs	r3, #0
 8009496:	e9c5 2300 	strd	r2, r3, [r5]
  acc_ref_c = 0;
 800949a:	e9c4 2300 	strd	r2, r3, [r4]
  acc_samp_s = 0;
 800949e:	e9c0 2300 	strd	r2, r3, [r0]
}
 80094a2:	bc30      	pop	{r4, r5}
  acc_samp_c = 0;
 80094a4:	e9c1 2300 	strd	r2, r3, [r1]
}
 80094a8:	4770      	bx	lr
 80094aa:	bf00      	nop
 80094ac:	200068e0 	.word	0x200068e0
 80094b0:	200068d0 	.word	0x200068d0
 80094b4:	200068c8 	.word	0x200068c8
 80094b8:	200068d8 	.word	0x200068d8

080094bc <smith_grid>:
}
#else
static int smith_grid(int x, int y)
{
  uint16_t r = P_RADIUS;
  uint32_t _r = x * x + y * y;
 80094bc:	fb01 f301 	mul.w	r3, r1, r1
 80094c0:	fb00 3300 	mla	r3, r0, r0, r3
  int32_t d = _r;
  if (d > r * r + r)
 80094c4:	f645 22d8 	movw	r2, #23256	@ 0x5ad8
 80094c8:	4293      	cmp	r3, r2
 80094ca:	dc52      	bgt.n	8009572 <smith_grid+0xb6>
    return 0; // outer area
  if (d > r * r - r)
 80094cc:	f645 12a8 	movw	r2, #22952	@ 0x59a8
 80094d0:	4293      	cmp	r3, r2
 80094d2:	dc4c      	bgt.n	800956e <smith_grid+0xb2>
    return 1; // 1 - outer circle
  if (y == 0)
 80094d4:	2900      	cmp	r1, #0
 80094d6:	d04a      	beq.n	800956e <smith_grid+0xb2>
    return 1; // 2 - horizontal axis
  if (y < 0)
 80094d8:	2900      	cmp	r1, #0
 80094da:	bfb8      	it	lt
 80094dc:	4249      	neglt	r1, r1
    y = -y; //  mirror by y axis
  uint32_t r_y = r * y;
 80094de:	f04f 0c98 	mov.w	ip, #152	@ 0x98
  if (x >= 0)
  { //   valid only if x >= 0
    if (x >= r / 2)
    { //    valid only if x >= P_RADIUS/2
      d = _r - 2 * r * x - r_y + r * r + r / 2;
 80094e2:	f44f 7298 	mov.w	r2, #304	@ 0x130
  if (x >= 0)
 80094e6:	2800      	cmp	r0, #0
  uint32_t r_y = r * y;
 80094e8:	fb0c f101 	mul.w	r1, ip, r1
      d = _r - 2 * r * x - r_y + r * r + r / 2;
 80094ec:	fb02 3210 	mls	r2, r2, r0, r3
  if (x >= 0)
 80094f0:	db2a      	blt.n	8009548 <smith_grid+0x8c>
    if (x >= r / 2)
 80094f2:	284b      	cmp	r0, #75	@ 0x4b
 80094f4:	dd15      	ble.n	8009522 <smith_grid+0x66>
      d = _r - 2 * r * x - r_y + r * r + r / 2;
 80094f6:	f5c1 4cb5 	rsb	ip, r1, #23168	@ 0x5a80
 80094fa:	f10c 0c0c 	add.w	ip, ip, #12
 80094fe:	4494      	add	ip, r2
      if ((uint32_t)d <= r)
 8009500:	f1bc 0f98 	cmp.w	ip, #152	@ 0x98
 8009504:	d933      	bls.n	800956e <smith_grid+0xb2>
        return 1; // 3 - Constant Reactance Circle: 2j : R/2 = P_RADIUS/2 (mirror by y)
      d = _r - (3 * r / 2) * x + r * r / 2 + r / 4;
 8009506:	f04f 0ce4 	mov.w	ip, #228	@ 0xe4
 800950a:	fb0c 3c10 	mls	ip, ip, r0, r3
 800950e:	f50c 5c35 	add.w	ip, ip, #11584	@ 0x2d40
 8009512:	f10c 0c06 	add.w	ip, ip, #6
      if (d < 0)
 8009516:	f1bc 0f00 	cmp.w	ip, #0
 800951a:	db2a      	blt.n	8009572 <smith_grid+0xb6>
        return 0;
      if (d <= r / 2)
 800951c:	f1bc 0f4c 	cmp.w	ip, #76	@ 0x4c
 8009520:	dd25      	ble.n	800956e <smith_grid+0xb2>
        return 1; // 4 - Constant Resistance Circle: 3 : R/4 = P_RADIUS/4
    }
    d = _r - 2 * r * x - 2 * r_y + r * r + r;
 8009522:	eba2 0c41 	sub.w	ip, r2, r1, lsl #1
 8009526:	f50c 4cb5 	add.w	ip, ip, #23168	@ 0x5a80
 800952a:	f10c 0c58 	add.w	ip, ip, #88	@ 0x58
    if ((uint32_t)d <= 2 * r)
 800952e:	f5bc 7f98 	cmp.w	ip, #304	@ 0x130
 8009532:	d91c      	bls.n	800956e <smith_grid+0xb2>
      return 1; // 5 - Constant Reactance Circle: 1j : R = P_RADIUS  (mirror by y)
    d = _r - r * x + r / 2;
 8009534:	f04f 0c98 	mov.w	ip, #152	@ 0x98
 8009538:	fb0c 3c10 	mls	ip, ip, r0, r3
    if (d < 0)
 800953c:	f11c 0c4c 	adds.w	ip, ip, #76	@ 0x4c
 8009540:	d417      	bmi.n	8009572 <smith_grid+0xb6>
      return 0;
    if (d <= r)
 8009542:	f1bc 0f98 	cmp.w	ip, #152	@ 0x98
 8009546:	dd12      	ble.n	800956e <smith_grid+0xb2>
      return 1; // 6 - Constant Resistance Circle: 1 : R/2
  }
  d = _r - 2 * r * x - 4 * r_y + r * r + r * 2;
 8009548:	eba2 0281 	sub.w	r2, r2, r1, lsl #2
 800954c:	f502 42b6 	add.w	r2, r2, #23296	@ 0x5b00
 8009550:	3270      	adds	r2, #112	@ 0x70
  if ((uint32_t)d <= r * 4)
 8009552:	f5b2 7f18 	cmp.w	r2, #608	@ 0x260
 8009556:	d90a      	bls.n	800956e <smith_grid+0xb2>
    return 1; // 7 - Constant Reactance Circle: 1/2j : R*2  (mirror by y)
  d = _r - x * (r / 2) - r * r / 2 + r * 3 / 4;
 8009558:	224c      	movs	r2, #76	@ 0x4c
 800955a:	fb02 3010 	mls	r0, r2, r0, r3
 800955e:	f5a0 5032 	sub.w	r0, r0, #11392	@ 0x2c80
 8009562:	382e      	subs	r0, #46	@ 0x2e
  if ((uint32_t)d <= r * 3 / 2)
 8009564:	28e4      	cmp	r0, #228	@ 0xe4
 8009566:	bf8c      	ite	hi
 8009568:	2000      	movhi	r0, #0
 800956a:	2001      	movls	r0, #1
 800956c:	4770      	bx	lr
    return 1; // 1 - outer circle
 800956e:	2001      	movs	r0, #1
    return 1; // 8 - Constant Resistance Circle: 1/3 : R*3/4
  return 0;
}
 8009570:	4770      	bx	lr
    return 0; // outer area
 8009572:	2000      	movs	r0, #0
 8009574:	4770      	bx	lr
 8009576:	bf00      	nop

08009578 <cell_blit_bitmap>:
  }
}

// Slower, but allow any width bitmaps
static void cell_blit_bitmap(int16_t x, int16_t y, uint16_t w, uint16_t h, const uint8_t *bmp)
{
 8009578:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800957c:	4606      	mov	r6, r0
 800957e:	4610      	mov	r0, r2
  int16_t x1, y1;
  if ((x1 = x + w) < 0 || (y1 = y + h) < 0)
 8009580:	1984      	adds	r4, r0, r6
 8009582:	0424      	lsls	r4, r4, #16
{
 8009584:	9a06      	ldr	r2, [sp, #24]
  if ((x1 = x + w) < 0 || (y1 = y + h) < 0)
 8009586:	d439      	bmi.n	80095fc <cell_blit_bitmap+0x84>
 8009588:	440b      	add	r3, r1
 800958a:	b21b      	sxth	r3, r3
 800958c:	2b00      	cmp	r3, #0
 800958e:	db35      	blt.n	80095fc <cell_blit_bitmap+0x84>
    return;
  if (y1 >= CELLHEIGHT)
 8009590:	2b20      	cmp	r3, #32
 8009592:	bfa8      	it	ge
 8009594:	2320      	movge	r3, #32
    y1 = CELLHEIGHT; // clip bottom
  if (y < 0)
 8009596:	2900      	cmp	r1, #0
 8009598:	db32      	blt.n	8009600 <cell_blit_bitmap+0x88>
  {
    bmp -= y * ((w + 7) >> 3);
    y = 0;
  } // clip top
  for (uint8_t bits = 0; y < y1; y++)
 800959a:	4299      	cmp	r1, r3
 800959c:	da2e      	bge.n	80095fc <cell_blit_bitmap+0x84>
 800959e:	1a5b      	subs	r3, r3, r1
 80095a0:	fa11 f783 	uxtah	r7, r1, r3
        bits = *bmp++;
      if ((0x80 & bits) == 0)
        continue; // no pixel
      if ((uint32_t)(x + r) >= CELLWIDTH)
        continue; // x+r < 0 || x+r >= CELLWIDTH
      cell_buffer[y * CELLWIDTH + x + r] = foreground_color;
 80095a4:	4b1a      	ldr	r3, [pc, #104]	@ (8009610 <cell_blit_bitmap+0x98>)
 80095a6:	f8df 806c 	ldr.w	r8, [pc, #108]	@ 8009614 <cell_blit_bitmap+0x9c>
 80095aa:	681c      	ldr	r4, [r3, #0]
 80095ac:	eb06 1541 	add.w	r5, r6, r1, lsl #5
 80095b0:	eb06 1747 	add.w	r7, r6, r7, lsl #5
 80095b4:	eb04 0445 	add.w	r4, r4, r5, lsl #1
    bmp -= y * ((w + 7) >> 3);
 80095b8:	2100      	movs	r1, #0
    y = 0;
 80095ba:	46b4      	mov	ip, r6
    for (int r = 0; r < w; r++, bits <<= 1)
 80095bc:	2300      	movs	r3, #0
        bits = *bmp++;
 80095be:	4696      	mov	lr, r2
      if ((r & 7) == 0)
 80095c0:	f013 0f07 	tst.w	r3, #7
        bits = *bmp++;
 80095c4:	bf04      	itt	eq
 80095c6:	f81e 1b01 	ldrbeq.w	r1, [lr], #1
 80095ca:	4672      	moveq	r2, lr
    for (int r = 0; r < w; r++, bits <<= 1)
 80095cc:	ea4f 0e41 	mov.w	lr, r1, lsl #1
      if ((0x80 & bits) == 0)
 80095d0:	f011 0f80 	tst.w	r1, #128	@ 0x80
    for (int r = 0; r < w; r++, bits <<= 1)
 80095d4:	fa5f f18e 	uxtb.w	r1, lr
      if ((0x80 & bits) == 0)
 80095d8:	d006      	beq.n	80095e8 <cell_blit_bitmap+0x70>
      if ((uint32_t)(x + r) >= CELLWIDTH)
 80095da:	f1bc 0f1f 	cmp.w	ip, #31
      cell_buffer[y * CELLWIDTH + x + r] = foreground_color;
 80095de:	bf9c      	itt	ls
 80095e0:	f8b8 e000 	ldrhls.w	lr, [r8]
 80095e4:	f824 e013 	strhls.w	lr, [r4, r3, lsl #1]
    for (int r = 0; r < w; r++, bits <<= 1)
 80095e8:	3301      	adds	r3, #1
 80095ea:	4283      	cmp	r3, r0
 80095ec:	f10c 0c01 	add.w	ip, ip, #1
 80095f0:	d1e5      	bne.n	80095be <cell_blit_bitmap+0x46>
  for (uint8_t bits = 0; y < y1; y++)
 80095f2:	3520      	adds	r5, #32
 80095f4:	42bd      	cmp	r5, r7
 80095f6:	f104 0440 	add.w	r4, r4, #64	@ 0x40
 80095fa:	d1de      	bne.n	80095ba <cell_blit_bitmap+0x42>
    }
  }
}
 80095fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bmp -= y * ((w + 7) >> 3);
 8009600:	1dc4      	adds	r4, r0, #7
 8009602:	10e4      	asrs	r4, r4, #3
 8009604:	fb04 2211 	mls	r2, r4, r1, r2
    y = 0;
 8009608:	2100      	movs	r1, #0
  for (uint8_t bits = 0; y < y1; y++)
 800960a:	4299      	cmp	r1, r3
 800960c:	dbc7      	blt.n	800959e <cell_blit_bitmap+0x26>
 800960e:	e7f5      	b.n	80095fc <cell_blit_bitmap+0x84>
 8009610:	200089a4 	.word	0x200089a4
 8009614:	200089f2 	.word	0x200089f2

08009618 <mark_line>:
//**************************************************************************************
// Cell mark map functions
//**************************************************************************************
static void mark_line(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2)
{
  x1 /= CELLWIDTH;
 8009618:	0940      	lsrs	r0, r0, #5
  x2 /= CELLWIDTH;
 800961a:	0952      	lsrs	r2, r2, #5
  y1 /= CELLHEIGHT;
  y2 /= CELLHEIGHT;
  if (x1 == x2 && y1 == y2)
 800961c:	4290      	cmp	r0, r2
  y1 /= CELLHEIGHT;
 800961e:	ea4f 1151 	mov.w	r1, r1, lsr #5
  y2 /= CELLHEIGHT;
 8009622:	ea4f 1353 	mov.w	r3, r3, lsr #5
  if (x1 == x2 && y1 == y2)
 8009626:	d020      	beq.n	800966a <mark_line+0x52>
  {
    markmap[y1] |= 1 << x1;
    return;
  }
  if (x1 > x2)
 8009628:	d92b      	bls.n	8009682 <mark_line+0x6a>
    SWAP(uint16_t, x1, x2);
  uint32_t mask = ((1 << (x2 - x1 + 1)) - 1) << x1;
 800962a:	1a80      	subs	r0, r0, r2
 800962c:	f100 0c01 	add.w	ip, r0, #1
 8009630:	2001      	movs	r0, #1
 8009632:	fa00 f00c 	lsl.w	r0, r0, ip
 8009636:	3801      	subs	r0, #1
  if (y1 > y2)
 8009638:	4299      	cmp	r1, r3
  uint32_t mask = ((1 << (x2 - x1 + 1)) - 1) << x1;
 800963a:	fa00 f002 	lsl.w	r0, r0, r2
  if (y1 > y2)
 800963e:	d910      	bls.n	8009662 <mark_line+0x4a>
    SWAP(uint16_t, y1, y2);
  for (; y1 <= y2; y1++)
 8009640:	4a12      	ldr	r2, [pc, #72]	@ (800968c <mark_line+0x74>)
 8009642:	1ac9      	subs	r1, r1, r3
 8009644:	fa13 fc81 	uxtah	ip, r3, r1
    markmap[y1] |= mask;
 8009648:	b281      	uxth	r1, r0
 800964a:	1c90      	adds	r0, r2, #2
 800964c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8009650:	eb00 004c 	add.w	r0, r0, ip, lsl #1
 8009654:	881a      	ldrh	r2, [r3, #0]
 8009656:	430a      	orrs	r2, r1
 8009658:	f823 2b02 	strh.w	r2, [r3], #2
  for (; y1 <= y2; y1++)
 800965c:	4298      	cmp	r0, r3
 800965e:	d1f9      	bne.n	8009654 <mark_line+0x3c>
 8009660:	4770      	bx	lr
  if (y1 > y2)
 8009662:	461a      	mov	r2, r3
  y1 /= CELLHEIGHT;
 8009664:	460b      	mov	r3, r1
  y2 /= CELLHEIGHT;
 8009666:	4611      	mov	r1, r2
 8009668:	e7ea      	b.n	8009640 <mark_line+0x28>
  if (x1 == x2 && y1 == y2)
 800966a:	4299      	cmp	r1, r3
 800966c:	d1dd      	bne.n	800962a <mark_line+0x12>
    markmap[y1] |= 1 << x1;
 800966e:	4a07      	ldr	r2, [pc, #28]	@ (800968c <mark_line+0x74>)
 8009670:	2301      	movs	r3, #1
 8009672:	f832 c011 	ldrh.w	ip, [r2, r1, lsl #1]
 8009676:	4083      	lsls	r3, r0
 8009678:	ea43 030c 	orr.w	r3, r3, ip
 800967c:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    return;
 8009680:	4770      	bx	lr
  if (x1 > x2)
 8009682:	4694      	mov	ip, r2
  x1 /= CELLWIDTH;
 8009684:	4602      	mov	r2, r0
  x2 /= CELLWIDTH;
 8009686:	4660      	mov	r0, ip
 8009688:	e7cf      	b.n	800962a <mark_line+0x12>
 800968a:	bf00      	nop
 800968c:	20008990 	.word	0x20008990

08009690 <mark_set_index>:
}

static void mark_set_index(index_t *index, uint16_t i, uint16_t x, uint16_t y)
{
 8009690:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  static uint16_t diff;
  static index_t last_erase;
  diff = (diff << 1);
 8009694:	f8df e088 	ldr.w	lr, [pc, #136]	@ 8009720 <mark_set_index+0x90>
 8009698:	f8be c000 	ldrh.w	ip, [lr]
{
 800969c:	4616      	mov	r6, r2
  if (index[i].x != x || index[i].y != y)
 800969e:	f830 2021 	ldrh.w	r2, [r0, r1, lsl #2]
  diff = (diff << 1);
 80096a2:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80096a6:	fa1f fc8c 	uxth.w	ip, ip
  if (index[i].x != x || index[i].y != y)
 80096aa:	42b2      	cmp	r2, r6
{
 80096ac:	460c      	mov	r4, r1
 80096ae:	4605      	mov	r5, r0
 80096b0:	461f      	mov	r7, r3
  diff = (diff << 1);
 80096b2:	f8ae c000 	strh.w	ip, [lr]
  if (index[i].x != x || index[i].y != y)
 80096b6:	ea4f 0981 	mov.w	r9, r1, lsl #2
 80096ba:	eb00 0881 	add.w	r8, r0, r1, lsl #2
 80096be:	d010      	beq.n	80096e2 <mark_set_index+0x52>
    diff |= 1;
 80096c0:	f04c 0c01 	orr.w	ip, ip, #1
 80096c4:	f8ae c000 	strh.w	ip, [lr]
  if ((diff & 3) && i > 0)
  {                                                                // one of points for trace line change (only for > 0 index)
    mark_line(last_erase.x, last_erase.y, index[i].x, index[i].y); // mark old line for erase
 80096c8:	f8df a058 	ldr.w	sl, [pc, #88]	@ 8009724 <mark_set_index+0x94>
  if ((diff & 3) && i > 0)
 80096cc:	b99c      	cbnz	r4, 80096f6 <mark_set_index+0x66>
    mark_line(index[i - 1].x, index[i - 1].y, x, y);               // mark new line for draw
  }
  last_erase = index[i];
 80096ce:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 80096d2:	f8ca 3000 	str.w	r3, [sl]
  index[i].x = x;
 80096d6:	f825 6024 	strh.w	r6, [r5, r4, lsl #2]
  index[i].y = y;
 80096da:	f8a8 7002 	strh.w	r7, [r8, #2]
}
 80096de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (index[i].x != x || index[i].y != y)
 80096e2:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 80096e6:	42bb      	cmp	r3, r7
 80096e8:	d1ea      	bne.n	80096c0 <mark_set_index+0x30>
  if ((diff & 3) && i > 0)
 80096ea:	f01c 0f02 	tst.w	ip, #2
 80096ee:	d1eb      	bne.n	80096c8 <mark_set_index+0x38>
 80096f0:	f8df a030 	ldr.w	sl, [pc, #48]	@ 8009724 <mark_set_index+0x94>
 80096f4:	e7eb      	b.n	80096ce <mark_set_index+0x3e>
    mark_line(last_erase.x, last_erase.y, index[i].x, index[i].y); // mark old line for erase
 80096f6:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 80096fa:	f8ba 1002 	ldrh.w	r1, [sl, #2]
 80096fe:	f8ba 0000 	ldrh.w	r0, [sl]
    mark_line(index[i - 1].x, index[i - 1].y, x, y);               // mark new line for draw
 8009702:	f1a9 0904 	sub.w	r9, r9, #4
    mark_line(last_erase.x, last_erase.y, index[i].x, index[i].y); // mark old line for erase
 8009706:	f7ff ff87 	bl	8009618 <mark_line>
    mark_line(index[i - 1].x, index[i - 1].y, x, y);               // mark new line for draw
 800970a:	eb05 0309 	add.w	r3, r5, r9
 800970e:	f835 0009 	ldrh.w	r0, [r5, r9]
 8009712:	8859      	ldrh	r1, [r3, #2]
 8009714:	4632      	mov	r2, r6
 8009716:	463b      	mov	r3, r7
 8009718:	f7ff ff7e 	bl	8009618 <mark_line>
 800971c:	e7d7      	b.n	80096ce <mark_set_index+0x3e>
 800971e:	bf00      	nop
 8009720:	200069ac 	.word	0x200069ac
 8009724:	200069a8 	.word	0x200069a8

08009728 <invalidate_rect_func>:
/*
 * Force region of screen update
 */
static void invalidate_rect_func(int x0, int y0, int x1, int y1)
{
  uint32_t mask = ((1 << (x1 - x0 + 1)) - 1) << x0;
 8009728:	1a12      	subs	r2, r2, r0
 800972a:	3201      	adds	r2, #1
 800972c:	f04f 0c01 	mov.w	ip, #1
 8009730:	fa0c fc02 	lsl.w	ip, ip, r2
 8009734:	f10c 3cff 	add.w	ip, ip, #4294967295
  for (; y0 <= y1; y0++)
 8009738:	4299      	cmp	r1, r3
  uint32_t mask = ((1 << (x1 - x0 + 1)) - 1) << x0;
 800973a:	fa0c fc00 	lsl.w	ip, ip, r0
  for (; y0 <= y1; y0++)
 800973e:	dc0f      	bgt.n	8009760 <invalidate_rect_func+0x38>
 8009740:	4a08      	ldr	r2, [pc, #32]	@ (8009764 <invalidate_rect_func+0x3c>)
 8009742:	3301      	adds	r3, #1
 8009744:	eb02 0241 	add.w	r2, r2, r1, lsl #1
    if ((uint32_t)y0 < MAX_MARKMAP_Y)
 8009748:	2909      	cmp	r1, #9
  for (; y0 <= y1; y0++)
 800974a:	f101 0101 	add.w	r1, r1, #1
    if ((uint32_t)y0 < MAX_MARKMAP_Y)
 800974e:	dc03      	bgt.n	8009758 <invalidate_rect_func+0x30>
      markmap[y0] |= mask;
 8009750:	8810      	ldrh	r0, [r2, #0]
 8009752:	ea4c 0000 	orr.w	r0, ip, r0
 8009756:	8010      	strh	r0, [r2, #0]
  for (; y0 <= y1; y0++)
 8009758:	4299      	cmp	r1, r3
 800975a:	f102 0202 	add.w	r2, r2, #2
 800975e:	d1f3      	bne.n	8009748 <invalidate_rect_func+0x20>
}
 8009760:	4770      	bx	lr
 8009762:	bf00      	nop
 8009764:	20008990 	.word	0x20008990

08009768 <real>:
//**************************************************************************************
static float real(int i, const float *v)
{
  (void)i;
  return v[0];
}
 8009768:	ed91 0a00 	vldr	s0, [r1]
 800976c:	4770      	bx	lr
 800976e:	bf00      	nop

08009770 <imag>:
//**************************************************************************************
static float imag(int i, const float *v)
{
  (void)i;
  return v[1];
}
 8009770:	ed91 0a01 	vldr	s0, [r1, #4]
 8009774:	4770      	bx	lr
 8009776:	bf00      	nop

08009778 <resistance>:
// Z phase = atan(X, R)
//**************************************************************************************
static float resistance(int i, const float *v)
{
  (void)i;
  return get_s11_r(1.0f - v[0], -v[1], PORT_Z);
 8009778:	edd1 6a00 	vldr	s13, [r1]
 800977c:	ed91 7a01 	vldr	s14, [r1, #4]
 8009780:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8009784:	ee77 7ae6 	vsub.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 8009788:	ee27 7a07 	vmul.f32	s14, s14, s14
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800978c:	eddf 6a07 	vldr	s13, [pc, #28]	@ 80097ac <resistance+0x34>
static float get_l(float re, float im) { return (re * re + im * im); }
 8009790:	eea7 7aa7 	vfma.f32	s14, s15, s15
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 8009794:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8009798:	eddf 6a05 	vldr	s13, [pc, #20]	@ 80097b0 <resistance+0x38>
 800979c:	ee87 0a87 	vdiv.f32	s0, s15, s14
 80097a0:	ee30 0a66 	vsub.f32	s0, s0, s13
 80097a4:	eeb0 0ac0 	vabs.f32	s0, s0
}
 80097a8:	4770      	bx	lr
 80097aa:	bf00      	nop
 80097ac:	42c80000 	.word	0x42c80000
 80097b0:	42480000 	.word	0x42480000

080097b4 <time_of_index>:
}

static float time_of_index(int idx)
{
  freq_t span = get_sweep_frequency(ST_SPAN);
  return (idx * (sweep_points - 1)) / ((float)FFT_SIZE * span);
 80097b4:	4909      	ldr	r1, [pc, #36]	@ (80097dc <time_of_index+0x28>)
 80097b6:	8b4b      	ldrh	r3, [r1, #26]
    case ST_SPAN:   return frequency1 - frequency0;
 80097b8:	e9d1 1201 	ldrd	r1, r2, [r1, #4]
 80097bc:	3b01      	subs	r3, #1
 80097be:	fb00 f303 	mul.w	r3, r0, r3
 80097c2:	1a52      	subs	r2, r2, r1
 80097c4:	ee00 2a10 	vmov	s0, r2
 80097c8:	ee07 3a90 	vmov	s15, r3
 80097cc:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 80097d0:	eefa 7aeb 	vcvt.f32.s32	s15, s15, #9
}
 80097d4:	ee87 0a80 	vdiv.f32	s0, s15, s0
 80097d8:	4770      	bx	lr
 80097da:	bf00      	nop
 80097dc:	20000aa8 	.word	0x20000aa8

080097e0 <distance_of_index>:

static float distance_of_index(int idx)
{
 80097e0:	b508      	push	{r3, lr}
  return velocity_factor * (SPEED_OF_LIGHT / 200.0f) * time_of_index(idx);
 80097e2:	f7ff ffe7 	bl	80097b4 <time_of_index>
 80097e6:	4b07      	ldr	r3, [pc, #28]	@ (8009804 <distance_of_index+0x24>)
 80097e8:	ed9f 7a07 	vldr	s14, [pc, #28]	@ 8009808 <distance_of_index+0x28>
 80097ec:	f893 3099 	ldrb.w	r3, [r3, #153]	@ 0x99
 80097f0:	ee07 3a90 	vmov	s15, r3
 80097f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80097f8:	ee67 7a87 	vmul.f32	s15, s15, s14
}
 80097fc:	ee27 0a80 	vmul.f32	s0, s15, s0
 8009800:	bd08      	pop	{r3, pc}
 8009802:	bf00      	nop
 8009804:	20000aa8 	.word	0x20000aa8
 8009808:	49b6fa92 	.word	0x49b6fa92

0800980c <_greater>:
}

//**************************************************************************************
//            Marker search functions
//**************************************************************************************
static bool _greater(int x, int y) { return x > y; }
 800980c:	4288      	cmp	r0, r1
 800980e:	bfd4      	ite	le
 8009810:	2000      	movle	r0, #0
 8009812:	2001      	movgt	r0, #1
 8009814:	4770      	bx	lr
 8009816:	bf00      	nop

08009818 <_lesser>:
static bool _lesser(int x, int y) { return x < y; }
 8009818:	4288      	cmp	r0, r1
 800981a:	bfac      	ite	ge
 800981c:	2000      	movge	r0, #0
 800981e:	2001      	movlt	r0, #1
 8009820:	4770      	bx	lr
 8009822:	bf00      	nop

08009824 <match_quadratic_equation>:
static char measure_memory[128];

// Measure math functions
// quadratic function solver
static void match_quadratic_equation(float a, float b, float c, float *x) {
  const float a_x_2 = 2.0f * a;
 8009824:	ee30 0a00 	vadd.f32	s0, s0, s0
  const float d = (b * b) - (2.0f * a_x_2 * c);
 8009828:	ee31 1a01 	vadd.f32	s2, s2, s2
  if (d < 0){
 800982c:	2300      	movs	r3, #0
  const float d = (b * b) - (2.0f * a_x_2 * c);
 800982e:	ee20 1a41 	vnmul.f32	s2, s0, s2
 8009832:	eea0 1aa0 	vfma.f32	s2, s1, s1
  if (d < 0){
 8009836:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 800983a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800983e:	d502      	bpl.n	8009846 <match_quadratic_equation+0x22>
    x[0] = x[1] = 0.0f;
 8009840:	6043      	str	r3, [r0, #4]
 8009842:	6003      	str	r3, [r0, #0]
    return;
 8009844:	4770      	bx	lr
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 8009846:	eeb1 1ac1 	vsqrt.f32	s2, s2
  }
  const float sd = vna_sqrtf(d);
  x[0] = (-b + sd) / a_x_2;
 800984a:	ee31 7a60 	vsub.f32	s14, s2, s1
  x[1] = (-b - sd) / a_x_2;
 800984e:	ee70 0a81 	vadd.f32	s1, s1, s2
  x[0] = (-b + sd) / a_x_2;
 8009852:	eec7 7a00 	vdiv.f32	s15, s14, s0
  x[1] = (-b - sd) / a_x_2;
 8009856:	eef1 0a60 	vneg.f32	s1, s1
  x[0] = (-b + sd) / a_x_2;
 800985a:	edc0 7a00 	vstr	s15, [r0]
  x[1] = (-b - sd) / a_x_2;
 800985e:	eec0 7a80 	vdiv.f32	s15, s1, s0
 8009862:	edc0 7a01 	vstr	s15, [r0, #4]
}
 8009866:	4770      	bx	lr

08009868 <_greaterf>:
}

// Peak search, use bilinear interpolation for peak detect
#define MEASURE_SEARCH_MIN 0
#define MEASURE_SEARCH_MAX 1
static bool _greaterf(float x, float y) { return x > y; }
 8009868:	eeb4 0ae0 	vcmpe.f32	s0, s1
 800986c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009870:	bfcc      	ite	gt
 8009872:	2001      	movgt	r0, #1
 8009874:	2000      	movle	r0, #0
 8009876:	4770      	bx	lr

08009878 <_lesserf>:
static bool _lesserf(float x, float y) { return x < y; }
 8009878:	eeb4 0ae0 	vcmpe.f32	s0, s1
 800987c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009880:	bf4c      	ite	mi
 8009882:	2001      	movmi	r0, #1
 8009884:	2000      	movpl	r0, #0
 8009886:	4770      	bx	lr

08009888 <s21pow2>:
//  float tan45;
} s21_analysis_t;
static s21_analysis_t *s21_measure = (s21_analysis_t *)measure_memory;

static float s21pow2(uint16_t i) {
  const float re = measured[1][i][0]; // S21 real
 8009888:	4b08      	ldr	r3, [pc, #32]	@ (80098ac <s21pow2+0x24>)
 800988a:	f200 1291 	addw	r2, r0, #401	@ 0x191
 800988e:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  const float im = measured[1][i][1]; // S21 imaginary
 8009892:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 8009896:	f603 438c 	addw	r3, r3, #3212	@ 0xc8c
 800989a:	ed93 0a00 	vldr	s0, [r3]
  const float re = measured[1][i][0]; // S21 real
 800989e:	edd2 7a00 	vldr	s15, [r2]
  return re*re+im*im; // S21^2
 80098a2:	ee20 0a00 	vmul.f32	s0, s0, s0
}
 80098a6:	eea7 0aa7 	vfma.f32	s0, s15, s15
 80098aa:	4770      	bx	lr
 80098ac:	20004f54 	.word	0x20004f54

080098b0 <s21tan>:

static float s21tan(uint16_t i) {
  const float re = measured[1][i][0]; // S21 real
  const float im = measured[1][i][1]; // S21 imaginary
 80098b0:	4b07      	ldr	r3, [pc, #28]	@ (80098d0 <s21tan+0x20>)
 80098b2:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
  const float re = measured[1][i][0]; // S21 real
 80098b6:	f200 1091 	addw	r0, r0, #401	@ 0x191
  const float im = measured[1][i][1]; // S21 imaginary
 80098ba:	f602 428c 	addw	r2, r2, #3212	@ 0xc8c
  const float re = measured[1][i][0]; // S21 real
 80098be:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
  return im/re; // tan(S21)
 80098c2:	ed92 0a00 	vldr	s0, [r2]
 80098c6:	edd3 7a00 	vldr	s15, [r3]
}
 80098ca:	ee80 0a27 	vdiv.f32	s0, s0, s15
 80098ce:	4770      	bx	lr
 80098d0:	20004f54 	.word	0x20004f54

080098d4 <s11imag>:
} s11_cable_measure_t;
static s11_cable_measure_t *s11_cable = (s11_cable_measure_t *)measure_memory;
float real_cable_len = 0.0f;

static float s11imag(uint16_t i) {
  return measured[0][i][1];
 80098d4:	4b02      	ldr	r3, [pc, #8]	@ (80098e0 <s11imag+0xc>)
 80098d6:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
}
 80098da:	ed93 0a01 	vldr	s0, [r3, #4]
 80098de:	4770      	bx	lr
 80098e0:	20004f54 	.word	0x20004f54

080098e4 <cell_string_width>:
}

static int cell_string_width(const char *str)
{
  int w = 0;
  while (*str)
 80098e4:	7803      	ldrb	r3, [r0, #0]
 80098e6:	b1ab      	cbz	r3, 8009914 <cell_string_width+0x30>
{
 80098e8:	b410      	push	{r4}
 80098ea:	4c0b      	ldr	r4, [pc, #44]	@ (8009918 <cell_string_width+0x34>)
 80098ec:	4601      	mov	r1, r0
  int w = 0;
 80098ee:	2000      	movs	r0, #0
    w += FONT_GET_WIDTH((uint8_t)*str++);
 80098f0:	3b16      	subs	r3, #22
 80098f2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80098f6:	eb03 0242 	add.w	r2, r3, r2, lsl #1
  while (*str)
 80098fa:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    w += FONT_GET_WIDTH((uint8_t)*str++);
 80098fe:	5ca2      	ldrb	r2, [r4, r2]
 8009900:	f002 0207 	and.w	r2, r2, #7
 8009904:	f1c2 0208 	rsb	r2, r2, #8
 8009908:	4410      	add	r0, r2
  while (*str)
 800990a:	2b00      	cmp	r3, #0
 800990c:	d1f0      	bne.n	80098f0 <cell_string_width+0xc>
  return w;
}
 800990e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009912:	4770      	bx	lr
  int w = 0;
 8009914:	4618      	mov	r0, r3
}
 8009916:	4770      	bx	lr
 8009918:	0801356c 	.word	0x0801356c

0800991c <cell_drawstring_big>:
    }
  }
}

static void cell_drawstring_big(const char *str, int x, int y)
{
 800991c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009920:	4603      	mov	r3, r0
 8009922:	b08d      	sub	sp, #52	@ 0x34
  while (*str)
 8009924:	7800      	ldrb	r0, [r0, #0]
{
 8009926:	920b      	str	r2, [sp, #44]	@ 0x2c
  while (*str)
 8009928:	2800      	cmp	r0, #0
 800992a:	f000 8095 	beq.w	8009a58 <cell_drawstring_big+0x13c>
 800992e:	461f      	mov	r7, r3
        cell_buffer[py * CELLWIDTH + px] = foreground_color;
 8009930:	4b56      	ldr	r3, [pc, #344]	@ (8009a8c <cell_drawstring_big+0x170>)
 8009932:	f8df a160 	ldr.w	sl, [pc, #352]	@ 8009a94 <cell_drawstring_big+0x178>
 8009936:	681c      	ldr	r4, [r3, #0]
 8009938:	9401      	str	r4, [sp, #4]
 800993a:	4613      	mov	r3, r2
 800993c:	3301      	adds	r3, #1
 800993e:	9309      	str	r3, [sp, #36]	@ 0x24
 8009940:	015b      	lsls	r3, r3, #5
 8009942:	f1a3 0220 	sub.w	r2, r3, #32
 8009946:	f503 7930 	add.w	r9, r3, #704	@ 0x2c0
 800994a:	9308      	str	r3, [sp, #32]
 800994c:	f1c4 0340 	rsb	r3, r4, #64	@ 0x40
 8009950:	9303      	str	r3, [sp, #12]
 8009952:	920a      	str	r2, [sp, #40]	@ 0x28
      const uint8_t mask = (uint8_t)(0x80u >> (xx & 7u));
 8009954:	f04f 0b80 	mov.w	fp, #128	@ 0x80
 8009958:	4603      	mov	r3, r0
 800995a:	f8cd 9010 	str.w	r9, [sp, #16]
  const uint16_t w = FONT_GET_WIDTH(ch);
 800995e:	3b16      	subs	r3, #22
 8009960:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8009964:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8009968:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 800996a:	9801      	ldr	r0, [sp, #4]
  const uint8_t *bmp = FONT_GET_DATA(ch);
 800996c:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 800996e:	440a      	add	r2, r1
 8009970:	eb00 0842 	add.w	r8, r0, r2, lsl #1
 8009974:	4846      	ldr	r0, [pc, #280]	@ (8009a90 <cell_drawstring_big+0x174>)
 8009976:	5cc2      	ldrb	r2, [r0, r3]
 8009978:	e9dd c608 	ldrd	ip, r6, [sp, #32]
 800997c:	f002 0207 	and.w	r2, r2, #7
 8009980:	e9cd 7105 	strd	r7, r1, [sp, #20]
  const uint16_t w = FONT_GET_WIDTH(ch);
 8009984:	f1c2 0208 	rsb	r2, r2, #8
 8009988:	f101 0e01 	add.w	lr, r1, #1
  const uint8_t *bmp = FONT_GET_DATA(ch);
 800998c:	4418      	add	r0, r3
  const uint16_t w = FONT_GET_WIDTH(ch);
 800998e:	b294      	uxth	r4, r2
  for (uint16_t yy = 0; yy < h; yy++)
 8009990:	46e1      	mov	r9, ip
 8009992:	f8cd e008 	str.w	lr, [sp, #8]
 8009996:	9207      	str	r2, [sp, #28]
    for (uint16_t xx = 0; xx < w; xx++)
 8009998:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  const uint8_t *bmp = FONT_GET_DATA(ch);
 800999c:	9600      	str	r6, [sp, #0]
 800999e:	eb03 0108 	add.w	r1, r3, r8
 80099a2:	2300      	movs	r3, #0
 80099a4:	e018      	b.n	80099d8 <cell_drawstring_big+0xbc>
      if ((unsigned)px < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 80099a6:	2d1f      	cmp	r5, #31
 80099a8:	d959      	bls.n	8009a5e <cell_drawstring_big+0x142>
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 80099aa:	2a20      	cmp	r2, #32
 80099ac:	d02f      	beq.n	8009a0e <cell_drawstring_big+0xf2>
      if ((unsigned)px < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 80099ae:	9e00      	ldr	r6, [sp, #0]
 80099b0:	2e1f      	cmp	r6, #31
 80099b2:	d80a      	bhi.n	80099ca <cell_drawstring_big+0xae>
        cell_buffer[(py + 1) * CELLWIDTH + px] = foreground_color;
 80099b4:	9e01      	ldr	r6, [sp, #4]
 80099b6:	f8ba 7000 	ldrh.w	r7, [sl]
 80099ba:	5277      	strh	r7, [r6, r1]
 80099bc:	4657      	mov	r7, sl
        cell_buffer[(py + 1) * CELLWIDTH + (px + 1)] = foreground_color;
 80099be:	eb09 0c02 	add.w	ip, r9, r2
 80099c2:	9e01      	ldr	r6, [sp, #4]
 80099c4:	883f      	ldrh	r7, [r7, #0]
 80099c6:	f826 701c 	strh.w	r7, [r6, ip, lsl #1]
    for (uint16_t xx = 0; xx < w; xx++)
 80099ca:	3301      	adds	r3, #1
 80099cc:	42a3      	cmp	r3, r4
 80099ce:	f102 0202 	add.w	r2, r2, #2
 80099d2:	f101 0104 	add.w	r1, r1, #4
 80099d6:	d028      	beq.n	8009a2a <cell_drawstring_big+0x10e>
      if ((row[xx >> 3] & mask) == 0)
 80099d8:	7807      	ldrb	r7, [r0, #0]
      const uint8_t mask = (uint8_t)(0x80u >> (xx & 7u));
 80099da:	fa2b fc03 	lsr.w	ip, fp, r3
      if ((row[xx >> 3] & mask) == 0)
 80099de:	ea1c 0f07 	tst.w	ip, r7
 80099e2:	d0f2      	beq.n	80099ca <cell_drawstring_big+0xae>
      if ((unsigned)px < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 80099e4:	1e57      	subs	r7, r2, #1
 80099e6:	2f1f      	cmp	r7, #31
 80099e8:	d9dd      	bls.n	80099a6 <cell_drawstring_big+0x8a>
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 80099ea:	2a1f      	cmp	r2, #31
 80099ec:	d8ed      	bhi.n	80099ca <cell_drawstring_big+0xae>
 80099ee:	2d1f      	cmp	r5, #31
 80099f0:	d807      	bhi.n	8009a02 <cell_drawstring_big+0xe6>
        cell_buffer[py * CELLWIDTH + (px + 1)] = foreground_color;
 80099f2:	4e26      	ldr	r6, [pc, #152]	@ (8009a8c <cell_drawstring_big+0x170>)
 80099f4:	f8ba e000 	ldrh.w	lr, [sl]
 80099f8:	6837      	ldr	r7, [r6, #0]
 80099fa:	ea4f 1c85 	mov.w	ip, r5, lsl #6
 80099fe:	f827 e00c 	strh.w	lr, [r7, ip]
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 8009a02:	9e00      	ldr	r6, [sp, #0]
 8009a04:	2e1f      	cmp	r6, #31
 8009a06:	d8e0      	bhi.n	80099ca <cell_drawstring_big+0xae>
 8009a08:	46cc      	mov	ip, r9
 8009a0a:	4657      	mov	r7, sl
 8009a0c:	e7d9      	b.n	80099c2 <cell_drawstring_big+0xa6>
      if ((unsigned)px < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 8009a0e:	9e00      	ldr	r6, [sp, #0]
 8009a10:	2e1f      	cmp	r6, #31
 8009a12:	d8da      	bhi.n	80099ca <cell_drawstring_big+0xae>
        cell_buffer[(py + 1) * CELLWIDTH + px] = foreground_color;
 8009a14:	9e01      	ldr	r6, [sp, #4]
 8009a16:	f8ba 7000 	ldrh.w	r7, [sl]
 8009a1a:	5277      	strh	r7, [r6, r1]
    for (uint16_t xx = 0; xx < w; xx++)
 8009a1c:	3301      	adds	r3, #1
 8009a1e:	42a3      	cmp	r3, r4
 8009a20:	f102 0202 	add.w	r2, r2, #2
 8009a24:	f101 0104 	add.w	r1, r1, #4
 8009a28:	d1d6      	bne.n	80099d8 <cell_drawstring_big+0xbc>
  for (uint16_t yy = 0; yy < h; yy++)
 8009a2a:	9b04      	ldr	r3, [sp, #16]
 8009a2c:	9e00      	ldr	r6, [sp, #0]
 8009a2e:	f109 0940 	add.w	r9, r9, #64	@ 0x40
 8009a32:	4599      	cmp	r9, r3
 8009a34:	f106 0602 	add.w	r6, r6, #2
 8009a38:	f105 0502 	add.w	r5, r5, #2
 8009a3c:	f108 0880 	add.w	r8, r8, #128	@ 0x80
 8009a40:	f100 0001 	add.w	r0, r0, #1
 8009a44:	d1a8      	bne.n	8009998 <cell_drawstring_big+0x7c>
  {
    const uint8_t ch = (uint8_t)*str++;
    cell_drawchar_big(ch, x, y);
    x += (int)(FONT_GET_WIDTH(ch) * 2u);
 8009a46:	e9dd 7105 	ldrd	r7, r1, [sp, #20]
 8009a4a:	9a07      	ldr	r2, [sp, #28]
  while (*str)
 8009a4c:	f817 3f01 	ldrb.w	r3, [r7, #1]!
    x += (int)(FONT_GET_WIDTH(ch) * 2u);
 8009a50:	eb01 0142 	add.w	r1, r1, r2, lsl #1
  while (*str)
 8009a54:	2b00      	cmp	r3, #0
 8009a56:	d182      	bne.n	800995e <cell_drawstring_big+0x42>
  }
}
 8009a58:	b00d      	add	sp, #52	@ 0x34
 8009a5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cell_buffer[py * CELLWIDTH + px] = foreground_color;
 8009a5e:	f8ba c000 	ldrh.w	ip, [sl]
 8009a62:	f828 c023 	strh.w	ip, [r8, r3, lsl #2]
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 8009a66:	2a20      	cmp	r2, #32
        cell_buffer[py * CELLWIDTH + px] = foreground_color;
 8009a68:	4657      	mov	r7, sl
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 8009a6a:	d0d0      	beq.n	8009a0e <cell_drawstring_big+0xf2>
        cell_buffer[py * CELLWIDTH + (px + 1)] = foreground_color;
 8009a6c:	4e07      	ldr	r6, [pc, #28]	@ (8009a8c <cell_drawstring_big+0x170>)
 8009a6e:	f8d6 e000 	ldr.w	lr, [r6]
 8009a72:	eb0e 0601 	add.w	r6, lr, r1
 8009a76:	f826 cc3e 	strh.w	ip, [r6, #-62]
      if ((unsigned)px < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 8009a7a:	9e00      	ldr	r6, [sp, #0]
 8009a7c:	2e1f      	cmp	r6, #31
 8009a7e:	d8a4      	bhi.n	80099ca <cell_drawstring_big+0xae>
        cell_buffer[(py + 1) * CELLWIDTH + px] = foreground_color;
 8009a80:	f8ba c000 	ldrh.w	ip, [sl]
 8009a84:	f82e c001 	strh.w	ip, [lr, r1]
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 8009a88:	e799      	b.n	80099be <cell_drawstring_big+0xa2>
 8009a8a:	bf00      	nop
 8009a8c:	200089a4 	.word	0x200089a4
 8009a90:	0801356c 	.word	0x0801356c
 8009a94:	200089f2 	.word	0x200089f2

08009a98 <groupdelay_from_array>:
{
 8009a98:	b510      	push	{r4, lr}
  int top = (i == sweep_points - 1) ? 0 : 1; // get next point
 8009a9a:	4c1b      	ldr	r4, [pc, #108]	@ (8009b08 <groupdelay_from_array+0x70>)
 8009a9c:	8b63      	ldrh	r3, [r4, #26]
 8009a9e:	3b01      	subs	r3, #1
 8009aa0:	1a1a      	subs	r2, r3, r0
 8009aa2:	bf18      	it	ne
 8009aa4:	2201      	movne	r2, #1
  int bottom = (i == 0) ? 0 : -1;            // get prev point
 8009aa6:	2800      	cmp	r0, #0
 8009aa8:	bf14      	ite	ne
 8009aaa:	2001      	movne	r0, #1
 8009aac:	2000      	moveq	r0, #0
  freq_t deltaf = get_sweep_frequency(ST_SPAN) / ((sweep_points - 1) / (top - bottom));
 8009aae:	4410      	add	r0, r2
  return groupdelay(&v[2 * bottom], &v[2 * top], deltaf);
 8009ab0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  float r = w[0] * v[0] + w[1] * v[1];
 8009ab4:	ed92 7a00 	vldr	s14, [r2]
 8009ab8:	edd2 0a01 	vldr	s1, [r2, #4]
  freq_t deltaf = get_sweep_frequency(ST_SPAN) / ((sweep_points - 1) / (top - bottom));
 8009abc:	fb93 f2f0 	sdiv	r2, r3, r0
  return groupdelay(&v[2 * bottom], &v[2 * top], deltaf);
 8009ac0:	bf14      	ite	ne
 8009ac2:	f06f 0307 	mvnne.w	r3, #7
 8009ac6:	2300      	moveq	r3, #0
 8009ac8:	4419      	add	r1, r3
  float r = w[0] * v[0] + w[1] * v[1];
 8009aca:	edd1 7a00 	vldr	s15, [r1]
 8009ace:	edd1 6a01 	vldr	s13, [r1, #4]
  float i = w[0] * v[1] - w[1] * v[0];
 8009ad2:	ee20 0ae7 	vnmul.f32	s0, s1, s15
 8009ad6:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
  float r = w[0] * v[0] + w[1] * v[1];
 8009ada:	ee60 0aa6 	vmul.f32	s1, s1, s13
  return vna_atan2f(i, r) / (2 * VNA_PI * deltaf);
 8009ade:	eea7 0a26 	vfma.f32	s0, s14, s13
 8009ae2:	1a5b      	subs	r3, r3, r1
  freq_t deltaf = get_sweep_frequency(ST_SPAN) / ((sweep_points - 1) / (top - bottom));
 8009ae4:	fbb3 f4f2 	udiv	r4, r3, r2
  return vna_atan2f(i, r) / (2 * VNA_PI * deltaf);
 8009ae8:	eee7 0a27 	vfma.f32	s1, s14, s15
 8009aec:	f007 fc7e 	bl	80113ec <vna_atan2f>
 8009af0:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 8009b0c <groupdelay_from_array+0x74>
 8009af4:	ee07 4a90 	vmov	s15, r4
 8009af8:	ee20 0a07 	vmul.f32	s0, s0, s14
 8009afc:	eef8 7a67 	vcvt.f32.u32	s15, s15
}
 8009b00:	ee80 0a27 	vdiv.f32	s0, s0, s15
 8009b04:	bd10      	pop	{r4, pc}
 8009b06:	bf00      	nop
 8009b08:	20000aa8 	.word	0x20000aa8
 8009b0c:	3e22f983 	.word	0x3e22f983

08009b10 <phase>:
{
 8009b10:	b508      	push	{r3, lr}
  return (180.0f / VNA_PI) * vna_atan2f(v[1], v[0]);
 8009b12:	edd1 0a00 	vldr	s1, [r1]
 8009b16:	ed91 0a01 	vldr	s0, [r1, #4]
 8009b1a:	f007 fc67 	bl	80113ec <vna_atan2f>
 8009b1e:	eddf 7a02 	vldr	s15, [pc, #8]	@ 8009b28 <phase+0x18>
}
 8009b22:	ee20 0a27 	vmul.f32	s0, s0, s15
 8009b26:	bd08      	pop	{r3, pc}
 8009b28:	42652ee0 	.word	0x42652ee0

08009b2c <get_w>:
static float get_w(int i) { return 2 * VNA_PI * getFrequency(i); }
 8009b2c:	b508      	push	{r3, lr}
 8009b2e:	b280      	uxth	r0, r0
 8009b30:	f7fc fd44 	bl	80065bc <getFrequency>
 8009b34:	ee07 0a90 	vmov	s15, r0
 8009b38:	ed9f 0a03 	vldr	s0, [pc, #12]	@ 8009b48 <get_w+0x1c>
 8009b3c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8009b40:	ee27 0a80 	vmul.f32	s0, s15, s0
 8009b44:	bd08      	pop	{r3, pc}
 8009b46:	bf00      	nop
 8009b48:	40c90fdb 	.word	0x40c90fdb

08009b4c <s11index>:

static float s11loss(uint16_t i) {
  return -0.5f * logmag(i, measured[0][i]);
}

static float s11index(uint16_t i) {
 8009b4c:	b508      	push	{r3, lr}
  return vna_sqrtf(getFrequency(i) * 1e-9f);
 8009b4e:	f7fc fd35 	bl	80065bc <getFrequency>
 8009b52:	ee00 0a10 	vmov	s0, r0
 8009b56:	eddf 7a04 	vldr	s15, [pc, #16]	@ 8009b68 <s11index+0x1c>
 8009b5a:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 8009b5e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8009b62:	eeb1 0ac0 	vsqrt.f32	s0, s0
}
 8009b66:	bd08      	pop	{r3, pc}
 8009b68:	3089705f 	.word	0x3089705f

08009b6c <measure_search_value>:
static float measure_search_value(uint16_t *idx, float y, get_value_t get, int16_t mode, int16_t marker_idx) {
 8009b6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009b70:	ed2d 8b04 	vpush	{d8-d9}
  uint16_t x = *idx;
 8009b74:	8804      	ldrh	r4, [r0, #0]
  for(; x < sweep_points; x+=mode) {
 8009b76:	f8df 90f0 	ldr.w	r9, [pc, #240]	@ 8009c68 <measure_search_value+0xfc>
static float measure_search_value(uint16_t *idx, float y, get_value_t get, int16_t mode, int16_t marker_idx) {
 8009b7a:	b082      	sub	sp, #8
 8009b7c:	4606      	mov	r6, r0
  y1 = y2 = y3 = get(x);
 8009b7e:	4620      	mov	r0, r4
static float measure_search_value(uint16_t *idx, float y, get_value_t get, int16_t mode, int16_t marker_idx) {
 8009b80:	eeb0 9a40 	vmov.f32	s18, s0
 8009b84:	460f      	mov	r7, r1
 8009b86:	4615      	mov	r5, r2
 8009b88:	4698      	mov	r8, r3
  y1 = y2 = y3 = get(x);
 8009b8a:	4788      	blx	r1
  bool result = (y3 > y); // current position depend from start point
 8009b8c:	eeb4 0ac9 	vcmpe.f32	s0, s18
 8009b90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  y1 = y2 = y3 = get(x);
 8009b94:	eef0 8a40 	vmov.f32	s17, s0
  bool result = (y3 > y); // current position depend from start point
 8009b98:	bfcc      	ite	gt
 8009b9a:	f04f 0a01 	movgt.w	sl, #1
 8009b9e:	f04f 0a00 	movle.w	sl, #0
  y1 = y2 = y3 = get(x);
 8009ba2:	eef0 9a40 	vmov.f32	s19, s0
  for(; x < sweep_points; x+=mode) {
 8009ba6:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 8009baa:	42a3      	cmp	r3, r4
 8009bac:	d917      	bls.n	8009bde <measure_search_value+0x72>
    y3 = get(x);
 8009bae:	4620      	mov	r0, r4
 8009bb0:	47b8      	blx	r7
    if(result != (y3 > y)) break;
 8009bb2:	eeb4 9ac0 	vcmpe.f32	s18, s0
 8009bb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009bba:	bf4c      	ite	mi
 8009bbc:	2301      	movmi	r3, #1
 8009bbe:	2300      	movpl	r3, #0
 8009bc0:	4553      	cmp	r3, sl
    y3 = get(x);
 8009bc2:	eeb0 8a40 	vmov.f32	s16, s0
    if(result != (y3 > y)) break;
 8009bc6:	d106      	bne.n	8009bd6 <measure_search_value+0x6a>
  for(; x < sweep_points; x+=mode) {
 8009bc8:	442c      	add	r4, r5
    y1 = y2;
 8009bca:	eef0 8a69 	vmov.f32	s17, s19
  for(; x < sweep_points; x+=mode) {
 8009bce:	b2a4      	uxth	r4, r4
    y2 = y3;
 8009bd0:	eef0 9a40 	vmov.f32	s19, s0
 8009bd4:	e7e7      	b.n	8009ba6 <measure_search_value+0x3a>
  if (x >= sweep_points) return 0;
 8009bd6:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 8009bda:	42a3      	cmp	r3, r4
 8009bdc:	d802      	bhi.n	8009be4 <measure_search_value+0x78>
 8009bde:	ed9f 0a21 	vldr	s0, [pc, #132]	@ 8009c64 <measure_search_value+0xf8>
 8009be2:	e03a      	b.n	8009c5a <measure_search_value+0xee>
  x-=mode;
 8009be4:	1b64      	subs	r4, r4, r5
 8009be6:	b2a4      	uxth	r4, r4
  set_marker_index(marker_idx, x);
 8009be8:	4640      	mov	r0, r8
  *idx = x;
 8009bea:	8034      	strh	r4, [r6, #0]
  set_marker_index(marker_idx, x);
 8009bec:	4621      	mov	r1, r4
 8009bee:	f7fd f9cd 	bl	8006f8c <set_marker_index>
  const float a = 0.5f * (y1 + y3) - y2;
 8009bf2:	ee38 7a88 	vadd.f32	s14, s17, s16
  const float b = 0.5f * (y3 - y1);
 8009bf6:	ee78 0a68 	vsub.f32	s1, s16, s17
  const float a = 0.5f * (y1 + y3) - y2;
 8009bfa:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
  match_quadratic_equation(a, b, c, r);
 8009bfe:	eeb0 0a69 	vmov.f32	s0, s19
 8009c02:	ee97 0a27 	vfnms.f32	s0, s14, s15
 8009c06:	4668      	mov	r0, sp
 8009c08:	ee39 1ac9 	vsub.f32	s2, s19, s18
 8009c0c:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8009c10:	f7ff fe08 	bl	8009824 <match_quadratic_equation>
  float res = (r[0] > 0 && r[0] < 1.0) ? r[0] : r[1];
 8009c14:	eddd 8a00 	vldr	s17, [sp]
 8009c18:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 8009c1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009c20:	dd06      	ble.n	8009c30 <measure_search_value+0xc4>
 8009c22:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8009c26:	eef4 8ae7 	vcmpe.f32	s17, s15
 8009c2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009c2e:	d401      	bmi.n	8009c34 <measure_search_value+0xc8>
 8009c30:	eddd 8a01 	vldr	s17, [sp, #4]
  if (mode < 0) res=-res;
 8009c34:	3501      	adds	r5, #1
  return getFrequency(x) + getFrequencyStep() * res;
 8009c36:	4620      	mov	r0, r4
  if (mode < 0) res=-res;
 8009c38:	bf08      	it	eq
 8009c3a:	eef1 8a68 	vnegeq.f32	s17, s17
  return getFrequency(x) + getFrequencyStep() * res;
 8009c3e:	f7fc fcbd 	bl	80065bc <getFrequency>
 8009c42:	ee08 0a10 	vmov	s16, r0
 8009c46:	f7fd f99b 	bl	8006f80 <getFrequencyStep>
 8009c4a:	ee07 0a90 	vmov	s15, r0
 8009c4e:	eeb8 0a48 	vcvt.f32.u32	s0, s16
 8009c52:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8009c56:	eea7 0aa8 	vfma.f32	s0, s15, s17
}
 8009c5a:	b002      	add	sp, #8
 8009c5c:	ecbd 8b04 	vpop	{d8-d9}
 8009c60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8009c64:	00000000 	.word	0x00000000
 8009c68:	20000aa8 	.word	0x20000aa8

08009c6c <cell_printf>:
{
 8009c6c:	b40c      	push	{r2, r3}
 8009c6e:	b500      	push	{lr}
  if ((uint32_t)(y + FONT_GET_HEIGHT) >= CELLHEIGHT + FONT_GET_HEIGHT || x >= CELLWIDTH)
 8009c70:	f101 020b 	add.w	r2, r1, #11
 8009c74:	2a2a      	cmp	r2, #42	@ 0x2a
{
 8009c76:	b085      	sub	sp, #20
  if ((uint32_t)(y + FONT_GET_HEIGHT) >= CELLHEIGHT + FONT_GET_HEIGHT || x >= CELLWIDTH)
 8009c78:	d801      	bhi.n	8009c7e <cell_printf+0x12>
 8009c7a:	281f      	cmp	r0, #31
 8009c7c:	dd05      	ble.n	8009c8a <cell_printf+0x1e>
    return 0;
 8009c7e:	2000      	movs	r0, #0
}
 8009c80:	b005      	add	sp, #20
 8009c82:	f85d eb04 	ldr.w	lr, [sp], #4
 8009c86:	b002      	add	sp, #8
 8009c88:	4770      	bx	lr
  cellPrintStream ps = {&cell_vmt, x, y};
 8009c8a:	460b      	mov	r3, r1
 8009c8c:	4908      	ldr	r1, [pc, #32]	@ (8009cb0 <cell_printf+0x44>)
 8009c8e:	9102      	str	r1, [sp, #8]
  va_start(ap, fmt);
 8009c90:	aa07      	add	r2, sp, #28
  cellPrintStream ps = {&cell_vmt, x, y};
 8009c92:	f8ad 000c 	strh.w	r0, [sp, #12]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8009c96:	9906      	ldr	r1, [sp, #24]
  cellPrintStream ps = {&cell_vmt, x, y};
 8009c98:	f8ad 300e 	strh.w	r3, [sp, #14]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8009c9c:	a802      	add	r0, sp, #8
  va_start(ap, fmt);
 8009c9e:	9201      	str	r2, [sp, #4]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8009ca0:	f7f8 fc66 	bl	8002570 <chvprintf>
}
 8009ca4:	b005      	add	sp, #20
 8009ca6:	f85d eb04 	ldr.w	lr, [sp], #4
 8009caa:	b002      	add	sp, #8
 8009cac:	4770      	bx	lr
 8009cae:	bf00      	nop
 8009cb0:	080141d0 	.word	0x080141d0

08009cb4 <draw_s11_resonance>:

static float s11_resonance_min(uint16_t i) {
  return fabsf(reactance(i, measured[0][i]));
}

static void draw_s11_resonance(int xp, int yp) {
 8009cb4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  cell_printf(xp, yp, "S11 RESONANCE");
  if (s11_resonance->count == 0) {
 8009cb8:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 8009d3c <draw_s11_resonance+0x88>
  cell_printf(xp, yp, "S11 RESONANCE");
 8009cbc:	4a1c      	ldr	r2, [pc, #112]	@ (8009d30 <draw_s11_resonance+0x7c>)
 8009cbe:	b205      	sxth	r5, r0
static void draw_s11_resonance(int xp, int yp) {
 8009cc0:	b085      	sub	sp, #20
 8009cc2:	460c      	mov	r4, r1
  cell_printf(xp, yp, "S11 RESONANCE");
 8009cc4:	4628      	mov	r0, r5
 8009cc6:	b209      	sxth	r1, r1
 8009cc8:	f7ff ffd0 	bl	8009c6c <cell_printf>
  if (s11_resonance->count == 0) {
 8009ccc:	f898 3048 	ldrb.w	r3, [r8, #72]	@ 0x48
 8009cd0:	b113      	cbz	r3, 8009cd8 <draw_s11_resonance+0x24>
 8009cd2:	4646      	mov	r6, r8
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Not found");
    return;
  }
  for (int i = 0; i < s11_resonance->count; i++)
 8009cd4:	2700      	movs	r7, #0
 8009cd6:	e009      	b.n	8009cec <draw_s11_resonance+0x38>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Not found");
 8009cd8:	f104 010c 	add.w	r1, r4, #12
 8009cdc:	4a15      	ldr	r2, [pc, #84]	@ (8009d34 <draw_s11_resonance+0x80>)
 8009cde:	b209      	sxth	r1, r1
 8009ce0:	4628      	mov	r0, r5
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "%q" S_Hz ", %F%+jF" S_OHM, s11_resonance->data[i].f, s11_resonance->data[i].r, s11_resonance->data[i].x);
}
 8009ce2:	b005      	add	sp, #20
 8009ce4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Not found");
 8009ce8:	f7ff bfc0 	b.w	8009c6c <cell_printf>
  for (int i = 0; i < s11_resonance->count; i++)
 8009cec:	f898 3048 	ldrb.w	r3, [r8, #72]	@ 0x48
 8009cf0:	42bb      	cmp	r3, r7
 8009cf2:	f106 060c 	add.w	r6, r6, #12
 8009cf6:	dd17      	ble.n	8009d28 <draw_s11_resonance+0x74>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "%q" S_Hz ", %F%+jF" S_OHM, s11_resonance->data[i].f, s11_resonance->data[i].r, s11_resonance->data[i].x);
 8009cf8:	f856 0c04 	ldr.w	r0, [r6, #-4]
 8009cfc:	f7f6 fc50 	bl	80005a0 <__aeabi_f2d>
 8009d00:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009d04:	f856 0c08 	ldr.w	r0, [r6, #-8]
 8009d08:	f7f6 fc4a 	bl	80005a0 <__aeabi_f2d>
 8009d0c:	e9cd 0100 	strd	r0, r1, [sp]
 8009d10:	340c      	adds	r4, #12
 8009d12:	fa0f f984 	sxth.w	r9, r4
 8009d16:	f856 3c0c 	ldr.w	r3, [r6, #-12]
 8009d1a:	4a07      	ldr	r2, [pc, #28]	@ (8009d38 <draw_s11_resonance+0x84>)
 8009d1c:	4649      	mov	r1, r9
 8009d1e:	4628      	mov	r0, r5
 8009d20:	f7ff ffa4 	bl	8009c6c <cell_printf>
  for (int i = 0; i < s11_resonance->count; i++)
 8009d24:	3701      	adds	r7, #1
 8009d26:	e7e1      	b.n	8009cec <draw_s11_resonance+0x38>
}
 8009d28:	b005      	add	sp, #20
 8009d2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8009d2e:	bf00      	nop
 8009d30:	08012922 	.word	0x08012922
 8009d34:	08012930 	.word	0x08012930
 8009d38:	0801293a 	.word	0x0801293a
 8009d3c:	200069b4 	.word	0x200069b4

08009d40 <draw_s11_cable>:
static void draw_s11_cable(int xp, int yp){
 8009d40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009d44:	ed2d 8b02 	vpush	{d8}
  if (s11_cable->R){
 8009d48:	4e44      	ldr	r6, [pc, #272]	@ (8009e5c <draw_s11_cable+0x11c>)
  cell_printf(xp, yp, "S11 CABLE");
 8009d4a:	4a45      	ldr	r2, [pc, #276]	@ (8009e60 <draw_s11_cable+0x120>)
 8009d4c:	b205      	sxth	r5, r0
static void draw_s11_cable(int xp, int yp){
 8009d4e:	b084      	sub	sp, #16
 8009d50:	460c      	mov	r4, r1
  cell_printf(xp, yp, "S11 CABLE");
 8009d52:	4628      	mov	r0, r5
 8009d54:	b209      	sxth	r1, r1
 8009d56:	f7ff ff89 	bl	8009c6c <cell_printf>
  if (s11_cable->R){
 8009d5a:	edd6 7a01 	vldr	s15, [r6, #4]
 8009d5e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009d62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d66:	d00c      	beq.n	8009d82 <draw_s11_cable+0x42>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Z0 = %F" S_OHM, s11_cable->R);
 8009d68:	ee17 0a90 	vmov	r0, s15
 8009d6c:	f7f6 fc18 	bl	80005a0 <__aeabi_f2d>
 8009d70:	340c      	adds	r4, #12
 8009d72:	b227      	sxth	r7, r4
 8009d74:	e9cd 0100 	strd	r0, r1, [sp]
 8009d78:	4a3a      	ldr	r2, [pc, #232]	@ (8009e64 <draw_s11_cable+0x124>)
 8009d7a:	4639      	mov	r1, r7
 8009d7c:	4628      	mov	r0, r5
 8009d7e:	f7ff ff75 	bl	8009c6c <cell_printf>
  if (s11_cable->vf)
 8009d82:	ed96 8a05 	vldr	s16, [r6, #20]
 8009d86:	eeb5 8a40 	vcmp.f32	s16, #0.0
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "VF=%.2f%% (Length = %F" S_METRE ")", s11_cable->vf, real_cable_len);
 8009d8a:	f104 080c 	add.w	r8, r4, #12
  if (s11_cable->vf)
 8009d8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "VF=%.2f%% (Length = %F" S_METRE ")", s11_cable->vf, real_cable_len);
 8009d92:	fa0f f788 	sxth.w	r7, r8
  if (s11_cable->vf)
 8009d96:	d012      	beq.n	8009dbe <draw_s11_cable+0x7e>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "VF=%.2f%% (Length = %F" S_METRE ")", s11_cable->vf, real_cable_len);
 8009d98:	4b33      	ldr	r3, [pc, #204]	@ (8009e68 <draw_s11_cable+0x128>)
 8009d9a:	6818      	ldr	r0, [r3, #0]
 8009d9c:	f7f6 fc00 	bl	80005a0 <__aeabi_f2d>
 8009da0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009da4:	ee18 0a10 	vmov	r0, s16
 8009da8:	f7f6 fbfa 	bl	80005a0 <__aeabi_f2d>
 8009dac:	4a2f      	ldr	r2, [pc, #188]	@ (8009e6c <draw_s11_cable+0x12c>)
 8009dae:	e9cd 0100 	strd	r0, r1, [sp]
 8009db2:	4639      	mov	r1, r7
 8009db4:	4628      	mov	r0, r5
 8009db6:	f7ff ff59 	bl	8009c6c <cell_printf>
 8009dba:	4644      	mov	r4, r8
 8009dbc:	e016      	b.n	8009dec <draw_s11_cable+0xac>
  else if (s11_cable->len)
 8009dbe:	edd6 7a02 	vldr	s15, [r6, #8]
 8009dc2:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009dc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009dca:	d00f      	beq.n	8009dec <draw_s11_cable+0xac>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Length = %F" S_METRE " (VF=%d%%)", s11_cable->len, velocity_factor);
 8009dcc:	4b28      	ldr	r3, [pc, #160]	@ (8009e70 <draw_s11_cable+0x130>)
 8009dce:	ee17 0a90 	vmov	r0, s15
 8009dd2:	f893 3099 	ldrb.w	r3, [r3, #153]	@ 0x99
 8009dd6:	9302      	str	r3, [sp, #8]
 8009dd8:	f7f6 fbe2 	bl	80005a0 <__aeabi_f2d>
 8009ddc:	4a25      	ldr	r2, [pc, #148]	@ (8009e74 <draw_s11_cable+0x134>)
 8009dde:	e9cd 0100 	strd	r0, r1, [sp]
 8009de2:	4639      	mov	r1, r7
 8009de4:	4628      	mov	r0, r5
 8009de6:	f7ff ff41 	bl	8009c6c <cell_printf>
 8009dea:	e7e6      	b.n	8009dba <draw_s11_cable+0x7a>
  cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Loss = %F" S_dB " (%.4F" S_Hz ")", s11_cable->mloss, s11_cable->freq);
 8009dec:	6830      	ldr	r0, [r6, #0]
 8009dee:	f7f6 fbd7 	bl	80005a0 <__aeabi_f2d>
 8009df2:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009df6:	6930      	ldr	r0, [r6, #16]
 8009df8:	f7f6 fbd2 	bl	80005a0 <__aeabi_f2d>
 8009dfc:	f104 070c 	add.w	r7, r4, #12
 8009e00:	b23f      	sxth	r7, r7
 8009e02:	e9cd 0100 	strd	r0, r1, [sp]
 8009e06:	4a1c      	ldr	r2, [pc, #112]	@ (8009e78 <draw_s11_cable+0x138>)
 8009e08:	4639      	mov	r1, r7
 8009e0a:	4628      	mov	r0, r5
 8009e0c:	f7ff ff2e 	bl	8009c6c <cell_printf>
  if (s11_cable->len) {
 8009e10:	ed96 8a02 	vldr	s16, [r6, #8]
 8009e14:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009e18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e1c:	d019      	beq.n	8009e52 <draw_s11_cable+0x112>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Att (" S_dB "/100" S_METRE "): %F" S_dB " (%.4F" S_Hz ")", s11_cable->mloss * 100.0f / l, s11_cable->freq);
 8009e1e:	6830      	ldr	r0, [r6, #0]
 8009e20:	f7f6 fbbe 	bl	80005a0 <__aeabi_f2d>
 8009e24:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009e28:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 8009e7c <draw_s11_cable+0x13c>
 8009e2c:	edd6 7a04 	vldr	s15, [r6, #16]
 8009e30:	ee67 7a87 	vmul.f32	s15, s15, s14
 8009e34:	3418      	adds	r4, #24
 8009e36:	eec7 7a88 	vdiv.f32	s15, s15, s16
 8009e3a:	b224      	sxth	r4, r4
 8009e3c:	ee17 0a90 	vmov	r0, s15
 8009e40:	f7f6 fbae 	bl	80005a0 <__aeabi_f2d>
 8009e44:	4a0e      	ldr	r2, [pc, #56]	@ (8009e80 <draw_s11_cable+0x140>)
 8009e46:	e9cd 0100 	strd	r0, r1, [sp]
 8009e4a:	4621      	mov	r1, r4
 8009e4c:	4628      	mov	r0, r5
 8009e4e:	f7ff ff0d 	bl	8009c6c <cell_printf>
}
 8009e52:	b004      	add	sp, #16
 8009e54:	ecbd 8b02 	vpop	{d8}
 8009e58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009e5c:	200069b4 	.word	0x200069b4
 8009e60:	08012948 	.word	0x08012948
 8009e64:	08012952 	.word	0x08012952
 8009e68:	200069b0 	.word	0x200069b0
 8009e6c:	0801295b 	.word	0x0801295b
 8009e70:	20000aa8 	.word	0x20000aa8
 8009e74:	08012974 	.word	0x08012974
 8009e78:	0801298b 	.word	0x0801298b
 8009e7c:	42c80000 	.word	0x42c80000
 8009e80:	080129a0 	.word	0x080129a0

08009e84 <draw_s21_pass>:
static void draw_s21_pass(int xp, int yp, s21_pass *p, const char *name) {
 8009e84:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  cell_printf(xp, yp, name);
 8009e86:	b205      	sxth	r5, r0
static void draw_s21_pass(int xp, int yp, s21_pass *p, const char *name) {
 8009e88:	4616      	mov	r6, r2
 8009e8a:	460c      	mov	r4, r1
  cell_printf(xp, yp, name);
 8009e8c:	461a      	mov	r2, r3
 8009e8e:	b209      	sxth	r1, r1
 8009e90:	4628      	mov	r0, r5
 8009e92:	f7ff feeb 	bl	8009c6c <cell_printf>
  if (p->f[_3dB]) cell_printf(xp, yp +   STR_MEASURE_HEIGHT, "%.6F" S_Hz,  p->f[_3dB]);
 8009e96:	edd6 7a00 	vldr	s15, [r6]
 8009e9a:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009e9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ea2:	d00d      	beq.n	8009ec0 <draw_s21_pass+0x3c>
 8009ea4:	ee17 0a90 	vmov	r0, s15
 8009ea8:	f7f6 fb7a 	bl	80005a0 <__aeabi_f2d>
 8009eac:	f104 070c 	add.w	r7, r4, #12
 8009eb0:	b23f      	sxth	r7, r7
 8009eb2:	e9cd 0100 	strd	r0, r1, [sp]
 8009eb6:	4a1e      	ldr	r2, [pc, #120]	@ (8009f30 <draw_s21_pass+0xac>)
 8009eb8:	4639      	mov	r1, r7
 8009eba:	4628      	mov	r0, r5
 8009ebc:	f7ff fed6 	bl	8009c6c <cell_printf>
  if (p->f[_6dB]) cell_printf(xp, yp + 2*STR_MEASURE_HEIGHT, "%.6F" S_Hz,  p->f[_6dB]);
 8009ec0:	edd6 7a01 	vldr	s15, [r6, #4]
 8009ec4:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009ec8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ecc:	d00d      	beq.n	8009eea <draw_s21_pass+0x66>
 8009ece:	ee17 0a90 	vmov	r0, s15
 8009ed2:	f7f6 fb65 	bl	80005a0 <__aeabi_f2d>
 8009ed6:	f104 0718 	add.w	r7, r4, #24
 8009eda:	b23f      	sxth	r7, r7
 8009edc:	e9cd 0100 	strd	r0, r1, [sp]
 8009ee0:	4a13      	ldr	r2, [pc, #76]	@ (8009f30 <draw_s21_pass+0xac>)
 8009ee2:	4639      	mov	r1, r7
 8009ee4:	4628      	mov	r0, r5
 8009ee6:	f7ff fec1 	bl	8009c6c <cell_printf>
  if (p->decade) {
 8009eea:	edd6 7a04 	vldr	s15, [r6, #16]
 8009eee:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009ef2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ef6:	d019      	beq.n	8009f2c <draw_s21_pass+0xa8>
    cell_printf(xp, yp                     , "%F" S_dB "/dec", p->decade);
 8009ef8:	ee17 0a90 	vmov	r0, s15
 8009efc:	f7f6 fb50 	bl	80005a0 <__aeabi_f2d>
  yp+= 3 * STR_MEASURE_HEIGHT;
 8009f00:	f104 0724 	add.w	r7, r4, #36	@ 0x24
    cell_printf(xp, yp                     , "%F" S_dB "/dec", p->decade);
 8009f04:	b23f      	sxth	r7, r7
 8009f06:	e9cd 0100 	strd	r0, r1, [sp]
 8009f0a:	4a0a      	ldr	r2, [pc, #40]	@ (8009f34 <draw_s21_pass+0xb0>)
 8009f0c:	4639      	mov	r1, r7
 8009f0e:	4628      	mov	r0, r5
 8009f10:	f7ff feac 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp + STR_MEASURE_HEIGHT, "%F" S_dB "/oct", p->octave);
 8009f14:	6970      	ldr	r0, [r6, #20]
 8009f16:	f7f6 fb43 	bl	80005a0 <__aeabi_f2d>
 8009f1a:	3430      	adds	r4, #48	@ 0x30
 8009f1c:	b224      	sxth	r4, r4
 8009f1e:	e9cd 0100 	strd	r0, r1, [sp]
 8009f22:	4a05      	ldr	r2, [pc, #20]	@ (8009f38 <draw_s21_pass+0xb4>)
 8009f24:	4621      	mov	r1, r4
 8009f26:	4628      	mov	r0, r5
 8009f28:	f7ff fea0 	bl	8009c6c <cell_printf>
}
 8009f2c:	b003      	add	sp, #12
 8009f2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009f30:	08012a1d 	.word	0x08012a1d
 8009f34:	080129bd 	.word	0x080129bd
 8009f38:	080129c6 	.word	0x080129c6

08009f3c <draw_filter_result>:
static void draw_filter_result(int xp, int yp){
 8009f3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009f40:	ed2d 8b02 	vpush	{d8}
  if (s21_filter->vmax < S21_MEASURE_FILTER_THRESHOLD) return;
 8009f44:	4c60      	ldr	r4, [pc, #384]	@ (800a0c8 <draw_filter_result+0x18c>)
  cell_printf(xp, yp, "S21 FILTER");
 8009f46:	4a61      	ldr	r2, [pc, #388]	@ (800a0cc <draw_filter_result+0x190>)
 8009f48:	b205      	sxth	r5, r0
static void draw_filter_result(int xp, int yp){
 8009f4a:	b085      	sub	sp, #20
 8009f4c:	4680      	mov	r8, r0
 8009f4e:	460f      	mov	r7, r1
  cell_printf(xp, yp, "S21 FILTER");
 8009f50:	4628      	mov	r0, r5
 8009f52:	b209      	sxth	r1, r1
 8009f54:	f7ff fe8a 	bl	8009c6c <cell_printf>
  if (s21_filter->vmax < S21_MEASURE_FILTER_THRESHOLD) return;
 8009f58:	edd4 7a01 	vldr	s15, [r4, #4]
 8009f5c:	ed9f 7a5c 	vldr	s14, [pc, #368]	@ 800a0d0 <draw_filter_result+0x194>
 8009f60:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009f64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009f68:	f100 80a8 	bmi.w	800a0bc <draw_filter_result+0x180>
  if (s21_filter->f_center) {
 8009f6c:	ed94 8a0e 	vldr	s16, [r4, #56]	@ 0x38
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->f_center, s21_filter->vmax);
 8009f70:	ee17 0a90 	vmov	r0, s15
 8009f74:	f7f6 fb14 	bl	80005a0 <__aeabi_f2d>
  if (s21_filter->f_center) {
 8009f78:	eeb5 8a40 	vcmp.f32	s16, #0.0
  yp+= STR_MEASURE_HEIGHT;
 8009f7c:	f107 060c 	add.w	r6, r7, #12
  if (s21_filter->f_center) {
 8009f80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->f_center, s21_filter->vmax);
 8009f84:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009f88:	fa0f f986 	sxth.w	r9, r6
  if (s21_filter->f_center) {
 8009f8c:	d034      	beq.n	8009ff8 <draw_filter_result+0xbc>
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->f_center, s21_filter->vmax);
 8009f8e:	ee18 0a10 	vmov	r0, s16
 8009f92:	f7f6 fb05 	bl	80005a0 <__aeabi_f2d>
 8009f96:	4a4f      	ldr	r2, [pc, #316]	@ (800a0d4 <draw_filter_result+0x198>)
 8009f98:	e9cd 0100 	strd	r0, r1, [sp]
 8009f9c:	4649      	mov	r1, r9
 8009f9e:	4628      	mov	r0, r5
 8009fa0:	f7ff fe64 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Bw (-%d" S_dB "): %.6F" S_Hz, 3, s21_filter->bw_3dB);
 8009fa4:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8009fa6:	f7f6 fafb 	bl	80005a0 <__aeabi_f2d>
 8009faa:	f107 0618 	add.w	r6, r7, #24
 8009fae:	b236      	sxth	r6, r6
 8009fb0:	e9cd 0100 	strd	r0, r1, [sp]
 8009fb4:	4a48      	ldr	r2, [pc, #288]	@ (800a0d8 <draw_filter_result+0x19c>)
 8009fb6:	2303      	movs	r3, #3
 8009fb8:	4631      	mov	r1, r6
 8009fba:	4628      	mov	r0, r5
 8009fbc:	f7ff fe56 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Bw (-%d" S_dB "): %.6F" S_Hz, 6, s21_filter->bw_6dB);
 8009fc0:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8009fc2:	f7f6 faed 	bl	80005a0 <__aeabi_f2d>
 8009fc6:	f107 0624 	add.w	r6, r7, #36	@ 0x24
 8009fca:	b236      	sxth	r6, r6
 8009fcc:	e9cd 0100 	strd	r0, r1, [sp]
 8009fd0:	4a41      	ldr	r2, [pc, #260]	@ (800a0d8 <draw_filter_result+0x19c>)
 8009fd2:	2306      	movs	r3, #6
 8009fd4:	4631      	mov	r1, r6
 8009fd6:	4628      	mov	r0, r5
 8009fd8:	f7ff fe48 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Q: %F", s21_filter->q);
 8009fdc:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8009fde:	f7f6 fadf 	bl	80005a0 <__aeabi_f2d>
 8009fe2:	f107 0630 	add.w	r6, r7, #48	@ 0x30
 8009fe6:	b237      	sxth	r7, r6
 8009fe8:	e9cd 0100 	strd	r0, r1, [sp]
 8009fec:	4a3b      	ldr	r2, [pc, #236]	@ (800a0dc <draw_filter_result+0x1a0>)
 8009fee:	4639      	mov	r1, r7
 8009ff0:	4628      	mov	r0, r5
 8009ff2:	f7ff fe3b 	bl	8009c6c <cell_printf>
 8009ff6:	e009      	b.n	800a00c <draw_filter_result+0xd0>
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->fmax, s21_filter->vmax);
 8009ff8:	6820      	ldr	r0, [r4, #0]
 8009ffa:	f7f6 fad1 	bl	80005a0 <__aeabi_f2d>
 8009ffe:	4a35      	ldr	r2, [pc, #212]	@ (800a0d4 <draw_filter_result+0x198>)
 800a000:	e9cd 0100 	strd	r0, r1, [sp]
 800a004:	4649      	mov	r1, r9
 800a006:	4628      	mov	r0, r5
 800a008:	f7ff fe30 	bl	8009c6c <cell_printf>
  if (s21_filter->lo_pass.f[_3dB] || s21_filter->hi_pass.f[_3dB]) {
 800a00c:	edd4 7a02 	vldr	s15, [r4, #8]
 800a010:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a014:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a018:	d106      	bne.n	800a028 <draw_filter_result+0xec>
 800a01a:	edd4 7a08 	vldr	s15, [r4, #32]
 800a01e:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a026:	d049      	beq.n	800a0bc <draw_filter_result+0x180>
    yp+= STR_MEASURE_HEIGHT;
 800a028:	360c      	adds	r6, #12
    cell_printf(xp, yp + 1 * STR_MEASURE_HEIGHT, "f(-%d):", 3);
 800a02a:	b2b7      	uxth	r7, r6
 800a02c:	f107 010c 	add.w	r1, r7, #12
 800a030:	4a2b      	ldr	r2, [pc, #172]	@ (800a0e0 <draw_filter_result+0x1a4>)
 800a032:	2303      	movs	r3, #3
 800a034:	b209      	sxth	r1, r1
 800a036:	4628      	mov	r0, r5
 800a038:	f7ff fe18 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp + 2 * STR_MEASURE_HEIGHT, "f(-%d):", 6);
 800a03c:	f107 0118 	add.w	r1, r7, #24
 800a040:	4a27      	ldr	r2, [pc, #156]	@ (800a0e0 <draw_filter_result+0x1a4>)
 800a042:	2306      	movs	r3, #6
 800a044:	b209      	sxth	r1, r1
 800a046:	4628      	mov	r0, r5
 800a048:	f7ff fe10 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp + 3 * STR_MEASURE_HEIGHT, "Roll:");
 800a04c:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 800a050:	4a24      	ldr	r2, [pc, #144]	@ (800a0e4 <draw_filter_result+0x1a8>)
 800a052:	b209      	sxth	r1, r1
 800a054:	4628      	mov	r0, r5
 800a056:	f7ff fe09 	bl	8009c6c <cell_printf>
    if (s21_filter->hi_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->hi_pass, s21_filter->f_center ? "Low-side"  : "High-pass"); xp+= width1; }
 800a05a:	edd4 7a08 	vldr	s15, [r4, #32]
 800a05e:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a062:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    xp+= width0;
 800a066:	f108 002a 	add.w	r0, r8, #42	@ 0x2a
    if (s21_filter->hi_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->hi_pass, s21_filter->f_center ? "Low-side"  : "High-pass"); xp+= width1; }
 800a06a:	d00e      	beq.n	800a08a <draw_filter_result+0x14e>
 800a06c:	edd4 7a0e 	vldr	s15, [r4, #56]	@ 0x38
 800a070:	4a1d      	ldr	r2, [pc, #116]	@ (800a0e8 <draw_filter_result+0x1ac>)
 800a072:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a076:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a07a:	bf14      	ite	ne
 800a07c:	4b1b      	ldrne	r3, [pc, #108]	@ (800a0ec <draw_filter_result+0x1b0>)
 800a07e:	4b1c      	ldreq	r3, [pc, #112]	@ (800a0f0 <draw_filter_result+0x1b4>)
 800a080:	4631      	mov	r1, r6
 800a082:	f7ff feff 	bl	8009e84 <draw_s21_pass>
 800a086:	f108 007e 	add.w	r0, r8, #126	@ 0x7e
    if (s21_filter->lo_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->lo_pass, s21_filter->f_center ? "High-side" : "Low-pass");               }
 800a08a:	edd4 7a02 	vldr	s15, [r4, #8]
 800a08e:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a096:	d011      	beq.n	800a0bc <draw_filter_result+0x180>
 800a098:	edd4 7a0e 	vldr	s15, [r4, #56]	@ 0x38
 800a09c:	4a15      	ldr	r2, [pc, #84]	@ (800a0f4 <draw_filter_result+0x1b8>)
 800a09e:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a0a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a0a6:	bf14      	ite	ne
 800a0a8:	4b13      	ldrne	r3, [pc, #76]	@ (800a0f8 <draw_filter_result+0x1bc>)
 800a0aa:	4b14      	ldreq	r3, [pc, #80]	@ (800a0fc <draw_filter_result+0x1c0>)
 800a0ac:	4631      	mov	r1, r6
}
 800a0ae:	b005      	add	sp, #20
 800a0b0:	ecbd 8b02 	vpop	{d8}
 800a0b4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (s21_filter->lo_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->lo_pass, s21_filter->f_center ? "High-side" : "Low-pass");               }
 800a0b8:	f7ff bee4 	b.w	8009e84 <draw_s21_pass>
}
 800a0bc:	b005      	add	sp, #20
 800a0be:	ecbd 8b02 	vpop	{d8}
 800a0c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800a0c6:	bf00      	nop
 800a0c8:	200069b4 	.word	0x200069b4
 800a0cc:	080129f5 	.word	0x080129f5
 800a0d0:	c2480000 	.word	0xc2480000
 800a0d4:	08012a00 	.word	0x08012a00
 800a0d8:	08012a11 	.word	0x08012a11
 800a0dc:	08012a24 	.word	0x08012a24
 800a0e0:	08012a2a 	.word	0x08012a2a
 800a0e4:	08012a32 	.word	0x08012a32
 800a0e8:	200069d4 	.word	0x200069d4
 800a0ec:	080129cf 	.word	0x080129cf
 800a0f0:	080129d8 	.word	0x080129d8
 800a0f4:	200069bc 	.word	0x200069bc
 800a0f8:	080129e2 	.word	0x080129e2
 800a0fc:	080129ec 	.word	0x080129ec

0800a100 <draw_serial_result>:
static void draw_serial_result(int xp, int yp) {
 800a100:	b5f0      	push	{r4, r5, r6, r7, lr}
  cell_printf(xp, yp, s21_measure->header);
 800a102:	4d2d      	ldr	r5, [pc, #180]	@ (800a1b8 <draw_serial_result+0xb8>)
 800a104:	b206      	sxth	r6, r0
static void draw_serial_result(int xp, int yp) {
 800a106:	460f      	mov	r7, r1
  cell_printf(xp, yp, s21_measure->header);
 800a108:	682a      	ldr	r2, [r5, #0]
static void draw_serial_result(int xp, int yp) {
 800a10a:	b087      	sub	sp, #28
  cell_printf(xp, yp, s21_measure->header);
 800a10c:	b209      	sxth	r1, r1
 800a10e:	4630      	mov	r0, r6
 800a110:	f7ff fdac 	bl	8009c6c <cell_printf>
  if (s21_measure->freq == 0 && s21_measure->freq1 == 0) {
 800a114:	686b      	ldr	r3, [r5, #4]
  yp+=STR_MEASURE_HEIGHT;
 800a116:	f107 040c 	add.w	r4, r7, #12
  if (s21_measure->freq == 0 && s21_measure->freq1 == 0) {
 800a11a:	b953      	cbnz	r3, 800a132 <draw_serial_result+0x32>
 800a11c:	68ab      	ldr	r3, [r5, #8]
 800a11e:	2b00      	cmp	r3, #0
 800a120:	d130      	bne.n	800a184 <draw_serial_result+0x84>
    cell_printf(xp, yp, "Not found");
 800a122:	4a26      	ldr	r2, [pc, #152]	@ (800a1bc <draw_serial_result+0xbc>)
 800a124:	b221      	sxth	r1, r4
 800a126:	4630      	mov	r0, r6
}
 800a128:	b007      	add	sp, #28
 800a12a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    cell_printf(xp, yp, "Not found");
 800a12e:	f7ff bd9d 	b.w	8009c6c <cell_printf>
    cell_printf(xp, yp                    , "Fs=%q" S_Hz, s21_measure->freq);
 800a132:	4a23      	ldr	r2, [pc, #140]	@ (800a1c0 <draw_serial_result+0xc0>)
 800a134:	b221      	sxth	r1, r4
 800a136:	4630      	mov	r0, r6
 800a138:	f7ff fd98 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Lm=%F" S_HENRY "  Cm=%F" S_FARAD "  Rm=%F" S_OHM, s21_measure->l, s21_measure->c, s21_measure->r);
 800a13c:	69e8      	ldr	r0, [r5, #28]
 800a13e:	f7f6 fa2f 	bl	80005a0 <__aeabi_f2d>
 800a142:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800a146:	6968      	ldr	r0, [r5, #20]
 800a148:	f7f6 fa2a 	bl	80005a0 <__aeabi_f2d>
 800a14c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a150:	6928      	ldr	r0, [r5, #16]
 800a152:	f7f6 fa25 	bl	80005a0 <__aeabi_f2d>
 800a156:	f107 0418 	add.w	r4, r7, #24
 800a15a:	b224      	sxth	r4, r4
 800a15c:	e9cd 0100 	strd	r0, r1, [sp]
 800a160:	4a18      	ldr	r2, [pc, #96]	@ (800a1c4 <draw_serial_result+0xc4>)
 800a162:	4621      	mov	r1, r4
 800a164:	4630      	mov	r0, r6
 800a166:	f7ff fd81 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Q=%.3f", s21_measure->q);
 800a16a:	6a28      	ldr	r0, [r5, #32]
 800a16c:	f7f6 fa18 	bl	80005a0 <__aeabi_f2d>
 800a170:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 800a174:	b227      	sxth	r7, r4
 800a176:	e9cd 0100 	strd	r0, r1, [sp]
 800a17a:	4a13      	ldr	r2, [pc, #76]	@ (800a1c8 <draw_serial_result+0xc8>)
 800a17c:	4639      	mov	r1, r7
 800a17e:	4630      	mov	r0, r6
 800a180:	f7ff fd74 	bl	8009c6c <cell_printf>
  if (s21_measure->freq1){
 800a184:	68ab      	ldr	r3, [r5, #8]
 800a186:	b1a3      	cbz	r3, 800a1b2 <draw_serial_result+0xb2>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Fp=%q" S_Hz "  " S_DELTA "F=%d", s21_measure->freq1, s21_measure->df);
 800a188:	68ea      	ldr	r2, [r5, #12]
 800a18a:	9200      	str	r2, [sp, #0]
 800a18c:	f104 010c 	add.w	r1, r4, #12
 800a190:	4a0e      	ldr	r2, [pc, #56]	@ (800a1cc <draw_serial_result+0xcc>)
 800a192:	b209      	sxth	r1, r1
 800a194:	4630      	mov	r0, r6
 800a196:	f7ff fd69 	bl	8009c6c <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Cp=%F" S_FARAD, s21_measure->c1);
 800a19a:	69a8      	ldr	r0, [r5, #24]
 800a19c:	f7f6 fa00 	bl	80005a0 <__aeabi_f2d>
 800a1a0:	3418      	adds	r4, #24
 800a1a2:	b224      	sxth	r4, r4
 800a1a4:	e9cd 0100 	strd	r0, r1, [sp]
 800a1a8:	4a09      	ldr	r2, [pc, #36]	@ (800a1d0 <draw_serial_result+0xd0>)
 800a1aa:	4621      	mov	r1, r4
 800a1ac:	4630      	mov	r0, r6
 800a1ae:	f7ff fd5d 	bl	8009c6c <cell_printf>
}
 800a1b2:	b007      	add	sp, #28
 800a1b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a1b6:	bf00      	nop
 800a1b8:	200069b4 	.word	0x200069b4
 800a1bc:	08012930 	.word	0x08012930
 800a1c0:	08012a38 	.word	0x08012a38
 800a1c4:	08012a40 	.word	0x08012a40
 800a1c8:	08012a57 	.word	0x08012a57
 800a1cc:	08012a5e 	.word	0x08012a5e
 800a1d0:	08012a6d 	.word	0x08012a6d

0800a1d4 <lc_match_x_str>:
  if (isnan(X) || 0.0f == X || -0.0f == X)
 800a1d4:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a1d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a1dc:	d027      	beq.n	800a22e <lc_match_x_str+0x5a>
  if (X < 0.0f) {X = -1.0f / X; type = S_FARAD[0];}
 800a1de:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800a1e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a1e6:	bf44      	itt	mi
 800a1e8:	eebf 7a00 	vmovmi.f32	s14, #240	@ 0xbf800000 -1.0
 800a1ec:	ee87 0a00 	vdivmi.f32	s0, s14, s0
{
 800a1f0:	b530      	push	{r4, r5, lr}
 800a1f2:	b085      	sub	sp, #20
  if (X < 0.0f) {X = -1.0f / X; type = S_FARAD[0];}
 800a1f4:	bf4c      	ite	mi
 800a1f6:	2346      	movmi	r3, #70	@ 0x46
  else          {               type = S_HENRY[0];}
 800a1f8:	2348      	movpl	r3, #72	@ 0x48
  cell_printf(xp, yp, "%4.2F%c", val, type);
 800a1fa:	b215      	sxth	r5, r2
 800a1fc:	b20c      	sxth	r4, r1
 800a1fe:	9302      	str	r3, [sp, #8]
  float val = X / ((2.0f * VNA_PI) * FHz);
 800a200:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 800a230 <lc_match_x_str+0x5c>
 800a204:	ee07 0a90 	vmov	s15, r0
 800a208:	ee20 0a07 	vmul.f32	s0, s0, s14
 800a20c:	eef8 7a67 	vcvt.f32.u32	s15, s15
  cell_printf(xp, yp, "%4.2F%c", val, type);
 800a210:	eec0 7a27 	vdiv.f32	s15, s0, s15
 800a214:	ee17 0a90 	vmov	r0, s15
 800a218:	f7f6 f9c2 	bl	80005a0 <__aeabi_f2d>
 800a21c:	4a05      	ldr	r2, [pc, #20]	@ (800a234 <lc_match_x_str+0x60>)
 800a21e:	e9cd 0100 	strd	r0, r1, [sp]
 800a222:	4629      	mov	r1, r5
 800a224:	4620      	mov	r0, r4
 800a226:	f7ff fd21 	bl	8009c6c <cell_printf>
}
 800a22a:	b005      	add	sp, #20
 800a22c:	bd30      	pop	{r4, r5, pc}
 800a22e:	4770      	bx	lr
 800a230:	3e22f983 	.word	0x3e22f983
 800a234:	08012a74 	.word	0x08012a74

0800a238 <draw_lc_match>:
static void draw_lc_match(int xp, int yp) {
 800a238:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800a23c:	4e30      	ldr	r6, [pc, #192]	@ (800a300 <draw_lc_match+0xc8>)
 800a23e:	fa0f f880 	sxth.w	r8, r0
static void draw_lc_match(int xp, int yp) {
 800a242:	4605      	mov	r5, r0
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800a244:	6870      	ldr	r0, [r6, #4]
static void draw_lc_match(int xp, int yp) {
 800a246:	460c      	mov	r4, r1
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800a248:	b20f      	sxth	r7, r1
 800a24a:	f7f6 f9a9 	bl	80005a0 <__aeabi_f2d>
  yp += STR_MEASURE_HEIGHT;
 800a24e:	340c      	adds	r4, #12
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800a250:	e9cd 0100 	strd	r0, r1, [sp]
 800a254:	4a2b      	ldr	r2, [pc, #172]	@ (800a304 <draw_lc_match+0xcc>)
 800a256:	4639      	mov	r1, r7
 800a258:	4640      	mov	r0, r8
 800a25a:	f7ff fd07 	bl	8009c6c <cell_printf>
  if (yp >= CELLHEIGHT) return;
 800a25e:	2c1f      	cmp	r4, #31
 800a260:	dc4b      	bgt.n	800a2fa <draw_lc_match+0xc2>
  if (lc_match_array->num_matches < 0)
 800a262:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	@ 0x38
 800a266:	2b00      	cmp	r3, #0
    cell_printf(xp, yp, "No LC match for this");
 800a268:	b227      	sxth	r7, r4
  if (lc_match_array->num_matches < 0)
 800a26a:	da01      	bge.n	800a270 <draw_lc_match+0x38>
    cell_printf(xp, yp, "No LC match for this");
 800a26c:	4a26      	ldr	r2, [pc, #152]	@ (800a308 <draw_lc_match+0xd0>)
 800a26e:	e001      	b.n	800a274 <draw_lc_match+0x3c>
  else if (lc_match_array->num_matches == 0)
 800a270:	d107      	bne.n	800a282 <draw_lc_match+0x4a>
    cell_printf(xp, yp, "No need for LC match");
 800a272:	4a26      	ldr	r2, [pc, #152]	@ (800a30c <draw_lc_match+0xd4>)
 800a274:	4639      	mov	r1, r7
 800a276:	4640      	mov	r0, r8
}
 800a278:	b002      	add	sp, #8
 800a27a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cell_printf(xp, yp, "No need for LC match");
 800a27e:	f7ff bcf5 	b.w	8009c6c <cell_printf>
    cell_printf(xp                      , yp, "Src shunt" );
 800a282:	4639      	mov	r1, r7
 800a284:	4a22      	ldr	r2, [pc, #136]	@ (800a310 <draw_lc_match+0xd8>)
 800a286:	4640      	mov	r0, r8
    cell_printf(xp +   STR_MEASURE_WIDTH, yp, "Series"    );
 800a288:	fa1f f885 	uxth.w	r8, r5
    cell_printf(xp                      , yp, "Src shunt" );
 800a28c:	f7ff fcee 	bl	8009c6c <cell_printf>
    cell_printf(xp +   STR_MEASURE_WIDTH, yp, "Series"    );
 800a290:	f108 0046 	add.w	r0, r8, #70	@ 0x46
 800a294:	4639      	mov	r1, r7
 800a296:	4a1f      	ldr	r2, [pc, #124]	@ (800a314 <draw_lc_match+0xdc>)
 800a298:	b200      	sxth	r0, r0
 800a29a:	f7ff fce7 	bl	8009c6c <cell_printf>
    cell_printf(xp + 2*STR_MEASURE_WIDTH, yp, "Load shunt");
 800a29e:	f108 008c 	add.w	r0, r8, #140	@ 0x8c
 800a2a2:	4639      	mov	r1, r7
 800a2a4:	4a1c      	ldr	r2, [pc, #112]	@ (800a318 <draw_lc_match+0xe0>)
 800a2a6:	b200      	sxth	r0, r0
 800a2a8:	f7ff fce0 	bl	8009c6c <cell_printf>
    for (int i = 0; i < lc_match_array->num_matches; i++){
 800a2ac:	4637      	mov	r7, r6
 800a2ae:	f04f 0800 	mov.w	r8, #0
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xs , xp +   STR_MEASURE_WIDTH, yp);
 800a2b2:	f105 0a46 	add.w	sl, r5, #70	@ 0x46
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xpl, xp + 2*STR_MEASURE_WIDTH, yp);
 800a2b6:	f105 098c 	add.w	r9, r5, #140	@ 0x8c
    for (int i = 0; i < lc_match_array->num_matches; i++){
 800a2ba:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	@ 0x38
 800a2be:	4543      	cmp	r3, r8
 800a2c0:	dd1b      	ble.n	800a2fa <draw_lc_match+0xc2>
      yp += STR_MEASURE_HEIGHT;
 800a2c2:	340c      	adds	r4, #12
      if (yp >= CELLHEIGHT) return;
 800a2c4:	2c1f      	cmp	r4, #31
 800a2c6:	dc18      	bgt.n	800a2fa <draw_lc_match+0xc2>
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xps, xp                      , yp);
 800a2c8:	ed97 0a02 	vldr	s0, [r7, #8]
 800a2cc:	6830      	ldr	r0, [r6, #0]
 800a2ce:	4622      	mov	r2, r4
 800a2d0:	4629      	mov	r1, r5
 800a2d2:	f7ff ff7f 	bl	800a1d4 <lc_match_x_str>
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xs , xp +   STR_MEASURE_WIDTH, yp);
 800a2d6:	ed97 0a03 	vldr	s0, [r7, #12]
 800a2da:	6830      	ldr	r0, [r6, #0]
 800a2dc:	4622      	mov	r2, r4
 800a2de:	4651      	mov	r1, sl
 800a2e0:	f7ff ff78 	bl	800a1d4 <lc_match_x_str>
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xpl, xp + 2*STR_MEASURE_WIDTH, yp);
 800a2e4:	ed97 0a04 	vldr	s0, [r7, #16]
 800a2e8:	6830      	ldr	r0, [r6, #0]
 800a2ea:	4622      	mov	r2, r4
 800a2ec:	4649      	mov	r1, r9
 800a2ee:	f7ff ff71 	bl	800a1d4 <lc_match_x_str>
    for (int i = 0; i < lc_match_array->num_matches; i++){
 800a2f2:	f108 0801 	add.w	r8, r8, #1
 800a2f6:	370c      	adds	r7, #12
 800a2f8:	e7df      	b.n	800a2ba <draw_lc_match+0x82>
}
 800a2fa:	b002      	add	sp, #8
 800a2fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800a300:	200069b4 	.word	0x200069b4
 800a304:	08012a7c 	.word	0x08012a7c
 800a308:	08012a9d 	.word	0x08012a9d
 800a30c:	08012ab2 	.word	0x08012ab2
 800a310:	08012ac7 	.word	0x08012ac7
 800a314:	08012ad1 	.word	0x08012ad1
 800a318:	08012ad8 	.word	0x08012ad8

0800a31c <trace_print_value_string>:
{
 800a31c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t type = trace[t].type;
 800a320:	f8df c190 	ldr.w	ip, [pc, #400]	@ 800a4b4 <trace_print_value_string+0x198>
{
 800a324:	ed2d 8b02 	vpush	{d8}
 800a328:	461f      	mov	r7, r3
  uint8_t type = trace[t].type;
 800a32a:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800a32e:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
{
 800a332:	b089      	sub	sp, #36	@ 0x24
  uint8_t type = trace[t].type;
 800a334:	f893 4029 	ldrb.w	r4, [r3, #41]	@ 0x29
{
 800a338:	460e      	mov	r6, r1
  if (type >= MAX_TRACE_TYPE)
 800a33a:	2c1d      	cmp	r4, #29
  uint8_t type = trace[t].type;
 800a33c:	ea4f 0142 	mov.w	r1, r2, lsl #1
 800a340:	9106      	str	r1, [sp, #24]
  if (type >= MAX_TRACE_TYPE)
 800a342:	d83a      	bhi.n	800a3ba <trace_print_value_string+0x9e>
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800a344:	f8df a170 	ldr.w	sl, [pc, #368]	@ 800a4b8 <trace_print_value_string+0x19c>
  float (*array)[2] = measured[trace[t].channel];
 800a348:	f893 e02a 	ldrb.w	lr, [r3, #42]	@ 0x2a
 800a34c:	4957      	ldr	r1, [pc, #348]	@ (800a4ac <trace_print_value_string+0x190>)
 800a34e:	4605      	mov	r5, r0
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800a350:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800a354:	9814      	ldr	r0, [sp, #80]	@ 0x50
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800a356:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
  float (*array)[2] = measured[trace[t].channel];
 800a35a:	f640 4888 	movw	r8, #3208	@ 0xc88
 800a35e:	fb08 180e 	mla	r8, r8, lr, r1
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800a362:	3001      	adds	r0, #1
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800a364:	f8d3 9018 	ldr.w	r9, [r3, #24]
  float *coeff = array[index];
 800a368:	eb08 01c7 	add.w	r1, r8, r7, lsl #3
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800a36c:	ea4f 0bc4 	mov.w	fp, r4, lsl #3
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800a370:	d028      	beq.n	800a3c4 <trace_print_value_string+0xa8>
  if (c)
 800a372:	f1b9 0f00 	cmp.w	r9, #0
 800a376:	d145      	bne.n	800a404 <trace_print_value_string+0xe8>
    format_smith_value(xpos, ypos, coeff, index, type == TRC_SMITH ? trace[t].smith_format : MS_REIM);
 800a378:	2c03      	cmp	r4, #3
 800a37a:	d061      	beq.n	800a440 <trace_print_value_string+0x124>
  float zr = re(idx, coeff);
 800a37c:	4638      	mov	r0, r7
 800a37e:	f7ff f9f3 	bl	8009768 <real>
 800a382:	ee10 4a10 	vmov	r4, s0
  float zi = im(idx, coeff);
 800a386:	f7ff f9f3 	bl	8009770 <imag>
  const char *format = marker_info_list[m].format;
 800a38a:	f8df 8130 	ldr.w	r8, [pc, #304]	@ 800a4bc <trace_print_value_string+0x1a0>
  float zi = im(idx, coeff);
 800a38e:	eeb0 8a40 	vmov.f32	s16, s0
 800a392:	2300      	movs	r3, #0
  cell_printf(xpos, ypos, format, zr, zi, value);
 800a394:	ee18 0a10 	vmov	r0, s16
 800a398:	9304      	str	r3, [sp, #16]
 800a39a:	f7f6 f901 	bl	80005a0 <__aeabi_f2d>
 800a39e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800a3a2:	4620      	mov	r0, r4
 800a3a4:	f7f6 f8fc 	bl	80005a0 <__aeabi_f2d>
 800a3a8:	b236      	sxth	r6, r6
 800a3aa:	b22d      	sxth	r5, r5
 800a3ac:	e9cd 0100 	strd	r0, r1, [sp]
 800a3b0:	4642      	mov	r2, r8
 800a3b2:	4631      	mov	r1, r6
 800a3b4:	4628      	mov	r0, r5
 800a3b6:	f7ff fc59 	bl	8009c6c <cell_printf>
}
 800a3ba:	b009      	add	sp, #36	@ 0x24
 800a3bc:	ecbd 8b02 	vpop	{d8}
 800a3c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800a3c4:	685b      	ldr	r3, [r3, #4]
 800a3c6:	9306      	str	r3, [sp, #24]
  if (c)
 800a3c8:	f1b9 0f00 	cmp.w	r9, #0
 800a3cc:	d0d4      	beq.n	800a378 <trace_print_value_string+0x5c>
    float v = c(index, coeff); // Get value
 800a3ce:	4638      	mov	r0, r7
 800a3d0:	47c8      	blx	r9
 800a3d2:	ee10 3a10 	vmov	r3, s0
    cell_printf(xpos, ypos, format, v, trace_info_list[type].symbol);
 800a3d6:	ebab 0404 	sub.w	r4, fp, r4
 800a3da:	eb0a 0484 	add.w	r4, sl, r4, lsl #2
 800a3de:	4618      	mov	r0, r3
 800a3e0:	68e3      	ldr	r3, [r4, #12]
 800a3e2:	9302      	str	r3, [sp, #8]
 800a3e4:	f7f6 f8dc 	bl	80005a0 <__aeabi_f2d>
 800a3e8:	b236      	sxth	r6, r6
 800a3ea:	b22d      	sxth	r5, r5
 800a3ec:	e9cd 0100 	strd	r0, r1, [sp]
 800a3f0:	9a06      	ldr	r2, [sp, #24]
 800a3f2:	4631      	mov	r1, r6
 800a3f4:	4628      	mov	r0, r5
 800a3f6:	f7ff fc39 	bl	8009c6c <cell_printf>
}
 800a3fa:	b009      	add	sp, #36	@ 0x24
 800a3fc:	ecbd 8b02 	vpop	{d8}
 800a400:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800a404:	689b      	ldr	r3, [r3, #8]
 800a406:	9306      	str	r3, [sp, #24]
    float v = c(index, coeff); // Get value
 800a408:	4638      	mov	r0, r7
 800a40a:	47c8      	blx	r9
 800a40c:	ed8d 0a07 	vstr	s0, [sp, #28]
    if (index_ref >= 0 && v != infinityf())
 800a410:	f007 f870 	bl	80114f4 <infinityf>
 800a414:	9b07      	ldr	r3, [sp, #28]
 800a416:	ee07 3a90 	vmov	s15, r3
 800a41a:	eeb4 0a67 	vcmp.f32	s0, s15
 800a41e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a422:	d0d8      	beq.n	800a3d6 <trace_print_value_string+0xba>
      v -= c(index, array[index_ref]); // Calculate delta value
 800a424:	9307      	str	r3, [sp, #28]
 800a426:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 800a428:	4638      	mov	r0, r7
 800a42a:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
 800a42e:	47c8      	blx	r9
 800a430:	9b07      	ldr	r3, [sp, #28]
 800a432:	ee07 3a90 	vmov	s15, r3
 800a436:	ee77 7ac0 	vsub.f32	s15, s15, s0
 800a43a:	ee17 3a90 	vmov	r3, s15
 800a43e:	e7ca      	b.n	800a3d6 <trace_print_value_string+0xba>
    format_smith_value(xpos, ypos, coeff, index, type == TRC_SMITH ? trace[t].smith_format : MS_REIM);
 800a440:	0050      	lsls	r0, r2, #1
 800a442:	4410      	add	r0, r2
 800a444:	eb0c 0c80 	add.w	ip, ip, r0, lsl #2
 800a448:	f89c 902b 	ldrb.w	r9, [ip, #43]	@ 0x2b
  if (m >= MS_END)
 800a44c:	f1b9 0f0c 	cmp.w	r9, #12
 800a450:	d8b3      	bhi.n	800a3ba <trace_print_value_string+0x9e>
  get_value_cb_t im = marker_info_list[m].get_im_cb;
 800a452:	4b17      	ldr	r3, [pc, #92]	@ (800a4b0 <trace_print_value_string+0x194>)
  float zr = re(idx, coeff);
 800a454:	9106      	str	r1, [sp, #24]
  get_value_cb_t im = marker_info_list[m].get_im_cb;
 800a456:	eb03 1309 	add.w	r3, r3, r9, lsl #4
  float zr = re(idx, coeff);
 800a45a:	4638      	mov	r0, r7
 800a45c:	689a      	ldr	r2, [r3, #8]
  get_value_cb_t im = marker_info_list[m].get_im_cb;
 800a45e:	f8d3 a00c 	ldr.w	sl, [r3, #12]
  const char *format = marker_info_list[m].format;
 800a462:	f8d3 8004 	ldr.w	r8, [r3, #4]
  float zr = re(idx, coeff);
 800a466:	4790      	blx	r2
  float zi = im(idx, coeff);
 800a468:	9906      	ldr	r1, [sp, #24]
 800a46a:	4638      	mov	r0, r7
  float zr = re(idx, coeff);
 800a46c:	ee10 4a10 	vmov	r4, s0
  float zi = im(idx, coeff);
 800a470:	47d0      	blx	sl
  if (LC_MARKER_VALUE(m))
 800a472:	f241 5350 	movw	r3, #5456	@ 0x1550
 800a476:	fa43 f309 	asr.w	r3, r3, r9
 800a47a:	f013 0301 	ands.w	r3, r3, #1
  float zi = im(idx, coeff);
 800a47e:	eeb0 8a40 	vmov.f32	s16, s0
  if (LC_MARKER_VALUE(m))
 800a482:	d087      	beq.n	800a394 <trace_print_value_string+0x78>
    float w = get_w(idx);
 800a484:	4638      	mov	r0, r7
 800a486:	f7ff fb51 	bl	8009b2c <get_w>
    if (zi < 0)
 800a48a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800a48e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a492:	d403      	bmi.n	800a49c <trace_print_value_string+0x180>
      zi = zi / (w);
 800a494:	ee88 8a00 	vdiv.f32	s16, s16, s0
 800a498:	2348      	movs	r3, #72	@ 0x48
 800a49a:	e77b      	b.n	800a394 <trace_print_value_string+0x78>
      zi = -1.0f / (w * zi);
 800a49c:	ee28 0a00 	vmul.f32	s0, s16, s0
 800a4a0:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
 800a4a4:	ee87 8a80 	vdiv.f32	s16, s15, s0
      value = S_FARAD[0];
 800a4a8:	2346      	movs	r3, #70	@ 0x46
 800a4aa:	e773      	b.n	800a394 <trace_print_value_string+0x78>
 800a4ac:	20004f54 	.word	0x20004f54
 800a4b0:	08014470 	.word	0x08014470
 800a4b4:	20000aa8 	.word	0x20000aa8
 800a4b8:	08014540 	.word	0x08014540
 800a4bc:	08011d30 	.word	0x08011d30

0800a4c0 <find_filter_pass>:
static void find_filter_pass(float max, s21_pass *p, uint16_t idx, int16_t mode) {
 800a4c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a4c4:	ed2d 8b02 	vpush	{d8}
 800a4c8:	b082      	sub	sp, #8
 800a4ca:	f8df 80a8 	ldr.w	r8, [pc, #168]	@ 800a574 <find_filter_pass+0xb4>
 800a4ce:	f8ad 1006 	strh.w	r1, [sp, #6]
 800a4d2:	eeb0 8a40 	vmov.f32	s16, s0
 800a4d6:	4604      	mov	r4, r0
 800a4d8:	4616      	mov	r6, r2
 800a4da:	4607      	mov	r7, r0
  for (int i = 0; i < _end; i++)
 800a4dc:	2500      	movs	r5, #0
    p->f[i] = measure_search_value(&idx, max - filter_att[i], s21logmag, mode, i == 0 ? (mode == MEASURE_SEARCH_LEFT ? 1 : 2) : MARKER_INVALID);
 800a4de:	ecb8 0a01 	vldmia	r8!, {s0}
 800a4e2:	ee38 0a40 	vsub.f32	s0, s16, s0
 800a4e6:	b925      	cbnz	r5, 800a4f2 <find_filter_pass+0x32>
 800a4e8:	1c72      	adds	r2, r6, #1
 800a4ea:	bf14      	ite	ne
 800a4ec:	2302      	movne	r3, #2
 800a4ee:	2301      	moveq	r3, #1
 800a4f0:	e001      	b.n	800a4f6 <find_filter_pass+0x36>
 800a4f2:	f04f 33ff 	mov.w	r3, #4294967295
 800a4f6:	491c      	ldr	r1, [pc, #112]	@ (800a568 <find_filter_pass+0xa8>)
 800a4f8:	4632      	mov	r2, r6
 800a4fa:	f10d 0006 	add.w	r0, sp, #6
 800a4fe:	f7ff fb35 	bl	8009b6c <measure_search_value>
  for (int i = 0; i < _end; i++)
 800a502:	3501      	adds	r5, #1
 800a504:	2d04      	cmp	r5, #4
    p->f[i] = measure_search_value(&idx, max - filter_att[i], s21logmag, mode, i == 0 ? (mode == MEASURE_SEARCH_LEFT ? 1 : 2) : MARKER_INVALID);
 800a506:	eca7 0a01 	vstmia	r7!, {s0}
  for (int i = 0; i < _end; i++)
 800a50a:	d1e8      	bne.n	800a4de <find_filter_pass+0x1e>
  if (p->f[_10dB] != 0 && p->f[_20dB] != 0) {
 800a50c:	edd4 7a02 	vldr	s15, [r4, #8]
 800a510:	eef5 7a40 	vcmp.f32	s15, #0.0
  p->decade = p->octave = 0.0f;
 800a514:	2300      	movs	r3, #0
  if (p->f[_10dB] != 0 && p->f[_20dB] != 0) {
 800a516:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  p->decade = p->octave = 0.0f;
 800a51a:	6163      	str	r3, [r4, #20]
 800a51c:	6123      	str	r3, [r4, #16]
  if (p->f[_10dB] != 0 && p->f[_20dB] != 0) {
 800a51e:	d01e      	beq.n	800a55e <find_filter_pass+0x9e>
 800a520:	ed94 0a03 	vldr	s0, [r4, #12]
 800a524:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a528:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a52c:	d017      	beq.n	800a55e <find_filter_pass+0x9e>
    float k = vna_fabsf(vna_logf(p->f[_20dB]) - vna_logf(p->f[_10dB]));
 800a52e:	f006 fef5 	bl	801131c <vna_logf>
 800a532:	eeb0 8a40 	vmov.f32	s16, s0
 800a536:	ed94 0a02 	vldr	s0, [r4, #8]
 800a53a:	f006 feef 	bl	801131c <vna_logf>
    p->decade = (10.0f * logf(10.0f)) / k;
 800a53e:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 800a56c <find_filter_pass+0xac>
    float k = vna_fabsf(vna_logf(p->f[_20dB]) - vna_logf(p->f[_10dB]));
 800a542:	ee38 0a40 	vsub.f32	s0, s16, s0
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800a546:	eeb0 0ac0 	vabs.f32	s0, s0
    p->decade = (10.0f * logf(10.0f)) / k;
 800a54a:	eec7 7a00 	vdiv.f32	s15, s14, s0
    p->octave = (10.0f * logf( 2.0f)) / k;
 800a54e:	ed9f 7a08 	vldr	s14, [pc, #32]	@ 800a570 <find_filter_pass+0xb0>
    p->decade = (10.0f * logf(10.0f)) / k;
 800a552:	edc4 7a04 	vstr	s15, [r4, #16]
    p->octave = (10.0f * logf( 2.0f)) / k;
 800a556:	eec7 7a00 	vdiv.f32	s15, s14, s0
 800a55a:	edc4 7a05 	vstr	s15, [r4, #20]
}
 800a55e:	b002      	add	sp, #8
 800a560:	ecbd 8b02 	vpop	{d8}
 800a564:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a568:	0800ab55 	.word	0x0800ab55
 800a56c:	41b834f2 	.word	0x41b834f2
 800a570:	40ddce9e 	.word	0x40ddce9e
 800a574:	08014260 	.word	0x08014260

0800a578 <marker_area_max>:
{
 800a578:	b538      	push	{r3, r4, r5, lr}
 800a57a:	4b1a      	ldr	r3, [pc, #104]	@ (800a5e4 <marker_area_max+0x6c>)
  int t_count = 0, m_count = 0, i;
 800a57c:	2400      	movs	r4, #0
 800a57e:	f103 0030 	add.w	r0, r3, #48	@ 0x30
{
 800a582:	461d      	mov	r5, r3
 800a584:	461a      	mov	r2, r3
    if (trace[i].enabled)
 800a586:	f892 1028 	ldrb.w	r1, [r2, #40]	@ 0x28
  for (i = 0; i < TRACES_MAX; i++)
 800a58a:	320c      	adds	r2, #12
    if (trace[i].enabled)
 800a58c:	b101      	cbz	r1, 800a590 <marker_area_max+0x18>
      t_count++;
 800a58e:	3401      	adds	r4, #1
  for (i = 0; i < TRACES_MAX; i++)
 800a590:	4290      	cmp	r0, r2
 800a592:	d1f8      	bne.n	800a586 <marker_area_max+0xe>
  for (i = 0; i < MARKERS_MAX; i++)
 800a594:	4814      	ldr	r0, [pc, #80]	@ (800a5e8 <marker_area_max+0x70>)
  int t_count = 0, m_count = 0, i;
 800a596:	2100      	movs	r1, #0
    if (markers[i].enabled)
 800a598:	f893 2058 	ldrb.w	r2, [r3, #88]	@ 0x58
  for (i = 0; i < MARKERS_MAX; i++)
 800a59c:	3308      	adds	r3, #8
    if (markers[i].enabled)
 800a59e:	b102      	cbz	r2, 800a5a2 <marker_area_max+0x2a>
      m_count++;
 800a5a0:	3101      	adds	r1, #1
  for (i = 0; i < MARKERS_MAX; i++)
 800a5a2:	4298      	cmp	r0, r3
 800a5a4:	d1f8      	bne.n	800a598 <marker_area_max+0x20>
  int cnt = t_count > m_count ? t_count : m_count;
 800a5a6:	428c      	cmp	r4, r1
 800a5a8:	bfb8      	it	lt
 800a5aa:	460c      	movlt	r4, r1
  if (get_electrical_delay() != 0.0f)
 800a5ac:	f7fe f878 	bl	80086a0 <get_electrical_delay>
  if (s21_offset != 0.0f)
 800a5b0:	edd5 7a2a 	vldr	s15, [r5, #168]	@ 0xa8
 800a5b4:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a5b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5bc:	d010      	beq.n	800a5e0 <marker_area_max+0x68>
  if (get_electrical_delay() != 0.0f)
 800a5be:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a5c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5c6:	bf14      	ite	ne
 800a5c8:	2301      	movne	r3, #1
 800a5ca:	2300      	moveq	r3, #0
 800a5cc:	005b      	lsls	r3, r3, #1
    extra += 2;
 800a5ce:	3302      	adds	r3, #2
  cnt = (cnt + extra + 1) >> 1;
 800a5d0:	4423      	add	r3, r4
 800a5d2:	3301      	adds	r3, #1
 800a5d4:	105b      	asrs	r3, r3, #1
  return cnt * FONT_STR_HEIGHT;
 800a5d6:	eb03 0083 	add.w	r0, r3, r3, lsl #2
}
 800a5da:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 800a5de:	bd38      	pop	{r3, r4, r5, pc}
 800a5e0:	2302      	movs	r3, #2
 800a5e2:	e7f5      	b.n	800a5d0 <marker_area_max+0x58>
 800a5e4:	20000aa8 	.word	0x20000aa8
 800a5e8:	20000ae8 	.word	0x20000ae8

0800a5ec <cell_fill_bg_rect.constprop.0>:
static void cell_fill_bg_rect(int x0, int y0, int x, int y, int w, int h)
 800a5ec:	b510      	push	{r4, lr}
  w += PAD * 2;
 800a5ee:	9c02      	ldr	r4, [sp, #8]
 800a5f0:	f104 0e06 	add.w	lr, r4, #6
  if (w <= 0 || h <= 0)
 800a5f4:	f1be 0f00 	cmp.w	lr, #0
 800a5f8:	dd3d      	ble.n	800a676 <cell_fill_bg_rect.constprop.0+0x8a>
  x -= PAD;
 800a5fa:	f1a2 0c03 	sub.w	ip, r2, #3
  int xe = x + w;
 800a5fe:	44e6      	add	lr, ip
  if (xs < x0)
 800a600:	4584      	cmp	ip, r0
  if (xe > x0 + CELLWIDTH)
 800a602:	f100 0220 	add.w	r2, r0, #32
  if (xs < x0)
 800a606:	bfb8      	it	lt
 800a608:	4684      	movlt	ip, r0
  if (xe > x0 + CELLWIDTH)
 800a60a:	4596      	cmp	lr, r2
 800a60c:	bfa8      	it	ge
 800a60e:	4696      	movge	lr, r2
  if (xe <= xs || ye <= ys)
 800a610:	45f4      	cmp	ip, lr
 800a612:	da30      	bge.n	800a676 <cell_fill_bg_rect.constprop.0+0x8a>
  y -= PAD;
 800a614:	1eda      	subs	r2, r3, #3
  if (ys < y0)
 800a616:	428a      	cmp	r2, r1
  int ye = y + h;
 800a618:	f103 0319 	add.w	r3, r3, #25
  if (ye > y0 + CELLHEIGHT)
 800a61c:	f101 0420 	add.w	r4, r1, #32
  if (ys < y0)
 800a620:	bfb8      	it	lt
 800a622:	460a      	movlt	r2, r1
  if (ye > y0 + CELLHEIGHT)
 800a624:	42a3      	cmp	r3, r4
 800a626:	bfa8      	it	ge
 800a628:	4623      	movge	r3, r4
  if (xe <= xs || ye <= ys)
 800a62a:	429a      	cmp	r2, r3
 800a62c:	da23      	bge.n	800a676 <cell_fill_bg_rect.constprop.0+0x8a>
  const pixel_t bg = GET_PALTETTE_COLOR(LCD_BG_COLOR);
 800a62e:	1a52      	subs	r2, r2, r1
    pixel_t *row = cell_buffer + (yy - y0) * CELLWIDTH + (xs - x0);
 800a630:	ebac 0000 	sub.w	r0, ip, r0
 800a634:	1a59      	subs	r1, r3, r1
 800a636:	eb00 1342 	add.w	r3, r0, r2, lsl #5
 800a63a:	4a0f      	ldr	r2, [pc, #60]	@ (800a678 <cell_fill_bg_rect.constprop.0+0x8c>)
 800a63c:	6812      	ldr	r2, [r2, #0]
 800a63e:	4473      	add	r3, lr
 800a640:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 800a644:	eba3 010c 	sub.w	r1, r3, ip
 800a648:	eb00 030e 	add.w	r3, r0, lr
 800a64c:	eba2 004c 	sub.w	r0, r2, ip, lsl #1
 800a650:	eb00 0043 	add.w	r0, r0, r3, lsl #1
  const pixel_t bg = GET_PALTETTE_COLOR(LCD_BG_COLOR);
 800a654:	4b09      	ldr	r3, [pc, #36]	@ (800a67c <cell_fill_bg_rect.constprop.0+0x90>)
 800a656:	ebac 0e0e 	sub.w	lr, ip, lr
 800a65a:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 800a65e:	8bd9      	ldrh	r1, [r3, #30]
  for (int yy = ys; yy < ye; yy++)
 800a660:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    pixel_t *row = cell_buffer + (yy - y0) * CELLWIDTH + (xs - x0);
 800a664:	eb02 030e 	add.w	r3, r2, lr
      *row++ = bg;
 800a668:	f823 1b02 	strh.w	r1, [r3], #2
    for (int xx = xs; xx < xe; xx++)
 800a66c:	4293      	cmp	r3, r2
 800a66e:	d1fb      	bne.n	800a668 <cell_fill_bg_rect.constprop.0+0x7c>
  for (int yy = ys; yy < ye; yy++)
 800a670:	3240      	adds	r2, #64	@ 0x40
 800a672:	4282      	cmp	r2, r0
 800a674:	d1f6      	bne.n	800a664 <cell_fill_bg_rect.constprop.0+0x78>
}
 800a676:	bd10      	pop	{r4, pc}
 800a678:	200089a4 	.word	0x200089a4
 800a67c:	20000318 	.word	0x20000318

0800a680 <search_peak_value.constprop.0>:
static float search_peak_value(uint16_t *xp, get_value_t get, bool mode) {
 800a680:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  bool (*compare)(float x, float y) = mode ? _greaterf : _lesserf;
 800a684:	4b28      	ldr	r3, [pc, #160]	@ (800a728 <search_peak_value.constprop.0+0xa8>)
  for(int i = 1; i < sweep_points; i++) {
 800a686:	f8df 90a8 	ldr.w	r9, [pc, #168]	@ 800a730 <search_peak_value.constprop.0+0xb0>
static float search_peak_value(uint16_t *xp, get_value_t get, bool mode) {
 800a68a:	460d      	mov	r5, r1
  bool (*compare)(float x, float y) = mode ? _greaterf : _lesserf;
 800a68c:	4927      	ldr	r1, [pc, #156]	@ (800a72c <search_peak_value.constprop.0+0xac>)
static float search_peak_value(uint16_t *xp, get_value_t get, bool mode) {
 800a68e:	ed2d 8b02 	vpush	{d8}
 800a692:	4607      	mov	r7, r0
  float y2 = get(x), ytemp;
 800a694:	2000      	movs	r0, #0
  bool (*compare)(float x, float y) = mode ? _greaterf : _lesserf;
 800a696:	2a00      	cmp	r2, #0
 800a698:	bf0c      	ite	eq
 800a69a:	468a      	moveq	sl, r1
 800a69c:	469a      	movne	sl, r3
  float y2 = get(x), ytemp;
 800a69e:	47a8      	blx	r5
  for(int i = 1; i < sweep_points; i++) {
 800a6a0:	2601      	movs	r6, #1
  float y2 = get(x), ytemp;
 800a6a2:	eeb0 8a40 	vmov.f32	s16, s0
  uint16_t x = 0;
 800a6a6:	2400      	movs	r4, #0
  for(int i = 1; i < sweep_points; i++) {
 800a6a8:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800a6ac:	429e      	cmp	r6, r3
 800a6ae:	da11      	bge.n	800a6d4 <search_peak_value.constprop.0+0x54>
    if(compare(ytemp = get(i), y2)) {
 800a6b0:	fa1f f886 	uxth.w	r8, r6
 800a6b4:	4640      	mov	r0, r8
 800a6b6:	47a8      	blx	r5
 800a6b8:	eef0 0a48 	vmov.f32	s1, s16
 800a6bc:	eef0 8a40 	vmov.f32	s17, s0
 800a6c0:	47d0      	blx	sl
 800a6c2:	2800      	cmp	r0, #0
  for(int i = 1; i < sweep_points; i++) {
 800a6c4:	f106 0601 	add.w	r6, r6, #1
 800a6c8:	bf18      	it	ne
 800a6ca:	eeb0 8a68 	vmovne.f32	s16, s17
 800a6ce:	bf18      	it	ne
 800a6d0:	4644      	movne	r4, r8
 800a6d2:	e7e9      	b.n	800a6a8 <search_peak_value.constprop.0+0x28>
  if (x < 1 || x >= sweep_points - 1) return y2;
 800a6d4:	b314      	cbz	r4, 800a71c <search_peak_value.constprop.0+0x9c>
 800a6d6:	3b01      	subs	r3, #1
 800a6d8:	429c      	cmp	r4, r3
 800a6da:	da1f      	bge.n	800a71c <search_peak_value.constprop.0+0x9c>
  float y1 = get(x-1);
 800a6dc:	1e60      	subs	r0, r4, #1
 800a6de:	b280      	uxth	r0, r0
  *xp = x;
 800a6e0:	803c      	strh	r4, [r7, #0]
  float y1 = get(x-1);
 800a6e2:	47a8      	blx	r5
  float y3 = get(x+1);
 800a6e4:	1c60      	adds	r0, r4, #1
 800a6e6:	b280      	uxth	r0, r0
  float y1 = get(x-1);
 800a6e8:	eef0 8a40 	vmov.f32	s17, s0
  float y3 = get(x+1);
 800a6ec:	47a8      	blx	r5
  if (y1 == y3) return y2;
 800a6ee:	eef4 8a40 	vcmp.f32	s17, s0
 800a6f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a6f6:	d011      	beq.n	800a71c <search_peak_value.constprop.0+0x9c>
  const float a = 8.0f * (y1 - 2.0f * y2 + y3);
 800a6f8:	ee38 7a80 	vadd.f32	s14, s17, s0
  const float b = y3 - y1;
 800a6fc:	ee70 7a68 	vsub.f32	s15, s0, s17
  const float a = 8.0f * (y1 - 2.0f * y2 + y3);
 800a700:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 800a704:	eea8 7a66 	vfms.f32	s14, s16, s13
  return c - b * b / a;
 800a708:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800a70c:	eef4 6a00 	vmov.f32	s13, #64	@ 0x3e000000  0.125
 800a710:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800a714:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800a718:	ee38 8a66 	vsub.f32	s16, s16, s13
}
 800a71c:	eeb0 0a48 	vmov.f32	s0, s16
 800a720:	ecbd 8b02 	vpop	{d8}
 800a724:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800a728:	08009869 	.word	0x08009869
 800a72c:	08009879 	.word	0x08009879
 800a730:	20000aa8 	.word	0x20000aa8

0800a734 <prepare_filter>:
static void prepare_filter(uint8_t type, uint8_t update_mask) {
 800a734:	b573      	push	{r0, r1, r4, r5, r6, lr}
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800a736:	2201      	movs	r2, #1
 800a738:	492d      	ldr	r1, [pc, #180]	@ (800a7f0 <prepare_filter+0xbc>)
 800a73a:	4c2e      	ldr	r4, [pc, #184]	@ (800a7f4 <prepare_filter+0xc0>)
  uint16_t xp = 0;
 800a73c:	2600      	movs	r6, #0
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800a73e:	f10d 0006 	add.w	r0, sp, #6
  uint16_t xp = 0;
 800a742:	f8ad 6006 	strh.w	r6, [sp, #6]
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800a746:	f7ff ff9b 	bl	800a680 <search_peak_value.constprop.0>
  if (s21_filter->vmax >= S21_MEASURE_FILTER_THRESHOLD) {
 800a74a:	eddf 7a2b 	vldr	s15, [pc, #172]	@ 800a7f8 <prepare_filter+0xc4>
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800a74e:	ed84 0a01 	vstr	s0, [r4, #4]
  if (s21_filter->vmax >= S21_MEASURE_FILTER_THRESHOLD) {
 800a752:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800a756:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a75a:	db40      	blt.n	800a7de <prepare_filter+0xaa>
    set_marker_index(0, xp);                                                           // Put marker on maximum value point
 800a75c:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800a760:	4630      	mov	r0, r6
 800a762:	4629      	mov	r1, r5
 800a764:	f7fc fc12 	bl	8006f8c <set_marker_index>
    s21_filter->fmax = getFrequency(xp);                                               // Get maximum value frequency
 800a768:	4628      	mov	r0, r5
 800a76a:	f7fb ff27 	bl	80065bc <getFrequency>
 800a76e:	ee07 0a90 	vmov	s15, r0
 800a772:	4620      	mov	r0, r4
 800a774:	eef8 7a67 	vcvt.f32.u32	s15, s15
    find_filter_pass(s21_filter->vmax, &s21_filter->hi_pass, xp, MEASURE_SEARCH_LEFT); // Search High-pass filter data (or Low side for bandpass)
 800a778:	ed94 0a01 	vldr	s0, [r4, #4]
    s21_filter->fmax = getFrequency(xp);                                               // Get maximum value frequency
 800a77c:	edc4 7a00 	vstr	s15, [r4]
 800a780:	3020      	adds	r0, #32
    find_filter_pass(s21_filter->vmax, &s21_filter->hi_pass, xp, MEASURE_SEARCH_LEFT); // Search High-pass filter data (or Low side for bandpass)
 800a782:	f04f 32ff 	mov.w	r2, #4294967295
 800a786:	4629      	mov	r1, r5
 800a788:	f7ff fe9a 	bl	800a4c0 <find_filter_pass>
    find_filter_pass(s21_filter->vmax, &s21_filter->lo_pass, xp, MEASURE_SEARCH_RIGHT);// Search Low-pass filter data (or High side for bandpass)
 800a78c:	ed94 0a01 	vldr	s0, [r4, #4]
 800a790:	2201      	movs	r2, #1
 800a792:	4629      	mov	r1, r5
 800a794:	f104 0008 	add.w	r0, r4, #8
 800a798:	f7ff fe92 	bl	800a4c0 <find_filter_pass>
    s21_filter->f_center = s21_filter->lo_pass.f[_3dB] * s21_filter->hi_pass.f[_3dB];  // Center frequency (if 0, one or both points not found)
 800a79c:	ed94 7a02 	vldr	s14, [r4, #8]
 800a7a0:	edd4 6a08 	vldr	s13, [r4, #32]
 800a7a4:	ee67 7a26 	vmul.f32	s15, s14, s13
    if (s21_filter->f_center) {
 800a7a8:	eef5 7a40 	vcmp.f32	s15, #0.0
 800a7ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    s21_filter->f_center = s21_filter->lo_pass.f[_3dB] * s21_filter->hi_pass.f[_3dB];  // Center frequency (if 0, one or both points not found)
 800a7b0:	edc4 7a0e 	vstr	s15, [r4, #56]	@ 0x38
    if (s21_filter->f_center) {
 800a7b4:	d013      	beq.n	800a7de <prepare_filter+0xaa>
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800a7b6:	eef1 7ae7 	vsqrt.f32	s15, s15
      s21_filter->bw_3dB = s21_filter->lo_pass.f[_3dB] - s21_filter->hi_pass.f[_3dB];
 800a7ba:	ee37 7a66 	vsub.f32	s14, s14, s13
      s21_filter->bw_6dB = s21_filter->lo_pass.f[_6dB] - s21_filter->hi_pass.f[_6dB];
 800a7be:	ed94 6a09 	vldr	s12, [r4, #36]	@ 0x24
 800a7c2:	edd4 6a03 	vldr	s13, [r4, #12]
      s21_filter->bw_3dB = s21_filter->lo_pass.f[_3dB] - s21_filter->hi_pass.f[_3dB];
 800a7c6:	ed84 7a0f 	vstr	s14, [r4, #60]	@ 0x3c
      s21_filter->bw_6dB = s21_filter->lo_pass.f[_6dB] - s21_filter->hi_pass.f[_6dB];
 800a7ca:	ee76 6ac6 	vsub.f32	s13, s13, s12
      s21_filter->f_center = vna_sqrtf(s21_filter->f_center);
 800a7ce:	edc4 7a0e 	vstr	s15, [r4, #56]	@ 0x38
      s21_filter->bw_6dB = s21_filter->lo_pass.f[_6dB] - s21_filter->hi_pass.f[_6dB];
 800a7d2:	edc4 6a10 	vstr	s13, [r4, #64]	@ 0x40
      s21_filter->q = s21_filter->f_center / s21_filter->bw_3dB;
 800a7d6:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800a7da:	edc4 6a11 	vstr	s13, [r4, #68]	@ 0x44
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800a7de:	2306      	movs	r3, #6
 800a7e0:	2207      	movs	r2, #7
 800a7e2:	2102      	movs	r1, #2
 800a7e4:	2000      	movs	r0, #0
}
 800a7e6:	b002      	add	sp, #8
 800a7e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800a7ec:	f7fe bf9c 	b.w	8009728 <invalidate_rect_func>
 800a7f0:	0800ab55 	.word	0x0800ab55
 800a7f4:	200069b4 	.word	0x200069b4
 800a7f8:	c2480000 	.word	0xc2480000

0800a7fc <analysis_lcseries>:
static void analysis_lcseries(void) {
 800a7fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a7fe:	ed2d 8b02 	vpush	{d8}
  s21_measure->header = "LC-SERIES";
 800a802:	4c40      	ldr	r4, [pc, #256]	@ (800a904 <analysis_lcseries+0x108>)
 800a804:	4b40      	ldr	r3, [pc, #256]	@ (800a908 <analysis_lcseries+0x10c>)
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MAX);
 800a806:	4941      	ldr	r1, [pc, #260]	@ (800a90c <analysis_lcseries+0x110>)
static void analysis_lcseries(void) {
 800a808:	b083      	sub	sp, #12
  uint16_t xp=0, x2;
 800a80a:	2700      	movs	r7, #0
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MAX);
 800a80c:	2201      	movs	r2, #1
 800a80e:	a801      	add	r0, sp, #4
  uint16_t xp=0, x2;
 800a810:	f8ad 7004 	strh.w	r7, [sp, #4]
  s21_measure->header = "LC-SERIES";
 800a814:	6023      	str	r3, [r4, #0]
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MAX);
 800a816:	f7ff ff33 	bl	800a680 <search_peak_value.constprop.0>
  if (xp == 0) return; // peak not found
 800a81a:	f8bd 5004 	ldrh.w	r5, [sp, #4]
 800a81e:	2d00      	cmp	r5, #0
 800a820:	d06c      	beq.n	800a8fc <analysis_lcseries+0x100>
 800a822:	eeb1 7ac0 	vsqrt.f32	s14, s0
  s21_measure->r = 2 * config._measure_r * (1.0f / vna_sqrtf(ypeak) - 1.0f);
 800a826:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 800a82a:	eec8 6a07 	vdiv.f32	s13, s16, s14
 800a82e:	4e38      	ldr	r6, [pc, #224]	@ (800a910 <analysis_lcseries+0x114>)
 800a830:	edd6 7a1a 	vldr	s15, [r6, #104]	@ 0x68
 800a834:	ee36 7ac8 	vsub.f32	s14, s13, s16
 800a838:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800a83c:	ee67 7a87 	vmul.f32	s15, s15, s14
  if(s21_measure->r < 0) return;
 800a840:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800a844:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  s21_measure->r = 2 * config._measure_r * (1.0f / vna_sqrtf(ypeak) - 1.0f);
 800a848:	edc4 7a07 	vstr	s15, [r4, #28]
  if(s21_measure->r < 0) return;
 800a84c:	d456      	bmi.n	800a8fc <analysis_lcseries+0x100>
  set_marker_index(0, xp);
 800a84e:	4629      	mov	r1, r5
 800a850:	4638      	mov	r0, r7
 800a852:	f7fc fb9b 	bl	8006f8c <set_marker_index>
  float f1 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800a856:	eeb0 0a48 	vmov.f32	s0, s16
 800a85a:	492e      	ldr	r1, [pc, #184]	@ (800a914 <analysis_lcseries+0x118>)
  x2 = xp;
 800a85c:	f8ad 5006 	strh.w	r5, [sp, #6]
  float f1 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800a860:	2301      	movs	r3, #1
 800a862:	f04f 32ff 	mov.w	r2, #4294967295
 800a866:	f10d 0006 	add.w	r0, sp, #6
 800a86a:	f7ff f97f 	bl	8009b6c <measure_search_value>
  if (f1 == 0) return; // not found
 800a86e:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float f1 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800a876:	eeb0 8a40 	vmov.f32	s16, s0
  if (f1 == 0) return; // not found
 800a87a:	d03f      	beq.n	800a8fc <analysis_lcseries+0x100>
  float f2 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800a87c:	4925      	ldr	r1, [pc, #148]	@ (800a914 <analysis_lcseries+0x118>)
  x2 = xp;
 800a87e:	f8ad 5006 	strh.w	r5, [sp, #6]
  float f2 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800a882:	2302      	movs	r3, #2
 800a884:	2201      	movs	r2, #1
 800a886:	eebf 0a00 	vmov.f32	s0, #240	@ 0xbf800000 -1.0
 800a88a:	f10d 0006 	add.w	r0, sp, #6
 800a88e:	f7ff f96d 	bl	8009b6c <measure_search_value>
  if (f2 == 0) return; // not found
 800a892:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800a896:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a89a:	d02f      	beq.n	800a8fc <analysis_lcseries+0x100>
  float reff = 2.0f * config._measure_r + s21_measure->r;
 800a89c:	ed94 6a07 	vldr	s12, [r4, #28]
 800a8a0:	edd6 6a1a 	vldr	s13, [r6, #104]	@ 0x68
 800a8a4:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800a8a8:	eef0 5a46 	vmov.f32	s11, s12
 800a8ac:	eee6 5aa7 	vfma.f32	s11, s13, s15
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800a8b0:	eddf 6a19 	vldr	s13, [pc, #100]	@ 800a918 <analysis_lcseries+0x11c>
  float bw = f2 - f1;
 800a8b4:	ee30 7a48 	vsub.f32	s14, s0, s16
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800a8b8:	ee25 5aa6 	vmul.f32	s10, s11, s13
  float fpeak = vna_sqrtf(f2 * f1);
 800a8bc:	ee28 0a00 	vmul.f32	s0, s16, s0
 800a8c0:	eeb1 0ac0 	vsqrt.f32	s0, s0
  s21_measure->freq = fpeak;
 800a8c4:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800a8c8:	edc4 7a01 	vstr	s15, [r4, #4]
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800a8cc:	eec5 7a07 	vdiv.f32	s15, s10, s14
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * reff);
 800a8d0:	ee27 7a26 	vmul.f32	s14, s14, s13
 800a8d4:	ee60 6a00 	vmul.f32	s13, s0, s0
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800a8d8:	edc4 7a04 	vstr	s15, [r4, #16]
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * reff);
 800a8dc:	ee66 6aa5 	vmul.f32	s13, s13, s11
 800a8e0:	eec7 5a26 	vdiv.f32	s11, s14, s13
  s21_measure->q = (2.0f * VNA_PI) * fpeak * s21_measure->l / s21_measure->r;
 800a8e4:	ed9f 7a0d 	vldr	s14, [pc, #52]	@ 800a91c <analysis_lcseries+0x120>
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * reff);
 800a8e8:	edc4 5a05 	vstr	s11, [r4, #20]
  s21_measure->q = (2.0f * VNA_PI) * fpeak * s21_measure->l / s21_measure->r;
 800a8ec:	ee67 7a87 	vmul.f32	s15, s15, s14
 800a8f0:	ee67 7a80 	vmul.f32	s15, s15, s0
 800a8f4:	ee87 7a86 	vdiv.f32	s14, s15, s12
 800a8f8:	ed84 7a08 	vstr	s14, [r4, #32]
}
 800a8fc:	b003      	add	sp, #12
 800a8fe:	ecbd 8b02 	vpop	{d8}
 800a902:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a904:	200069b4 	.word	0x200069b4
 800a908:	08012ae3 	.word	0x08012ae3
 800a90c:	08009889 	.word	0x08009889
 800a910:	20000318 	.word	0x20000318
 800a914:	080098b1 	.word	0x080098b1
 800a918:	3e22f983 	.word	0x3e22f983
 800a91c:	40c90fdb 	.word	0x40c90fdb

0800a920 <cellPut>:
{
 800a920:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (ps->x < CELLWIDTH && ps->y < CELLHEIGHT)
 800a924:	f9b0 6004 	ldrsh.w	r6, [r0, #4]
 800a928:	2e1f      	cmp	r6, #31
{
 800a92a:	b08b      	sub	sp, #44	@ 0x2c
  if (ps->x < CELLWIDTH && ps->y < CELLHEIGHT)
 800a92c:	dc05      	bgt.n	800a93a <cellPut+0x1a>
 800a92e:	f9b0 8006 	ldrsh.w	r8, [r0, #6]
 800a932:	f1b8 0f1f 	cmp.w	r8, #31
 800a936:	4604      	mov	r4, r0
 800a938:	dd03      	ble.n	800a942 <cellPut+0x22>
}
 800a93a:	2000      	movs	r0, #0
 800a93c:	b00b      	add	sp, #44	@ 0x2c
 800a93e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t w = FONT_GET_WIDTH(ch);
 800a942:	3916      	subs	r1, #22
 800a944:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 800a948:	4d31      	ldr	r5, [pc, #196]	@ (800aa10 <cellPut+0xf0>)
 800a94a:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 800a94e:	f815 9001 	ldrb.w	r9, [r5, r1]
 800a952:	f009 0907 	and.w	r9, r9, #7
 800a956:	f1c9 0708 	rsb	r7, r9, #8
 800a95a:	b2bf      	uxth	r7, r7
  if (x + w < 0 || h + y < 0)
 800a95c:	42fe      	cmn	r6, r7
  cell_blit_bitmap_shadow(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 800a95e:	440d      	add	r5, r1
  if (x + w < 0 || h + y < 0)
 800a960:	d447      	bmi.n	800a9f2 <cellPut+0xd2>
 800a962:	f118 0f0b 	cmn.w	r8, #11
 800a966:	db44      	blt.n	800a9f2 <cellPut+0xd2>
  dst[0] = dst[1] = 0;
 800a968:	2300      	movs	r3, #0
    p = (bmp[i] << 8) & mask; // extend from 8 bit width to 16 bit
 800a96a:	469b      	mov	fp, r3
  dst[0] = dst[1] = 0;
 800a96c:	9302      	str	r3, [sp, #8]
  uint16_t dst[16], mask = 0xFFFF << (16 - w), p;
 800a96e:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 800a972:	f1c7 0310 	rsb	r3, r7, #16
 800a976:	4099      	lsls	r1, r3
    p = (bmp[i] << 8) & mask; // extend from 8 bit width to 16 bit
 800a978:	b209      	sxth	r1, r1
 800a97a:	f105 3eff 	add.w	lr, r5, #4294967295
 800a97e:	a802      	add	r0, sp, #8
 800a980:	f105 0a0a 	add.w	sl, r5, #10
 800a984:	465b      	mov	r3, fp
 800a986:	469c      	mov	ip, r3
 800a988:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
 800a98c:	ea01 2303 	and.w	r3, r1, r3, lsl #8
    p |= (p >> 1) | (p >> 2); // shadow horizontally
 800a990:	465a      	mov	r2, fp
 800a992:	ea4f 0b93 	mov.w	fp, r3, lsr #2
 800a996:	ea4b 0b53 	orr.w	fp, fp, r3, lsr #1
 800a99a:	ea43 030b 	orr.w	r3, r3, fp
    p = (p >> 8) | (p << 8);  // swap bytes (render do by 8 bit)
 800a99e:	ba5b      	rev16	r3, r3
    dst[i + 2] = p;           // shadow vertically
 800a9a0:	8083      	strh	r3, [r0, #4]
    p = (p >> 8) | (p << 8);  // swap bytes (render do by 8 bit)
 800a9a2:	b29b      	uxth	r3, r3
    dst[i + 1] |= dst[i + 2];
 800a9a4:	ea43 0b0c 	orr.w	fp, r3, ip
    dst[i] |= dst[i + 1];
 800a9a8:	ea4b 0202 	orr.w	r2, fp, r2
  for (i = 0; i < h; i++)
 800a9ac:	45f2      	cmp	sl, lr
    dst[i + 1] |= dst[i + 2];
 800a9ae:	f8a0 b002 	strh.w	fp, [r0, #2]
    dst[i] |= dst[i + 1];
 800a9b2:	f820 2b02 	strh.w	r2, [r0], #2
  for (i = 0; i < h; i++)
 800a9b6:	d1e6      	bne.n	800a986 <cellPut+0x66>
  pixel_t t = foreground_color;             // remember color
 800a9b8:	f8df a058 	ldr.w	sl, [pc, #88]	@ 800aa14 <cellPut+0xf4>
  lcd_set_foreground(LCD_TXT_SHADOW_COLOR); // set shadow color
 800a9bc:	201a      	movs	r0, #26
  pixel_t t = foreground_color;             // remember color
 800a9be:	f8ba b000 	ldrh.w	fp, [sl]
  lcd_set_foreground(LCD_TXT_SHADOW_COLOR); // set shadow color
 800a9c2:	f005 fb85 	bl	80100d0 <lcd_set_foreground>
  w += 2;
 800a9c6:	f1c9 020a 	rsb	r2, r9, #10
  cell_blit_bitmap(x - 1, y - 1, w < 9 ? 9 : w, h, (uint8_t *)dst);
 800a9ca:	b292      	uxth	r2, r2
 800a9cc:	ab02      	add	r3, sp, #8
 800a9ce:	f108 31ff 	add.w	r1, r8, #4294967295
 800a9d2:	1e70      	subs	r0, r6, #1
 800a9d4:	2a09      	cmp	r2, #9
 800a9d6:	9300      	str	r3, [sp, #0]
 800a9d8:	bf38      	it	cc
 800a9da:	2209      	movcc	r2, #9
 800a9dc:	b209      	sxth	r1, r1
 800a9de:	b200      	sxth	r0, r0
 800a9e0:	230d      	movs	r3, #13
 800a9e2:	f7fe fdc9 	bl	8009578 <cell_blit_bitmap>
  cell_blit_bitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 800a9e6:	f9b4 6004 	ldrsh.w	r6, [r4, #4]
 800a9ea:	f9b4 8006 	ldrsh.w	r8, [r4, #6]
  foreground_color = t; // restore color
 800a9ee:	f8aa b000 	strh.w	fp, [sl]
  cell_blit_bitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 800a9f2:	4630      	mov	r0, r6
 800a9f4:	463a      	mov	r2, r7
 800a9f6:	9500      	str	r5, [sp, #0]
 800a9f8:	230b      	movs	r3, #11
 800a9fa:	4641      	mov	r1, r8
 800a9fc:	f7fe fdbc 	bl	8009578 <cell_blit_bitmap>
  ps->x += w;
 800aa00:	88a3      	ldrh	r3, [r4, #4]
}
 800aa02:	2000      	movs	r0, #0
  ps->x += w;
 800aa04:	441f      	add	r7, r3
 800aa06:	80a7      	strh	r7, [r4, #4]
}
 800aa08:	b00b      	add	sp, #44	@ 0x2c
 800aa0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800aa0e:	bf00      	nop
 800aa10:	0801356c 	.word	0x0801356c
 800aa14:	200089f2 	.word	0x200089f2

0800aa18 <conductance>:
  return get_s11_r(1.0f + v[0], v[1], 1.0f / PORT_Z);
 800aa18:	edd1 7a00 	vldr	s15, [r1]
 800aa1c:	ed91 7a01 	vldr	s14, [r1, #4]
 800aa20:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800aa24:	ee77 7aa6 	vadd.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800aa28:	ee27 7a07 	vmul.f32	s14, s14, s14
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800aa2c:	eddf 6a07 	vldr	s13, [pc, #28]	@ 800aa4c <conductance+0x34>
static float get_l(float re, float im) { return (re * re + im * im); }
 800aa30:	eea7 7aa7 	vfma.f32	s14, s15, s15
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800aa34:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800aa38:	eddf 6a05 	vldr	s13, [pc, #20]	@ 800aa50 <conductance+0x38>
 800aa3c:	ee87 0a87 	vdiv.f32	s0, s15, s14
 800aa40:	ee30 0a66 	vsub.f32	s0, s0, s13
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800aa44:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800aa48:	4770      	bx	lr
 800aa4a:	bf00      	nop
 800aa4c:	3d23d70a 	.word	0x3d23d70a
 800aa50:	3ca3d70a 	.word	0x3ca3d70a

0800aa54 <parallel_r>:
{
 800aa54:	b508      	push	{r3, lr}
  return 1.0f / conductance(i, v);
 800aa56:	f7ff ffdf 	bl	800aa18 <conductance>
 800aa5a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
}
 800aa5e:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800aa62:	bd08      	pop	{r3, pc}

0800aa64 <s21series_r>:
  return get_s21_r(v[0], v[1], 2.0f * PORT_Z);
 800aa64:	edd1 7a01 	vldr	s15, [r1, #4]
 800aa68:	ed91 7a00 	vldr	s14, [r1]
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800aa6c:	eddf 6a06 	vldr	s13, [pc, #24]	@ 800aa88 <s21series_r+0x24>
static float get_l(float re, float im) { return (re * re + im * im); }
 800aa70:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800aa74:	eee7 7a07 	vfma.f32	s15, s14, s14
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800aa78:	ee27 7a26 	vmul.f32	s14, s14, s13
 800aa7c:	ee87 0a27 	vdiv.f32	s0, s14, s15
}
 800aa80:	ee30 0a66 	vsub.f32	s0, s0, s13
 800aa84:	4770      	bx	lr
 800aa86:	bf00      	nop
 800aa88:	42c80000 	.word	0x42c80000

0800aa8c <susceptance>:
  return get_s11_x(1.0f + v[0], v[1], 1.0f / PORT_Z);
 800aa8c:	edd1 7a01 	vldr	s15, [r1, #4]
 800aa90:	ed91 7a00 	vldr	s14, [r1]
 800aa94:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800aa98:	ee37 7a26 	vadd.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800aa9c:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800aaa0:	eddf 6a04 	vldr	s13, [pc, #16]	@ 800aab4 <susceptance+0x28>
static float get_l(float re, float im) { return (re * re + im * im); }
 800aaa4:	eea7 0a07 	vfma.f32	s0, s14, s14
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800aaa8:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
 800aaac:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800aab0:	4770      	bx	lr
 800aab2:	bf00      	nop
 800aab4:	bd23d70a 	.word	0xbd23d70a

0800aab8 <parallel_x>:
{
 800aab8:	b508      	push	{r3, lr}
  return -1.0f / susceptance(i, v);
 800aaba:	f7ff ffe7 	bl	800aa8c <susceptance>
 800aabe:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
}
 800aac2:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800aac6:	bd08      	pop	{r3, pc}

0800aac8 <parallel_l>:
{
 800aac8:	b508      	push	{r3, lr}
 800aaca:	ed2d 8b02 	vpush	{d8}
  const float xp = parallel_x(i, v);
 800aace:	f7ff fff3 	bl	800aab8 <parallel_x>
 800aad2:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800aad6:	f7ff f829 	bl	8009b2c <get_w>
}
 800aada:	ee88 0a00 	vdiv.f32	s0, s16, s0
 800aade:	ecbd 8b02 	vpop	{d8}
 800aae2:	bd08      	pop	{r3, pc}

0800aae4 <parallel_c>:
{
 800aae4:	b508      	push	{r3, lr}
 800aae6:	ed2d 8b02 	vpush	{d8}
  const float yi = susceptance(i, v);
 800aaea:	f7ff ffcf 	bl	800aa8c <susceptance>
 800aaee:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800aaf2:	f7ff f81b 	bl	8009b2c <get_w>
}
 800aaf6:	ee88 0a00 	vdiv.f32	s0, s16, s0
 800aafa:	ecbd 8b02 	vpop	{d8}
 800aafe:	bd08      	pop	{r3, pc}

0800ab00 <s21series_x>:
  return get_s21_x(v[0], v[1], 2.0f * PORT_Z);
 800ab00:	edd1 7a01 	vldr	s15, [r1, #4]
 800ab04:	ed91 7a00 	vldr	s14, [r1]
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800ab08:	eddf 6a05 	vldr	s13, [pc, #20]	@ 800ab20 <s21series_x+0x20>
static float get_l(float re, float im) { return (re * re + im * im); }
 800ab0c:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800ab10:	ee67 7aa6 	vmul.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800ab14:	eea7 0a07 	vfma.f32	s0, s14, s14
}
 800ab18:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ab1c:	4770      	bx	lr
 800ab1e:	bf00      	nop
 800ab20:	c2c80000 	.word	0xc2c80000

0800ab24 <logmag>:
  return vna_log10f_x_10(get_l(v[0], v[1]));
 800ab24:	ed91 0a01 	vldr	s0, [r1, #4]
 800ab28:	edd1 7a00 	vldr	s15, [r1]
static float get_l(float re, float im) { return (re * re + im * im); }
 800ab2c:	ee20 0a00 	vmul.f32	s0, s0, s0
  return vna_log10f_x_10(get_l(v[0], v[1]));
 800ab30:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800ab34:	f006 bc26 	b.w	8011384 <vna_log10f_x_10>

0800ab38 <s11loss>:
  return -0.5f * logmag(i, measured[0][i]);
 800ab38:	4905      	ldr	r1, [pc, #20]	@ (800ab50 <s11loss+0x18>)
static float s11loss(uint16_t i) {
 800ab3a:	b508      	push	{r3, lr}
  return -0.5f * logmag(i, measured[0][i]);
 800ab3c:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800ab40:	f7ff fff0 	bl	800ab24 <logmag>
}
 800ab44:	eefe 7a00 	vmov.f32	s15, #224	@ 0xbf000000 -0.5
 800ab48:	ee20 0a27 	vmul.f32	s0, s0, s15
 800ab4c:	bd08      	pop	{r3, pc}
 800ab4e:	bf00      	nop
 800ab50:	20004f54 	.word	0x20004f54

0800ab54 <s21logmag>:
  return logmag(i, measured[1][i]);
 800ab54:	4903      	ldr	r1, [pc, #12]	@ (800ab64 <s21logmag+0x10>)
 800ab56:	f200 1391 	addw	r3, r0, #401	@ 0x191
 800ab5a:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 800ab5e:	f7ff bfe1 	b.w	800ab24 <logmag>
 800ab62:	bf00      	nop
 800ab64:	20004f54 	.word	0x20004f54

0800ab68 <phase_z>:
  const float r = 1.0f - get_l(v[0], v[1]);
 800ab68:	edd1 7a00 	vldr	s15, [r1]
 800ab6c:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 800ab70:	eee7 0ae7 	vfms.f32	s1, s15, s15
{
 800ab74:	b508      	push	{r3, lr}
  const float r = 1.0f - get_l(v[0], v[1]);
 800ab76:	edd1 7a01 	vldr	s15, [r1, #4]
  return (180.0f / VNA_PI) * vna_atan2f(x, r);
 800ab7a:	eee7 0ae7 	vfms.f32	s1, s15, s15
 800ab7e:	ee37 0aa7 	vadd.f32	s0, s15, s15
 800ab82:	f006 fc33 	bl	80113ec <vna_atan2f>
 800ab86:	eddf 7a02 	vldr	s15, [pc, #8]	@ 800ab90 <phase_z+0x28>
}
 800ab8a:	ee20 0a27 	vmul.f32	s0, s0, s15
 800ab8e:	bd08      	pop	{r3, pc}
 800ab90:	42652ee0 	.word	0x42652ee0

0800ab94 <s21_qualityfactor>:
  return vna_fabsf(v[1] / (v[0] - get_l(v[0], v[1])));
 800ab94:	edd1 6a00 	vldr	s13, [r1]
 800ab98:	ed91 7a01 	vldr	s14, [r1, #4]
 800ab9c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800aba0:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800aba4:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800aba8:	eee7 7a47 	vfms.f32	s15, s14, s14
 800abac:	ee87 0a27 	vdiv.f32	s0, s14, s15
 800abb0:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800abb4:	4770      	bx	lr
 800abb6:	bf00      	nop

0800abb8 <s21series_z>:
  float l1 = get_l(v[0], v[1]);
 800abb8:	edd1 7a01 	vldr	s15, [r1, #4]
 800abbc:	edd1 6a00 	vldr	s13, [r1]
  return 2.0f * PORT_Z * vna_sqrtf(l2 / l1);
 800abc0:	ed9f 0a0a 	vldr	s0, [pc, #40]	@ 800abec <s21series_z+0x34>
static float get_l(float re, float im) { return (re * re + im * im); }
 800abc4:	ee67 7aa7 	vmul.f32	s15, s15, s15
  float l2 = get_l(1.0f - v[0], v[1]);
 800abc8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800abcc:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800abd0:	eeb0 6a67 	vmov.f32	s12, s15
 800abd4:	eea6 6aa6 	vfma.f32	s12, s13, s13
 800abd8:	eee7 7a07 	vfma.f32	s15, s14, s14
  return 2.0f * PORT_Z * vna_sqrtf(l2 / l1);
 800abdc:	ee87 7a86 	vdiv.f32	s14, s15, s12
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800abe0:	eeb1 7ac7 	vsqrt.f32	s14, s14
}
 800abe4:	ee27 0a00 	vmul.f32	s0, s14, s0
 800abe8:	4770      	bx	lr
 800abea:	bf00      	nop
 800abec:	42c80000 	.word	0x42c80000

0800abf0 <s21shunt_z>:
  float l1 = get_l(v[0], v[1]);
 800abf0:	edd1 7a01 	vldr	s15, [r1, #4]
 800abf4:	edd1 6a00 	vldr	s13, [r1]
static float get_l(float re, float im) { return (re * re + im * im); }
 800abf8:	ee67 7aa7 	vmul.f32	s15, s15, s15
  float l2 = get_l(1.0f - v[0], v[1]);
 800abfc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800ac00:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800ac04:	eeb0 6a67 	vmov.f32	s12, s15
 800ac08:	eea6 6aa6 	vfma.f32	s12, s13, s13
 800ac0c:	eee7 7a07 	vfma.f32	s15, s14, s14
  return 0.5f * PORT_Z * vna_sqrtf(l1 / l2);
 800ac10:	eeb3 0a09 	vmov.f32	s0, #57	@ 0x41c80000  25.0
 800ac14:	ee86 7a27 	vdiv.f32	s14, s12, s15
 800ac18:	eeb1 7ac7 	vsqrt.f32	s14, s14
}
 800ac1c:	ee27 0a00 	vmul.f32	s0, s14, s0
 800ac20:	4770      	bx	lr
 800ac22:	bf00      	nop

0800ac24 <qualityfactor>:
  const float r = 1.0f - get_l(v[0], v[1]);
 800ac24:	ed91 7a00 	vldr	s14, [r1]
 800ac28:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800ac2c:	eee7 7a47 	vfms.f32	s15, s14, s14
 800ac30:	ed91 7a01 	vldr	s14, [r1, #4]
 800ac34:	eee7 7a47 	vfms.f32	s15, s14, s14
  const float x = 2.0f * v[1];
 800ac38:	ee77 6a07 	vadd.f32	s13, s14, s14
  return vna_fabsf(x / r);
 800ac3c:	ee86 0aa7 	vdiv.f32	s0, s13, s15
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800ac40:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800ac44:	4770      	bx	lr
 800ac46:	bf00      	nop

0800ac48 <mod_z>:
  return z0 * vna_sqrtf(get_l(1.0f + v[0], v[1]) / get_l(1.0f - v[0], v[1])); // always >= 0
 800ac48:	edd1 7a01 	vldr	s15, [r1, #4]
 800ac4c:	ed91 6a00 	vldr	s12, [r1]
 800ac50:	ed9f 0a0b 	vldr	s0, [pc, #44]	@ 800ac80 <mod_z+0x38>
static float get_l(float re, float im) { return (re * re + im * im); }
 800ac54:	ee67 7aa7 	vmul.f32	s15, s15, s15
  return z0 * vna_sqrtf(get_l(1.0f + v[0], v[1]) / get_l(1.0f - v[0], v[1])); // always >= 0
 800ac58:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800ac5c:	ee76 6a07 	vadd.f32	s13, s12, s14
 800ac60:	ee37 7a46 	vsub.f32	s14, s14, s12
static float get_l(float re, float im) { return (re * re + im * im); }
 800ac64:	eeb0 6a67 	vmov.f32	s12, s15
 800ac68:	eea6 6aa6 	vfma.f32	s12, s13, s13
 800ac6c:	eee7 7a07 	vfma.f32	s15, s14, s14
  return z0 * vna_sqrtf(get_l(1.0f + v[0], v[1]) / get_l(1.0f - v[0], v[1])); // always >= 0
 800ac70:	ee86 7a27 	vdiv.f32	s14, s12, s15
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800ac74:	eeb1 7ac7 	vsqrt.f32	s14, s14
}
 800ac78:	ee27 0a00 	vmul.f32	s0, s14, s0
 800ac7c:	4770      	bx	lr
 800ac7e:	bf00      	nop
 800ac80:	42480000 	.word	0x42480000

0800ac84 <mod_y>:
{
 800ac84:	b508      	push	{r3, lr}
  return 1.0f / mod_z(i, v); // always >= 0
 800ac86:	f7ff ffdf 	bl	800ac48 <mod_z>
 800ac8a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
}
 800ac8e:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ac92:	bd08      	pop	{r3, pc}

0800ac94 <linear>:
  return vna_sqrtf(get_l(v[0], v[1]));
 800ac94:	ed91 0a01 	vldr	s0, [r1, #4]
 800ac98:	edd1 7a00 	vldr	s15, [r1]
static float get_l(float re, float im) { return (re * re + im * im); }
 800ac9c:	ee20 0a00 	vmul.f32	s0, s0, s0
 800aca0:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800aca4:	eeb1 0ac0 	vsqrt.f32	s0, s0
}
 800aca8:	4770      	bx	lr
 800acaa:	bf00      	nop

0800acac <swr>:
{
 800acac:	b508      	push	{r3, lr}
  float x = linear(i, v);
 800acae:	f7ff fff1 	bl	800ac94 <linear>
  if (x > 0.99f)
 800acb2:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 800acdc <swr+0x30>
 800acb6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800acba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800acbe:	dc08      	bgt.n	800acd2 <swr+0x26>
  return (1.0f + x) / (1.0f - x);
 800acc0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800acc4:	ee30 7a27 	vadd.f32	s14, s0, s15
 800acc8:	ee37 0ac0 	vsub.f32	s0, s15, s0
}
 800accc:	ee87 0a00 	vdiv.f32	s0, s14, s0
 800acd0:	bd08      	pop	{r3, pc}
 800acd2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return infinityf();
 800acd6:	f006 bc0d 	b.w	80114f4 <infinityf>
 800acda:	bf00      	nop
 800acdc:	3f7d70a4 	.word	0x3f7d70a4

0800ace0 <s21shunt_x>:
  return get_s21_x(1.0f - v[0], -v[1], 0.5f * PORT_Z);
 800ace0:	edd1 7a01 	vldr	s15, [r1, #4]
 800ace4:	edd1 6a00 	vldr	s13, [r1]
 800ace8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800acec:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800acf0:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800acf4:	eef3 6a09 	vmov.f32	s13, #57	@ 0x41c80000  25.0
static float get_l(float re, float im) { return (re * re + im * im); }
 800acf8:	eea7 0a07 	vfma.f32	s0, s14, s14
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800acfc:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
 800ad00:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ad04:	4770      	bx	lr
 800ad06:	bf00      	nop

0800ad08 <reactance>:
  return get_s11_x(1.0f - v[0], -v[1], PORT_Z);
 800ad08:	edd1 7a01 	vldr	s15, [r1, #4]
 800ad0c:	edd1 6a00 	vldr	s13, [r1]
 800ad10:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800ad14:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800ad18:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800ad1c:	eddf 6a04 	vldr	s13, [pc, #16]	@ 800ad30 <reactance+0x28>
static float get_l(float re, float im) { return (re * re + im * im); }
 800ad20:	eea7 0a07 	vfma.f32	s0, s14, s14
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800ad24:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
 800ad28:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ad2c:	4770      	bx	lr
 800ad2e:	bf00      	nop
 800ad30:	42c80000 	.word	0x42c80000

0800ad34 <s11_resonance_min>:
  return fabsf(reactance(i, measured[0][i]));
 800ad34:	4904      	ldr	r1, [pc, #16]	@ (800ad48 <s11_resonance_min+0x14>)
static float s11_resonance_min(uint16_t i) {
 800ad36:	b508      	push	{r3, lr}
  return fabsf(reactance(i, measured[0][i]));
 800ad38:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800ad3c:	f7ff ffe4 	bl	800ad08 <reactance>
}
 800ad40:	eeb0 0ac0 	vabs.f32	s0, s0
 800ad44:	bd08      	pop	{r3, pc}
 800ad46:	bf00      	nop
 800ad48:	20004f54 	.word	0x20004f54

0800ad4c <series_l>:
{
 800ad4c:	b508      	push	{r3, lr}
 800ad4e:	ed2d 8b02 	vpush	{d8}
  const float zi = reactance(i, v);
 800ad52:	f7ff ffd9 	bl	800ad08 <reactance>
 800ad56:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800ad5a:	f7fe fee7 	bl	8009b2c <get_w>
}
 800ad5e:	ee88 0a00 	vdiv.f32	s0, s16, s0
 800ad62:	ecbd 8b02 	vpop	{d8}
 800ad66:	bd08      	pop	{r3, pc}

0800ad68 <series_c>:
{
 800ad68:	b508      	push	{r3, lr}
 800ad6a:	ed2d 8b02 	vpush	{d8}
  const float zi = reactance(i, v);
 800ad6e:	f7ff ffcb 	bl	800ad08 <reactance>
 800ad72:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800ad76:	f7fe fed9 	bl	8009b2c <get_w>
  return -1.0f / (w * zi);
 800ad7a:	ee28 0a00 	vmul.f32	s0, s16, s0
}
 800ad7e:	ecbd 8b02 	vpop	{d8}
  return -1.0f / (w * zi);
 800ad82:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
}
 800ad86:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ad8a:	bd08      	pop	{r3, pc}

0800ad8c <prepare_lc_match>:
static void prepare_lc_match(uint8_t mode, uint8_t update_mask) {
 800ad8c:	b530      	push	{r4, r5, lr}
 800ad8e:	ed2d 8b04 	vpush	{d8-d9}
  freq_t freq = get_marker_frequency(active_marker);
 800ad92:	4d75      	ldr	r5, [pc, #468]	@ (800af68 <prepare_lc_match+0x1dc>)
static void prepare_lc_match(uint8_t mode, uint8_t update_mask) {
 800ad94:	b083      	sub	sp, #12
  freq_t freq = get_marker_frequency(active_marker);
 800ad96:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800ad9a:	f7fc fa35 	bl	8007208 <get_marker_frequency>
  if (freq == 0)// || lc_match_array->Hz == freq)
 800ad9e:	2800      	cmp	r0, #0
 800ada0:	f000 80de 	beq.w	800af60 <prepare_lc_match+0x1d4>
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800ada4:	f995 301d 	ldrsb.w	r3, [r5, #29]
  lc_match_array->R0 = PORT_Z; // 50.0f
 800ada8:	4c70      	ldr	r4, [pc, #448]	@ (800af6c <prepare_lc_match+0x1e0>)
  const float RL = resistance(index, coeff);
 800adaa:	4971      	ldr	r1, [pc, #452]	@ (800af70 <prepare_lc_match+0x1e4>)
  lc_match_array->Hz = freq;
 800adac:	6020      	str	r0, [r4, #0]
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800adae:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
  lc_match_array->R0 = PORT_Z; // 50.0f
 800adb2:	ed9f 9a70 	vldr	s18, [pc, #448]	@ 800af74 <prepare_lc_match+0x1e8>
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800adb6:	f8b5 005a 	ldrh.w	r0, [r5, #90]	@ 0x5a
  lc_match_array->R0 = PORT_Z; // 50.0f
 800adba:	ed84 9a01 	vstr	s18, [r4, #4]
  const float RL = resistance(index, coeff);
 800adbe:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800adc2:	f7fe fcd9 	bl	8009778 <resistance>
 800adc6:	eef0 8a40 	vmov.f32	s17, s0
  const float XL = reactance(index, coeff);
 800adca:	f7ff ff9d 	bl	800ad08 <reactance>
  if (RL <= 0.5f)
 800adce:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 800add2:	eef4 8ae7 	vcmpe.f32	s17, s15
 800add6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  const float XL = reactance(index, coeff);
 800adda:	eeb0 8a40 	vmov.f32	s16, s0
  if (RL <= 0.5f)
 800adde:	f240 80ad 	bls.w	800af3c <prepare_lc_match+0x1b0>
  const float vswr = swr(index, coeff);
 800ade2:	f7ff ff63 	bl	800acac <swr>
  if (vswr <= 1.1f || q_factor >= 100.0f)
 800ade6:	eddf 7a64 	vldr	s15, [pc, #400]	@ 800af78 <prepare_lc_match+0x1ec>
 800adea:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800adee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800adf2:	f240 80a6 	bls.w	800af42 <prepare_lc_match+0x1b6>
  const float q_factor = XL / RL;
 800adf6:	eec8 7a28 	vdiv.f32	s15, s16, s17
  if (vswr <= 1.1f || q_factor >= 100.0f)
 800adfa:	eddf 0a60 	vldr	s1, [pc, #384]	@ 800af7c <prepare_lc_match+0x1f0>
 800adfe:	eef4 7ae0 	vcmpe.f32	s15, s1
 800ae02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae06:	f280 809c 	bge.w	800af42 <prepare_lc_match+0x1b6>
  if ((RL * 1.1f) > R0 && RL < (R0 * 1.1f)) {
 800ae0a:	eddf 7a5d 	vldr	s15, [pc, #372]	@ 800af80 <prepare_lc_match+0x1f4>
 800ae0e:	eef4 8ae7 	vcmpe.f32	s17, s15
 800ae12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae16:	f04f 0500 	mov.w	r5, #0
 800ae1a:	dd0e      	ble.n	800ae3a <prepare_lc_match+0xae>
 800ae1c:	eddf 7a59 	vldr	s15, [pc, #356]	@ 800af84 <prepare_lc_match+0x1f8>
 800ae20:	eef4 8ae7 	vcmpe.f32	s17, s15
 800ae24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae28:	d512      	bpl.n	800ae50 <prepare_lc_match+0xc4>
    matches[0].xs  = -XL;
 800ae2a:	eeb1 8a48 	vneg.f32	s16, s16
    matches[0].xpl = 0.0f;
 800ae2e:	6125      	str	r5, [r4, #16]
    matches[0].xps = 0.0f;
 800ae30:	60a5      	str	r5, [r4, #8]
    matches[0].xs  = -XL;
 800ae32:	ed84 8a03 	vstr	s16, [r4, #12]
    return 1;
 800ae36:	2301      	movs	r3, #1
 800ae38:	e086      	b.n	800af48 <prepare_lc_match+0x1bc>
  if (RL >= R0 || RL * RL + XL * XL > R0 * RL) {
 800ae3a:	ee68 6a08 	vmul.f32	s13, s16, s16
 800ae3e:	ee68 7a89 	vmul.f32	s15, s17, s18
 800ae42:	eee8 6aa8 	vfma.f32	s13, s17, s17
 800ae46:	eef4 6ae7 	vcmpe.f32	s13, s15
 800ae4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae4e:	dd3d      	ble.n	800aecc <prepare_lc_match+0x140>
  const float c = R0 * (XL * XL + RL * RL);
 800ae50:	ee28 6aa8 	vmul.f32	s12, s17, s17
  match_quadratic_equation(a, b, c, xp);
 800ae54:	ee68 0a20 	vmul.f32	s1, s16, s1
  const float c = R0 * (XL * XL + RL * RL);
 800ae58:	eef0 6a46 	vmov.f32	s13, s12
 800ae5c:	eee8 6a08 	vfma.f32	s13, s16, s16
  match_quadratic_equation(a, b, c, xp);
 800ae60:	4668      	mov	r0, sp
 800ae62:	ee39 0a68 	vsub.f32	s0, s18, s17
 800ae66:	ee26 1a89 	vmul.f32	s2, s13, s18
 800ae6a:	f7fe fcdb 	bl	8009824 <match_quadratic_equation>
  const float XL1 = XL + xp[0];
 800ae6e:	eddd 7a00 	vldr	s15, [sp]
  matches[0].xps = 0.0f;
 800ae72:	60a5      	str	r5, [r4, #8]
  const float XL1 = XL + xp[0];
 800ae74:	ee38 7a27 	vadd.f32	s14, s16, s15
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800ae78:	eeb0 5a46 	vmov.f32	s10, s12
 800ae7c:	ee67 5aa7 	vmul.f32	s11, s15, s15
 800ae80:	eea7 5a07 	vfma.f32	s10, s14, s14
  matches[1].xps = 0.0f;
 800ae84:	6165      	str	r5, [r4, #20]
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800ae86:	ee65 5a87 	vmul.f32	s11, s11, s14
  matches[0].xpl = xp[0];
 800ae8a:	edc4 7a04 	vstr	s15, [r4, #16]
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800ae8e:	ee85 7a85 	vdiv.f32	s14, s11, s10
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800ae92:	eef4 8ac9 	vcmpe.f32	s17, s18
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800ae96:	ee37 7a67 	vsub.f32	s14, s14, s15
  const float XL2 = XL + xp[1];
 800ae9a:	eddd 7a01 	vldr	s15, [sp, #4]
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800ae9e:	ed84 7a03 	vstr	s14, [r4, #12]
  const float XL2 = XL + xp[1];
 800aea2:	ee38 7a27 	vadd.f32	s14, s16, s15
  matches[1].xs  = xp[1] * xp[1] * XL2 / (RL * RL + XL2 * XL2) - xp[1];
 800aea6:	ee67 5aa7 	vmul.f32	s11, s15, s15
 800aeaa:	eea7 6a07 	vfma.f32	s12, s14, s14
 800aeae:	ee65 5a87 	vmul.f32	s11, s11, s14
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800aeb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  matches[1].xs  = xp[1] * xp[1] * XL2 / (RL * RL + XL2 * XL2) - xp[1];
 800aeb6:	ee85 7a86 	vdiv.f32	s14, s11, s12
  matches[1].xpl = xp[1];
 800aeba:	edc4 7a07 	vstr	s15, [r4, #28]
  matches[1].xs  = xp[1] * xp[1] * XL2 / (RL * RL + XL2 * XL2) - xp[1];
 800aebe:	ee37 7a67 	vsub.f32	s14, s14, s15
 800aec2:	ed84 7a06 	vstr	s14, [r4, #24]
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800aec6:	da3e      	bge.n	800af46 <prepare_lc_match+0x1ba>
    n = 2;
 800aec8:	2202      	movs	r2, #2
 800aeca:	e000      	b.n	800aece <prepare_lc_match+0x142>
  int16_t n = 0;
 800aecc:	2200      	movs	r2, #0
  match_quadratic_equation(a, b, c, xs);
 800aece:	eee8 6ac9 	vfms.f32	s13, s17, s18
  lc_match_calc_lo(R0, RL, XL, &matches[n]);   // Compute Lo-Z solutions
 800aed2:	492d      	ldr	r1, [pc, #180]	@ (800af88 <prepare_lc_match+0x1fc>)
 800aed4:	230c      	movs	r3, #12
  match_quadratic_equation(a, b, c, xs);
 800aed6:	ee78 0a08 	vadd.f32	s1, s16, s16
 800aeda:	eeb0 1a66 	vmov.f32	s2, s13
 800aede:	4668      	mov	r0, sp
 800aee0:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
  lc_match_calc_lo(R0, RL, XL, &matches[n]);   // Compute Lo-Z solutions
 800aee4:	fb03 1102 	mla	r1, r3, r2, r1
  match_quadratic_equation(a, b, c, xs);
 800aee8:	f7fe fc9c 	bl	8009824 <match_quadratic_equation>
  const float XL1 = XL + xs[0];
 800aeec:	ed9d 7a00 	vldr	s14, [sp]
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800aef0:	eddf 6a26 	vldr	s13, [pc, #152]	@ 800af8c <prepare_lc_match+0x200>
  matches[0].xs  = xs[0];
 800aef4:	ed81 7a01 	vstr	s14, [r1, #4]
  const float XL1 = XL + xs[0];
 800aef8:	ee78 7a07 	vadd.f32	s15, s16, s14
  const float RL1 = RL - R0;
 800aefc:	ee78 8ac9 	vsub.f32	s17, s17, s18
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800af00:	ee27 7aa7 	vmul.f32	s14, s15, s15
 800af04:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800af08:	eea8 7aa8 	vfma.f32	s14, s17, s17
  matches[0].xpl = 0.0f;
 800af0c:	608d      	str	r5, [r1, #8]
  matches[1].xpl = 0.0f;
 800af0e:	614d      	str	r5, [r1, #20]
  return n + 2;
 800af10:	1c93      	adds	r3, r2, #2
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800af12:	ee87 6a87 	vdiv.f32	s12, s15, s14
  const float XL2 = XL + xs[1];
 800af16:	eddd 7a01 	vldr	s15, [sp, #4]
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800af1a:	ed81 6a00 	vstr	s12, [r1]
  const float XL2 = XL + xs[1];
 800af1e:	ee38 8a27 	vadd.f32	s16, s16, s15
  matches[1].xs  = xs[1];
 800af22:	edc1 7a04 	vstr	s15, [r1, #16]
  matches[1].xps = - R0 * R0 * XL2 / (RL1 * RL1 + XL2 * XL2);
 800af26:	ee68 7a08 	vmul.f32	s15, s16, s16
 800af2a:	ee28 8a26 	vmul.f32	s16, s16, s13
 800af2e:	eee8 7aa8 	vfma.f32	s15, s17, s17
 800af32:	ee88 7a27 	vdiv.f32	s14, s16, s15
 800af36:	ed81 7a03 	vstr	s14, [r1, #12]
  return n + 2;
 800af3a:	e005      	b.n	800af48 <prepare_lc_match+0x1bc>
    return -1;
 800af3c:	f04f 33ff 	mov.w	r3, #4294967295
 800af40:	e002      	b.n	800af48 <prepare_lc_match+0x1bc>
    return 0;
 800af42:	2300      	movs	r3, #0
 800af44:	e000      	b.n	800af48 <prepare_lc_match+0x1bc>
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800af46:	2302      	movs	r3, #2
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800af48:	8723      	strh	r3, [r4, #56]	@ 0x38
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800af4a:	2207      	movs	r2, #7
 800af4c:	2304      	movs	r3, #4
 800af4e:	2102      	movs	r1, #2
 800af50:	2000      	movs	r0, #0
}
 800af52:	b003      	add	sp, #12
 800af54:	ecbd 8b04 	vpop	{d8-d9}
 800af58:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800af5c:	f7fe bbe4 	b.w	8009728 <invalidate_rect_func>
}
 800af60:	b003      	add	sp, #12
 800af62:	ecbd 8b04 	vpop	{d8-d9}
 800af66:	bd30      	pop	{r4, r5, pc}
 800af68:	20000aa8 	.word	0x20000aa8
 800af6c:	200069b4 	.word	0x200069b4
 800af70:	20004f54 	.word	0x20004f54
 800af74:	42480000 	.word	0x42480000
 800af78:	3f8ccccd 	.word	0x3f8ccccd
 800af7c:	42c80000 	.word	0x42c80000
 800af80:	4235d174 	.word	0x4235d174
 800af84:	425c0000 	.word	0x425c0000
 800af88:	200069bc 	.word	0x200069bc
 800af8c:	c51c4000 	.word	0xc51c4000

0800af90 <s21shunt_r>:
  return get_s21_r(1.0f - v[0], -v[1], 0.5f * PORT_Z);
 800af90:	edd1 6a00 	vldr	s13, [r1]
 800af94:	ed91 7a01 	vldr	s14, [r1, #4]
 800af98:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800af9c:	ee77 7ae6 	vsub.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800afa0:	ee27 7a07 	vmul.f32	s14, s14, s14
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800afa4:	eef3 6a09 	vmov.f32	s13, #57	@ 0x41c80000  25.0
static float get_l(float re, float im) { return (re * re + im * im); }
 800afa8:	eea7 7aa7 	vfma.f32	s14, s15, s15
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800afac:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800afb0:	ee87 0a87 	vdiv.f32	s0, s15, s14
}
 800afb4:	ee30 0a66 	vsub.f32	s0, s0, s13
 800afb8:	4770      	bx	lr
 800afba:	bf00      	nop

0800afbc <s11_resonance_value>:
static float s11_resonance_value(uint16_t i) {
 800afbc:	4b02      	ldr	r3, [pc, #8]	@ (800afc8 <s11_resonance_value+0xc>)
 800afbe:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800afc2:	ed93 0a01 	vldr	s0, [r3, #4]
 800afc6:	4770      	bx	lr
 800afc8:	20004f54 	.word	0x20004f54

0800afcc <measure_get_value.constprop.0>:
  if (f < frequency0 || f > frequency1)
 800afcc:	4b3e      	ldr	r3, [pc, #248]	@ (800b0c8 <measure_get_value.constprop.0+0xfc>)
static bool measure_get_value(uint16_t ch, freq_t f, float *data){
 800afce:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (f < frequency0 || f > frequency1)
 800afd2:	685a      	ldr	r2, [r3, #4]
 800afd4:	4282      	cmp	r2, r0
 800afd6:	d872      	bhi.n	800b0be <measure_get_value.constprop.0+0xf2>
 800afd8:	689d      	ldr	r5, [r3, #8]
 800afda:	42a8      	cmp	r0, r5
 800afdc:	d86f      	bhi.n	800b0be <measure_get_value.constprop.0+0xf2>
  uint16_t _points = sweep_points - 1;
 800afde:	8b5e      	ldrh	r6, [r3, #26]
 800afe0:	3e01      	subs	r6, #1
 800afe2:	b2b6      	uxth	r6, r6
  uint32_t idx = (uint64_t)(f - frequency0) * (uint64_t)_points / span;
 800afe4:	f04f 0b00 	mov.w	fp, #0
  freq_t span = frequency1 - frequency0;
 800afe8:	1aad      	subs	r5, r5, r2
  uint32_t idx = (uint64_t)(f - frequency0) * (uint64_t)_points / span;
 800afea:	1a84      	subs	r4, r0, r2
 800afec:	465b      	mov	r3, fp
 800afee:	462a      	mov	r2, r5
 800aff0:	468a      	mov	sl, r1
 800aff2:	fba4 0106 	umull	r0, r1, r4, r6
 800aff6:	f7f5 fc89 	bl	800090c <__aeabi_uldivmod>
  uint64_t v = (uint64_t)span * idx + _points/2;
 800affa:	ea4f 0856 	mov.w	r8, r6, lsr #1
 800affe:	465b      	mov	r3, fp
 800b000:	fbe5 8300 	umlal	r8, r3, r5, r0
 800b004:	9301      	str	r3, [sp, #4]
  freq_t src_f0 = frequency0 + (v       ) / _points;
 800b006:	4632      	mov	r2, r6
 800b008:	465b      	mov	r3, fp
 800b00a:	9901      	ldr	r1, [sp, #4]
  uint32_t idx = (uint64_t)(f - frequency0) * (uint64_t)_points / span;
 800b00c:	4607      	mov	r7, r0
  freq_t src_f0 = frequency0 + (v       ) / _points;
 800b00e:	4640      	mov	r0, r8
 800b010:	f7f5 fc7c 	bl	800090c <__aeabi_uldivmod>
  freq_t src_f1 = frequency0 + (v + span) / _points;
 800b014:	9901      	ldr	r1, [sp, #4]
  freq_t src_f0 = frequency0 + (v       ) / _points;
 800b016:	4681      	mov	r9, r0
  freq_t src_f1 = frequency0 + (v + span) / _points;
 800b018:	eb15 0008 	adds.w	r0, r5, r8
 800b01c:	f141 0100 	adc.w	r1, r1, #0
 800b020:	4632      	mov	r2, r6
 800b022:	465b      	mov	r3, fp
 800b024:	f7f5 fc72 	bl	800090c <__aeabi_uldivmod>
  float k1 = (delta == 0) ? 0.0f : (float)(f - src_f0) / delta;
 800b028:	ebb0 0009 	subs.w	r0, r0, r9
 800b02c:	d00c      	beq.n	800b048 <measure_get_value.constprop.0+0x7c>
 800b02e:	eba4 0409 	sub.w	r4, r4, r9
 800b032:	ee07 4a90 	vmov	s15, r4
 800b036:	ee07 0a10 	vmov	s14, r0
 800b03a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800b03e:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 800b042:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800b046:	e001      	b.n	800b04c <measure_get_value.constprop.0+0x80>
 800b048:	eddf 6a20 	vldr	s13, [pc, #128]	@ 800b0cc <measure_get_value.constprop.0+0x100>
  data[0] = bilinear_interpolation(measured[ch][idx-1][0], measured[ch][idx  ][0], measured[ch][idx+1][0],k1);
 800b04c:	4b20      	ldr	r3, [pc, #128]	@ (800b0d0 <measure_get_value.constprop.0+0x104>)
 800b04e:	1e7a      	subs	r2, r7, #1
 800b050:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 800b054:	3701      	adds	r7, #1
 800b056:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 800b05a:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 800b05e:	ed92 5a00 	vldr	s10, [r2]
 800b062:	edd3 5a00 	vldr	s11, [r3]
 800b066:	ed91 7a00 	vldr	s14, [r1]
  const float a = 0.5f * (y1 + y3) - y2;
 800b06a:	ee75 4a25 	vadd.f32	s9, s10, s11
 800b06e:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 800b072:	eef0 7a47 	vmov.f32	s15, s14
 800b076:	eed4 7a86 	vfnms.f32	s15, s9, s12
  return true;
 800b07a:	2001      	movs	r0, #1
  const float b = 0.5f * (y3 - y1);
 800b07c:	ee75 5ac5 	vsub.f32	s11, s11, s10
  return a * x * x + b * x + c;
 800b080:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800b084:	eee5 7a86 	vfma.f32	s15, s11, s12
 800b088:	eea6 7aa7 	vfma.f32	s14, s13, s15
  data[0] = bilinear_interpolation(measured[ch][idx-1][0], measured[ch][idx  ][0], measured[ch][idx+1][0],k1);
 800b08c:	ed8a 7a00 	vstr	s14, [sl]
  data[1] = bilinear_interpolation(measured[ch][idx-1][1], measured[ch][idx  ][1], measured[ch][idx+1][1],k1);
 800b090:	ed92 5a01 	vldr	s10, [r2, #4]
 800b094:	edd3 5a01 	vldr	s11, [r3, #4]
 800b098:	ed91 7a01 	vldr	s14, [r1, #4]
  const float a = 0.5f * (y1 + y3) - y2;
 800b09c:	ee75 4a25 	vadd.f32	s9, s10, s11
 800b0a0:	eef0 7a47 	vmov.f32	s15, s14
 800b0a4:	eed4 7a86 	vfnms.f32	s15, s9, s12
  const float b = 0.5f * (y3 - y1);
 800b0a8:	ee75 5ac5 	vsub.f32	s11, s11, s10
  return a * x * x + b * x + c;
 800b0ac:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800b0b0:	eee5 7a86 	vfma.f32	s15, s11, s12
 800b0b4:	eea6 7aa7 	vfma.f32	s14, s13, s15
  data[1] = bilinear_interpolation(measured[ch][idx-1][1], measured[ch][idx  ][1], measured[ch][idx+1][1],k1);
 800b0b8:	ed8a 7a01 	vstr	s14, [sl, #4]
  return true;
 800b0bc:	e000      	b.n	800b0c0 <measure_get_value.constprop.0+0xf4>
    return false;
 800b0be:	2000      	movs	r0, #0
}
 800b0c0:	b003      	add	sp, #12
 800b0c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b0c6:	bf00      	nop
 800b0c8:	20000aa8 	.word	0x20000aa8
 800b0cc:	00000000 	.word	0x00000000
 800b0d0:	20004f54 	.word	0x20004f54

0800b0d4 <add_resonance_value>:

static bool add_resonance_value(int i, uint16_t x, freq_t f) {
 800b0d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b0d6:	4604      	mov	r4, r0
 800b0d8:	460f      	mov	r7, r1
  float data[2];
  if (measure_get_value(0, f, data)) {
 800b0da:	4610      	mov	r0, r2
 800b0dc:	4669      	mov	r1, sp
static bool add_resonance_value(int i, uint16_t x, freq_t f) {
 800b0de:	4616      	mov	r6, r2
  if (measure_get_value(0, f, data)) {
 800b0e0:	f7ff ff74 	bl	800afcc <measure_get_value.constprop.0>
 800b0e4:	4605      	mov	r5, r0
 800b0e6:	b170      	cbz	r0, 800b106 <add_resonance_value+0x32>
    s11_resonance->data[i].f = f;
 800b0e8:	230c      	movs	r3, #12
 800b0ea:	4908      	ldr	r1, [pc, #32]	@ (800b10c <add_resonance_value+0x38>)
 800b0ec:	4363      	muls	r3, r4
 800b0ee:	18ca      	adds	r2, r1, r3
 800b0f0:	50ce      	str	r6, [r1, r3]
    //set_marker_index(i, x);
    s11_resonance->data[i].r = resistance(x, data);
 800b0f2:	4638      	mov	r0, r7
 800b0f4:	4669      	mov	r1, sp
 800b0f6:	f7fe fb3f 	bl	8009778 <resistance>
 800b0fa:	ed82 0a01 	vstr	s0, [r2, #4]
    s11_resonance->data[i].x = reactance(x, data);
 800b0fe:	f7ff fe03 	bl	800ad08 <reactance>
 800b102:	ed82 0a02 	vstr	s0, [r2, #8]
    return true;
  }
  return false;
}
 800b106:	4628      	mov	r0, r5
 800b108:	b003      	add	sp, #12
 800b10a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b10c:	200069b4 	.word	0x200069b4

0800b110 <prepare_s11_resonance>:

static void prepare_s11_resonance(uint8_t type, uint8_t update_mask) {
 800b110:	b530      	push	{r4, r5, lr}
 800b112:	ed2d 8b02 	vpush	{d8}
  (void)type;
  if (update_mask & MEASURE_UPD_SWEEP) {
 800b116:	07cb      	lsls	r3, r1, #31
static void prepare_s11_resonance(uint8_t type, uint8_t update_mask) {
 800b118:	b083      	sub	sp, #12
  if (update_mask & MEASURE_UPD_SWEEP) {
 800b11a:	d538      	bpl.n	800b18e <prepare_s11_resonance+0x7e>
    int i;
    freq_t f;
    uint16_t x = 0;
 800b11c:	2400      	movs	r4, #0
    // Search resonances (X == 0)
    for (i = 0; i < MEASURE_RESONANCE_COUNT && i < MARKERS_MAX;) {
      f = measure_search_value(&x, 0.0f, s11_resonance_value, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800b11e:	ed9f 8a21 	vldr	s16, [pc, #132]	@ 800b1a4 <prepare_s11_resonance+0x94>
    uint16_t x = 0;
 800b122:	f8ad 4006 	strh.w	r4, [sp, #6]
      f = measure_search_value(&x, 0.0f, s11_resonance_value, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800b126:	2201      	movs	r2, #1
 800b128:	491f      	ldr	r1, [pc, #124]	@ (800b1a8 <prepare_s11_resonance+0x98>)
 800b12a:	f04f 33ff 	mov.w	r3, #4294967295
 800b12e:	eeb0 0a48 	vmov.f32	s0, s16
 800b132:	f10d 0006 	add.w	r0, sp, #6
 800b136:	f7fe fd19 	bl	8009b6c <measure_search_value>
 800b13a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800b13e:	ee17 2a90 	vmov	r2, s15
      if (f == 0) break;
 800b142:	b162      	cbz	r2, 800b15e <prepare_s11_resonance+0x4e>
      if (add_resonance_value(i, x, f))
 800b144:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800b148:	4620      	mov	r0, r4
 800b14a:	4629      	mov	r1, r5
 800b14c:	f7ff ffc2 	bl	800b0d4 <add_resonance_value>
 800b150:	4404      	add	r4, r0
        i++;
      x++;
 800b152:	3501      	adds	r5, #1
    for (i = 0; i < MEASURE_RESONANCE_COUNT && i < MARKERS_MAX;) {
 800b154:	2c06      	cmp	r4, #6
      x++;
 800b156:	f8ad 5006 	strh.w	r5, [sp, #6]
    for (i = 0; i < MEASURE_RESONANCE_COUNT && i < MARKERS_MAX;) {
 800b15a:	d1e4      	bne.n	800b126 <prepare_s11_resonance+0x16>
 800b15c:	e014      	b.n	800b188 <prepare_s11_resonance+0x78>
    }
    if (i == 0) { // Search minimum position, if resonances not found
 800b15e:	b99c      	cbnz	r4, 800b188 <prepare_s11_resonance+0x78>
      x = 0;
      search_peak_value(&x, s11_resonance_min, MEASURE_SEARCH_MIN);
 800b160:	4912      	ldr	r1, [pc, #72]	@ (800b1ac <prepare_s11_resonance+0x9c>)
      x = 0;
 800b162:	f8ad 4006 	strh.w	r4, [sp, #6]
      search_peak_value(&x, s11_resonance_min, MEASURE_SEARCH_MIN);
 800b166:	4622      	mov	r2, r4
 800b168:	f10d 0006 	add.w	r0, sp, #6
 800b16c:	f7ff fa88 	bl	800a680 <search_peak_value.constprop.0>
      if (x && add_resonance_value(0, x, getFrequency(x)))
 800b170:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800b174:	b145      	cbz	r5, 800b188 <prepare_s11_resonance+0x78>
 800b176:	4628      	mov	r0, r5
 800b178:	f7fb fa20 	bl	80065bc <getFrequency>
 800b17c:	4629      	mov	r1, r5
 800b17e:	4602      	mov	r2, r0
 800b180:	4620      	mov	r0, r4
 800b182:	f7ff ffa7 	bl	800b0d4 <add_resonance_value>
 800b186:	4604      	mov	r4, r0
        i = 1;
    }
    s11_resonance->count = i;
 800b188:	4b09      	ldr	r3, [pc, #36]	@ (800b1b0 <prepare_s11_resonance+0xa0>)
 800b18a:	f883 4048 	strb.w	r4, [r3, #72]	@ 0x48
  }
  // Prepare for update
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b18e:	2305      	movs	r3, #5
 800b190:	2207      	movs	r2, #7
 800b192:	2102      	movs	r1, #2
 800b194:	2000      	movs	r0, #0
                  STR_MEASURE_X + 3 * STR_MEASURE_WIDTH, STR_MEASURE_Y + (MEASURE_RESONANCE_COUNT + 1) * STR_MEASURE_HEIGHT);
}
 800b196:	b003      	add	sp, #12
 800b198:	ecbd 8b02 	vpop	{d8}
 800b19c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b1a0:	f7fe bac2 	b.w	8009728 <invalidate_rect_func>
 800b1a4:	00000000 	.word	0x00000000
 800b1a8:	0800afbd 	.word	0x0800afbd
 800b1ac:	0800ad35 	.word	0x0800ad35
 800b1b0:	200069b4 	.word	0x200069b4

0800b1b4 <update_grid>:
{
 800b1b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (fspan == 0)
 800b1b6:	1a0d      	subs	r5, r1, r0
 800b1b8:	d02b      	beq.n	800b212 <update_grid+0x5e>
  freq_t dgrid = 1000000000, grid; // Max grid step = pattern * 1GHz grid
 800b1ba:	4c1b      	ldr	r4, [pc, #108]	@ (800b228 <update_grid+0x74>)
  } while (dgrid /= 10);
 800b1bc:	4a1b      	ldr	r2, [pc, #108]	@ (800b22c <update_grid+0x78>)
 800b1be:	f04f 0e0a 	mov.w	lr, #10
 800b1c2:	e000      	b.n	800b1c6 <update_grid+0x12>
 800b1c4:	4664      	mov	r4, ip
 800b1c6:	fba2 3c04 	umull	r3, ip, r2, r4
    k = fspan / grid;
 800b1ca:	fbb5 f3f4 	udiv	r3, r5, r4
    if (k >= N * 5)
 800b1ce:	2b13      	cmp	r3, #19
  } while (dgrid /= 10);
 800b1d0:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
    if (k >= N * 5)
 800b1d4:	d822      	bhi.n	800b21c <update_grid+0x68>
    if (k >= N * 2)
 800b1d6:	2b07      	cmp	r3, #7
 800b1d8:	d823      	bhi.n	800b222 <update_grid+0x6e>
    if (k >= N * 1)
 800b1da:	2b03      	cmp	r3, #3
 800b1dc:	d802      	bhi.n	800b1e4 <update_grid+0x30>
  } while (dgrid /= 10);
 800b1de:	f1be 0e01 	subs.w	lr, lr, #1
 800b1e2:	d1ef      	bne.n	800b1c4 <update_grid+0x10>
  grid_offset = ((uint64_t)(fstart % grid) * (WIDTH << GRID_BITS)) / fspan;
 800b1e4:	fbb0 f3f4 	udiv	r3, r0, r4
 800b1e8:	f24e 3680 	movw	r6, #58240	@ 0xe380
 800b1ec:	fb04 0013 	mls	r0, r4, r3, r0
 800b1f0:	462a      	mov	r2, r5
 800b1f2:	2300      	movs	r3, #0
 800b1f4:	fba0 0106 	umull	r0, r1, r0, r6
 800b1f8:	f7f5 fb88 	bl	800090c <__aeabi_uldivmod>
 800b1fc:	4f0c      	ldr	r7, [pc, #48]	@ (800b230 <update_grid+0x7c>)
  grid_width = ((uint64_t)grid * (WIDTH << GRID_BITS)) / fspan;
 800b1fe:	462a      	mov	r2, r5
  grid_offset = ((uint64_t)(fstart % grid) * (WIDTH << GRID_BITS)) / fspan;
 800b200:	8038      	strh	r0, [r7, #0]
  grid_width = ((uint64_t)grid * (WIDTH << GRID_BITS)) / fspan;
 800b202:	2300      	movs	r3, #0
 800b204:	fba4 0106 	umull	r0, r1, r4, r6
 800b208:	f7f5 fb80 	bl	800090c <__aeabi_uldivmod>
 800b20c:	4c09      	ldr	r4, [pc, #36]	@ (800b234 <update_grid+0x80>)
 800b20e:	8020      	strh	r0, [r4, #0]
}
 800b210:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    grid_offset = grid_width = 0;
 800b212:	4a08      	ldr	r2, [pc, #32]	@ (800b234 <update_grid+0x80>)
 800b214:	4b06      	ldr	r3, [pc, #24]	@ (800b230 <update_grid+0x7c>)
 800b216:	8015      	strh	r5, [r2, #0]
 800b218:	801d      	strh	r5, [r3, #0]
}
 800b21a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      grid *= 5;
 800b21c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
      break;
 800b220:	e7e0      	b.n	800b1e4 <update_grid+0x30>
      grid *= 2;
 800b222:	0064      	lsls	r4, r4, #1
      break;
 800b224:	e7de      	b.n	800b1e4 <update_grid+0x30>
 800b226:	bf00      	nop
 800b228:	3b9aca00 	.word	0x3b9aca00
 800b22c:	cccccccd 	.word	0xcccccccd
 800b230:	20006a38 	.word	0x20006a38
 800b234:	20006a36 	.word	0x20006a36

0800b238 <get_trace_typename>:
  if (t == TRC_SMITH && ADMIT_MARKER_VALUE(marker_smith_format))
 800b238:	2803      	cmp	r0, #3
 800b23a:	d005      	beq.n	800b248 <get_trace_typename+0x10>
  return trace_info_list[t].name;
 800b23c:	4b06      	ldr	r3, [pc, #24]	@ (800b258 <get_trace_typename+0x20>)
 800b23e:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 800b242:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800b246:	4770      	bx	lr
  if (t == TRC_SMITH && ADMIT_MARKER_VALUE(marker_smith_format))
 800b248:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800b24c:	410b      	asrs	r3, r1
 800b24e:	07db      	lsls	r3, r3, #31
 800b250:	d5f4      	bpl.n	800b23c <get_trace_typename+0x4>
    return "ADMIT";
 800b252:	4802      	ldr	r0, [pc, #8]	@ (800b25c <get_trace_typename+0x24>)
}
 800b254:	4770      	bx	lr
 800b256:	bf00      	nop
 800b258:	08014540 	.word	0x08014540
 800b25c:	08011d38 	.word	0x08011d38

0800b260 <request_to_draw_marker>:
{
 800b260:	b570      	push	{r4, r5, r6, lr}
 800b262:	4c15      	ldr	r4, [pc, #84]	@ (800b2b8 <request_to_draw_marker+0x58>)
 800b264:	4d15      	ldr	r5, [pc, #84]	@ (800b2bc <request_to_draw_marker+0x5c>)
 800b266:	f104 0630 	add.w	r6, r4, #48	@ 0x30
 800b26a:	eb05 0580 	add.w	r5, r5, r0, lsl #2
    if (!trace[t].enabled)
 800b26e:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 800b272:	b1db      	cbz	r3, 800b2ac <request_to_draw_marker+0x4c>
    int y = index[mk_idx].y + ((index[mk_idx].y < MARKER_HEIGHT * 2) ? 1 : -Y_MARKER_OFFSET);
 800b274:	8869      	ldrh	r1, [r5, #2]
    int x = index[mk_idx].x - X_MARKER_OFFSET;
 800b276:	8828      	ldrh	r0, [r5, #0]
    int y = index[mk_idx].y + ((index[mk_idx].y < MARKER_HEIGHT * 2) ? 1 : -Y_MARKER_OFFSET);
 800b278:	291b      	cmp	r1, #27
 800b27a:	bf8c      	ite	hi
 800b27c:	f06f 030d 	mvnhi.w	r3, #13
 800b280:	2301      	movls	r3, #1
 800b282:	4419      	add	r1, r3
    invalidate_rect(x, y, x + MARKER_WIDTH - 1, y + MARKER_HEIGHT - 1);
 800b284:	f111 030d 	adds.w	r3, r1, #13
 800b288:	f100 0205 	add.w	r2, r0, #5
 800b28c:	bf48      	it	mi
 800b28e:	f101 032c 	addmi.w	r3, r1, #44	@ 0x2c
    int x = index[mk_idx].x - X_MARKER_OFFSET;
 800b292:	3805      	subs	r0, #5
    invalidate_rect(x, y, x + MARKER_WIDTH - 1, y + MARKER_HEIGHT - 1);
 800b294:	2900      	cmp	r1, #0
 800b296:	bfb8      	it	lt
 800b298:	311f      	addlt	r1, #31
 800b29a:	2800      	cmp	r0, #0
 800b29c:	bfb8      	it	lt
 800b29e:	301f      	addlt	r0, #31
 800b2a0:	1152      	asrs	r2, r2, #5
 800b2a2:	115b      	asrs	r3, r3, #5
 800b2a4:	1149      	asrs	r1, r1, #5
 800b2a6:	1140      	asrs	r0, r0, #5
 800b2a8:	f7fe fa3e 	bl	8009728 <invalidate_rect_func>
  for (int t = 0; t < TRACES_MAX; t++)
 800b2ac:	340c      	adds	r4, #12
 800b2ae:	42a6      	cmp	r6, r4
 800b2b0:	f205 6544 	addw	r5, r5, #1604	@ 0x644
 800b2b4:	d1db      	bne.n	800b26e <request_to_draw_marker+0xe>
}
 800b2b6:	bd70      	pop	{r4, r5, r6, pc}
 800b2b8:	20000aa8 	.word	0x20000aa8
 800b2bc:	20006a3c 	.word	0x20006a3c

0800b2c0 <markmap_all_markers>:
{
 800b2c0:	b570      	push	{r4, r5, r6, lr}
 800b2c2:	4c0b      	ldr	r4, [pc, #44]	@ (800b2f0 <markmap_all_markers+0x30>)
 800b2c4:	f104 0540 	add.w	r5, r4, #64	@ 0x40
    if (!markers[i].enabled)
 800b2c8:	f894 3058 	ldrb.w	r3, [r4, #88]	@ 0x58
 800b2cc:	b11b      	cbz	r3, 800b2d6 <markmap_all_markers+0x16>
    request_to_draw_marker(markers[i].index);
 800b2ce:	f8b4 005a 	ldrh.w	r0, [r4, #90]	@ 0x5a
 800b2d2:	f7ff ffc5 	bl	800b260 <request_to_draw_marker>
  for (i = 0; i < MARKERS_MAX; i++)
 800b2d6:	3408      	adds	r4, #8
 800b2d8:	42ac      	cmp	r4, r5
 800b2da:	d1f5      	bne.n	800b2c8 <markmap_all_markers+0x8>
  invalidate_rect(0, 0, AREA_WIDTH_NORMAL, marker_area_max());
 800b2dc:	f7ff f94c 	bl	800a578 <marker_area_max>
 800b2e0:	2100      	movs	r1, #0
 800b2e2:	1143      	asrs	r3, r0, #5
}
 800b2e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  invalidate_rect(0, 0, AREA_WIDTH_NORMAL, marker_area_max());
 800b2e8:	220e      	movs	r2, #14
 800b2ea:	4608      	mov	r0, r1
 800b2ec:	f7fe ba1c 	b.w	8009728 <invalidate_rect_func>
 800b2f0:	20000aa8 	.word	0x20000aa8

0800b2f4 <prepare_series>:
static void prepare_series(uint8_t type, uint8_t update_mask) {
 800b2f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b2f8:	ed2d 8b02 	vpush	{d8}
  s21_measure->freq  = 0;
 800b2fc:	4c67      	ldr	r4, [pc, #412]	@ (800b49c <prepare_series+0x1a8>)
 800b2fe:	2500      	movs	r5, #0
  switch (type){
 800b300:	2803      	cmp	r0, #3
static void prepare_series(uint8_t type, uint8_t update_mask) {
 800b302:	b082      	sub	sp, #8
  s21_measure->freq1 = 0;
 800b304:	e9c4 5501 	strd	r5, r5, [r4, #4]
  switch (type){
 800b308:	f000 8082 	beq.w	800b410 <prepare_series+0x11c>
 800b30c:	2804      	cmp	r0, #4
 800b30e:	4606      	mov	r6, r0
 800b310:	f000 8081 	beq.w	800b416 <prepare_series+0x122>
 800b314:	2802      	cmp	r0, #2
 800b316:	f040 80bb 	bne.w	800b490 <prepare_series+0x19c>
  s21_measure->r = config._measure_r * att / (2.0f * (1.0f - att));
 800b31a:	f8df 8198 	ldr.w	r8, [pc, #408]	@ 800b4b4 <prepare_series+0x1c0>
  s21_measure->header = "LC-SHUNT";
 800b31e:	4b60      	ldr	r3, [pc, #384]	@ (800b4a0 <prepare_series+0x1ac>)
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800b320:	4960      	ldr	r1, [pc, #384]	@ (800b4a4 <prepare_series+0x1b0>)
  uint16_t xp = 0, x2;
 800b322:	f8ad 5004 	strh.w	r5, [sp, #4]
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800b326:	462a      	mov	r2, r5
 800b328:	a801      	add	r0, sp, #4
  s21_measure->header = "LC-SHUNT";
 800b32a:	6023      	str	r3, [r4, #0]
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800b32c:	f7ff f9a8 	bl	800a680 <search_peak_value.constprop.0>
 800b330:	eeb1 0ac0 	vsqrt.f32	s0, s0
  s21_measure->r = config._measure_r * att / (2.0f * (1.0f - att));
 800b334:	edd8 7a1a 	vldr	s15, [r8, #104]	@ 0x68
 800b338:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 800b33c:	ee67 7a87 	vmul.f32	s15, s15, s14
 800b340:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800b344:	ee67 7a80 	vmul.f32	s15, s15, s0
 800b348:	ee37 7a40 	vsub.f32	s14, s14, s0
 800b34c:	eec7 6a87 	vdiv.f32	s13, s15, s14
  if(s21_measure->r < 0.0f) return;
 800b350:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 800b354:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  s21_measure->r = config._measure_r * att / (2.0f * (1.0f - att));
 800b358:	edc4 6a07 	vstr	s13, [r4, #28]
  if(s21_measure->r < 0.0f) return;
 800b35c:	f100 808b 	bmi.w	800b476 <prepare_series+0x182>
  set_marker_index(0, xp);
 800b360:	f8bd 7004 	ldrh.w	r7, [sp, #4]
 800b364:	4628      	mov	r0, r5
 800b366:	4639      	mov	r1, r7
 800b368:	f7fb fe10 	bl	8006f8c <set_marker_index>
  float tan45 = config._measure_r/(config._measure_r + 4.0f * s21_measure->r);
 800b36c:	edd8 7a1a 	vldr	s15, [r8, #104]	@ 0x68
 800b370:	ed94 6a07 	vldr	s12, [r4, #28]
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b374:	494c      	ldr	r1, [pc, #304]	@ (800b4a8 <prepare_series+0x1b4>)
  x2 = xp;
 800b376:	f8ad 7006 	strh.w	r7, [sp, #6]
  float tan45 = config._measure_r/(config._measure_r + 4.0f * s21_measure->r);
 800b37a:	eef1 6a00 	vmov.f32	s13, #16	@ 0x40800000  4.0
 800b37e:	eeb0 7a67 	vmov.f32	s14, s15
 800b382:	eea6 7a26 	vfma.f32	s14, s12, s13
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b386:	2301      	movs	r3, #1
 800b388:	f04f 32ff 	mov.w	r2, #4294967295
 800b38c:	f10d 0006 	add.w	r0, sp, #6
  float tan45 = config._measure_r/(config._measure_r + 4.0f * s21_measure->r);
 800b390:	eec7 8a87 	vdiv.f32	s17, s15, s14
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b394:	eeb1 0a68 	vneg.f32	s0, s17
 800b398:	f7fe fbe8 	bl	8009b6c <measure_search_value>
  if (f1 == 0) return;
 800b39c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b3a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b3a4:	eeb0 8a40 	vmov.f32	s16, s0
  if (f1 == 0) return;
 800b3a8:	d065      	beq.n	800b476 <prepare_series+0x182>
  float f2 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800b3aa:	493f      	ldr	r1, [pc, #252]	@ (800b4a8 <prepare_series+0x1b4>)
  x2 = xp;
 800b3ac:	f8ad 7006 	strh.w	r7, [sp, #6]
  float f2 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800b3b0:	4633      	mov	r3, r6
 800b3b2:	2201      	movs	r2, #1
 800b3b4:	eeb0 0a68 	vmov.f32	s0, s17
 800b3b8:	f10d 0006 	add.w	r0, sp, #6
 800b3bc:	f7fe fbd6 	bl	8009b6c <measure_search_value>
  if (f2 == 0) return;
 800b3c0:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b3c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b3c8:	d055      	beq.n	800b476 <prepare_series+0x182>
  float bw = f2 - f1;
 800b3ca:	ee70 7a48 	vsub.f32	s15, s0, s16
  float fpeak = vna_sqrtf(f2 * f1);
 800b3ce:	ee28 0a00 	vmul.f32	s0, s16, s0
 800b3d2:	eeb1 0ac0 	vsqrt.f32	s0, s0
  s21_measure->freq = fpeak;
 800b3d6:	eebc 7ac0 	vcvt.u32.f32	s14, s0
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800b3da:	eddf 6a34 	vldr	s13, [pc, #208]	@ 800b4ac <prepare_series+0x1b8>
  s21_measure->freq = fpeak;
 800b3de:	ed84 7a01 	vstr	s14, [r4, #4]
  s21_measure->q = fpeak / bw;
 800b3e2:	ee80 7a27 	vdiv.f32	s14, s0, s15
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800b3e6:	ee20 0a00 	vmul.f32	s0, s0, s0
  s21_measure->q = fpeak / bw;
 800b3ea:	ed84 7a08 	vstr	s14, [r4, #32]
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800b3ee:	ed94 7a07 	vldr	s14, [r4, #28]
 800b3f2:	ee67 5a26 	vmul.f32	s11, s14, s13
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800b3f6:	ee20 0a07 	vmul.f32	s0, s0, s14
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800b3fa:	ee85 6aa7 	vdiv.f32	s12, s11, s15
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800b3fe:	ee67 7aa6 	vmul.f32	s15, s15, s13
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800b402:	ed84 6a04 	vstr	s12, [r4, #16]
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800b406:	ee87 7a80 	vdiv.f32	s14, s15, s0
 800b40a:	ed84 7a05 	vstr	s14, [r4, #20]
 800b40e:	e032      	b.n	800b476 <prepare_series+0x182>
    case MEASURE_SERIES_LC:   n = 4;   analysis_lcseries(); break;
 800b410:	f7ff f9f4 	bl	800a7fc <analysis_lcseries>
 800b414:	e02f      	b.n	800b476 <prepare_series+0x182>
  analysis_lcseries();
 800b416:	f7ff f9f1 	bl	800a7fc <analysis_lcseries>
  s21_measure->header = "XTAL-SERIES";
 800b41a:	4b25      	ldr	r3, [pc, #148]	@ (800b4b0 <prepare_series+0x1bc>)
  search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800b41c:	4921      	ldr	r1, [pc, #132]	@ (800b4a4 <prepare_series+0x1b0>)
  uint16_t xp=0;
 800b41e:	f8ad 5006 	strh.w	r5, [sp, #6]
  search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800b422:	462a      	mov	r2, r5
 800b424:	f10d 0006 	add.w	r0, sp, #6
  s21_measure->header = "XTAL-SERIES";
 800b428:	6023      	str	r3, [r4, #0]
  search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800b42a:	f7ff f929 	bl	800a680 <search_peak_value.constprop.0>
  if (xp == 0) return;
 800b42e:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800b432:	b305      	cbz	r5, 800b476 <prepare_series+0x182>
  set_marker_index(3, xp);
 800b434:	4629      	mov	r1, r5
 800b436:	2003      	movs	r0, #3
 800b438:	f7fb fda8 	bl	8006f8c <set_marker_index>
  freq_t freq1 = getFrequency(xp);
 800b43c:	4628      	mov	r0, r5
 800b43e:	f7fb f8bd 	bl	80065bc <getFrequency>
  if(freq1 < s21_measure->freq) return;
 800b442:	6863      	ldr	r3, [r4, #4]
 800b444:	4298      	cmp	r0, r3
 800b446:	d316      	bcc.n	800b476 <prepare_series+0x182>
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800b448:	ed94 7a05 	vldr	s14, [r4, #20]
  s21_measure->freq1 = freq1;
 800b44c:	60a0      	str	r0, [r4, #8]
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800b44e:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 800b452:	ee27 7a27 	vmul.f32	s14, s14, s15
 800b456:	ee07 3a90 	vmov	s15, r3
 800b45a:	eef8 7a67 	vcvt.f32.u32	s15, s15
  s21_measure->df = s21_measure->freq1 - s21_measure->freq;
 800b45e:	1ac0      	subs	r0, r0, r3
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800b460:	ee27 7a27 	vmul.f32	s14, s14, s15
 800b464:	ee07 0a90 	vmov	s15, r0
 800b468:	eef8 7a67 	vcvt.f32.u32	s15, s15
  s21_measure->df = s21_measure->freq1 - s21_measure->freq;
 800b46c:	60e0      	str	r0, [r4, #12]
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800b46e:	eec7 6a27 	vdiv.f32	s13, s14, s15
 800b472:	edc4 6a06 	vstr	s13, [r4, #24]
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b476:	2304      	movs	r3, #4
 800b478:	2207      	movs	r2, #7
 800b47a:	2102      	movs	r1, #2
 800b47c:	2000      	movs	r0, #0
 800b47e:	f7fe f953 	bl	8009728 <invalidate_rect_func>
}
 800b482:	b002      	add	sp, #8
 800b484:	ecbd 8b02 	vpop	{d8}
 800b488:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  markmap_all_markers();
 800b48c:	f7ff bf18 	b.w	800b2c0 <markmap_all_markers>
}
 800b490:	b002      	add	sp, #8
 800b492:	ecbd 8b02 	vpop	{d8}
 800b496:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b49a:	bf00      	nop
 800b49c:	200069b4 	.word	0x200069b4
 800b4a0:	08012aed 	.word	0x08012aed
 800b4a4:	08009889 	.word	0x08009889
 800b4a8:	080098b1 	.word	0x080098b1
 800b4ac:	3e22f983 	.word	0x3e22f983
 800b4b0:	08012af6 	.word	0x08012af6
 800b4b4:	20000318 	.word	0x20000318

0800b4b8 <marker_search>:
{
 800b4b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (current_trace == TRACE_INVALID || active_marker == MARKER_INVALID)
 800b4bc:	4e19      	ldr	r6, [pc, #100]	@ (800b524 <marker_search+0x6c>)
 800b4be:	f996 301c 	ldrsb.w	r3, [r6, #28]
 800b4c2:	1c59      	adds	r1, r3, #1
 800b4c4:	d02b      	beq.n	800b51e <marker_search+0x66>
 800b4c6:	f996 001d 	ldrsb.w	r0, [r6, #29]
 800b4ca:	1c42      	adds	r2, r0, #1
 800b4cc:	d027      	beq.n	800b51e <marker_search+0x66>
  index_t *index = trace_index[current_trace];
 800b4ce:	4d16      	ldr	r5, [pc, #88]	@ (800b528 <marker_search+0x70>)
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800b4d0:	4a16      	ldr	r2, [pc, #88]	@ (800b52c <marker_search+0x74>)
  index_t *index = trace_index[current_trace];
 800b4d2:	f240 6144 	movw	r1, #1604	@ 0x644
 800b4d6:	fb01 5503 	mla	r5, r1, r3, r5
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800b4da:	8a93      	ldrh	r3, [r2, #20]
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800b4dc:	886f      	ldrh	r7, [r5, #2]
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800b4de:	075b      	lsls	r3, r3, #29
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800b4e0:	8b73      	ldrh	r3, [r6, #26]
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800b4e2:	bf4c      	ite	mi
 800b4e4:	f8df 8048 	ldrmi.w	r8, [pc, #72]	@ 800b530 <marker_search+0x78>
 800b4e8:	f8df 8048 	ldrpl.w	r8, [pc, #72]	@ 800b534 <marker_search+0x7c>
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800b4ec:	2b01      	cmp	r3, #1
  int found = 0;
 800b4ee:	f04f 0900 	mov.w	r9, #0
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800b4f2:	d90f      	bls.n	800b514 <marker_search+0x5c>
 800b4f4:	3502      	adds	r5, #2
 800b4f6:	2401      	movs	r4, #1
    if ((*compare)(value, index[i].y))
 800b4f8:	f835 1024 	ldrh.w	r1, [r5, r4, lsl #2]
 800b4fc:	4638      	mov	r0, r7
 800b4fe:	47c0      	blx	r8
 800b500:	b110      	cbz	r0, 800b508 <marker_search+0x50>
      value = index[i].y;
 800b502:	f835 7024 	ldrh.w	r7, [r5, r4, lsl #2]
      found = i;
 800b506:	46a1      	mov	r9, r4
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800b508:	8b73      	ldrh	r3, [r6, #26]
 800b50a:	3401      	adds	r4, #1
 800b50c:	42a3      	cmp	r3, r4
 800b50e:	dcf3      	bgt.n	800b4f8 <marker_search+0x40>
  set_marker_index(active_marker, found);
 800b510:	f996 001d 	ldrsb.w	r0, [r6, #29]
 800b514:	4649      	mov	r1, r9
}
 800b516:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  set_marker_index(active_marker, found);
 800b51a:	f7fb bd37 	b.w	8006f8c <set_marker_index>
}
 800b51e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b522:	bf00      	nop
 800b524:	20000aa8 	.word	0x20000aa8
 800b528:	20006a3c 	.word	0x20006a3c
 800b52c:	20000318 	.word	0x20000318
 800b530:	08009819 	.word	0x08009819
 800b534:	0800980d 	.word	0x0800980d

0800b538 <distance_to_index>:
{
 800b538:	b410      	push	{r4}
  x -= index[idx].x;
 800b53a:	f240 6444 	movw	r4, #1604	@ 0x644
 800b53e:	fb04 f000 	mul.w	r0, r4, r0
 800b542:	4c09      	ldr	r4, [pc, #36]	@ (800b568 <distance_to_index+0x30>)
 800b544:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800b548:	eb01 0c04 	add.w	ip, r1, r4
 800b54c:	5a60      	ldrh	r0, [r4, r1]
  y -= index[idx].y;
 800b54e:	f8bc 1002 	ldrh.w	r1, [ip, #2]
}
 800b552:	f85d 4b04 	ldr.w	r4, [sp], #4
  x -= index[idx].x;
 800b556:	1a10      	subs	r0, r2, r0
  y -= index[idx].y;
 800b558:	1a5b      	subs	r3, r3, r1
  x -= index[idx].x;
 800b55a:	b200      	sxth	r0, r0
  return x * x + y * y;
 800b55c:	fb13 f303 	smulbb	r3, r3, r3
}
 800b560:	fb00 3000 	mla	r0, r0, r0, r3
 800b564:	4770      	bx	lr
 800b566:	bf00      	nop
 800b568:	20006a3c 	.word	0x20006a3c

0800b56c <search_nearest_index>:
{
 800b56c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (i = 0; i < sweep_points; i++)
 800b570:	4b12      	ldr	r3, [pc, #72]	@ (800b5bc <search_nearest_index+0x50>)
 800b572:	f8b3 901a 	ldrh.w	r9, [r3, #26]
 800b576:	f1b9 0f00 	cmp.w	r9, #0
 800b57a:	d019      	beq.n	800b5b0 <search_nearest_index+0x44>
    int d = distance_to_index(t, i, x, y);
 800b57c:	fa4f f882 	sxtb.w	r8, r2
 800b580:	b20f      	sxth	r7, r1
 800b582:	b202      	sxth	r2, r0
  for (i = 0; i < sweep_points; i++)
 800b584:	2400      	movs	r4, #0
  int min_d = MARKER_PICKUP_DISTANCE * MARKER_PICKUP_DISTANCE;
 800b586:	f44f 7561 	mov.w	r5, #900	@ 0x384
  int min_i = -1;
 800b58a:	f04f 36ff 	mov.w	r6, #4294967295
    int d = distance_to_index(t, i, x, y);
 800b58e:	b2a1      	uxth	r1, r4
 800b590:	463b      	mov	r3, r7
 800b592:	4640      	mov	r0, r8
 800b594:	f7ff ffd0 	bl	800b538 <distance_to_index>
    min_i = i;
 800b598:	42a8      	cmp	r0, r5
 800b59a:	bfb8      	it	lt
 800b59c:	4626      	movlt	r6, r4
  for (i = 0; i < sweep_points; i++)
 800b59e:	f104 0401 	add.w	r4, r4, #1
    min_i = i;
 800b5a2:	bfb8      	it	lt
 800b5a4:	4605      	movlt	r5, r0
  for (i = 0; i < sweep_points; i++)
 800b5a6:	454c      	cmp	r4, r9
 800b5a8:	d1f1      	bne.n	800b58e <search_nearest_index+0x22>
}
 800b5aa:	4630      	mov	r0, r6
 800b5ac:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  int min_i = -1;
 800b5b0:	f04f 36ff 	mov.w	r6, #4294967295
}
 800b5b4:	4630      	mov	r0, r6
 800b5b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b5ba:	bf00      	nop
 800b5bc:	20000aa8 	.word	0x20000aa8

0800b5c0 <parabolic_regression>:
void parabolic_regression(int N, get_value_t getx, get_value_t gety, float *result) {
 800b5c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b5c4:	ed2d 8b08 	vpush	{d8-d11}
  x = y = xx = xy = xxy = xxx = xxxx = 0.0f;
 800b5c8:	ed9f 8a32 	vldr	s16, [pc, #200]	@ 800b694 <parabolic_regression+0xd4>
void parabolic_regression(int N, get_value_t getx, get_value_t gety, float *result) {
 800b5cc:	4604      	mov	r4, r0
 800b5ce:	4688      	mov	r8, r1
 800b5d0:	4617      	mov	r7, r2
 800b5d2:	461d      	mov	r5, r3
  for (int i = 0; i < N; ++i) {
 800b5d4:	2600      	movs	r6, #0
  x = y = xx = xy = xxy = xxx = xxxx = 0.0f;
 800b5d6:	eef0 9a48 	vmov.f32	s19, s16
 800b5da:	eef0 8a48 	vmov.f32	s17, s16
 800b5de:	eef0 aa48 	vmov.f32	s21, s16
 800b5e2:	eeb0 9a48 	vmov.f32	s18, s16
 800b5e6:	eef0 ba48 	vmov.f32	s23, s16
 800b5ea:	eeb0 ba48 	vmov.f32	s22, s16
  for (int i = 0; i < N; ++i) {
 800b5ee:	42a6      	cmp	r6, r4
 800b5f0:	da1b      	bge.n	800b62a <parabolic_regression+0x6a>
    _x   = getx(i); _y   = gety(i); // Get x and y
 800b5f2:	fa1f f986 	uxth.w	r9, r6
 800b5f6:	4648      	mov	r0, r9
 800b5f8:	47c0      	blx	r8
 800b5fa:	4648      	mov	r0, r9
 800b5fc:	eeb0 aa40 	vmov.f32	s20, s0
 800b600:	47b8      	blx	r7
    _xx  =   _x*_x; _xy  =   _x*_y;
 800b602:	ee6a 7a0a 	vmul.f32	s15, s20, s20
 800b606:	ee2a 7a00 	vmul.f32	s14, s20, s0
    xxx +=  _x*_xx; xxy +=  _x*_xy; // SUMM(x^3) and SUMM(x^2 * y)
 800b60a:	eeea 9a27 	vfma.f32	s19, s20, s15
  for (int i = 0; i < N; ++i) {
 800b60e:	3601      	adds	r6, #1
    xxx +=  _x*_xx; xxy +=  _x*_xy; // SUMM(x^3) and SUMM(x^2 * y)
 800b610:	eeea 8a07 	vfma.f32	s17, s20, s14
    xxxx+= _xx*_xx;                 // SUMM(x^4)
 800b614:	eea7 8aa7 	vfma.f32	s16, s15, s15
    x   +=      _x; y   +=      _y; // SUMM(x^1) and SUMM(x^0 * y)
 800b618:	ee3b ba0a 	vadd.f32	s22, s22, s20
 800b61c:	ee7b ba80 	vadd.f32	s23, s23, s0
    xx  +=     _xx; xy  +=     _xy; // SUMM(x^2) and SUMM(x^1 * y)
 800b620:	ee39 9a27 	vadd.f32	s18, s18, s15
 800b624:	ee7a aa87 	vadd.f32	s21, s21, s14
  for (int i = 0; i < N; ++i) {
 800b628:	e7e1      	b.n	800b5ee <parabolic_regression+0x2e>
  float xm  = x / N, ym  = y / N, xxm = xx / N, a, b, c;
 800b62a:	ee07 4a90 	vmov	s15, r4
 800b62e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800b632:	ee8b 6a27 	vdiv.f32	s12, s22, s15
 800b636:	ee8b 7aa7 	vdiv.f32	s14, s23, s15
 800b63a:	eec9 4a27 	vdiv.f32	s9, s18, s15
  xxx -= xx* xm; xxy -= xx* ym;
 800b63e:	eef0 7a69 	vmov.f32	s15, s19
 800b642:	eee9 7a46 	vfms.f32	s15, s18, s12
  xx  -=  x* xm; xy  -=  x* ym;
 800b646:	eeeb aa47 	vfms.f32	s21, s22, s14
  xxxx-= xx*xxm;
 800b64a:	eea9 8a64 	vfms.f32	s16, s18, s9
  xxx -= xx* xm; xxy -= xx* ym;
 800b64e:	eee9 8a47 	vfms.f32	s17, s18, s14
  xx  -=  x* xm; xy  -=  x* ym;
 800b652:	eeab 9a46 	vfms.f32	s18, s22, s12
  c = (xx  *xxy - xxx* xy) / (xxxx*xx - xxx*xxx);
 800b656:	ee6a 5ae7 	vnmul.f32	s11, s21, s15
 800b65a:	ee67 6ae7 	vnmul.f32	s13, s15, s15
 800b65e:	eee8 5a89 	vfma.f32	s11, s17, s18
  b = (xxxx* xy - xxx*xxy) / (xxxx*xx - xxx*xxx);
 800b662:	ee68 8ae7 	vnmul.f32	s17, s17, s15
  c = (xx  *xxy - xxx* xy) / (xxxx*xx - xxx*xxx);
 800b666:	eee8 6a09 	vfma.f32	s13, s16, s18
  b = (xxxx* xy - xxx*xxy) / (xxxx*xx - xxx*xxx);
 800b66a:	eee8 8a2a 	vfma.f32	s17, s16, s21
  c = (xx  *xxy - xxx* xy) / (xxxx*xx - xxx*xxx);
 800b66e:	ee85 5aa6 	vdiv.f32	s10, s11, s13
  b = (xxxx* xy - xxx*xxy) / (xxxx*xx - xxx*xxx);
 800b672:	eec8 7aa6 	vdiv.f32	s15, s17, s13
}
 800b676:	ecbd 8b08 	vpop	{d8-d11}
  result[2] = c;
 800b67a:	ed85 5a02 	vstr	s10, [r5, #8]
  a = ym - b*xm - c*xxm;
 800b67e:	eea6 7a67 	vfms.f32	s14, s12, s15
  result[1] = b;
 800b682:	edc5 7a01 	vstr	s15, [r5, #4]
  a = ym - b*xm - c*xxm;
 800b686:	eea4 7ac5 	vfms.f32	s14, s9, s10
  result[0] = a;
 800b68a:	ed85 7a00 	vstr	s14, [r5]
}
 800b68e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800b692:	bf00      	nop
 800b694:	00000000 	.word	0x00000000

0800b698 <prepare_s11_cable>:
static void prepare_s11_cable(uint8_t type, uint8_t update_mask) {
 800b698:	b530      	push	{r4, r5, lr}
  if (update_mask & MEASURE_UPD_SWEEP) {
 800b69a:	07cc      	lsls	r4, r1, #31
static void prepare_s11_cable(uint8_t type, uint8_t update_mask) {
 800b69c:	b085      	sub	sp, #20
  if (update_mask & MEASURE_UPD_SWEEP) {
 800b69e:	d54c      	bpl.n	800b73a <prepare_s11_cable+0xa2>
    s11_cable->R = 0.0f;
 800b6a0:	ed9f 0a3d 	vldr	s0, [pc, #244]	@ 800b798 <prepare_s11_cable+0x100>
 800b6a4:	4c3d      	ldr	r4, [pc, #244]	@ (800b79c <prepare_s11_cable+0x104>)
    f1 = measure_search_value(&x,  0, s11imag, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800b6a6:	493e      	ldr	r1, [pc, #248]	@ (800b7a0 <prepare_s11_cable+0x108>)
    s11_cable->R = 0.0f;
 800b6a8:	ed84 0a01 	vstr	s0, [r4, #4]
    uint16_t x = 0;
 800b6ac:	2300      	movs	r3, #0
 800b6ae:	f8ad 3006 	strh.w	r3, [sp, #6]
    f1 = measure_search_value(&x,  0, s11imag, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800b6b2:	f10d 0006 	add.w	r0, sp, #6
 800b6b6:	f04f 33ff 	mov.w	r3, #4294967295
 800b6ba:	2201      	movs	r2, #1
    s11_cable->len = 0.0f;
 800b6bc:	ed84 0a02 	vstr	s0, [r4, #8]
    s11_cable->vf = 0.0f;
 800b6c0:	ed84 0a05 	vstr	s0, [r4, #20]
    f1 = measure_search_value(&x,  0, s11imag, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800b6c4:	f7fe fa52 	bl	8009b6c <measure_search_value>
 800b6c8:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800b6cc:	4d35      	ldr	r5, [pc, #212]	@ (800b7a4 <prepare_s11_cable+0x10c>)
 800b6ce:	ee17 0a90 	vmov	r0, s15
    if (f1){
 800b6d2:	b358      	cbz	r0, 800b72c <prepare_s11_cable+0x94>
      float electric_lengh = (SPEED_OF_LIGHT / 400.0f) / f1;
 800b6d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800b6d8:	eddf 6a33 	vldr	s13, [pc, #204]	@ 800b7a8 <prepare_s11_cable+0x110>
      if (real_cable_len != 0.0f) {
 800b6dc:	4b33      	ldr	r3, [pc, #204]	@ (800b7ac <prepare_s11_cable+0x114>)
      float electric_lengh = (SPEED_OF_LIGHT / 400.0f) / f1;
 800b6de:	ee86 7aa7 	vdiv.f32	s14, s13, s15
      if (real_cable_len != 0.0f) {
 800b6e2:	edd3 7a00 	vldr	s15, [r3]
 800b6e6:	eef5 7a40 	vcmp.f32	s15, #0.0
 800b6ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b6ee:	d006      	beq.n	800b6fe <prepare_s11_cable+0x66>
        s11_cable->vf = real_cable_len / electric_lengh;
 800b6f0:	eec7 6a87 	vdiv.f32	s13, s15, s14
        s11_cable->len = real_cable_len;
 800b6f4:	edc4 7a02 	vstr	s15, [r4, #8]
        s11_cable->vf = real_cable_len / electric_lengh;
 800b6f8:	edc4 6a05 	vstr	s13, [r4, #20]
 800b6fc:	e009      	b.n	800b712 <prepare_s11_cable+0x7a>
      } else s11_cable->len = velocity_factor * electric_lengh;
 800b6fe:	f895 3099 	ldrb.w	r3, [r5, #153]	@ 0x99
 800b702:	ee07 3a90 	vmov	s15, r3
 800b706:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800b70a:	ee67 7a87 	vmul.f32	s15, s15, s14
 800b70e:	edc4 7a02 	vstr	s15, [r4, #8]
      if (measure_get_value(0, f1/2, data)){
 800b712:	a902      	add	r1, sp, #8
 800b714:	0840      	lsrs	r0, r0, #1
 800b716:	f7ff fc59 	bl	800afcc <measure_get_value.constprop.0>
 800b71a:	b138      	cbz	r0, 800b72c <prepare_s11_cable+0x94>
        s11_cable->R = vna_fabsf(reactance(0, data));
 800b71c:	a902      	add	r1, sp, #8
 800b71e:	2000      	movs	r0, #0
 800b720:	f7ff faf2 	bl	800ad08 <reactance>
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800b724:	eeb0 0ac0 	vabs.f32	s0, s0
 800b728:	ed84 0a01 	vstr	s0, [r4, #4]
    parabolic_regression(sweep_points, s11index, s11loss, &s11_cable->a);
 800b72c:	4b20      	ldr	r3, [pc, #128]	@ (800b7b0 <prepare_s11_cable+0x118>)
 800b72e:	4a21      	ldr	r2, [pc, #132]	@ (800b7b4 <prepare_s11_cable+0x11c>)
 800b730:	4921      	ldr	r1, [pc, #132]	@ (800b7b8 <prepare_s11_cable+0x120>)
 800b732:	8b68      	ldrh	r0, [r5, #26]
 800b734:	f7ff ff44 	bl	800b5c0 <parabolic_regression>
  if ((update_mask & MEASURE_UPD_ALL) && active_marker != MARKER_INVALID) {
 800b738:	e001      	b.n	800b73e <prepare_s11_cable+0xa6>
 800b73a:	0788      	lsls	r0, r1, #30
 800b73c:	d023      	beq.n	800b786 <prepare_s11_cable+0xee>
 800b73e:	4b19      	ldr	r3, [pc, #100]	@ (800b7a4 <prepare_s11_cable+0x10c>)
 800b740:	f993 201d 	ldrsb.w	r2, [r3, #29]
 800b744:	1c51      	adds	r1, r2, #1
 800b746:	d01e      	beq.n	800b786 <prepare_s11_cable+0xee>
    int idx = markers[active_marker].index;
 800b748:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    s11_cable->freq = (float)getFrequency(idx);
 800b74c:	f8b3 005a 	ldrh.w	r0, [r3, #90]	@ 0x5a
 800b750:	f7fa ff34 	bl	80065bc <getFrequency>
 800b754:	ee07 0a90 	vmov	s15, r0
 800b758:	4b10      	ldr	r3, [pc, #64]	@ (800b79c <prepare_s11_cable+0x104>)
    float f = s11_cable->freq * 1e-9f;
 800b75a:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800b7bc <prepare_s11_cable+0x124>
    s11_cable->mloss = s11_cable->a + s11_cable->b * vna_sqrtf(f) + s11_cable->c * f;
 800b75e:	ed93 6a08 	vldr	s12, [r3, #32]
    s11_cable->freq = (float)getFrequency(idx);
 800b762:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800b766:	edc3 7a00 	vstr	s15, [r3]
    float f = s11_cable->freq * 1e-9f;
 800b76a:	ee67 7a87 	vmul.f32	s15, s15, s14
    s11_cable->mloss = s11_cable->a + s11_cable->b * vna_sqrtf(f) + s11_cable->c * f;
 800b76e:	ed93 7a07 	vldr	s14, [r3, #28]
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800b772:	eef1 6ae7 	vsqrt.f32	s13, s15
 800b776:	eea6 7a26 	vfma.f32	s14, s12, s13
 800b77a:	edd3 6a09 	vldr	s13, [r3, #36]	@ 0x24
 800b77e:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800b782:	ed83 7a04 	vstr	s14, [r3, #16]
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b786:	2304      	movs	r3, #4
 800b788:	2207      	movs	r2, #7
 800b78a:	2102      	movs	r1, #2
 800b78c:	2000      	movs	r0, #0
}
 800b78e:	b005      	add	sp, #20
 800b790:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b794:	f7fd bfc8 	b.w	8009728 <invalidate_rect_func>
 800b798:	00000000 	.word	0x00000000
 800b79c:	200069b4 	.word	0x200069b4
 800b7a0:	080098d5 	.word	0x080098d5
 800b7a4:	20000aa8 	.word	0x20000aa8
 800b7a8:	4936fa92 	.word	0x4936fa92
 800b7ac:	200069b0 	.word	0x200069b0
 800b7b0:	200069d0 	.word	0x200069d0
 800b7b4:	0800ab39 	.word	0x0800ab39
 800b7b8:	08009b4d 	.word	0x08009b4d
 800b7bc:	3089705f 	.word	0x3089705f

0800b7c0 <plot_get_measure_channels>:
  return measure[current_props._measure].option;
 800b7c0:	4b04      	ldr	r3, [pc, #16]	@ (800b7d4 <plot_get_measure_channels+0x14>)
 800b7c2:	4a05      	ldr	r2, [pc, #20]	@ (800b7d8 <plot_get_measure_channels+0x18>)
 800b7c4:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800b7c8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
}
 800b7cc:	f812 0023 	ldrb.w	r0, [r2, r3, lsl #2]
 800b7d0:	4770      	bx	lr
 800b7d2:	bf00      	nop
 800b7d4:	20000aa8 	.word	0x20000aa8
 800b7d8:	08014200 	.word	0x08014200

0800b7dc <set_area_size>:
  lcd_bulk_continue(OFFSETX + x0, OFFSETY + y0, w, h);
}

void set_area_size(uint16_t w, uint16_t h)
{
  area_width = w;
 800b7dc:	4a02      	ldr	r2, [pc, #8]	@ (800b7e8 <set_area_size+0xc>)
  area_height = h;
 800b7de:	4b03      	ldr	r3, [pc, #12]	@ (800b7ec <set_area_size+0x10>)
  area_width = w;
 800b7e0:	8010      	strh	r0, [r2, #0]
  area_height = h;
 800b7e2:	8019      	strh	r1, [r3, #0]
}
 800b7e4:	4770      	bx	lr
 800b7e6:	bf00      	nop
 800b7e8:	200003da 	.word	0x200003da
 800b7ec:	200003d8 	.word	0x200003d8

0800b7f0 <request_to_redraw>:
//**************************************************************************************
//            Set update mask for next screen update
//**************************************************************************************
void request_to_redraw(uint16_t mask)
{
  redraw_request |= mask;
 800b7f0:	4b02      	ldr	r3, [pc, #8]	@ (800b7fc <request_to_redraw+0xc>)
 800b7f2:	881a      	ldrh	r2, [r3, #0]
 800b7f4:	4310      	orrs	r0, r2
 800b7f6:	8018      	strh	r0, [r3, #0]
}
 800b7f8:	4770      	bx	lr
 800b7fa:	bf00      	nop
 800b7fc:	200089a8 	.word	0x200089a8

0800b800 <request_to_draw_cells_behind_menu>:
{
 800b800:	b508      	push	{r3, lr}
  invalidate_rect(LCD_WIDTH - MENU_BUTTON_WIDTH - OFFSETX, 0, LCD_WIDTH - OFFSETX, LCD_HEIGHT - 1);
 800b802:	200b      	movs	r0, #11
 800b804:	2309      	movs	r3, #9
 800b806:	220e      	movs	r2, #14
 800b808:	2100      	movs	r1, #0
 800b80a:	f7fd ff8d 	bl	8009728 <invalidate_rect_func>
}
 800b80e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_CELLS | REDRAW_FREQUENCY);
 800b812:	200c      	movs	r0, #12
 800b814:	f7ff bfec 	b.w	800b7f0 <request_to_redraw>

0800b818 <plot_set_measure_mode>:
  if (mode >= MEASURE_END)
 800b818:	2807      	cmp	r0, #7
 800b81a:	d900      	bls.n	800b81e <plot_set_measure_mode+0x6>
 800b81c:	4770      	bx	lr
{
 800b81e:	b410      	push	{r4}
  data_update = 0xFF;
 800b820:	4a05      	ldr	r2, [pc, #20]	@ (800b838 <plot_set_measure_mode+0x20>)
  current_props._measure = mode;
 800b822:	4c06      	ldr	r4, [pc, #24]	@ (800b83c <plot_set_measure_mode+0x24>)
 800b824:	4603      	mov	r3, r0
  data_update = 0xFF;
 800b826:	21ff      	movs	r1, #255	@ 0xff
  current_props._measure = mode;
 800b828:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  data_update = 0xFF;
 800b82c:	7011      	strb	r1, [r2, #0]
}
 800b82e:	f85d 4b04 	ldr.w	r4, [sp], #4
  request_to_redraw(REDRAW_AREA);
 800b832:	2002      	movs	r0, #2
 800b834:	f7ff bfdc 	b.w	800b7f0 <request_to_redraw>
 800b838:	20006a34 	.word	0x20006a34
 800b83c:	20000aa8 	.word	0x20000aa8

0800b840 <draw_all>:
{
 800b840:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (redraw_request & REDRAW_PLOT)
 800b844:	4b98      	ldr	r3, [pc, #608]	@ (800baa8 <draw_all+0x268>)
{
 800b846:	ed2d 8b04 	vpush	{d8-d9}
  if (redraw_request & REDRAW_PLOT)
 800b84a:	881b      	ldrh	r3, [r3, #0]
 800b84c:	07da      	lsls	r2, r3, #31
{
 800b84e:	b0b7      	sub	sp, #220	@ 0xdc
  if (redraw_request & REDRAW_PLOT)
 800b850:	f100 81ca 	bmi.w	800bbe8 <draw_all+0x3a8>
  if (area_width == 0)
 800b854:	4b95      	ldr	r3, [pc, #596]	@ (800baac <draw_all+0x26c>)
 800b856:	881b      	ldrh	r3, [r3, #0]
 800b858:	2b00      	cmp	r3, #0
 800b85a:	f000 81be 	beq.w	800bbda <draw_all+0x39a>
  if (redraw_request & REDRAW_CLRSCR)
 800b85e:	4b92      	ldr	r3, [pc, #584]	@ (800baa8 <draw_all+0x268>)
 800b860:	881c      	ldrh	r4, [r3, #0]
 800b862:	05a7      	lsls	r7, r4, #22
 800b864:	f100 81ae 	bmi.w	800bbc4 <draw_all+0x384>
  if (redraw_request & REDRAW_AREA)
 800b868:	07a6      	lsls	r6, r4, #30
 800b86a:	d42a      	bmi.n	800b8c2 <draw_all+0x82>
    if (redraw_request & REDRAW_MARKER)
 800b86c:	06a5      	lsls	r5, r4, #26
 800b86e:	f101 82f9 	bmi.w	800ce64 <draw_all+0x1624>
    if (redraw_request & REDRAW_REFERENCE)
 800b872:	0660      	lsls	r0, r4, #25
 800b874:	f101 82fd 	bmi.w	800ce72 <draw_all+0x1632>
    if (redraw_request & REDRAW_GRID_VALUE)
 800b878:	0622      	lsls	r2, r4, #24
 800b87a:	f101 8302 	bmi.w	800ce82 <draw_all+0x1642>
  if (redraw_request & (REDRAW_CELLS | REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_REFERENCE | REDRAW_AREA))
 800b87e:	f014 0fe6 	tst.w	r4, #230	@ 0xe6
 800b882:	f041 8303 	bne.w	800ce8c <draw_all+0x164c>
  if (redraw_request & REDRAW_FREQUENCY)
 800b886:	0725      	lsls	r5, r4, #28
 800b888:	f100 8086 	bmi.w	800b998 <draw_all+0x158>
  if (redraw_request & REDRAW_CAL_STATUS)
 800b88c:	06e0      	lsls	r0, r4, #27
 800b88e:	f100 80d5 	bmi.w	800ba3c <draw_all+0x1fc>
  if (redraw_request & REDRAW_BATTERY)
 800b892:	05e7      	lsls	r7, r4, #23
 800b894:	f100 815e 	bmi.w	800bb54 <draw_all+0x314>


static void plot_draw_swr_reference_lines(void)
{
  
  if (drawTheSWRLines == false)
 800b898:	4b85      	ldr	r3, [pc, #532]	@ (800bab0 <draw_all+0x270>)
  redraw_request = 0;
 800b89a:	4983      	ldr	r1, [pc, #524]	@ (800baa8 <draw_all+0x268>)
  if (drawTheSWRLines == false)
 800b89c:	781b      	ldrb	r3, [r3, #0]
  redraw_request = 0;
 800b89e:	2200      	movs	r2, #0
 800b8a0:	800a      	strh	r2, [r1, #0]
  if (drawTheSWRLines == false)
 800b8a2:	b14b      	cbz	r3, 800b8b8 <draw_all+0x78>
    return;

  const trace_t *t = &trace[3]; // typically trace 3 is SWR
  if (t->type != TRC_SWR || !t->enabled)
 800b8a4:	4b83      	ldr	r3, [pc, #524]	@ (800bab4 <draw_all+0x274>)
 800b8a6:	f893 204d 	ldrb.w	r2, [r3, #77]	@ 0x4d
 800b8aa:	2a06      	cmp	r2, #6
 800b8ac:	d104      	bne.n	800b8b8 <draw_all+0x78>
 800b8ae:	f893 204c 	ldrb.w	r2, [r3, #76]	@ 0x4c
 800b8b2:	2a00      	cmp	r2, #0
 800b8b4:	f040 820d 	bne.w	800bcd2 <draw_all+0x492>
}
 800b8b8:	b037      	add	sp, #220	@ 0xdc
 800b8ba:	ecbd 8b04 	vpop	{d8-d9}
 800b8be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    markmap[n] = (map_t)-1;
 800b8c2:	4e7d      	ldr	r6, [pc, #500]	@ (800bab8 <draw_all+0x278>)
 800b8c4:	f04f 33ff 	mov.w	r3, #4294967295
 800b8c8:	e9c6 3300 	strd	r3, r3, [r6]
 800b8cc:	e9c6 3302 	strd	r3, r3, [r6, #8]
 800b8d0:	6133      	str	r3, [r6, #16]
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800b8d2:	4b76      	ldr	r3, [pc, #472]	@ (800baac <draw_all+0x26c>)
  if (current_props._measure >= MEASURE_END)
 800b8d4:	4c77      	ldr	r4, [pc, #476]	@ (800bab4 <draw_all+0x274>)
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800b8d6:	881f      	ldrh	r7, [r3, #0]
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800b8d8:	4b78      	ldr	r3, [pc, #480]	@ (800babc <draw_all+0x27c>)
  if (current_props._measure >= MEASURE_END)
 800b8da:	f894 0021 	ldrb.w	r0, [r4, #33]	@ 0x21
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800b8de:	881b      	ldrh	r3, [r3, #0]
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800b8e0:	371f      	adds	r7, #31
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800b8e2:	331f      	adds	r3, #31
  if (current_props._measure >= MEASURE_END)
 800b8e4:	2807      	cmp	r0, #7
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800b8e6:	ea4f 1767 	mov.w	r7, r7, asr #5
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800b8ea:	ea4f 1863 	mov.w	r8, r3, asr #5
 800b8ee:	ea4f 1553 	mov.w	r5, r3, lsr #5
  if (current_props._measure >= MEASURE_END)
 800b8f2:	d810      	bhi.n	800b916 <draw_all+0xd6>
  measure_prepare_cb_t measure_cb = measure[current_props._measure].measure_prepare;
 800b8f4:	4a72      	ldr	r2, [pc, #456]	@ (800bac0 <draw_all+0x280>)
 800b8f6:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 800b8fa:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800b8fe:	6893      	ldr	r3, [r2, #8]
  if (measure_cb && (data_update & measure[current_props._measure].update))
 800b900:	2b00      	cmp	r3, #0
 800b902:	f001 838c 	beq.w	800d01e <draw_all+0x17de>
 800b906:	4c6f      	ldr	r4, [pc, #444]	@ (800bac4 <draw_all+0x284>)
 800b908:	7852      	ldrb	r2, [r2, #1]
 800b90a:	7821      	ldrb	r1, [r4, #0]
 800b90c:	4211      	tst	r1, r2
 800b90e:	d000      	beq.n	800b912 <draw_all+0xd2>
    measure_cb(current_props._measure, data_update);
 800b910:	4798      	blx	r3
  data_update = 0;
 800b912:	2300      	movs	r3, #0
 800b914:	7023      	strb	r3, [r4, #0]
  for (n = 0; n < h; n++)
 800b916:	f1b8 0f00 	cmp.w	r8, #0
 800b91a:	d030      	beq.n	800b97e <draw_all+0x13e>
 800b91c:	017b      	lsls	r3, r7, #5
 800b91e:	9309      	str	r3, [sp, #36]	@ 0x24
 800b920:	f06f 03ea 	mvn.w	r3, #234	@ 0xea
 800b924:	4c64      	ldr	r4, [pc, #400]	@ (800bab8 <draw_all+0x278>)
 800b926:	930d      	str	r3, [sp, #52]	@ 0x34
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800b928:	eddf 8a67 	vldr	s17, [pc, #412]	@ 800bac8 <draw_all+0x288>
  for (n = 0; n < h; n++)
 800b92c:	9518      	str	r5, [sp, #96]	@ 0x60
 800b92e:	2300      	movs	r3, #0
 800b930:	9315      	str	r3, [sp, #84]	@ 0x54
 800b932:	9416      	str	r4, [sp, #88]	@ 0x58
 800b934:	961a      	str	r6, [sp, #104]	@ 0x68
    map_t update_map = markmap[n];
 800b936:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 800b938:	f833 2b02 	ldrh.w	r2, [r3], #2
 800b93c:	9207      	str	r2, [sp, #28]
 800b93e:	9316      	str	r3, [sp, #88]	@ 0x58
    for (m = 0; update_map && m < w; update_map >>= 1, m++)
 800b940:	b192      	cbz	r2, 800b968 <draw_all+0x128>
 800b942:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800b944:	33eb      	adds	r3, #235	@ 0xeb
 800b946:	9308      	str	r3, [sp, #32]
 800b948:	2300      	movs	r3, #0
 800b94a:	469b      	mov	fp, r3
 800b94c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800b94e:	459b      	cmp	fp, r3
 800b950:	d00a      	beq.n	800b968 <draw_all+0x128>
      if (update_map & 1)
 800b952:	9b07      	ldr	r3, [sp, #28]
 800b954:	07dd      	lsls	r5, r3, #31
 800b956:	f100 8249 	bmi.w	800bdec <draw_all+0x5ac>
    for (m = 0; update_map && m < w; update_map >>= 1, m++)
 800b95a:	085b      	lsrs	r3, r3, #1
 800b95c:	9307      	str	r3, [sp, #28]
 800b95e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800b960:	f10b 0b20 	add.w	fp, fp, #32
 800b964:	459b      	cmp	fp, r3
 800b966:	d1f4      	bne.n	800b952 <draw_all+0x112>
  for (n = 0; n < h; n++)
 800b968:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800b96a:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 800b96c:	3220      	adds	r2, #32
 800b96e:	3301      	adds	r3, #1
 800b970:	920d      	str	r2, [sp, #52]	@ 0x34
 800b972:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 800b974:	b29b      	uxth	r3, r3
 800b976:	429a      	cmp	r2, r3
 800b978:	9315      	str	r3, [sp, #84]	@ 0x54
 800b97a:	d1dc      	bne.n	800b936 <draw_all+0xf6>
 800b97c:	9e1a      	ldr	r6, [sp, #104]	@ 0x68
    markmap[n] = (map_t)0;
 800b97e:	2300      	movs	r3, #0
 800b980:	e9c6 3300 	strd	r3, r3, [r6]
 800b984:	e9c6 3302 	strd	r3, r3, [r6, #8]
 800b988:	6133      	str	r3, [r6, #16]
  lcd_bulk_finish();
 800b98a:	f004 fa89 	bl	800fea0 <lcd_bulk_finish>
  if (redraw_request & REDRAW_FREQUENCY)
 800b98e:	4b46      	ldr	r3, [pc, #280]	@ (800baa8 <draw_all+0x268>)
 800b990:	881c      	ldrh	r4, [r3, #0]
 800b992:	0725      	lsls	r5, r4, #28
 800b994:	f57f af7a 	bpl.w	800b88c <draw_all+0x4c>
  char lm0 = lever_mode == LM_FREQ_0 ? S_SARROW[0] : ' ';
 800b998:	4f4c      	ldr	r7, [pc, #304]	@ (800bacc <draw_all+0x28c>)
 800b99a:	7f3b      	ldrb	r3, [r7, #28]
 800b99c:	2b02      	cmp	r3, #2
 800b99e:	f000 81f7 	beq.w	800bd90 <draw_all+0x550>
  char lm1 = lever_mode == LM_FREQ_1 ? S_SARROW[0] : ' ';
 800b9a2:	2b03      	cmp	r3, #3
 800b9a4:	f04f 0520 	mov.w	r5, #32
 800b9a8:	f041 82ab 	bne.w	800cf02 <draw_all+0x16c2>
 800b9ac:	2618      	movs	r6, #24
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800b9ae:	2100      	movs	r1, #0
 800b9b0:	2001      	movs	r0, #1
  if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800b9b2:	4c40      	ldr	r4, [pc, #256]	@ (800bab4 <draw_all+0x274>)
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800b9b4:	f004 fba4 	bl	8010100 <lcd_set_colors>
  lcd_fill(0, HEIGHT + OFFSETY + 1, LCD_WIDTH, LCD_HEIGHT - HEIGHT - OFFSETY - 1);
 800b9b8:	f240 1131 	movw	r1, #305	@ 0x131
 800b9bc:	2000      	movs	r0, #0
 800b9be:	230f      	movs	r3, #15
 800b9c0:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800b9c4:	f004 fa96 	bl	800fef4 <lcd_fill>
  if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800b9c8:	8b21      	ldrh	r1, [r4, #24]
 800b9ca:	07c8      	lsls	r0, r1, #31
 800b9cc:	f101 8275 	bmi.w	800ceba <draw_all+0x167a>
    if (FREQ_IS_CW())
 800b9d0:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
 800b9d4:	429a      	cmp	r2, r3
 800b9d6:	f001 839c 	beq.w	800d112 <draw_all+0x18d2>
    else if (FREQ_IS_STARTSTOP())
 800b9da:	0649      	lsls	r1, r1, #25
 800b9dc:	f101 8294 	bmi.w	800cf08 <draw_all+0x16c8>
      lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm0, "START", get_sweep_frequency(ST_START));
 800b9e0:	9201      	str	r2, [sp, #4]
 800b9e2:	4a3b      	ldr	r2, [pc, #236]	@ (800bad0 <draw_all+0x290>)
 800b9e4:	9200      	str	r2, [sp, #0]
 800b9e6:	462b      	mov	r3, r5
 800b9e8:	4a3a      	ldr	r2, [pc, #232]	@ (800bad4 <draw_all+0x294>)
 800b9ea:	f240 1133 	movw	r1, #307	@ 0x133
 800b9ee:	200f      	movs	r0, #15
 800b9f0:	f004 fc16 	bl	8010220 <lcd_printf>
      lcd_printf(FREQUENCIES_XPOS2, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm1, "STOP", get_sweep_frequency(ST_STOP));
 800b9f4:	68a3      	ldr	r3, [r4, #8]
 800b9f6:	9301      	str	r3, [sp, #4]
 800b9f8:	4b37      	ldr	r3, [pc, #220]	@ (800bad8 <draw_all+0x298>)
 800b9fa:	9300      	str	r3, [sp, #0]
 800b9fc:	4a35      	ldr	r2, [pc, #212]	@ (800bad4 <draw_all+0x294>)
 800b9fe:	4633      	mov	r3, r6
 800ba00:	f240 1133 	movw	r1, #307	@ 0x133
 800ba04:	f44f 70a3 	mov.w	r0, #326	@ 0x146
 800ba08:	f004 fc0a 	bl	8010220 <lcd_printf>
  lcd_set_foreground(LCD_BW_TEXT_COLOR);
 800ba0c:	2012      	movs	r0, #18
 800ba0e:	f004 fb5f 	bl	80100d0 <lcd_set_foreground>
  lcd_set_colors(LCD_SPEC_INPUT_COLOR, LCD_BG_COLOR);
 800ba12:	2100      	movs	r1, #0
 800ba14:	200e      	movs	r0, #14
 800ba16:	f004 fb73 	bl	8010100 <lcd_set_colors>
  lcd_printf(FREQUENCIES_XPOS3, FREQUENCIES_YPOS, "BW:%u" S_Hz " %up", get_bandwidth_frequency(config._bandwidth), sweep_points);
 800ba1a:	8b78      	ldrh	r0, [r7, #26]
 800ba1c:	f7fa fdc8 	bl	80065b0 <get_bandwidth_frequency>
 800ba20:	8b61      	ldrh	r1, [r4, #26]
 800ba22:	9100      	str	r1, [sp, #0]
 800ba24:	4603      	mov	r3, r0
 800ba26:	4a2d      	ldr	r2, [pc, #180]	@ (800badc <draw_all+0x29c>)
 800ba28:	f240 1133 	movw	r1, #307	@ 0x133
 800ba2c:	20ce      	movs	r0, #206	@ 0xce
 800ba2e:	f004 fbf7 	bl	8010220 <lcd_printf>
  if (redraw_request & REDRAW_CAL_STATUS)
 800ba32:	4b1d      	ldr	r3, [pc, #116]	@ (800baa8 <draw_all+0x268>)
 800ba34:	881c      	ldrh	r4, [r3, #0]
 800ba36:	06e0      	lsls	r0, r4, #27
 800ba38:	f57f af2b 	bpl.w	800b892 <draw_all+0x52>
  lcd_set_colors(LCD_DISABLE_CAL_COLOR, LCD_BG_COLOR);
 800ba3c:	2100      	movs	r1, #0
 800ba3e:	2018      	movs	r0, #24
  if (cal_status & CALSTAT_APPLY)
 800ba40:	4c1c      	ldr	r4, [pc, #112]	@ (800bab4 <draw_all+0x274>)
  lcd_set_colors(LCD_DISABLE_CAL_COLOR, LCD_BG_COLOR);
 800ba42:	f004 fb5d 	bl	8010100 <lcd_set_colors>
  lcd_fill(x, y, OFFSETX - x, 10 * (sFONT_STR_HEIGHT));
 800ba46:	220f      	movs	r2, #15
 800ba48:	2164      	movs	r1, #100	@ 0x64
 800ba4a:	236e      	movs	r3, #110	@ 0x6e
 800ba4c:	2000      	movs	r0, #0
 800ba4e:	f004 fa51 	bl	800fef4 <lcd_fill>
  if (cal_status & CALSTAT_APPLY)
 800ba52:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
 800ba54:	05d1      	lsls	r1, r2, #23
 800ba56:	d522      	bpl.n	800ba9e <draw_all+0x25e>
    char c[4] = {'C', '0' + lastsaveid, 0, 0};
 800ba58:	4b21      	ldr	r3, [pc, #132]	@ (800bae0 <draw_all+0x2a0>)
 800ba5a:	2143      	movs	r1, #67	@ 0x43
 800ba5c:	881b      	ldrh	r3, [r3, #0]
 800ba5e:	f88d 1088 	strb.w	r1, [sp, #136]	@ 0x88
 800ba62:	2100      	movs	r1, #0
 800ba64:	f8ad 108a 	strh.w	r1, [sp, #138]	@ 0x8a
    if (lastsaveid == NO_SAVE_SLOT)
 800ba68:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 800ba6c:	428b      	cmp	r3, r1
    char c[4] = {'C', '0' + lastsaveid, 0, 0};
 800ba6e:	bf1a      	itte	ne
 800ba70:	3330      	addne	r3, #48	@ 0x30
 800ba72:	b2db      	uxtbne	r3, r3
      c[1] = '*';
 800ba74:	232a      	moveq	r3, #42	@ 0x2a
    if (cal_status & CALSTAT_INTERPOLATED)
 800ba76:	0592      	lsls	r2, r2, #22
 800ba78:	f88d 3089 	strb.w	r3, [sp, #137]	@ 0x89
 800ba7c:	f141 8264 	bpl.w	800cf48 <draw_all+0x1708>
      lcd_set_foreground(LCD_INTERP_CAL_COLOR);
 800ba80:	2017      	movs	r0, #23
 800ba82:	f004 fb25 	bl	80100d0 <lcd_set_foreground>
      c[0] = 'c';
 800ba86:	2363      	movs	r3, #99	@ 0x63
 800ba88:	f88d 3088 	strb.w	r3, [sp, #136]	@ 0x88
    lcd_drawstring(x, y, c);
 800ba8c:	aa22      	add	r2, sp, #136	@ 0x88
 800ba8e:	2164      	movs	r1, #100	@ 0x64
 800ba90:	2000      	movs	r0, #0
 800ba92:	f004 fbc5 	bl	8010220 <lcd_printf>
    lcd_set_foreground(LCD_FG_COLOR);
 800ba96:	2001      	movs	r0, #1
 800ba98:	f004 fb1a 	bl	80100d0 <lcd_set_foreground>
    if (cal_status & calibration_text[i].mask)
 800ba9c:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800ba9e:	4d11      	ldr	r5, [pc, #68]	@ (800bae4 <draw_all+0x2a4>)
      c[1] = '*';
 800baa0:	2664      	movs	r6, #100	@ 0x64
 800baa2:	f105 0724 	add.w	r7, r5, #36	@ 0x24
 800baa6:	e022      	b.n	800baee <draw_all+0x2ae>
 800baa8:	200089a8 	.word	0x200089a8
 800baac:	200003da 	.word	0x200003da
 800bab0:	2000686c 	.word	0x2000686c
 800bab4:	20000aa8 	.word	0x20000aa8
 800bab8:	20008990 	.word	0x20008990
 800babc:	200003d8 	.word	0x200003d8
 800bac0:	08014200 	.word	0x08014200
 800bac4:	20006a34 	.word	0x20006a34
 800bac8:	42180000 	.word	0x42180000
 800bacc:	20000318 	.word	0x20000318
 800bad0:	08011e8c 	.word	0x08011e8c
 800bad4:	08011e7c 	.word	0x08011e7c
 800bad8:	08011e94 	.word	0x08011e94
 800badc:	08011ed4 	.word	0x08011ed4
 800bae0:	200099f6 	.word	0x200099f6
 800bae4:	080141ac 	.word	0x080141ac
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800bae8:	3504      	adds	r5, #4
 800baea:	42bd      	cmp	r5, r7
 800baec:	d00c      	beq.n	800bb08 <draw_all+0x2c8>
    if (cal_status & calibration_text[i].mask)
 800baee:	886b      	ldrh	r3, [r5, #2]
 800baf0:	421a      	tst	r2, r3
 800baf2:	d0f9      	beq.n	800bae8 <draw_all+0x2a8>
      lcd_drawstring(x, y += sFONT_STR_HEIGHT, &calibration_text[i].text);
 800baf4:	360b      	adds	r6, #11
 800baf6:	462a      	mov	r2, r5
 800baf8:	b231      	sxth	r1, r6
 800bafa:	2000      	movs	r0, #0
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800bafc:	3504      	adds	r5, #4
      lcd_drawstring(x, y += sFONT_STR_HEIGHT, &calibration_text[i].text);
 800bafe:	f004 fb8f 	bl	8010220 <lcd_printf>
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800bb02:	42bd      	cmp	r5, r7
  if ((cal_status & CALSTAT_APPLY) && cal_power != current_props._power)
 800bb04:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800bb06:	d1f2      	bne.n	800baee <draw_all+0x2ae>
  if ((cal_status & CALSTAT_APPLY) && cal_power != current_props._power)
 800bb08:	05d3      	lsls	r3, r2, #23
 800bb0a:	d507      	bpl.n	800bb1c <draw_all+0x2dc>
 800bb0c:	f894 2020 	ldrb.w	r2, [r4, #32]
 800bb10:	7fe3      	ldrb	r3, [r4, #31]
 800bb12:	429a      	cmp	r2, r3
 800bb14:	d002      	beq.n	800bb1c <draw_all+0x2dc>
    lcd_set_foreground(LCD_DISABLE_CAL_COLOR);
 800bb16:	2018      	movs	r0, #24
 800bb18:	f004 fada 	bl	80100d0 <lcd_set_foreground>
  lcd_set_foreground(LCD_BG_COLOR); // ADDED BY ME to hide power level when cal not applied
 800bb1c:	2000      	movs	r0, #0
 800bb1e:	f004 fad7 	bl	80100d0 <lcd_set_foreground>
  lcd_printf(x, y += sFONT_STR_HEIGHT, "P%c", current_props._power > 3 ? ('a') : (current_props._power * 2 + '2'));
 800bb22:	7fe3      	ldrb	r3, [r4, #31]
 800bb24:	4aa2      	ldr	r2, [pc, #648]	@ (800bdb0 <draw_all+0x570>)
 800bb26:	2b03      	cmp	r3, #3
 800bb28:	bf98      	it	ls
 800bb2a:	3319      	addls	r3, #25
 800bb2c:	f106 010b 	add.w	r1, r6, #11
 800bb30:	b209      	sxth	r1, r1
 800bb32:	bf94      	ite	ls
 800bb34:	005b      	lslls	r3, r3, #1
 800bb36:	2361      	movhi	r3, #97	@ 0x61
 800bb38:	2000      	movs	r0, #0
 800bb3a:	f004 fb71 	bl	8010220 <lcd_printf>
  uint8_t smooth = get_smooth_factor();
 800bb3e:	f7fa f92f 	bl	8005da0 <get_smooth_factor>
  if (smooth > 0)
 800bb42:	4604      	mov	r4, r0
 800bb44:	2800      	cmp	r0, #0
 800bb46:	f040 8126 	bne.w	800bd96 <draw_all+0x556>
  if (redraw_request & REDRAW_BATTERY)
 800bb4a:	4b9a      	ldr	r3, [pc, #616]	@ (800bdb4 <draw_all+0x574>)
 800bb4c:	881c      	ldrh	r4, [r3, #0]
 800bb4e:	05e7      	lsls	r7, r4, #23
 800bb50:	f57f aea2 	bpl.w	800b898 <draw_all+0x58>
  int16_t vbat = adc_vbat_read();
 800bb54:	f004 ffba 	bl	8010acc <adc_vbat_read>
  if (vbat <= 0)
 800bb58:	1e04      	subs	r4, r0, #0
 800bb5a:	f77f ae9d 	ble.w	800b898 <draw_all+0x58>
  if (vbat >= BATTERY_WARNING_LEVEL) {
 800bb5e:	f640 43e3 	movw	r3, #3299	@ 0xce3
 800bb62:	429c      	cmp	r4, r3
    lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 800bb64:	f04f 0100 	mov.w	r1, #0
  if (vbat >= BATTERY_WARNING_LEVEL) {
 800bb68:	f301 81f3 	bgt.w	800cf52 <draw_all+0x1712>
  lcd_set_colors(LCD_LOW_BAT_COLOR, LCD_BG_COLOR);
 800bb6c:	200d      	movs	r0, #13
 800bb6e:	f004 fac7 	bl	8010100 <lcd_set_colors>
  string_buf[x++] = 0b00000000;
 800bb72:	4b91      	ldr	r3, [pc, #580]	@ (800bdb8 <draw_all+0x578>)
 800bb74:	9322      	str	r3, [sp, #136]	@ 0x88
  for (int power = BATTERY_TOP_LEVEL; power > BATTERY_BOTTOM_LEVEL;)
 800bb76:	f241 0104 	movw	r1, #4100	@ 0x1004
 800bb7a:	f10d 008b 	add.w	r0, sp, #139	@ 0x8b
  string_buf[x++] = 0b11111111;
 800bb7e:	2304      	movs	r3, #4
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800bb80:	2581      	movs	r5, #129	@ 0x81
    if ((x & 3) == 0)
 800bb82:	079e      	lsls	r6, r3, #30
      string_buf[x++] = 0b10000001;
 800bb84:	f103 0201 	add.w	r2, r3, #1
    if ((x & 3) == 0)
 800bb88:	f001 8028 	beq.w	800cbdc <draw_all+0x139c>
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800bb8c:	428c      	cmp	r4, r1
    power -= 100;
 800bb8e:	f1a1 0164 	sub.w	r1, r1, #100	@ 0x64
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800bb92:	f2c1 8028 	blt.w	800cbe6 <draw_all+0x13a6>
 800bb96:	f103 01d8 	add.w	r1, r3, #216	@ 0xd8
 800bb9a:	4469      	add	r1, sp
 800bb9c:	20bd      	movs	r0, #189	@ 0xbd
 800bb9e:	f801 0c50 	strb.w	r0, [r1, #-80]
  string_buf[x++] = 0b10000001;
 800bba2:	446a      	add	r2, sp
 800bba4:	2081      	movs	r0, #129	@ 0x81
 800bba6:	f882 0088 	strb.w	r0, [r2, #136]	@ 0x88
  string_buf[x++] = 0b11111111;
 800bbaa:	3303      	adds	r3, #3
  lcd_blitBitmap(BATTERY_ICON_POSX, BATTERY_ICON_POSY, 8, x, string_buf);
 800bbac:	aa22      	add	r2, sp, #136	@ 0x88
  string_buf[x++] = 0b11111111;
 800bbae:	20ff      	movs	r0, #255	@ 0xff
 800bbb0:	f801 0c4e 	strb.w	r0, [r1, #-78]
  lcd_blitBitmap(BATTERY_ICON_POSX, BATTERY_ICON_POSY, 8, x, string_buf);
 800bbb4:	b29b      	uxth	r3, r3
 800bbb6:	9200      	str	r2, [sp, #0]
 800bbb8:	2102      	movs	r1, #2
 800bbba:	2208      	movs	r2, #8
 800bbbc:	2003      	movs	r0, #3
 800bbbe:	f004 fab1 	bl	8010124 <lcd_blitBitmap>
 800bbc2:	e669      	b.n	800b898 <draw_all+0x58>
    lcd_set_background(LCD_BG_COLOR);
 800bbc4:	2000      	movs	r0, #0
 800bbc6:	f004 fa8f 	bl	80100e8 <lcd_set_background>
    lcd_clear_screen();
 800bbca:	f004 fa33 	bl	8010034 <lcd_clear_screen>
  if (redraw_request & REDRAW_AREA)
 800bbce:	4b79      	ldr	r3, [pc, #484]	@ (800bdb4 <draw_all+0x574>)
 800bbd0:	881c      	ldrh	r4, [r3, #0]
 800bbd2:	07a6      	lsls	r6, r4, #30
 800bbd4:	f57f ae4a 	bpl.w	800b86c <draw_all+0x2c>
 800bbd8:	e673      	b.n	800b8c2 <draw_all+0x82>
    redraw_request = 0;
 800bbda:	4a76      	ldr	r2, [pc, #472]	@ (800bdb4 <draw_all+0x574>)
 800bbdc:	8013      	strh	r3, [r2, #0]
}
 800bbde:	b037      	add	sp, #220	@ 0xdc
 800bbe0:	ecbd 8b04 	vpop	{d8-d9}
 800bbe4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  markmap_all_markers();
 800bbe8:	4c74      	ldr	r4, [pc, #464]	@ (800bdbc <draw_all+0x57c>)
 800bbea:	f8df a1fc 	ldr.w	sl, [pc, #508]	@ 800bde8 <draw_all+0x5a8>
 800bbee:	f7ff fb67 	bl	800b2c0 <markmap_all_markers>
  float (*array)[2] = measured[trace[t].channel];
 800bbf2:	46a0      	mov	r8, r4
 800bbf4:	9407      	str	r4, [sp, #28]
 800bbf6:	4654      	mov	r4, sl
    if (trace[t].enabled)
 800bbf8:	f898 3028 	ldrb.w	r3, [r8, #40]	@ 0x28
 800bbfc:	b9a3      	cbnz	r3, 800bc28 <draw_all+0x3e8>
  for (int t = 0; t < TRACES_MAX; t++)
 800bbfe:	4b70      	ldr	r3, [pc, #448]	@ (800bdc0 <draw_all+0x580>)
 800bc00:	f108 080c 	add.w	r8, r8, #12
 800bc04:	4598      	cmp	r8, r3
 800bc06:	f204 6444 	addw	r4, r4, #1604	@ 0x644
 800bc0a:	d1f5      	bne.n	800bbf8 <draw_all+0x3b8>
  if (props_mode & TD_MARKER_TRACK)
 800bc0c:	9c07      	ldr	r4, [sp, #28]
 800bc0e:	8b23      	ldrh	r3, [r4, #24]
 800bc10:	061b      	lsls	r3, r3, #24
 800bc12:	f101 813e 	bmi.w	800ce92 <draw_all+0x1652>
  data_update |= flag;
 800bc16:	4c6b      	ldr	r4, [pc, #428]	@ (800bdc4 <draw_all+0x584>)
 800bc18:	7823      	ldrb	r3, [r4, #0]
  request_to_redraw(REDRAW_MARKER | REDRAW_CELLS);
 800bc1a:	2024      	movs	r0, #36	@ 0x24
  data_update |= flag;
 800bc1c:	f043 0301 	orr.w	r3, r3, #1
 800bc20:	7023      	strb	r3, [r4, #0]
  request_to_redraw(REDRAW_MARKER | REDRAW_CELLS);
 800bc22:	f7ff fde5 	bl	800b7f0 <request_to_redraw>
}
 800bc26:	e615      	b.n	800b854 <draw_all+0x14>
  uint16_t start = 0, stop = sweep_points - 1, i;
 800bc28:	9b07      	ldr	r3, [sp, #28]
  float (*array)[2] = measured[trace[t].channel];
 800bc2a:	4a67      	ldr	r2, [pc, #412]	@ (800bdc8 <draw_all+0x588>)
 800bc2c:	f898 602a 	ldrb.w	r6, [r8, #42]	@ 0x2a
  uint16_t start = 0, stop = sweep_points - 1, i;
 800bc30:	8b59      	ldrh	r1, [r3, #26]
  uint32_t type = 1 << trace[t].type;
 800bc32:	f898 3029 	ldrb.w	r3, [r8, #41]	@ 0x29
  float scale = get_trace_scale(t);
 800bc36:	edd8 7a0b 	vldr	s15, [r8, #44]	@ 0x2c
  float (*array)[2] = measured[trace[t].channel];
 800bc3a:	f640 4088 	movw	r0, #3208	@ 0xc88
 800bc3e:	fb00 2606 	mla	r6, r0, r6, r2
  if (type & RECTANGULAR_GRID_MASK)
 800bc42:	4862      	ldr	r0, [pc, #392]	@ (800bdcc <draw_all+0x58c>)
  uint32_t type = 1 << trace[t].type;
 800bc44:	2201      	movs	r2, #1
 800bc46:	409a      	lsls	r2, r3
  uint16_t start = 0, stop = sweep_points - 1, i;
 800bc48:	3901      	subs	r1, #1
  if (type & RECTANGULAR_GRID_MASK)
 800bc4a:	ea12 0500 	ands.w	r5, r2, r0
  uint16_t start = 0, stop = sweep_points - 1, i;
 800bc4e:	b28f      	uxth	r7, r1
  if (type & RECTANGULAR_GRID_MASK)
 800bc50:	f041 8070 	bne.w	800cd34 <draw_all+0x14f4>
  if (type & ROUND_GRID_MASK)
 800bc54:	f012 0f18 	tst.w	r2, #24
 800bc58:	d0d1      	beq.n	800bbfe <draw_all+0x3be>
    const float rscale = P_RADIUS / scale;
 800bc5a:	ed9f 7a5d 	vldr	s14, [pc, #372]	@ 800bdd0 <draw_all+0x590>
 800bc5e:	ee87 6a27 	vdiv.f32	s12, s14, s15
    for (i = start; i <= stop; i++)
 800bc62:	4629      	mov	r1, r5
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800bc64:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
      cartesian_scale(array[i], &x, &y, rscale);
 800bc68:	b2ab      	uxth	r3, r5
 800bc6a:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800bc6e:	edd3 7a00 	vldr	s15, [r3]
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800bc72:	edd3 5a01 	vldr	s11, [r3, #4]
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800bc76:	eeb0 7a66 	vmov.f32	s14, s13
 800bc7a:	eea6 7a27 	vfma.f32	s14, s12, s15
      mark_set_index(index, i, x, y);
 800bc7e:	4620      	mov	r0, r4
    for (i = start; i <= stop; i++)
 800bc80:	3501      	adds	r5, #1
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800bc82:	eef0 7a66 	vmov.f32	s15, s13
 800bc86:	eee6 7a25 	vfma.f32	s15, s12, s11
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800bc8a:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800bc8e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800bc92:	ee17 2a10 	vmov	r2, s14
 800bc96:	32e8      	adds	r2, #232	@ 0xe8
  else if (x > CELLOFFSETX + WIDTH)
 800bc98:	b212      	sxth	r2, r2
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800bc9a:	ee17 3a90 	vmov	r3, s15
  if (x < CELLOFFSETX)
 800bc9e:	f5b2 7fe6 	cmp.w	r2, #460	@ 0x1cc
 800bca2:	bfa8      	it	ge
 800bca4:	f44f 72e6 	movge.w	r2, #460	@ 0x1cc
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800bca8:	f1c3 0398 	rsb	r3, r3, #152	@ 0x98
  if (x < CELLOFFSETX)
 800bcac:	2a05      	cmp	r2, #5
  else if (y > HEIGHT)
 800bcae:	b21b      	sxth	r3, r3
  if (x < CELLOFFSETX)
 800bcb0:	bfb8      	it	lt
 800bcb2:	2205      	movlt	r2, #5
  if (y < 0)
 800bcb4:	f5b3 7f98 	cmp.w	r3, #304	@ 0x130
 800bcb8:	bfa8      	it	ge
 800bcba:	f44f 7398 	movge.w	r3, #304	@ 0x130
 800bcbe:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
      mark_set_index(index, i, x, y);
 800bcc2:	b292      	uxth	r2, r2
 800bcc4:	b29b      	uxth	r3, r3
 800bcc6:	f7fd fce3 	bl	8009690 <mark_set_index>
    for (i = start; i <= stop; i++)
 800bcca:	b2a9      	uxth	r1, r5
 800bccc:	428f      	cmp	r7, r1
 800bcce:	d2cb      	bcs.n	800bc68 <draw_all+0x428>
 800bcd0:	e795      	b.n	800bbfe <draw_all+0x3be>
    return;

  float scale  = get_trace_scale(3);
  float refpos = HEIGHT - (get_trace_refpos(3)) * GRIDY + 0.5f;
 800bcd2:	eddf 7a40 	vldr	s15, [pc, #256]	@ 800bdd4 <draw_all+0x594>
  float scale  = get_trace_scale(3);
 800bcd6:	edd3 6a14 	vldr	s13, [r3, #80]	@ 0x50
  float dscale = GRIDY / scale;

  // --- SWR reference lines (cyan) ---
  const float refs[] = {1.5f, 2.0f, 3.0f};
 800bcda:	4d3f      	ldr	r5, [pc, #252]	@ (800bdd8 <draw_all+0x598>)
  float refpos = HEIGHT - (get_trace_refpos(3)) * GRIDY + 0.5f;
 800bcdc:	ed93 7a15 	vldr	s14, [r3, #84]	@ 0x54
 800bce0:	ed9f 8a3e 	vldr	s16, [pc, #248]	@ 800bddc <draw_all+0x59c>
  float dscale = GRIDY / scale;
 800bce4:	eec7 8aa6 	vdiv.f32	s17, s15, s13
  const float refs[] = {1.5f, 2.0f, 3.0f};
 800bce8:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800bcec:	ac1c      	add	r4, sp, #112	@ 0x70
 800bcee:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  const int nrefs = sizeof(refs) / sizeof(refs[0]);

  lcd_set_foreground(LCD_TRACE_1_COLOR + 1); // match SWR trace color (your "cyan")
 800bcf2:	2007      	movs	r0, #7
 800bcf4:	ae1f      	add	r6, sp, #124	@ 0x7c
  float refpos = HEIGHT - (get_trace_refpos(3)) * GRIDY + 0.5f;
 800bcf6:	eea7 8a67 	vfms.f32	s16, s14, s15
  lcd_set_foreground(LCD_TRACE_1_COLOR + 1); // match SWR trace color (your "cyan")
 800bcfa:	f004 f9e9 	bl	80100d0 <lcd_set_foreground>

  for (int i = 0; i < nrefs; i++)
  {
    float v = refs[i] - 1.0f;            // SWR offset from 1.0 baseline
 800bcfe:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
 800bd02:	eef1 8a68 	vneg.f32	s17, s17
 800bd06:	ecb4 7a01 	vldmia	r4!, {s14}
 800bd0a:	ee37 7a49 	vsub.f32	s14, s14, s18
    int y   = (int)(refpos - v * dscale);
 800bd0e:	eef0 7a48 	vmov.f32	s15, s16
 800bd12:	eee8 7a87 	vfma.f32	s15, s17, s14
 800bd16:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bd1a:	ee17 3a90 	vmov	r3, s15

    if (y >= 0 && y < HEIGHT)
 800bd1e:	f5b3 7f98 	cmp.w	r3, #304	@ 0x130
 800bd22:	f0c1 80ba 	bcc.w	800ce9a <draw_all+0x165a>
  for (int i = 0; i < nrefs; i++)
 800bd26:	42a6      	cmp	r6, r4
 800bd28:	d1ed      	bne.n	800bd06 <draw_all+0x4c6>
  }

  // --- Labels in the left margin (aligned to the same Y) ---
  // If you also want "1.0", add it here:
  // const float labs[] = {1.0f, 1.5f, 2.0f, 3.0f};
  const float labs[] = {1.5f, 2.0f, 3.0f};
 800bd2a:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800bd2e:	ad22      	add	r5, sp, #136	@ 0x88
 800bd30:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  const int nlabs = sizeof(labs) / sizeof(labs[0]);

  lcd_set_font(FONT_SMALL);
  lcd_set_colors(LCD_TRACE_1_COLOR + 1, LCD_BG_COLOR);
 800bd34:	2100      	movs	r1, #0
 800bd36:	2007      	movs	r0, #7
 800bd38:	f004 f9e2 	bl	8010100 <lcd_set_colors>

  int x = UI_SCALE_REF_X0;               // left margin anchor (OFFSETX - 5)

  for (int i = 0; i < nlabs; i++)
  {
    float v = labs[i] - 1.0f;
 800bd3c:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
 800bd40:	af25      	add	r7, sp, #148	@ 0x94
    int font_h = sFONT_STR_HEIGHT;
    int y_text = y - (font_h / 2);

    // Clamp so top-most label (often 1.5) never disappears
    if (y_text < 0) y_text = 0;
    if (y_text > (HEIGHT - font_h)) y_text = HEIGHT - font_h;
 800bd42:	f240 1625 	movw	r6, #293	@ 0x125
    float v = labs[i] - 1.0f;
 800bd46:	ecb5 7a01 	vldmia	r5!, {s14}
 800bd4a:	ee77 6a49 	vsub.f32	s13, s14, s18
    int y   = (int)(refpos - v * dscale);
 800bd4e:	eef0 7a48 	vmov.f32	s15, s16
 800bd52:	eee8 7aa6 	vfma.f32	s15, s17, s13

    lcd_printf(x, y_text, "%.1f", labs[i]);
 800bd56:	ee17 0a10 	vmov	r0, s14
    int y   = (int)(refpos - v * dscale);
 800bd5a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bd5e:	ee17 3a90 	vmov	r3, s15
    int y_text = y - (font_h / 2);
 800bd62:	3b05      	subs	r3, #5
    if (y_text > (HEIGHT - font_h)) y_text = HEIGHT - font_h;
 800bd64:	42b3      	cmp	r3, r6
 800bd66:	bfa8      	it	ge
 800bd68:	4633      	movge	r3, r6
    if (y_text < 0) y_text = 0;
 800bd6a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    lcd_printf(x, y_text, "%.1f", labs[i]);
 800bd6e:	b21c      	sxth	r4, r3
 800bd70:	f7f4 fc16 	bl	80005a0 <__aeabi_f2d>
 800bd74:	4a1a      	ldr	r2, [pc, #104]	@ (800bde0 <draw_all+0x5a0>)
 800bd76:	e9cd 0100 	strd	r0, r1, [sp]
 800bd7a:	4621      	mov	r1, r4
 800bd7c:	200a      	movs	r0, #10
 800bd7e:	f004 fa4f 	bl	8010220 <lcd_printf>
  for (int i = 0; i < nlabs; i++)
 800bd82:	42af      	cmp	r7, r5
 800bd84:	d1df      	bne.n	800bd46 <draw_all+0x506>
}
 800bd86:	b037      	add	sp, #220	@ 0xdc
 800bd88:	ecbd 8b04 	vpop	{d8-d9}
 800bd8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  char lm0 = lever_mode == LM_FREQ_0 ? S_SARROW[0] : ' ';
 800bd90:	2518      	movs	r5, #24
  char lm1 = lever_mode == LM_FREQ_1 ? S_SARROW[0] : ' ';
 800bd92:	2620      	movs	r6, #32
 800bd94:	e60b      	b.n	800b9ae <draw_all+0x16e>
    lcd_set_foreground(LCD_FG_COLOR);
 800bd96:	2001      	movs	r0, #1
 800bd98:	f004 f99a 	bl	80100d0 <lcd_set_foreground>
    lcd_printf(x, y += sFONT_STR_HEIGHT, "s%d", smooth);
 800bd9c:	f106 0121 	add.w	r1, r6, #33	@ 0x21
 800bda0:	4a10      	ldr	r2, [pc, #64]	@ (800bde4 <draw_all+0x5a4>)
 800bda2:	4623      	mov	r3, r4
 800bda4:	b209      	sxth	r1, r1
 800bda6:	2000      	movs	r0, #0
 800bda8:	f004 fa3a 	bl	8010220 <lcd_printf>
 800bdac:	e6cd      	b.n	800bb4a <draw_all+0x30a>
 800bdae:	bf00      	nop
 800bdb0:	08011ee0 	.word	0x08011ee0
 800bdb4:	200089a8 	.word	0x200089a8
 800bdb8:	ff3c3c00 	.word	0xff3c3c00
 800bdbc:	20000aa8 	.word	0x20000aa8
 800bdc0:	20000ad8 	.word	0x20000ad8
 800bdc4:	20006a34 	.word	0x20006a34
 800bdc8:	20004f54 	.word	0x20004f54
 800bdcc:	3fffffe7 	.word	0x3fffffe7
 800bdd0:	43180000 	.word	0x43180000
 800bdd4:	42180000 	.word	0x42180000
 800bdd8:	08011890 	.word	0x08011890
 800bddc:	43984000 	.word	0x43984000
 800bde0:	08011ee8 	.word	0x08011ee8
 800bde4:	08011ee4 	.word	0x08011ee4
 800bde8:	20006a3c 	.word	0x20006a3c
  if (w > area_width - x0)
 800bdec:	4bb8      	ldr	r3, [pc, #736]	@ (800c0d0 <draw_all+0x890>)
 800bdee:	881b      	ldrh	r3, [r3, #0]
 800bdf0:	eba3 030b 	sub.w	r3, r3, fp
  if (w <= 0 || h <= 0)
 800bdf4:	2b00      	cmp	r3, #0
  if (w > area_width - x0)
 800bdf6:	930e      	str	r3, [sp, #56]	@ 0x38
  if (w <= 0 || h <= 0)
 800bdf8:	f340 8161 	ble.w	800c0be <draw_all+0x87e>
  if (h > area_height - y0)
 800bdfc:	4bb5      	ldr	r3, [pc, #724]	@ (800c0d4 <draw_all+0x894>)
 800bdfe:	9a08      	ldr	r2, [sp, #32]
 800be00:	881b      	ldrh	r3, [r3, #0]
 800be02:	1a9b      	subs	r3, r3, r2
  if (w <= 0 || h <= 0)
 800be04:	2b00      	cmp	r3, #0
 800be06:	f340 815a 	ble.w	800c0be <draw_all+0x87e>
  if (h > area_height - y0)
 800be0a:	2b20      	cmp	r3, #32
 800be0c:	bfa8      	it	ge
 800be0e:	2320      	movge	r3, #32
 800be10:	461c      	mov	r4, r3
 800be12:	930a      	str	r3, [sp, #40]	@ 0x28
  cell_buffer = lcd_get_cell_buffer();
 800be14:	f003 ff86 	bl	800fd24 <lcd_get_cell_buffer>
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800be18:	4baf      	ldr	r3, [pc, #700]	@ (800c0d8 <draw_all+0x898>)
  cell_buffer = lcd_get_cell_buffer();
 800be1a:	4ab0      	ldr	r2, [pc, #704]	@ (800c0dc <draw_all+0x89c>)
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800be1c:	930f      	str	r3, [sp, #60]	@ 0x3c
  cell_buffer = lcd_get_cell_buffer();
 800be1e:	6010      	str	r0, [r2, #0]
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800be20:	8bda      	ldrh	r2, [r3, #30]
  int count = h * CELLWIDTH / 8;
 800be22:	b223      	sxth	r3, r4
 800be24:	0099      	lsls	r1, r3, #2
  cell_buffer = lcd_get_cell_buffer();
 800be26:	4680      	mov	r8, r0
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800be28:	eb02 4202 	add.w	r2, r2, r2, lsl #16
  uint32_t *p = (uint32_t *)cell_buffer;
 800be2c:	4603      	mov	r3, r0
  } while (--count);
 800be2e:	3901      	subs	r1, #1
    p[0] = clr;
 800be30:	e9c3 2200 	strd	r2, r2, [r3]
 800be34:	e9c3 2202 	strd	r2, r2, [r3, #8]
    p += 4;
 800be38:	f103 0310 	add.w	r3, r3, #16
  } while (--count);
 800be3c:	d1f7      	bne.n	800be2e <draw_all+0x5ee>
 800be3e:	4ba8      	ldr	r3, [pc, #672]	@ (800c0e0 <draw_all+0x8a0>)
 800be40:	9117      	str	r1, [sp, #92]	@ 0x5c
 800be42:	468c      	mov	ip, r1
  bool use_smith = false;
 800be44:	468a      	mov	sl, r1
 800be46:	930c      	str	r3, [sp, #48]	@ 0x30
 800be48:	f103 0130 	add.w	r1, r3, #48	@ 0x30
  } while (--count);
 800be4c:	930b      	str	r3, [sp, #44]	@ 0x2c
      trace_type |= (1 << trace[t].type);
 800be4e:	2401      	movs	r4, #1
    if (trace[t].enabled)
 800be50:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 800be54:	b182      	cbz	r2, 800be78 <draw_all+0x638>
      trace_type |= (1 << trace[t].type);
 800be56:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800be5a:	fa04 f002 	lsl.w	r0, r4, r2
      if (trace[t].type == TRC_SMITH && !ADMIT_MARKER_VALUE(trace[t].smith_format))
 800be5e:	2a03      	cmp	r2, #3
      trace_type |= (1 << trace[t].type);
 800be60:	ea4c 0c00 	orr.w	ip, ip, r0
      if (trace[t].type == TRC_SMITH && !ADMIT_MARKER_VALUE(trace[t].smith_format))
 800be64:	d108      	bne.n	800be78 <draw_all+0x638>
 800be66:	f893 002b 	ldrb.w	r0, [r3, #43]	@ 0x2b
 800be6a:	f46f 72f0 	mvn.w	r2, #480	@ 0x1e0
 800be6e:	4102      	asrs	r2, r0
 800be70:	f002 0201 	and.w	r2, r2, #1
 800be74:	ea4a 0a02 	orr.w	sl, sl, r2
  for (t = 0; t < TRACES_MAX; t++)
 800be78:	330c      	adds	r3, #12
 800be7a:	428b      	cmp	r3, r1
 800be7c:	d1e8      	bne.n	800be50 <draw_all+0x610>
  c = GET_PALTETTE_COLOR(LCD_GRID_COLOR);
 800be7e:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 800be80:	8c54      	ldrh	r4, [r2, #34]	@ 0x22
  if (w > area_width - x0)
 800be82:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
  if (trace_type & RECTANGULAR_GRID_MASK)
 800be84:	f02c 4340 	bic.w	r3, ip, #3221225472	@ 0xc0000000
  if (w > area_width - x0)
 800be88:	2a20      	cmp	r2, #32
 800be8a:	bfa8      	it	ge
 800be8c:	2220      	movge	r2, #32
  if (trace_type & RECTANGULAR_GRID_MASK)
 800be8e:	f023 0318 	bic.w	r3, r3, #24
  if (w > area_width - x0)
 800be92:	9214      	str	r2, [sp, #80]	@ 0x50
  if (trace_type & RECTANGULAR_GRID_MASK)
 800be94:	2b00      	cmp	r3, #0
 800be96:	f000 8139 	beq.w	800c10c <draw_all+0x8cc>
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800be9a:	4b92      	ldr	r3, [pc, #584]	@ (800c0e4 <draw_all+0x8a4>)
  if (x == 0 || x == WIDTH)
 800be9c:	f8cd 8010 	str.w	r8, [sp, #16]
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800bea0:	8818      	ldrh	r0, [r3, #0]
    const int step = VNA_MODE(VNA_MODE_DOT_GRID) ? 2 : 1;
 800bea2:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800bea4:	8a9b      	ldrh	r3, [r3, #20]
 800bea6:	f013 0f10 	tst.w	r3, #16
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800beaa:	4b8f      	ldr	r3, [pc, #572]	@ (800c0e8 <draw_all+0x8a8>)
 800beac:	f8b3 e000 	ldrh.w	lr, [r3]
        for (y = 0; y < h * CELLWIDTH; y += step * CELLWIDTH)
 800beb0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800beb2:	f5a0 7020 	sub.w	r0, r0, #640	@ 0x280
 800beb6:	4641      	mov	r1, r8
 800beb8:	eb00 10cb 	add.w	r0, r0, fp, lsl #7
  if (x == 0 || x == WIDTH)
 800bebc:	f8dd 8050 	ldr.w	r8, [sp, #80]	@ 0x50
    const int step = VNA_MODE(VNA_MODE_DOT_GRID) ? 2 : 1;
 800bec0:	bf0c      	ite	eq
 800bec2:	2720      	moveq	r7, #32
 800bec4:	2740      	movne	r7, #64	@ 0x40
        for (y = 0; y < h * CELLWIDTH; y += step * CELLWIDTH)
 800bec6:	015e      	lsls	r6, r3, #5
 800bec8:	f1ab 0205 	sub.w	r2, fp, #5
    for (x = 0; x < w; x++)
 800becc:	2500      	movs	r5, #0
  if (x == 0 || x == WIDTH)
 800bece:	f240 19c7 	movw	r9, #455	@ 0x1c7
 800bed2:	e011      	b.n	800bef8 <draw_all+0x6b8>
 800bed4:	454a      	cmp	r2, r9
 800bed6:	d014      	beq.n	800bf02 <draw_all+0x6c2>
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800bed8:	fbb0 f3fe 	udiv	r3, r0, lr
 800bedc:	fb0e 0313 	mls	r3, lr, r3, r0
      if (rectangular_grid_x(x + x0))
 800bee0:	2b7f      	cmp	r3, #127	@ 0x7f
 800bee2:	d90e      	bls.n	800bf02 <draw_all+0x6c2>
    for (x = 0; x < w; x++)
 800bee4:	3501      	adds	r5, #1
 800bee6:	45a8      	cmp	r8, r5
 800bee8:	f102 0201 	add.w	r2, r2, #1
 800beec:	f100 0080 	add.w	r0, r0, #128	@ 0x80
 800bef0:	f101 0102 	add.w	r1, r1, #2
 800bef4:	f340 8108 	ble.w	800c108 <draw_all+0x8c8>
  if ((uint32_t)x > WIDTH)
 800bef8:	f5b2 7fe4 	cmp.w	r2, #456	@ 0x1c8
 800befc:	d2f2      	bcs.n	800bee4 <draw_all+0x6a4>
  if (x == 0 || x == WIDTH)
 800befe:	2a00      	cmp	r2, #0
 800bf00:	d1e8      	bne.n	800bed4 <draw_all+0x694>
 800bf02:	2300      	movs	r3, #0
          cell_buffer[y + x] = c;
 800bf04:	f821 4013 	strh.w	r4, [r1, r3, lsl #1]
        for (y = 0; y < h * CELLWIDTH; y += step * CELLWIDTH)
 800bf08:	443b      	add	r3, r7
 800bf0a:	42b3      	cmp	r3, r6
 800bf0c:	dbfa      	blt.n	800bf04 <draw_all+0x6c4>
 800bf0e:	e7e9      	b.n	800bee4 <draw_all+0x6a4>
  if (y0 <= marker_area_max())
 800bf10:	f7fe fb32 	bl	800a578 <marker_area_max>
 800bf14:	9b08      	ldr	r3, [sp, #32]
 800bf16:	4283      	cmp	r3, r0
 800bf18:	f340 835a 	ble.w	800c5d0 <draw_all+0xd90>
  if (y0 == CELLHEIGHT)
 800bf1c:	9b15      	ldr	r3, [sp, #84]	@ 0x54
  if (mla_resonance_locked && (swr > 0.0f) && (swr < 100.0f)) {
 800bf1e:	4e73      	ldr	r6, [pc, #460]	@ (800c0ec <draw_all+0x8ac>)
  if (y0 == CELLHEIGHT)
 800bf20:	2b01      	cmp	r3, #1
 800bf22:	f000 8543 	beq.w	800c9ac <draw_all+0x116c>
 800bf26:	ac22      	add	r4, sp, #136	@ 0x88
  const uint32_t bw_hz = (uint32_t)mla_bw_swr2;
 800bf28:	4d71      	ldr	r5, [pc, #452]	@ (800c0f0 <draw_all+0x8b0>)
 800bf2a:	682b      	ldr	r3, [r5, #0]
  if (bw_hz > 0)
 800bf2c:	2b00      	cmp	r3, #0
 800bf2e:	f000 82e7 	beq.w	800c500 <draw_all+0xcc0>
  const uint32_t bw_khz = (bw_hz + 500U) / 1000U;
 800bf32:	4a70      	ldr	r2, [pc, #448]	@ (800c0f4 <draw_all+0x8b4>)
 800bf34:	f503 73fa 	add.w	r3, r3, #500	@ 0x1f4
 800bf38:	fba2 2303 	umull	r2, r3, r2, r3
    plot_printf(msg, (int)sizeof(msg), "BW2=%u kHz", (unsigned)bw_khz);
 800bf3c:	099b      	lsrs	r3, r3, #6
 800bf3e:	4a6e      	ldr	r2, [pc, #440]	@ (800c0f8 <draw_all+0x8b8>)
 800bf40:	2120      	movs	r1, #32
 800bf42:	4620      	mov	r0, r4
 800bf44:	f7f6 febe 	bl	8002cc4 <plot_printf>
  const int text_w = cell_string_width(msg) * 2;
 800bf48:	4620      	mov	r0, r4
 800bf4a:	f7fd fccb 	bl	80098e4 <cell_string_width>
 800bf4e:	0040      	lsls	r0, r0, #1
  if (x >= x0 + CELLWIDTH || x + text_w <= x0)
 800bf50:	f100 0209 	add.w	r2, r0, #9
 800bf54:	4593      	cmp	fp, r2
 800bf56:	dc14      	bgt.n	800bf82 <draw_all+0x742>
  if (y >= y0 + CELLHEIGHT || y + text_h <= y0)
 800bf58:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800bf5a:	2b34      	cmp	r3, #52	@ 0x34
 800bf5c:	d811      	bhi.n	800bf82 <draw_all+0x742>
  cell_fill_bg_rect(x0, y0, x, y, text_wt, text_ht);
 800bf5e:	220a      	movs	r2, #10
 800bf60:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800bf64:	9000      	str	r0, [sp, #0]
 800bf66:	f44f 7385 	mov.w	r3, #266	@ 0x10a
 800bf6a:	4658      	mov	r0, fp
 800bf6c:	f7fe fb3e 	bl	800a5ec <cell_fill_bg_rect.constprop.0>
  lcd_set_foreground(LCD_SPEC_INPUT_COLOR);
 800bf70:	200e      	movs	r0, #14
 800bf72:	f004 f8ad 	bl	80100d0 <lcd_set_foreground>
  cell_drawstring_big(msg, x - x0, y - y0);
 800bf76:	220a      	movs	r2, #10
 800bf78:	eba2 010b 	sub.w	r1, r2, fp
 800bf7c:	4620      	mov	r0, r4
 800bf7e:	f7fd fccd 	bl	800991c <cell_drawstring_big>
  if (mla_resonance_locked && mla_res_freq != 0 && mla_bw_swr2 != 0)
 800bf82:	7833      	ldrb	r3, [r6, #0]
 800bf84:	b133      	cbz	r3, 800bf94 <draw_all+0x754>
 800bf86:	4b5d      	ldr	r3, [pc, #372]	@ (800c0fc <draw_all+0x8bc>)
 800bf88:	681b      	ldr	r3, [r3, #0]
 800bf8a:	b11b      	cbz	r3, 800bf94 <draw_all+0x754>
 800bf8c:	682a      	ldr	r2, [r5, #0]
 800bf8e:	2a00      	cmp	r2, #0
 800bf90:	f040 867d 	bne.w	800cc8e <draw_all+0x144e>
    plot_printf(msg, (int)sizeof(msg), "Q=--");
 800bf94:	4a5a      	ldr	r2, [pc, #360]	@ (800c100 <draw_all+0x8c0>)
 800bf96:	2118      	movs	r1, #24
 800bf98:	4620      	mov	r0, r4
 800bf9a:	f7f6 fe93 	bl	8002cc4 <plot_printf>
  const int text_w = cell_string_width(msg) * 2; // big font = 2x
 800bf9e:	4620      	mov	r0, r4
 800bfa0:	f7fd fca0 	bl	80098e4 <cell_string_width>
 800bfa4:	0045      	lsls	r5, r0, #1
  const int x = CELLOFFSETX + WIDTH - margin - text_w;
 800bfa6:	f5c5 75e2 	rsb	r5, r5, #452	@ 0x1c4
  if (x >= x0 + CELLWIDTH || x + text_w <= x0)
 800bfaa:	f10b 031f 	add.w	r3, fp, #31
 800bfae:	429d      	cmp	r5, r3
 800bfb0:	dc1c      	bgt.n	800bfec <draw_all+0x7ac>
 800bfb2:	f5bb 7fe2 	cmp.w	fp, #452	@ 0x1c4
 800bfb6:	f080 84cd 	bcs.w	800c954 <draw_all+0x1114>
  if (y >= y0 + CELLHEIGHT || y + text_h <= y0)
 800bfba:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800bfbc:	2b34      	cmp	r3, #52	@ 0x34
 800bfbe:	d815      	bhi.n	800bfec <draw_all+0x7ac>
  lcd_set_foreground(LCD_SPEC_INPUT_COLOR); // bright green
 800bfc0:	200e      	movs	r0, #14
 800bfc2:	f004 f885 	bl	80100d0 <lcd_set_foreground>
  const int text_wt = cell_string_width(msg) * 2;
 800bfc6:	4620      	mov	r0, r4
 800bfc8:	f7fd fc8c 	bl	80098e4 <cell_string_width>
 800bfcc:	0040      	lsls	r0, r0, #1
  cell_fill_bg_rect(x0, y0, x, y, text_wt, text_ht);
 800bfce:	9000      	str	r0, [sp, #0]
 800bfd0:	462a      	mov	r2, r5
 800bfd2:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800bfd6:	4658      	mov	r0, fp
 800bfd8:	f44f 7385 	mov.w	r3, #266	@ 0x10a
 800bfdc:	f7fe fb06 	bl	800a5ec <cell_fill_bg_rect.constprop.0>
  cell_drawstring_big(msg, x - x0, y - y0);
 800bfe0:	eba5 010b 	sub.w	r1, r5, fp
 800bfe4:	4620      	mov	r0, r4
 800bfe6:	220a      	movs	r2, #10
 800bfe8:	f7fd fc98 	bl	800991c <cell_drawstring_big>
  if (current_props._measure >= MEASURE_END)
 800bfec:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800bfee:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800bff2:	2b07      	cmp	r3, #7
 800bff4:	d811      	bhi.n	800c01a <draw_all+0x7da>
  measure_cell_cb_t measure_draw_cb = measure[current_props._measure].measure_cell;
 800bff6:	4a43      	ldr	r2, [pc, #268]	@ (800c104 <draw_all+0x8c4>)
 800bff8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800bffc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800c000:	685c      	ldr	r4, [r3, #4]
  if (measure_draw_cb)
 800c002:	b154      	cbz	r4, 800c01a <draw_all+0x7da>
    lcd_set_colors(LCD_MEASURE_COLOR, LCD_BG_COLOR);
 800c004:	2100      	movs	r1, #0
 800c006:	2015      	movs	r0, #21
 800c008:	f004 f87a 	bl	8010100 <lcd_set_colors>
    measure_draw_cb(STR_MEASURE_X - x0, STR_MEASURE_Y - y0);
 800c00c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800c00e:	f06f 019a 	mvn.w	r1, #154	@ 0x9a
 800c012:	1ac9      	subs	r1, r1, r3
 800c014:	f1cb 000f 	rsb	r0, fp, #15
 800c018:	47a0      	blx	r4
  if ((uint32_t)(x + REFERENCE_WIDTH) >= CELLWIDTH + REFERENCE_WIDTH)
 800c01a:	f1cb 0306 	rsb	r3, fp, #6
 800c01e:	2b25      	cmp	r3, #37	@ 0x25
 800c020:	d828      	bhi.n	800c074 <draw_all+0x834>
    if (!trace[t].enabled || ((1 << trace[t].type) & (ROUND_GRID_MASK)))
 800c022:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800c026:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800c028:	eeb6 8a00 	vmov.f32	s16, #96	@ 0x3f000000  0.5
 800c02c:	2406      	movs	r4, #6
    if (!trace[t].enabled || ((1 << trace[t].type) & (ROUND_GRID_MASK)))
 800c02e:	2518      	movs	r5, #24
 800c030:	f896 3028 	ldrb.w	r3, [r6, #40]	@ 0x28
 800c034:	b1c3      	cbz	r3, 800c068 <draw_all+0x828>
 800c036:	f896 3029 	ldrb.w	r3, [r6, #41]	@ 0x29
 800c03a:	fa45 f303 	asr.w	r3, r5, r3
 800c03e:	f013 0901 	ands.w	r9, r3, #1
 800c042:	d111      	bne.n	800c068 <draw_all+0x828>
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800c044:	ed96 7a0c 	vldr	s14, [r6, #48]	@ 0x30
 800c048:	eef0 7a48 	vmov.f32	s15, s16
 800c04c:	eee7 7a28 	vfma.f32	s15, s14, s17
 800c050:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800c054:	ee17 7a90 	vmov	r7, s15
 800c058:	f5c7 7798 	rsb	r7, r7, #304	@ 0x130
 800c05c:	eba7 0708 	sub.w	r7, r7, r8
    if ((uint32_t)(y + REFERENCE_HEIGHT) < CELLHEIGHT + REFERENCE_HEIGHT)
 800c060:	1cfb      	adds	r3, r7, #3
 800c062:	2b24      	cmp	r3, #36	@ 0x24
 800c064:	f240 82a7 	bls.w	800c5b6 <draw_all+0xd76>
  for (int t = 0; t < TRACES_MAX; t++)
 800c068:	3401      	adds	r4, #1
 800c06a:	b2a4      	uxth	r4, r4
 800c06c:	2c0a      	cmp	r4, #10
 800c06e:	f106 060c 	add.w	r6, r6, #12
 800c072:	d1dd      	bne.n	800c030 <draw_all+0x7f0>
  if (w < CELLWIDTH)
 800c074:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 800c076:	2b1f      	cmp	r3, #31
 800c078:	dc1a      	bgt.n	800c0b0 <draw_all+0x870>
    pixel_t *src = cell_buffer + CELLWIDTH;
 800c07a:	4b18      	ldr	r3, [pc, #96]	@ (800c0dc <draw_all+0x89c>)
    for (y = h; --y; src += CELLWIDTH - w)
 800c07c:	990a      	ldr	r1, [sp, #40]	@ 0x28
    pixel_t *src = cell_buffer + CELLWIDTH;
 800c07e:	681c      	ldr	r4, [r3, #0]
    pixel_t *dst = cell_buffer + w;
 800c080:	9a14      	ldr	r2, [sp, #80]	@ 0x50
    for (y = h; --y; src += CELLWIDTH - w)
 800c082:	1e4d      	subs	r5, r1, #1
    pixel_t *src = cell_buffer + CELLWIDTH;
 800c084:	f104 0340 	add.w	r3, r4, #64	@ 0x40
    pixel_t *dst = cell_buffer + w;
 800c088:	ea4f 0642 	mov.w	r6, r2, lsl #1
 800c08c:	eb04 0442 	add.w	r4, r4, r2, lsl #1
    for (y = h; --y; src += CELLWIDTH - w)
 800c090:	d00e      	beq.n	800c0b0 <draw_all+0x870>
 800c092:	f1c2 0720 	rsb	r7, r2, #32
 800c096:	007f      	lsls	r7, r7, #1
      for (x = w; x--;)
 800c098:	1ea2      	subs	r2, r4, #2
 800c09a:	1998      	adds	r0, r3, r6
        *dst++ = *src++;
 800c09c:	f833 1b02 	ldrh.w	r1, [r3], #2
 800c0a0:	f822 1f02 	strh.w	r1, [r2, #2]!
      for (x = w; x--;)
 800c0a4:	4283      	cmp	r3, r0
 800c0a6:	d1f9      	bne.n	800c09c <draw_all+0x85c>
    for (y = h; --y; src += CELLWIDTH - w)
 800c0a8:	3d01      	subs	r5, #1
 800c0aa:	4434      	add	r4, r6
 800c0ac:	443b      	add	r3, r7
 800c0ae:	d1f3      	bne.n	800c098 <draw_all+0x858>
  lcd_bulk_continue(OFFSETX + x0, OFFSETY + y0, w, h);
 800c0b0:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800c0b2:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 800c0b4:	9908      	ldr	r1, [sp, #32]
 800c0b6:	f10b 000f 	add.w	r0, fp, #15
 800c0ba:	f003 fef9 	bl	800feb0 <lcd_bulk_continue>
    for (m = 0; update_map && m < w; update_map >>= 1, m++)
 800c0be:	9b07      	ldr	r3, [sp, #28]
 800c0c0:	085b      	lsrs	r3, r3, #1
 800c0c2:	f10b 0b20 	add.w	fp, fp, #32
 800c0c6:	9307      	str	r3, [sp, #28]
 800c0c8:	f47f ac40 	bne.w	800b94c <draw_all+0x10c>
 800c0cc:	e44c      	b.n	800b968 <draw_all+0x128>
 800c0ce:	bf00      	nop
 800c0d0:	200003da 	.word	0x200003da
 800c0d4:	200003d8 	.word	0x200003d8
 800c0d8:	20000318 	.word	0x20000318
 800c0dc:	200089a4 	.word	0x200089a4
 800c0e0:	20000aa8 	.word	0x20000aa8
 800c0e4:	20006a38 	.word	0x20006a38
 800c0e8:	20006a36 	.word	0x20006a36
 800c0ec:	20006875 	.word	0x20006875
 800c0f0:	20006868 	.word	0x20006868
 800c0f4:	10624dd3 	.word	0x10624dd3
 800c0f8:	08011e54 	.word	0x08011e54
 800c0fc:	2000687c 	.word	0x2000687c
 800c100:	08011e74 	.word	0x08011e74
 800c104:	08014200 	.word	0x08014200
 800c108:	f8dd 8010 	ldr.w	r8, [sp, #16]
  if (trace_type & (1 << TRC_SMITH))
 800c10c:	f01c 0908 	ands.w	r9, ip, #8
 800c110:	f000 81fc 	beq.w	800c50c <draw_all+0xccc>
    if (use_smith)
 800c114:	f1ba 0f00 	cmp.w	sl, #0
 800c118:	f000 83fa 	beq.w	800c910 <draw_all+0x10d0>
  for (y = 0; y < h; y++)
 800c11c:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800c11e:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 800c122:	f8cd 8010 	str.w	r8, [sp, #16]
 800c126:	4646      	mov	r6, r8
 800c128:	2300      	movs	r3, #0
 800c12a:	f1ab 05e8 	sub.w	r5, fp, #232	@ 0xe8
 800c12e:	f8cd b040 	str.w	fp, [sp, #64]	@ 0x40
 800c132:	f102 0a53 	add.w	sl, r2, #83	@ 0x53
 800c136:	4698      	mov	r8, r3
 800c138:	46b3      	mov	fp, r6
      if (smith_grid(x + x0, y + y0))
 800c13a:	eb0a 0708 	add.w	r7, sl, r8
    for (x = 0; x < w; x++)
 800c13e:	2600      	movs	r6, #0
      if (smith_grid(x + x0, y + y0))
 800c140:	4639      	mov	r1, r7
 800c142:	19a8      	adds	r0, r5, r6
 800c144:	f7fd f9ba 	bl	80094bc <smith_grid>
 800c148:	b108      	cbz	r0, 800c14e <draw_all+0x90e>
        cell_buffer[y * CELLWIDTH + x] = color;
 800c14a:	f82b 4016 	strh.w	r4, [fp, r6, lsl #1]
    for (x = 0; x < w; x++)
 800c14e:	3601      	adds	r6, #1
 800c150:	45b1      	cmp	r9, r6
 800c152:	dcf5      	bgt.n	800c140 <draw_all+0x900>
  for (y = 0; y < h; y++)
 800c154:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800c156:	f108 0801 	add.w	r8, r8, #1
 800c15a:	4543      	cmp	r3, r8
 800c15c:	f10b 0b40 	add.w	fp, fp, #64	@ 0x40
 800c160:	dceb      	bgt.n	800c13a <draw_all+0x8fa>
 800c162:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800c166:	f8dd b040 	ldr.w	fp, [sp, #64]	@ 0x40
    if (((1 << trace[t].type) & RECTANGULAR_GRID_MASK) && !enabled_store_trace && sweep_points > 30)
 800c16a:	4bb2      	ldr	r3, [pc, #712]	@ (800c434 <draw_all+0xbf4>)
 800c16c:	4ab2      	ldr	r2, [pc, #712]	@ (800c438 <draw_all+0xbf8>)
 800c16e:	f893 a000 	ldrb.w	sl, [r3]
    if (!needProcessTrace(t))
 800c172:	f01a 0f01 	tst.w	sl, #1
 800c176:	f000 85a3 	beq.w	800ccc0 <draw_all+0x1480>
  int head = 0, tail = sweep_points;
 800c17a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800c17c:	f8b3 901a 	ldrh.w	r9, [r3, #26]
    c = GET_PALTETTE_COLOR(LCD_TRACE_1_COLOR + t);
 800c180:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
      i1 = sweep_points - 1;
 800c182:	f109 39ff 	add.w	r9, r9, #4294967295
    for (int i = i0; i < i1; i++)
 800c186:	f1b9 0f00 	cmp.w	r9, #0
    c = GET_PALTETTE_COLOR(LCD_TRACE_1_COLOR + t);
 800c18a:	f8b3 e032 	ldrh.w	lr, [r3, #50]	@ 0x32
    for (int i = i0; i < i1; i++)
 800c18e:	f340 8597 	ble.w	800ccc0 <draw_all+0x1480>
 800c192:	4baa      	ldr	r3, [pc, #680]	@ (800c43c <draw_all+0xbfc>)
    int i0 = 0, i1 = 0;
 800c194:	f04f 0c00 	mov.w	ip, #0
    for (int i = i0; i < i1; i++)
 800c198:	2004      	movs	r0, #4
 800c19a:	eb02 0989 	add.w	r9, r2, r9, lsl #2
 800c19e:	e9cd a010 	strd	sl, r0, [sp, #64]	@ 0x40
 800c1a2:	e9cd 3212 	strd	r3, r2, [sp, #72]	@ 0x48
 800c1a6:	f8cd 9010 	str.w	r9, [sp, #16]
 800c1aa:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800c1ae:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
      int x1 = index[i].x - x0;
 800c1b2:	f8bc 3000 	ldrh.w	r3, [ip]
      int y1 = index[i].y - y0;
 800c1b6:	f8bc 0002 	ldrh.w	r0, [ip, #2]
      int x2 = index[i + 1].x - x0;
 800c1ba:	f8bc a004 	ldrh.w	sl, [ip, #4]
      int y2 = index[i + 1].y - y0;
 800c1be:	f8bc 6006 	ldrh.w	r6, [ip, #6]
  if (x0 < 0 && x1 < 0)
 800c1c2:	ebb3 050b 	subs.w	r5, r3, fp
      int y1 = index[i].y - y0;
 800c1c6:	eba0 0709 	sub.w	r7, r0, r9
      int x2 = index[i + 1].x - x0;
 800c1ca:	ebaa 020b 	sub.w	r2, sl, fp
      int y2 = index[i + 1].y - y0;
 800c1ce:	eba6 0109 	sub.w	r1, r6, r9
  if (x0 < 0 && x1 < 0)
 800c1d2:	f100 8089 	bmi.w	800c2e8 <draw_all+0xaa8>
  if (y0 < 0 && y1 < 0)
 800c1d6:	2f00      	cmp	r7, #0
 800c1d8:	f2c0 80a8 	blt.w	800c32c <draw_all+0xaec>
  if (x0 >= CELLWIDTH && x1 >= CELLWIDTH)
 800c1dc:	2d1f      	cmp	r5, #31
 800c1de:	f340 80d2 	ble.w	800c386 <draw_all+0xb46>
 800c1e2:	2a1f      	cmp	r2, #31
 800c1e4:	dc34      	bgt.n	800c250 <draw_all+0xa10>
  if (y0 >= CELLHEIGHT && y1 >= CELLHEIGHT)
 800c1e6:	2f1f      	cmp	r7, #31
 800c1e8:	f340 80a7 	ble.w	800c33a <draw_all+0xafa>
 800c1ec:	291f      	cmp	r1, #31
 800c1ee:	dc2f      	bgt.n	800c250 <draw_all+0xa10>
  if (y1 < y0)
 800c1f0:	42b0      	cmp	r0, r6
 800c1f2:	f240 8084 	bls.w	800c2fe <draw_all+0xabe>
  int dx = (x0 - x1), sx = 1;
 800c1f6:	ebaa 0403 	sub.w	r4, sl, r3
 800c1fa:	f04f 0a01 	mov.w	sl, #1
  int dy = (y1 - y0);
 800c1fe:	1a78      	subs	r0, r7, r1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c200:	42e0      	cmn	r0, r4
 800c202:	f100 80aa 	bmi.w	800c35a <draw_all+0xb1a>
 800c206:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
 800c20a:	105b      	asrs	r3, r3, #1
 800c20c:	425b      	negs	r3, r3
  if (y0 < 0)
 800c20e:	2900      	cmp	r1, #0
 800c210:	db5d      	blt.n	800c2ce <draw_all+0xa8e>
  y0 *= CELLWIDTH;
 800c212:	0149      	lsls	r1, r1, #5
      cell_buffer[y0 + x0] = c;
 800c214:	1856      	adds	r6, r2, r1
    if ((uint32_t)x0 < CELLWIDTH)
 800c216:	2a1f      	cmp	r2, #31
    if (x0 + y0 == y1 + x1)
 800c218:	eb05 1547 	add.w	r5, r5, r7, lsl #5
      cell_buffer[y0 + x0] = c;
 800c21c:	bf98      	it	ls
 800c21e:	f828 e016 	strhls.w	lr, [r8, r6, lsl #1]
    if (x0 + y0 == y1 + x1)
 800c222:	42b5      	cmp	r5, r6
 800c224:	d014      	beq.n	800c250 <draw_all+0xa10>
    if (e2 > dx)
 800c226:	42a3      	cmp	r3, r4
      err -= dy;
 800c228:	bfc6      	itte	gt
 800c22a:	1a1e      	subgt	r6, r3, r0
      x0 += sx;
 800c22c:	4452      	addgt	r2, sl
 800c22e:	461e      	movle	r6, r3
    if (e2 < dy)
 800c230:	4283      	cmp	r3, r0
 800c232:	da05      	bge.n	800c240 <draw_all+0xa00>
      y0 += CELLWIDTH;
 800c234:	3120      	adds	r1, #32
      if (y0 >= CELLHEIGHT * CELLWIDTH)
 800c236:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
      err -= dx;
 800c23a:	eba6 0604 	sub.w	r6, r6, r4
      if (y0 >= CELLHEIGHT * CELLWIDTH)
 800c23e:	da07      	bge.n	800c250 <draw_all+0xa10>
 800c240:	4633      	mov	r3, r6
      cell_buffer[y0 + x0] = c;
 800c242:	1856      	adds	r6, r2, r1
    if ((uint32_t)x0 < CELLWIDTH)
 800c244:	2a1f      	cmp	r2, #31
      cell_buffer[y0 + x0] = c;
 800c246:	bf98      	it	ls
 800c248:	f828 e016 	strhls.w	lr, [r8, r6, lsl #1]
    if (x0 + y0 == y1 + x1)
 800c24c:	42b5      	cmp	r5, r6
 800c24e:	d1ea      	bne.n	800c226 <draw_all+0x9e6>
    for (int i = i0; i < i1; i++)
 800c250:	9b04      	ldr	r3, [sp, #16]
 800c252:	f10c 0c04 	add.w	ip, ip, #4
 800c256:	459c      	cmp	ip, r3
 800c258:	d1ab      	bne.n	800c1b2 <draw_all+0x972>
 800c25a:	e9dd a010 	ldrd	sl, r0, [sp, #64]	@ 0x40
 800c25e:	e9dd 3212 	ldrd	r3, r2, [sp, #72]	@ 0x48
  for (t = TRACE_INDEX_COUNT - 1; t >= 0; t--)
 800c262:	3801      	subs	r0, #1
 800c264:	1c44      	adds	r4, r0, #1
 800c266:	f1a3 030c 	sub.w	r3, r3, #12
 800c26a:	f2a2 6244 	subw	r2, r2, #1604	@ 0x644
 800c26e:	f000 8098 	beq.w	800c3a2 <draw_all+0xb62>
    if (!needProcessTrace(t))
 800c272:	f893 1058 	ldrb.w	r1, [r3, #88]	@ 0x58
 800c276:	2900      	cmp	r1, #0
 800c278:	d0f3      	beq.n	800c262 <draw_all+0xa22>
    if (((1 << trace[t].type) & RECTANGULAR_GRID_MASK) && !enabled_store_trace && sweep_points > 30)
 800c27a:	f893 4059 	ldrb.w	r4, [r3, #89]	@ 0x59
 800c27e:	4970      	ldr	r1, [pc, #448]	@ (800c440 <draw_all+0xc00>)
 800c280:	4121      	asrs	r1, r4
    c = GET_PALTETTE_COLOR(LCD_TRACE_1_COLOR + t);
 800c282:	4c70      	ldr	r4, [pc, #448]	@ (800c444 <draw_all+0xc04>)
 800c284:	f834 e010 	ldrh.w	lr, [r4, r0, lsl #1]
    if (((1 << trace[t].type) & RECTANGULAR_GRID_MASK) && !enabled_store_trace && sweep_points > 30)
 800c288:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 800c28a:	07c9      	lsls	r1, r1, #31
 800c28c:	8b66      	ldrh	r6, [r4, #26]
 800c28e:	d505      	bpl.n	800c29c <draw_all+0xa5c>
 800c290:	f1ba 0f00 	cmp.w	sl, #0
 800c294:	d102      	bne.n	800c29c <draw_all+0xa5c>
 800c296:	2e1e      	cmp	r6, #30
 800c298:	f200 83fe 	bhi.w	800ca98 <draw_all+0x1258>
      i1 = sweep_points - 1;
 800c29c:	f106 39ff 	add.w	r9, r6, #4294967295
    int i0 = 0, i1 = 0;
 800c2a0:	f04f 0c00 	mov.w	ip, #0
    for (int i = i0; i < i1; i++)
 800c2a4:	45cc      	cmp	ip, r9
 800c2a6:	f6ff af78 	blt.w	800c19a <draw_all+0x95a>
 800c2aa:	e7da      	b.n	800c262 <draw_all+0xa22>
  int dy = (y1 - y0);
 800c2ac:	1a30      	subs	r0, r6, r0
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c2ae:	4613      	mov	r3, r2
 800c2b0:	42e0      	cmn	r0, r4
 800c2b2:	462a      	mov	r2, r5
 800c2b4:	461d      	mov	r5, r3
 800c2b6:	bf4c      	ite	mi
 800c2b8:	eb04 73d4 	addmi.w	r3, r4, r4, lsr #31
 800c2bc:	eb00 73d0 	addpl.w	r3, r0, r0, lsr #31
 800c2c0:	463e      	mov	r6, r7
 800c2c2:	105b      	asrs	r3, r3, #1
 800c2c4:	460f      	mov	r7, r1
 800c2c6:	425b      	negs	r3, r3
 800c2c8:	4631      	mov	r1, r6
  int dx = (x0 - x1), sx = 1;
 800c2ca:	f04f 0a01 	mov.w	sl, #1
      if (e2 > dx)
 800c2ce:	42a3      	cmp	r3, r4
    sx = -sx;
 800c2d0:	461e      	mov	r6, r3
        x0 += sx;
 800c2d2:	bfc4      	itt	gt
 800c2d4:	4452      	addgt	r2, sl
        err -= dy;
 800c2d6:	1a1b      	subgt	r3, r3, r0
      if (e2 < dy)
 800c2d8:	4286      	cmp	r6, r0
 800c2da:	daf8      	bge.n	800c2ce <draw_all+0xa8e>
        if (y0 == 0)
 800c2dc:	1c4e      	adds	r6, r1, #1
        err -= dx;
 800c2de:	eba3 0304 	sub.w	r3, r3, r4
        if (y0 == 0)
 800c2e2:	d03f      	beq.n	800c364 <draw_all+0xb24>
        y0++;
 800c2e4:	3101      	adds	r1, #1
 800c2e6:	e7f2      	b.n	800c2ce <draw_all+0xa8e>
  if (x0 < 0 && x1 < 0)
 800c2e8:	2a00      	cmp	r2, #0
 800c2ea:	dbb1      	blt.n	800c250 <draw_all+0xa10>
  if (y0 < 0 && y1 < 0)
 800c2ec:	2f00      	cmp	r7, #0
 800c2ee:	db3b      	blt.n	800c368 <draw_all+0xb28>
  if (y0 >= CELLHEIGHT && y1 >= CELLHEIGHT)
 800c2f0:	2f1f      	cmp	r7, #31
 800c2f2:	f340 80de 	ble.w	800c4b2 <draw_all+0xc72>
 800c2f6:	291f      	cmp	r1, #31
 800c2f8:	dcaa      	bgt.n	800c250 <draw_all+0xa10>
  if (y1 < y0)
 800c2fa:	42b0      	cmp	r0, r6
 800c2fc:	d826      	bhi.n	800c34c <draw_all+0xb0c>
  int dx = (x0 - x1), sx = 1;
 800c2fe:	eba3 040a 	sub.w	r4, r3, sl
  if (dx > 0)
 800c302:	2c00      	cmp	r4, #0
 800c304:	f340 80c7 	ble.w	800c496 <draw_all+0xc56>
    dx = -dx;
 800c308:	ebaa 0403 	sub.w	r4, sl, r3
  int dy = (y1 - y0);
 800c30c:	1a30      	subs	r0, r6, r0
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c30e:	4613      	mov	r3, r2
 800c310:	463e      	mov	r6, r7
 800c312:	42e0      	cmn	r0, r4
 800c314:	460f      	mov	r7, r1
 800c316:	462a      	mov	r2, r5
 800c318:	4631      	mov	r1, r6
 800c31a:	461d      	mov	r5, r3
 800c31c:	d42c      	bmi.n	800c378 <draw_all+0xb38>
 800c31e:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
 800c322:	105b      	asrs	r3, r3, #1
 800c324:	425b      	negs	r3, r3
    sx = -sx;
 800c326:	f04f 3aff 	mov.w	sl, #4294967295
 800c32a:	e772      	b.n	800c212 <draw_all+0x9d2>
  if (y0 < 0 && y1 < 0)
 800c32c:	2900      	cmp	r1, #0
 800c32e:	db8f      	blt.n	800c250 <draw_all+0xa10>
  if (x0 >= CELLWIDTH && x1 >= CELLWIDTH)
 800c330:	2d1f      	cmp	r5, #31
 800c332:	f340 80cc 	ble.w	800c4ce <draw_all+0xc8e>
 800c336:	2a1f      	cmp	r2, #31
 800c338:	dc8a      	bgt.n	800c250 <draw_all+0xa10>
  if (y1 < y0)
 800c33a:	42b0      	cmp	r0, r6
 800c33c:	f63f af5b 	bhi.w	800c1f6 <draw_all+0x9b6>
 800c340:	4638      	mov	r0, r7
 800c342:	4613      	mov	r3, r2
 800c344:	460f      	mov	r7, r1
 800c346:	462a      	mov	r2, r5
 800c348:	4601      	mov	r1, r0
 800c34a:	461d      	mov	r5, r3
    dx = -dx;
 800c34c:	1aac      	subs	r4, r5, r2
  int dy = (y1 - y0);
 800c34e:	1a78      	subs	r0, r7, r1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c350:	42e0      	cmn	r0, r4
    sx = -sx;
 800c352:	f04f 3aff 	mov.w	sl, #4294967295
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c356:	f57f af56 	bpl.w	800c206 <draw_all+0x9c6>
 800c35a:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
 800c35e:	105b      	asrs	r3, r3, #1
 800c360:	425b      	negs	r3, r3
 800c362:	e754      	b.n	800c20e <draw_all+0x9ce>
 800c364:	2100      	movs	r1, #0
 800c366:	e755      	b.n	800c214 <draw_all+0x9d4>
  if (y0 < 0 && y1 < 0)
 800c368:	2900      	cmp	r1, #0
 800c36a:	f6ff af71 	blt.w	800c250 <draw_all+0xa10>
  if (y1 < y0)
 800c36e:	42b0      	cmp	r0, r6
    dx = -dx;
 800c370:	eba3 040a 	sub.w	r4, r3, sl
  if (y1 < y0)
 800c374:	d99a      	bls.n	800c2ac <draw_all+0xa6c>
  int dy = (y1 - y0);
 800c376:	1b80      	subs	r0, r0, r6
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c378:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
 800c37c:	105b      	asrs	r3, r3, #1
 800c37e:	425b      	negs	r3, r3
    sx = -sx;
 800c380:	f04f 3aff 	mov.w	sl, #4294967295
 800c384:	e745      	b.n	800c212 <draw_all+0x9d2>
  if (y0 >= CELLHEIGHT && y1 >= CELLHEIGHT)
 800c386:	2f1f      	cmp	r7, #31
 800c388:	f340 80b0 	ble.w	800c4ec <draw_all+0xcac>
 800c38c:	291f      	cmp	r1, #31
 800c38e:	f73f af5f 	bgt.w	800c250 <draw_all+0xa10>
  if (y1 < y0)
 800c392:	42b0      	cmp	r0, r6
 800c394:	d9b3      	bls.n	800c2fe <draw_all+0xabe>
  int dx = (x0 - x1), sx = 1;
 800c396:	1b54      	subs	r4, r2, r5
  if (dx > 0)
 800c398:	2c00      	cmp	r4, #0
 800c39a:	dcd7      	bgt.n	800c34c <draw_all+0xb0c>
  int dx = (x0 - x1), sx = 1;
 800c39c:	f04f 0a01 	mov.w	sl, #1
 800c3a0:	e72d      	b.n	800c1fe <draw_all+0x9be>
  if (VNA_MODE(VNA_MODE_SHOW_GRID) && x0 > (GRID_X_TEXT - CELLWIDTH))
 800c3a2:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800c3a4:	8a9b      	ldrh	r3, [r3, #20]
 800c3a6:	071e      	lsls	r6, r3, #28
 800c3a8:	d503      	bpl.n	800c3b2 <draw_all+0xb72>
 800c3aa:	f5bb 7fc2 	cmp.w	fp, #388	@ 0x184
 800c3ae:	f200 8394 	bhi.w	800cada <draw_all+0x129a>
  for (int i = 0; i < MARKERS_MAX; i++)
 800c3b2:	f8df 90a4 	ldr.w	r9, [pc, #164]	@ 800c458 <draw_all+0xc18>
 800c3b6:	4e21      	ldr	r6, [pc, #132]	@ (800c43c <draw_all+0xbfc>)
 800c3b8:	46ca      	mov	sl, r9
 800c3ba:	e007      	b.n	800c3cc <draw_all+0xb8c>
 800c3bc:	4b22      	ldr	r3, [pc, #136]	@ (800c448 <draw_all+0xc08>)
 800c3be:	f10a 0a38 	add.w	sl, sl, #56	@ 0x38
 800c3c2:	459a      	cmp	sl, r3
 800c3c4:	f106 0608 	add.w	r6, r6, #8
 800c3c8:	f43f ada2 	beq.w	800bf10 <draw_all+0x6d0>
    if (!markers[i].enabled)
 800c3cc:	f896 3058 	ldrb.w	r3, [r6, #88]	@ 0x58
 800c3d0:	2b00      	cmp	r3, #0
 800c3d2:	d0f3      	beq.n	800c3bc <draw_all+0xb7c>
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800c3d4:	f8b6 505a 	ldrh.w	r5, [r6, #90]	@ 0x5a
 800c3d8:	4b1c      	ldr	r3, [pc, #112]	@ (800c44c <draw_all+0xc0c>)
        marker = MARKER_RBITMAP(i + 1);
 800c3da:	f8dd 8030 	ldr.w	r8, [sp, #48]	@ 0x30
 800c3de:	9604      	str	r6, [sp, #16]
        marker = MARKER_BITMAP(i + 1);
 800c3e0:	f1aa 091c 	sub.w	r9, sl, #28
 800c3e4:	eb03 0585 	add.w	r5, r3, r5, lsl #2
        marker = MARKER_RBITMAP(i + 1);
 800c3e8:	2406      	movs	r4, #6
 800c3ea:	464e      	mov	r6, r9
      if (!trace[t].enabled)
 800c3ec:	f898 3028 	ldrb.w	r3, [r8, #40]	@ 0x28
 800c3f0:	b193      	cbz	r3, 800c418 <draw_all+0xbd8>
      if (index[mk_idx].y < MARKER_HEIGHT * 2)
 800c3f2:	886a      	ldrh	r2, [r5, #2]
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800c3f4:	882f      	ldrh	r7, [r5, #0]
        y = index[mk_idx].y - y0 + 1;
 800c3f6:	9b08      	ldr	r3, [sp, #32]
      if (index[mk_idx].y < MARKER_HEIGHT * 2)
 800c3f8:	2a1b      	cmp	r2, #27
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800c3fa:	eba7 070b 	sub.w	r7, r7, fp
        y = index[mk_idx].y - y0 + 1;
 800c3fe:	eba2 0303 	sub.w	r3, r2, r3
      if (index[mk_idx].y < MARKER_HEIGHT * 2)
 800c402:	d813      	bhi.n	800c42c <draw_all+0xbec>
        plate = MARKER_RBITMAP(0);
 800c404:	4a12      	ldr	r2, [pc, #72]	@ (800c450 <draw_all+0xc10>)
        y = index[mk_idx].y - y0 + 1;
 800c406:	3301      	adds	r3, #1
        marker = MARKER_RBITMAP(i + 1);
 800c408:	46d1      	mov	r9, sl
      if ((uint32_t)(x + MARKER_WIDTH) < (CELLWIDTH + MARKER_WIDTH) &&
 800c40a:	1db9      	adds	r1, r7, #6
 800c40c:	292a      	cmp	r1, #42	@ 0x2a
          (uint32_t)(y + MARKER_HEIGHT) < (CELLHEIGHT + MARKER_HEIGHT))
 800c40e:	f103 000e 	add.w	r0, r3, #14
      if ((uint32_t)(x + MARKER_WIDTH) < (CELLWIDTH + MARKER_WIDTH) &&
 800c412:	d801      	bhi.n	800c418 <draw_all+0xbd8>
 800c414:	282d      	cmp	r0, #45	@ 0x2d
 800c416:	d921      	bls.n	800c45c <draw_all+0xc1c>
    for (t = 0; t < TRACES_MAX; t++)
 800c418:	3401      	adds	r4, #1
 800c41a:	b2a4      	uxth	r4, r4
 800c41c:	2c0a      	cmp	r4, #10
 800c41e:	f108 080c 	add.w	r8, r8, #12
 800c422:	f205 6544 	addw	r5, r5, #1604	@ 0x644
 800c426:	d1e1      	bne.n	800c3ec <draw_all+0xbac>
 800c428:	9e04      	ldr	r6, [sp, #16]
 800c42a:	e7c7      	b.n	800c3bc <draw_all+0xb7c>
        plate = MARKER_BITMAP(0);
 800c42c:	4a09      	ldr	r2, [pc, #36]	@ (800c454 <draw_all+0xc14>)
        y = index[mk_idx].y - y0 - Y_MARKER_OFFSET;
 800c42e:	3b0e      	subs	r3, #14
        marker = MARKER_BITMAP(i + 1);
 800c430:	46b1      	mov	r9, r6
 800c432:	e7ea      	b.n	800c40a <draw_all+0xbca>
 800c434:	20006a35 	.word	0x20006a35
 800c438:	2000834c 	.word	0x2000834c
 800c43c:	20000aa8 	.word	0x20000aa8
 800c440:	3fffffe7 	.word	0x3fffffe7
 800c444:	20000342 	.word	0x20000342
 800c448:	08014484 	.word	0x08014484
 800c44c:	20006a3c 	.word	0x20006a3c
 800c450:	0801428c 	.word	0x0801428c
 800c454:	08014270 	.word	0x08014270
 800c458:	080142c4 	.word	0x080142c4
        lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c45c:	4620      	mov	r0, r4
 800c45e:	e9cd 3210 	strd	r3, r2, [sp, #64]	@ 0x40
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800c462:	3f05      	subs	r7, #5
        lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c464:	f003 fe34 	bl	80100d0 <lcd_set_foreground>
        cell_blit_bitmap(x, y, MARKER_WIDTH, MARKER_HEIGHT, plate);
 800c468:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 800c46a:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 800c46c:	9200      	str	r2, [sp, #0]
 800c46e:	b23f      	sxth	r7, r7
 800c470:	b219      	sxth	r1, r3
 800c472:	220b      	movs	r2, #11
 800c474:	230e      	movs	r3, #14
 800c476:	4638      	mov	r0, r7
 800c478:	9110      	str	r1, [sp, #64]	@ 0x40
 800c47a:	f7fd f87d 	bl	8009578 <cell_blit_bitmap>
        lcd_set_foreground(LCD_TXT_SHADOW_COLOR);
 800c47e:	201a      	movs	r0, #26
 800c480:	f003 fe26 	bl	80100d0 <lcd_set_foreground>
        cell_blit_bitmap(x, y, MARKER_WIDTH, MARKER_HEIGHT, marker);
 800c484:	9910      	ldr	r1, [sp, #64]	@ 0x40
 800c486:	f8cd 9000 	str.w	r9, [sp]
 800c48a:	230e      	movs	r3, #14
 800c48c:	4638      	mov	r0, r7
 800c48e:	220b      	movs	r2, #11
 800c490:	f7fd f872 	bl	8009578 <cell_blit_bitmap>
 800c494:	e7c0      	b.n	800c418 <draw_all+0xbd8>
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c496:	4613      	mov	r3, r2
 800c498:	462a      	mov	r2, r5
 800c49a:	461d      	mov	r5, r3
 800c49c:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
  int dy = (y1 - y0);
 800c4a0:	1a30      	subs	r0, r6, r0
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c4a2:	105b      	asrs	r3, r3, #1
 800c4a4:	463e      	mov	r6, r7
 800c4a6:	425b      	negs	r3, r3
 800c4a8:	460f      	mov	r7, r1
  int dx = (x0 - x1), sx = 1;
 800c4aa:	f04f 0a01 	mov.w	sl, #1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c4ae:	4631      	mov	r1, r6
 800c4b0:	e6af      	b.n	800c212 <draw_all+0x9d2>
  if (y1 < y0)
 800c4b2:	42b0      	cmp	r0, r6
 800c4b4:	f63f af4a 	bhi.w	800c34c <draw_all+0xb0c>
  int dx = (x0 - x1), sx = 1;
 800c4b8:	eba3 040a 	sub.w	r4, r3, sl
 800c4bc:	4638      	mov	r0, r7
 800c4be:	4613      	mov	r3, r2
 800c4c0:	460f      	mov	r7, r1
 800c4c2:	462a      	mov	r2, r5
 800c4c4:	4601      	mov	r1, r0
 800c4c6:	461d      	mov	r5, r3
 800c4c8:	f04f 0a01 	mov.w	sl, #1
 800c4cc:	e697      	b.n	800c1fe <draw_all+0x9be>
  if (y1 < y0)
 800c4ce:	42b0      	cmp	r0, r6
 800c4d0:	d90f      	bls.n	800c4f2 <draw_all+0xcb2>
  int dx = (x0 - x1), sx = 1;
 800c4d2:	ebaa 0403 	sub.w	r4, sl, r3
  if (dx > 0)
 800c4d6:	2c00      	cmp	r4, #0
 800c4d8:	f73f af38 	bgt.w	800c34c <draw_all+0xb0c>
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c4dc:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
 800c4e0:	105b      	asrs	r3, r3, #1
  int dy = (y1 - y0);
 800c4e2:	1b80      	subs	r0, r0, r6
  int dx = (x0 - x1), sx = 1;
 800c4e4:	f04f 0a01 	mov.w	sl, #1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800c4e8:	425b      	negs	r3, r3
 800c4ea:	e690      	b.n	800c20e <draw_all+0x9ce>
  if (y1 < y0)
 800c4ec:	42b0      	cmp	r0, r6
 800c4ee:	f63f af52 	bhi.w	800c396 <draw_all+0xb56>
 800c4f2:	4608      	mov	r0, r1
 800c4f4:	4613      	mov	r3, r2
 800c4f6:	4639      	mov	r1, r7
 800c4f8:	462a      	mov	r2, r5
 800c4fa:	4607      	mov	r7, r0
 800c4fc:	461d      	mov	r5, r3
 800c4fe:	e74a      	b.n	800c396 <draw_all+0xb56>
    plot_printf(msg, (int)sizeof(msg), "BW2=-- kHz");
 800c500:	4a72      	ldr	r2, [pc, #456]	@ (800c6cc <draw_all+0xe8c>)
 800c502:	2120      	movs	r1, #32
 800c504:	4620      	mov	r0, r4
 800c506:	f7f6 fbdd 	bl	8002cc4 <plot_printf>
 800c50a:	e51d      	b.n	800bf48 <draw_all+0x708>
  else if (trace_type & (1 << TRC_POLAR))
 800c50c:	f01c 0f10 	tst.w	ip, #16
 800c510:	f43f ae2b 	beq.w	800c16a <draw_all+0x92a>
  for (y = 0; y < h; y++)
 800c514:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800c516:	f8cd 8040 	str.w	r8, [sp, #64]	@ 0x40
 800c51a:	46c4      	mov	ip, r8
 800c51c:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 800c520:	f8dd 8050 	ldr.w	r8, [sp, #80]	@ 0x50
 800c524:	f103 0753 	add.w	r7, r3, #83	@ 0x53
 800c528:	f1ab 05e8 	sub.w	r5, fp, #232	@ 0xe8
  if (d > P_RADIUS * P_RADIUS + P_RADIUS)
 800c52c:	f645 26d8 	movw	r6, #23256	@ 0x5ad8
  if (d > P_RADIUS * P_RADIUS - P_RADIUS)
 800c530:	f645 1ea8 	movw	lr, #22952	@ 0x59a8
  uint32_t d = x * x + y * y;
 800c534:	fb07 f007 	mul.w	r0, r7, r7
 800c538:	462b      	mov	r3, r5
    for (x = 0; x < w; x++)
 800c53a:	2200      	movs	r2, #0
 800c53c:	9504      	str	r5, [sp, #16]
  uint32_t d = x * x + y * y;
 800c53e:	fb03 0103 	mla	r1, r3, r3, r0
  if (d > P_RADIUS * P_RADIUS + P_RADIUS)
 800c542:	42b1      	cmp	r1, r6
 800c544:	dc26      	bgt.n	800c594 <draw_all+0xd54>
  if (d > P_RADIUS * P_RADIUS - P_RADIUS)
 800c546:	4571      	cmp	r1, lr
 800c548:	dc22      	bgt.n	800c590 <draw_all+0xd50>
  if (x == 0 || y == 0)
 800c54a:	b30b      	cbz	r3, 800c590 <draw_all+0xd50>
 800c54c:	b307      	cbz	r7, 800c590 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS / 25 - P_RADIUS / 5)
 800c54e:	f240 357d 	movw	r5, #893	@ 0x37d
 800c552:	42a9      	cmp	r1, r5
 800c554:	dd1e      	ble.n	800c594 <draw_all+0xd54>
  if (d < P_RADIUS * P_RADIUS / 25 + P_RADIUS / 5)
 800c556:	f240 35b9 	movw	r5, #953	@ 0x3b9
 800c55a:	42a9      	cmp	r1, r5
 800c55c:	dd18      	ble.n	800c590 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS * 4 / 25 - P_RADIUS * 2 / 5)
 800c55e:	f640 6533 	movw	r5, #3635	@ 0xe33
 800c562:	42a9      	cmp	r1, r5
 800c564:	dd16      	ble.n	800c594 <draw_all+0xd54>
  if (d < P_RADIUS * P_RADIUS * 4 / 25 + P_RADIUS * 2 / 5)
 800c566:	f640 65ab 	movw	r5, #3755	@ 0xeab
 800c56a:	42a9      	cmp	r1, r5
 800c56c:	dd10      	ble.n	800c590 <draw_all+0xd50>
  if (x == y || x == -y)
 800c56e:	42bb      	cmp	r3, r7
 800c570:	d00e      	beq.n	800c590 <draw_all+0xd50>
 800c572:	42fb      	cmn	r3, r7
 800c574:	d00c      	beq.n	800c590 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS * 9 / 25 - P_RADIUS * 3 / 5)
 800c576:	f242 0521 	movw	r5, #8225	@ 0x2021
 800c57a:	42a9      	cmp	r1, r5
 800c57c:	dd0a      	ble.n	800c594 <draw_all+0xd54>
  if (d < P_RADIUS * P_RADIUS * 9 / 25 + P_RADIUS * 3 / 5)
 800c57e:	f242 05d7 	movw	r5, #8407	@ 0x20d7
 800c582:	42a9      	cmp	r1, r5
 800c584:	dd04      	ble.n	800c590 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS * 16 / 25 - P_RADIUS * 4 / 5)
 800c586:	f5a1 5165 	sub.w	r1, r1, #14656	@ 0x3940
 800c58a:	3909      	subs	r1, #9
 800c58c:	29f1      	cmp	r1, #241	@ 0xf1
 800c58e:	d801      	bhi.n	800c594 <draw_all+0xd54>
        cell_buffer[y * CELLWIDTH + x] = color;
 800c590:	f82c 4012 	strh.w	r4, [ip, r2, lsl #1]
    for (x = 0; x < w; x++)
 800c594:	3201      	adds	r2, #1
 800c596:	4590      	cmp	r8, r2
 800c598:	f103 0301 	add.w	r3, r3, #1
 800c59c:	dccf      	bgt.n	800c53e <draw_all+0xcfe>
  for (y = 0; y < h; y++)
 800c59e:	f109 0901 	add.w	r9, r9, #1
 800c5a2:	45ca      	cmp	sl, r9
 800c5a4:	9d04      	ldr	r5, [sp, #16]
 800c5a6:	f107 0701 	add.w	r7, r7, #1
 800c5aa:	f10c 0c40 	add.w	ip, ip, #64	@ 0x40
 800c5ae:	dcc1      	bgt.n	800c534 <draw_all+0xcf4>
 800c5b0:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 800c5b4:	e5d9      	b.n	800c16a <draw_all+0x92a>
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c5b6:	4620      	mov	r0, r4
 800c5b8:	f003 fd8a 	bl	80100d0 <lcd_set_foreground>
      cell_blit_bitmap(x, y, REFERENCE_WIDTH, REFERENCE_HEIGHT, (const uint8_t *)reference_bitmap);
 800c5bc:	4b44      	ldr	r3, [pc, #272]	@ (800c6d0 <draw_all+0xe90>)
 800c5be:	9300      	str	r3, [sp, #0]
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800c5c0:	1eb9      	subs	r1, r7, #2
      cell_blit_bitmap(x, y, REFERENCE_WIDTH, REFERENCE_HEIGHT, (const uint8_t *)reference_bitmap);
 800c5c2:	b209      	sxth	r1, r1
 800c5c4:	4648      	mov	r0, r9
 800c5c6:	2305      	movs	r3, #5
 800c5c8:	2206      	movs	r2, #6
 800c5ca:	f7fc ffd5 	bl	8009578 <cell_blit_bitmap>
 800c5ce:	e54b      	b.n	800c068 <draw_all+0x828>
  if (active_marker == MARKER_INVALID)
 800c5d0:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 800c5d2:	f991 301d 	ldrsb.w	r3, [r1, #29]
 800c5d6:	1c5c      	adds	r4, r3, #1
 800c5d8:	f000 8167 	beq.w	800c8aa <draw_all+0x106a>
  int active_marker_idx = markers[active_marker].index;
 800c5dc:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800c5e0:	f8b3 305a 	ldrh.w	r3, [r3, #90]	@ 0x5a
 800c5e4:	9304      	str	r3, [sp, #16]
  if (previous_marker != MARKER_INVALID && current_trace != TRACE_INVALID)
 800c5e6:	f991 301e 	ldrsb.w	r3, [r1, #30]
 800c5ea:	3301      	adds	r3, #1
 800c5ec:	d07c      	beq.n	800c6e8 <draw_all+0xea8>
 800c5ee:	f991 201c 	ldrsb.w	r2, [r1, #28]
 800c5f2:	1c50      	adds	r0, r2, #1
  int j = 0;
 800c5f4:	f04f 0800 	mov.w	r8, #0
  if (previous_marker != MARKER_INVALID && current_trace != TRACE_INVALID)
 800c5f8:	f000 8413 	beq.w	800ce22 <draw_all+0x15e2>
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c5fc:	1d93      	adds	r3, r2, #6
 800c5fe:	b29b      	uxth	r3, r3
    t = current_trace;
 800c600:	f8cd b048 	str.w	fp, [sp, #72]	@ 0x48
 800c604:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ 800c6e4 <draw_all+0xea4>
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c608:	9313      	str	r3, [sp, #76]	@ 0x4c
    t = current_trace;
 800c60a:	4644      	mov	r4, r8
 800c60c:	9219      	str	r2, [sp, #100]	@ 0x64
 800c60e:	468b      	mov	fp, r1
 800c610:	e020      	b.n	800c654 <draw_all+0xe14>
 800c612:	931b      	str	r3, [sp, #108]	@ 0x6c
        freq_t freq1 = get_marker_frequency(active_marker);
 800c614:	f7fa fdf8 	bl	8007208 <get_marker_frequency>
        freq_t delta = freq > freq1 ? freq - freq1 : freq1 - freq;
 800c618:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
        cell_printf(xpos, ypos, S_DELTA MARKER_FREQ, delta);
 800c61a:	4a2e      	ldr	r2, [pc, #184]	@ (800c6d4 <draw_all+0xe94>)
        freq_t delta = freq > freq1 ? freq - freq1 : freq1 - freq;
 800c61c:	4283      	cmp	r3, r0
 800c61e:	bf8c      	ite	hi
 800c620:	1a1b      	subhi	r3, r3, r0
 800c622:	1ac3      	subls	r3, r0, r3
        cell_printf(xpos, ypos, S_DELTA MARKER_FREQ, delta);
 800c624:	4651      	mov	r1, sl
 800c626:	f9bd 0040 	ldrsh.w	r0, [sp, #64]	@ 0x40
 800c62a:	f7fd fb1f 	bl	8009c6c <cell_printf>
        delta_index = active_marker_idx;
 800c62e:	9f04      	ldr	r7, [sp, #16]
      lcd_set_foreground(LCD_FG_COLOR);
 800c630:	2001      	movs	r0, #1
 800c632:	f003 fd4d 	bl	80100d0 <lcd_set_foreground>
      trace_print_value_string(xpos, ypos, t, mk_index, delta_index);
 800c636:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 800c638:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 800c63a:	9700      	str	r7, [sp, #0]
 800c63c:	4631      	mov	r1, r6
 800c63e:	f105 008e 	add.w	r0, r5, #142	@ 0x8e
      j++;
 800c642:	f108 0801 	add.w	r8, r8, #1
      trace_print_value_string(xpos, ypos, t, mk_index, delta_index);
 800c646:	f7fd fe69 	bl	800a31c <trace_print_value_string>
    for (mk = 0; mk < MARKERS_MAX; mk++)
 800c64a:	2c08      	cmp	r4, #8
 800c64c:	f109 0908 	add.w	r9, r9, #8
 800c650:	f000 82d3 	beq.w	800cbfa <draw_all+0x13ba>
      if (!markers[mk].enabled)
 800c654:	f899 3058 	ldrb.w	r3, [r9, #88]	@ 0x58
 800c658:	4627      	mov	r7, r4
 800c65a:	3401      	adds	r4, #1
 800c65c:	2b00      	cmp	r3, #0
 800c65e:	d0f4      	beq.n	800c64a <draw_all+0xe0a>
      ypos = marker_pos[j].y - y0;
 800c660:	4a1d      	ldr	r2, [pc, #116]	@ (800c6d8 <draw_all+0xe98>)
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c662:	9813      	ldr	r0, [sp, #76]	@ 0x4c
      xpos = marker_pos[j].x - x0;
 800c664:	f832 5028 	ldrh.w	r5, [r2, r8, lsl #2]
      ypos = marker_pos[j].y - y0;
 800c668:	eb02 0388 	add.w	r3, r2, r8, lsl #2
 800c66c:	885e      	ldrh	r6, [r3, #2]
 800c66e:	9b08      	ldr	r3, [sp, #32]
 800c670:	1af6      	subs	r6, r6, r3
      xpos = marker_pos[j].x - x0;
 800c672:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 800c674:	1aed      	subs	r5, r5, r3
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c676:	f003 fd2b 	bl	80100d0 <lcd_set_foreground>
      if (mk == active_marker && lever_mode == LM_MARKER)
 800c67a:	f99b 301d 	ldrsb.w	r3, [fp, #29]
 800c67e:	42bb      	cmp	r3, r7
        cell_printf(xpos, ypos, S_SARROW);
 800c680:	fa0f fa86 	sxth.w	sl, r6
      if (mk == active_marker && lever_mode == LM_MARKER)
 800c684:	f000 829f 	beq.w	800cbc6 <draw_all+0x1386>
      xpos += FONT_WIDTH;
 800c688:	1de8      	adds	r0, r5, #7
      cell_printf(xpos, ypos, "M%d", mk + 1);
 800c68a:	4a14      	ldr	r2, [pc, #80]	@ (800c6dc <draw_all+0xe9c>)
 800c68c:	4623      	mov	r3, r4
 800c68e:	4651      	mov	r1, sl
 800c690:	b200      	sxth	r0, r0
 800c692:	f7fd faeb 	bl	8009c6c <cell_printf>
      uint32_t mk_index = markers[mk].index;
 800c696:	f8b9 305a 	ldrh.w	r3, [r9, #90]	@ 0x5a
 800c69a:	9311      	str	r3, [sp, #68]	@ 0x44
      freq_t freq = get_marker_frequency(mk);
 800c69c:	4638      	mov	r0, r7
      xpos += 3 * FONT_WIDTH - 2;
 800c69e:	f105 031a 	add.w	r3, r5, #26
 800c6a2:	9310      	str	r3, [sp, #64]	@ 0x40
      freq_t freq = get_marker_frequency(mk);
 800c6a4:	f7fa fdb0 	bl	8007208 <get_marker_frequency>
      if ((props_mode & TD_MARKER_DELTA) && mk != active_marker)
 800c6a8:	f8bb 2018 	ldrh.w	r2, [fp, #24]
 800c6ac:	05d2      	lsls	r2, r2, #23
      freq_t freq = get_marker_frequency(mk);
 800c6ae:	4603      	mov	r3, r0
      if ((props_mode & TD_MARKER_DELTA) && mk != active_marker)
 800c6b0:	d503      	bpl.n	800c6ba <draw_all+0xe7a>
 800c6b2:	f99b 001d 	ldrsb.w	r0, [fp, #29]
 800c6b6:	42b8      	cmp	r0, r7
 800c6b8:	d1ab      	bne.n	800c612 <draw_all+0xdd2>
        cell_printf(xpos, ypos, MARKER_FREQ, freq);
 800c6ba:	f9bd 0040 	ldrsh.w	r0, [sp, #64]	@ 0x40
 800c6be:	4a08      	ldr	r2, [pc, #32]	@ (800c6e0 <draw_all+0xea0>)
 800c6c0:	4651      	mov	r1, sl
 800c6c2:	f7fd fad3 	bl	8009c6c <cell_printf>
      int32_t delta_index = -1;
 800c6c6:	f04f 37ff 	mov.w	r7, #4294967295
 800c6ca:	e7b1      	b.n	800c630 <draw_all+0xdf0>
 800c6cc:	08011e60 	.word	0x08011e60
 800c6d0:	08014468 	.word	0x08014468
 800c6d4:	08011d6c 	.word	0x08011d6c
 800c6d8:	080141e0 	.word	0x080141e0
 800c6dc:	08011d68 	.word	0x08011d68
 800c6e0:	08011d74 	.word	0x08011d74
 800c6e4:	20000aa8 	.word	0x20000aa8
 800c6e8:	f04f 0800 	mov.w	r8, #0
 800c6ec:	4da2      	ldr	r5, [pc, #648]	@ (800c978 <draw_all+0x1138>)
 800c6ee:	4644      	mov	r4, r8
      if (!trace[t].enabled)
 800c6f0:	f895 3028 	ldrb.w	r3, [r5, #40]	@ 0x28
 800c6f4:	2b00      	cmp	r3, #0
 800c6f6:	d058      	beq.n	800c7aa <draw_all+0xf6a>
      ypos = marker_pos[j].y - y0;
 800c6f8:	4aa0      	ldr	r2, [pc, #640]	@ (800c97c <draw_all+0x113c>)
 800c6fa:	eb02 0388 	add.w	r3, r2, r8, lsl #2
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c6fe:	1da0      	adds	r0, r4, #6
      ypos = marker_pos[j].y - y0;
 800c700:	885f      	ldrh	r7, [r3, #2]
 800c702:	9b08      	ldr	r3, [sp, #32]
      xpos = marker_pos[j].x - x0;
 800c704:	f832 6028 	ldrh.w	r6, [r2, r8, lsl #2]
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c708:	b280      	uxth	r0, r0
      ypos = marker_pos[j].y - y0;
 800c70a:	1aff      	subs	r7, r7, r3
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800c70c:	f003 fce0 	bl	80100d0 <lcd_set_foreground>
      if (t == current_trace)
 800c710:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800c712:	f993 301c 	ldrsb.w	r3, [r3, #28]
 800c716:	42a3      	cmp	r3, r4
      xpos = marker_pos[j].x - x0;
 800c718:	eba6 060b 	sub.w	r6, r6, fp
        cell_printf(xpos, ypos, S_SARROW);
 800c71c:	fa0f f987 	sxth.w	r9, r7
      if (t == current_trace)
 800c720:	f000 8382 	beq.w	800ce28 <draw_all+0x15e8>
      cell_printf(xpos, ypos, get_trace_chname(t));
 800c724:	4620      	mov	r0, r4
 800c726:	f7fa ffd3 	bl	80076d0 <get_trace_chname>
 800c72a:	4602      	mov	r2, r0
      xpos += FONT_WIDTH;
 800c72c:	1df0      	adds	r0, r6, #7
      cell_printf(xpos, ypos, get_trace_chname(t));
 800c72e:	4649      	mov	r1, r9
 800c730:	b200      	sxth	r0, r0
 800c732:	f7fd fa9b 	bl	8009c6c <cell_printf>
  int type = trace[t].type;
 800c736:	f895 0029 	ldrb.w	r0, [r5, #41]	@ 0x29
  const char *v = trace_info_list[trace[t].type].symbol;
 800c73a:	4a91      	ldr	r2, [pc, #580]	@ (800c980 <draw_all+0x1140>)
  float scale = get_trace_scale(t);
 800c73c:	f8d5 a02c 	ldr.w	sl, [r5, #44]	@ 0x2c
  int smith = trace[t].smith_format;
 800c740:	f895 102b 	ldrb.w	r1, [r5, #43]	@ 0x2b
  const char *v = trace_info_list[trace[t].type].symbol;
 800c744:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
 800c748:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    format = (scale != 1.0f) ? "%s %0.1fFS" : "%s ";
 800c74c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
  const char *v = trace_info_list[trace[t].type].symbol;
 800c750:	68da      	ldr	r2, [r3, #12]
  switch (type)
 800c752:	1ec3      	subs	r3, r0, #3
 800c754:	2b01      	cmp	r3, #1
      xpos += 4 * FONT_WIDTH - 2;
 800c756:	f106 0621 	add.w	r6, r6, #33	@ 0x21
  switch (type)
 800c75a:	f240 82b7 	bls.w	800cccc <draw_all+0x148c>
    format = "%s %F%s/";
 800c75e:	4b89      	ldr	r3, [pc, #548]	@ (800c984 <draw_all+0x1144>)
 800c760:	9310      	str	r3, [sp, #64]	@ 0x40
  return cell_printf(xpos, ypos, format, get_trace_typename(type, smith), scale, v);
 800c762:	f7fe fd69 	bl	800b238 <get_trace_typename>
 800c766:	4603      	mov	r3, r0
 800c768:	4650      	mov	r0, sl
 800c76a:	9202      	str	r2, [sp, #8]
 800c76c:	9311      	str	r3, [sp, #68]	@ 0x44
 800c76e:	f7f3 ff17 	bl	80005a0 <__aeabi_f2d>
 800c772:	fa0f fa86 	sxth.w	sl, r6
 800c776:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 800c77a:	e9cd 0100 	strd	r0, r1, [sp]
 800c77e:	4649      	mov	r1, r9
 800c780:	4650      	mov	r0, sl
 800c782:	f7fd fa73 	bl	8009c6c <cell_printf>
      xpos += n * FONT_WIDTH - 5;
 800c786:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 800c78a:	1c83      	adds	r3, r0, #2
      lcd_set_foreground(LCD_FG_COLOR);
 800c78c:	2001      	movs	r0, #1
      xpos += n * FONT_WIDTH - 5;
 800c78e:	441e      	add	r6, r3
      lcd_set_foreground(LCD_FG_COLOR);
 800c790:	f003 fc9e 	bl	80100d0 <lcd_set_foreground>
      trace_print_value_string(xpos, ypos, t, active_marker_idx, -1);
 800c794:	f04f 33ff 	mov.w	r3, #4294967295
 800c798:	9300      	str	r3, [sp, #0]
 800c79a:	4639      	mov	r1, r7
 800c79c:	9b04      	ldr	r3, [sp, #16]
 800c79e:	4630      	mov	r0, r6
 800c7a0:	4622      	mov	r2, r4
      j++;
 800c7a2:	f108 0801 	add.w	r8, r8, #1
      trace_print_value_string(xpos, ypos, t, active_marker_idx, -1);
 800c7a6:	f7fd fdb9 	bl	800a31c <trace_print_value_string>
    for (t = 0; t < TRACES_MAX; t++)
 800c7aa:	3401      	adds	r4, #1
 800c7ac:	2c04      	cmp	r4, #4
 800c7ae:	f105 050c 	add.w	r5, r5, #12
 800c7b2:	d19d      	bne.n	800c6f0 <draw_all+0xeb0>
    ypos = 1 + ((j + 1) / 2) * FONT_STR_HEIGHT - y0;
 800c7b4:	f108 0301 	add.w	r3, r8, #1
 800c7b8:	105b      	asrs	r3, r3, #1
 800c7ba:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800c7be:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800c7c2:	9a08      	ldr	r2, [sp, #32]
 800c7c4:	3301      	adds	r3, #1
 800c7c6:	1a9d      	subs	r5, r3, r2
    if (lever_mode == LM_MARKER)
 800c7c8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800c7ca:	7f1b      	ldrb	r3, [r3, #28]
      cell_printf(xpos, ypos, S_SARROW);
 800c7cc:	b22e      	sxth	r6, r5
    if (lever_mode == LM_MARKER)
 800c7ce:	2b00      	cmp	r3, #0
 800c7d0:	f000 836b 	beq.w	800ceaa <draw_all+0x166a>
    cell_printf(xpos, ypos, "M%d:", active_marker + 1);
 800c7d4:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800c7d6:	fa1f f48b 	uxth.w	r4, fp
 800c7da:	f992 301d 	ldrsb.w	r3, [r2, #29]
 800c7de:	4a6a      	ldr	r2, [pc, #424]	@ (800c988 <draw_all+0x1148>)
 800c7e0:	f5c4 7082 	rsb	r0, r4, #260	@ 0x104
 800c7e4:	3301      	adds	r3, #1
 800c7e6:	b200      	sxth	r0, r0
 800c7e8:	4631      	mov	r1, r6
 800c7ea:	f7fd fa3f 	bl	8009c6c <cell_printf>
    if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800c7ee:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800c7f0:	8b13      	ldrh	r3, [r2, #24]
      cell_printf(xpos, ypos, "%q" S_Hz, get_marker_frequency(active_marker));
 800c7f2:	f5c4 748e 	rsb	r4, r4, #284	@ 0x11c
 800c7f6:	3401      	adds	r4, #1
    if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800c7f8:	07db      	lsls	r3, r3, #31
      cell_printf(xpos, ypos, "%q" S_Hz, get_marker_frequency(active_marker));
 800c7fa:	b227      	sxth	r7, r4
    if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800c7fc:	f100 82f6 	bmi.w	800cdec <draw_all+0x15ac>
      cell_printf(xpos, ypos, "%q" S_Hz, get_marker_frequency(active_marker));
 800c800:	f992 001d 	ldrsb.w	r0, [r2, #29]
 800c804:	f7fa fd00 	bl	8007208 <get_marker_frequency>
 800c808:	4a60      	ldr	r2, [pc, #384]	@ (800c98c <draw_all+0x114c>)
 800c80a:	4603      	mov	r3, r0
 800c80c:	4631      	mov	r1, r6
 800c80e:	4638      	mov	r0, r7
 800c810:	f7fd fa2c 	bl	8009c6c <cell_printf>
  float electrical_delay = get_electrical_delay();
 800c814:	f7fb ff44 	bl	80086a0 <get_electrical_delay>
  if (electrical_delay != 0.0f)
 800c818:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800c81c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float electrical_delay = get_electrical_delay();
 800c820:	eeb0 8a40 	vmov.f32	s16, s0
  if (electrical_delay != 0.0f)
 800c824:	d02a      	beq.n	800c87c <draw_all+0x103c>
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800c826:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800c828:	ed9f 7a59 	vldr	s14, [pc, #356]	@ 800c990 <draw_all+0x1150>
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800c82c:	7f1b      	ldrb	r3, [r3, #28]
 800c82e:	2b04      	cmp	r3, #4
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800c830:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800c832:	f893 3099 	ldrb.w	r3, [r3, #153]	@ 0x99
 800c836:	ee07 3a90 	vmov	s15, r3
 800c83a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c83e:	f1cb 0318 	rsb	r3, fp, #24
 800c842:	ee67 7a87 	vmul.f32	s15, s15, s14
 800c846:	b21e      	sxth	r6, r3
 800c848:	ee67 7a80 	vmul.f32	s15, s15, s0
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800c84c:	bf18      	it	ne
 800c84e:	2720      	movne	r7, #32
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800c850:	ee17 0a90 	vmov	r0, s15
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800c854:	bf08      	it	eq
 800c856:	2718      	moveq	r7, #24
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800c858:	f7f3 fea2 	bl	80005a0 <__aeabi_f2d>
 800c85c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800c860:	ee18 0a10 	vmov	r0, s16
 800c864:	f7f3 fe9c 	bl	80005a0 <__aeabi_f2d>
 800c868:	b22c      	sxth	r4, r5
 800c86a:	e9cd 0100 	strd	r0, r1, [sp]
 800c86e:	4a49      	ldr	r2, [pc, #292]	@ (800c994 <draw_all+0x1154>)
 800c870:	463b      	mov	r3, r7
 800c872:	4621      	mov	r1, r4
 800c874:	4630      	mov	r0, r6
 800c876:	f7fd f9f9 	bl	8009c6c <cell_printf>
    ypos += FONT_STR_HEIGHT;
 800c87a:	350b      	adds	r5, #11
  if (s21_offset != 0.0f)
 800c87c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800c87e:	edd3 7a2a 	vldr	s15, [r3, #168]	@ 0xa8
 800c882:	eef5 7a40 	vcmp.f32	s15, #0.0
 800c886:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c88a:	d00e      	beq.n	800c8aa <draw_all+0x106a>
    cell_printf(xpos, ypos, "S21 offset: %.3F" S_dB, s21_offset);
 800c88c:	ee17 0a90 	vmov	r0, s15
 800c890:	f7f3 fe86 	bl	80005a0 <__aeabi_f2d>
 800c894:	b22c      	sxth	r4, r5
 800c896:	f1cb 0518 	rsb	r5, fp, #24
 800c89a:	b22d      	sxth	r5, r5
 800c89c:	e9cd 0100 	strd	r0, r1, [sp]
 800c8a0:	4a3d      	ldr	r2, [pc, #244]	@ (800c998 <draw_all+0x1158>)
 800c8a2:	4621      	mov	r1, r4
 800c8a4:	4628      	mov	r0, r5
 800c8a6:	f7fd f9e1 	bl	8009c6c <cell_printf>
  if (y0 == 0)
 800c8aa:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 800c8ac:	2b00      	cmp	r3, #0
 800c8ae:	f47f ab35 	bne.w	800bf1c <draw_all+0x6dc>
  if (mla_resonance_locked && mla_res_freq != 0)
 800c8b2:	4e3a      	ldr	r6, [pc, #232]	@ (800c99c <draw_all+0x115c>)
 800c8b4:	7833      	ldrb	r3, [r6, #0]
 800c8b6:	b123      	cbz	r3, 800c8c2 <draw_all+0x1082>
 800c8b8:	4b39      	ldr	r3, [pc, #228]	@ (800c9a0 <draw_all+0x1160>)
 800c8ba:	6819      	ldr	r1, [r3, #0]
 800c8bc:	2900      	cmp	r1, #0
 800c8be:	f040 83b1 	bne.w	800d024 <draw_all+0x17e4>
    plot_printf(msg, (int)sizeof(msg), "F Res ---.---.--- Hz");
 800c8c2:	ac22      	add	r4, sp, #136	@ 0x88
 800c8c4:	4a37      	ldr	r2, [pc, #220]	@ (800c9a4 <draw_all+0x1164>)
 800c8c6:	2128      	movs	r1, #40	@ 0x28
 800c8c8:	4620      	mov	r0, r4
 800c8ca:	f7f6 f9fb 	bl	8002cc4 <plot_printf>
  const int text_w = cell_string_width(msg) * 2;
 800c8ce:	4620      	mov	r0, r4
 800c8d0:	f7fd f808 	bl	80098e4 <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800c8d4:	f240 13c7 	movw	r3, #455	@ 0x1c7
 800c8d8:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
 800c8dc:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
  lcd_set_foreground(LCD_INTERP_CAL_COLOR); // bright green
 800c8e0:	2017      	movs	r0, #23
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800c8e2:	105d      	asrs	r5, r3, #1
  lcd_set_foreground(LCD_INTERP_CAL_COLOR); // bright green
 800c8e4:	f003 fbf4 	bl	80100d0 <lcd_set_foreground>
  const int text_wt = cell_string_width(msg) * 2;
 800c8e8:	4620      	mov	r0, r4
 800c8ea:	f7fc fffb 	bl	80098e4 <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800c8ee:	3505      	adds	r5, #5
  const int text_wt = cell_string_width(msg) * 2;
 800c8f0:	0040      	lsls	r0, r0, #1
  cell_fill_bg_rect(x0, y0, x, y, text_wt, text_ht);
 800c8f2:	9000      	str	r0, [sp, #0]
 800c8f4:	462a      	mov	r2, r5
 800c8f6:	4658      	mov	r0, fp
 800c8f8:	2301      	movs	r3, #1
 800c8fa:	2100      	movs	r1, #0
 800c8fc:	f7fd fe76 	bl	800a5ec <cell_fill_bg_rect.constprop.0>
  cell_drawstring_big(msg, x - x0, y - y0);
 800c900:	eba5 010b 	sub.w	r1, r5, fp
 800c904:	2201      	movs	r2, #1
 800c906:	4620      	mov	r0, r4
 800c908:	f7fd f808 	bl	800991c <cell_drawstring_big>
  if (y0 == CELLHEIGHT)
 800c90c:	f7ff bb0c 	b.w	800bf28 <draw_all+0x6e8>
  for (y = 0; y < h; y++)
 800c910:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800c912:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 800c916:	f8cd b040 	str.w	fp, [sp, #64]	@ 0x40
 800c91a:	4653      	mov	r3, sl
 800c91c:	f1cb 07e8 	rsb	r7, fp, #232	@ 0xe8
 800c920:	f102 0a53 	add.w	sl, r2, #83	@ 0x53
 800c924:	f8cd 8010 	str.w	r8, [sp, #16]
 800c928:	469b      	mov	fp, r3
      if (smith_grid(-x + x0, y + y0))
 800c92a:	eb0a 050b 	add.w	r5, sl, fp
    for (x = 0; x < w; x++)
 800c92e:	2600      	movs	r6, #0
      if (smith_grid(-x + x0, y + y0))
 800c930:	4629      	mov	r1, r5
 800c932:	1bb8      	subs	r0, r7, r6
 800c934:	f7fc fdc2 	bl	80094bc <smith_grid>
 800c938:	b108      	cbz	r0, 800c93e <draw_all+0x10fe>
        cell_buffer[y * CELLWIDTH + x] = color;
 800c93a:	f828 4016 	strh.w	r4, [r8, r6, lsl #1]
    for (x = 0; x < w; x++)
 800c93e:	3601      	adds	r6, #1
 800c940:	45b1      	cmp	r9, r6
 800c942:	dcf5      	bgt.n	800c930 <draw_all+0x10f0>
  for (y = 0; y < h; y++)
 800c944:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800c946:	f10b 0b01 	add.w	fp, fp, #1
 800c94a:	455b      	cmp	r3, fp
 800c94c:	f108 0840 	add.w	r8, r8, #64	@ 0x40
 800c950:	dceb      	bgt.n	800c92a <draw_all+0x10ea>
 800c952:	e406      	b.n	800c162 <draw_all+0x922>
  if (current_props._measure >= MEASURE_END)
 800c954:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800c956:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800c95a:	2b07      	cmp	r3, #7
 800c95c:	f63f ab8a 	bhi.w	800c074 <draw_all+0x834>
  measure_cell_cb_t measure_draw_cb = measure[current_props._measure].measure_cell;
 800c960:	4a11      	ldr	r2, [pc, #68]	@ (800c9a8 <draw_all+0x1168>)
 800c962:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c966:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800c96a:	685c      	ldr	r4, [r3, #4]
  if (measure_draw_cb)
 800c96c:	2c00      	cmp	r4, #0
 800c96e:	f47f ab49 	bne.w	800c004 <draw_all+0x7c4>
 800c972:	f7ff bb7f 	b.w	800c074 <draw_all+0x834>
 800c976:	bf00      	nop
 800c978:	20000aa8 	.word	0x20000aa8
 800c97c:	080141e0 	.word	0x080141e0
 800c980:	08014540 	.word	0x08014540
 800c984:	08011d40 	.word	0x08011d40
 800c988:	08011d98 	.word	0x08011d98
 800c98c:	08011d74 	.word	0x08011d74
 800c990:	4a36fa92 	.word	0x4a36fa92
 800c994:	08011da0 	.word	0x08011da0
 800c998:	08011db4 	.word	0x08011db4
 800c99c:	20006875 	.word	0x20006875
 800c9a0:	2000687c 	.word	0x2000687c
 800c9a4:	08011dd4 	.word	0x08011dd4
 800c9a8:	08014200 	.word	0x08014200
  if (mla_resonance_locked && (swr > 0.0f) && (swr < 100.0f)) {
 800c9ac:	7833      	ldrb	r3, [r6, #0]
 800c9ae:	2b00      	cmp	r3, #0
 800c9b0:	f000 80d7 	beq.w	800cb62 <draw_all+0x1322>
  float swr = mla_res_swr;
 800c9b4:	4bce      	ldr	r3, [pc, #824]	@ (800ccf0 <draw_all+0x14b0>)
 800c9b6:	ed93 8a00 	vldr	s16, [r3]
  if (mla_resonance_locked && (swr > 0.0f) && (swr < 100.0f)) {
 800c9ba:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800c9be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c9c2:	f340 80ce 	ble.w	800cb62 <draw_all+0x1322>
 800c9c6:	ed9f 9acb 	vldr	s18, [pc, #812]	@ 800ccf4 <draw_all+0x14b4>
 800c9ca:	eeb4 8ac9 	vcmpe.f32	s16, s18
 800c9ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c9d2:	f140 80c6 	bpl.w	800cb62 <draw_all+0x1322>
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800c9d6:	ee18 0a10 	vmov	r0, s16
 800c9da:	f7f3 fde1 	bl	80005a0 <__aeabi_f2d>
    if (swr > 1.0001f) {
 800c9de:	eddf 7ac6 	vldr	s15, [pc, #792]	@ 800ccf8 <draw_all+0x14b8>
 800c9e2:	eeb4 8ae7 	vcmpe.f32	s16, s15
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800c9e6:	4604      	mov	r4, r0
 800c9e8:	460d      	mov	r5, r1
    if (swr > 1.0001f) {
 800c9ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800c9ee:	e9cd 4504 	strd	r4, r5, [sp, #16]
    if (swr > 1.0001f) {
 800c9f2:	f300 82b9 	bgt.w	800cf68 <draw_all+0x1728>
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800c9f6:	ed9d 7b04 	vldr	d7, [sp, #16]
 800c9fa:	ac22      	add	r4, sp, #136	@ 0x88
 800c9fc:	f04f 0800 	mov.w	r8, #0
 800ca00:	f04f 0900 	mov.w	r9, #0
 800ca04:	4abd      	ldr	r2, [pc, #756]	@ (800ccfc <draw_all+0x14bc>)
 800ca06:	2150      	movs	r1, #80	@ 0x50
 800ca08:	ed8d 7b00 	vstr	d7, [sp]
 800ca0c:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800ca10:	4620      	mov	r0, r4
 800ca12:	f7f6 f957 	bl	8002cc4 <plot_printf>
  int text_w = cell_string_width(msg) * 2; // BIG font => *2
 800ca16:	4620      	mov	r0, r4
 800ca18:	f7fc ff64 	bl	80098e4 <cell_string_width>
 800ca1c:	0040      	lsls	r0, r0, #1
  if (text_w > max_w) {
 800ca1e:	f5b0 7fe2 	cmp.w	r0, #452	@ 0x1c4
 800ca22:	f2c0 838f 	blt.w	800d144 <draw_all+0x1904>
      plot_printf(msg, (int)sizeof(msg), "SWR %.2f Refl %.1f%%", swr, pref_pct);
 800ca26:	ed9d 7b04 	vldr	d7, [sp, #16]
 800ca2a:	4ab5      	ldr	r2, [pc, #724]	@ (800cd00 <draw_all+0x14c0>)
 800ca2c:	2150      	movs	r1, #80	@ 0x50
 800ca2e:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800ca32:	ed8d 7b00 	vstr	d7, [sp]
 800ca36:	4620      	mov	r0, r4
 800ca38:	f7f6 f944 	bl	8002cc4 <plot_printf>
    text_w = cell_string_width(msg) * 2;
 800ca3c:	4620      	mov	r0, r4
 800ca3e:	f7fc ff51 	bl	80098e4 <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800ca42:	f240 12c7 	movw	r2, #455	@ 0x1c7
 800ca46:	eba2 0240 	sub.w	r2, r2, r0, lsl #1
 800ca4a:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 800ca4e:	1057      	asrs	r7, r2, #1
    text_w = cell_string_width(msg) * 2;
 800ca50:	0040      	lsls	r0, r0, #1
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800ca52:	3705      	adds	r7, #5
    if      (swr <= 1.10f) color_idx = LCD_INTERP_CAL_COLOR; // bright green
 800ca54:	eddf 7aab 	vldr	s15, [pc, #684]	@ 800cd04 <draw_all+0x14c4>
 800ca58:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800ca5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca60:	f240 82d9 	bls.w	800d016 <draw_all+0x17d6>
    else if (swr <= 1.50f) color_idx = LCD_TRACE_3_COLOR;    // green
 800ca64:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 800ca68:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800ca6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca70:	f240 82d3 	bls.w	800d01a <draw_all+0x17da>
    else if (swr <= 2.00f) color_idx = LCD_TRACE_1_COLOR;    // yellow
 800ca74:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800ca78:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800ca7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca80:	f240 835a 	bls.w	800d138 <draw_all+0x18f8>
    else if (swr <= 3.00f) color_idx = LCD_TRACE_4_COLOR;    // magenta
 800ca84:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
    else                   color_idx = LCD_DISABLE_CAL_COLOR;// red
 800ca88:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800ca8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ca90:	bf94      	ite	ls
 800ca92:	2509      	movls	r5, #9
 800ca94:	2518      	movhi	r5, #24
 800ca96:	e084      	b.n	800cba2 <draw_all+0x1362>
      search_index_range_x(x0, x0 + w, index, &i0, &i1);
 800ca98:	9914      	ldr	r1, [sp, #80]	@ 0x50
  int head = 0, tail = sweep_points;
 800ca9a:	4634      	mov	r4, r6
      search_index_range_x(x0, x0 + w, index, &i0, &i1);
 800ca9c:	eb0b 0701 	add.w	r7, fp, r1
  int head = 0, tail = sweep_points;
 800caa0:	4655      	mov	r5, sl
    i = (head + tail) >> 1;
 800caa2:	eb05 0904 	add.w	r9, r5, r4
 800caa6:	ea4f 0969 	mov.w	r9, r9, asr #1
    if (index[i].x >= x2)
 800caaa:	f832 1029 	ldrh.w	r1, [r2, r9, lsl #2]
 800caae:	428f      	cmp	r7, r1
 800cab0:	dc0b      	bgt.n	800caca <draw_all+0x128a>
      if (tail == i)
 800cab2:	454c      	cmp	r4, r9
 800cab4:	f43f abd5 	beq.w	800c262 <draw_all+0xa22>
      tail = i;
 800cab8:	464c      	mov	r4, r9
    i = (head + tail) >> 1;
 800caba:	eb05 0904 	add.w	r9, r5, r4
 800cabe:	ea4f 0969 	mov.w	r9, r9, asr #1
    if (index[i].x >= x2)
 800cac2:	f832 1029 	ldrh.w	r1, [r2, r9, lsl #2]
 800cac6:	428f      	cmp	r7, r1
 800cac8:	ddf3      	ble.n	800cab2 <draw_all+0x1272>
    else if (index[i].x < x1)
 800caca:	458b      	cmp	fp, r1
 800cacc:	f340 81b2 	ble.w	800ce34 <draw_all+0x15f4>
      if (head == i)
 800cad0:	454d      	cmp	r5, r9
 800cad2:	f43f abc6 	beq.w	800c262 <draw_all+0xa22>
      head = i;
 800cad6:	464d      	mov	r5, r9
 800cad8:	e7e3      	b.n	800caa2 <draw_all+0x1262>
  if (current_trace == TRACE_INVALID)
 800cada:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 800cadc:	f991 301c 	ldrsb.w	r3, [r1, #28]
 800cae0:	1c5d      	adds	r5, r3, #1
 800cae2:	f43f ac66 	beq.w	800c3b2 <draw_all+0xb72>
  uint32_t trace_type = 1 << trace[current_trace].type;
 800cae6:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 800caea:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800caee:	2101      	movs	r1, #1
 800caf0:	f892 0029 	ldrb.w	r0, [r2, #41]	@ 0x29
 800caf4:	4081      	lsls	r1, r0
  if (trace_type & ROUND_GRID_MASK)
 800caf6:	f011 0f18 	tst.w	r1, #24
 800cafa:	f47f ac5a 	bne.w	800c3b2 <draw_all+0xb72>
  float ref = NGRIDY - get_trace_refpos(current_trace);
 800cafe:	edd2 7a0c 	vldr	s15, [r2, #48]	@ 0x30
  float scale = get_trace_scale(current_trace);
 800cb02:	ed92 9a0b 	vldr	s18, [r2, #44]	@ 0x2c
  int16_t ypos = 0 - y0 + 2;
 800cb06:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800cb08:	f5c2 447f 	rsb	r4, r2, #65280	@ 0xff00
  float ref = NGRIDY - get_trace_refpos(current_trace);
 800cb0c:	eeb2 8a00 	vmov.f32	s16, #32	@ 0x41000000  8.0
  int16_t ypos = 0 - y0 + 2;
 800cb10:	3417      	adds	r4, #23
  int16_t xpos = GRID_X_TEXT - x0;
 800cb12:	f5cb 75d2 	rsb	r5, fp, #420	@ 0x1a4
  if (trace_type & (1 << TRC_SWR))
 800cb16:	2806      	cmp	r0, #6
  float ref = NGRIDY - get_trace_refpos(current_trace);
 800cb18:	ee38 8a67 	vsub.f32	s16, s16, s15
  int16_t ypos = 0 - y0 + 2;
 800cb1c:	b224      	sxth	r4, r4
  int16_t xpos = GRID_X_TEXT - x0;
 800cb1e:	b22d      	sxth	r5, r5
  if (trace_type & (1 << TRC_SWR))
 800cb20:	d105      	bne.n	800cb2e <draw_all+0x12ee>
    ref += 1.0f / scale; // For SWR trace, value shift by 1.0
 800cb22:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800cb26:	eec7 7a09 	vdiv.f32	s15, s14, s18
 800cb2a:	ee38 8a27 	vadd.f32	s16, s16, s15
  lcd_set_foreground(LCD_TRACE_1_COLOR + current_trace);
 800cb2e:	3306      	adds	r3, #6
 800cb30:	b298      	uxth	r0, r3
 800cb32:	f003 facd 	bl	80100d0 <lcd_set_foreground>
    ref -= 1.0f;
 800cb36:	eef7 9a00 	vmov.f32	s19, #112	@ 0x3f800000  1.0
    cell_printf(xpos, ypos, "% 6.3F", ref * scale);
 800cb3a:	ee69 7a08 	vmul.f32	s15, s18, s16
    ref -= 1.0f;
 800cb3e:	ee38 8a69 	vsub.f32	s16, s16, s19
    cell_printf(xpos, ypos, "% 6.3F", ref * scale);
 800cb42:	ee17 0a90 	vmov	r0, s15
 800cb46:	f7f3 fd2b 	bl	80005a0 <__aeabi_f2d>
 800cb4a:	e9cd 0100 	strd	r0, r1, [sp]
 800cb4e:	4621      	mov	r1, r4
 800cb50:	3426      	adds	r4, #38	@ 0x26
 800cb52:	4a6d      	ldr	r2, [pc, #436]	@ (800cd08 <draw_all+0x14c8>)
 800cb54:	4628      	mov	r0, r5
  } while ((ypos += GRIDY) < CELLHEIGHT);
 800cb56:	b224      	sxth	r4, r4
    cell_printf(xpos, ypos, "% 6.3F", ref * scale);
 800cb58:	f7fd f888 	bl	8009c6c <cell_printf>
  } while ((ypos += GRIDY) < CELLHEIGHT);
 800cb5c:	2c1f      	cmp	r4, #31
 800cb5e:	ddec      	ble.n	800cb3a <draw_all+0x12fa>
 800cb60:	e427      	b.n	800c3b2 <draw_all+0xb72>
    plot_printf(msg, (int)sizeof(msg), "SWR --.--  |  Refl --.-%%");
 800cb62:	ac22      	add	r4, sp, #136	@ 0x88
 800cb64:	4a69      	ldr	r2, [pc, #420]	@ (800cd0c <draw_all+0x14cc>)
 800cb66:	2150      	movs	r1, #80	@ 0x50
 800cb68:	4620      	mov	r0, r4
 800cb6a:	f7f6 f8ab 	bl	8002cc4 <plot_printf>
  int text_w = cell_string_width(msg) * 2; // BIG font => *2
 800cb6e:	4620      	mov	r0, r4
 800cb70:	f7fc feb8 	bl	80098e4 <cell_string_width>
 800cb74:	0040      	lsls	r0, r0, #1
  if (text_w > max_w) {
 800cb76:	f5b0 7fe2 	cmp.w	r0, #452	@ 0x1c4
 800cb7a:	f2c0 80b2 	blt.w	800cce2 <draw_all+0x14a2>
      plot_printf(msg, (int)sizeof(msg), "SWR --.-- Refl --.-%%");
 800cb7e:	4a64      	ldr	r2, [pc, #400]	@ (800cd10 <draw_all+0x14d0>)
 800cb80:	2150      	movs	r1, #80	@ 0x50
 800cb82:	4620      	mov	r0, r4
 800cb84:	f7f6 f89e 	bl	8002cc4 <plot_printf>
    text_w = cell_string_width(msg) * 2;
 800cb88:	4620      	mov	r0, r4
 800cb8a:	f7fc feab 	bl	80098e4 <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800cb8e:	f240 12c7 	movw	r2, #455	@ 0x1c7
 800cb92:	eba2 0240 	sub.w	r2, r2, r0, lsl #1
 800cb96:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 800cb9a:	1057      	asrs	r7, r2, #1
    text_w = cell_string_width(msg) * 2;
 800cb9c:	0040      	lsls	r0, r0, #1
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800cb9e:	3705      	adds	r7, #5
  uint16_t color_idx = LCD_BW_TEXT_COLOR; // gray for invalid/unlocked
 800cba0:	2512      	movs	r5, #18
  cell_fill_bg_rect(x0, y0, x, y, text_w, text_ht);
 800cba2:	463a      	mov	r2, r7
 800cba4:	9000      	str	r0, [sp, #0]
 800cba6:	232a      	movs	r3, #42	@ 0x2a
 800cba8:	2120      	movs	r1, #32
 800cbaa:	4658      	mov	r0, fp
 800cbac:	f7fd fd1e 	bl	800a5ec <cell_fill_bg_rect.constprop.0>
  lcd_set_foreground(color_idx);
 800cbb0:	4628      	mov	r0, r5
 800cbb2:	f003 fa8d 	bl	80100d0 <lcd_set_foreground>
  cell_drawstring_big(msg, x - x0, y - y0);
 800cbb6:	eba7 010b 	sub.w	r1, r7, fp
 800cbba:	220a      	movs	r2, #10
 800cbbc:	4620      	mov	r0, r4
 800cbbe:	f7fc fead 	bl	800991c <cell_drawstring_big>
}
 800cbc2:	f7ff b9b1 	b.w	800bf28 <draw_all+0x6e8>
      if (mk == active_marker && lever_mode == LM_MARKER)
 800cbc6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800cbc8:	7f1b      	ldrb	r3, [r3, #28]
 800cbca:	2b00      	cmp	r3, #0
 800cbcc:	f47f ad5c 	bne.w	800c688 <draw_all+0xe48>
        cell_printf(xpos, ypos, S_SARROW);
 800cbd0:	4a50      	ldr	r2, [pc, #320]	@ (800cd14 <draw_all+0x14d4>)
 800cbd2:	4651      	mov	r1, sl
 800cbd4:	b228      	sxth	r0, r5
 800cbd6:	f7fd f849 	bl	8009c6c <cell_printf>
 800cbda:	e555      	b.n	800c688 <draw_all+0xe48>
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800cbdc:	f800 5f01 	strb.w	r5, [r0, #1]!
  lcd_printf(x, y += sFONT_STR_HEIGHT, "P%c", current_props._power > 3 ? ('a') : (current_props._power * 2 + '2'));
 800cbe0:	4613      	mov	r3, r2
 800cbe2:	f7fe bfce 	b.w	800bb82 <draw_all+0x342>
  for (int power = BATTERY_TOP_LEVEL; power > BATTERY_BOTTOM_LEVEL;)
 800cbe6:	f5b1 6f48 	cmp.w	r1, #3200	@ 0xc80
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800cbea:	f800 5f01 	strb.w	r5, [r0, #1]!
  for (int power = BATTERY_TOP_LEVEL; power > BATTERY_BOTTOM_LEVEL;)
 800cbee:	dcf7      	bgt.n	800cbe0 <draw_all+0x13a0>
 800cbf0:	f103 01d8 	add.w	r1, r3, #216	@ 0xd8
 800cbf4:	4469      	add	r1, sp
 800cbf6:	f7fe bfd4 	b.w	800bba2 <draw_all+0x362>
    ypos = 1 + ((j + 1) / 2) * FONT_STR_HEIGHT - y0;
 800cbfa:	f108 0301 	add.w	r3, r8, #1
 800cbfe:	105b      	asrs	r3, r3, #1
 800cc00:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800cc04:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    if (!(props_mode & TD_MARKER_DELTA) && active_marker != previous_marker)
 800cc08:	990b      	ldr	r1, [sp, #44]	@ 0x2c
    ypos = 1 + ((j + 1) / 2) * FONT_STR_HEIGHT - y0;
 800cc0a:	9a08      	ldr	r2, [sp, #32]
 800cc0c:	f8dd b048 	ldr.w	fp, [sp, #72]	@ 0x48
 800cc10:	3301      	adds	r3, #1
 800cc12:	1a9d      	subs	r5, r3, r2
    if (!(props_mode & TD_MARKER_DELTA) && active_marker != previous_marker)
 800cc14:	8b0b      	ldrh	r3, [r1, #24]
 800cc16:	05d8      	lsls	r0, r3, #23
 800cc18:	f53f adfc 	bmi.w	800c814 <draw_all+0xfd4>
 800cc1c:	f991 301d 	ldrsb.w	r3, [r1, #29]
 800cc20:	f991 201e 	ldrsb.w	r2, [r1, #30]
 800cc24:	4293      	cmp	r3, r2
 800cc26:	f43f adf5 	beq.w	800c814 <draw_all+0xfd4>
      int previous_marker_idx = markers[previous_marker].index;
 800cc2a:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 800cc2e:	fa1f f48b 	uxth.w	r4, fp
      cell_printf(xpos, ypos, S_DELTA "%d-%d:", active_marker + 1, previous_marker + 1);
 800cc32:	3201      	adds	r2, #1
 800cc34:	f1c4 00fd 	rsb	r0, r4, #253	@ 0xfd
 800cc38:	b22e      	sxth	r6, r5
      int previous_marker_idx = markers[previous_marker].index;
 800cc3a:	f8b1 705a 	ldrh.w	r7, [r1, #90]	@ 0x5a
      cell_printf(xpos, ypos, S_DELTA "%d-%d:", active_marker + 1, previous_marker + 1);
 800cc3e:	9200      	str	r2, [sp, #0]
 800cc40:	3301      	adds	r3, #1
 800cc42:	4a35      	ldr	r2, [pc, #212]	@ (800cd18 <draw_all+0x14d8>)
 800cc44:	4631      	mov	r1, r6
 800cc46:	b200      	sxth	r0, r0
 800cc48:	f7fd f810 	bl	8009c6c <cell_printf>
      if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800cc4c:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800cc4e:	8b13      	ldrh	r3, [r2, #24]
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800cc50:	f5c4 7491 	rsb	r4, r4, #290	@ 0x122
      if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800cc54:	07d9      	lsls	r1, r3, #31
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800cc56:	b224      	sxth	r4, r4
      if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800cc58:	f100 81b2 	bmi.w	800cfc0 <draw_all+0x1780>
        freq_t freq = get_marker_frequency(active_marker);
 800cc5c:	f992 001d 	ldrsb.w	r0, [r2, #29]
 800cc60:	f7fa fad2 	bl	8007208 <get_marker_frequency>
        freq_t freq1 = get_marker_frequency(previous_marker);
 800cc64:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
        freq_t freq = get_marker_frequency(active_marker);
 800cc66:	4607      	mov	r7, r0
        freq_t freq1 = get_marker_frequency(previous_marker);
 800cc68:	f992 001e 	ldrsb.w	r0, [r2, #30]
 800cc6c:	f7fa facc 	bl	8007208 <get_marker_frequency>
        freq_t delta = freq >= freq1 ? freq - freq1 : freq1 - freq;
 800cc70:	4287      	cmp	r7, r0
        freq_t freq1 = get_marker_frequency(previous_marker);
 800cc72:	4603      	mov	r3, r0
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800cc74:	bf27      	ittee	cs
 800cc76:	222b      	movcs	r2, #43	@ 0x2b
        freq_t delta = freq >= freq1 ? freq - freq1 : freq1 - freq;
 800cc78:	1a3b      	subcs	r3, r7, r0
 800cc7a:	1bdb      	subcc	r3, r3, r7
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800cc7c:	222d      	movcc	r2, #45	@ 0x2d
 800cc7e:	9300      	str	r3, [sp, #0]
 800cc80:	4631      	mov	r1, r6
 800cc82:	4613      	mov	r3, r2
 800cc84:	4620      	mov	r0, r4
 800cc86:	4a25      	ldr	r2, [pc, #148]	@ (800cd1c <draw_all+0x14dc>)
 800cc88:	f7fc fff0 	bl	8009c6c <cell_printf>
 800cc8c:	e5c2      	b.n	800c814 <draw_all+0xfd4>
    float q = (float)mla_res_freq / (float)mla_bw_swr2;
 800cc8e:	ee07 3a90 	vmov	s15, r3
 800cc92:	ee07 2a10 	vmov	s14, r2
 800cc96:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cc9a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    q_int = (uint32_t)(q + 0.5f); // round to nearest integer
 800cc9e:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
    float q = (float)mla_res_freq / (float)mla_bw_swr2;
 800cca2:	eec7 6a87 	vdiv.f32	s13, s15, s14
    plot_printf(msg, (int)sizeof(msg), "Q2=%u", (unsigned)q_int);
 800cca6:	4a1e      	ldr	r2, [pc, #120]	@ (800cd20 <draw_all+0x14e0>)
 800cca8:	2118      	movs	r1, #24
 800ccaa:	4620      	mov	r0, r4
    q_int = (uint32_t)(q + 0.5f); // round to nearest integer
 800ccac:	ee76 7a86 	vadd.f32	s15, s13, s12
    plot_printf(msg, (int)sizeof(msg), "Q2=%u", (unsigned)q_int);
 800ccb0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800ccb4:	ee17 3a90 	vmov	r3, s15
 800ccb8:	f7f6 f804 	bl	8002cc4 <plot_printf>
  {
 800ccbc:	f7ff b96f 	b.w	800bf9e <draw_all+0x75e>
  for (t = TRACE_INDEX_COUNT - 1; t >= 0; t--)
 800ccc0:	4b18      	ldr	r3, [pc, #96]	@ (800cd24 <draw_all+0x14e4>)
 800ccc2:	f2a2 6244 	subw	r2, r2, #1604	@ 0x644
 800ccc6:	2003      	movs	r0, #3
 800ccc8:	f7ff bad3 	b.w	800c272 <draw_all+0xa32>
    format = (scale != 1.0f) ? "%s %0.1fFS" : "%s ";
 800cccc:	ee07 aa10 	vmov	s14, sl
 800ccd0:	eeb4 7a67 	vcmp.f32	s14, s15
 800ccd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ccd8:	f040 80a0 	bne.w	800ce1c <draw_all+0x15dc>
 800ccdc:	4b12      	ldr	r3, [pc, #72]	@ (800cd28 <draw_all+0x14e8>)
 800ccde:	9310      	str	r3, [sp, #64]	@ 0x40
 800cce0:	e53f      	b.n	800c762 <draw_all+0xf22>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800cce2:	f5c0 72e3 	rsb	r2, r0, #454	@ 0x1c6
 800cce6:	3201      	adds	r2, #1
 800cce8:	1052      	asrs	r2, r2, #1
 800ccea:	1d57      	adds	r7, r2, #5
  uint16_t color_idx = LCD_BW_TEXT_COLOR; // gray for invalid/unlocked
 800ccec:	2512      	movs	r5, #18
 800ccee:	e758      	b.n	800cba2 <draw_all+0x1362>
 800ccf0:	20006878 	.word	0x20006878
 800ccf4:	42c80000 	.word	0x42c80000
 800ccf8:	3f800347 	.word	0x3f800347
 800ccfc:	08011dec 	.word	0x08011dec
 800cd00:	08011e24 	.word	0x08011e24
 800cd04:	3f8ccccd 	.word	0x3f8ccccd
 800cd08:	08011d5c 	.word	0x08011d5c
 800cd0c:	08011e08 	.word	0x08011e08
 800cd10:	08011e3c 	.word	0x08011e3c
 800cd14:	08011d64 	.word	0x08011d64
 800cd18:	08011d7c 	.word	0x08011d7c
 800cd1c:	08011d84 	.word	0x08011d84
 800cd20:	08011e6c 	.word	0x08011e6c
 800cd24:	20000a9c 	.word	0x20000a9c
 800cd28:	08011d58 	.word	0x08011d58
 800cd2c:	42180000 	.word	0x42180000
 800cd30:	43984000 	.word	0x43984000
  float refpos = HEIGHT - (get_trace_refpos(t)) * GRIDY + 0.5f;   // 0.5 for pixel align
 800cd34:	ed1f 7a03 	vldr	s14, [pc, #-12]	@ 800cd2c <draw_all+0x14ec>
 800cd38:	edd8 6a0c 	vldr	s13, [r8, #48]	@ 0x30
 800cd3c:	ed5f 8a04 	vldr	s17, [pc, #-16]	@ 800cd30 <draw_all+0x14f0>
  get_value_cb_t c = trace_info_list[trace[t].type].get_value_cb; // Get callback for value calculation
 800cd40:	4ac9      	ldr	r2, [pc, #804]	@ (800d068 <draw_all+0x1828>)
      float v = c ? c(i, array[i]) : 0.0f; // Get value
 800cd42:	eddf 9aca 	vldr	s19, [pc, #808]	@ 800d06c <draw_all+0x182c>
    const float dscale = GRIDY / scale;
 800cd46:	ee87 9a27 	vdiv.f32	s18, s14, s15
    if (type & (1 << TRC_SWR))
 800cd4a:	2b06      	cmp	r3, #6
  get_value_cb_t c = trace_info_list[trace[t].type].get_value_cb; // Get callback for value calculation
 800cd4c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800cd50:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    uint32_t dx = ((WIDTH) << 16) / (sweep_points - 1), x = (CELLOFFSETX << 16) + dx * start + 0x8000;
 800cd54:	f04f 0a00 	mov.w	sl, #0
  get_value_cb_t c = trace_info_list[trace[t].type].get_value_cb; // Get callback for value calculation
 800cd58:	f8d3 b018 	ldr.w	fp, [r3, #24]
    uint32_t dx = ((WIDTH) << 16) / (sweep_points - 1), x = (CELLOFFSETX << 16) + dx * start + 0x8000;
 800cd5c:	4bc4      	ldr	r3, [pc, #784]	@ (800d070 <draw_all+0x1830>)
 800cd5e:	fb93 f3f1 	sdiv	r3, r3, r1
 800cd62:	9304      	str	r3, [sp, #16]
 800cd64:	4623      	mov	r3, r4
 800cd66:	f44f 29b0 	mov.w	r9, #360448	@ 0x58000
 800cd6a:	465c      	mov	r4, fp
 800cd6c:	4655      	mov	r5, sl
 800cd6e:	469b      	mov	fp, r3
  float refpos = HEIGHT - (get_trace_refpos(t)) * GRIDY + 0.5f;   // 0.5 for pixel align
 800cd70:	eee6 8ac7 	vfms.f32	s17, s13, s14
      refpos += dscale; // For SWR need shift value by 1.0 down
 800cd74:	bf08      	it	eq
 800cd76:	ee78 8a89 	vaddeq.f32	s17, s17, s18
        y = refpos - v * dscale;
 800cd7a:	eeb1 9a49 	vneg.f32	s18, s18
 800cd7e:	e02b      	b.n	800cdd8 <draw_all+0x1598>
      float v = c ? c(i, array[i]) : 0.0f; // Get value
 800cd80:	eb06 01c0 	add.w	r1, r6, r0, lsl #3
 800cd84:	47a0      	blx	r4
 800cd86:	eeb0 8a40 	vmov.f32	s16, s0
      if (v == infinityf())
 800cd8a:	f004 fbb3 	bl	80114f4 <infinityf>
 800cd8e:	eeb4 0a48 	vcmp.f32	s0, s16
        y = refpos - v * dscale;
 800cd92:	eef0 7a68 	vmov.f32	s15, s17
      if (v == infinityf())
 800cd96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        y = refpos - v * dscale;
 800cd9a:	eee8 7a09 	vfma.f32	s15, s16, s18
        if (y < 0)
 800cd9e:	f04f 0300 	mov.w	r3, #0
      if (v == infinityf())
 800cda2:	d00b      	beq.n	800cdbc <draw_all+0x157c>
        y = refpos - v * dscale;
 800cda4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800cda8:	ee17 3a90 	vmov	r3, s15
        else if (y > HEIGHT)
 800cdac:	f5b3 7f98 	cmp.w	r3, #304	@ 0x130
 800cdb0:	bfa8      	it	ge
 800cdb2:	f44f 7398 	movge.w	r3, #304	@ 0x130
        if (y < 0)
 800cdb6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
      mark_set_index(index, i, (uint16_t)(x >> 16), y);
 800cdba:	b29b      	uxth	r3, r3
 800cdbc:	4629      	mov	r1, r5
 800cdbe:	ea4f 4219 	mov.w	r2, r9, lsr #16
 800cdc2:	4658      	mov	r0, fp
    for (i = start; i <= stop; i++, x += dx)
 800cdc4:	f10a 0a01 	add.w	sl, sl, #1
      mark_set_index(index, i, (uint16_t)(x >> 16), y);
 800cdc8:	f7fc fc62 	bl	8009690 <mark_set_index>
    for (i = start; i <= stop; i++, x += dx)
 800cdcc:	fa1f f58a 	uxth.w	r5, sl
 800cdd0:	9b04      	ldr	r3, [sp, #16]
 800cdd2:	42af      	cmp	r7, r5
 800cdd4:	4499      	add	r9, r3
 800cdd6:	d306      	bcc.n	800cde6 <draw_all+0x15a6>
      float v = c ? c(i, array[i]) : 0.0f; // Get value
 800cdd8:	fa1f f08a 	uxth.w	r0, sl
 800cddc:	2c00      	cmp	r4, #0
 800cdde:	d1cf      	bne.n	800cd80 <draw_all+0x1540>
 800cde0:	eeb0 8a69 	vmov.f32	s16, s19
 800cde4:	e7d1      	b.n	800cd8a <draw_all+0x154a>
 800cde6:	465c      	mov	r4, fp
 800cde8:	f7fe bf09 	b.w	800bbfe <draw_all+0x3be>
      cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx), distance_of_index(active_marker_idx));
 800cdec:	9804      	ldr	r0, [sp, #16]
 800cdee:	f7fc fce1 	bl	80097b4 <time_of_index>
 800cdf2:	ee10 4a10 	vmov	r4, s0
 800cdf6:	f7fc fcf3 	bl	80097e0 <distance_of_index>
 800cdfa:	ee10 0a10 	vmov	r0, s0
 800cdfe:	f7f3 fbcf 	bl	80005a0 <__aeabi_f2d>
 800ce02:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800ce06:	4620      	mov	r0, r4
 800ce08:	f7f3 fbca 	bl	80005a0 <__aeabi_f2d>
 800ce0c:	4a99      	ldr	r2, [pc, #612]	@ (800d074 <draw_all+0x1834>)
 800ce0e:	e9cd 0100 	strd	r0, r1, [sp]
 800ce12:	4631      	mov	r1, r6
 800ce14:	4638      	mov	r0, r7
 800ce16:	f7fc ff29 	bl	8009c6c <cell_printf>
 800ce1a:	e4fb      	b.n	800c814 <draw_all+0xfd4>
    format = (scale != 1.0f) ? "%s %0.1fFS" : "%s ";
 800ce1c:	4b96      	ldr	r3, [pc, #600]	@ (800d078 <draw_all+0x1838>)
 800ce1e:	9310      	str	r3, [sp, #64]	@ 0x40
 800ce20:	e49f      	b.n	800c762 <draw_all+0xf22>
 800ce22:	4d96      	ldr	r5, [pc, #600]	@ (800d07c <draw_all+0x183c>)
 800ce24:	4644      	mov	r4, r8
 800ce26:	e463      	b.n	800c6f0 <draw_all+0xeb0>
        cell_printf(xpos, ypos, S_SARROW);
 800ce28:	4a95      	ldr	r2, [pc, #596]	@ (800d080 <draw_all+0x1840>)
 800ce2a:	4649      	mov	r1, r9
 800ce2c:	b230      	sxth	r0, r6
 800ce2e:	f7fc ff1d 	bl	8009c6c <cell_printf>
 800ce32:	e477      	b.n	800c724 <draw_all+0xee4>
  *i0 = *i1 = i;
 800ce34:	46cc      	mov	ip, r9
 800ce36:	e005      	b.n	800ce44 <draw_all+0x1604>
  while (*i0 > 0 && x1 <= index[--*i0].x)
 800ce38:	f10c 3cff 	add.w	ip, ip, #4294967295
 800ce3c:	f832 102c 	ldrh.w	r1, [r2, ip, lsl #2]
 800ce40:	458b      	cmp	fp, r1
 800ce42:	dc02      	bgt.n	800ce4a <draw_all+0x160a>
 800ce44:	f1bc 0f00 	cmp.w	ip, #0
 800ce48:	dcf6      	bgt.n	800ce38 <draw_all+0x15f8>
  while (*i1 < sweep_points - 1 && x2 > index[++*i1].x)
 800ce4a:	3e01      	subs	r6, #1
 800ce4c:	e006      	b.n	800ce5c <draw_all+0x161c>
 800ce4e:	f109 0901 	add.w	r9, r9, #1
 800ce52:	f832 1029 	ldrh.w	r1, [r2, r9, lsl #2]
 800ce56:	428f      	cmp	r7, r1
 800ce58:	f77f aa24 	ble.w	800c2a4 <draw_all+0xa64>
 800ce5c:	45b1      	cmp	r9, r6
 800ce5e:	dbf6      	blt.n	800ce4e <draw_all+0x160e>
 800ce60:	f7ff ba20 	b.w	800c2a4 <draw_all+0xa64>
      markmap_all_markers();
 800ce64:	f7fe fa2c 	bl	800b2c0 <markmap_all_markers>
    if (redraw_request & REDRAW_REFERENCE)
 800ce68:	4b86      	ldr	r3, [pc, #536]	@ (800d084 <draw_all+0x1844>)
 800ce6a:	881c      	ldrh	r4, [r3, #0]
 800ce6c:	0660      	lsls	r0, r4, #25
 800ce6e:	f57e ad03 	bpl.w	800b878 <draw_all+0x38>
  invalidate_rect(0, 0, CELLOFFSETX + 1, AREA_HEIGHT_NORMAL);
 800ce72:	2200      	movs	r2, #0
 800ce74:	4611      	mov	r1, r2
 800ce76:	2309      	movs	r3, #9
 800ce78:	4610      	mov	r0, r2
 800ce7a:	f7fc fc55 	bl	8009728 <invalidate_rect_func>
    if (redraw_request & REDRAW_GRID_VALUE)
 800ce7e:	0621      	lsls	r1, r4, #24
 800ce80:	d504      	bpl.n	800ce8c <draw_all+0x164c>
  if (VNA_MODE(VNA_MODE_SHOW_GRID))
 800ce82:	4b81      	ldr	r3, [pc, #516]	@ (800d088 <draw_all+0x1848>)
 800ce84:	8a9b      	ldrh	r3, [r3, #20]
 800ce86:	071b      	lsls	r3, r3, #28
 800ce88:	f100 814f 	bmi.w	800d12a <draw_all+0x18ea>
  if (redraw_request & (REDRAW_CELLS | REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_REFERENCE | REDRAW_AREA))
 800ce8c:	4e7f      	ldr	r6, [pc, #508]	@ (800d08c <draw_all+0x184c>)
 800ce8e:	f7fe bd20 	b.w	800b8d2 <draw_all+0x92>
    marker_search();
 800ce92:	f7fe fb11 	bl	800b4b8 <marker_search>
 800ce96:	f7fe bebe 	b.w	800bc16 <draw_all+0x3d6>
      lcd_line(CELLOFFSETX + 10, y, CELLOFFSETX + WIDTH - 1, y);
 800ce9a:	f240 12cb 	movw	r2, #459	@ 0x1cb
 800ce9e:	4619      	mov	r1, r3
 800cea0:	200f      	movs	r0, #15
 800cea2:	f003 f873 	bl	800ff8c <lcd_line>
 800cea6:	f7fe bf3e 	b.w	800bd26 <draw_all+0x4e6>
      cell_printf(xpos, ypos, S_SARROW);
 800ceaa:	f1cb 00fd 	rsb	r0, fp, #253	@ 0xfd
 800ceae:	4a74      	ldr	r2, [pc, #464]	@ (800d080 <draw_all+0x1840>)
 800ceb0:	4631      	mov	r1, r6
 800ceb2:	b200      	sxth	r0, r0
 800ceb4:	f7fc feda 	bl	8009c6c <cell_printf>
 800ceb8:	e48c      	b.n	800c7d4 <draw_all+0xf94>
    lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "START 0" S_SECOND "    VF = %d%%", velocity_factor);
 800ceba:	f894 3099 	ldrb.w	r3, [r4, #153]	@ 0x99
 800cebe:	4a74      	ldr	r2, [pc, #464]	@ (800d090 <draw_all+0x1850>)
 800cec0:	f240 1133 	movw	r1, #307	@ 0x133
 800cec4:	200f      	movs	r0, #15
 800cec6:	f003 f9ab 	bl	8010220 <lcd_printf>
    lcd_printf(FREQUENCIES_XPOS2, FREQUENCIES_YPOS, "STOP %F" S_SECOND " (%F" S_METRE ")", time_of_index(sweep_points - 1), distance_of_index(sweep_points - 1));
 800ceca:	8b60      	ldrh	r0, [r4, #26]
 800cecc:	3801      	subs	r0, #1
 800cece:	f7fc fc71 	bl	80097b4 <time_of_index>
 800ced2:	ee10 5a10 	vmov	r5, s0
 800ced6:	f7fc fc83 	bl	80097e0 <distance_of_index>
 800ceda:	ee10 0a10 	vmov	r0, s0
 800cede:	f7f3 fb5f 	bl	80005a0 <__aeabi_f2d>
 800cee2:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800cee6:	4628      	mov	r0, r5
 800cee8:	f7f3 fb5a 	bl	80005a0 <__aeabi_f2d>
 800ceec:	4a69      	ldr	r2, [pc, #420]	@ (800d094 <draw_all+0x1854>)
 800ceee:	e9cd 0100 	strd	r0, r1, [sp]
 800cef2:	f240 1133 	movw	r1, #307	@ 0x133
 800cef6:	f44f 70a3 	mov.w	r0, #326	@ 0x146
 800cefa:	f003 f991 	bl	8010220 <lcd_printf>
 800cefe:	f7fe bd85 	b.w	800ba0c <draw_all+0x1cc>
  char lm1 = lever_mode == LM_FREQ_1 ? S_SARROW[0] : ' ';
 800cf02:	462e      	mov	r6, r5
 800cf04:	f7fe bd53 	b.w	800b9ae <draw_all+0x16e>
    case ST_CENTER: return (frequency0>>1) + (frequency1>>1) + (frequency0&1);
 800cf08:	085b      	lsrs	r3, r3, #1
 800cf0a:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 800cf0e:	f002 0201 	and.w	r2, r2, #1
 800cf12:	4413      	add	r3, r2
      lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm0, "CENTER", get_sweep_frequency(ST_CENTER));
 800cf14:	4a60      	ldr	r2, [pc, #384]	@ (800d098 <draw_all+0x1858>)
 800cf16:	9301      	str	r3, [sp, #4]
 800cf18:	9200      	str	r2, [sp, #0]
 800cf1a:	462b      	mov	r3, r5
 800cf1c:	4a5f      	ldr	r2, [pc, #380]	@ (800d09c <draw_all+0x185c>)
 800cf1e:	f240 1133 	movw	r1, #307	@ 0x133
 800cf22:	200f      	movs	r0, #15
 800cf24:	f003 f97c 	bl	8010220 <lcd_printf>
    case ST_SPAN:   return frequency1 - frequency0;
 800cf28:	6861      	ldr	r1, [r4, #4]
 800cf2a:	68a2      	ldr	r2, [r4, #8]
 800cf2c:	1a52      	subs	r2, r2, r1
      lcd_printf(FREQUENCIES_XPOS2, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm1, "SPAN", get_sweep_frequency(ST_SPAN));
 800cf2e:	9201      	str	r2, [sp, #4]
 800cf30:	4a5b      	ldr	r2, [pc, #364]	@ (800d0a0 <draw_all+0x1860>)
 800cf32:	9200      	str	r2, [sp, #0]
 800cf34:	4633      	mov	r3, r6
 800cf36:	4a59      	ldr	r2, [pc, #356]	@ (800d09c <draw_all+0x185c>)
 800cf38:	f240 1133 	movw	r1, #307	@ 0x133
 800cf3c:	f44f 70a3 	mov.w	r0, #326	@ 0x146
 800cf40:	f003 f96e 	bl	8010220 <lcd_printf>
 800cf44:	f7fe bd62 	b.w	800ba0c <draw_all+0x1cc>
      lcd_set_foreground(LCD_FG_COLOR);
 800cf48:	2001      	movs	r0, #1
 800cf4a:	f003 f8c1 	bl	80100d0 <lcd_set_foreground>
 800cf4e:	f7fe bd9d 	b.w	800ba8c <draw_all+0x24c>
    lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 800cf52:	4608      	mov	r0, r1
 800cf54:	f003 f8d4 	bl	8010100 <lcd_set_colors>
    lcd_fill(BATTERY_ICON_POSX, BATTERY_ICON_POSY, 8, 18);  // 18 is a safe icon height
 800cf58:	2312      	movs	r3, #18
 800cf5a:	2208      	movs	r2, #8
 800cf5c:	2102      	movs	r1, #2
 800cf5e:	2003      	movs	r0, #3
 800cf60:	f002 ffc8 	bl	800fef4 <lcd_fill>
    return;
 800cf64:	f7fe bc98 	b.w	800b898 <draw_all+0x58>
      g = (swr - 1.0f) / (swr + 1.0f);
 800cf68:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800cf6c:	ee78 6a67 	vsub.f32	s13, s16, s15
 800cf70:	ee38 7a27 	vadd.f32	s14, s16, s15
 800cf74:	eec6 7a87 	vdiv.f32	s15, s13, s14
      pref_pct = 100.0f * g * g;
 800cf78:	ee67 7aa7 	vmul.f32	s15, s15, s15
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800cf7c:	ee67 7a89 	vmul.f32	s15, s15, s18
 800cf80:	ee17 0a90 	vmov	r0, s15
 800cf84:	f7f3 fb0c 	bl	80005a0 <__aeabi_f2d>
 800cf88:	ec45 4b17 	vmov	d7, r4, r5
 800cf8c:	4680      	mov	r8, r0
 800cf8e:	4689      	mov	r9, r1
 800cf90:	ac22      	add	r4, sp, #136	@ 0x88
 800cf92:	4a44      	ldr	r2, [pc, #272]	@ (800d0a4 <draw_all+0x1864>)
 800cf94:	2150      	movs	r1, #80	@ 0x50
 800cf96:	ed8d 7b00 	vstr	d7, [sp]
 800cf9a:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800cf9e:	4620      	mov	r0, r4
 800cfa0:	f7f5 fe90 	bl	8002cc4 <plot_printf>
  int text_w = cell_string_width(msg) * 2; // BIG font => *2
 800cfa4:	4620      	mov	r0, r4
 800cfa6:	f7fc fc9d 	bl	80098e4 <cell_string_width>
 800cfaa:	0040      	lsls	r0, r0, #1
  if (text_w > max_w) {
 800cfac:	f5b0 7fe2 	cmp.w	r0, #452	@ 0x1c4
 800cfb0:	f6bf ad39 	bge.w	800ca26 <draw_all+0x11e6>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800cfb4:	f5c0 72e3 	rsb	r2, r0, #454	@ 0x1c6
 800cfb8:	3201      	adds	r2, #1
 800cfba:	1052      	asrs	r2, r2, #1
 800cfbc:	1d57      	adds	r7, r2, #5
  if (valid) {
 800cfbe:	e549      	b.n	800ca54 <draw_all+0x1214>
        cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx) - time_of_index(previous_marker_idx),
 800cfc0:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800cfc4:	4640      	mov	r0, r8
 800cfc6:	f7fc fbf5 	bl	80097b4 <time_of_index>
 800cfca:	4638      	mov	r0, r7
 800cfcc:	eeb0 9a40 	vmov.f32	s18, s0
 800cfd0:	f7fc fbf0 	bl	80097b4 <time_of_index>
                    distance_of_index(active_marker_idx) - distance_of_index(previous_marker_idx));
 800cfd4:	4640      	mov	r0, r8
        cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx) - time_of_index(previous_marker_idx),
 800cfd6:	eeb0 8a40 	vmov.f32	s16, s0
                    distance_of_index(active_marker_idx) - distance_of_index(previous_marker_idx));
 800cfda:	f7fc fc01 	bl	80097e0 <distance_of_index>
 800cfde:	4638      	mov	r0, r7
 800cfe0:	eef0 6a40 	vmov.f32	s13, s0
 800cfe4:	f7fc fbfc 	bl	80097e0 <distance_of_index>
        cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx) - time_of_index(previous_marker_idx),
 800cfe8:	ee76 7ac0 	vsub.f32	s15, s13, s0
 800cfec:	ee17 0a90 	vmov	r0, s15
 800cff0:	f7f3 fad6 	bl	80005a0 <__aeabi_f2d>
 800cff4:	ee79 7a48 	vsub.f32	s15, s18, s16
 800cff8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800cffc:	ee17 0a90 	vmov	r0, s15
 800d000:	f7f3 face 	bl	80005a0 <__aeabi_f2d>
 800d004:	4a1b      	ldr	r2, [pc, #108]	@ (800d074 <draw_all+0x1834>)
 800d006:	e9cd 0100 	strd	r0, r1, [sp]
 800d00a:	4631      	mov	r1, r6
 800d00c:	4620      	mov	r0, r4
 800d00e:	f7fc fe2d 	bl	8009c6c <cell_printf>
 800d012:	f7ff bbff 	b.w	800c814 <draw_all+0xfd4>
    if      (swr <= 1.10f) color_idx = LCD_INTERP_CAL_COLOR; // bright green
 800d016:	2517      	movs	r5, #23
 800d018:	e5c3      	b.n	800cba2 <draw_all+0x1362>
    else if (swr <= 1.50f) color_idx = LCD_TRACE_3_COLOR;    // green
 800d01a:	2508      	movs	r5, #8
 800d01c:	e5c1      	b.n	800cba2 <draw_all+0x1362>
 800d01e:	4c22      	ldr	r4, [pc, #136]	@ (800d0a8 <draw_all+0x1868>)
 800d020:	f7fe bc77 	b.w	800b912 <draw_all+0xd2>
  int group = 0;
 800d024:	9a15      	ldr	r2, [sp, #84]	@ 0x54
      rev[ri++] = (char)('0' + (hz % 10));
 800d026:	f8df c084 	ldr.w	ip, [pc, #132]	@ 800d0ac <draw_all+0x186c>
  int group = 0;
 800d02a:	4617      	mov	r7, r2
      rev[ri++] = (char)('0' + (hz % 10));
 800d02c:	fbac 3001 	umull	r3, r0, ip, r1
 800d030:	08c0      	lsrs	r0, r0, #3
 800d032:	eb00 0480 	add.w	r4, r0, r0, lsl #2
 800d036:	eba1 0444 	sub.w	r4, r1, r4, lsl #1
      group++;
 800d03a:	3701      	adds	r7, #1
      rev[ri++] = (char)('0' + (hz % 10));
 800d03c:	eb0d 0502 	add.w	r5, sp, r2
 800d040:	3430      	adds	r4, #48	@ 0x30
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800d042:	2f03      	cmp	r7, #3
      rev[ri++] = (char)('0' + (hz % 10));
 800d044:	f885 4088 	strb.w	r4, [r5, #136]	@ 0x88
 800d048:	f102 0301 	add.w	r3, r2, #1
      hz /= 10;
 800d04c:	460c      	mov	r4, r1
 800d04e:	4601      	mov	r1, r0
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800d050:	d02e      	beq.n	800d0b0 <draw_all+0x1870>
    while (hz > 0 && ri < (int)sizeof(rev) - 1)
 800d052:	2c09      	cmp	r4, #9
 800d054:	d939      	bls.n	800d0ca <draw_all+0x188a>
 800d056:	461a      	mov	r2, r3
 800d058:	2a17      	cmp	r2, #23
 800d05a:	d1e7      	bne.n	800d02c <draw_all+0x17ec>
  rev[ri] = 0;
 800d05c:	2300      	movs	r3, #0
 800d05e:	f88d 309f 	strb.w	r3, [sp, #159]	@ 0x9f
 800d062:	2317      	movs	r3, #23
 800d064:	e038      	b.n	800d0d8 <draw_all+0x1898>
 800d066:	bf00      	nop
 800d068:	08014540 	.word	0x08014540
 800d06c:	00000000 	.word	0x00000000
 800d070:	01c70000 	.word	0x01c70000
 800d074:	08011d8c 	.word	0x08011d8c
 800d078:	08011d4c 	.word	0x08011d4c
 800d07c:	20000aa8 	.word	0x20000aa8
 800d080:	08011d64 	.word	0x08011d64
 800d084:	200089a8 	.word	0x200089a8
 800d088:	20000318 	.word	0x20000318
 800d08c:	20008990 	.word	0x20008990
 800d090:	08011eac 	.word	0x08011eac
 800d094:	08011ec4 	.word	0x08011ec4
 800d098:	08011e9c 	.word	0x08011e9c
 800d09c:	08011e7c 	.word	0x08011e7c
 800d0a0:	08011ea4 	.word	0x08011ea4
 800d0a4:	08011dec 	.word	0x08011dec
 800d0a8:	20006a34 	.word	0x20006a34
 800d0ac:	cccccccd 	.word	0xcccccccd
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800d0b0:	2c09      	cmp	r4, #9
 800d0b2:	d90a      	bls.n	800d0ca <draw_all+0x188a>
        rev[ri++] = '.';
 800d0b4:	f103 00d8 	add.w	r0, r3, #216	@ 0xd8
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800d0b8:	2b17      	cmp	r3, #23
        rev[ri++] = '.';
 800d0ba:	4468      	add	r0, sp
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800d0bc:	d0ce      	beq.n	800d05c <draw_all+0x181c>
        rev[ri++] = '.';
 800d0be:	232e      	movs	r3, #46	@ 0x2e
 800d0c0:	3202      	adds	r2, #2
 800d0c2:	f800 3c50 	strb.w	r3, [r0, #-80]
        group = 0;
 800d0c6:	2700      	movs	r7, #0
 800d0c8:	e7c6      	b.n	800d058 <draw_all+0x1818>
  rev[ri] = 0;
 800d0ca:	2100      	movs	r1, #0
 800d0cc:	eb0d 0203 	add.w	r2, sp, r3
  while (ri > 0 && oi < out_len - 1)
 800d0d0:	428b      	cmp	r3, r1
  rev[ri] = 0;
 800d0d2:	f882 1088 	strb.w	r1, [r2, #136]	@ 0x88
  while (ri > 0 && oi < out_len - 1)
 800d0d6:	dd31      	ble.n	800d13c <draw_all+0x18fc>
 800d0d8:	ac22      	add	r4, sp, #136	@ 0x88
 800d0da:	18e2      	adds	r2, r4, r3
 800d0dc:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 800d0de:	ab1c      	add	r3, sp, #112	@ 0x70
 800d0e0:	4619      	mov	r1, r3
    out[oi++] = rev[--ri];
 800d0e2:	f812 5d01 	ldrb.w	r5, [r2, #-1]!
 800d0e6:	f801 5b01 	strb.w	r5, [r1], #1
  while (ri > 0 && oi < out_len - 1)
 800d0ea:	42a2      	cmp	r2, r4
    out[oi++] = rev[--ri];
 800d0ec:	f100 0001 	add.w	r0, r0, #1
  while (ri > 0 && oi < out_len - 1)
 800d0f0:	d00c      	beq.n	800d10c <draw_all+0x18cc>
 800d0f2:	2817      	cmp	r0, #23
 800d0f4:	d1f5      	bne.n	800d0e2 <draw_all+0x18a2>
 800d0f6:	f10d 0287 	add.w	r2, sp, #135	@ 0x87
  out[oi] = 0;
 800d0fa:	2100      	movs	r1, #0
 800d0fc:	7011      	strb	r1, [r2, #0]
    plot_printf(msg, (int)sizeof(msg), "F Res %s Hz", fbuf);
 800d0fe:	4620      	mov	r0, r4
 800d100:	4a14      	ldr	r2, [pc, #80]	@ (800d154 <draw_all+0x1914>)
 800d102:	2128      	movs	r1, #40	@ 0x28
 800d104:	f7f5 fdde 	bl	8002cc4 <plot_printf>
  {
 800d108:	f7ff bbe1 	b.w	800c8ce <draw_all+0x108e>
  out[oi] = 0;
 800d10c:	4602      	mov	r2, r0
 800d10e:	441a      	add	r2, r3
 800d110:	e7f3      	b.n	800d0fa <draw_all+0x18ba>
      lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm0, "CW", get_sweep_frequency(ST_CW));
 800d112:	4b11      	ldr	r3, [pc, #68]	@ (800d158 <draw_all+0x1918>)
 800d114:	9201      	str	r2, [sp, #4]
 800d116:	9300      	str	r3, [sp, #0]
 800d118:	4a10      	ldr	r2, [pc, #64]	@ (800d15c <draw_all+0x191c>)
 800d11a:	462b      	mov	r3, r5
 800d11c:	f240 1133 	movw	r1, #307	@ 0x133
 800d120:	200f      	movs	r0, #15
 800d122:	f003 f87d 	bl	8010220 <lcd_printf>
 800d126:	f7fe bc71 	b.w	800ba0c <draw_all+0x1cc>
    invalidate_rect(GRID_X_TEXT, 0, LCD_WIDTH - OFFSETX, LCD_HEIGHT - 1);
 800d12a:	2309      	movs	r3, #9
 800d12c:	220e      	movs	r2, #14
 800d12e:	2100      	movs	r1, #0
 800d130:	200d      	movs	r0, #13
 800d132:	f7fc faf9 	bl	8009728 <invalidate_rect_func>
 800d136:	e6a9      	b.n	800ce8c <draw_all+0x164c>
    else if (swr <= 2.00f) color_idx = LCD_TRACE_1_COLOR;    // yellow
 800d138:	2506      	movs	r5, #6
 800d13a:	e532      	b.n	800cba2 <draw_all+0x1362>
  while (ri > 0 && oi < out_len - 1)
 800d13c:	ab1c      	add	r3, sp, #112	@ 0x70
 800d13e:	461a      	mov	r2, r3
 800d140:	ac22      	add	r4, sp, #136	@ 0x88
 800d142:	e7da      	b.n	800d0fa <draw_all+0x18ba>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800d144:	f5c0 72e3 	rsb	r2, r0, #454	@ 0x1c6
 800d148:	3201      	adds	r2, #1
 800d14a:	1052      	asrs	r2, r2, #1
 800d14c:	1d57      	adds	r7, r2, #5
    if      (swr <= 1.10f) color_idx = LCD_INTERP_CAL_COLOR; // bright green
 800d14e:	2517      	movs	r5, #23
 800d150:	e527      	b.n	800cba2 <draw_all+0x1362>
 800d152:	bf00      	nop
 800d154:	08011dc8 	.word	0x08011dc8
 800d158:	08011e88 	.word	0x08011e88
 800d15c:	08011e7c 	.word	0x08011e7c

0800d160 <redraw_marker>:
  if (marker == MARKER_INVALID || !markers[marker].enabled)
 800d160:	1c42      	adds	r2, r0, #1
 800d162:	d029      	beq.n	800d1b8 <redraw_marker+0x58>
{
 800d164:	b508      	push	{r3, lr}
  if (marker == MARKER_INVALID || !markers[marker].enabled)
 800d166:	f100 020b 	add.w	r2, r0, #11
 800d16a:	4b14      	ldr	r3, [pc, #80]	@ (800d1bc <redraw_marker+0x5c>)
 800d16c:	f813 1032 	ldrb.w	r1, [r3, r2, lsl #3]
 800d170:	b1d9      	cbz	r1, 800d1aa <redraw_marker+0x4a>
  if (marker == active_marker)
 800d172:	f993 101d 	ldrsb.w	r1, [r3, #29]
 800d176:	4281      	cmp	r1, r0
 800d178:	d018      	beq.n	800d1ac <redraw_marker+0x4c>
  request_to_draw_marker(markers[marker].index);
 800d17a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800d17e:	8858      	ldrh	r0, [r3, #2]
 800d180:	f7fe f86e 	bl	800b260 <request_to_draw_marker>
  invalidate_rect(0, 0, AREA_WIDTH_NORMAL, marker_area_max());
 800d184:	f7fd f9f8 	bl	800a578 <marker_area_max>
 800d188:	2100      	movs	r1, #0
 800d18a:	1143      	asrs	r3, r0, #5
 800d18c:	220e      	movs	r2, #14
 800d18e:	4608      	mov	r0, r1
 800d190:	f7fc faca 	bl	8009728 <invalidate_rect_func>
  redraw_request |= REDRAW_CELLS;     // Update cells
 800d194:	4a0a      	ldr	r2, [pc, #40]	@ (800d1c0 <redraw_marker+0x60>)
  redraw_request &= ~(REDRAW_MARKER); // reset all marker update
 800d196:	8813      	ldrh	r3, [r2, #0]
 800d198:	f023 0320 	bic.w	r3, r3, #32
  redraw_request |= REDRAW_CELLS;     // Update cells
 800d19c:	f043 0304 	orr.w	r3, r3, #4
 800d1a0:	8013      	strh	r3, [r2, #0]
}
 800d1a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  draw_all();
 800d1a6:	f7fe bb4b 	b.w	800b840 <draw_all>
}
 800d1aa:	bd08      	pop	{r3, pc}
  data_update |= flag;
 800d1ac:	4805      	ldr	r0, [pc, #20]	@ (800d1c4 <redraw_marker+0x64>)
 800d1ae:	7801      	ldrb	r1, [r0, #0]
 800d1b0:	f041 0102 	orr.w	r1, r1, #2
 800d1b4:	7001      	strb	r1, [r0, #0]
}
 800d1b6:	e7e0      	b.n	800d17a <redraw_marker+0x1a>
 800d1b8:	4770      	bx	lr
 800d1ba:	bf00      	nop
 800d1bc:	20000aa8 	.word	0x20000aa8
 800d1c0:	200089a8 	.word	0x200089a8
 800d1c4:	20006a34 	.word	0x20006a34

0800d1c8 <plot_init>:
{
 800d1c8:	b508      	push	{r3, lr}
  request_to_redraw(REDRAW_PLOT | REDRAW_ALL);
 800d1ca:	f240 301b 	movw	r0, #795	@ 0x31b
 800d1ce:	f7fe fb0f 	bl	800b7f0 <request_to_redraw>
}
 800d1d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  draw_all();
 800d1d6:	f7fe bb33 	b.w	800b840 <draw_all>
 800d1da:	bf00      	nop

0800d1dc <NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 800d1dc:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800d1e0:	4905      	ldr	r1, [pc, #20]	@ (800d1f8 <NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800d1e2:	4b06      	ldr	r3, [pc, #24]	@ (800d1fc <NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800d1e4:	68ca      	ldr	r2, [r1, #12]
 800d1e6:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800d1ea:	4313      	orrs	r3, r2
 800d1ec:	60cb      	str	r3, [r1, #12]
 800d1ee:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 800d1f2:	bf00      	nop
  while(1) { __NOP(); }                                             /* wait until reset */
 800d1f4:	e7fd      	b.n	800d1f2 <NVIC_SystemReset+0x16>
 800d1f6:	bf00      	nop
 800d1f8:	e000ed00 	.word	0xe000ed00
 800d1fc:	05fa0004 	.word	0x05fa0004

0800d200 <get_buttons>:
// Icons for UI
#include "icons_menu.c"

static uint16_t get_buttons(void)
{
  uint16_t cur_button = READ_BUTTONS();
 800d200:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 800d204:	6918      	ldr	r0, [r3, #16]
#ifdef __FLIP_DISPLAY__
  // swap bits in byte (swap leveler left and right bits for rotated display)
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY) && (((cur_button >> GPIOA_LEVER1) ^ (cur_button >> GPIOA_LEVER2)) & 1))
 800d206:	4b07      	ldr	r3, [pc, #28]	@ (800d224 <get_buttons+0x24>)
 800d208:	8a9b      	ldrh	r3, [r3, #20]
 800d20a:	069b      	lsls	r3, r3, #26
  uint16_t cur_button = READ_BUTTONS();
 800d20c:	f000 000e 	and.w	r0, r0, #14
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY) && (((cur_button >> GPIOA_LEVER1) ^ (cur_button >> GPIOA_LEVER2)) & 1))
 800d210:	d507      	bpl.n	800d222 <get_buttons+0x22>
 800d212:	f3c0 0340 	ubfx	r3, r0, #1, #1
 800d216:	ea83 03d0 	eor.w	r3, r3, r0, lsr #3
 800d21a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800d21e:	ea80 0043 	eor.w	r0, r0, r3, lsl #1
    cur_button ^= (1 << GPIOA_LEVER1) | (1 << GPIOA_LEVER2);
#endif
  return cur_button;
}
 800d222:	4770      	bx	lr
 800d224:	20000318 	.word	0x20000318

0800d228 <touch_position>:
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
  getTouchPoint(x2, y2, "LOWER RIGHT", &config._touch_cal[p2]);
}

static void touch_position(int *x, int *y)
{
 800d228:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef __REMOTE_DESKTOP__
  if (touch_remote != REMOTE_NONE)
  {
    *x = last_touch_x;
 800d22a:	4b1d      	ldr	r3, [pc, #116]	@ (800d2a0 <touch_position+0x78>)
  if (touch_remote != REMOTE_NONE)
 800d22c:	4c1d      	ldr	r4, [pc, #116]	@ (800d2a4 <touch_position+0x7c>)
    *x = last_touch_x;
 800d22e:	f9b3 2000 	ldrsh.w	r2, [r3]
  if (touch_remote != REMOTE_NONE)
 800d232:	7824      	ldrb	r4, [r4, #0]
    *y = last_touch_y;
 800d234:	4b1c      	ldr	r3, [pc, #112]	@ (800d2a8 <touch_position+0x80>)
 800d236:	f9b3 3000 	ldrsh.w	r3, [r3]
  if (touch_remote != REMOTE_NONE)
 800d23a:	bb6c      	cbnz	r4, 800d298 <touch_position+0x70>
    return;
  }
#endif
  int tx, ty;
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800d23c:	4c1b      	ldr	r4, [pc, #108]	@ (800d2ac <touch_position+0x84>)
 800d23e:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
  if (tx < 0)
    tx = 0;
  else if (tx >= LCD_WIDTH)
    tx = LCD_WIDTH - 1;
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800d242:	f9b4 700e 	ldrsh.w	r7, [r4, #14]
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800d246:	1b92      	subs	r2, r2, r6
 800d248:	f240 15bf 	movw	r5, #447	@ 0x1bf
 800d24c:	436a      	muls	r2, r5
 800d24e:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800d252:	1bdb      	subs	r3, r3, r7
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800d254:	1bad      	subs	r5, r5, r6
 800d256:	fb92 f2f5 	sdiv	r2, r2, r5
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800d25a:	f240 151f 	movw	r5, #287	@ 0x11f
 800d25e:	436b      	muls	r3, r5
 800d260:	f9b4 5012 	ldrsh.w	r5, [r4, #18]
  if (ty < 0)
    ty = 0;
  else if (ty >= LCD_HEIGHT)
    ty = LCD_HEIGHT - 1;
#ifdef __FLIP_DISPLAY__
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 800d264:	8aa4      	ldrh	r4, [r4, #20]
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800d266:	3210      	adds	r2, #16
  else if (tx >= LCD_WIDTH)
 800d268:	f240 16df 	movw	r6, #479	@ 0x1df
 800d26c:	42b2      	cmp	r2, r6
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800d26e:	eba5 0507 	sub.w	r5, r5, r7
 800d272:	fb93 f3f5 	sdiv	r3, r3, r5
  else if (ty >= LCD_HEIGHT)
 800d276:	f240 153f 	movw	r5, #319	@ 0x13f
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800d27a:	f103 0310 	add.w	r3, r3, #16
  else if (tx >= LCD_WIDTH)
 800d27e:	bfa8      	it	ge
 800d280:	4632      	movge	r2, r6
  else if (ty >= LCD_HEIGHT)
 800d282:	42ab      	cmp	r3, r5
 800d284:	bfa8      	it	ge
 800d286:	462b      	movge	r3, r5
  if (tx < 0)
 800d288:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 800d28c:	06a4      	lsls	r4, r4, #26
  if (ty < 0)
 800d28e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  {
    tx = LCD_WIDTH - 1 - tx;
 800d292:	bf44      	itt	mi
 800d294:	1ab2      	submi	r2, r6, r2
    ty = LCD_HEIGHT - 1 - ty;
 800d296:	1aeb      	submi	r3, r5, r3
    *x = last_touch_x;
 800d298:	6002      	str	r2, [r0, #0]
    *y = last_touch_y;
 800d29a:	600b      	str	r3, [r1, #0]
  }
#endif
  *x = tx;
  *y = ty;
}
 800d29c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d29e:	bf00      	nop
 800d2a0:	200089de 	.word	0x200089de
 800d2a4:	200089bc 	.word	0x200089bc
 800d2a8:	200089dc 	.word	0x200089dc
 800d2ac:	20000318 	.word	0x20000318

0800d2b0 <menu_reboot_cb>:
  (void)data;
  ui_enter_dfu();
}

static UI_FUNCTION_CALLBACK(menu_reboot_cb)
{
 800d2b0:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 800d2b2:	b672      	cpsid	i
  chSysDisable(); // optional
  NVIC_SystemReset();
 800d2b4:	f7ff ff92 	bl	800d1dc <NVIC_SystemReset>

0800d2b8 <menu_measure_cb>:
}

static UI_FUNCTION_CALLBACK(menu_measure_cb)
{

  HB9II_mode = 2;
 800d2b8:	4b01      	ldr	r3, [pc, #4]	@ (800d2c0 <menu_measure_cb+0x8>)
 800d2ba:	2202      	movs	r2, #2
 800d2bc:	601a      	str	r2, [r3, #0]

  // (void)data;
  // menu_push_submenu(menu_measure_list[current_props._measure]);
}
 800d2be:	4770      	bx	lr
 800d2c0:	200068ac 	.word	0x200068ac

0800d2c4 <browser_get_button_pos>:
  // File button, only size and start position, must be idx = FILE_BUTTON_FILE
  [FILE_BUTTON_FILE] = {                              0,                               0,           LCD_WIDTH/FILES_COLUMNS, FILE_BUTTON_HEIGHT,                                   FONT_WIDTH/2 + 3},
};

static void browser_get_button_pos(int idx, browser_btn_t *b) {
  int n = idx >= FILE_BUTTON_FILE ? FILE_BUTTON_FILE : idx;
 800d2c4:	2804      	cmp	r0, #4
 800d2c6:	4602      	mov	r2, r0
#if 0
  memcpy(b, &browser_btn[n], sizeof(browser_btn_t));
#else
  b->x = browser_btn[n].x;
 800d2c8:	4b0f      	ldr	r3, [pc, #60]	@ (800d308 <browser_get_button_pos+0x44>)
  int n = idx >= FILE_BUTTON_FILE ? FILE_BUTTON_FILE : idx;
 800d2ca:	bfa8      	it	ge
 800d2cc:	2204      	movge	r2, #4
static void browser_get_button_pos(int idx, browser_btn_t *b) {
 800d2ce:	b5f0      	push	{r4, r5, r6, r7, lr}
  b->x = browser_btn[n].x;
 800d2d0:	f833 6032 	ldrh.w	r6, [r3, r2, lsl #3]
 800d2d4:	800e      	strh	r6, [r1, #0]
  b->y = browser_btn[n].y;
 800d2d6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  b->w = browser_btn[n].w;
  b->h = browser_btn[n].h;
  b->ofs = browser_btn[n].ofs;
#endif
  if (idx > FILE_BUTTON_FILE) { // for file buttons use multiplier from start offset
 800d2da:	2804      	cmp	r0, #4
  b->y = browser_btn[n].y;
 800d2dc:	885a      	ldrh	r2, [r3, #2]
  b->w = browser_btn[n].w;
 800d2de:	889c      	ldrh	r4, [r3, #4]
  b->y = browser_btn[n].y;
 800d2e0:	804a      	strh	r2, [r1, #2]
  b->w = browser_btn[n].w;
 800d2e2:	808c      	strh	r4, [r1, #4]
  b->h = browser_btn[n].h;
 800d2e4:	799f      	ldrb	r7, [r3, #6]
 800d2e6:	88db      	ldrh	r3, [r3, #6]
 800d2e8:	80cb      	strh	r3, [r1, #6]
  if (idx > FILE_BUTTON_FILE) { // for file buttons use multiplier from start offset
 800d2ea:	dd0c      	ble.n	800d306 <browser_get_button_pos+0x42>
    idx-= FILE_BUTTON_FILE;
 800d2ec:	3804      	subs	r0, #4
    b->x+= b->w * (idx / FILES_ROWS);
 800d2ee:	250a      	movs	r5, #10
 800d2f0:	fbb0 f3f5 	udiv	r3, r0, r5
    b->y+= b->h * (idx % FILES_ROWS);
 800d2f4:	fb05 0013 	mls	r0, r5, r3, r0
 800d2f8:	fb10 f007 	smulbb	r0, r0, r7
    b->x+= b->w * (idx / FILES_ROWS);
 800d2fc:	fb13 6404 	smlabb	r4, r3, r4, r6
    b->y+= b->h * (idx % FILES_ROWS);
 800d300:	4402      	add	r2, r0
    b->x+= b->w * (idx / FILES_ROWS);
 800d302:	800c      	strh	r4, [r1, #0]
    b->y+= b->h * (idx % FILES_ROWS);
 800d304:	804a      	strh	r2, [r1, #2]
  }
}
 800d306:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d308:	08014ba8 	.word	0x08014ba8

0800d30c <browser_get_max>:
  }
}

static int browser_get_max(void) {
  // get max buttons depend from page and file count
  int max = current_page == page_count ? (file_count % FILES_PER_PAGE) : FILES_PER_PAGE;
 800d30c:	4b0a      	ldr	r3, [pc, #40]	@ (800d338 <browser_get_max+0x2c>)
 800d30e:	881a      	ldrh	r2, [r3, #0]
 800d310:	4b0a      	ldr	r3, [pc, #40]	@ (800d33c <browser_get_max+0x30>)
 800d312:	881b      	ldrh	r3, [r3, #0]
 800d314:	429a      	cmp	r2, r3
 800d316:	d10c      	bne.n	800d332 <browser_get_max+0x26>
 800d318:	4b09      	ldr	r3, [pc, #36]	@ (800d340 <browser_get_max+0x34>)
 800d31a:	8818      	ldrh	r0, [r3, #0]
  if (file_count > 0 && max == 0) max = FILES_PER_PAGE;
 800d31c:	b150      	cbz	r0, 800d334 <browser_get_max+0x28>
  int max = current_page == page_count ? (file_count % FILES_PER_PAGE) : FILES_PER_PAGE;
 800d31e:	231e      	movs	r3, #30
 800d320:	fbb0 f2f3 	udiv	r2, r0, r3
 800d324:	fb03 0012 	mls	r0, r3, r2, r0
 800d328:	b280      	uxth	r0, r0
 800d32a:	2800      	cmp	r0, #0
 800d32c:	bf08      	it	eq
 800d32e:	4618      	moveq	r0, r3
 800d330:	e000      	b.n	800d334 <browser_get_max+0x28>
  if (file_count > 0 && max == 0) max = FILES_PER_PAGE;
 800d332:	201e      	movs	r0, #30
  return max + FILE_BUTTON_FILE - 1;
}
 800d334:	3003      	adds	r0, #3
 800d336:	4770      	bx	lr
 800d338:	200089ac 	.word	0x200089ac
 800d33c:	200089ae 	.word	0x200089ae
 800d340:	200089b0 	.word	0x200089b0

0800d344 <ui_keyboard_cb>:
};

// Keyboard callback function for UI button
void ui_keyboard_cb(uint16_t data, button_t *b)
{
  const keyboard_cb_t cb = keypads_mode_tbl[data].cb;
 800d344:	4b04      	ldr	r3, [pc, #16]	@ (800d358 <ui_keyboard_cb+0x14>)
 800d346:	220a      	movs	r2, #10
 800d348:	fb02 3000 	mla	r0, r2, r0, r3
 800d34c:	f8d0 3006 	ldr.w	r3, [r0, #6]
  if (cb)
 800d350:	b10b      	cbz	r3, 800d356 <ui_keyboard_cb+0x12>
    cb(keypads_mode_tbl[data].data, b);
 800d352:	7840      	ldrb	r0, [r0, #1]
 800d354:	4718      	bx	r3
}
 800d356:	4770      	bx	lr
 800d358:	080148a8 	.word	0x080148a8

0800d35c <period_pos>:
}

static int period_pos(void)
{
  int j;
  for (j = 0; kp_buf[j] && kp_buf[j] != '.'; j++)
 800d35c:	4b04      	ldr	r3, [pc, #16]	@ (800d370 <period_pos+0x14>)
 800d35e:	2000      	movs	r0, #0
 800d360:	f813 2b01 	ldrb.w	r2, [r3], #1
 800d364:	b11a      	cbz	r2, 800d36e <period_pos+0x12>
 800d366:	2a2e      	cmp	r2, #46	@ 0x2e
 800d368:	d001      	beq.n	800d36e <period_pos+0x12>
 800d36a:	3001      	adds	r0, #1
 800d36c:	e7f8      	b.n	800d360 <period_pos+0x4>
    ;
  return j;
}
 800d36e:	4770      	bx	lr
 800d370:	200089c8 	.word	0x200089c8

0800d374 <step_round>:

// ex. 10942 -> 10000
//      6791 ->  5000
//       341 ->   200
static freq_t step_round(freq_t v)
{
 800d374:	4603      	mov	r3, r0
  // decade step
  freq_t nx, x = 1;
 800d376:	2201      	movs	r2, #1
  while ((nx = x * 10) < v)
 800d378:	210a      	movs	r1, #10
 800d37a:	4610      	mov	r0, r2
 800d37c:	434a      	muls	r2, r1
 800d37e:	429a      	cmp	r2, r3
 800d380:	d3fb      	bcc.n	800d37a <step_round+0x6>
    x = nx;
  // 1-2-5 step
  if (x * 2 > v)
 800d382:	ebb3 0f40 	cmp.w	r3, r0, lsl #1
 800d386:	ea4f 0240 	mov.w	r2, r0, lsl #1
 800d38a:	d304      	bcc.n	800d396 <step_round+0x22>
    return x;
  if (x * 5 > v)
 800d38c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    return x * 2;
 800d390:	4298      	cmp	r0, r3
 800d392:	bf88      	it	hi
 800d394:	4610      	movhi	r0, r2
  return x * 5;
}
 800d396:	4770      	bx	lr

0800d398 <touch_stop_watchdog>:
  if (!(touch_status_flag & TOUCH_INTERRUPT_ENABLED))
 800d398:	4a04      	ldr	r2, [pc, #16]	@ (800d3ac <touch_stop_watchdog+0x14>)
 800d39a:	7813      	ldrb	r3, [r2, #0]
 800d39c:	07d9      	lsls	r1, r3, #31
 800d39e:	d504      	bpl.n	800d3aa <touch_stop_watchdog+0x12>
  touch_status_flag ^= TOUCH_INTERRUPT_ENABLED;
 800d3a0:	f083 0301 	eor.w	r3, r3, #1
 800d3a4:	7013      	strb	r3, [r2, #0]
  adc_stop_analog_watchdog();
 800d3a6:	f003 bbf9 	b.w	8010b9c <adc_stop_analog_watchdog>
}
 800d3aa:	4770      	bx	lr
 800d3ac:	200089e1 	.word	0x200089e1

0800d3b0 <touch_prepare_sense>:
{
 800d3b0:	b510      	push	{r4, lr}
  palSetPadMode(GPIOB, GPIOB_YN, PAL_MODE_INPUT);          // Hi-z mode
 800d3b2:	480f      	ldr	r0, [pc, #60]	@ (800d3f0 <touch_prepare_sense+0x40>)
 800d3b4:	2200      	movs	r2, #0
 800d3b6:	2101      	movs	r1, #1
 800d3b8:	f003 fe2c 	bl	8011014 <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_YP, PAL_MODE_INPUT_PULLDOWN); // Use pull
 800d3bc:	2240      	movs	r2, #64	@ 0x40
 800d3be:	2107      	movs	r1, #7
 800d3c0:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800d3c4:	f003 fe26 	bl	8011014 <palSetPadMode>
  palSetPad(GPIOB, GPIOB_XN);
 800d3c8:	4b09      	ldr	r3, [pc, #36]	@ (800d3f0 <touch_prepare_sense+0x40>)
  palSetPadMode(GPIOB, GPIOB_XN, PAL_MODE_OUTPUT_PUSHPULL);
 800d3ca:	4809      	ldr	r0, [pc, #36]	@ (800d3f0 <touch_prepare_sense+0x40>)
  palSetPad(GPIOB, GPIOB_XN);
 800d3cc:	2401      	movs	r4, #1
  palSetPad(GPIOA, GPIOA_XP);
 800d3ce:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
  palSetPad(GPIOB, GPIOB_XN);
 800d3d2:	619c      	str	r4, [r3, #24]
  palSetPad(GPIOA, GPIOA_XP);
 800d3d4:	2340      	movs	r3, #64	@ 0x40
 800d3d6:	6193      	str	r3, [r2, #24]
  palSetPadMode(GPIOB, GPIOB_XN, PAL_MODE_OUTPUT_PUSHPULL);
 800d3d8:	2100      	movs	r1, #0
 800d3da:	4622      	mov	r2, r4
 800d3dc:	f003 fe1a 	bl	8011014 <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_XP, PAL_MODE_OUTPUT_PUSHPULL);
 800d3e0:	4622      	mov	r2, r4
 800d3e2:	2106      	movs	r1, #6
}
 800d3e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  palSetPadMode(GPIOA, GPIOA_XP, PAL_MODE_OUTPUT_PUSHPULL);
 800d3e8:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800d3ec:	f003 be12 	b.w	8011014 <palSetPadMode>
 800d3f0:	48000400 	.word	0x48000400

0800d3f4 <touch_measure_y>:
{
 800d3f4:	b508      	push	{r3, lr}
  palClearPad(GPIOB, GPIOB_XN);
 800d3f6:	4b07      	ldr	r3, [pc, #28]	@ (800d414 <touch_measure_y+0x20>)
 800d3f8:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800d3fc:	619a      	str	r2, [r3, #24]
  palSetPadMode(GPIOA, GPIOA_YP, PAL_MODE_INPUT_ANALOG); // <- ADC_TOUCH_Y channel
 800d3fe:	2107      	movs	r1, #7
 800d400:	f640 0203 	movw	r2, #2051	@ 0x803
 800d404:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800d408:	f003 fe04 	bl	8011014 <palSetPadMode>
  return adc_single_read(ADC_TOUCH_Y);
 800d40c:	2004      	movs	r0, #4
 800d40e:	f003 fb4d 	bl	8010aac <adc_single_read>
}
 800d412:	bd08      	pop	{r3, pc}
 800d414:	48000400 	.word	0x48000400

0800d418 <touch_measure_x>:
  palSetPad(GPIOB, GPIOB_YN);
 800d418:	4a11      	ldr	r2, [pc, #68]	@ (800d460 <touch_measure_x+0x48>)
  palSetPadMode(GPIOB, GPIOB_YN, PAL_MODE_OUTPUT_PUSHPULL);
 800d41a:	4811      	ldr	r0, [pc, #68]	@ (800d460 <touch_measure_x+0x48>)
{
 800d41c:	b508      	push	{r3, lr}
  palSetPad(GPIOB, GPIOB_YN);
 800d41e:	2302      	movs	r3, #2
 800d420:	6193      	str	r3, [r2, #24]
  palClearPad(GPIOA, GPIOA_YP);
 800d422:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
 800d426:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
 800d42a:	6193      	str	r3, [r2, #24]
  palSetPadMode(GPIOB, GPIOB_YN, PAL_MODE_OUTPUT_PUSHPULL);
 800d42c:	2201      	movs	r2, #1
 800d42e:	4611      	mov	r1, r2
 800d430:	f003 fdf0 	bl	8011014 <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_YP, PAL_MODE_OUTPUT_PUSHPULL);
 800d434:	2201      	movs	r2, #1
 800d436:	2107      	movs	r1, #7
 800d438:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800d43c:	f003 fdea 	bl	8011014 <palSetPadMode>
  palSetPadMode(GPIOB, GPIOB_XN, PAL_MODE_INPUT);        // Hi-z mode
 800d440:	2200      	movs	r2, #0
 800d442:	4611      	mov	r1, r2
 800d444:	4806      	ldr	r0, [pc, #24]	@ (800d460 <touch_measure_x+0x48>)
 800d446:	f003 fde5 	bl	8011014 <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_XP, PAL_MODE_INPUT_ANALOG); // <- ADC_TOUCH_X channel
 800d44a:	f640 0203 	movw	r2, #2051	@ 0x803
 800d44e:	2106      	movs	r1, #6
 800d450:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800d454:	f003 fdde 	bl	8011014 <palSetPadMode>
  return adc_single_read(ADC_TOUCH_X);
 800d458:	2003      	movs	r0, #3
 800d45a:	f003 fb27 	bl	8010aac <adc_single_read>
}
 800d45e:	bd08      	pop	{r3, pc}
 800d460:	48000400 	.word	0x48000400

0800d464 <touch_status>:
{
 800d464:	b508      	push	{r3, lr}
  return adc_single_read(ADC_TOUCH_Y) > TOUCH_THRESHOLD;
 800d466:	2004      	movs	r0, #4
 800d468:	f003 fb20 	bl	8010aac <adc_single_read>
}
 800d46c:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
 800d470:	bf94      	ite	ls
 800d472:	2000      	movls	r0, #0
 800d474:	2001      	movhi	r0, #1
 800d476:	bd08      	pop	{r3, pc}

0800d478 <touch_check>:
{
 800d478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  touch_stop_watchdog();
 800d47a:	f7ff ff8d 	bl	800d398 <touch_stop_watchdog>
  int stat = touch_status();
 800d47e:	f7ff fff1 	bl	800d464 <touch_status>
  if (stat)
 800d482:	4f11      	ldr	r7, [pc, #68]	@ (800d4c8 <touch_check+0x50>)
 800d484:	b190      	cbz	r0, 800d4ac <touch_check+0x34>
 800d486:	4604      	mov	r4, r0
    int y = touch_measure_y();
 800d488:	f7ff ffb4 	bl	800d3f4 <touch_measure_y>
 800d48c:	4605      	mov	r5, r0
    int x = touch_measure_x();
 800d48e:	f7ff ffc3 	bl	800d418 <touch_measure_x>
 800d492:	4606      	mov	r6, r0
    touch_prepare_sense();
 800d494:	f7ff ff8c 	bl	800d3b0 <touch_prepare_sense>
    if (touch_status())
 800d498:	f7ff ffe4 	bl	800d464 <touch_status>
 800d49c:	b118      	cbz	r0, 800d4a6 <touch_check+0x2e>
      last_touch_x = x;
 800d49e:	4b0b      	ldr	r3, [pc, #44]	@ (800d4cc <touch_check+0x54>)
 800d4a0:	801e      	strh	r6, [r3, #0]
      last_touch_y = y;
 800d4a2:	4b0b      	ldr	r3, [pc, #44]	@ (800d4d0 <touch_check+0x58>)
 800d4a4:	801d      	strh	r5, [r3, #0]
    touch_remote = REMOTE_NONE;
 800d4a6:	2300      	movs	r3, #0
 800d4a8:	703b      	strb	r3, [r7, #0]
 800d4aa:	e003      	b.n	800d4b4 <touch_check+0x3c>
    stat = touch_remote == REMOTE_PRESS;
 800d4ac:	783c      	ldrb	r4, [r7, #0]
 800d4ae:	1e63      	subs	r3, r4, #1
 800d4b0:	425c      	negs	r4, r3
 800d4b2:	415c      	adcs	r4, r3
  if (stat != last_touch_status)
 800d4b4:	4b07      	ldr	r3, [pc, #28]	@ (800d4d4 <touch_check+0x5c>)
 800d4b6:	781a      	ldrb	r2, [r3, #0]
 800d4b8:	42a2      	cmp	r2, r4
    last_touch_status = stat;
 800d4ba:	bf1c      	itt	ne
 800d4bc:	701c      	strbne	r4, [r3, #0]
    return stat ? EVT_TOUCH_PRESSED : EVT_TOUCH_RELEASED;
 800d4be:	f1c4 0403 	rsbne	r4, r4, #3
}
 800d4c2:	4620      	mov	r0, r4
 800d4c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d4c6:	bf00      	nop
 800d4c8:	200089bc 	.word	0x200089bc
 800d4cc:	200089de 	.word	0x200089de
 800d4d0:	200089dc 	.word	0x200089dc
 800d4d4:	200089e0 	.word	0x200089e0

0800d4d8 <touch_wait_release>:
{
 800d4d8:	b508      	push	{r3, lr}
  while (touch_check() != EVT_TOUCH_RELEASED)
 800d4da:	f7ff ffcd 	bl	800d478 <touch_check>
 800d4de:	2803      	cmp	r0, #3
 800d4e0:	d1fb      	bne.n	800d4da <touch_wait_release+0x2>
}
 800d4e2:	bd08      	pop	{r3, pc}

0800d4e4 <select_lever_mode>:
{
 800d4e4:	b508      	push	{r3, lr}
  if (lever_mode == mode)
 800d4e6:	4b06      	ldr	r3, [pc, #24]	@ (800d500 <select_lever_mode+0x1c>)
 800d4e8:	7f1a      	ldrb	r2, [r3, #28]
 800d4ea:	4282      	cmp	r2, r0
 800d4ec:	d006      	beq.n	800d4fc <select_lever_mode+0x18>
  lever_mode = mode;
 800d4ee:	7718      	strb	r0, [r3, #28]
  request_to_redraw(REDRAW_BACKUP | REDRAW_FREQUENCY | REDRAW_MARKER);
 800d4f0:	f44f 6085 	mov.w	r0, #1064	@ 0x428
 800d4f4:	f7fe f97c 	bl	800b7f0 <request_to_redraw>
  return true;
 800d4f8:	2001      	movs	r0, #1
 800d4fa:	e000      	b.n	800d4fe <select_lever_mode+0x1a>
    return false;
 800d4fc:	2000      	movs	r0, #0
}
 800d4fe:	bd08      	pop	{r3, pc}
 800d500:	20000318 	.word	0x20000318

0800d504 <btn_check>:
{
 800d504:	b538      	push	{r3, r4, r5, lr}
    if (ticks - last_button_down_ticks > BUTTON_DEBOUNCE_TICKS)
 800d506:	4c10      	ldr	r4, [pc, #64]	@ (800d548 <btn_check+0x44>)
 800d508:	f04f 4580 	mov.w	r5, #1073741824	@ 0x40000000
 800d50c:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 800d50e:	6823      	ldr	r3, [r4, #0]
 800d510:	1acb      	subs	r3, r1, r3
 800d512:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 800d516:	d803      	bhi.n	800d520 <btn_check+0x1c>
    chThdSleepMilliseconds(2);
 800d518:	20c8      	movs	r0, #200	@ 0xc8
 800d51a:	f7f3 fcb9 	bl	8000e90 <chThdSleep>
    ticks = chVTGetSystemTimeX();
 800d51e:	e7f5      	b.n	800d50c <btn_check+0x8>
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800d520:	4a0a      	ldr	r2, [pc, #40]	@ (800d54c <btn_check+0x48>)
  uint16_t cur_button = get_buttons();
 800d522:	f7ff fe6d 	bl	800d200 <get_buttons>
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800d526:	8813      	ldrh	r3, [r2, #0]
  last_button = cur_button;
 800d528:	8010      	strh	r0, [r2, #0]
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800d52a:	ea20 0303 	bic.w	r3, r0, r3
  if (button_set & BUTTON_PUSH)
 800d52e:	f3c3 0080 	ubfx	r0, r3, #2, #1
  if (button_set & BUTTON_UP)
 800d532:	071a      	lsls	r2, r3, #28
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800d534:	b29d      	uxth	r5, r3
    status |= EVT_UP;
 800d536:	bf48      	it	mi
 800d538:	f040 0010 	orrmi.w	r0, r0, #16
  if (button_set & BUTTON_DOWN)
 800d53c:	07ab      	lsls	r3, r5, #30
  last_button_down_ticks = ticks;
 800d53e:	6021      	str	r1, [r4, #0]
    status |= EVT_DOWN;
 800d540:	bf48      	it	mi
 800d542:	f040 0020 	orrmi.w	r0, r0, #32
}
 800d546:	bd38      	pop	{r3, r4, r5, pc}
 800d548:	200089e8 	.word	0x200089e8
 800d54c:	200089ec 	.word	0x200089ec

0800d550 <btn_wait_release>:
{
 800d550:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    systime_t dt = ticks - last_button_down_ticks;
 800d554:	4f1e      	ldr	r7, [pc, #120]	@ (800d5d0 <btn_wait_release+0x80>)
    uint16_t changed = last_button ^ cur_button;
 800d556:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 800d5d8 <btn_wait_release+0x88>
        ticks > last_button_repeat_ticks)
 800d55a:	4e1e      	ldr	r6, [pc, #120]	@ (800d5d4 <btn_wait_release+0x84>)
 800d55c:	f04f 4980 	mov.w	r9, #1073741824	@ 0x40000000
    chThdSleepMilliseconds(10);
 800d560:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800d564:	f8d9 4024 	ldr.w	r4, [r9, #36]	@ 0x24
    systime_t dt = ticks - last_button_down_ticks;
 800d568:	683d      	ldr	r5, [r7, #0]
    chThdSleepMilliseconds(10);
 800d56a:	f7f3 fc91 	bl	8000e90 <chThdSleep>
    uint16_t cur_button = get_buttons();
 800d56e:	f7ff fe47 	bl	800d200 <get_buttons>
    uint16_t changed = last_button ^ cur_button;
 800d572:	f8b8 1000 	ldrh.w	r1, [r8]
    systime_t dt = ticks - last_button_down_ticks;
 800d576:	1b65      	subs	r5, r4, r5
    uint16_t changed = last_button ^ cur_button;
 800d578:	ea81 0300 	eor.w	r3, r1, r0
    uint16_t cur_button = get_buttons();
 800d57c:	4602      	mov	r2, r0
    if (dt >= BUTTON_DOWN_LONG_TICKS && (cur_button & BUTTON_PUSH))
 800d57e:	f24c 304f 	movw	r0, #49999	@ 0xc34f
 800d582:	4285      	cmp	r5, r0
    uint16_t changed = last_button ^ cur_button;
 800d584:	b29b      	uxth	r3, r3
    if (dt >= BUTTON_DOWN_LONG_TICKS && (cur_button & BUTTON_PUSH))
 800d586:	d901      	bls.n	800d58c <btn_wait_release+0x3c>
 800d588:	0750      	lsls	r0, r2, #29
 800d58a:	d41b      	bmi.n	800d5c4 <btn_wait_release+0x74>
    if (changed & BUTTON_PUSH) // release
 800d58c:	f013 0004 	ands.w	r0, r3, #4
 800d590:	d11a      	bne.n	800d5c8 <btn_wait_release+0x78>
    if (changed)
 800d592:	4291      	cmp	r1, r2
 800d594:	d003      	beq.n	800d59e <btn_wait_release+0x4e>
      last_button = cur_button;
 800d596:	f8a8 2000 	strh.w	r2, [r8]
      last_button_down_ticks = ticks;
 800d59a:	603c      	str	r4, [r7, #0]
      return 0;
 800d59c:	e015      	b.n	800d5ca <btn_wait_release+0x7a>
    if (dt > BUTTON_DOWN_LONG_TICKS &&
 800d59e:	f24c 3350 	movw	r3, #50000	@ 0xc350
 800d5a2:	429d      	cmp	r5, r3
 800d5a4:	d9dc      	bls.n	800d560 <btn_wait_release+0x10>
 800d5a6:	6833      	ldr	r3, [r6, #0]
 800d5a8:	42a3      	cmp	r3, r4
 800d5aa:	d2d9      	bcs.n	800d560 <btn_wait_release+0x10>
        status |= EVT_DOWN | EVT_REPEAT;
 800d5ac:	f011 0002 	ands.w	r0, r1, #2
 800d5b0:	bf18      	it	ne
 800d5b2:	2060      	movne	r0, #96	@ 0x60
      last_button_repeat_ticks = ticks + BUTTON_REPEAT_TICKS;
 800d5b4:	f604 34b8 	addw	r4, r4, #3000	@ 0xbb8
      if (cur_button & BUTTON_UP)
 800d5b8:	070b      	lsls	r3, r1, #28
        status |= EVT_UP | EVT_REPEAT;
 800d5ba:	bf48      	it	mi
 800d5bc:	f040 0050 	orrmi.w	r0, r0, #80	@ 0x50
      last_button_repeat_ticks = ticks + BUTTON_REPEAT_TICKS;
 800d5c0:	6034      	str	r4, [r6, #0]
      return status;
 800d5c2:	e002      	b.n	800d5ca <btn_wait_release+0x7a>
      return EVT_BUTTON_DOWN_LONG;
 800d5c4:	2004      	movs	r0, #4
 800d5c6:	e000      	b.n	800d5ca <btn_wait_release+0x7a>
      return EVT_BUTTON_SINGLE_CLICK;
 800d5c8:	2001      	movs	r0, #1
}
 800d5ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d5ce:	bf00      	nop
 800d5d0:	200089e8 	.word	0x200089e8
 800d5d4:	200089e4 	.word	0x200089e4
 800d5d8:	200089ec 	.word	0x200089ec

0800d5dc <ui_draw_button>:
{
 800d5dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d5e0:	f8dd a020 	ldr.w	sl, [sp, #32]
  uint16_t type = b->border;
 800d5e4:	f89a 7002 	ldrb.w	r7, [sl, #2]
  if (bw)
 800d5e8:	f017 0407 	ands.w	r4, r7, #7
{
 800d5ec:	4605      	mov	r5, r0
 800d5ee:	460e      	mov	r6, r1
 800d5f0:	4690      	mov	r8, r2
 800d5f2:	4699      	mov	r9, r3
  if (bw)
 800d5f4:	d037      	beq.n	800d666 <ui_draw_button+0x8a>
    lcd_set_background(type & BUTTON_BORDER_TOP ? br : bd);
 800d5f6:	f017 0f10 	tst.w	r7, #16
 800d5fa:	bf0c      	ite	eq
 800d5fc:	2010      	moveq	r0, #16
 800d5fe:	200f      	movne	r0, #15
 800d600:	f002 fd72 	bl	80100e8 <lcd_set_background>
    lcd_fill(x, y, w, bw); // top
 800d604:	4628      	mov	r0, r5
 800d606:	4623      	mov	r3, r4
 800d608:	4642      	mov	r2, r8
 800d60a:	4631      	mov	r1, r6
 800d60c:	f002 fc72 	bl	800fef4 <lcd_fill>
    lcd_set_background(type & BUTTON_BORDER_LEFT ? br : bd);
 800d610:	f017 0f40 	tst.w	r7, #64	@ 0x40
 800d614:	bf0c      	ite	eq
 800d616:	2010      	moveq	r0, #16
 800d618:	200f      	movne	r0, #15
 800d61a:	f002 fd65 	bl	80100e8 <lcd_set_background>
    lcd_fill(x, y, bw, h); // left
 800d61e:	4628      	mov	r0, r5
 800d620:	464b      	mov	r3, r9
 800d622:	4622      	mov	r2, r4
 800d624:	4631      	mov	r1, r6
 800d626:	f002 fc65 	bl	800fef4 <lcd_fill>
    lcd_set_background(type & BUTTON_BORDER_RIGHT ? br : bd);
 800d62a:	f017 0f80 	tst.w	r7, #128	@ 0x80
 800d62e:	bf0c      	ite	eq
 800d630:	2010      	moveq	r0, #16
 800d632:	200f      	movne	r0, #15
 800d634:	f002 fd58 	bl	80100e8 <lcd_set_background>
    lcd_fill(x + w - bw, y, bw, h); // right
 800d638:	eb05 0008 	add.w	r0, r5, r8
 800d63c:	1b00      	subs	r0, r0, r4
 800d63e:	464b      	mov	r3, r9
 800d640:	4622      	mov	r2, r4
 800d642:	4631      	mov	r1, r6
 800d644:	f002 fc56 	bl	800fef4 <lcd_fill>
    lcd_set_background(type & BUTTON_BORDER_BOTTOM ? br : bd);
 800d648:	f017 0f20 	tst.w	r7, #32
 800d64c:	bf0c      	ite	eq
 800d64e:	2010      	moveq	r0, #16
 800d650:	200f      	movne	r0, #15
 800d652:	f002 fd49 	bl	80100e8 <lcd_set_background>
    lcd_fill(x, y + h - bw, w, bw); // bottom
 800d656:	eb06 0109 	add.w	r1, r6, r9
 800d65a:	4623      	mov	r3, r4
 800d65c:	4642      	mov	r2, r8
 800d65e:	1b09      	subs	r1, r1, r4
 800d660:	4628      	mov	r0, r5
 800d662:	f002 fc47 	bl	800fef4 <lcd_fill>
  lcd_set_colors(b->fg, b->bg);
 800d666:	f89a 1000 	ldrb.w	r1, [sl]
 800d66a:	f89a 0001 	ldrb.w	r0, [sl, #1]
 800d66e:	f002 fd47 	bl	8010100 <lcd_set_colors>
  if (type & BUTTON_BORDER_NO_FILL)
 800d672:	073b      	lsls	r3, r7, #28
 800d674:	d409      	bmi.n	800d68a <ui_draw_button+0xae>
  lcd_fill(x + bw, y + bw, w - (bw * 2), h - (bw * 2));
 800d676:	eba9 0344 	sub.w	r3, r9, r4, lsl #1
 800d67a:	eba8 0244 	sub.w	r2, r8, r4, lsl #1
 800d67e:	1931      	adds	r1, r6, r4
 800d680:	1928      	adds	r0, r5, r4
}
 800d682:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  lcd_fill(x + bw, y + bw, w - (bw * 2), h - (bw * 2));
 800d686:	f002 bc35 	b.w	800fef4 <lcd_fill>
}
 800d68a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

0800d690 <browser_draw_button>:
static void browser_draw_button(int idx, const char *txt) {
 800d690:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (idx < 0) return;
 800d692:	1e04      	subs	r4, r0, #0
static void browser_draw_button(int idx, const char *txt) {
 800d694:	b08f      	sub	sp, #60	@ 0x3c
  if (idx < 0) return;
 800d696:	db3f      	blt.n	800d718 <browser_draw_button+0x88>
 800d698:	460d      	mov	r5, r1
  browser_get_button_pos(idx, &btn);
 800d69a:	a902      	add	r1, sp, #8
 800d69c:	f7ff fe12 	bl	800d2c4 <browser_get_button_pos>
  b.bg = (idx == FILE_BUTTON_DEL && (browser_mode & BROWSER_DELETE)) ? LCD_LOW_BAT_COLOR : LCD_MENU_COLOR;
 800d6a0:	2c03      	cmp	r4, #3
 800d6a2:	d107      	bne.n	800d6b4 <browser_draw_button+0x24>
 800d6a4:	4b1d      	ldr	r3, [pc, #116]	@ (800d71c <browser_draw_button+0x8c>)
 800d6a6:	881b      	ldrh	r3, [r3, #0]
 800d6a8:	f013 0f01 	tst.w	r3, #1
 800d6ac:	bf14      	ite	ne
 800d6ae:	230d      	movne	r3, #13
 800d6b0:	2303      	moveq	r3, #3
 800d6b2:	e000      	b.n	800d6b6 <browser_draw_button+0x26>
 800d6b4:	2303      	movs	r3, #3
 800d6b6:	f88d 3010 	strb.w	r3, [sp, #16]
  b.fg = LCD_MENU_TEXT_COLOR;
 800d6ba:	2304      	movs	r3, #4
 800d6bc:	f88d 3011 	strb.w	r3, [sp, #17]
  b.border = (idx == selection) ? BROWSER_BUTTON_BORDER|BUTTON_BORDER_FALLING : BROWSER_BUTTON_BORDER|BUTTON_BORDER_RISE;
 800d6c0:	4b17      	ldr	r3, [pc, #92]	@ (800d720 <browser_draw_button+0x90>)
 800d6c2:	f993 3000 	ldrsb.w	r3, [r3]
 800d6c6:	42a3      	cmp	r3, r4
 800d6c8:	bf14      	ite	ne
 800d6ca:	2391      	movne	r3, #145	@ 0x91
 800d6cc:	2361      	moveq	r3, #97	@ 0x61
  if (txt == NULL) b.border|= BUTTON_BORDER_NO_FILL;
 800d6ce:	b90d      	cbnz	r5, 800d6d4 <browser_draw_button+0x44>
 800d6d0:	f043 0308 	orr.w	r3, r3, #8
  ui_draw_button(btn.x, btn.y, btn.w, btn.h, &b);
 800d6d4:	f8bd 6008 	ldrh.w	r6, [sp, #8]
 800d6d8:	f8bd 700a 	ldrh.w	r7, [sp, #10]
 800d6dc:	f89d 400e 	ldrb.w	r4, [sp, #14]
  b.border = (idx == selection) ? BROWSER_BUTTON_BORDER|BUTTON_BORDER_FALLING : BROWSER_BUTTON_BORDER|BUTTON_BORDER_RISE;
 800d6e0:	f88d 3012 	strb.w	r3, [sp, #18]
  ui_draw_button(btn.x, btn.y, btn.w, btn.h, &b);
 800d6e4:	ab04      	add	r3, sp, #16
 800d6e6:	9300      	str	r3, [sp, #0]
 800d6e8:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 800d6ec:	4623      	mov	r3, r4
 800d6ee:	4639      	mov	r1, r7
 800d6f0:	4630      	mov	r0, r6
 800d6f2:	f7ff ff73 	bl	800d5dc <ui_draw_button>
  if (txt) lcd_printf(btn.x + btn.ofs, btn.y + (btn.h - FONT_STR_HEIGHT) / 2, txt);
 800d6f6:	b17d      	cbz	r5, 800d718 <browser_draw_button+0x88>
 800d6f8:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800d6fc:	3c0b      	subs	r4, #11
 800d6fe:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 800d702:	eb07 0164 	add.w	r1, r7, r4, asr #1
 800d706:	18f0      	adds	r0, r6, r3
 800d708:	462a      	mov	r2, r5
 800d70a:	b209      	sxth	r1, r1
 800d70c:	b200      	sxth	r0, r0
}
 800d70e:	b00f      	add	sp, #60	@ 0x3c
 800d710:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  if (txt) lcd_printf(btn.x + btn.ofs, btn.y + (btn.h - FONT_STR_HEIGHT) / 2, txt);
 800d714:	f002 bd84 	b.w	8010220 <lcd_printf>
}
 800d718:	b00f      	add	sp, #60	@ 0x3c
 800d71a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d71c:	200089aa 	.word	0x200089aa
 800d720:	200003f0 	.word	0x200003f0

0800d724 <browser_draw_buttons>:
static void browser_draw_buttons(void) {
 800d724:	b508      	push	{r3, lr}
  browser_draw_button(FILE_BUTTON_DEL, "DEL");
 800d726:	4909      	ldr	r1, [pc, #36]	@ (800d74c <browser_draw_buttons+0x28>)
 800d728:	2003      	movs	r0, #3
 800d72a:	f7ff ffb1 	bl	800d690 <browser_draw_button>
  browser_draw_button(FILE_BUTTON_LEFT,  "<");
 800d72e:	4908      	ldr	r1, [pc, #32]	@ (800d750 <browser_draw_buttons+0x2c>)
 800d730:	2000      	movs	r0, #0
 800d732:	f7ff ffad 	bl	800d690 <browser_draw_button>
  browser_draw_button(FILE_BUTTON_RIGHT, ">");
 800d736:	4907      	ldr	r1, [pc, #28]	@ (800d754 <browser_draw_buttons+0x30>)
 800d738:	2001      	movs	r0, #1
 800d73a:	f7ff ffa9 	bl	800d690 <browser_draw_button>
}
 800d73e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  browser_draw_button(FILE_BUTTON_EXIT,  "X");
 800d742:	4905      	ldr	r1, [pc, #20]	@ (800d758 <browser_draw_buttons+0x34>)
 800d744:	2002      	movs	r0, #2
 800d746:	f7ff bfa3 	b.w	800d690 <browser_draw_button>
 800d74a:	bf00      	nop
 800d74c:	08012b19 	.word	0x08012b19
 800d750:	08012b1d 	.word	0x08012b1d
 800d754:	08012b1f 	.word	0x08012b1f
 800d758:	08012b21 	.word	0x08012b21

0800d75c <getTouchPoint>:
{
 800d75c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d75e:	4606      	mov	r6, r0
 800d760:	460f      	mov	r7, r1
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800d762:	2001      	movs	r0, #1
 800d764:	2100      	movs	r1, #0
{
 800d766:	461c      	mov	r4, r3
 800d768:	4615      	mov	r5, r2
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800d76a:	f002 fcc9 	bl	8010100 <lcd_set_colors>
  lcd_clear_screen();
 800d76e:	f002 fc61 	bl	8010034 <lcd_clear_screen>
  lcd_blitBitmap(x, y, TOUCH_MARK_W, TOUCH_MARK_H, (const uint8_t *)touch_bitmap);
 800d772:	4b0c      	ldr	r3, [pc, #48]	@ (800d7a4 <getTouchPoint+0x48>)
 800d774:	9300      	str	r3, [sp, #0]
 800d776:	2309      	movs	r3, #9
 800d778:	461a      	mov	r2, r3
 800d77a:	4639      	mov	r1, r7
 800d77c:	4630      	mov	r0, r6
 800d77e:	f002 fcd1 	bl	8010124 <lcd_blitBitmap>
  lcd_printf((LCD_WIDTH - FONT_STR_WIDTH(18)) / 2, (LCD_HEIGHT - FONT_GET_HEIGHT) / 2, "TOUCH %s *", name);
 800d782:	462b      	mov	r3, r5
 800d784:	4a08      	ldr	r2, [pc, #32]	@ (800d7a8 <getTouchPoint+0x4c>)
 800d786:	219a      	movs	r1, #154	@ 0x9a
 800d788:	20b1      	movs	r0, #177	@ 0xb1
 800d78a:	f002 fd49 	bl	8010220 <lcd_printf>
  touch_wait_release();
 800d78e:	f7ff fea3 	bl	800d4d8 <touch_wait_release>
  data[0] = last_touch_x;
 800d792:	4b06      	ldr	r3, [pc, #24]	@ (800d7ac <getTouchPoint+0x50>)
 800d794:	881b      	ldrh	r3, [r3, #0]
 800d796:	8023      	strh	r3, [r4, #0]
  data[1] = last_touch_y;
 800d798:	4b05      	ldr	r3, [pc, #20]	@ (800d7b0 <getTouchPoint+0x54>)
 800d79a:	881b      	ldrh	r3, [r3, #0]
 800d79c:	8063      	strh	r3, [r4, #2]
}
 800d79e:	b003      	add	sp, #12
 800d7a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d7a2:	bf00      	nop
 800d7a4:	08014ee4 	.word	0x08014ee4
 800d7a8:	08012b23 	.word	0x08012b23
 800d7ac:	200089de 	.word	0x200089de
 800d7b0:	200089dc 	.word	0x200089dc

0800d7b4 <ui_mode_normal>:
{
 800d7b4:	b510      	push	{r4, lr}
  if (ui_mode == UI_NORMAL)
 800d7b6:	4c0c      	ldr	r4, [pc, #48]	@ (800d7e8 <ui_mode_normal+0x34>)
 800d7b8:	7823      	ldrb	r3, [r4, #0]
 800d7ba:	b1a3      	cbz	r3, 800d7e6 <ui_mode_normal+0x32>
  set_area_size(AREA_WIDTH_NORMAL, AREA_HEIGHT_NORMAL);
 800d7bc:	f240 1131 	movw	r1, #305	@ 0x131
 800d7c0:	f240 10d1 	movw	r0, #465	@ 0x1d1
 800d7c4:	f7fe f80a 	bl	800b7dc <set_area_size>
  if (ui_mode == UI_MENU)
 800d7c8:	7823      	ldrb	r3, [r4, #0]
 800d7ca:	2b01      	cmp	r3, #1
 800d7cc:	d101      	bne.n	800d7d2 <ui_mode_normal+0x1e>
    request_to_draw_cells_behind_menu();
 800d7ce:	f7fe f817 	bl	800b800 <request_to_draw_cells_behind_menu>
  if (ui_mode == UI_KEYPAD || ui_mode == UI_BROWSER)
 800d7d2:	7823      	ldrb	r3, [r4, #0]
 800d7d4:	3b02      	subs	r3, #2
 800d7d6:	2b01      	cmp	r3, #1
 800d7d8:	d803      	bhi.n	800d7e2 <ui_mode_normal+0x2e>
    request_to_redraw(REDRAW_ALL);
 800d7da:	f240 301a 	movw	r0, #794	@ 0x31a
 800d7de:	f7fe f807 	bl	800b7f0 <request_to_redraw>
  ui_mode = UI_NORMAL;
 800d7e2:	2300      	movs	r3, #0
 800d7e4:	7023      	strb	r3, [r4, #0]
}
 800d7e6:	bd10      	pop	{r4, pc}
 800d7e8:	200089c4 	.word	0x200089c4

0800d7ec <keypad_draw_button>:
  if (id < 0)
 800d7ec:	2800      	cmp	r0, #0
 800d7ee:	db4b      	blt.n	800d888 <keypad_draw_button+0x9c>
{
 800d7f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d7f2:	b08d      	sub	sp, #52	@ 0x34
  button.fg = LCD_MENU_TEXT_COLOR;
 800d7f4:	2304      	movs	r3, #4
 800d7f6:	f88d 3009 	strb.w	r3, [sp, #9]
  if (id == selection)
 800d7fa:	4b24      	ldr	r3, [pc, #144]	@ (800d88c <keypad_draw_button+0xa0>)
  const keypad_pos_t *p = &key_pos[keypads->type];
 800d7fc:	4f24      	ldr	r7, [pc, #144]	@ (800d890 <keypad_draw_button+0xa4>)
  if (id == selection)
 800d7fe:	f993 3000 	ldrsb.w	r3, [r3]
 800d802:	4283      	cmp	r3, r0
 800d804:	bf14      	ite	ne
 800d806:	2391      	movne	r3, #145	@ 0x91
 800d808:	2361      	moveq	r3, #97	@ 0x61
    button.border = KEYBOARD_BUTTON_BORDER | BUTTON_BORDER_FALLING;
 800d80a:	f88d 300a 	strb.w	r3, [sp, #10]
  const keypad_pos_t *p = &key_pos[keypads->type];
 800d80e:	683b      	ldr	r3, [r7, #0]
 800d810:	785c      	ldrb	r4, [r3, #1]
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800d812:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800d816:	ea4f 0640 	mov.w	r6, r0, lsl #1
 800d81a:	7899      	ldrb	r1, [r3, #2]
 800d81c:	4b1d      	ldr	r3, [pc, #116]	@ (800d894 <keypad_draw_button+0xa8>)
 800d81e:	eb03 00c4 	add.w	r0, r3, r4, lsl #3
  if (id == selection)
 800d822:	bf14      	ite	ne
 800d824:	2203      	movne	r2, #3
 800d826:	2205      	moveq	r2, #5
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800d828:	f833 4034 	ldrh.w	r4, [r3, r4, lsl #3]
    button.bg = LCD_MENU_ACTIVE_COLOR;
 800d82c:	f88d 2008 	strb.w	r2, [sp, #8]
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800d830:	8882      	ldrh	r2, [r0, #4]
  int y = p->y_offs + (keypads->buttons[id].pos & 0xF) * p->height;
 800d832:	88c3      	ldrh	r3, [r0, #6]
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800d834:	090d      	lsrs	r5, r1, #4
 800d836:	fb02 4405 	mla	r4, r2, r5, r4
  int y = p->y_offs + (keypads->buttons[id].pos & 0xF) * p->height;
 800d83a:	8845      	ldrh	r5, [r0, #2]
 800d83c:	f001 010f 	and.w	r1, r1, #15
 800d840:	fb03 5501 	mla	r5, r3, r1, r5
  ui_draw_button(x, y, p->width, p->height, &button);
 800d844:	a902      	add	r1, sp, #8
 800d846:	9100      	str	r1, [sp, #0]
 800d848:	b2a0      	uxth	r0, r4
 800d84a:	b2a9      	uxth	r1, r5
 800d84c:	f7ff fec6 	bl	800d5dc <ui_draw_button>
  uint8_t ch = keypads->buttons[id].c;
 800d850:	683b      	ldr	r3, [r7, #0]
 800d852:	441e      	add	r6, r3
 800d854:	78f0      	ldrb	r0, [r6, #3]
  if (ch == KP_EMPTY)
 800d856:	28ff      	cmp	r0, #255	@ 0xff
 800d858:	d014      	beq.n	800d884 <keypad_draw_button+0x98>
  if (keypads->type == NUM_KEYBOARD)
 800d85a:	785b      	ldrb	r3, [r3, #1]
 800d85c:	b943      	cbnz	r3, 800d870 <keypad_draw_button+0x84>
    lcd_drawfont(ch,
 800d85e:	f105 0219 	add.w	r2, r5, #25
 800d862:	f104 0134 	add.w	r1, r4, #52	@ 0x34
}
 800d866:	b00d      	add	sp, #52	@ 0x34
 800d868:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    lcd_drawfont(ch,
 800d86c:	f002 bdde 	b.w	801042c <lcd_drawfont>
    lcd_drawchar_size(ch,
 800d870:	2302      	movs	r3, #2
 800d872:	f105 020d 	add.w	r2, r5, #13
 800d876:	f104 0112 	add.w	r1, r4, #18
}
 800d87a:	b00d      	add	sp, #52	@ 0x34
 800d87c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    lcd_drawchar_size(ch,
 800d880:	f002 bd56 	b.w	8010330 <lcd_drawchar_size>
}
 800d884:	b00d      	add	sp, #52	@ 0x34
 800d886:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d888:	4770      	bx	lr
 800d88a:	bf00      	nop
 800d88c:	200003f0 	.word	0x200003f0
 800d890:	200089c0 	.word	0x200089c0
 800d894:	08014b64 	.word	0x08014b64

0800d898 <ui_mode_keypad>:
{
 800d898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (ui_mode == UI_KEYPAD)
 800d89a:	4b27      	ldr	r3, [pc, #156]	@ (800d938 <ui_mode_keypad+0xa0>)
 800d89c:	781a      	ldrb	r2, [r3, #0]
 800d89e:	2a02      	cmp	r2, #2
 800d8a0:	d048      	beq.n	800d934 <ui_mode_keypad+0x9c>
  set_area_size(0, 0);
 800d8a2:	2100      	movs	r1, #0
 800d8a4:	4604      	mov	r4, r0
  ui_mode = UI_KEYPAD;
 800d8a6:	2202      	movs	r2, #2
  keypad_mode = mode;
 800d8a8:	4e24      	ldr	r6, [pc, #144]	@ (800d93c <ui_mode_keypad+0xa4>)
  ui_mode = UI_KEYPAD;
 800d8aa:	701a      	strb	r2, [r3, #0]
  set_area_size(0, 0);
 800d8ac:	4608      	mov	r0, r1
 800d8ae:	f7fd ff95 	bl	800b7dc <set_area_size>
  keypads = keypad_type_list[keypads_mode_tbl[mode].keypad_type];
 800d8b2:	230a      	movs	r3, #10
 800d8b4:	4d22      	ldr	r5, [pc, #136]	@ (800d940 <ui_mode_keypad+0xa8>)
  keypad_mode = mode;
 800d8b6:	7034      	strb	r4, [r6, #0]
  keypads = keypad_type_list[keypads_mode_tbl[mode].keypad_type];
 800d8b8:	435c      	muls	r4, r3
 800d8ba:	4b22      	ldr	r3, [pc, #136]	@ (800d944 <ui_mode_keypad+0xac>)
 800d8bc:	5d2a      	ldrb	r2, [r5, r4]
 800d8be:	4f22      	ldr	r7, [pc, #136]	@ (800d948 <ui_mode_keypad+0xb0>)
 800d8c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800d8c4:	603b      	str	r3, [r7, #0]
  selection = -1;
 800d8c6:	4b21      	ldr	r3, [pc, #132]	@ (800d94c <ui_mode_keypad+0xb4>)
 800d8c8:	22ff      	movs	r2, #255	@ 0xff
 800d8ca:	701a      	strb	r2, [r3, #0]
  kp_buf[0] = 0;
 800d8cc:	4b20      	ldr	r3, [pc, #128]	@ (800d950 <ui_mode_keypad+0xb8>)
 800d8ce:	2400      	movs	r4, #0
 800d8d0:	701c      	strb	r4, [r3, #0]
  for (int i = 0; i < keypads->size; i++)
 800d8d2:	683b      	ldr	r3, [r7, #0]
 800d8d4:	781b      	ldrb	r3, [r3, #0]
 800d8d6:	429c      	cmp	r4, r3
 800d8d8:	da04      	bge.n	800d8e4 <ui_mode_keypad+0x4c>
    keypad_draw_button(i);
 800d8da:	4620      	mov	r0, r4
 800d8dc:	f7ff ff86 	bl	800d7ec <keypad_draw_button>
  for (int i = 0; i < keypads->size; i++)
 800d8e0:	3401      	adds	r4, #1
 800d8e2:	e7f6      	b.n	800d8d2 <ui_mode_keypad+0x3a>
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800d8e4:	2114      	movs	r1, #20
 800d8e6:	2013      	movs	r0, #19
 800d8e8:	f002 fc0a 	bl	8010100 <lcd_set_colors>
  lcd_fill(0, LCD_HEIGHT - NUM_INPUT_HEIGHT, LCD_WIDTH, NUM_INPUT_HEIGHT);
 800d8ec:	2320      	movs	r3, #32
 800d8ee:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800d8f2:	f44f 7190 	mov.w	r1, #288	@ 0x120
 800d8f6:	2000      	movs	r0, #0
 800d8f8:	f002 fafc 	bl	800fef4 <lcd_fill>
  const char *label = keypads_mode_tbl[keypad_mode].name;
 800d8fc:	7833      	ldrb	r3, [r6, #0]
 800d8fe:	220a      	movs	r2, #10
 800d900:	fb02 5503 	mla	r5, r2, r3, r5
  int n = 1;
 800d904:	2301      	movs	r3, #1
  const char *label = keypads_mode_tbl[keypad_mode].name;
 800d906:	f8d5 2002 	ldr.w	r2, [r5, #2]
  while (*label)
 800d90a:	1e51      	subs	r1, r2, #1
 800d90c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 800d910:	b118      	cbz	r0, 800d91a <ui_mode_keypad+0x82>
    if (*label++ == '\n')
 800d912:	280a      	cmp	r0, #10
      n++;
 800d914:	bf08      	it	eq
 800d916:	3301      	addeq	r3, #1
 800d918:	e7f8      	b.n	800d90c <ui_mode_keypad+0x74>
  lcd_drawstring(10, LCD_HEIGHT - (FONT_STR_HEIGHT * lines + NUM_INPUT_HEIGHT) / 2, label);
 800d91a:	210b      	movs	r1, #11
 800d91c:	434b      	muls	r3, r1
 800d91e:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800d922:	1059      	asrs	r1, r3, #1
 800d924:	f5c1 7198 	rsb	r1, r1, #304	@ 0x130
}
 800d928:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  lcd_drawstring(10, LCD_HEIGHT - (FONT_STR_HEIGHT * lines + NUM_INPUT_HEIGHT) / 2, label);
 800d92c:	b209      	sxth	r1, r1
 800d92e:	200a      	movs	r0, #10
 800d930:	f002 bc76 	b.w	8010220 <lcd_printf>
}
 800d934:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d936:	bf00      	nop
 800d938:	200089c4 	.word	0x200089c4
 800d93c:	200089bf 	.word	0x200089bf
 800d940:	080148a8 	.word	0x080148a8
 800d944:	080149f4 	.word	0x080149f4
 800d948:	200089c0 	.word	0x200089c0
 800d94c:	200003f0 	.word	0x200003f0
 800d950:	200089c8 	.word	0x200089c8

0800d954 <load_cmd>:
{
 800d954:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800d958:	4e16      	ldr	r6, [pc, #88]	@ (800d9b4 <load_cmd+0x60>)
{
 800d95a:	4607      	mov	r7, r0
  uint16_t j = 0, i;
 800d95c:	2500      	movs	r5, #0
        line[j++] = (char)c; // Store
 800d95e:	f506 7880 	add.w	r8, r6, #256	@ 0x100
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800d962:	ab01      	add	r3, sp, #4
 800d964:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800d968:	4631      	mov	r1, r6
 800d96a:	4638      	mov	r0, r7
 800d96c:	f7f7 f8e6 	bl	8004b3c <f_read>
 800d970:	4604      	mov	r4, r0
 800d972:	b9d0      	cbnz	r0, 800d9aa <load_cmd+0x56>
 800d974:	9b01      	ldr	r3, [sp, #4]
 800d976:	b1c3      	cbz	r3, 800d9aa <load_cmd+0x56>
        line[j] = 0;
 800d978:	46a1      	mov	r9, r4
    for (i = 0; i < size; i++)
 800d97a:	9a01      	ldr	r2, [sp, #4]
 800d97c:	b2a3      	uxth	r3, r4
 800d97e:	429a      	cmp	r2, r3
 800d980:	d9ef      	bls.n	800d962 <load_cmd+0xe>
      uint8_t c = buf_8[i];
 800d982:	5cf3      	ldrb	r3, [r6, r3]
      if (c == '\r')
 800d984:	2b0d      	cmp	r3, #13
 800d986:	d106      	bne.n	800d996 <load_cmd+0x42>
        line[j] = 0;
 800d988:	f808 9005 	strb.w	r9, [r8, r5]
        VNAShell_executeCMDLine(line);
 800d98c:	480a      	ldr	r0, [pc, #40]	@ (800d9b8 <load_cmd+0x64>)
 800d98e:	f7fa fedf 	bl	8008750 <VNAShell_executeCMDLine>
        j = 0;
 800d992:	2500      	movs	r5, #0
 800d994:	e007      	b.n	800d9a6 <load_cmd+0x52>
      else if (c < 0x20)
 800d996:	2b1f      	cmp	r3, #31
 800d998:	d905      	bls.n	800d9a6 <load_cmd+0x52>
      else if (j < line_size)
 800d99a:	2d7f      	cmp	r5, #127	@ 0x7f
 800d99c:	d803      	bhi.n	800d9a6 <load_cmd+0x52>
        line[j++] = (char)c; // Store
 800d99e:	1c6a      	adds	r2, r5, #1
 800d9a0:	f808 3005 	strb.w	r3, [r8, r5]
 800d9a4:	b295      	uxth	r5, r2
    for (i = 0; i < size; i++)
 800d9a6:	3401      	adds	r4, #1
 800d9a8:	e7e7      	b.n	800d97a <load_cmd+0x26>
}
 800d9aa:	2000      	movs	r0, #0
 800d9ac:	b003      	add	sp, #12
 800d9ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d9b2:	bf00      	nop
 800d9b4:	200089f4 	.word	0x200089f4
 800d9b8:	20008af4 	.word	0x20008af4

0800d9bc <save_bin>:
{
 800d9bc:	b507      	push	{r0, r1, r2, lr}
  return f_write(f, src, total, &size);
 800d9be:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 800d9c2:	ab01      	add	r3, sp, #4
 800d9c4:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
 800d9c8:	f7f7 f98c 	bl	8004ce4 <f_write>
}
 800d9cc:	b003      	add	sp, #12
 800d9ce:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800d9d4 <save_cal>:
{
 800d9d4:	b507      	push	{r0, r1, r2, lr}
  return f_write(f, src, total, &size);
 800d9d6:	4904      	ldr	r1, [pc, #16]	@ (800d9e8 <save_cal+0x14>)
 800d9d8:	ab01      	add	r3, sp, #4
 800d9da:	f643 727c 	movw	r2, #16252	@ 0x3f7c
 800d9de:	f7f7 f981 	bl	8004ce4 <f_write>
}
 800d9e2:	b003      	add	sp, #12
 800d9e4:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9e8:	20000aa8 	.word	0x20000aa8

0800d9ec <load_cal>:
  if (fno->fsize != sizeof(current_props) || f_read(f, &magic, sizeof(magic), &size) != FR_OK ||
 800d9ec:	e9d1 3200 	ldrd	r3, r2, [r1]
 800d9f0:	f5a3 537d 	sub.w	r3, r3, #16192	@ 0x3f40
 800d9f4:	3b3c      	subs	r3, #60	@ 0x3c
 800d9f6:	4313      	orrs	r3, r2
{
 800d9f8:	b513      	push	{r0, r1, r4, lr}
  if (fno->fsize != sizeof(current_props) || f_read(f, &magic, sizeof(magic), &size) != FR_OK ||
 800d9fa:	d001      	beq.n	800da00 <load_cal+0x14>
    return "Format err";
 800d9fc:	480f      	ldr	r0, [pc, #60]	@ (800da3c <load_cal+0x50>)
 800d9fe:	e01b      	b.n	800da38 <load_cal+0x4c>
  if (fno->fsize != sizeof(current_props) || f_read(f, &magic, sizeof(magic), &size) != FR_OK ||
 800da00:	2204      	movs	r2, #4
 800da02:	466b      	mov	r3, sp
 800da04:	eb0d 0102 	add.w	r1, sp, r2
 800da08:	4604      	mov	r4, r0
 800da0a:	f7f7 f897 	bl	8004b3c <f_read>
 800da0e:	2800      	cmp	r0, #0
 800da10:	d1f4      	bne.n	800d9fc <load_cal+0x10>
 800da12:	4b0b      	ldr	r3, [pc, #44]	@ (800da40 <load_cal+0x54>)
 800da14:	9a01      	ldr	r2, [sp, #4]
 800da16:	429a      	cmp	r2, r3
 800da18:	d1f0      	bne.n	800d9fc <load_cal+0x10>
      magic != PROPERTIES_MAGIC || f_read(f, src, total, &size) != FR_OK)
 800da1a:	4620      	mov	r0, r4
 800da1c:	4909      	ldr	r1, [pc, #36]	@ (800da44 <load_cal+0x58>)
 800da1e:	466b      	mov	r3, sp
 800da20:	f643 7278 	movw	r2, #16248	@ 0x3f78
 800da24:	f7f7 f88a 	bl	8004b3c <f_read>
 800da28:	4604      	mov	r4, r0
 800da2a:	2800      	cmp	r0, #0
 800da2c:	d1e6      	bne.n	800d9fc <load_cal+0x10>
  load_properties(NO_SAVE_SLOT);
 800da2e:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 800da32:	f7f9 fb47 	bl	80070c4 <load_properties>
  return NULL;
 800da36:	4620      	mov	r0, r4
}
 800da38:	b002      	add	sp, #8
 800da3a:	bd10      	pop	{r4, pc}
 800da3c:	08012b2e 	.word	0x08012b2e
 800da40:	434f4e54 	.word	0x434f4e54
 800da44:	20000aac 	.word	0x20000aac

0800da48 <load_tiff>:
{
 800da48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FRESULT res = f_read(f, (void *)buf_16, sizeof(tif_header), &size); // read header
 800da4c:	4d3f      	ldr	r5, [pc, #252]	@ (800db4c <load_tiff+0x104>)
{
 800da4e:	b085      	sub	sp, #20
 800da50:	4688      	mov	r8, r1
  FRESULT res = f_read(f, (void *)buf_16, sizeof(tif_header), &size); // read header
 800da52:	ab03      	add	r3, sp, #12
 800da54:	2268      	movs	r2, #104	@ 0x68
 800da56:	4629      	mov	r1, r5
{
 800da58:	4607      	mov	r7, r0
  FRESULT res = f_read(f, (void *)buf_16, sizeof(tif_header), &size); // read header
 800da5a:	f7f7 f86f 	bl	8004b3c <f_read>
  if (res != FR_OK ||
 800da5e:	2800      	cmp	r0, #0
 800da60:	d16f      	bne.n	800db42 <load_tiff+0xfa>
 800da62:	882a      	ldrh	r2, [r5, #0]
 800da64:	f644 1349 	movw	r3, #18761	@ 0x4949
 800da68:	429a      	cmp	r2, r3
 800da6a:	d16a      	bne.n	800db42 <load_tiff+0xfa>
      buf_16[0] != 0x4949 ||      // Check header ID
 800da6c:	8a6b      	ldrh	r3, [r5, #18]
 800da6e:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 800da72:	d166      	bne.n	800db42 <load_tiff+0xfa>
      buf_16[9] != LCD_WIDTH ||   // Check Width
 800da74:	8beb      	ldrh	r3, [r5, #30]
 800da76:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800da7a:	d162      	bne.n	800db42 <load_tiff+0xfa>
      buf_16[15] != LCD_HEIGHT || // Check Height
 800da7c:	8eea      	ldrh	r2, [r5, #54]	@ 0x36
 800da7e:	f248 0305 	movw	r3, #32773	@ 0x8005
 800da82:	429a      	cmp	r2, r3
 800da84:	d15d      	bne.n	800db42 <load_tiff+0xfa>
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800da86:	f8df 90cc 	ldr.w	r9, [pc, #204]	@ 800db54 <load_tiff+0x10c>
 800da8a:	4604      	mov	r4, r0
    for (int x = 0; x < LCD_WIDTH * 3;)
 800da8c:	f04f 0a00 	mov.w	sl, #0
      res = f_read(f, data, 2, &size); // Read count and value
 800da90:	ab03      	add	r3, sp, #12
 800da92:	2202      	movs	r2, #2
 800da94:	a902      	add	r1, sp, #8
 800da96:	4638      	mov	r0, r7
 800da98:	f7f7 f850 	bl	8004b3c <f_read>
      int count = data[0];             // count
 800da9c:	f99d 2008 	ldrsb.w	r2, [sp, #8]
      res = f_read(f, data, 2, &size); // Read count and value
 800daa0:	4606      	mov	r6, r0
      if (count > 0)
 800daa2:	2a00      	cmp	r2, #0
      buf_8[x++] = data[1];            // copy first value
 800daa4:	f89d 0009 	ldrb.w	r0, [sp, #9]
 800daa8:	f805 000a 	strb.w	r0, [r5, sl]
      int count = data[0];             // count
 800daac:	4611      	mov	r1, r2
      buf_8[x++] = data[1];            // copy first value
 800daae:	f10a 0b01 	add.w	fp, sl, #1
 800dab2:	eb05 030a 	add.w	r3, r5, sl
      if (count > 0)
 800dab6:	dd0b      	ble.n	800dad0 <load_tiff+0x88>
        res = f_read(f, &buf_8[x], count, &size);
 800dab8:	ab03      	add	r3, sp, #12
 800daba:	eb05 010b 	add.w	r1, r5, fp
 800dabe:	4638      	mov	r0, r7
 800dac0:	9201      	str	r2, [sp, #4]
 800dac2:	f7f7 f83b 	bl	8004b3c <f_read>
        x += count;
 800dac6:	9a01      	ldr	r2, [sp, #4]
        res = f_read(f, &buf_8[x], count, &size);
 800dac8:	4606      	mov	r6, r0
        x += count;
 800daca:	eb02 0a0b 	add.w	sl, r2, fp
 800dace:	e007      	b.n	800dae0 <load_tiff+0x98>
        while (count++ < 0)
 800dad0:	3101      	adds	r1, #1
 800dad2:	2901      	cmp	r1, #1
 800dad4:	d002      	beq.n	800dadc <load_tiff+0x94>
          buf_8[x++] = data[1]; // if count < 0 need repeat value -count times
 800dad6:	f803 0f01 	strb.w	r0, [r3, #1]!
 800dada:	e7f9      	b.n	800dad0 <load_tiff+0x88>
 800dadc:	ebab 0a02 	sub.w	sl, fp, r2
    for (int x = 0; x < LCD_WIDTH * 3;)
 800dae0:	f5ba 6fb4 	cmp.w	sl, #1440	@ 0x5a0
 800dae4:	dbd4      	blt.n	800da90 <load_tiff+0x48>
    for (int x = 0; x < LCD_WIDTH; x++)
 800dae6:	f8df c064 	ldr.w	ip, [pc, #100]	@ 800db4c <load_tiff+0x104>
 800daea:	2200      	movs	r2, #0
    for (int x = 0; x < LCD_WIDTH * 3;)
 800daec:	4660      	mov	r0, ip
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800daee:	7881      	ldrb	r1, [r0, #2]
 800daf0:	f890 e001 	ldrb.w	lr, [r0, #1]
 800daf4:	0149      	lsls	r1, r1, #5
 800daf6:	ea09 23ce 	and.w	r3, r9, lr, lsl #11
 800dafa:	f401 51f8 	and.w	r1, r1, #7936	@ 0x1f00
 800dafe:	4319      	orrs	r1, r3
 800db00:	f810 3b03 	ldrb.w	r3, [r0], #3
 800db04:	f023 0307 	bic.w	r3, r3, #7
 800db08:	ea43 135e 	orr.w	r3, r3, lr, lsr #5
    for (int x = 0; x < LCD_WIDTH; x++)
 800db0c:	3201      	adds	r2, #1
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800db0e:	430b      	orrs	r3, r1
    for (int x = 0; x < LCD_WIDTH; x++)
 800db10:	f5b2 7ff0 	cmp.w	r2, #480	@ 0x1e0
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800db14:	f82c 3b02 	strh.w	r3, [ip], #2
    for (int x = 0; x < LCD_WIDTH; x++)
 800db18:	d1e9      	bne.n	800daee <load_tiff+0xa6>
    lcd_bulk(0, y, LCD_WIDTH, 1);
 800db1a:	4621      	mov	r1, r4
 800db1c:	2301      	movs	r3, #1
 800db1e:	2000      	movs	r0, #0
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800db20:	3401      	adds	r4, #1
    lcd_bulk(0, y, LCD_WIDTH, 1);
 800db22:	f002 f9d9 	bl	800fed8 <lcd_bulk>
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800db26:	f5b4 7fa0 	cmp.w	r4, #320	@ 0x140
 800db2a:	d001      	beq.n	800db30 <load_tiff+0xe8>
 800db2c:	2e00      	cmp	r6, #0
 800db2e:	d0ad      	beq.n	800da8c <load_tiff+0x44>
  lcd_printf(0, LCD_HEIGHT - 3 * FONT_STR_HEIGHT, fno->fname);
 800db30:	f108 021a 	add.w	r2, r8, #26
 800db34:	f240 111f 	movw	r1, #287	@ 0x11f
 800db38:	2000      	movs	r0, #0
 800db3a:	f002 fb71 	bl	8010220 <lcd_printf>
  return NULL;
 800db3e:	2000      	movs	r0, #0
 800db40:	e000      	b.n	800db44 <load_tiff+0xfc>
    return "Format err";
 800db42:	4803      	ldr	r0, [pc, #12]	@ (800db50 <load_tiff+0x108>)
}
 800db44:	b005      	add	sp, #20
 800db46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800db4a:	bf00      	nop
 800db4c:	200089f4 	.word	0x200089f4
 800db50:	08012b2e 	.word	0x08012b2e
 800db54:	ffffe000 	.word	0xffffe000

0800db58 <save_tiff>:
{
 800db58:	b5f0      	push	{r4, r5, r6, r7, lr}
 800db5a:	b085      	sub	sp, #20
  FRESULT res = f_write(f, tif_header, sizeof(tif_header), &size); // Write header struct
 800db5c:	4925      	ldr	r1, [pc, #148]	@ (800dbf4 <save_tiff+0x9c>)
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800db5e:	4f26      	ldr	r7, [pc, #152]	@ (800dbf8 <save_tiff+0xa0>)
  FRESULT res = f_write(f, tif_header, sizeof(tif_header), &size); // Write header struct
 800db60:	ab03      	add	r3, sp, #12
 800db62:	2268      	movs	r2, #104	@ 0x68
{
 800db64:	4606      	mov	r6, r0
  FRESULT res = f_write(f, tif_header, sizeof(tif_header), &size); // Write header struct
 800db66:	f7f7 f8bd 	bl	8004ce4 <f_write>
 800db6a:	4604      	mov	r4, r0
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 800db6c:	2011      	movs	r0, #17
 800db6e:	f002 fabb 	bl	80100e8 <lcd_set_background>
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800db72:	2500      	movs	r5, #0
 800db74:	2c00      	cmp	r4, #0
 800db76:	d13a      	bne.n	800dbee <save_tiff+0x96>
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800db78:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800db7c:	4629      	mov	r1, r5
 800db7e:	9700      	str	r7, [sp, #0]
 800db80:	2301      	movs	r3, #1
 800db82:	4620      	mov	r0, r4
 800db84:	f002 f94a 	bl	800fe1c <lcd_read_memory>
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800db88:	4a1b      	ldr	r2, [pc, #108]	@ (800dbf8 <save_tiff+0xa0>)
 800db8a:	f240 11df 	movw	r1, #479	@ 0x1df
      uint16_t color = (buf_16[x] << 8) | (buf_16[x] >> 8);
 800db8e:	f837 3011 	ldrh.w	r3, [r7, r1, lsl #1]
 800db92:	ba5b      	rev16	r3, r3
      buf_8[3 * x + 0] = (color >> 8) & 0xF8; // if (buf_8[3*x + 0] < 0) buf_8[3*x + 0]+= 7;
 800db94:	f3c3 2007 	ubfx	r0, r3, #8, #8
 800db98:	f020 0007 	bic.w	r0, r0, #7
 800db9c:	f882 061d 	strb.w	r0, [r2, #1565]	@ 0x61d
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800dba0:	3901      	subs	r1, #1
      buf_8[3 * x + 1] = (color >> 3) & 0xFC; // if (buf_8[3*x + 1] < 0) buf_8[3*x + 1]+= 3;
 800dba2:	f3c3 00cc 	ubfx	r0, r3, #3, #13
      buf_8[3 * x + 2] = (color << 3) & 0xF8; // if (buf_8[3*x + 2] < 0) buf_8[3*x + 2]+= 7;
 800dba6:	00db      	lsls	r3, r3, #3
 800dba8:	f882 361f 	strb.w	r3, [r2, #1567]	@ 0x61f
      buf_8[3 * x + 1] = (color >> 3) & 0xFC; // if (buf_8[3*x + 1] < 0) buf_8[3*x + 1]+= 3;
 800dbac:	f020 0003 	bic.w	r0, r0, #3
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800dbb0:	1c4b      	adds	r3, r1, #1
      buf_8[3 * x + 1] = (color >> 3) & 0xFC; // if (buf_8[3*x + 1] < 0) buf_8[3*x + 1]+= 3;
 800dbb2:	f882 061e 	strb.w	r0, [r2, #1566]	@ 0x61e
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800dbb6:	f1a2 0203 	sub.w	r2, r2, #3
 800dbba:	d1e8      	bne.n	800db8e <save_tiff+0x36>
    size = packbits(buf_8, (char *)buf_16, LCD_WIDTH * 3);
 800dbbc:	f44f 62b4 	mov.w	r2, #1440	@ 0x5a0
 800dbc0:	4639      	mov	r1, r7
 800dbc2:	480e      	ldr	r0, [pc, #56]	@ (800dbfc <save_tiff+0xa4>)
 800dbc4:	f7fb f810 	bl	8008be8 <packbits>
    res = f_write(f, buf_16, size, &size);
 800dbc8:	ab03      	add	r3, sp, #12
    size = packbits(buf_8, (char *)buf_16, LCD_WIDTH * 3);
 800dbca:	4602      	mov	r2, r0
 800dbcc:	9003      	str	r0, [sp, #12]
    res = f_write(f, buf_16, size, &size);
 800dbce:	4639      	mov	r1, r7
 800dbd0:	4630      	mov	r0, r6
 800dbd2:	f7f7 f887 	bl	8004ce4 <f_write>
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800dbd6:	2301      	movs	r3, #1
 800dbd8:	4629      	mov	r1, r5
    res = f_write(f, buf_16, size, &size);
 800dbda:	4604      	mov	r4, r0
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800dbdc:	461a      	mov	r2, r3
 800dbde:	f240 10df 	movw	r0, #479	@ 0x1df
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800dbe2:	3501      	adds	r5, #1
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800dbe4:	f002 f986 	bl	800fef4 <lcd_fill>
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800dbe8:	f5b5 7fa0 	cmp.w	r5, #320	@ 0x140
 800dbec:	d1c2      	bne.n	800db74 <save_tiff+0x1c>
}
 800dbee:	4620      	mov	r0, r4
 800dbf0:	b005      	add	sp, #20
 800dbf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dbf4:	08014c40 	.word	0x08014c40
 800dbf8:	200089f4 	.word	0x200089f4
 800dbfc:	20008a74 	.word	0x20008a74

0800dc00 <load_bmp>:
{
 800dc00:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  FRESULT res = f_read(f, (void *)buf_16, sizeof(bmp_header_v4), &size); // read header
 800dc04:	4c1d      	ldr	r4, [pc, #116]	@ (800dc7c <load_bmp+0x7c>)
{
 800dc06:	460e      	mov	r6, r1
  FRESULT res = f_read(f, (void *)buf_16, sizeof(bmp_header_v4), &size); // read header
 800dc08:	ab01      	add	r3, sp, #4
 800dc0a:	227a      	movs	r2, #122	@ 0x7a
 800dc0c:	4621      	mov	r1, r4
{
 800dc0e:	4607      	mov	r7, r0
  FRESULT res = f_read(f, (void *)buf_16, sizeof(bmp_header_v4), &size); // read header
 800dc10:	f7f6 ff94 	bl	8004b3c <f_read>
  if (res != FR_OK || buf_16[9] != LCD_WIDTH || buf_16[11] != LCD_HEIGHT || buf_16[14] != 16)
 800dc14:	bb70      	cbnz	r0, 800dc74 <load_bmp+0x74>
 800dc16:	8a63      	ldrh	r3, [r4, #18]
 800dc18:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 800dc1c:	d12a      	bne.n	800dc74 <load_bmp+0x74>
 800dc1e:	8ae3      	ldrh	r3, [r4, #22]
 800dc20:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800dc24:	d126      	bne.n	800dc74 <load_bmp+0x74>
 800dc26:	8ba3      	ldrh	r3, [r4, #28]
 800dc28:	2b10      	cmp	r3, #16
 800dc2a:	d123      	bne.n	800dc74 <load_bmp+0x74>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800dc2c:	f240 153f 	movw	r5, #319	@ 0x13f
    res = f_read(f, (void *)buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800dc30:	ab01      	add	r3, sp, #4
 800dc32:	f44f 7270 	mov.w	r2, #960	@ 0x3c0
 800dc36:	4621      	mov	r1, r4
 800dc38:	4638      	mov	r0, r7
 800dc3a:	f7f6 ff7f 	bl	8004b3c <f_read>
    swap_bytes(buf_16, LCD_WIDTH);
 800dc3e:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
    res = f_read(f, (void *)buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800dc42:	4680      	mov	r8, r0
    swap_bytes(buf_16, LCD_WIDTH);
 800dc44:	4620      	mov	r0, r4
 800dc46:	f7fa ffc3 	bl	8008bd0 <swap_bytes>
    lcd_bulk(0, y, LCD_WIDTH, 1);
 800dc4a:	4629      	mov	r1, r5
 800dc4c:	2301      	movs	r3, #1
 800dc4e:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800dc52:	2000      	movs	r0, #0
 800dc54:	f002 f940 	bl	800fed8 <lcd_bulk>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800dc58:	3d01      	subs	r5, #1
 800dc5a:	d302      	bcc.n	800dc62 <load_bmp+0x62>
 800dc5c:	f1b8 0f00 	cmp.w	r8, #0
 800dc60:	d0e6      	beq.n	800dc30 <load_bmp+0x30>
  lcd_printf(0, LCD_HEIGHT - 3 * FONT_STR_HEIGHT, fno->fname);
 800dc62:	f106 021a 	add.w	r2, r6, #26
 800dc66:	f240 111f 	movw	r1, #287	@ 0x11f
 800dc6a:	2000      	movs	r0, #0
 800dc6c:	f002 fad8 	bl	8010220 <lcd_printf>
  return NULL;
 800dc70:	2000      	movs	r0, #0
 800dc72:	e000      	b.n	800dc76 <load_bmp+0x76>
    return "Format err";
 800dc74:	4802      	ldr	r0, [pc, #8]	@ (800dc80 <load_bmp+0x80>)
}
 800dc76:	b002      	add	sp, #8
 800dc78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800dc7c:	200089f4 	.word	0x200089f4
 800dc80:	08012b2e 	.word	0x08012b2e

0800dc84 <save_bmp>:
{
 800dc84:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dc86:	b085      	sub	sp, #20
  FRESULT res = f_write(f, bmp_header_v4, sizeof(bmp_header_v4), &size); // Write header struct
 800dc88:	4917      	ldr	r1, [pc, #92]	@ (800dce8 <save_bmp+0x64>)
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800dc8a:	4f18      	ldr	r7, [pc, #96]	@ (800dcec <save_bmp+0x68>)
  FRESULT res = f_write(f, bmp_header_v4, sizeof(bmp_header_v4), &size); // Write header struct
 800dc8c:	ab03      	add	r3, sp, #12
 800dc8e:	227a      	movs	r2, #122	@ 0x7a
{
 800dc90:	4606      	mov	r6, r0
  FRESULT res = f_write(f, bmp_header_v4, sizeof(bmp_header_v4), &size); // Write header struct
 800dc92:	f7f7 f827 	bl	8004ce4 <f_write>
 800dc96:	4604      	mov	r4, r0
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 800dc98:	2011      	movs	r0, #17
 800dc9a:	f002 fa25 	bl	80100e8 <lcd_set_background>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800dc9e:	f240 153f 	movw	r5, #319	@ 0x13f
 800dca2:	b9ec      	cbnz	r4, 800dce0 <save_bmp+0x5c>
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800dca4:	2301      	movs	r3, #1
 800dca6:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800dcaa:	4629      	mov	r1, r5
 800dcac:	4620      	mov	r0, r4
 800dcae:	9700      	str	r7, [sp, #0]
 800dcb0:	f002 f8b4 	bl	800fe1c <lcd_read_memory>
    swap_bytes(buf_16, LCD_WIDTH);
 800dcb4:	480d      	ldr	r0, [pc, #52]	@ (800dcec <save_bmp+0x68>)
 800dcb6:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
 800dcba:	f7fa ff89 	bl	8008bd0 <swap_bytes>
    res = f_write(f, buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800dcbe:	490b      	ldr	r1, [pc, #44]	@ (800dcec <save_bmp+0x68>)
 800dcc0:	ab03      	add	r3, sp, #12
 800dcc2:	f44f 7270 	mov.w	r2, #960	@ 0x3c0
 800dcc6:	4630      	mov	r0, r6
 800dcc8:	f7f7 f80c 	bl	8004ce4 <f_write>
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800dccc:	2301      	movs	r3, #1
 800dcce:	4629      	mov	r1, r5
    res = f_write(f, buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800dcd0:	4604      	mov	r4, r0
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800dcd2:	461a      	mov	r2, r3
 800dcd4:	f240 10df 	movw	r0, #479	@ 0x1df
 800dcd8:	f002 f90c 	bl	800fef4 <lcd_fill>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800dcdc:	3d01      	subs	r5, #1
 800dcde:	d2e0      	bcs.n	800dca2 <save_bmp+0x1e>
}
 800dce0:	4620      	mov	r0, r4
 800dce2:	b005      	add	sp, #20
 800dce4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dce6:	bf00      	nop
 800dce8:	08014ca8 	.word	0x08014ca8
 800dcec:	200089f4 	.word	0x200089f4

0800dcf0 <load_snp>:
{
 800dcf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dcf4:	ed2d 8b02 	vpush	{d8}
 800dcf8:	b095      	sub	sp, #84	@ 0x54
  freq_t start = 0, stop = 0, freq;
 800dcfa:	2500      	movs	r5, #0
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800dcfc:	f8df b144 	ldr.w	fp, [pc, #324]	@ 800de44 <load_snp+0x154>
        measured[0][count][0] = my_atof(args[1]);
 800dd00:	f8df 8144 	ldr.w	r8, [pc, #324]	@ 800de48 <load_snp+0x158>
{
 800dd04:	9200      	str	r2, [sp, #0]
 800dd06:	4681      	mov	r9, r0
  freq_t start = 0, stop = 0, freq;
 800dd08:	46aa      	mov	sl, r5
  uint16_t j = 0, i, count = 0;
 800dd0a:	462c      	mov	r4, r5
 800dd0c:	462f      	mov	r7, r5
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800dd0e:	ab03      	add	r3, sp, #12
 800dd10:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800dd14:	4659      	mov	r1, fp
 800dd16:	4648      	mov	r0, r9
 800dd18:	f7f6 ff10 	bl	8004b3c <f_read>
 800dd1c:	4606      	mov	r6, r0
 800dd1e:	2800      	cmp	r0, #0
 800dd20:	d168      	bne.n	800ddf4 <load_snp+0x104>
 800dd22:	9b03      	ldr	r3, [sp, #12]
 800dd24:	2b00      	cmp	r3, #0
 800dd26:	d065      	beq.n	800ddf4 <load_snp+0x104>
          measured[1][count][0] = 0.0f;
 800dd28:	ed9f 8a41 	vldr	s16, [pc, #260]	@ 800de30 <load_snp+0x140>
    for (i = 0; i < size; i++)
 800dd2c:	9a03      	ldr	r2, [sp, #12]
 800dd2e:	b2b3      	uxth	r3, r6
 800dd30:	429a      	cmp	r2, r3
 800dd32:	d9ec      	bls.n	800dd0e <load_snp+0x1e>
      uint8_t c = buf_8[i];
 800dd34:	f81b 3003 	ldrb.w	r3, [fp, r3]
      if (c == '\r')
 800dd38:	2b0d      	cmp	r3, #13
 800dd3a:	d151      	bne.n	800dde0 <load_snp+0xf0>
        line[j] = 0;
 800dd3c:	4a3d      	ldr	r2, [pc, #244]	@ (800de34 <load_snp+0x144>)
        int nargs = parse_line(line, args, 16); // Parse line to 16 args
 800dd3e:	483d      	ldr	r0, [pc, #244]	@ (800de34 <load_snp+0x144>)
        line[j] = 0;
 800dd40:	2300      	movs	r3, #0
 800dd42:	55d3      	strb	r3, [r2, r7]
        int nargs = parse_line(line, args, 16); // Parse line to 16 args
 800dd44:	2210      	movs	r2, #16
 800dd46:	eb0d 0102 	add.w	r1, sp, r2
 800dd4a:	f7fa ff0f 	bl	8008b6c <parse_line>
        if (nargs < 2 || args[0][0] == '#' || args[0][0] == '!')
 800dd4e:	2801      	cmp	r0, #1
        int nargs = parse_line(line, args, 16); // Parse line to 16 args
 800dd50:	4607      	mov	r7, r0
        if (nargs < 2 || args[0][0] == '#' || args[0][0] == '!')
 800dd52:	dd43      	ble.n	800dddc <load_snp+0xec>
 800dd54:	9804      	ldr	r0, [sp, #16]
 800dd56:	7803      	ldrb	r3, [r0, #0]
 800dd58:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
 800dd5c:	2b21      	cmp	r3, #33	@ 0x21
 800dd5e:	d03d      	beq.n	800dddc <load_snp+0xec>
        freq = my_atoui(args[0]); // Get frequency
 800dd60:	f7fa fe28 	bl	80089b4 <my_atoui>
        if (count >= SWEEP_POINTS_MAX || freq > FREQUENCY_MAX)
 800dd64:	f5b4 7fc8 	cmp.w	r4, #400	@ 0x190
        freq = my_atoui(args[0]); // Get frequency
 800dd68:	4605      	mov	r5, r0
        if (count >= SWEEP_POINTS_MAX || freq > FREQUENCY_MAX)
 800dd6a:	d802      	bhi.n	800dd72 <load_snp+0x82>
 800dd6c:	4b32      	ldr	r3, [pc, #200]	@ (800de38 <load_snp+0x148>)
 800dd6e:	4298      	cmp	r0, r3
 800dd70:	d901      	bls.n	800dd76 <load_snp+0x86>
          return "Format err";
 800dd72:	4832      	ldr	r0, [pc, #200]	@ (800de3c <load_snp+0x14c>)
 800dd74:	e056      	b.n	800de24 <load_snp+0x134>
          start = freq; // For index 0 set as start
 800dd76:	2c00      	cmp	r4, #0
 800dd78:	bf08      	it	eq
 800dd7a:	4682      	moveq	sl, r0
        measured[0][count][0] = my_atof(args[1]);
 800dd7c:	9805      	ldr	r0, [sp, #20]
 800dd7e:	f7fa fe3f 	bl	8008a00 <my_atof>
 800dd82:	eb08 03c4 	add.w	r3, r8, r4, lsl #3
        measured[0][count][1] = my_atof(args[2]); // get S11 data
 800dd86:	9806      	ldr	r0, [sp, #24]
        measured[0][count][0] = my_atof(args[1]);
 800dd88:	ed83 0a00 	vstr	s0, [r3]
 800dd8c:	9301      	str	r3, [sp, #4]
        measured[0][count][1] = my_atof(args[2]); // get S11 data
 800dd8e:	f7fa fe37 	bl	8008a00 <my_atof>
 800dd92:	9b01      	ldr	r3, [sp, #4]
 800dd94:	ed83 0a01 	vstr	s0, [r3, #4]
        if (format == FMT_S2P_FILE && nargs >= 4)
 800dd98:	9b00      	ldr	r3, [sp, #0]
 800dd9a:	2b01      	cmp	r3, #1
 800dd9c:	f204 1391 	addw	r3, r4, #401	@ 0x191
 800dda0:	d10e      	bne.n	800ddc0 <load_snp+0xd0>
 800dda2:	2f03      	cmp	r7, #3
 800dda4:	dd0c      	ble.n	800ddc0 <load_snp+0xd0>
          measured[1][count][0] = my_atof(args[3]);
 800dda6:	9807      	ldr	r0, [sp, #28]
 800dda8:	9301      	str	r3, [sp, #4]
 800ddaa:	f7fa fe29 	bl	8008a00 <my_atof>
 800ddae:	9b01      	ldr	r3, [sp, #4]
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ddb0:	9808      	ldr	r0, [sp, #32]
          measured[1][count][0] = my_atof(args[3]);
 800ddb2:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 800ddb6:	ed83 0a00 	vstr	s0, [r3]
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ddba:	f7fa fe21 	bl	8008a00 <my_atof>
 800ddbe:	e005      	b.n	800ddcc <load_snp+0xdc>
          measured[1][count][0] = 0.0f;
 800ddc0:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 800ddc4:	ed83 8a00 	vstr	s16, [r3]
 800ddc8:	eeb0 0a48 	vmov.f32	s0, s16
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ddcc:	00e3      	lsls	r3, r4, #3
 800ddce:	4443      	add	r3, r8
 800ddd0:	f603 438c 	addw	r3, r3, #3212	@ 0xc8c
        count++;
 800ddd4:	3401      	adds	r4, #1
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ddd6:	ed83 0a00 	vstr	s0, [r3]
        count++;
 800ddda:	b2a4      	uxth	r4, r4
        j = 0;
 800dddc:	2700      	movs	r7, #0
 800ddde:	e007      	b.n	800ddf0 <load_snp+0x100>
      else if (c < 0x20)
 800dde0:	2b1f      	cmp	r3, #31
 800dde2:	d905      	bls.n	800ddf0 <load_snp+0x100>
      else if (j < line_size)
 800dde4:	2f7f      	cmp	r7, #127	@ 0x7f
 800dde6:	d803      	bhi.n	800ddf0 <load_snp+0x100>
        line[j++] = (char)c; // Store
 800dde8:	4912      	ldr	r1, [pc, #72]	@ (800de34 <load_snp+0x144>)
 800ddea:	1c7a      	adds	r2, r7, #1
 800ddec:	55cb      	strb	r3, [r1, r7]
 800ddee:	b297      	uxth	r7, r2
    for (i = 0; i < size; i++)
 800ddf0:	3601      	adds	r6, #1
 800ddf2:	e79b      	b.n	800dd2c <load_snp+0x3c>
  if (count != 0)
 800ddf4:	b90c      	cbnz	r4, 800ddfa <load_snp+0x10a>
  return NULL;
 800ddf6:	2000      	movs	r0, #0
 800ddf8:	e014      	b.n	800de24 <load_snp+0x134>
    pause_sweep();
 800ddfa:	f7f8 fa87 	bl	800630c <pause_sweep>
    current_props._electrical_delay[0] = 0.0f; // Reset delays
 800ddfe:	4b10      	ldr	r3, [pc, #64]	@ (800de40 <load_snp+0x150>)
 800de00:	2200      	movs	r2, #0
    set_sweep_frequency(ST_START, start);
 800de02:	4651      	mov	r1, sl
 800de04:	2000      	movs	r0, #0
    current_props._electrical_delay[0] = 0.0f; // Reset delays
 800de06:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
    current_props._electrical_delay[1] = 0.0f; // Reset delays
 800de0a:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    current_props._sweep_points = count;
 800de0e:	835c      	strh	r4, [r3, #26]
    set_sweep_frequency(ST_START, start);
 800de10:	f7f9 fa04 	bl	800721c <set_sweep_frequency>
    set_sweep_frequency(ST_STOP, stop);
 800de14:	4629      	mov	r1, r5
 800de16:	2001      	movs	r0, #1
 800de18:	f7f9 fa00 	bl	800721c <set_sweep_frequency>
    request_to_redraw(REDRAW_PLOT);
 800de1c:	2001      	movs	r0, #1
 800de1e:	f7fd fce7 	bl	800b7f0 <request_to_redraw>
 800de22:	e7e8      	b.n	800ddf6 <load_snp+0x106>
}
 800de24:	b015      	add	sp, #84	@ 0x54
 800de26:	ecbd 8b02 	vpop	{d8}
 800de2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800de2e:	bf00      	nop
 800de30:	00000000 	.word	0x00000000
 800de34:	20008af4 	.word	0x20008af4
 800de38:	a0eebb00 	.word	0xa0eebb00
 800de3c:	08012b2e 	.word	0x08012b2e
 800de40:	20000aa8 	.word	0x20000aa8
 800de44:	200089f4 	.word	0x200089f4
 800de48:	20004f54 	.word	0x20004f54

0800de4c <save_snp>:
{
 800de4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800de50:	b08a      	sub	sp, #40	@ 0x28
 800de52:	4607      	mov	r7, r0
    res = f_write(f, s1_file_header, sizeof(s1_file_header) - 1, &size);
 800de54:	ab09      	add	r3, sp, #36	@ 0x24
 800de56:	222a      	movs	r2, #42	@ 0x2a
  if (format == FMT_S1P_FILE)
 800de58:	b929      	cbnz	r1, 800de66 <save_snp+0x1a>
    res = f_write(f, s1_file_header, sizeof(s1_file_header) - 1, &size);
 800de5a:	4923      	ldr	r1, [pc, #140]	@ (800dee8 <save_snp+0x9c>)
    s_file_format = s1_file_param;
 800de5c:	f8df 8098 	ldr.w	r8, [pc, #152]	@ 800def8 <save_snp+0xac>
    res = f_write(f, s1_file_header, sizeof(s1_file_header) - 1, &size);
 800de60:	f7f6 ff40 	bl	8004ce4 <f_write>
 800de64:	e004      	b.n	800de70 <save_snp+0x24>
    res = f_write(f, s2_file_header, sizeof(s2_file_header) - 1, &size);
 800de66:	4921      	ldr	r1, [pc, #132]	@ (800deec <save_snp+0xa0>)
    s_file_format = s2_file_param;
 800de68:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 800defc <save_snp+0xb0>
    res = f_write(f, s2_file_header, sizeof(s2_file_header) - 1, &size);
 800de6c:	f7f6 ff3a 	bl	8004ce4 <f_write>
  for (int i = 0; i < sweep_points && res == FR_OK; i++)
 800de70:	4c1f      	ldr	r4, [pc, #124]	@ (800def0 <save_snp+0xa4>)
 800de72:	f8df 908c 	ldr.w	r9, [pc, #140]	@ 800df00 <save_snp+0xb4>
 800de76:	f604 4688 	addw	r6, r4, #3208	@ 0xc88
 800de7a:	2500      	movs	r5, #0
 800de7c:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800de80:	42ab      	cmp	r3, r5
 800de82:	dd2d      	ble.n	800dee0 <save_snp+0x94>
 800de84:	3408      	adds	r4, #8
 800de86:	3608      	adds	r6, #8
 800de88:	bb50      	cbnz	r0, 800dee0 <save_snp+0x94>
    size = plot_printf(buf_8, 128, s_file_format, getFrequency(i), measured[0][i][0], measured[0][i][1], measured[1][i][0], measured[1][i][1]);
 800de8a:	b2a8      	uxth	r0, r5
 800de8c:	f7f8 fb96 	bl	80065bc <getFrequency>
 800de90:	4682      	mov	sl, r0
 800de92:	f856 0c04 	ldr.w	r0, [r6, #-4]
 800de96:	f7f2 fb83 	bl	80005a0 <__aeabi_f2d>
 800de9a:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800de9e:	f856 0c08 	ldr.w	r0, [r6, #-8]
 800dea2:	f7f2 fb7d 	bl	80005a0 <__aeabi_f2d>
 800dea6:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800deaa:	f854 0c04 	ldr.w	r0, [r4, #-4]
 800deae:	f7f2 fb77 	bl	80005a0 <__aeabi_f2d>
 800deb2:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800deb6:	f854 0c08 	ldr.w	r0, [r4, #-8]
 800deba:	f7f2 fb71 	bl	80005a0 <__aeabi_f2d>
 800debe:	4653      	mov	r3, sl
 800dec0:	e9cd 0100 	strd	r0, r1, [sp]
 800dec4:	4642      	mov	r2, r8
 800dec6:	2180      	movs	r1, #128	@ 0x80
 800dec8:	480a      	ldr	r0, [pc, #40]	@ (800def4 <save_snp+0xa8>)
 800deca:	f7f4 fefb 	bl	8002cc4 <plot_printf>
    res = f_write(f, buf_8, size, &size);
 800dece:	4909      	ldr	r1, [pc, #36]	@ (800def4 <save_snp+0xa8>)
    size = plot_printf(buf_8, 128, s_file_format, getFrequency(i), measured[0][i][0], measured[0][i][1], measured[1][i][0], measured[1][i][1]);
 800ded0:	9009      	str	r0, [sp, #36]	@ 0x24
 800ded2:	4602      	mov	r2, r0
    res = f_write(f, buf_8, size, &size);
 800ded4:	ab09      	add	r3, sp, #36	@ 0x24
 800ded6:	4638      	mov	r0, r7
 800ded8:	f7f6 ff04 	bl	8004ce4 <f_write>
  for (int i = 0; i < sweep_points && res == FR_OK; i++)
 800dedc:	3501      	adds	r5, #1
 800dede:	e7cd      	b.n	800de7c <save_snp+0x30>
}
 800dee0:	b00a      	add	sp, #40	@ 0x28
 800dee2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800dee6:	bf00      	nop
 800dee8:	08014d80 	.word	0x08014d80
 800deec:	08014d44 	.word	0x08014d44
 800def0:	20004f54 	.word	0x20004f54
 800def4:	200089f4 	.word	0x200089f4
 800def8:	08014d70 	.word	0x08014d70
 800defc:	08014d24 	.word	0x08014d24
 800df00:	20000aa8 	.word	0x20000aa8

0800df04 <sd_findnext>:
static FRESULT sd_findnext(DIR* dp, FILINFO* fno) {
 800df04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800df08:	4605      	mov	r5, r0
 800df0a:	460c      	mov	r4, r1
 800df0c:	f101 0719 	add.w	r7, r1, #25
    if (compare_ext(fno->fname, dp->pat)) return FR_OK;
 800df10:	f101 061a 	add.w	r6, r1, #26
  while (f_readdir(dp, fno) == FR_OK && fno->fname[0]) {
 800df14:	4621      	mov	r1, r4
 800df16:	4628      	mov	r0, r5
 800df18:	f7f7 f8ca 	bl	80050b0 <f_readdir>
 800df1c:	b9d8      	cbnz	r0, 800df56 <sd_findnext+0x52>
 800df1e:	7ea3      	ldrb	r3, [r4, #26]
 800df20:	b1cb      	cbz	r3, 800df56 <sd_findnext+0x52>
    if (fno->fattrib & AM_DIR) continue;
 800df22:	7b23      	ldrb	r3, [r4, #12]
 800df24:	f013 0310 	ands.w	r3, r3, #16
 800df28:	d1f4      	bne.n	800df14 <sd_findnext+0x10>
  while (name[i]) if (name[i++] == '.') j = i;    // Get last '.' position + 1
 800df2a:	463a      	mov	r2, r7
 800df2c:	f892 8001 	ldrb.w	r8, [r2, #1]
 800df30:	1c51      	adds	r1, r2, #1
 800df32:	f1b8 0f00 	cmp.w	r8, #0
 800df36:	d006      	beq.n	800df46 <sd_findnext+0x42>
 800df38:	f1b8 0f2e 	cmp.w	r8, #46	@ 0x2e
 800df3c:	bf04      	itt	eq
 800df3e:	3a18      	subeq	r2, #24
 800df40:	1b13      	subeq	r3, r2, r4
static FRESULT sd_findnext(DIR* dp, FILINFO* fno) {
 800df42:	460a      	mov	r2, r1
 800df44:	e7f2      	b.n	800df2c <sd_findnext+0x28>
  return j == 0 ? false : strcmpi(&name[j], ext); // Compare text after '.' and ext
 800df46:	2b00      	cmp	r3, #0
 800df48:	d0e4      	beq.n	800df14 <sd_findnext+0x10>
 800df4a:	6d29      	ldr	r1, [r5, #80]	@ 0x50
 800df4c:	18f0      	adds	r0, r6, r3
 800df4e:	f7fa fdd1 	bl	8008af4 <strcmpi>
 800df52:	b910      	cbnz	r0, 800df5a <sd_findnext+0x56>
 800df54:	e7de      	b.n	800df14 <sd_findnext+0x10>
  return FR_NO_FILE;
 800df56:	f04f 0804 	mov.w	r8, #4
}
 800df5a:	4640      	mov	r0, r8
 800df5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800df60 <input_date_time>:
  if (b)
 800df60:	2900      	cmp	r1, #0
 800df62:	d17d      	bne.n	800e060 <input_date_time+0x100>
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 800df64:	4a3f      	ldr	r2, [pc, #252]	@ (800e064 <input_date_time+0x104>)
{
 800df66:	b4f3      	push	{r0, r1, r4, r5, r6, r7}
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 800df68:	6813      	ldr	r3, [r2, #0]
 800df6a:	4c3f      	ldr	r4, [pc, #252]	@ (800e068 <input_date_time+0x108>)
 800df6c:	f003 337f 	and.w	r3, r3, #2139062143	@ 0x7f7f7f7f
 800df70:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 800df74:	9300      	str	r3, [sp, #0]
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 800df76:	6852      	ldr	r2, [r2, #4]
 800df78:	4b3c      	ldr	r3, [pc, #240]	@ (800e06c <input_date_time+0x10c>)
 800df7a:	4013      	ands	r3, r2
 800df7c:	9301      	str	r3, [sp, #4]
  for (; i < 6 && kp_buf[i] != 0; i++)
 800df7e:	4622      	mov	r2, r4
 800df80:	f814 3b01 	ldrb.w	r3, [r4], #1
 800df84:	b133      	cbz	r3, 800df94 <input_date_time+0x34>
 800df86:	3101      	adds	r1, #1
    kp_buf[i] -= '0';
 800df88:	3b30      	subs	r3, #48	@ 0x30
  for (; i < 6 && kp_buf[i] != 0; i++)
 800df8a:	2906      	cmp	r1, #6
    kp_buf[i] -= '0';
 800df8c:	f804 3c01 	strb.w	r3, [r4, #-1]
  for (; i < 6 && kp_buf[i] != 0; i++)
 800df90:	d1f6      	bne.n	800df80 <input_date_time+0x20>
 800df92:	e004      	b.n	800df9e <input_date_time+0x3e>
  for (; i < 6; i++)
 800df94:	2906      	cmp	r1, #6
 800df96:	d002      	beq.n	800df9e <input_date_time+0x3e>
    kp_buf[i] = 0;
 800df98:	5453      	strb	r3, [r2, r1]
  for (; i < 6; i++)
 800df9a:	3101      	adds	r1, #1
 800df9c:	e7fa      	b.n	800df94 <input_date_time+0x34>
    kp_buf[i] = (kp_buf[2 * i] << 4) | kp_buf[2 * i + 1]; // BCD format
 800df9e:	7813      	ldrb	r3, [r2, #0]
 800dfa0:	7854      	ldrb	r4, [r2, #1]
 800dfa2:	7891      	ldrb	r1, [r2, #2]
 800dfa4:	7915      	ldrb	r5, [r2, #4]
 800dfa6:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 800dfaa:	78d3      	ldrb	r3, [r2, #3]
 800dfac:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800dfb0:	7951      	ldrb	r1, [r2, #5]
 800dfb2:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
 800dfb6:	b2e4      	uxtb	r4, r4
 800dfb8:	b2db      	uxtb	r3, r3
 800dfba:	b2c9      	uxtb	r1, r1
  if (data == KM_RTC_DATE)
 800dfbc:	2818      	cmp	r0, #24
    kp_buf[i] = (kp_buf[2 * i] << 4) | kp_buf[2 * i + 1]; // BCD format
 800dfbe:	7014      	strb	r4, [r2, #0]
 800dfc0:	7053      	strb	r3, [r2, #1]
 800dfc2:	7091      	strb	r1, [r2, #2]
  if (data == KM_RTC_DATE)
 800dfc4:	d134      	bne.n	800e030 <input_date_time+0xd0>
    if (kp_buf[1] < 1)
 800dfc6:	b90b      	cbnz	r3, 800dfcc <input_date_time+0x6c>
      kp_buf[1] = 1;
 800dfc8:	2301      	movs	r3, #1
 800dfca:	e002      	b.n	800dfd2 <input_date_time+0x72>
    else if (kp_buf[1] > 0x12)
 800dfcc:	2b12      	cmp	r3, #18
 800dfce:	d901      	bls.n	800dfd4 <input_date_time+0x74>
      kp_buf[1] = 0x12;
 800dfd0:	2312      	movs	r3, #18
 800dfd2:	7053      	strb	r3, [r2, #1]
    uint8_t day_max = 28 + ((0b11101100000000000010111110111011001100 >> (kp_buf[1] << 1)) & 3);
 800dfd4:	7855      	ldrb	r5, [r2, #1]
    if (kp_buf[2] < 1)
 800dfd6:	b911      	cbnz	r1, 800dfde <input_date_time+0x7e>
      kp_buf[2] = 1;
 800dfd8:	2101      	movs	r1, #1
 800dfda:	7091      	strb	r1, [r2, #2]
 800dfdc:	e021      	b.n	800e022 <input_date_time+0xc2>
    uint8_t day_max = 28 + ((0b11101100000000000010111110111011001100 >> (kp_buf[1] << 1)) & 3);
 800dfde:	0068      	lsls	r0, r5, #1
 800dfe0:	4b23      	ldr	r3, [pc, #140]	@ (800e070 <input_date_time+0x110>)
 800dfe2:	f04f 0c3b 	mov.w	ip, #59	@ 0x3b
 800dfe6:	f1c0 0720 	rsb	r7, r0, #32
 800dfea:	f1b0 0620 	subs.w	r6, r0, #32
 800dfee:	fa23 f300 	lsr.w	r3, r3, r0
 800dff2:	fa0c f707 	lsl.w	r7, ip, r7
 800dff6:	ea43 0307 	orr.w	r3, r3, r7
 800dffa:	bf5c      	itt	pl
 800dffc:	fa4c f606 	asrpl.w	r6, ip, r6
 800e000:	4333      	orrpl	r3, r6
 800e002:	f003 0303 	and.w	r3, r3, #3
 800e006:	331c      	adds	r3, #28
    day_max = ((day_max / 10) << 4) | (day_max % 10); // to BCD
 800e008:	270a      	movs	r7, #10
 800e00a:	fbb3 f6f7 	udiv	r6, r3, r7
 800e00e:	0130      	lsls	r0, r6, #4
 800e010:	fb07 3316 	mls	r3, r7, r6, r3
 800e014:	b2c0      	uxtb	r0, r0
 800e016:	b2db      	uxtb	r3, r3
 800e018:	4303      	orrs	r3, r0
    else if (kp_buf[2] > day_max)
 800e01a:	428b      	cmp	r3, r1
      kp_buf[2] = day_max;
 800e01c:	bf3c      	itt	cc
 800e01e:	7093      	strbcc	r3, [r2, #2]
 800e020:	4619      	movcc	r1, r3
    time[6] = kp_buf[0]; // year
 800e022:	f88d 4006 	strb.w	r4, [sp, #6]
    time[5] = kp_buf[1]; // month
 800e026:	f88d 5005 	strb.w	r5, [sp, #5]
    time[4] = kp_buf[2]; // day
 800e02a:	f88d 1004 	strb.w	r1, [sp, #4]
 800e02e:	e011      	b.n	800e054 <input_date_time+0xf4>
    if (kp_buf[0] > 0x23)
 800e030:	2c23      	cmp	r4, #35	@ 0x23
 800e032:	bf28      	it	cs
 800e034:	2423      	movcs	r4, #35	@ 0x23
    if (kp_buf[1] > 0x59)
 800e036:	2b59      	cmp	r3, #89	@ 0x59
 800e038:	bf28      	it	cs
 800e03a:	2359      	movcs	r3, #89	@ 0x59
    if (kp_buf[2] > 0x59)
 800e03c:	2959      	cmp	r1, #89	@ 0x59
 800e03e:	bf28      	it	cs
 800e040:	2159      	movcs	r1, #89	@ 0x59
 800e042:	7014      	strb	r4, [r2, #0]
    if (kp_buf[1] > 0x59)
 800e044:	7053      	strb	r3, [r2, #1]
    if (kp_buf[2] > 0x59)
 800e046:	7091      	strb	r1, [r2, #2]
    time[2] = kp_buf[0]; // hour
 800e048:	f88d 4002 	strb.w	r4, [sp, #2]
    time[1] = kp_buf[1]; // min
 800e04c:	f88d 3001 	strb.w	r3, [sp, #1]
    time[0] = kp_buf[2]; // sec
 800e050:	f88d 1000 	strb.w	r1, [sp]
  rtc_set_time(dt_buf[1], dt_buf[0]);
 800e054:	e9dd 1000 	ldrd	r1, r0, [sp]
}
 800e058:	b002      	add	sp, #8
 800e05a:	bcf0      	pop	{r4, r5, r6, r7}
  rtc_set_time(dt_buf[1], dt_buf[0]);
 800e05c:	f002 be4e 	b.w	8010cfc <rtc_set_time>
 800e060:	4770      	bx	lr
 800e062:	bf00      	nop
 800e064:	40002800 	.word	0x40002800
 800e068:	200089c8 	.word	0x200089c8
 800e06c:	00ff1f3f 	.word	0x00ff1f3f
 800e070:	000beecc 	.word	0x000beecc

0800e074 <touch_start_watchdog>:
{
 800e074:	b510      	push	{r4, lr}
  if (touch_status_flag & TOUCH_INTERRUPT_ENABLED)
 800e076:	4a06      	ldr	r2, [pc, #24]	@ (800e090 <touch_start_watchdog+0x1c>)
 800e078:	7813      	ldrb	r3, [r2, #0]
 800e07a:	f013 0401 	ands.w	r4, r3, #1
 800e07e:	d106      	bne.n	800e08e <touch_start_watchdog+0x1a>
  touch_status_flag ^= TOUCH_INTERRUPT_ENABLED;
 800e080:	f083 0301 	eor.w	r3, r3, #1
 800e084:	7013      	strb	r3, [r2, #0]
  adc_start_analog_watchdog();
 800e086:	f002 fd6f 	bl	8010b68 <adc_start_analog_watchdog>
  touch_remote = REMOTE_NONE;
 800e08a:	4b02      	ldr	r3, [pc, #8]	@ (800e094 <touch_start_watchdog+0x20>)
 800e08c:	701c      	strb	r4, [r3, #0]
}
 800e08e:	bd10      	pop	{r4, pc}
 800e090:	200089e1 	.word	0x200089e1
 800e094:	200089bc 	.word	0x200089bc

0800e098 <keypad_click>:
  int c = keypads->buttons[key].c; // !!! Use key + 1 (zero key index used or size define)
 800e098:	4b81      	ldr	r3, [pc, #516]	@ (800e2a0 <keypad_click+0x208>)
{
 800e09a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  int c = keypads->buttons[key].c; // !!! Use key + 1 (zero key index used or size define)
 800e09e:	681f      	ldr	r7, [r3, #0]
  int index = strlen(kp_buf);
 800e0a0:	4e80      	ldr	r6, [pc, #512]	@ (800e2a4 <keypad_click+0x20c>)
  int c = keypads->buttons[key].c; // !!! Use key + 1 (zero key index used or size define)
 800e0a2:	eb07 0040 	add.w	r0, r7, r0, lsl #1
 800e0a6:	78c4      	ldrb	r4, [r0, #3]
  int index = strlen(kp_buf);
 800e0a8:	4630      	mov	r0, r6
 800e0aa:	f7f2 fc49 	bl	8000940 <strlen>
  int result = keypads->type == NUM_KEYBOARD ? num_keypad_click(c, index) : txt_keypad_click(c, index);
 800e0ae:	787a      	ldrb	r2, [r7, #1]
 800e0b0:	2a00      	cmp	r2, #0
 800e0b2:	f040 80c4 	bne.w	800e23e <keypad_click+0x1a6>
  if (c >= KP_k && c <= KP_PERCENT)
 800e0b6:	f1a4 030d 	sub.w	r3, r4, #13
 800e0ba:	2b09      	cmp	r3, #9
 800e0bc:	4605      	mov	r5, r0
 800e0be:	d832      	bhi.n	800e126 <keypad_click+0x8e>
    if (kp_index == 0)
 800e0c0:	2800      	cmp	r0, #0
 800e0c2:	f000 80e7 	beq.w	800e294 <keypad_click+0x1fc>
    if (c >= KP_k && c <= KP_G)
 800e0c6:	2b02      	cmp	r3, #2
 800e0c8:	d81c      	bhi.n	800e104 <keypad_click+0x6c>
      int i = period_pos();
 800e0ca:	f7ff f947 	bl	800d35c <period_pos>
      uint16_t scale = c - KP_k + 1;
 800e0ce:	3c0c      	subs	r4, #12
 800e0d0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800e0d4:	b2a4      	uxth	r4, r4
      if (scale + i > NUMINPUT_LEN)
 800e0d6:	1823      	adds	r3, r4, r0
 800e0d8:	2b0c      	cmp	r3, #12
        scale = NUMINPUT_LEN - i;
 800e0da:	bfc4      	itt	gt
 800e0dc:	f1c0 040c 	rsbgt	r4, r0, #12
 800e0e0:	b2a4      	uxthgt	r4, r4
 800e0e2:	4430      	add	r0, r6
          kp_buf[i + 2] = 0;
 800e0e4:	2100      	movs	r1, #0
        char v = kp_buf[i + 1];
 800e0e6:	7843      	ldrb	r3, [r0, #1]
        if (v == 0 || kp_buf[i] == 0)
 800e0e8:	7802      	ldrb	r2, [r0, #0]
 800e0ea:	b103      	cbz	r3, 800e0ee <keypad_click+0x56>
 800e0ec:	b90a      	cbnz	r2, 800e0f2 <keypad_click+0x5a>
          kp_buf[i + 2] = 0;
 800e0ee:	7081      	strb	r1, [r0, #2]
          v = '0';
 800e0f0:	2330      	movs	r3, #48	@ 0x30
        kp_buf[i + 1] = kp_buf[i];
 800e0f2:	f800 2f01 	strb.w	r2, [r0, #1]!
      } while (--scale);
 800e0f6:	3c01      	subs	r4, #1
 800e0f8:	b2a4      	uxth	r4, r4
        kp_buf[i++] = v;
 800e0fa:	f800 3c01 	strb.w	r3, [r0, #-1]
      } while (--scale);
 800e0fe:	2c00      	cmp	r4, #0
 800e100:	d1f1      	bne.n	800e0e6 <keypad_click+0x4e>
 800e102:	e0c2      	b.n	800e28a <keypad_click+0x1f2>
    else if (c >= KP_m && c <= KP_p)
 800e104:	f1a4 0310 	sub.w	r3, r4, #16
 800e108:	2b03      	cmp	r3, #3
 800e10a:	f200 80be 	bhi.w	800e28a <keypad_click+0x1f2>
      const char prefix[] = {'m', 'u', 'n', 'p'};
 800e10e:	4b66      	ldr	r3, [pc, #408]	@ (800e2a8 <keypad_click+0x210>)
 800e110:	9301      	str	r3, [sp, #4]
      kp_buf[kp_index] = prefix[c - KP_m];
 800e112:	f104 0308 	add.w	r3, r4, #8
 800e116:	eb0d 0403 	add.w	r4, sp, r3
      kp_buf[kp_index + 1] = 0;
 800e11a:	4435      	add	r5, r6
      kp_buf[kp_index] = prefix[c - KP_m];
 800e11c:	f814 3c14 	ldrb.w	r3, [r4, #-20]
 800e120:	5433      	strb	r3, [r6, r0]
      kp_buf[kp_index + 1] = 0;
 800e122:	706a      	strb	r2, [r5, #1]
  if (result == K_DONE)
 800e124:	e0b1      	b.n	800e28a <keypad_click+0x1f2>
  int maxlength = (1 << keypad_mode) & ((1 << KM_RTC_DATE) | (1 << KM_RTC_TIME)) ? 6 : NUMINPUT_LEN;
 800e126:	4b61      	ldr	r3, [pc, #388]	@ (800e2ac <keypad_click+0x214>)
 800e128:	781a      	ldrb	r2, [r3, #0]
 800e12a:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
 800e12e:	4113      	asrs	r3, r2
 800e130:	f013 0701 	ands.w	r7, r3, #1
 800e134:	bf0c      	ite	eq
 800e136:	f04f 080c 	moveq.w	r8, #12
 800e13a:	f04f 0806 	movne.w	r8, #6
  if (c == KP_BS)
 800e13e:	2c0c      	cmp	r4, #12
 800e140:	d101      	bne.n	800e146 <keypad_click+0xae>
    if (kp_index == 0)
 800e142:	b958      	cbnz	r0, 800e15c <keypad_click+0xc4>
 800e144:	e0a6      	b.n	800e294 <keypad_click+0x1fc>
  else if (c == KP_MINUS)
 800e146:	2c0b      	cmp	r4, #11
 800e148:	d113      	bne.n	800e172 <keypad_click+0xda>
    if (kp_buf[0] == '-')
 800e14a:	7833      	ldrb	r3, [r6, #0]
 800e14c:	2b2d      	cmp	r3, #45	@ 0x2d
        kp_buf[i] = kp_buf[i + 1];
 800e14e:	f04f 020c 	mov.w	r2, #12
    if (kp_buf[0] == '-')
 800e152:	d105      	bne.n	800e160 <keypad_click+0xc8>
        kp_buf[i] = kp_buf[i + 1];
 800e154:	1c71      	adds	r1, r6, #1
 800e156:	4630      	mov	r0, r6
 800e158:	f003 fb4e 	bl	80117f8 <memmove>
      --kp_index;
 800e15c:	3d01      	subs	r5, #1
 800e15e:	e01b      	b.n	800e198 <keypad_click+0x100>
        kp_buf[i] = kp_buf[i - 1];
 800e160:	4631      	mov	r1, r6
 800e162:	1c70      	adds	r0, r6, #1
 800e164:	f003 fb48 	bl	80117f8 <memmove>
      kp_buf[0] = '-';
 800e168:	232d      	movs	r3, #45	@ 0x2d
      if (kp_index < maxlength)
 800e16a:	4545      	cmp	r5, r8
      kp_buf[0] = '-';
 800e16c:	7033      	strb	r3, [r6, #0]
      if (kp_index < maxlength)
 800e16e:	da13      	bge.n	800e198 <keypad_click+0x100>
 800e170:	e011      	b.n	800e196 <keypad_click+0xfe>
  else if (kp_index < maxlength)
 800e172:	4540      	cmp	r0, r8
 800e174:	da10      	bge.n	800e198 <keypad_click+0x100>
    if (c <= KP_9)
 800e176:	2c09      	cmp	r4, #9
 800e178:	dc02      	bgt.n	800e180 <keypad_click+0xe8>
      kp_buf[kp_index++] = '0' + c;
 800e17a:	3430      	adds	r4, #48	@ 0x30
 800e17c:	5434      	strb	r4, [r6, r0]
 800e17e:	e00a      	b.n	800e196 <keypad_click+0xfe>
    else if (c == KP_PERIOD && kp_index == period_pos() && maxlength == NUMINPUT_LEN) // append period if there are no period and for num input (skip for date/time)
 800e180:	2c0a      	cmp	r4, #10
 800e182:	d109      	bne.n	800e198 <keypad_click+0x100>
 800e184:	f7ff f8ea 	bl	800d35c <period_pos>
 800e188:	4285      	cmp	r5, r0
 800e18a:	d105      	bne.n	800e198 <keypad_click+0x100>
 800e18c:	f1b8 0f0c 	cmp.w	r8, #12
 800e190:	d102      	bne.n	800e198 <keypad_click+0x100>
      kp_buf[kp_index++] = '.';
 800e192:	232e      	movs	r3, #46	@ 0x2e
 800e194:	5573      	strb	r3, [r6, r5]
 800e196:	3501      	adds	r5, #1
  kp_buf[kp_index] = '\0';
 800e198:	2300      	movs	r3, #0
 800e19a:	5573      	strb	r3, [r6, r5]
  if ((1 << keypad_mode) & ((1 << KM_RTC_DATE) | (1 << KM_RTC_TIME)))
 800e19c:	b987      	cbnz	r7, 800e1c0 <keypad_click+0x128>
    xsim = (0b00100100100100100 >> (2 - (period_pos() % 3))) & (~1);
 800e19e:	f7ff f8dd 	bl	800d35c <period_pos>
 800e1a2:	2303      	movs	r3, #3
 800e1a4:	fbb0 f3f3 	udiv	r3, r0, r3
 800e1a8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800e1ac:	1ac0      	subs	r0, r0, r3
 800e1ae:	f1c0 0002 	rsb	r0, r0, #2
 800e1b2:	f644 1424 	movw	r4, #18724	@ 0x4924
 800e1b6:	4104      	asrs	r4, r0
 800e1b8:	f024 0401 	bic.w	r4, r4, #1
 800e1bc:	b2a4      	uxth	r4, r4
 800e1be:	e000      	b.n	800e1c2 <keypad_click+0x12a>
    xsim = 0b01010100;
 800e1c0:	2454      	movs	r4, #84	@ 0x54
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800e1c2:	2114      	movs	r1, #20
 800e1c4:	2013      	movs	r0, #19
 800e1c6:	f001 ff9b 	bl	8010100 <lcd_set_colors>
  while (*buf)
 800e1ca:	4e36      	ldr	r6, [pc, #216]	@ (800e2a4 <keypad_click+0x20c>)
  uint16_t x = 14 + FONT_STR_WIDTH(12), space;
 800e1cc:	f04f 0862 	mov.w	r8, #98	@ 0x62
  while (*buf)
 800e1d0:	f816 7b01 	ldrb.w	r7, [r6], #1
 800e1d4:	b34f      	cbz	r7, 800e22a <keypad_click+0x192>
    if (c == '.')
 800e1d6:	2f2e      	cmp	r7, #46	@ 0x2e
 800e1d8:	d103      	bne.n	800e1e2 <keypad_click+0x14a>
      xsim <<= 4;
 800e1da:	0124      	lsls	r4, r4, #4
 800e1dc:	b2a4      	uxth	r4, r4
      c = KP_PERIOD;
 800e1de:	270a      	movs	r7, #10
 800e1e0:	e009      	b.n	800e1f6 <keypad_click+0x15e>
    else if (c == '-')
 800e1e2:	2f2d      	cmp	r7, #45	@ 0x2d
 800e1e4:	d104      	bne.n	800e1f0 <keypad_click+0x158>
      xsim &= ~3;
 800e1e6:	f024 0403 	bic.w	r4, r4, #3
 800e1ea:	b2a4      	uxth	r4, r4
      c = KP_MINUS;
 800e1ec:	270b      	movs	r7, #11
 800e1ee:	e002      	b.n	800e1f6 <keypad_click+0x15e>
    else if (c >= '0' && c <= '9')
 800e1f0:	3f30      	subs	r7, #48	@ 0x30
 800e1f2:	2f09      	cmp	r7, #9
 800e1f4:	d8ec      	bhi.n	800e1d0 <keypad_click+0x138>
    space = 2 + 10 * (xsim & 1);
 800e1f6:	f004 0501 	and.w	r5, r4, #1
 800e1fa:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 800e1fe:	006d      	lsls	r5, r5, #1
 800e200:	3502      	adds	r5, #2
    lcd_fill(x, y, space, NUM_FONT_GET_HEIGHT);
 800e202:	462a      	mov	r2, r5
    x += space;
 800e204:	4445      	add	r5, r8
    lcd_fill(x, y, space, NUM_FONT_GET_HEIGHT);
 800e206:	4640      	mov	r0, r8
 800e208:	2316      	movs	r3, #22
 800e20a:	f240 1125 	movw	r1, #293	@ 0x125
    x += space;
 800e20e:	b2ad      	uxth	r5, r5
    lcd_fill(x, y, space, NUM_FONT_GET_HEIGHT);
 800e210:	f001 fe70 	bl	800fef4 <lcd_fill>
    lcd_drawfont(c, x, y);
 800e214:	4629      	mov	r1, r5
 800e216:	f240 1225 	movw	r2, #293	@ 0x125
 800e21a:	b2f8      	uxtb	r0, r7
    x += NUM_FONT_GET_WIDTH;
 800e21c:	3510      	adds	r5, #16
    lcd_drawfont(c, x, y);
 800e21e:	f002 f905 	bl	801042c <lcd_drawfont>
    xsim >>= 1;
 800e222:	0864      	lsrs	r4, r4, #1
    x += NUM_FONT_GET_WIDTH;
 800e224:	fa1f f885 	uxth.w	r8, r5
 800e228:	e7d2      	b.n	800e1d0 <keypad_click+0x138>
  lcd_fill(x, y, NUM_FONT_GET_WIDTH + 2 + 10, NUM_FONT_GET_HEIGHT);
 800e22a:	2316      	movs	r3, #22
 800e22c:	221c      	movs	r2, #28
 800e22e:	f240 1125 	movw	r1, #293	@ 0x125
 800e232:	4640      	mov	r0, r8
}
 800e234:	b002      	add	sp, #8
 800e236:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  lcd_fill(x, y, NUM_FONT_GET_WIDTH + 2 + 10, NUM_FONT_GET_HEIGHT);
 800e23a:	f001 be5b 	b.w	800fef4 <lcd_fill>
  if (c == S_ENTER[0])
 800e23e:	2c16      	cmp	r4, #22
 800e240:	d101      	bne.n	800e246 <keypad_click+0x1ae>
    return kp_index == 0 ? K_CANCEL : K_DONE;
 800e242:	b338      	cbz	r0, 800e294 <keypad_click+0x1fc>
 800e244:	e021      	b.n	800e28a <keypad_click+0x1f2>
  if (c == S_LARROW[0])
 800e246:	2c1a      	cmp	r4, #26
 800e248:	d102      	bne.n	800e250 <keypad_click+0x1b8>
    if (kp_index == 0)
 800e24a:	b318      	cbz	r0, 800e294 <keypad_click+0x1fc>
    --kp_index;
 800e24c:	1e42      	subs	r2, r0, #1
 800e24e:	e004      	b.n	800e25a <keypad_click+0x1c2>
  else if (kp_index < TXTINPUT_LEN)
 800e250:	2812      	cmp	r0, #18
    kp_buf[kp_index++] = c;
 800e252:	bf1a      	itte	ne
 800e254:	5434      	strbne	r4, [r6, r0]
 800e256:	1c42      	addne	r2, r0, #1
 800e258:	4602      	moveq	r2, r0
  kp_buf[kp_index] = '\0';
 800e25a:	2300      	movs	r3, #0
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800e25c:	2114      	movs	r1, #20
 800e25e:	2013      	movs	r0, #19
  kp_buf[kp_index] = '\0';
 800e260:	54b3      	strb	r3, [r6, r2]
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800e262:	f001 ff4d 	bl	8010100 <lcd_set_colors>
  lcd_fill(x, y, FONT_STR_WIDTH(20) * n, FONT_GET_HEIGHT * n);
 800e266:	2316      	movs	r3, #22
 800e268:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800e26c:	f240 1125 	movw	r1, #293	@ 0x125
 800e270:	2031      	movs	r0, #49	@ 0x31
 800e272:	f001 fe3f 	bl	800fef4 <lcd_fill>
  lcd_drawstring_size(buf, x, y, n);
 800e276:	480b      	ldr	r0, [pc, #44]	@ (800e2a4 <keypad_click+0x20c>)
 800e278:	2302      	movs	r3, #2
 800e27a:	f240 1225 	movw	r2, #293	@ 0x125
 800e27e:	2131      	movs	r1, #49	@ 0x31
}
 800e280:	b002      	add	sp, #8
 800e282:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  lcd_drawstring_size(buf, x, y, n);
 800e286:	f002 b8e9 	b.w	801045c <lcd_drawstring_size>
    ui_keyboard_cb(keypad_mode, NULL); // apply input done
 800e28a:	4b08      	ldr	r3, [pc, #32]	@ (800e2ac <keypad_click+0x214>)
 800e28c:	2100      	movs	r1, #0
 800e28e:	7818      	ldrb	r0, [r3, #0]
 800e290:	f7ff f858 	bl	800d344 <ui_keyboard_cb>
}
 800e294:	b002      	add	sp, #8
 800e296:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ui_mode_normal();
 800e29a:	f7ff ba8b 	b.w	800d7b4 <ui_mode_normal>
 800e29e:	bf00      	nop
 800e2a0:	200089c0 	.word	0x200089c0
 800e2a4:	200089c8 	.word	0x200089c8
 800e2a8:	706e756d 	.word	0x706e756d
 800e2ac:	200089bf 	.word	0x200089bf

0800e2b0 <ui_keypad_touch>:
{
 800e2b0:	b570      	push	{r4, r5, r6, lr}
  const keypad_pos_t *p = &key_pos[keypads->type];
 800e2b2:	4b21      	ldr	r3, [pc, #132]	@ (800e338 <ui_keypad_touch+0x88>)
  if (touch_x < p->x_offs || touch_y < p->y_offs)
 800e2b4:	4a21      	ldr	r2, [pc, #132]	@ (800e33c <ui_keypad_touch+0x8c>)
  const keypad_pos_t *p = &key_pos[keypads->type];
 800e2b6:	681d      	ldr	r5, [r3, #0]
 800e2b8:	786b      	ldrb	r3, [r5, #1]
  if (touch_x < p->x_offs || touch_y < p->y_offs)
 800e2ba:	f832 4033 	ldrh.w	r4, [r2, r3, lsl #3]
 800e2be:	4284      	cmp	r4, r0
 800e2c0:	dc38      	bgt.n	800e334 <ui_keypad_touch+0x84>
 800e2c2:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800e2c6:	8853      	ldrh	r3, [r2, #2]
 800e2c8:	428b      	cmp	r3, r1
 800e2ca:	dc33      	bgt.n	800e334 <ui_keypad_touch+0x84>
  touch_x -= p->x_offs;
 800e2cc:	1b00      	subs	r0, r0, r4
  touch_y -= p->y_offs;
 800e2ce:	1acb      	subs	r3, r1, r3
  touch_y /= p->height;
 800e2d0:	88d1      	ldrh	r1, [r2, #6]
  touch_x /= p->width;
 800e2d2:	8892      	ldrh	r2, [r2, #4]
 800e2d4:	fbb0 f0f2 	udiv	r0, r0, r2
  for (int i = 0; i < keypads->size; i++)
 800e2d8:	462a      	mov	r2, r5
  touch_y /= p->height;
 800e2da:	fbb3 f3f1 	udiv	r3, r3, r1
  uint8_t pos = (touch_y & 0x0F) | (touch_x << 4);
 800e2de:	f003 030f 	and.w	r3, r3, #15
 800e2e2:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  for (int i = 0; i < keypads->size; i++)
 800e2e6:	f812 1b02 	ldrb.w	r1, [r2], #2
  uint8_t pos = (touch_y & 0x0F) | (touch_x << 4);
 800e2ea:	b2db      	uxtb	r3, r3
  for (int i = 0; i < keypads->size; i++)
 800e2ec:	2400      	movs	r4, #0
 800e2ee:	42a1      	cmp	r1, r4
 800e2f0:	dd20      	ble.n	800e334 <ui_keypad_touch+0x84>
    if (keypads->buttons[i].pos != pos)
 800e2f2:	f812 0014 	ldrb.w	r0, [r2, r4, lsl #1]
 800e2f6:	4298      	cmp	r0, r3
 800e2f8:	d001      	beq.n	800e2fe <ui_keypad_touch+0x4e>
  for (int i = 0; i < keypads->size; i++)
 800e2fa:	3401      	adds	r4, #1
 800e2fc:	e7f7      	b.n	800e2ee <ui_keypad_touch+0x3e>
    if (keypads->buttons[i].c == KP_EMPTY)
 800e2fe:	eb05 0544 	add.w	r5, r5, r4, lsl #1
 800e302:	78eb      	ldrb	r3, [r5, #3]
 800e304:	2bff      	cmp	r3, #255	@ 0xff
 800e306:	d015      	beq.n	800e334 <ui_keypad_touch+0x84>
    int old = selection;
 800e308:	4d0d      	ldr	r5, [pc, #52]	@ (800e340 <ui_keypad_touch+0x90>)
 800e30a:	f995 6000 	ldrsb.w	r6, [r5]
    keypad_draw_button(selection = i); // draw new focus
 800e30e:	b260      	sxtb	r0, r4
 800e310:	7028      	strb	r0, [r5, #0]
 800e312:	f7ff fa6b 	bl	800d7ec <keypad_draw_button>
    keypad_draw_button(old);           // Erase old focus
 800e316:	4630      	mov	r0, r6
 800e318:	f7ff fa68 	bl	800d7ec <keypad_draw_button>
    touch_wait_release();
 800e31c:	f7ff f8dc 	bl	800d4d8 <touch_wait_release>
    keypad_draw_button(i); // erase new focus
 800e320:	4620      	mov	r0, r4
    selection = -1;
 800e322:	23ff      	movs	r3, #255	@ 0xff
 800e324:	702b      	strb	r3, [r5, #0]
    keypad_draw_button(i); // erase new focus
 800e326:	f7ff fa61 	bl	800d7ec <keypad_draw_button>
    keypad_click(i);       // Process input
 800e32a:	4620      	mov	r0, r4
}
 800e32c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    keypad_click(i);       // Process input
 800e330:	f7ff beb2 	b.w	800e098 <keypad_click>
}
 800e334:	bd70      	pop	{r4, r5, r6, pc}
 800e336:	bf00      	nop
 800e338:	200089c0 	.word	0x200089c0
 800e33c:	08014b64 	.word	0x08014b64
 800e340:	200003f0 	.word	0x200003f0

0800e344 <ui_keypad_lever>:
  if (status == EVT_BUTTON_SINGLE_CLICK)
 800e344:	2801      	cmp	r0, #1
{
 800e346:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e34a:	4d22      	ldr	r5, [pc, #136]	@ (800e3d4 <ui_keypad_lever+0x90>)
  if (status == EVT_BUTTON_SINGLE_CLICK)
 800e34c:	d107      	bne.n	800e35e <ui_keypad_lever+0x1a>
    if (selection >= 0) // Process input
 800e34e:	f995 0000 	ldrsb.w	r0, [r5]
 800e352:	2800      	cmp	r0, #0
 800e354:	db3c      	blt.n	800e3d0 <ui_keypad_lever+0x8c>
}
 800e356:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      keypad_click(selection);
 800e35a:	f7ff be9d 	b.w	800e098 <keypad_click>
  int keypads_last_index = keypads->size - 1;
 800e35e:	4e1e      	ldr	r6, [pc, #120]	@ (800e3d8 <ui_keypad_lever+0x94>)
 800e360:	6833      	ldr	r3, [r6, #0]
 800e362:	781c      	ldrb	r4, [r3, #0]
 800e364:	4602      	mov	r2, r0
 800e366:	3c01      	subs	r4, #1
    int old = selection;
 800e368:	f995 3000 	ldrsb.w	r3, [r5]
    } while (keypads->buttons[selection].c == KP_EMPTY); // Skip empty
 800e36c:	f8d6 e000 	ldr.w	lr, [r6]
      if ((status & EVT_DOWN) && --selection < 0)
 800e370:	f002 0c20 	and.w	ip, r2, #32
    int old = selection;
 800e374:	4618      	mov	r0, r3
    } while (keypads->buttons[selection].c == KP_EMPTY); // Skip empty
 800e376:	2100      	movs	r1, #0
        selection = keypads_last_index;
 800e378:	b267      	sxtb	r7, r4
      if ((status & EVT_UP) && ++selection > keypads_last_index)
 800e37a:	f002 0210 	and.w	r2, r2, #16
      if ((status & EVT_DOWN) && --selection < 0)
 800e37e:	f1bc 0f00 	cmp.w	ip, #0
 800e382:	d005      	beq.n	800e390 <ui_keypad_lever+0x4c>
 800e384:	3b01      	subs	r3, #1
 800e386:	b25b      	sxtb	r3, r3
 800e388:	2b00      	cmp	r3, #0
        selection = keypads_last_index;
 800e38a:	bfb8      	it	lt
 800e38c:	463b      	movlt	r3, r7
 800e38e:	2101      	movs	r1, #1
      if ((status & EVT_UP) && ++selection > keypads_last_index)
 800e390:	b132      	cbz	r2, 800e3a0 <ui_keypad_lever+0x5c>
 800e392:	3301      	adds	r3, #1
 800e394:	b25b      	sxtb	r3, r3
 800e396:	42a3      	cmp	r3, r4
 800e398:	f04f 0101 	mov.w	r1, #1
        selection = 0;
 800e39c:	bfc8      	it	gt
 800e39e:	2300      	movgt	r3, #0
    } while (keypads->buttons[selection].c == KP_EMPTY); // Skip empty
 800e3a0:	eb0e 0843 	add.w	r8, lr, r3, lsl #1
 800e3a4:	f898 8003 	ldrb.w	r8, [r8, #3]
 800e3a8:	f1b8 0fff 	cmp.w	r8, #255	@ 0xff
 800e3ac:	d0e7      	beq.n	800e37e <ui_keypad_lever+0x3a>
 800e3ae:	b101      	cbz	r1, 800e3b2 <ui_keypad_lever+0x6e>
 800e3b0:	702b      	strb	r3, [r5, #0]
    keypad_draw_button(old);
 800e3b2:	f7ff fa1b 	bl	800d7ec <keypad_draw_button>
    keypad_draw_button(selection);
 800e3b6:	f995 0000 	ldrsb.w	r0, [r5]
 800e3ba:	f7ff fa17 	bl	800d7ec <keypad_draw_button>
    chThdSleepMilliseconds(100);
 800e3be:	f242 7010 	movw	r0, #10000	@ 0x2710
 800e3c2:	f7f2 fd65 	bl	8000e90 <chThdSleep>
  } while ((status = btn_wait_release()) != 0);
 800e3c6:	f7ff f8c3 	bl	800d550 <btn_wait_release>
 800e3ca:	4602      	mov	r2, r0
 800e3cc:	2800      	cmp	r0, #0
 800e3ce:	d1cb      	bne.n	800e368 <ui_keypad_lever+0x24>
}
 800e3d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e3d4:	200003f0 	.word	0x200003f0
 800e3d8:	200089c0 	.word	0x200089c0

0800e3dc <menu_draw>:
{
 800e3dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  menu_draw_buttons(menu_stack[menu_current_level], mask);
 800e3e0:	4b54      	ldr	r3, [pc, #336]	@ (800e534 <menu_draw+0x158>)
 800e3e2:	f8df 8164 	ldr.w	r8, [pc, #356]	@ 800e548 <menu_draw+0x16c>
 800e3e6:	781a      	ldrb	r2, [r3, #0]
 800e3e8:	4b53      	ldr	r3, [pc, #332]	@ (800e538 <menu_draw+0x15c>)
 800e3ea:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
{
 800e3ee:	b08d      	sub	sp, #52	@ 0x34
 800e3f0:	4681      	mov	r9, r0
  int y = MENU_BUTTON_Y_OFFSET;
 800e3f2:	f04f 0b01 	mov.w	fp, #1
  for (i = 0; i < MENU_BUTTON_MAX && m; i++, m = menu_next_item(m), y += menu_button_height)
 800e3f6:	2600      	movs	r6, #0
 800e3f8:	2c00      	cmp	r4, #0
 800e3fa:	f000 8086 	beq.w	800e50a <menu_draw+0x12e>
    if ((mask & (1 << i)) == 0)
 800e3fe:	2301      	movs	r3, #1
 800e400:	40b3      	lsls	r3, r6
 800e402:	ea13 0f09 	tst.w	r3, r9
 800e406:	d074      	beq.n	800e4f2 <menu_draw+0x116>
    button.fg = LCD_MENU_TEXT_COLOR;
 800e408:	2304      	movs	r3, #4
 800e40a:	f88d 3009 	strb.w	r3, [sp, #9]
    button.icon = BUTTON_ICON_NONE;
 800e40e:	23ff      	movs	r3, #255	@ 0xff
 800e410:	f88d 300b 	strb.w	r3, [sp, #11]
    if (ui_mode == UI_MENU && i == selection)
 800e414:	4b49      	ldr	r3, [pc, #292]	@ (800e53c <menu_draw+0x160>)
 800e416:	781b      	ldrb	r3, [r3, #0]
 800e418:	2b01      	cmp	r3, #1
 800e41a:	d104      	bne.n	800e426 <menu_draw+0x4a>
 800e41c:	4b48      	ldr	r3, [pc, #288]	@ (800e540 <menu_draw+0x164>)
 800e41e:	f993 3000 	ldrsb.w	r3, [r3]
 800e422:	429e      	cmp	r6, r3
 800e424:	d002      	beq.n	800e42c <menu_draw+0x50>
 800e426:	2203      	movs	r2, #3
 800e428:	2391      	movs	r3, #145	@ 0x91
 800e42a:	e001      	b.n	800e430 <menu_draw+0x54>
 800e42c:	2205      	movs	r2, #5
 800e42e:	2361      	movs	r3, #97	@ 0x61
      button.bg = LCD_MENU_ACTIVE_COLOR;
 800e430:	f88d 2008 	strb.w	r2, [sp, #8]
      button.border = MENU_BUTTON_BORDER | BUTTON_BORDER_FALLING;
 800e434:	f88d 300a 	strb.w	r3, [sp, #10]
    if (m->type == MT_ADV_CALLBACK)
 800e438:	7823      	ldrb	r3, [r4, #0]
 800e43a:	2b03      	cmp	r3, #3
 800e43c:	f10d 0a08 	add.w	sl, sp, #8
 800e440:	d116      	bne.n	800e470 <menu_draw+0x94>
      button.label[0] = 0;
 800e442:	2300      	movs	r3, #0
 800e444:	f88d 3010 	strb.w	r3, [sp, #16]
      if (m->reference)
 800e448:	f8d4 3006 	ldr.w	r3, [r4, #6]
 800e44c:	b943      	cbnz	r3, 800e460 <menu_draw+0x84>
        plot_printf(button.label, sizeof(button.label), m->label, button.p1.u);
 800e44e:	9b03      	ldr	r3, [sp, #12]
 800e450:	f8d4 2002 	ldr.w	r2, [r4, #2]
 800e454:	2120      	movs	r1, #32
 800e456:	a804      	add	r0, sp, #16
 800e458:	f7f4 fc34 	bl	8002cc4 <plot_printf>
      text = button.label;
 800e45c:	ad04      	add	r5, sp, #16
 800e45e:	e009      	b.n	800e474 <menu_draw+0x98>
        ((menuaction_acb_t)m->reference)(m->data, &button);
 800e460:	7860      	ldrb	r0, [r4, #1]
 800e462:	4651      	mov	r1, sl
 800e464:	4798      	blx	r3
      if (button.label[0] == 0)
 800e466:	f89d 3010 	ldrb.w	r3, [sp, #16]
 800e46a:	2b00      	cmp	r3, #0
 800e46c:	d1f6      	bne.n	800e45c <menu_draw+0x80>
 800e46e:	e7ee      	b.n	800e44e <menu_draw+0x72>
      text = m->label;
 800e470:	f8d4 5002 	ldr.w	r5, [r4, #2]
    ui_draw_button(LCD_WIDTH - MENU_BUTTON_WIDTH, y, MENU_BUTTON_WIDTH, menu_button_height, &button);
 800e474:	f8cd a000 	str.w	sl, [sp]
 800e478:	fa1f f78b 	uxth.w	r7, fp
 800e47c:	225b      	movs	r2, #91	@ 0x5b
 800e47e:	f8b8 3000 	ldrh.w	r3, [r8]
 800e482:	4639      	mov	r1, r7
 800e484:	f240 1085 	movw	r0, #389	@ 0x185
 800e488:	f7ff f8a8 	bl	800d5dc <ui_draw_button>
    if (button.icon >= 0)
 800e48c:	f99d 200b 	ldrsb.w	r2, [sp, #11]
 800e490:	2a00      	cmp	r2, #0
 800e492:	db15      	blt.n	800e4c0 <menu_draw+0xe4>
      lcd_blitBitmap(LCD_WIDTH - MENU_BUTTON_WIDTH + MENU_BUTTON_BORDER + MENU_ICON_OFFSET, y + (menu_button_height - ICON_HEIGHT) / 2, ICON_WIDTH, ICON_HEIGHT, ICON_GET_DATA(button.icon));
 800e494:	f8b8 1000 	ldrh.w	r1, [r8]
 800e498:	482a      	ldr	r0, [pc, #168]	@ (800e544 <menu_draw+0x168>)
 800e49a:	390b      	subs	r1, #11
 800e49c:	2316      	movs	r3, #22
 800e49e:	fb02 0303 	mla	r3, r2, r3, r0
 800e4a2:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800e4a6:	9300      	str	r3, [sp, #0]
 800e4a8:	eb07 0161 	add.w	r1, r7, r1, asr #1
 800e4ac:	230b      	movs	r3, #11
 800e4ae:	f44f 70c5 	mov.w	r0, #394	@ 0x18a
 800e4b2:	461a      	mov	r2, r3
 800e4b4:	b289      	uxth	r1, r1
 800e4b6:	f001 fe35 	bl	8010124 <lcd_blitBitmap>
      text_offs = LCD_WIDTH - MENU_BUTTON_WIDTH + MENU_BUTTON_BORDER + MENU_ICON_OFFSET + ICON_SIZE;
 800e4ba:	f44f 70cc 	mov.w	r0, #408	@ 0x198
 800e4be:	e001      	b.n	800e4c4 <menu_draw+0xe8>
      text_offs = LCD_WIDTH - MENU_BUTTON_WIDTH + MENU_BUTTON_BORDER + MENU_TEXT_OFFSET;
 800e4c0:	f44f 70c6 	mov.w	r0, #396	@ 0x18c
  while (*label)
 800e4c4:	1e6a      	subs	r2, r5, #1
  int n = 1;
 800e4c6:	2301      	movs	r3, #1
  while (*label)
 800e4c8:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800e4cc:	b119      	cbz	r1, 800e4d6 <menu_draw+0xfa>
    if (*label++ == '\n')
 800e4ce:	290a      	cmp	r1, #10
      n++;
 800e4d0:	bf08      	it	eq
 800e4d2:	3301      	addeq	r3, #1
 800e4d4:	e7f8      	b.n	800e4c8 <menu_draw+0xec>
    lcd_printf(text_offs, y + (menu_button_height - lines * FONT_STR_HEIGHT + (FONT_STR_HEIGHT - FONT_GET_HEIGHT)) / 2, text);
 800e4d6:	f8b8 1000 	ldrh.w	r1, [r8]
 800e4da:	f06f 020a 	mvn.w	r2, #10
 800e4de:	fb02 1103 	mla	r1, r2, r3, r1
 800e4e2:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800e4e6:	eb07 0161 	add.w	r1, r7, r1, asr #1
 800e4ea:	462a      	mov	r2, r5
 800e4ec:	b209      	sxth	r1, r1
 800e4ee:	f001 fe97 	bl	8010220 <lcd_printf>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e4f2:	7aa3      	ldrb	r3, [r4, #10]
  for (i = 0; i < MENU_BUTTON_MAX && m; i++, m = menu_next_item(m), y += menu_button_height)
 800e4f4:	3601      	adds	r6, #1
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e4f6:	b10b      	cbz	r3, 800e4fc <menu_draw+0x120>
  m++; // Next item
 800e4f8:	340a      	adds	r4, #10
 800e4fa:	e000      	b.n	800e4fe <menu_draw+0x122>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e4fc:	6924      	ldr	r4, [r4, #16]
  for (i = 0; i < MENU_BUTTON_MAX && m; i++, m = menu_next_item(m), y += menu_button_height)
 800e4fe:	f8b8 3000 	ldrh.w	r3, [r8]
 800e502:	2e10      	cmp	r6, #16
 800e504:	449b      	add	fp, r3
 800e506:	f47f af77 	bne.w	800e3f8 <menu_draw+0x1c>
  if (AREA_HEIGHT_NORMAL + OFFSETY > y)
 800e50a:	f5bb 7f98 	cmp.w	fp, #304	@ 0x130
 800e50e:	dc0e      	bgt.n	800e52e <menu_draw+0x152>
    lcd_set_background(LCD_BG_COLOR);
 800e510:	2000      	movs	r0, #0
 800e512:	f001 fde9 	bl	80100e8 <lcd_set_background>
    lcd_fill(LCD_WIDTH - MENU_BUTTON_WIDTH, y, MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL + OFFSETY - y);
 800e516:	f5cb 7398 	rsb	r3, fp, #304	@ 0x130
 800e51a:	3301      	adds	r3, #1
 800e51c:	225b      	movs	r2, #91	@ 0x5b
 800e51e:	4659      	mov	r1, fp
 800e520:	f240 1085 	movw	r0, #389	@ 0x185
}
 800e524:	b00d      	add	sp, #52	@ 0x34
 800e526:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lcd_fill(LCD_WIDTH - MENU_BUTTON_WIDTH, y, MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL + OFFSETY - y);
 800e52a:	f001 bce3 	b.w	800fef4 <lcd_fill>
}
 800e52e:	b00d      	add	sp, #52	@ 0x34
 800e530:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e534:	200089bd 	.word	0x200089bd
 800e538:	200003dc 	.word	0x200003dc
 800e53c:	200089c4 	.word	0x200089c4
 800e540:	200003f0 	.word	0x200003f0
 800e544:	08014e60 	.word	0x08014e60
 800e548:	200003f2 	.word	0x200003f2

0800e54c <current_menu_get_count>:
  const menuitem_t *m = menu_stack[menu_current_level];
 800e54c:	4b07      	ldr	r3, [pc, #28]	@ (800e56c <current_menu_get_count+0x20>)
 800e54e:	781a      	ldrb	r2, [r3, #0]
 800e550:	4b07      	ldr	r3, [pc, #28]	@ (800e570 <current_menu_get_count+0x24>)
 800e552:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  int i = 0;
 800e556:	2000      	movs	r0, #0
  while (m)
 800e558:	b133      	cbz	r3, 800e568 <current_menu_get_count+0x1c>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e55a:	7a9a      	ldrb	r2, [r3, #10]
 800e55c:	3001      	adds	r0, #1
 800e55e:	b10a      	cbz	r2, 800e564 <current_menu_get_count+0x18>
  m++; // Next item
 800e560:	330a      	adds	r3, #10
  while (m)
 800e562:	e7fa      	b.n	800e55a <current_menu_get_count+0xe>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e564:	691b      	ldr	r3, [r3, #16]
    i++;
 800e566:	e7f7      	b.n	800e558 <current_menu_get_count+0xc>
}
 800e568:	4770      	bx	lr
 800e56a:	bf00      	nop
 800e56c:	200089bd 	.word	0x200089bd
 800e570:	200003dc 	.word	0x200003dc

0800e574 <ensure_selection>:
{
 800e574:	b508      	push	{r3, lr}
  int i = current_menu_get_count();
 800e576:	f7ff ffe9 	bl	800e54c <current_menu_get_count>
  if (selection < 0)
 800e57a:	4b0c      	ldr	r3, [pc, #48]	@ (800e5ac <ensure_selection+0x38>)
 800e57c:	f993 2000 	ldrsb.w	r2, [r3]
 800e580:	2a00      	cmp	r2, #0
 800e582:	da01      	bge.n	800e588 <ensure_selection+0x14>
    selection = -1;
 800e584:	22ff      	movs	r2, #255	@ 0xff
 800e586:	e002      	b.n	800e58e <ensure_selection+0x1a>
  else if (selection >= i)
 800e588:	4282      	cmp	r2, r0
 800e58a:	db01      	blt.n	800e590 <ensure_selection+0x1c>
    selection = i - 1;
 800e58c:	1e42      	subs	r2, r0, #1
 800e58e:	701a      	strb	r2, [r3, #0]
  else if (i >= MENU_BUTTON_MAX)
 800e590:	2810      	cmp	r0, #16
 800e592:	bfa8      	it	ge
 800e594:	2010      	movge	r0, #16
  menu_button_height = MENU_BUTTON_HEIGHT(i);
 800e596:	4a06      	ldr	r2, [pc, #24]	@ (800e5b0 <ensure_selection+0x3c>)
  if (i < MENU_BUTTON_MIN)
 800e598:	2808      	cmp	r0, #8
 800e59a:	bfb8      	it	lt
 800e59c:	2008      	movlt	r0, #8
  menu_button_height = MENU_BUTTON_HEIGHT(i);
 800e59e:	f240 1331 	movw	r3, #305	@ 0x131
 800e5a2:	fbb3 f3f0 	udiv	r3, r3, r0
 800e5a6:	8013      	strh	r3, [r2, #0]
}
 800e5a8:	bd08      	pop	{r3, pc}
 800e5aa:	bf00      	nop
 800e5ac:	200003f0 	.word	0x200003f0
 800e5b0:	200003f2 	.word	0x200003f2

0800e5b4 <menu_push_submenu>:
  if (menu_current_level < MENU_STACK_DEPTH_MAX - 1)
 800e5b4:	4a05      	ldr	r2, [pc, #20]	@ (800e5cc <menu_push_submenu+0x18>)
 800e5b6:	7813      	ldrb	r3, [r2, #0]
 800e5b8:	2b03      	cmp	r3, #3
 800e5ba:	d802      	bhi.n	800e5c2 <menu_push_submenu+0xe>
    menu_current_level++;
 800e5bc:	3301      	adds	r3, #1
 800e5be:	b2db      	uxtb	r3, r3
 800e5c0:	7013      	strb	r3, [r2, #0]
  menu_stack[menu_current_level] = submenu;
 800e5c2:	4a03      	ldr	r2, [pc, #12]	@ (800e5d0 <menu_push_submenu+0x1c>)
 800e5c4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  ensure_selection();
 800e5c8:	f7ff bfd4 	b.w	800e574 <ensure_selection>
 800e5cc:	200089bd 	.word	0x200089bd
 800e5d0:	200003dc 	.word	0x200003dc

0800e5d4 <menu_invoke>:
{
 800e5d4:	b508      	push	{r3, lr}
  const menuitem_t *m = menu_stack[menu_current_level];
 800e5d6:	4b19      	ldr	r3, [pc, #100]	@ (800e63c <menu_invoke+0x68>)
 800e5d8:	781a      	ldrb	r2, [r3, #0]
 800e5da:	4b19      	ldr	r3, [pc, #100]	@ (800e640 <menu_invoke+0x6c>)
 800e5dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  while (i--)
 800e5e0:	3801      	subs	r0, #1
 800e5e2:	d307      	bcc.n	800e5f4 <menu_invoke+0x20>
  if (m == NULL)
 800e5e4:	2b00      	cmp	r3, #0
 800e5e6:	d0fb      	beq.n	800e5e0 <menu_invoke+0xc>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e5e8:	7a9a      	ldrb	r2, [r3, #10]
 800e5ea:	b10a      	cbz	r2, 800e5f0 <menu_invoke+0x1c>
  m++; // Next item
 800e5ec:	330a      	adds	r3, #10
 800e5ee:	e7f7      	b.n	800e5e0 <menu_invoke+0xc>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800e5f0:	691b      	ldr	r3, [r3, #16]
 800e5f2:	e7f5      	b.n	800e5e0 <menu_invoke+0xc>
  if (menu == NULL)
 800e5f4:	b30b      	cbz	r3, 800e63a <menu_invoke+0x66>
  switch (menu->type)
 800e5f6:	781a      	ldrb	r2, [r3, #0]
 800e5f8:	2a02      	cmp	r2, #2
 800e5fa:	d008      	beq.n	800e60e <menu_invoke+0x3a>
 800e5fc:	2a03      	cmp	r2, #3
 800e5fe:	d00c      	beq.n	800e61a <menu_invoke+0x46>
 800e600:	2a01      	cmp	r2, #1
 800e602:	d110      	bne.n	800e626 <menu_invoke+0x52>
    menu_push_submenu((const menuitem_t *)menu->reference);
 800e604:	f8d3 0006 	ldr.w	r0, [r3, #6]
 800e608:	f7ff ffd4 	bl	800e5b4 <menu_push_submenu>
    break;
 800e60c:	e00b      	b.n	800e626 <menu_invoke+0x52>
    if (menu->reference)
 800e60e:	f8d3 2006 	ldr.w	r2, [r3, #6]
 800e612:	b142      	cbz	r2, 800e626 <menu_invoke+0x52>
      ((menuaction_cb_t)menu->reference)(menu->data);
 800e614:	7858      	ldrb	r0, [r3, #1]
 800e616:	4790      	blx	r2
 800e618:	e005      	b.n	800e626 <menu_invoke+0x52>
    if (menu->reference)
 800e61a:	f8d3 2006 	ldr.w	r2, [r3, #6]
 800e61e:	b112      	cbz	r2, 800e626 <menu_invoke+0x52>
      ((menuaction_acb_t)menu->reference)(menu->data, NULL);
 800e620:	7858      	ldrb	r0, [r3, #1]
 800e622:	2100      	movs	r1, #0
 800e624:	4790      	blx	r2
  if (ui_mode == UI_MENU)
 800e626:	4b07      	ldr	r3, [pc, #28]	@ (800e644 <menu_invoke+0x70>)
 800e628:	781b      	ldrb	r3, [r3, #0]
 800e62a:	2b01      	cmp	r3, #1
 800e62c:	d105      	bne.n	800e63a <menu_invoke+0x66>
}
 800e62e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    menu_draw(-1);
 800e632:	f04f 30ff 	mov.w	r0, #4294967295
 800e636:	f7ff bed1 	b.w	800e3dc <menu_draw>
}
 800e63a:	bd08      	pop	{r3, pc}
 800e63c:	200089bd 	.word	0x200089bd
 800e640:	200003dc 	.word	0x200003dc
 800e644:	200089c4 	.word	0x200089c4

0800e648 <menu_move_back>:
{
 800e648:	b508      	push	{r3, lr}
  if (menu_current_level == 0)
 800e64a:	4a07      	ldr	r2, [pc, #28]	@ (800e668 <menu_move_back+0x20>)
 800e64c:	7813      	ldrb	r3, [r2, #0]
 800e64e:	b14b      	cbz	r3, 800e664 <menu_move_back+0x1c>
 800e650:	4601      	mov	r1, r0
  menu_current_level--;
 800e652:	3b01      	subs	r3, #1
 800e654:	7013      	strb	r3, [r2, #0]
  ensure_selection();
 800e656:	f7ff ff8d 	bl	800e574 <ensure_selection>
  if (leave_ui)
 800e65a:	b119      	cbz	r1, 800e664 <menu_move_back+0x1c>
}
 800e65c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ui_mode_normal();
 800e660:	f7ff b8a8 	b.w	800d7b4 <ui_mode_normal>
}
 800e664:	bd08      	pop	{r3, pc}
 800e666:	bf00      	nop
 800e668:	200089bd 	.word	0x200089bd

0800e66c <ui_mode_menu>:
{
 800e66c:	b508      	push	{r3, lr}
  if (ui_mode == UI_MENU)
 800e66e:	4b0a      	ldr	r3, [pc, #40]	@ (800e698 <ui_mode_menu+0x2c>)
 800e670:	781a      	ldrb	r2, [r3, #0]
 800e672:	2a01      	cmp	r2, #1
 800e674:	d00f      	beq.n	800e696 <ui_mode_menu+0x2a>
  ui_mode = UI_MENU;
 800e676:	2201      	movs	r2, #1
  set_area_size(AREA_WIDTH_NORMAL - MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL);
 800e678:	f44f 70bb 	mov.w	r0, #374	@ 0x176
 800e67c:	f240 1131 	movw	r1, #305	@ 0x131
  ui_mode = UI_MENU;
 800e680:	701a      	strb	r2, [r3, #0]
  set_area_size(AREA_WIDTH_NORMAL - MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL);
 800e682:	f7fd f8ab 	bl	800b7dc <set_area_size>
  ensure_selection();
 800e686:	f7ff ff75 	bl	800e574 <ensure_selection>
}
 800e68a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  menu_draw(-1);
 800e68e:	f04f 30ff 	mov.w	r0, #4294967295
 800e692:	f7ff bea3 	b.w	800e3dc <menu_draw>
}
 800e696:	bd08      	pop	{r3, pc}
 800e698:	200089c4 	.word	0x200089c4

0800e69c <ui_normal_lever>:
  }
  return TRUE;
}

static void ui_normal_lever(uint16_t status)
{
 800e69c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e69e:	4603      	mov	r3, r0
  if (status & EVT_BUTTON_SINGLE_CLICK)
 800e6a0:	f010 0001 	ands.w	r0, r0, #1
 800e6a4:	d003      	beq.n	800e6ae <ui_normal_lever+0x12>
    break;
  case LM_EDELAY:
    lever_edelay(status);
    break;
  }
}
 800e6a6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ui_mode_menu();
 800e6aa:	f7ff bfdf 	b.w	800e66c <ui_mode_menu>
  switch (lever_mode)
 800e6ae:	4a5d      	ldr	r2, [pc, #372]	@ (800e824 <ui_normal_lever+0x188>)
 800e6b0:	7f11      	ldrb	r1, [r2, #28]
 800e6b2:	2903      	cmp	r1, #3
 800e6b4:	d803      	bhi.n	800e6be <ui_normal_lever+0x22>
 800e6b6:	2901      	cmp	r1, #1
 800e6b8:	d834      	bhi.n	800e724 <ui_normal_lever+0x88>
 800e6ba:	b119      	cbz	r1, 800e6c4 <ui_normal_lever+0x28>
 800e6bc:	e0b1      	b.n	800e822 <ui_normal_lever+0x186>
 800e6be:	2904      	cmp	r1, #4
 800e6c0:	d076      	beq.n	800e7b0 <ui_normal_lever+0x114>
 800e6c2:	e0ae      	b.n	800e822 <ui_normal_lever+0x186>
  if (active_marker == MARKER_INVALID || !markers[active_marker].enabled)
 800e6c4:	4d58      	ldr	r5, [pc, #352]	@ (800e828 <ui_normal_lever+0x18c>)
 800e6c6:	f995 201d 	ldrsb.w	r2, [r5, #29]
 800e6ca:	1c51      	adds	r1, r2, #1
 800e6cc:	f000 80a9 	beq.w	800e822 <ui_normal_lever+0x186>
 800e6d0:	320b      	adds	r2, #11
 800e6d2:	f815 2032 	ldrb.w	r2, [r5, r2, lsl #3]
 800e6d6:	2a00      	cmp	r2, #0
 800e6d8:	f000 80a3 	beq.w	800e822 <ui_normal_lever+0x186>
  uint16_t step = 1 << MARKER_SPEEDUP;
 800e6dc:	2408      	movs	r4, #8
    int idx = (int)markers[active_marker].index;
 800e6de:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800e6e2:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
    if ((status & EVT_DOWN) && (idx -= step >> MARKER_SPEEDUP) < 0)
 800e6e6:	069f      	lsls	r7, r3, #26
    int idx = (int)markers[active_marker].index;
 800e6e8:	f8b2 105a 	ldrh.w	r1, [r2, #90]	@ 0x5a
    if ((status & EVT_DOWN) && (idx -= step >> MARKER_SPEEDUP) < 0)
 800e6ec:	bf44      	itt	mi
 800e6ee:	eba1 01d4 	submi.w	r1, r1, r4, lsr #3
 800e6f2:	ea21 71e1 	bicmi.w	r1, r1, r1, asr #31
    if ((status & EVT_UP) && (idx += step >> MARKER_SPEEDUP) > sweep_points - 1)
 800e6f6:	06de      	lsls	r6, r3, #27
 800e6f8:	d506      	bpl.n	800e708 <ui_normal_lever+0x6c>
 800e6fa:	8b6b      	ldrh	r3, [r5, #26]
 800e6fc:	eb01 01d4 	add.w	r1, r1, r4, lsr #3
 800e700:	428b      	cmp	r3, r1
      idx = sweep_points - 1;
 800e702:	bfd8      	it	le
 800e704:	f103 31ff 	addle.w	r1, r3, #4294967295
    set_marker_index(active_marker, idx);
 800e708:	f7f8 fc40 	bl	8006f8c <set_marker_index>
    redraw_marker(active_marker);
 800e70c:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800e710:	f7fe fd26 	bl	800d160 <redraw_marker>
  } while ((status = btn_wait_release()) != 0);
 800e714:	f7fe ff1c 	bl	800d550 <btn_wait_release>
    step++;
 800e718:	3401      	adds	r4, #1
 800e71a:	b2a4      	uxth	r4, r4
  } while ((status = btn_wait_release()) != 0);
 800e71c:	4603      	mov	r3, r0
 800e71e:	2800      	cmp	r0, #0
 800e720:	d1dd      	bne.n	800e6de <ui_normal_lever+0x42>
 800e722:	e07e      	b.n	800e822 <ui_normal_lever+0x186>
    if (FREQ_IS_STARTSTOP())
 800e724:	4a40      	ldr	r2, [pc, #256]	@ (800e828 <ui_normal_lever+0x18c>)
 800e726:	8b15      	ldrh	r5, [r2, #24]
  if (mode == ST_SPAN && !var_freq)
 800e728:	6950      	ldr	r0, [r2, #20]
  if (lever_mode == LM_FREQ_0)
 800e72a:	2902      	cmp	r1, #2
 800e72c:	f005 0540 	and.w	r5, r5, #64	@ 0x40
 800e730:	f003 0710 	and.w	r7, r3, #16
 800e734:	f003 0620 	and.w	r6, r3, #32
 800e738:	d10a      	bne.n	800e750 <ui_normal_lever+0xb4>
    case ST_START:  return frequency0;
 800e73a:	6854      	ldr	r4, [r2, #4]
    if (FREQ_IS_STARTSTOP())
 800e73c:	b1d5      	cbz	r5, 800e774 <ui_normal_lever+0xd8>
    case ST_CENTER: return (frequency0>>1) + (frequency1>>1) + (frequency0&1);
 800e73e:	6895      	ldr	r5, [r2, #8]
 800e740:	0863      	lsrs	r3, r4, #1
 800e742:	eb03 0355 	add.w	r3, r3, r5, lsr #1
 800e746:	f004 0401 	and.w	r4, r4, #1
 800e74a:	441c      	add	r4, r3
      mode = ST_CENTER;
 800e74c:	460d      	mov	r5, r1
 800e74e:	e011      	b.n	800e774 <ui_normal_lever+0xd8>
 800e750:	6894      	ldr	r4, [r2, #8]
    if (FREQ_IS_STARTSTOP())
 800e752:	b175      	cbz	r5, 800e772 <ui_normal_lever+0xd6>
    case ST_SPAN:   return frequency1 - frequency0;
 800e754:	6853      	ldr	r3, [r2, #4]
 800e756:	1ae4      	subs	r4, r4, r3
  if (mode == ST_SPAN && !var_freq)
 800e758:	b9a0      	cbnz	r0, 800e784 <ui_normal_lever+0xe8>
    if (status & EVT_UP)
 800e75a:	b127      	cbz	r7, 800e766 <ui_normal_lever+0xca>
      freq = step_round(freq * 4 + 1);
 800e75c:	00a0      	lsls	r0, r4, #2
 800e75e:	3001      	adds	r0, #1
 800e760:	f7fe fe08 	bl	800d374 <step_round>
 800e764:	4604      	mov	r4, r0
    if (status & EVT_DOWN)
 800e766:	b19e      	cbz	r6, 800e790 <ui_normal_lever+0xf4>
      freq = step_round(freq - 1);
 800e768:	1e60      	subs	r0, r4, #1
 800e76a:	f7fe fe03 	bl	800d374 <step_round>
 800e76e:	4604      	mov	r4, r0
 800e770:	e00e      	b.n	800e790 <ui_normal_lever+0xf4>
      mode = ST_STOP;
 800e772:	2501      	movs	r5, #1
    freq_t step = var_freq ? var_freq : step_round(get_sweep_frequency(ST_SPAN) / 4);
 800e774:	b938      	cbnz	r0, 800e786 <ui_normal_lever+0xea>
 800e776:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
 800e77a:	1ac0      	subs	r0, r0, r3
 800e77c:	0880      	lsrs	r0, r0, #2
 800e77e:	f7fe fdf9 	bl	800d374 <step_round>
 800e782:	e000      	b.n	800e786 <ui_normal_lever+0xea>
      mode = ST_SPAN;
 800e784:	2504      	movs	r5, #4
    if (status & EVT_UP)
 800e786:	b107      	cbz	r7, 800e78a <ui_normal_lever+0xee>
      freq += step;
 800e788:	4404      	add	r4, r0
    if (status & EVT_DOWN)
 800e78a:	b116      	cbz	r6, 800e792 <ui_normal_lever+0xf6>
      freq -= step;
 800e78c:	1a24      	subs	r4, r4, r0
 800e78e:	e000      	b.n	800e792 <ui_normal_lever+0xf6>
      mode = ST_SPAN;
 800e790:	2504      	movs	r5, #4
  while (btn_wait_release() != 0)
 800e792:	f7fe fedd 	bl	800d550 <btn_wait_release>
 800e796:	2800      	cmp	r0, #0
 800e798:	d1fb      	bne.n	800e792 <ui_normal_lever+0xf6>
  if (freq > FREQUENCY_MAX || freq < FREQUENCY_MIN)
 800e79a:	4b24      	ldr	r3, [pc, #144]	@ (800e82c <ui_normal_lever+0x190>)
 800e79c:	f5a4 7216 	sub.w	r2, r4, #600	@ 0x258
 800e7a0:	429a      	cmp	r2, r3
 800e7a2:	d83e      	bhi.n	800e822 <ui_normal_lever+0x186>
  set_sweep_frequency(mode, freq);
 800e7a4:	4621      	mov	r1, r4
 800e7a6:	4628      	mov	r0, r5
}
 800e7a8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  set_sweep_frequency(mode, freq);
 800e7ac:	f7f8 bd36 	b.w	800721c <set_sweep_frequency>
  int ch = current_trace != TRACE_INVALID ? trace[current_trace].channel : 0;
 800e7b0:	4a1d      	ldr	r2, [pc, #116]	@ (800e828 <ui_normal_lever+0x18c>)
 800e7b2:	f992 101c 	ldrsb.w	r1, [r2, #28]
 800e7b6:	1c4c      	adds	r4, r1, #1
 800e7b8:	d004      	beq.n	800e7c4 <ui_normal_lever+0x128>
 800e7ba:	200c      	movs	r0, #12
 800e7bc:	fb00 2101 	mla	r1, r0, r1, r2
 800e7c0:	f891 002a 	ldrb.w	r0, [r1, #42]	@ 0x2a
  if (current_props._var_delay == 0.0f)
 800e7c4:	edd2 7a29 	vldr	s15, [r2, #164]	@ 0xa4
 800e7c8:	eef5 7a40 	vcmp.f32	s15, #0.0
  float value = current_props._electrical_delay[ch];
 800e7cc:	eb02 0180 	add.w	r1, r2, r0, lsl #2
  if (current_props._var_delay == 0.0f)
 800e7d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7d4:	f003 0210 	and.w	r2, r3, #16
  float value = current_props._electrical_delay[ch];
 800e7d8:	ed91 0a27 	vldr	s0, [r1, #156]	@ 0x9c
  if (current_props._var_delay == 0.0f)
 800e7dc:	f003 0320 	and.w	r3, r3, #32
 800e7e0:	d113      	bne.n	800e80a <ui_normal_lever+0x16e>
    float ratio = value > 0 ? STEPRATIO : -STEPRATIO;
 800e7e2:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800e7e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800e7ea:	bfcc      	ite	gt
 800e7ec:	ed9f 7a10 	vldrgt	s14, [pc, #64]	@ 800e830 <ui_normal_lever+0x194>
 800e7f0:	ed9f 7a10 	vldrle	s14, [pc, #64]	@ 800e834 <ui_normal_lever+0x198>
    if (status & EVT_UP)
 800e7f4:	b10a      	cbz	r2, 800e7fa <ui_normal_lever+0x15e>
      value *= (1.0f + ratio);
 800e7f6:	ee07 0a00 	vmla.f32	s0, s14, s0
    if (status & EVT_DOWN)
 800e7fa:	b163      	cbz	r3, 800e816 <ui_normal_lever+0x17a>
      value *= (1.0f - ratio);
 800e7fc:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800e800:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800e804:	ee20 0a27 	vmul.f32	s0, s0, s15
 800e808:	e005      	b.n	800e816 <ui_normal_lever+0x17a>
    if (status & EVT_UP)
 800e80a:	b10a      	cbz	r2, 800e810 <ui_normal_lever+0x174>
      value += current_props._var_delay;
 800e80c:	ee30 0a27 	vadd.f32	s0, s0, s15
    if (status & EVT_DOWN)
 800e810:	b10b      	cbz	r3, 800e816 <ui_normal_lever+0x17a>
      value -= current_props._var_delay;
 800e812:	ee30 0a67 	vsub.f32	s0, s0, s15
  set_electrical_delay(ch, value);
 800e816:	f7f9 ff0b 	bl	8008630 <set_electrical_delay>
  while (btn_wait_release() != 0)
 800e81a:	f7fe fe99 	bl	800d550 <btn_wait_release>
 800e81e:	2800      	cmp	r0, #0
 800e820:	d1fb      	bne.n	800e81a <ui_normal_lever+0x17e>
}
 800e822:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e824:	20000318 	.word	0x20000318
 800e828:	20000aa8 	.word	0x20000aa8
 800e82c:	a0eeb8a8 	.word	0xa0eeb8a8
 800e830:	3e4ccccd 	.word	0x3e4ccccd
 800e834:	be4ccccd 	.word	0xbe4ccccd

0800e838 <ui_menu_touch>:
  if (LCD_WIDTH - MENU_BUTTON_WIDTH < touch_x)
 800e838:	f5b0 7fc3 	cmp.w	r0, #390	@ 0x186
{
 800e83c:	b538      	push	{r3, r4, r5, lr}
  if (LCD_WIDTH - MENU_BUTTON_WIDTH < touch_x)
 800e83e:	db1f      	blt.n	800e880 <ui_menu_touch+0x48>
    int16_t i = (touch_y - MENU_BUTTON_Y_OFFSET) / menu_button_height;
 800e840:	4b12      	ldr	r3, [pc, #72]	@ (800e88c <ui_menu_touch+0x54>)
 800e842:	3901      	subs	r1, #1
 800e844:	881b      	ldrh	r3, [r3, #0]
 800e846:	fb91 f1f3 	sdiv	r1, r1, r3
    if ((uint16_t)i < (uint16_t)current_menu_get_count())
 800e84a:	f7ff fe7f 	bl	800e54c <current_menu_get_count>
 800e84e:	b28b      	uxth	r3, r1
 800e850:	b280      	uxth	r0, r0
 800e852:	4298      	cmp	r0, r3
 800e854:	d914      	bls.n	800e880 <ui_menu_touch+0x48>
      uint32_t mask = (1 << i) | (1 << selection);
 800e856:	4c0e      	ldr	r4, [pc, #56]	@ (800e890 <ui_menu_touch+0x58>)
 800e858:	f994 0000 	ldrsb.w	r0, [r4]
      selection = i;
 800e85c:	7021      	strb	r1, [r4, #0]
      uint32_t mask = (1 << i) | (1 << selection);
 800e85e:	b20d      	sxth	r5, r1
 800e860:	2301      	movs	r3, #1
 800e862:	fa03 f000 	lsl.w	r0, r3, r0
 800e866:	40ab      	lsls	r3, r5
      menu_draw(mask);
 800e868:	4318      	orrs	r0, r3
 800e86a:	f7ff fdb7 	bl	800e3dc <menu_draw>
      touch_wait_release();
 800e86e:	f7fe fe33 	bl	800d4d8 <touch_wait_release>
      selection = -1;
 800e872:	23ff      	movs	r3, #255	@ 0xff
 800e874:	7023      	strb	r3, [r4, #0]
      menu_invoke(i);
 800e876:	4628      	mov	r0, r5
}
 800e878:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      menu_invoke(i);
 800e87c:	f7ff beaa 	b.w	800e5d4 <menu_invoke>
  touch_wait_release();
 800e880:	f7fe fe2a 	bl	800d4d8 <touch_wait_release>
}
 800e884:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ui_mode_normal();
 800e888:	f7fe bf94 	b.w	800d7b4 <ui_mode_normal>
 800e88c:	200003f2 	.word	0x200003f2
 800e890:	200003f0 	.word	0x200003f0

0800e894 <ui_menu_lever>:
{
 800e894:	b570      	push	{r4, r5, r6, lr}
 800e896:	4601      	mov	r1, r0
  uint16_t count = current_menu_get_count();
 800e898:	f7ff fe58 	bl	800e54c <current_menu_get_count>
  if (status & EVT_BUTTON_SINGLE_CLICK)
 800e89c:	f011 0f01 	tst.w	r1, #1
 800e8a0:	4d18      	ldr	r5, [pc, #96]	@ (800e904 <ui_menu_lever+0x70>)
  uint16_t count = current_menu_get_count();
 800e8a2:	b284      	uxth	r4, r0
  if (status & EVT_BUTTON_SINGLE_CLICK)
 800e8a4:	d101      	bne.n	800e8aa <ui_menu_lever+0x16>
    uint32_t mask = 1 << selection;
 800e8a6:	2601      	movs	r6, #1
 800e8a8:	e00c      	b.n	800e8c4 <ui_menu_lever+0x30>
    if ((uint16_t)selection >= count)
 800e8aa:	f995 0000 	ldrsb.w	r0, [r5]
 800e8ae:	b283      	uxth	r3, r0
 800e8b0:	42a3      	cmp	r3, r4
 800e8b2:	d303      	bcc.n	800e8bc <ui_menu_lever+0x28>
}
 800e8b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ui_mode_normal();
 800e8b8:	f7fe bf7c 	b.w	800d7b4 <ui_mode_normal>
}
 800e8bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      menu_invoke(selection);
 800e8c0:	f7ff be88 	b.w	800e5d4 <menu_invoke>
    uint32_t mask = 1 << selection;
 800e8c4:	f995 3000 	ldrsb.w	r3, [r5]
    if (status & EVT_UP)
 800e8c8:	06ca      	lsls	r2, r1, #27
    uint32_t mask = 1 << selection;
 800e8ca:	fa06 f003 	lsl.w	r0, r6, r3
    if (status & EVT_UP)
 800e8ce:	d502      	bpl.n	800e8d6 <ui_menu_lever+0x42>
      selection++;
 800e8d0:	3301      	adds	r3, #1
 800e8d2:	b25b      	sxtb	r3, r3
 800e8d4:	702b      	strb	r3, [r5, #0]
    if (status & EVT_DOWN)
 800e8d6:	068a      	lsls	r2, r1, #26
 800e8d8:	d502      	bpl.n	800e8e0 <ui_menu_lever+0x4c>
      selection--;
 800e8da:	3b01      	subs	r3, #1
 800e8dc:	b25b      	sxtb	r3, r3
 800e8de:	702b      	strb	r3, [r5, #0]
    if ((uint16_t)selection >= count)
 800e8e0:	b29a      	uxth	r2, r3
 800e8e2:	42a2      	cmp	r2, r4
 800e8e4:	d2e6      	bcs.n	800e8b4 <ui_menu_lever+0x20>
    menu_draw(mask | (1 << selection));
 800e8e6:	fa06 f303 	lsl.w	r3, r6, r3
 800e8ea:	4318      	orrs	r0, r3
 800e8ec:	f7ff fd76 	bl	800e3dc <menu_draw>
    chThdSleepMilliseconds(100);
 800e8f0:	f242 7010 	movw	r0, #10000	@ 0x2710
 800e8f4:	f7f2 facc 	bl	8000e90 <chThdSleep>
  } while ((status = btn_wait_release()) != 0);
 800e8f8:	f7fe fe2a 	bl	800d550 <btn_wait_release>
 800e8fc:	4601      	mov	r1, r0
 800e8fe:	2800      	cmp	r0, #0
 800e900:	d1e0      	bne.n	800e8c4 <ui_menu_lever+0x30>
}
 800e902:	bd70      	pop	{r4, r5, r6, pc}
 800e904:	200003f0 	.word	0x200003f0

0800e908 <touch_checkHB9IIU>:
{
 800e908:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  touch_stop_watchdog();
 800e90a:	f7fe fd45 	bl	800d398 <touch_stop_watchdog>
  int stat = touch_status();
 800e90e:	f7fe fda9 	bl	800d464 <touch_status>
  if (stat)
 800e912:	4f16      	ldr	r7, [pc, #88]	@ (800e96c <touch_checkHB9IIU+0x64>)
 800e914:	b1e0      	cbz	r0, 800e950 <touch_checkHB9IIU+0x48>
 800e916:	4604      	mov	r4, r0
    int y = touch_measure_y();
 800e918:	f7fe fd6c 	bl	800d3f4 <touch_measure_y>
 800e91c:	4605      	mov	r5, r0
    int x = touch_measure_x();
 800e91e:	f7fe fd7b 	bl	800d418 <touch_measure_x>
 800e922:	4606      	mov	r6, r0
    touch_prepare_sense();
 800e924:	f7fe fd44 	bl	800d3b0 <touch_prepare_sense>
    if (touch_status())
 800e928:	f7fe fd9c 	bl	800d464 <touch_status>
 800e92c:	b168      	cbz	r0, 800e94a <touch_checkHB9IIU+0x42>
      last_touch_x = x;
 800e92e:	4b10      	ldr	r3, [pc, #64]	@ (800e970 <touch_checkHB9IIU+0x68>)
 800e930:	801e      	strh	r6, [r3, #0]
      last_touch_y = y;
 800e932:	4b10      	ldr	r3, [pc, #64]	@ (800e974 <touch_checkHB9IIU+0x6c>)
      touch_position(&px, &py); // uses existing calibration
 800e934:	a901      	add	r1, sp, #4
 800e936:	4668      	mov	r0, sp
      last_touch_y = y;
 800e938:	801d      	strh	r5, [r3, #0]
      touch_position(&px, &py); // uses existing calibration
 800e93a:	f7fe fc75 	bl	800d228 <touch_position>
      g_touch_px = px;
 800e93e:	4b0e      	ldr	r3, [pc, #56]	@ (800e978 <touch_checkHB9IIU+0x70>)
 800e940:	9a00      	ldr	r2, [sp, #0]
 800e942:	601a      	str	r2, [r3, #0]
      g_touch_py = py;
 800e944:	4b0d      	ldr	r3, [pc, #52]	@ (800e97c <touch_checkHB9IIU+0x74>)
 800e946:	9a01      	ldr	r2, [sp, #4]
 800e948:	601a      	str	r2, [r3, #0]
    touch_remote = REMOTE_NONE;
 800e94a:	2300      	movs	r3, #0
 800e94c:	703b      	strb	r3, [r7, #0]
 800e94e:	e003      	b.n	800e958 <touch_checkHB9IIU+0x50>
    stat = touch_remote == REMOTE_PRESS;
 800e950:	783c      	ldrb	r4, [r7, #0]
 800e952:	1e63      	subs	r3, r4, #1
 800e954:	425c      	negs	r4, r3
 800e956:	415c      	adcs	r4, r3
  if (stat != last_touch_status)
 800e958:	4b09      	ldr	r3, [pc, #36]	@ (800e980 <touch_checkHB9IIU+0x78>)
 800e95a:	781a      	ldrb	r2, [r3, #0]
 800e95c:	42a2      	cmp	r2, r4
    last_touch_status = stat;
 800e95e:	bf1c      	itt	ne
 800e960:	701c      	strbne	r4, [r3, #0]
    return stat ? EVT_TOUCH_PRESSED : EVT_TOUCH_RELEASED;
 800e962:	f1c4 0403 	rsbne	r4, r4, #3
}
 800e966:	4620      	mov	r0, r4
 800e968:	b003      	add	sp, #12
 800e96a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e96c:	200089bc 	.word	0x200089bc
 800e970:	200089de 	.word	0x200089de
 800e974:	200089dc 	.word	0x200089dc
 800e978:	200089b8 	.word	0x200089b8
 800e97c:	200089b4 	.word	0x200089b4
 800e980:	200089e0 	.word	0x200089e0

0800e984 <ui_message_box>:
{
 800e984:	b570      	push	{r4, r5, r6, lr}
 800e986:	b08c      	sub	sp, #48	@ 0x30
  b.bg = LCD_MENU_COLOR;
 800e988:	f240 4303 	movw	r3, #1027	@ 0x403
 800e98c:	f8ad 3008 	strh.w	r3, [sp, #8]
  b.border = BUTTON_BORDER_FLAT;
 800e990:	2300      	movs	r3, #0
{
 800e992:	460c      	mov	r4, r1
 800e994:	4615      	mov	r5, r2
  b.border = BUTTON_BORDER_FLAT;
 800e996:	f88d 300a 	strb.w	r3, [sp, #10]
  if (header)
 800e99a:	b180      	cbz	r0, 800e9be <ui_message_box+0x3a>
    ui_draw_button((LCD_WIDTH - MESSAGE_BOX_WIDTH) / 2, LCD_HEIGHT / 2 - 40, MESSAGE_BOX_WIDTH, 60, &b);
 800e99c:	ab02      	add	r3, sp, #8
 800e99e:	4606      	mov	r6, r0
 800e9a0:	9300      	str	r3, [sp, #0]
 800e9a2:	22b4      	movs	r2, #180	@ 0xb4
 800e9a4:	233c      	movs	r3, #60	@ 0x3c
 800e9a6:	2178      	movs	r1, #120	@ 0x78
 800e9a8:	2096      	movs	r0, #150	@ 0x96
 800e9aa:	f7fe fe17 	bl	800d5dc <ui_draw_button>
    lcd_drawstring(x, y, header);
 800e9ae:	4632      	mov	r2, r6
 800e9b0:	217d      	movs	r1, #125	@ 0x7d
 800e9b2:	20a0      	movs	r0, #160	@ 0xa0
 800e9b4:	f001 fc34 	bl	8010220 <lcd_printf>
    request_to_redraw(REDRAW_AREA);
 800e9b8:	2002      	movs	r0, #2
 800e9ba:	f7fc ff19 	bl	800b7f0 <request_to_redraw>
  if (text)
 800e9be:	b18c      	cbz	r4, 800e9e4 <ui_message_box+0x60>
    lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_FG_COLOR);
 800e9c0:	2101      	movs	r1, #1
 800e9c2:	2004      	movs	r0, #4
 800e9c4:	f001 fb9c 	bl	8010100 <lcd_set_colors>
    lcd_fill((LCD_WIDTH - MESSAGE_BOX_WIDTH) / 2 + 3, LCD_HEIGHT / 2 - 40 + FONT_STR_HEIGHT + 8, MESSAGE_BOX_WIDTH - 6, 60 - FONT_STR_HEIGHT - 8 - 3);
 800e9c8:	2326      	movs	r3, #38	@ 0x26
 800e9ca:	22ae      	movs	r2, #174	@ 0xae
 800e9cc:	218b      	movs	r1, #139	@ 0x8b
 800e9ce:	2099      	movs	r0, #153	@ 0x99
 800e9d0:	f001 fa90 	bl	800fef4 <lcd_fill>
    lcd_drawstring(x, y, text);
 800e9d4:	4622      	mov	r2, r4
 800e9d6:	2199      	movs	r1, #153	@ 0x99
 800e9d8:	20aa      	movs	r0, #170	@ 0xaa
 800e9da:	f001 fc21 	bl	8010220 <lcd_printf>
    request_to_redraw(REDRAW_AREA);
 800e9de:	2002      	movs	r0, #2
 800e9e0:	f7fc ff06 	bl	800b7f0 <request_to_redraw>
    chThdSleepMilliseconds(delay == 0 ? 50 : delay);
 800e9e4:	4c0d      	ldr	r4, [pc, #52]	@ (800ea1c <ui_message_box+0x98>)
 800e9e6:	436c      	muls	r4, r5
 800e9e8:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800e9ec:	f204 34e7 	addw	r4, r4, #999	@ 0x3e7
 800e9f0:	fbb4 f4f3 	udiv	r4, r4, r3
 800e9f4:	f241 3388 	movw	r3, #5000	@ 0x1388
 800e9f8:	2d00      	cmp	r5, #0
 800e9fa:	bf08      	it	eq
 800e9fc:	461c      	moveq	r4, r3
 800e9fe:	4620      	mov	r0, r4
 800ea00:	f7f2 fa46 	bl	8000e90 <chThdSleep>
  } while (delay == 0 && btn_check() != EVT_BUTTON_SINGLE_CLICK && touch_check() != EVT_TOUCH_PRESSED);
 800ea04:	b93d      	cbnz	r5, 800ea16 <ui_message_box+0x92>
 800ea06:	f7fe fd7d 	bl	800d504 <btn_check>
 800ea0a:	2801      	cmp	r0, #1
 800ea0c:	d003      	beq.n	800ea16 <ui_message_box+0x92>
 800ea0e:	f7fe fd33 	bl	800d478 <touch_check>
 800ea12:	2802      	cmp	r0, #2
 800ea14:	d1f3      	bne.n	800e9fe <ui_message_box+0x7a>
}
 800ea16:	b00c      	add	sp, #48	@ 0x30
 800ea18:	bd70      	pop	{r4, r5, r6, pc}
 800ea1a:	bf00      	nop
 800ea1c:	000186a0 	.word	0x000186a0

0800ea20 <browser_draw_page>:
static void browser_draw_page(int page) {
 800ea20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (f_mount(fs_volume, "", 1) != FR_OK ||
 800ea24:	493d      	ldr	r1, [pc, #244]	@ (800eb1c <browser_draw_page+0xfc>)
static void browser_draw_page(int page) {
 800ea26:	b0aa      	sub	sp, #168	@ 0xa8
 800ea28:	4605      	mov	r5, r0
  if (f_mount(fs_volume, "", 1) != FR_OK ||
 800ea2a:	2201      	movs	r2, #1
 800ea2c:	483c      	ldr	r0, [pc, #240]	@ (800eb20 <browser_draw_page+0x100>)
 800ea2e:	f7f5 ff33 	bl	8004898 <f_mount>
 800ea32:	b140      	cbz	r0, 800ea46 <browser_draw_page+0x26>
    ui_message_box("ERROR", "NO CARD", 2000);
 800ea34:	493b      	ldr	r1, [pc, #236]	@ (800eb24 <browser_draw_page+0x104>)
 800ea36:	483c      	ldr	r0, [pc, #240]	@ (800eb28 <browser_draw_page+0x108>)
 800ea38:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800ea3c:	f7ff ffa2 	bl	800e984 <ui_message_box>
    ui_mode_normal();
 800ea40:	f7fe feb8 	bl	800d7b4 <ui_mode_normal>
    return;
 800ea44:	e067      	b.n	800eb16 <browser_draw_page+0xf6>
      sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) {
 800ea46:	4b39      	ldr	r3, [pc, #228]	@ (800eb2c <browser_draw_page+0x10c>)
  dp->pat = pattern;
 800ea48:	4a39      	ldr	r2, [pc, #228]	@ (800eb30 <browser_draw_page+0x110>)
      sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) {
 800ea4a:	781b      	ldrb	r3, [r3, #0]
  return f_opendir(dp, path);
 800ea4c:	4933      	ldr	r1, [pc, #204]	@ (800eb1c <browser_draw_page+0xfc>)
      sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) {
 800ea4e:	011b      	lsls	r3, r3, #4
  return f_opendir(dp, path);
 800ea50:	a814      	add	r0, sp, #80	@ 0x50
  dp->pat = pattern;
 800ea52:	58d3      	ldr	r3, [r2, r3]
 800ea54:	9328      	str	r3, [sp, #160]	@ 0xa0
  return f_opendir(dp, path);
 800ea56:	f7f6 fadd 	bl	8005014 <f_opendir>
  if (f_mount(fs_volume, "", 1) != FR_OK ||
 800ea5a:	4604      	mov	r4, r0
 800ea5c:	2800      	cmp	r0, #0
 800ea5e:	d1e9      	bne.n	800ea34 <browser_draw_page+0x14>
  uint16_t start_file = (page - 1) * FILES_PER_PAGE;
 800ea60:	1e6a      	subs	r2, r5, #1
 800ea62:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 800ea66:	0052      	lsls	r2, r2, #1
  lcd_set_background(LCD_MENU_COLOR);
 800ea68:	2003      	movs	r0, #3
  uint16_t start_file = (page - 1) * FILES_PER_PAGE;
 800ea6a:	b296      	uxth	r6, r2
  lcd_set_background(LCD_MENU_COLOR);
 800ea6c:	f001 fb3c 	bl	80100e8 <lcd_set_background>
  while (sd_findnext(&dj, &fno) == FR_OK) {
 800ea70:	4f30      	ldr	r7, [pc, #192]	@ (800eb34 <browser_draw_page+0x114>)
    if (cnt >= start_file && cnt < (start_file + FILES_PER_PAGE)) {
 800ea72:	f106 081d 	add.w	r8, r6, #29
  while (sd_findnext(&dj, &fno) == FR_OK) {
 800ea76:	a904      	add	r1, sp, #16
 800ea78:	a814      	add	r0, sp, #80	@ 0x50
 800ea7a:	f7ff fa43 	bl	800df04 <sd_findnext>
 800ea7e:	b990      	cbnz	r0, 800eaa6 <browser_draw_page+0x86>
    if (cnt >= start_file && cnt < (start_file + FILES_PER_PAGE)) {
 800ea80:	42b4      	cmp	r4, r6
 800ea82:	db08      	blt.n	800ea96 <browser_draw_page+0x76>
 800ea84:	45a0      	cmp	r8, r4
 800ea86:	db06      	blt.n	800ea96 <browser_draw_page+0x76>
      browser_draw_button(cnt - start_file + FILE_BUTTON_FILE, fno.fname);
 800ea88:	f1c6 0004 	rsb	r0, r6, #4
 800ea8c:	f10d 012a 	add.w	r1, sp, #42	@ 0x2a
 800ea90:	4420      	add	r0, r4
 800ea92:	f7fe fdfd 	bl	800d690 <browser_draw_button>
    if (file_count && (start_file + FILES_PER_PAGE == cnt)) break;
 800ea96:	883b      	ldrh	r3, [r7, #0]
    cnt++;
 800ea98:	3401      	adds	r4, #1
    if (file_count && (start_file + FILES_PER_PAGE == cnt)) break;
 800ea9a:	2b00      	cmp	r3, #0
 800ea9c:	d0eb      	beq.n	800ea76 <browser_draw_page+0x56>
 800ea9e:	f106 031e 	add.w	r3, r6, #30
 800eaa2:	42a3      	cmp	r3, r4
 800eaa4:	d1e7      	bne.n	800ea76 <browser_draw_page+0x56>
  f_closedir(&dj);
 800eaa6:	a814      	add	r0, sp, #80	@ 0x50
 800eaa8:	f7f6 faf8 	bl	800509c <f_closedir>
  if (file_count == 0) {
 800eaac:	883b      	ldrh	r3, [r7, #0]
 800eaae:	b95b      	cbnz	r3, 800eac8 <browser_draw_page+0xa8>
    file_count = cnt;
 800eab0:	803c      	strh	r4, [r7, #0]
    page_count = cnt == 0 ? 1 : (file_count + FILES_PER_PAGE - 1) / FILES_PER_PAGE;
 800eab2:	b134      	cbz	r4, 800eac2 <browser_draw_page+0xa2>
 800eab4:	b2a2      	uxth	r2, r4
 800eab6:	321d      	adds	r2, #29
 800eab8:	231e      	movs	r3, #30
 800eaba:	fbb2 f2f3 	udiv	r2, r2, r3
 800eabe:	b292      	uxth	r2, r2
 800eac0:	e000      	b.n	800eac4 <browser_draw_page+0xa4>
 800eac2:	2201      	movs	r2, #1
 800eac4:	4b1c      	ldr	r3, [pc, #112]	@ (800eb38 <browser_draw_page+0x118>)
 800eac6:	801a      	strh	r2, [r3, #0]
  cnt-= start_file;
 800eac8:	1ba4      	subs	r4, r4, r6
  while(cnt < FILES_PER_PAGE) {
 800eaca:	2c1d      	cmp	r4, #29
 800eacc:	dc0f      	bgt.n	800eaee <browser_draw_page+0xce>
    browser_get_button_pos(cnt + FILE_BUTTON_FILE, &btn);
 800eace:	1d20      	adds	r0, r4, #4
 800ead0:	a902      	add	r1, sp, #8
 800ead2:	f7fe fbf7 	bl	800d2c4 <browser_get_button_pos>
    lcd_fill(btn.x, btn.y, btn.w, btn.h);
 800ead6:	f89d 300e 	ldrb.w	r3, [sp, #14]
 800eada:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 800eade:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 800eae2:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 800eae6:	f001 fa05 	bl	800fef4 <lcd_fill>
    cnt++;
 800eaea:	3401      	adds	r4, #1
 800eaec:	e7ed      	b.n	800eaca <browser_draw_page+0xaa>
  lcd_fill(0, LCD_HEIGHT - FILE_BOTTOM_HEIGHT, LCD_WIDTH, FILE_BOTTOM_HEIGHT);
 800eaee:	2314      	movs	r3, #20
 800eaf0:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800eaf4:	f44f 7196 	mov.w	r1, #300	@ 0x12c
 800eaf8:	2000      	movs	r0, #0
 800eafa:	f001 f9fb 	bl	800fef4 <lcd_fill>
  browser_draw_buttons();
 800eafe:	f7fe fe11 	bl	800d724 <browser_draw_buttons>
  lcd_printf((LCD_WIDTH - FONT_STR_WIDTH(6)) / 2, LCD_HEIGHT - (FILE_BOTTOM_HEIGHT + FONT_STR_HEIGHT) / 2, "- %u | %u -", page, page_count);
 800eb02:	4b0d      	ldr	r3, [pc, #52]	@ (800eb38 <browser_draw_page+0x118>)
 800eb04:	4a0d      	ldr	r2, [pc, #52]	@ (800eb3c <browser_draw_page+0x11c>)
 800eb06:	881b      	ldrh	r3, [r3, #0]
 800eb08:	9300      	str	r3, [sp, #0]
 800eb0a:	f240 1131 	movw	r1, #305	@ 0x131
 800eb0e:	462b      	mov	r3, r5
 800eb10:	20db      	movs	r0, #219	@ 0xdb
 800eb12:	f001 fb85 	bl	8010220 <lcd_printf>
}
 800eb16:	b02a      	add	sp, #168	@ 0xa8
 800eb18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800eb1c:	08012921 	.word	0x08012921
 800eb20:	200097b8 	.word	0x200097b8
 800eb24:	08012b39 	.word	0x08012b39
 800eb28:	08012b41 	.word	0x08012b41
 800eb2c:	200089bf 	.word	0x200089bf
 800eb30:	08014bd0 	.word	0x08014bd0
 800eb34:	200089b0 	.word	0x200089b0
 800eb38:	200089ae 	.word	0x200089ae
 800eb3c:	08012b47 	.word	0x08012b47

0800eb40 <ui_save_file>:
{
 800eb40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  file_save_cb_t save = file_opt[format].save;
 800eb44:	4f2e      	ldr	r7, [pc, #184]	@ (800ec00 <ui_save_file+0xc0>)
 800eb46:	eb07 1301 	add.w	r3, r7, r1, lsl #4
{
 800eb4a:	b08a      	sub	sp, #40	@ 0x28
  file_save_cb_t save = file_opt[format].save;
 800eb4c:	685e      	ldr	r6, [r3, #4]
  if (save == NULL)
 800eb4e:	2e00      	cmp	r6, #0
 800eb50:	d052      	beq.n	800ebf8 <ui_save_file+0xb8>
  if (ui_mode != UI_NORMAL && (file_opt[format].opt & FILE_OPT_REDRAW))
 800eb52:	4a2c      	ldr	r2, [pc, #176]	@ (800ec04 <ui_save_file+0xc4>)
 800eb54:	7812      	ldrb	r2, [r2, #0]
 800eb56:	4604      	mov	r4, r0
 800eb58:	460d      	mov	r5, r1
 800eb5a:	ea4f 1801 	mov.w	r8, r1, lsl #4
 800eb5e:	b132      	cbz	r2, 800eb6e <ui_save_file+0x2e>
 800eb60:	68db      	ldr	r3, [r3, #12]
 800eb62:	07db      	lsls	r3, r3, #31
 800eb64:	d503      	bpl.n	800eb6e <ui_save_file+0x2e>
    ui_mode_normal();
 800eb66:	f7fe fe25 	bl	800d7b4 <ui_mode_normal>
    draw_all();
 800eb6a:	f7fc fe69 	bl	800b840 <draw_all>
    plot_printf(fs_filename, FF_LFN_BUF, "VNA_%06x_%06x.%s", dr, tr, file_opt[format].ext);
 800eb6e:	f857 2008 	ldr.w	r2, [r7, r8]
  if (name == NULL)
 800eb72:	b984      	cbnz	r4, 800eb96 <ui_save_file+0x56>
    uint32_t tr = rtc_get_tr_bcd(); // TR read first
 800eb74:	4924      	ldr	r1, [pc, #144]	@ (800ec08 <ui_save_file+0xc8>)
 800eb76:	680b      	ldr	r3, [r1, #0]
    uint32_t dr = rtc_get_dr_bcd(); // DR read second
 800eb78:	6849      	ldr	r1, [r1, #4]
    plot_printf(fs_filename, FF_LFN_BUF, "VNA_%06x_%06x.%s", dr, tr, file_opt[format].ext);
 800eb7a:	9201      	str	r2, [sp, #4]
    uint32_t tr = rtc_get_tr_bcd(); // TR read first
 800eb7c:	f003 337f 	and.w	r3, r3, #2139062143	@ 0x7f7f7f7f
 800eb80:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
    plot_printf(fs_filename, FF_LFN_BUF, "VNA_%06x_%06x.%s", dr, tr, file_opt[format].ext);
 800eb84:	9300      	str	r3, [sp, #0]
 800eb86:	4b21      	ldr	r3, [pc, #132]	@ (800ec0c <ui_save_file+0xcc>)
 800eb88:	4a21      	ldr	r2, [pc, #132]	@ (800ec10 <ui_save_file+0xd0>)
 800eb8a:	400b      	ands	r3, r1
 800eb8c:	a802      	add	r0, sp, #8
 800eb8e:	2120      	movs	r1, #32
 800eb90:	f7f4 f898 	bl	8002cc4 <plot_printf>
 800eb94:	e006      	b.n	800eba4 <ui_save_file+0x64>
    plot_printf(fs_filename, FF_LFN_BUF, "%s.%s", name, file_opt[format].ext);
 800eb96:	9200      	str	r2, [sp, #0]
 800eb98:	4623      	mov	r3, r4
 800eb9a:	4a1e      	ldr	r2, [pc, #120]	@ (800ec14 <ui_save_file+0xd4>)
 800eb9c:	2120      	movs	r1, #32
 800eb9e:	a802      	add	r0, sp, #8
 800eba0:	f7f4 f890 	bl	8002cc4 <plot_printf>
  FRESULT res = f_mount(fs_volume, "", 1);
 800eba4:	491c      	ldr	r1, [pc, #112]	@ (800ec18 <ui_save_file+0xd8>)
 800eba6:	481d      	ldr	r0, [pc, #116]	@ (800ec1c <ui_save_file+0xdc>)
 800eba8:	2201      	movs	r2, #1
 800ebaa:	f7f5 fe75 	bl	8004898 <f_mount>
  if (res != FR_OK)
 800ebae:	4604      	mov	r4, r0
 800ebb0:	b968      	cbnz	r0, 800ebce <ui_save_file+0x8e>
  res = f_open(fs_file, fs_filename, FA_CREATE_ALWAYS | FA_READ | FA_WRITE);
 800ebb2:	481b      	ldr	r0, [pc, #108]	@ (800ec20 <ui_save_file+0xe0>)
 800ebb4:	220b      	movs	r2, #11
 800ebb6:	a902      	add	r1, sp, #8
 800ebb8:	f7f5 fe90 	bl	80048dc <f_open>
  if (res == FR_OK)
 800ebbc:	4604      	mov	r4, r0
 800ebbe:	b930      	cbnz	r0, 800ebce <ui_save_file+0x8e>
    res = save(fs_file, format);
 800ebc0:	4817      	ldr	r0, [pc, #92]	@ (800ec20 <ui_save_file+0xe0>)
 800ebc2:	4629      	mov	r1, r5
 800ebc4:	47b0      	blx	r6
 800ebc6:	4604      	mov	r4, r0
    f_close(fs_file);
 800ebc8:	4815      	ldr	r0, [pc, #84]	@ (800ec20 <ui_save_file+0xe0>)
 800ebca:	f7f6 fa13 	bl	8004ff4 <f_close>
  if (keyboard_temp == 1)
 800ebce:	4b15      	ldr	r3, [pc, #84]	@ (800ec24 <ui_save_file+0xe4>)
 800ebd0:	781b      	ldrb	r3, [r3, #0]
 800ebd2:	2b01      	cmp	r3, #1
 800ebd4:	d101      	bne.n	800ebda <ui_save_file+0x9a>
    toggle_sweep();
 800ebd6:	f7f7 fbb5 	bl	8006344 <toggle_sweep>
  ui_message_box("SD CARD SAVE", res == FR_OK ? fs_filename : "  Fail write  ", 2000);
 800ebda:	4913      	ldr	r1, [pc, #76]	@ (800ec28 <ui_save_file+0xe8>)
 800ebdc:	4813      	ldr	r0, [pc, #76]	@ (800ec2c <ui_save_file+0xec>)
 800ebde:	ab02      	add	r3, sp, #8
 800ebe0:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800ebe4:	2c00      	cmp	r4, #0
 800ebe6:	bf08      	it	eq
 800ebe8:	4619      	moveq	r1, r3
 800ebea:	f7ff fecb 	bl	800e984 <ui_message_box>
  request_to_redraw(REDRAW_AREA | REDRAW_FREQUENCY);
 800ebee:	200a      	movs	r0, #10
 800ebf0:	f7fc fdfe 	bl	800b7f0 <request_to_redraw>
  ui_mode_normal();
 800ebf4:	f7fe fdde 	bl	800d7b4 <ui_mode_normal>
}
 800ebf8:	b00a      	add	sp, #40	@ 0x28
 800ebfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ebfe:	bf00      	nop
 800ec00:	08014bd0 	.word	0x08014bd0
 800ec04:	200089c4 	.word	0x200089c4
 800ec08:	40002800 	.word	0x40002800
 800ec0c:	00ff1f3f 	.word	0x00ff1f3f
 800ec10:	08012b62 	.word	0x08012b62
 800ec14:	08012b73 	.word	0x08012b73
 800ec18:	08012921 	.word	0x08012921
 800ec1c:	200097b8 	.word	0x200097b8
 800ec20:	20009568 	.word	0x20009568
 800ec24:	200089be 	.word	0x200089be
 800ec28:	08012b53 	.word	0x08012b53
 800ec2c:	08012b79 	.word	0x08012b79

0800ec30 <menu_sdcard_cb>:
{
 800ec30:	b510      	push	{r4, lr}
  keyboard_temp = (sweep_mode & SWEEP_ENABLE) ? 1 : 0;
 800ec32:	4b10      	ldr	r3, [pc, #64]	@ (800ec74 <menu_sdcard_cb+0x44>)
 800ec34:	4a10      	ldr	r2, [pc, #64]	@ (800ec78 <menu_sdcard_cb+0x48>)
 800ec36:	781b      	ldrb	r3, [r3, #0]
 800ec38:	f003 0301 	and.w	r3, r3, #1
{
 800ec3c:	4604      	mov	r4, r0
  keyboard_temp = (sweep_mode & SWEEP_ENABLE) ? 1 : 0;
 800ec3e:	7013      	strb	r3, [r2, #0]
  if (keyboard_temp)
 800ec40:	b10b      	cbz	r3, 800ec46 <menu_sdcard_cb+0x16>
    toggle_sweep();
 800ec42:	f7f7 fb7f 	bl	8006344 <toggle_sweep>
  if (data == FMT_BMP_FILE && VNA_MODE(VNA_MODE_TIFF))
 800ec46:	4b0d      	ldr	r3, [pc, #52]	@ (800ec7c <menu_sdcard_cb+0x4c>)
 800ec48:	2c02      	cmp	r4, #2
 800ec4a:	8a9b      	ldrh	r3, [r3, #20]
 800ec4c:	d103      	bne.n	800ec56 <menu_sdcard_cb+0x26>
    return FMT_TIF_FILE;
 800ec4e:	f013 0f80 	tst.w	r3, #128	@ 0x80
 800ec52:	bf18      	it	ne
 800ec54:	2403      	movne	r4, #3
  if (VNA_MODE(VNA_MODE_AUTO_NAME))
 800ec56:	07db      	lsls	r3, r3, #31
 800ec58:	d505      	bpl.n	800ec66 <menu_sdcard_cb+0x36>
    ui_save_file(NULL, data);
 800ec5a:	b2e1      	uxtb	r1, r4
 800ec5c:	2000      	movs	r0, #0
}
 800ec5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ui_save_file(NULL, data);
 800ec62:	f7ff bf6d 	b.w	800eb40 <ui_save_file>
    ui_mode_keypad(data + KM_S1P_NAME); // If no auto name, call text keyboard input
 800ec66:	f104 001b 	add.w	r0, r4, #27
}
 800ec6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ui_mode_keypad(data + KM_S1P_NAME); // If no auto name, call text keyboard input
 800ec6e:	f7fe be13 	b.w	800d898 <ui_mode_keypad>
 800ec72:	bf00      	nop
 800ec74:	200003c4 	.word	0x200003c4
 800ec78:	200089be 	.word	0x200089be
 800ec7c:	20000318 	.word	0x20000318

0800ec80 <ui_normal_touch>:
  return TRUE;
}
#endif

static void ui_normal_touch(int touch_x, int touch_y)
{
 800ec80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ec84:	ed2d 8b02 	vpush	{d8}
 800ec88:	b089      	sub	sp, #36	@ 0x24
  touch_x -= OFFSETX;
 800ec8a:	f1a0 060f 	sub.w	r6, r0, #15
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800ec8e:	b20b      	sxth	r3, r1
 800ec90:	4d8c      	ldr	r5, [pc, #560]	@ (800eec4 <ui_normal_touch+0x244>)
  touch_x -= OFFSETX;
 800ec92:	9606      	str	r6, [sp, #24]
{
 800ec94:	4607      	mov	r7, r0
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800ec96:	b236      	sxth	r6, r6
 800ec98:	4618      	mov	r0, r3
 800ec9a:	4632      	mov	r2, r6
 800ec9c:	463b      	mov	r3, r7
 800ec9e:	9107      	str	r1, [sp, #28]
  int min_dist = MARKER_PICKUP_DISTANCE * MARKER_PICKUP_DISTANCE;
 800eca0:	f44f 7961 	mov.w	r9, #900	@ 0x384
  int i = MARKER_INVALID, mt, m, t;
 800eca4:	f04f 3aff 	mov.w	sl, #4294967295
  for (t = 0; t < TRACES_MAX; t++)
 800eca8:	f04f 0b00 	mov.w	fp, #0
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800ecac:	462e      	mov	r6, r5
 800ecae:	4607      	mov	r7, r0
    if (!trace[t].enabled)
 800ecb0:	f896 0028 	ldrb.w	r0, [r6, #40]	@ 0x28
 800ecb4:	b330      	cbz	r0, 800ed04 <ui_normal_touch+0x84>
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800ecb6:	fa4f f08b 	sxtb.w	r0, fp
 800ecba:	e9cd 0602 	strd	r0, r6, [sp, #8]
 800ecbe:	462c      	mov	r4, r5
 800ecc0:	461e      	mov	r6, r3
    for (m = 0; m < MARKERS_MAX; m++)
 800ecc2:	f04f 0800 	mov.w	r8, #0
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800ecc6:	463b      	mov	r3, r7
 800ecc8:	460f      	mov	r7, r1
      if (!markers[m].enabled)
 800ecca:	f894 1058 	ldrb.w	r1, [r4, #88]	@ 0x58
 800ecce:	b171      	cbz	r1, 800ecee <ui_normal_touch+0x6e>
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800ecd0:	f8b4 105a 	ldrh.w	r1, [r4, #90]	@ 0x5a
 800ecd4:	9802      	ldr	r0, [sp, #8]
 800ecd6:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800ecda:	f7fc fc2d 	bl	800b538 <distance_to_index>
      if (dist < min_dist)
 800ecde:	4548      	cmp	r0, r9
 800ece0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800ece4:	da03      	bge.n	800ecee <ui_normal_touch+0x6e>
        min_dist = dist;
 800ece6:	4681      	mov	r9, r0
        mt = t;
 800ece8:	f8cd b004 	str.w	fp, [sp, #4]
        i = m;
 800ecec:	46c2      	mov	sl, r8
    for (m = 0; m < MARKERS_MAX; m++)
 800ecee:	f108 0801 	add.w	r8, r8, #1
 800ecf2:	f1b8 0f08 	cmp.w	r8, #8
 800ecf6:	f104 0408 	add.w	r4, r4, #8
 800ecfa:	d1e6      	bne.n	800ecca <ui_normal_touch+0x4a>
 800ecfc:	4639      	mov	r1, r7
 800ecfe:	461f      	mov	r7, r3
 800ed00:	4633      	mov	r3, r6
 800ed02:	9e03      	ldr	r6, [sp, #12]
  for (t = 0; t < TRACES_MAX; t++)
 800ed04:	f10b 0b01 	add.w	fp, fp, #1
 800ed08:	f1bb 0f04 	cmp.w	fp, #4
 800ed0c:	f106 060c 	add.w	r6, r6, #12
 800ed10:	d1ce      	bne.n	800ecb0 <ui_normal_touch+0x30>
  if (i == MARKER_INVALID)
 800ed12:	f1ba 3fff 	cmp.w	sl, #4294967295
 800ed16:	461f      	mov	r7, r3
 800ed18:	460c      	mov	r4, r1
 800ed1a:	d036      	beq.n	800ed8a <ui_normal_touch+0x10a>
  if (active_marker != i)
 800ed1c:	4b69      	ldr	r3, [pc, #420]	@ (800eec4 <ui_normal_touch+0x244>)
 800ed1e:	f993 201d 	ldrsb.w	r2, [r3, #29]
 800ed22:	4552      	cmp	r2, sl
    previous_marker = active_marker;
 800ed24:	bf1c      	itt	ne
 800ed26:	779a      	strbne	r2, [r3, #30]
    active_marker = i;
 800ed28:	f883 a01d 	strbne.w	sl, [r3, #29]
  props_mode &= ~TD_MARKER_TRACK;
 800ed2c:	8b2b      	ldrh	r3, [r5, #24]
  select_lever_mode(LM_MARKER);
 800ed2e:	2000      	movs	r0, #0
  props_mode &= ~TD_MARKER_TRACK;
 800ed30:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800ed34:	832b      	strh	r3, [r5, #24]
  select_lever_mode(LM_MARKER);
 800ed36:	f7fe fbd5 	bl	800d4e4 <select_lever_mode>
  set_active_trace(mt);
 800ed3a:	9801      	ldr	r0, [sp, #4]
 800ed3c:	f7f8 fcee 	bl	800771c <set_active_trace>
    touch_position(&touch_x, &touch_y);
 800ed40:	a907      	add	r1, sp, #28
 800ed42:	a806      	add	r0, sp, #24
 800ed44:	f7fe fa70 	bl	800d228 <touch_position>
    int index = search_nearest_index(touch_x - OFFSETX, touch_y - OFFSETY, current_trace);
 800ed48:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800ed4c:	f995 201c 	ldrsb.w	r2, [r5, #28]
 800ed50:	380f      	subs	r0, #15
 800ed52:	f7fc fc0b 	bl	800b56c <search_nearest_index>
    if (index >= 0 && markers[active_marker].index != index)
 800ed56:	1e01      	subs	r1, r0, #0
 800ed58:	db0e      	blt.n	800ed78 <ui_normal_touch+0xf8>
 800ed5a:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800ed5e:	eb05 03c0 	add.w	r3, r5, r0, lsl #3
 800ed62:	f8b3 305a 	ldrh.w	r3, [r3, #90]	@ 0x5a
 800ed66:	4299      	cmp	r1, r3
 800ed68:	d006      	beq.n	800ed78 <ui_normal_touch+0xf8>
      set_marker_index(active_marker, index);
 800ed6a:	f7f8 f90f 	bl	8006f8c <set_marker_index>
      redraw_marker(active_marker);
 800ed6e:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800ed72:	f7fe f9f5 	bl	800d160 <redraw_marker>
 800ed76:	e003      	b.n	800ed80 <ui_normal_touch+0x100>
      chThdSleepMilliseconds(50); // Not check new position too fast
 800ed78:	f241 3088 	movw	r0, #5000	@ 0x1388
 800ed7c:	f7f2 f888 	bl	8000e90 <chThdSleep>
  } while (touch_check() != EVT_TOUCH_RELEASED);
 800ed80:	f7fe fb7a 	bl	800d478 <touch_check>
 800ed84:	2803      	cmp	r0, #3
 800ed86:	d1db      	bne.n	800ed40 <ui_normal_touch+0xc0>
 800ed88:	e097      	b.n	800eeba <ui_normal_touch+0x23a>
  if (touch_y < HEIGHT || touch_x < FREQUENCIES_XPOS3 || touch_x > FREQUENCIES_XPOS2)
 800ed8a:	f5b1 7f98 	cmp.w	r1, #304	@ 0x130
 800ed8e:	db18      	blt.n	800edc2 <ui_normal_touch+0x142>
 800ed90:	3bce      	subs	r3, #206	@ 0xce
 800ed92:	2b78      	cmp	r3, #120	@ 0x78
 800ed94:	d809      	bhi.n	800edaa <ui_normal_touch+0x12a>
  touch_wait_release();
 800ed96:	f7fe fb9f 	bl	800d4d8 <touch_wait_release>
  menu_sdcard_cb(FMT_BMP_FILE);
 800ed9a:	2002      	movs	r0, #2
  if (touch_apply_ref_scale(touch_x, touch_y))
    return; // Try apply ref / scale
  // default: switch menu mode after release
  touch_wait_release();
  ui_mode_menu();
}
 800ed9c:	b009      	add	sp, #36	@ 0x24
 800ed9e:	ecbd 8b02 	vpop	{d8}
 800eda2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  menu_sdcard_cb(FMT_BMP_FILE);
 800eda6:	f7ff bf43 	b.w	800ec30 <menu_sdcard_cb>
  if (touch_y > HEIGHT && (props_mode & DOMAIN_MODE) == DOMAIN_FREQ) // Only for frequency domain
 800edaa:	f5b1 7f98 	cmp.w	r1, #304	@ 0x130
 800edae:	d039      	beq.n	800ee24 <ui_normal_touch+0x1a4>
 800edb0:	8b2b      	ldrh	r3, [r5, #24]
 800edb2:	07d9      	lsls	r1, r3, #31
 800edb4:	d436      	bmi.n	800ee24 <ui_normal_touch+0x1a4>
    mode = touch_x < FREQUENCIES_XPOS2 ? LM_FREQ_0 : LM_FREQ_1;
 800edb6:	f5b7 7fa3 	cmp.w	r7, #326	@ 0x146
 800edba:	bfac      	ite	ge
 800edbc:	2403      	movge	r4, #3
 800edbe:	2402      	movlt	r4, #2
 800edc0:	e00f      	b.n	800ede2 <ui_normal_touch+0x162>
  if (touch_y < UI_MARKER_Y0)
 800edc2:	291d      	cmp	r1, #29
 800edc4:	dc2e      	bgt.n	800ee24 <ui_normal_touch+0x1a4>
    mode = (touch_x < (LCD_WIDTH / 2) && get_electrical_delay() != 0.0f) ? LM_EDELAY : LM_MARKER;
 800edc6:	2bef      	cmp	r3, #239	@ 0xef
 800edc8:	dc0a      	bgt.n	800ede0 <ui_normal_touch+0x160>
 800edca:	f7f9 fc69 	bl	80086a0 <get_electrical_delay>
 800edce:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800edd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800edd6:	bf14      	ite	ne
 800edd8:	2401      	movne	r4, #1
 800edda:	2400      	moveq	r4, #0
 800eddc:	00a4      	lsls	r4, r4, #2
 800edde:	e000      	b.n	800ede2 <ui_normal_touch+0x162>
 800ede0:	2400      	movs	r4, #0
  touch_wait_release();
 800ede2:	f7fe fb79 	bl	800d4d8 <touch_wait_release>
  if (select_lever_mode(mode))
 800ede6:	4620      	mov	r0, r4
 800ede8:	f7fe fb7c 	bl	800d4e4 <select_lever_mode>
 800edec:	2800      	cmp	r0, #0
 800edee:	d164      	bne.n	800eeba <ui_normal_touch+0x23a>
  switch (mode)
 800edf0:	2c03      	cmp	r4, #3
 800edf2:	d008      	beq.n	800ee06 <ui_normal_touch+0x186>
 800edf4:	2c04      	cmp	r4, #4
 800edf6:	d013      	beq.n	800ee20 <ui_normal_touch+0x1a0>
 800edf8:	2c02      	cmp	r4, #2
 800edfa:	d15e      	bne.n	800eeba <ui_normal_touch+0x23a>
    ui_mode_keypad(FREQ_IS_CENTERSPAN() ? KM_CENTER : KM_START);
 800edfc:	8b28      	ldrh	r0, [r5, #24]
 800edfe:	1140      	asrs	r0, r0, #5
 800ee00:	f000 0002 	and.w	r0, r0, #2
 800ee04:	e005      	b.n	800ee12 <ui_normal_touch+0x192>
    ui_mode_keypad(FREQ_IS_CENTERSPAN() ? KM_SPAN : KM_STOP);
 800ee06:	8b2b      	ldrh	r3, [r5, #24]
 800ee08:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800ee0c:	bf14      	ite	ne
 800ee0e:	4620      	movne	r0, r4
 800ee10:	2001      	moveq	r0, #1
}
 800ee12:	b009      	add	sp, #36	@ 0x24
 800ee14:	ecbd 8b02 	vpop	{d8}
 800ee18:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui_mode_keypad(FREQ_IS_CENTERSPAN() ? KM_SPAN : KM_STOP);
 800ee1c:	f7fe bd3c 	b.w	800d898 <ui_mode_keypad>
    ui_mode_keypad(KM_EDELAY);
 800ee20:	200f      	movs	r0, #15
 800ee22:	e7f6      	b.n	800ee12 <ui_normal_touch+0x192>
  int t = current_trace;
 800ee24:	4b27      	ldr	r3, [pc, #156]	@ (800eec4 <ui_normal_touch+0x244>)
 800ee26:	f993 501c 	ldrsb.w	r5, [r3, #28]
  if (t == TRACE_INVALID || trace[t].type == TRC_SMITH)
 800ee2a:	1c6a      	adds	r2, r5, #1
 800ee2c:	d03c      	beq.n	800eea8 <ui_normal_touch+0x228>
 800ee2e:	220c      	movs	r2, #12
 800ee30:	fb02 3305 	mla	r3, r2, r5, r3
 800ee34:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800ee38:	2a03      	cmp	r2, #3
 800ee3a:	d035      	beq.n	800eea8 <ui_normal_touch+0x228>
  if (touch_x < UI_SCALE_REF_X0 || touch_x > UI_SCALE_REF_X1 ||
 800ee3c:	3f0a      	subs	r7, #10
 800ee3e:	2f14      	cmp	r7, #20
 800ee40:	d832      	bhi.n	800eea8 <ui_normal_touch+0x228>
      touch_y < OFFSETY || touch_y > AREA_HEIGHT_NORMAL)
 800ee42:	f5b4 7f99 	cmp.w	r4, #306	@ 0x132
 800ee46:	da2f      	bge.n	800eea8 <ui_normal_touch+0x228>
  if (touch_y < GRIDY * 1 * NGRIDY / 4)
 800ee48:	2c4b      	cmp	r4, #75	@ 0x4b
  float ref = get_trace_refpos(t);
 800ee4a:	ed93 7a0c 	vldr	s14, [r3, #48]	@ 0x30
  float scale = get_trace_scale(t);
 800ee4e:	ed93 0a0b 	vldr	s0, [r3, #44]	@ 0x2c
  if (touch_y < GRIDY * 1 * NGRIDY / 4)
 800ee52:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 800ee56:	dc02      	bgt.n	800ee5e <ui_normal_touch+0x1de>
    ref += 0.5f;
 800ee58:	ee37 8a27 	vadd.f32	s16, s14, s15
 800ee5c:	e013      	b.n	800ee86 <ui_normal_touch+0x206>
  else if (touch_y < GRIDY * 2 * NGRIDY / 4)
 800ee5e:	2c97      	cmp	r4, #151	@ 0x97
 800ee60:	dc04      	bgt.n	800ee6c <ui_normal_touch+0x1ec>
    scale *= 2.0f;
 800ee62:	ee30 0a00 	vadd.f32	s0, s0, s0
    ref = ref / 2.0f - NGRIDY / 4 + NGRIDY / 2;
 800ee66:	eeb0 8a00 	vmov.f32	s16, #0	@ 0x40000000  2.0
 800ee6a:	e007      	b.n	800ee7c <ui_normal_touch+0x1fc>
  else if (touch_y < GRIDY * 3 * NGRIDY / 4)
 800ee6c:	2ce3      	cmp	r4, #227	@ 0xe3
 800ee6e:	dc08      	bgt.n	800ee82 <ui_normal_touch+0x202>
    scale /= 2.0f;
 800ee70:	ee20 0a27 	vmul.f32	s0, s0, s15
    ref = ref * 2.0f - NGRIDY + NGRIDY / 2;
 800ee74:	eeb9 8a00 	vmov.f32	s16, #144	@ 0xc0800000 -4.0
 800ee78:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800ee7c:	eea7 8a27 	vfma.f32	s16, s14, s15
 800ee80:	e001      	b.n	800ee86 <ui_normal_touch+0x206>
    ref -= 0.5f;
 800ee82:	ee37 8a67 	vsub.f32	s16, s14, s15
  set_trace_scale(t, scale);
 800ee86:	4628      	mov	r0, r5
 800ee88:	f7f8 fc56 	bl	8007738 <set_trace_scale>
  set_trace_refpos(t, ref);
 800ee8c:	4628      	mov	r0, r5
 800ee8e:	eeb0 0a48 	vmov.f32	s0, s16
 800ee92:	f7f8 fc65 	bl	8007760 <set_trace_refpos>
  chThdSleepMilliseconds(200);
 800ee96:	f644 6020 	movw	r0, #20000	@ 0x4e20
}
 800ee9a:	b009      	add	sp, #36	@ 0x24
 800ee9c:	ecbd 8b02 	vpop	{d8}
 800eea0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  chThdSleepMilliseconds(200);
 800eea4:	f7f1 bff4 	b.w	8000e90 <chThdSleep>
  touch_wait_release();
 800eea8:	f7fe fb16 	bl	800d4d8 <touch_wait_release>
}
 800eeac:	b009      	add	sp, #36	@ 0x24
 800eeae:	ecbd 8b02 	vpop	{d8}
 800eeb2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ui_mode_menu();
 800eeb6:	f7ff bbd9 	b.w	800e66c <ui_mode_menu>
}
 800eeba:	b009      	add	sp, #36	@ 0x24
 800eebc:	ecbd 8b02 	vpop	{d8}
 800eec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800eec4:	20000aa8 	.word	0x20000aa8

0800eec8 <input_filename>:
  if (b)
 800eec8:	b919      	cbnz	r1, 800eed2 <input_filename+0xa>
  ui_save_file(kp_buf, data);
 800eeca:	b2c1      	uxtb	r1, r0
 800eecc:	4801      	ldr	r0, [pc, #4]	@ (800eed4 <input_filename+0xc>)
 800eece:	f7ff be37 	b.w	800eb40 <ui_save_file>
}
 800eed2:	4770      	bx	lr
 800eed4:	200089c8 	.word	0x200089c8

0800eed8 <browser_key_press>:
  switch (key) {
 800eed8:	2802      	cmp	r0, #2
 800eeda:	f000 80ef 	beq.w	800f0bc <browser_key_press+0x1e4>
 800eede:	dc03      	bgt.n	800eee8 <browser_key_press+0x10>
      page = current_page;
 800eee0:	4b78      	ldr	r3, [pc, #480]	@ (800f0c4 <browser_key_press+0x1ec>)
 800eee2:	881a      	ldrh	r2, [r3, #0]
      if (key == FILE_BUTTON_LEFT  && --current_page < 1) current_page = page_count;
 800eee4:	b1a0      	cbz	r0, 800ef10 <browser_key_press+0x38>
 800eee6:	e008      	b.n	800eefa <browser_key_press+0x22>
  switch (key) {
 800eee8:	2803      	cmp	r0, #3
 800eeea:	d11f      	bne.n	800ef2c <browser_key_press+0x54>
      browser_mode^= BROWSER_DELETE;
 800eeec:	4a76      	ldr	r2, [pc, #472]	@ (800f0c8 <browser_key_press+0x1f0>)
 800eeee:	8813      	ldrh	r3, [r2, #0]
 800eef0:	f083 0301 	eor.w	r3, r3, #1
 800eef4:	8013      	strh	r3, [r2, #0]
      browser_draw_buttons();
 800eef6:	f7fe bc15 	b.w	800d724 <browser_draw_buttons>
      if (key == FILE_BUTTON_RIGHT && ++current_page > page_count) current_page = 1;
 800eefa:	4974      	ldr	r1, [pc, #464]	@ (800f0cc <browser_key_press+0x1f4>)
 800eefc:	1c50      	adds	r0, r2, #1
 800eefe:	8809      	ldrh	r1, [r1, #0]
 800ef00:	b280      	uxth	r0, r0
 800ef02:	4281      	cmp	r1, r0
 800ef04:	8018      	strh	r0, [r3, #0]
 800ef06:	f080 80d4 	bcs.w	800f0b2 <browser_key_press+0x1da>
 800ef0a:	2101      	movs	r1, #1
 800ef0c:	4608      	mov	r0, r1
 800ef0e:	e008      	b.n	800ef22 <browser_key_press+0x4a>
      if (key == FILE_BUTTON_LEFT  && --current_page < 1) current_page = page_count;
 800ef10:	1e50      	subs	r0, r2, #1
 800ef12:	b280      	uxth	r0, r0
 800ef14:	8018      	strh	r0, [r3, #0]
 800ef16:	2800      	cmp	r0, #0
 800ef18:	f040 80cb 	bne.w	800f0b2 <browser_key_press+0x1da>
 800ef1c:	496b      	ldr	r1, [pc, #428]	@ (800f0cc <browser_key_press+0x1f4>)
 800ef1e:	8808      	ldrh	r0, [r1, #0]
 800ef20:	4601      	mov	r1, r0
      if (page != current_page)
 800ef22:	4282      	cmp	r2, r0
      if (key == FILE_BUTTON_RIGHT && ++current_page > page_count) current_page = 1;
 800ef24:	8019      	strh	r1, [r3, #0]
      if (page != current_page)
 800ef26:	f000 80cb 	beq.w	800f0c0 <browser_key_press+0x1e8>
 800ef2a:	e0c2      	b.n	800f0b2 <browser_key_press+0x1da>
static void browser_key_press(int key) {
 800ef2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      browser_open_file(key - FILE_BUTTON_FILE + (current_page - 1) * FILES_PER_PAGE);
 800ef30:	f8df 9190 	ldr.w	r9, [pc, #400]	@ 800f0c4 <browser_key_press+0x1ec>
  if ((uint16_t)sel >= file_count) return;
 800ef34:	4e66      	ldr	r6, [pc, #408]	@ (800f0d0 <browser_key_press+0x1f8>)
      browser_open_file(key - FILE_BUTTON_FILE + (current_page - 1) * FILES_PER_PAGE);
 800ef36:	f8b9 3000 	ldrh.w	r3, [r9]
 800ef3a:	221e      	movs	r2, #30
 800ef3c:	3b01      	subs	r3, #1
 800ef3e:	3804      	subs	r0, #4
 800ef40:	fb02 0403 	mla	r4, r2, r3, r0
  if ((uint16_t)sel >= file_count) return;
 800ef44:	8832      	ldrh	r2, [r6, #0]
 800ef46:	b2a3      	uxth	r3, r4
 800ef48:	429a      	cmp	r2, r3
static void browser_key_press(int key) {
 800ef4a:	b0a8      	sub	sp, #160	@ 0xa0
  if ((uint16_t)sel >= file_count) return;
 800ef4c:	f240 80a0 	bls.w	800f090 <browser_key_press+0x1b8>
  if (f_mount(fs_volume, "", 1) != FR_OK) return;
 800ef50:	4960      	ldr	r1, [pc, #384]	@ (800f0d4 <browser_key_press+0x1fc>)
 800ef52:	4861      	ldr	r0, [pc, #388]	@ (800f0d8 <browser_key_press+0x200>)
 800ef54:	2201      	movs	r2, #1
 800ef56:	f7f5 fc9f 	bl	8004898 <f_mount>
 800ef5a:	2800      	cmp	r0, #0
 800ef5c:	f040 8098 	bne.w	800f090 <browser_key_press+0x1b8>
  if (sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) return;  // open dir
 800ef60:	f8df 8188 	ldr.w	r8, [pc, #392]	@ 800f0ec <browser_key_press+0x214>
 800ef64:	4f5d      	ldr	r7, [pc, #372]	@ (800f0dc <browser_key_press+0x204>)
 800ef66:	783b      	ldrb	r3, [r7, #0]
  return f_opendir(dp, path);
 800ef68:	495a      	ldr	r1, [pc, #360]	@ (800f0d4 <browser_key_press+0x1fc>)
  if (sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) return;  // open dir
 800ef6a:	011b      	lsls	r3, r3, #4
  return f_opendir(dp, path);
 800ef6c:	a812      	add	r0, sp, #72	@ 0x48
  dp->pat = pattern;
 800ef6e:	f858 3003 	ldr.w	r3, [r8, r3]
 800ef72:	9326      	str	r3, [sp, #152]	@ 0x98
  return f_opendir(dp, path);
 800ef74:	f7f6 f84e 	bl	8005014 <f_opendir>
  if (sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) return;  // open dir
 800ef78:	2800      	cmp	r0, #0
 800ef7a:	f040 8089 	bne.w	800f090 <browser_key_press+0x1b8>
  cnt = sel;
 800ef7e:	4625      	mov	r5, r4
  while (sd_findnext(&dj, &fno) == FR_OK && cnt != 0) cnt--;             // skip cnt files
 800ef80:	a902      	add	r1, sp, #8
 800ef82:	a812      	add	r0, sp, #72	@ 0x48
 800ef84:	f7fe ffbe 	bl	800df04 <sd_findnext>
 800ef88:	b910      	cbnz	r0, 800ef90 <browser_key_press+0xb8>
 800ef8a:	b10d      	cbz	r5, 800ef90 <browser_key_press+0xb8>
 800ef8c:	3d01      	subs	r5, #1
 800ef8e:	e7f7      	b.n	800ef80 <browser_key_press+0xa8>
  f_closedir(&dj);
 800ef90:	a812      	add	r0, sp, #72	@ 0x48
 800ef92:	f7f6 f883 	bl	800509c <f_closedir>
  if (browser_mode & BROWSER_DELETE) {f_unlink(fno.fname); return;}
 800ef96:	4b4c      	ldr	r3, [pc, #304]	@ (800f0c8 <browser_key_press+0x1f0>)
 800ef98:	881b      	ldrh	r3, [r3, #0]
 800ef9a:	f003 0301 	and.w	r3, r3, #1
  if (cnt != 0) return;
 800ef9e:	2d00      	cmp	r5, #0
 800efa0:	d176      	bne.n	800f090 <browser_key_press+0x1b8>
  if (browser_mode & BROWSER_DELETE) {f_unlink(fno.fname); return;}
 800efa2:	b123      	cbz	r3, 800efae <browser_key_press+0xd6>
 800efa4:	f10d 0022 	add.w	r0, sp, #34	@ 0x22
 800efa8:	f7f6 f8be 	bl	8005128 <f_unlink>
 800efac:	e070      	b.n	800f090 <browser_key_press+0x1b8>
  file_load_cb_t load = file_opt[keypad_mode].load;
 800efae:	783b      	ldrb	r3, [r7, #0]
 800efb0:	eb08 1303 	add.w	r3, r8, r3, lsl #4
 800efb4:	f8d3 a008 	ldr.w	sl, [r3, #8]
  if (load == NULL) return;
 800efb8:	f1ba 0f00 	cmp.w	sl, #0
 800efbc:	d068      	beq.n	800f090 <browser_key_press+0x1b8>
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800efbe:	4629      	mov	r1, r5
 800efc0:	2001      	movs	r0, #1
 800efc2:	f001 f89d 	bl	8010100 <lcd_set_colors>
  if (f_open(fs_file, fno.fname, FA_READ) != FR_OK) return;
 800efc6:	4846      	ldr	r0, [pc, #280]	@ (800f0e0 <browser_key_press+0x208>)
 800efc8:	2201      	movs	r2, #1
 800efca:	f10d 0122 	add.w	r1, sp, #34	@ 0x22
 800efce:	f7f5 fc85 	bl	80048dc <f_open>
 800efd2:	2800      	cmp	r0, #0
 800efd4:	d15c      	bne.n	800f090 <browser_key_press+0x1b8>
  const char *error = load(fs_file, &fno, keypad_mode);
 800efd6:	783a      	ldrb	r2, [r7, #0]
 800efd8:	4841      	ldr	r0, [pc, #260]	@ (800f0e0 <browser_key_press+0x208>)
 800efda:	a902      	add	r1, sp, #8
 800efdc:	47d0      	blx	sl
 800efde:	4682      	mov	sl, r0
  f_close(fs_file);
 800efe0:	483f      	ldr	r0, [pc, #252]	@ (800f0e0 <browser_key_press+0x208>)
 800efe2:	f7f6 f807 	bl	8004ff4 <f_close>
  bool need_continue = file_opt[keypad_mode].opt & FILE_OPT_CONTINUE;
 800efe6:	783b      	ldrb	r3, [r7, #0]
 800efe8:	eb08 1303 	add.w	r3, r8, r3, lsl #4
 800efec:	68dd      	ldr	r5, [r3, #12]
 800efee:	f005 0502 	and.w	r5, r5, #2
  if (error) {
 800eff2:	f1ba 0f00 	cmp.w	sl, #0
 800eff6:	d00b      	beq.n	800f010 <browser_key_press+0x138>
    lcd_clear_screen();
 800eff8:	f001 f81c 	bl	8010034 <lcd_clear_screen>
    ui_message_box(error, fno.fname, need_continue ? 100 : 2000);
 800effc:	2d00      	cmp	r5, #0
 800effe:	bf0c      	ite	eq
 800f000:	f44f 62fa 	moveq.w	r2, #2000	@ 0x7d0
 800f004:	2264      	movne	r2, #100	@ 0x64
 800f006:	f10d 0122 	add.w	r1, sp, #34	@ 0x22
 800f00a:	4650      	mov	r0, sl
 800f00c:	f7ff fcba 	bl	800e984 <ui_message_box>
  if (!need_continue) return;
 800f010:	2d00      	cmp	r5, #0
 800f012:	d03d      	beq.n	800f090 <browser_key_press+0x1b8>
    uint16_t status = btn_check();
 800f014:	f7fe fa76 	bl	800d504 <btn_check>
    if (status & EVT_UP  ) key = 1;
 800f018:	06c5      	lsls	r5, r0, #27
    if (status & EVT_DOWN) key = 0;
 800f01a:	bf5a      	itte	pl
 800f01c:	f3c0 1540 	ubfxpl	r5, r0, #5, #1
 800f020:	f105 35ff 	addpl.w	r5, r5, #4294967295
    if (status & EVT_UP  ) key = 1;
 800f024:	2501      	movmi	r5, #1
    if (status & EVT_BUTTON_SINGLE_CLICK) key = 2;
 800f026:	f010 0f01 	tst.w	r0, #1
 800f02a:	bf18      	it	ne
 800f02c:	2502      	movne	r5, #2
    status = touch_check();
 800f02e:	f7fe fa23 	bl	800d478 <touch_check>
    if (status == EVT_TOUCH_PRESSED || status == EVT_TOUCH_DOWN) {
 800f032:	3801      	subs	r0, #1
 800f034:	b280      	uxth	r0, r0
 800f036:	2801      	cmp	r0, #1
 800f038:	d80f      	bhi.n	800f05a <browser_key_press+0x182>
      touch_position(&touch_x, &touch_y);
 800f03a:	a901      	add	r1, sp, #4
 800f03c:	4668      	mov	r0, sp
 800f03e:	f7fe f8f3 	bl	800d228 <touch_position>
           if (touch_x < LCD_WIDTH *1/3) key = 0;
 800f042:	9b00      	ldr	r3, [sp, #0]
 800f044:	2b9f      	cmp	r3, #159	@ 0x9f
 800f046:	dd05      	ble.n	800f054 <browser_key_press+0x17c>
      else if (touch_x < LCD_WIDTH *2/3) key = 2;
 800f048:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800f04c:	bfac      	ite	ge
 800f04e:	2501      	movge	r5, #1
 800f050:	2502      	movlt	r5, #2
 800f052:	e000      	b.n	800f056 <browser_key_press+0x17e>
           if (touch_x < LCD_WIDTH *1/3) key = 0;
 800f054:	2500      	movs	r5, #0
      touch_wait_release();
 800f056:	f7fe fa3f 	bl	800d4d8 <touch_wait_release>
inline void delayMilliseconds(uint32_t ms) {_delay_8t(ms*125*STM32_CORE_CLOCK);}
 800f05a:	4822      	ldr	r0, [pc, #136]	@ (800f0e4 <browser_key_press+0x20c>)
 800f05c:	f7f9 fe06 	bl	8008c6c <_delay_8t>
         if (key == 0) {if (--sel < 0) sel = file_count - 1;}
 800f060:	b935      	cbnz	r5, 800f070 <browser_key_press+0x198>
 800f062:	1e63      	subs	r3, r4, #1
 800f064:	d401      	bmi.n	800f06a <browser_key_press+0x192>
repeat:
 800f066:	461c      	mov	r4, r3
 800f068:	e77d      	b.n	800ef66 <browser_key_press+0x8e>
         if (key == 0) {if (--sel < 0) sel = file_count - 1;}
 800f06a:	8833      	ldrh	r3, [r6, #0]
 800f06c:	3b01      	subs	r3, #1
 800f06e:	e00b      	b.n	800f088 <browser_key_press+0x1b0>
    else if (key == 1) {if (++sel > file_count - 1) sel = 0;}
 800f070:	2d01      	cmp	r5, #1
 800f072:	d105      	bne.n	800f080 <browser_key_press+0x1a8>
 800f074:	8832      	ldrh	r2, [r6, #0]
 800f076:	1c63      	adds	r3, r4, #1
 800f078:	429a      	cmp	r2, r3
 800f07a:	dcf4      	bgt.n	800f066 <browser_key_press+0x18e>
 800f07c:	2300      	movs	r3, #0
 800f07e:	e003      	b.n	800f088 <browser_key_press+0x1b0>
    else if (key == 2) break;
 800f080:	2d02      	cmp	r5, #2
 800f082:	d005      	beq.n	800f090 <browser_key_press+0x1b8>
 800f084:	4623      	mov	r3, r4
 800f086:	e001      	b.n	800f08c <browser_key_press+0x1b4>
    if (old_sel != sel) goto repeat;
 800f088:	429c      	cmp	r4, r3
 800f08a:	d1ec      	bne.n	800f066 <browser_key_press+0x18e>
    ui_message_box(error, fno.fname, need_continue ? 100 : 2000);
 800f08c:	461c      	mov	r4, r3
 800f08e:	e7c1      	b.n	800f014 <browser_key_press+0x13c>
      if (browser_mode & BROWSER_DELETE) {
 800f090:	4a0d      	ldr	r2, [pc, #52]	@ (800f0c8 <browser_key_press+0x1f0>)
 800f092:	8813      	ldrh	r3, [r2, #0]
 800f094:	07d9      	lsls	r1, r3, #31
 800f096:	d50e      	bpl.n	800f0b6 <browser_key_press+0x1de>
        file_count = 0;                      // Reeset file count (recalculate on draw page)
 800f098:	2100      	movs	r1, #0
 800f09a:	8031      	strh	r1, [r6, #0]
        selection = -1;                      // Reset delection
 800f09c:	4912      	ldr	r1, [pc, #72]	@ (800f0e8 <browser_key_press+0x210>)
 800f09e:	20ff      	movs	r0, #255	@ 0xff
 800f0a0:	7008      	strb	r0, [r1, #0]
        browser_draw_page(current_page);
 800f0a2:	f8b9 0000 	ldrh.w	r0, [r9]
        browser_mode&=~BROWSER_DELETE;       // Exit file delete mode
 800f0a6:	f023 0301 	bic.w	r3, r3, #1
 800f0aa:	8013      	strh	r3, [r2, #0]
}
 800f0ac:	b028      	add	sp, #160	@ 0xa0
 800f0ae:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        browser_draw_page(current_page);
 800f0b2:	f7ff bcb5 	b.w	800ea20 <browser_draw_page>
}
 800f0b6:	b028      	add	sp, #160	@ 0xa0
 800f0b8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      ui_mode_normal(); // Exit
 800f0bc:	f7fe bb7a 	b.w	800d7b4 <ui_mode_normal>
 800f0c0:	4770      	bx	lr
 800f0c2:	bf00      	nop
 800f0c4:	200089ac 	.word	0x200089ac
 800f0c8:	200089aa 	.word	0x200089aa
 800f0cc:	200089ae 	.word	0x200089ae
 800f0d0:	200089b0 	.word	0x200089b0
 800f0d4:	08012921 	.word	0x08012921
 800f0d8:	200097b8 	.word	0x200097b8
 800f0dc:	200089bf 	.word	0x200089bf
 800f0e0:	20009568 	.word	0x20009568
 800f0e4:	000dbba0 	.word	0x000dbba0
 800f0e8:	200003f0 	.word	0x200003f0
 800f0ec:	08014bd0 	.word	0x08014bd0

0800f0f0 <ui_browser_touch>:
  browser_mode = 0;
  browser_draw_page(current_page);
}

// Process UI input for browser
static void ui_browser_touch(int touch_x, int touch_y) {
 800f0f0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  browser_btn_t btn;
  int old = selection;
 800f0f4:	4f1d      	ldr	r7, [pc, #116]	@ (800f16c <ui_browser_touch+0x7c>)
static void ui_browser_touch(int touch_x, int touch_y) {
 800f0f6:	4606      	mov	r6, r0
  int max = browser_get_max();
 800f0f8:	f7fe f908 	bl	800d30c <browser_get_max>
  int old = selection;
 800f0fc:	f997 9000 	ldrsb.w	r9, [r7]
static void ui_browser_touch(int touch_x, int touch_y) {
 800f100:	460d      	mov	r5, r1
  int max = browser_get_max();
 800f102:	4680      	mov	r8, r0
  for (int idx = 0; idx <= max; idx++) {
 800f104:	2400      	movs	r4, #0
    browser_get_button_pos(idx, &btn);
 800f106:	4669      	mov	r1, sp
 800f108:	4620      	mov	r0, r4
 800f10a:	f7fe f8db 	bl	800d2c4 <browser_get_button_pos>
    if (touch_x < btn.x || touch_x >= btn.x + btn.w ||
 800f10e:	f8bd 2000 	ldrh.w	r2, [sp]
 800f112:	42b2      	cmp	r2, r6
 800f114:	dc0d      	bgt.n	800f132 <ui_browser_touch+0x42>
 800f116:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800f11a:	4413      	add	r3, r2
 800f11c:	42b3      	cmp	r3, r6
 800f11e:	dd08      	ble.n	800f132 <ui_browser_touch+0x42>
        touch_y < btn.y || touch_y >= btn.y + btn.h) continue;
 800f120:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    if (touch_x < btn.x || touch_x >= btn.x + btn.w ||
 800f124:	42aa      	cmp	r2, r5
 800f126:	dc04      	bgt.n	800f132 <ui_browser_touch+0x42>
        touch_y < btn.y || touch_y >= btn.y + btn.h) continue;
 800f128:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800f12c:	4413      	add	r3, r2
 800f12e:	42ab      	cmp	r3, r5
 800f130:	dc05      	bgt.n	800f13e <ui_browser_touch+0x4e>
  for (int idx = 0; idx <= max; idx++) {
 800f132:	3401      	adds	r4, #1
 800f134:	45a0      	cmp	r8, r4
 800f136:	dae6      	bge.n	800f106 <ui_browser_touch+0x16>
    selection = -1;
    browser_draw_button(idx, NULL);              // clear selection
    browser_key_press(idx);
    return;
  }
}
 800f138:	b003      	add	sp, #12
 800f13a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    browser_draw_button(selection = idx, NULL);  // draw new selection
 800f13e:	4620      	mov	r0, r4
 800f140:	2100      	movs	r1, #0
 800f142:	703c      	strb	r4, [r7, #0]
 800f144:	f7fe faa4 	bl	800d690 <browser_draw_button>
    browser_draw_button(old, NULL);              // clear old
 800f148:	4648      	mov	r0, r9
 800f14a:	2100      	movs	r1, #0
 800f14c:	f7fe faa0 	bl	800d690 <browser_draw_button>
    touch_wait_release();
 800f150:	f7fe f9c2 	bl	800d4d8 <touch_wait_release>
    selection = -1;
 800f154:	23ff      	movs	r3, #255	@ 0xff
    browser_draw_button(idx, NULL);              // clear selection
 800f156:	4620      	mov	r0, r4
 800f158:	2100      	movs	r1, #0
    selection = -1;
 800f15a:	703b      	strb	r3, [r7, #0]
    browser_draw_button(idx, NULL);              // clear selection
 800f15c:	f7fe fa98 	bl	800d690 <browser_draw_button>
    browser_key_press(idx);
 800f160:	4620      	mov	r0, r4
}
 800f162:	b003      	add	sp, #12
 800f164:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    browser_key_press(idx);
 800f168:	f7ff beb6 	b.w	800eed8 <browser_key_press>
 800f16c:	200003f0 	.word	0x200003f0

0800f170 <ui_browser_lever>:

static void ui_browser_lever(uint16_t status) {
  if (status == EVT_BUTTON_SINGLE_CLICK) {
 800f170:	2801      	cmp	r0, #1
static void ui_browser_lever(uint16_t status) {
 800f172:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f174:	4f1c      	ldr	r7, [pc, #112]	@ (800f1e8 <ui_browser_lever+0x78>)
  if (status == EVT_BUTTON_SINGLE_CLICK) {
 800f176:	d107      	bne.n	800f188 <ui_browser_lever+0x18>
    if (selection >= 0) browser_key_press(selection); // Process click
 800f178:	f997 0000 	ldrsb.w	r0, [r7]
 800f17c:	2800      	cmp	r0, #0
 800f17e:	db32      	blt.n	800f1e6 <ui_browser_lever+0x76>
      browser_draw_button(old, NULL);       // clear old selection
      browser_draw_button(selection, NULL); // draw new selection
    }
    chThdSleepMilliseconds(100);
  } while ((status = btn_wait_release()) != 0);
}
 800f180:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (selection >= 0) browser_key_press(selection); // Process click
 800f184:	f7ff bea8 	b.w	800eed8 <browser_key_press>
 800f188:	4601      	mov	r1, r0
  int max = browser_get_max();
 800f18a:	f7fe f8bf 	bl	800d30c <browser_get_max>
    if((status & EVT_UP)   && ++selection > max) selection = 0;
 800f18e:	2600      	movs	r6, #0
  int max = browser_get_max();
 800f190:	4604      	mov	r4, r0
    if((status & EVT_DOWN) && --selection < 0) selection = max;
 800f192:	b245      	sxtb	r5, r0
 800f194:	068b      	lsls	r3, r1, #26
    int old = selection;
 800f196:	f997 0000 	ldrsb.w	r0, [r7]
    if((status & EVT_DOWN) && --selection < 0) selection = max;
 800f19a:	d507      	bpl.n	800f1ac <ui_browser_lever+0x3c>
 800f19c:	1e43      	subs	r3, r0, #1
 800f19e:	b25b      	sxtb	r3, r3
 800f1a0:	2b00      	cmp	r3, #0
 800f1a2:	bfae      	itee	ge
 800f1a4:	703b      	strbge	r3, [r7, #0]
 800f1a6:	462b      	movlt	r3, r5
 800f1a8:	703d      	strblt	r5, [r7, #0]
 800f1aa:	e000      	b.n	800f1ae <ui_browser_lever+0x3e>
 800f1ac:	4603      	mov	r3, r0
    if((status & EVT_UP)   && ++selection > max) selection = 0;
 800f1ae:	06ca      	lsls	r2, r1, #27
 800f1b0:	d506      	bpl.n	800f1c0 <ui_browser_lever+0x50>
 800f1b2:	3301      	adds	r3, #1
 800f1b4:	b25b      	sxtb	r3, r3
 800f1b6:	42a3      	cmp	r3, r4
 800f1b8:	bfd2      	itee	le
 800f1ba:	703b      	strble	r3, [r7, #0]
 800f1bc:	703e      	strbgt	r6, [r7, #0]
 800f1be:	2300      	movgt	r3, #0
    if (old != selection) {
 800f1c0:	4298      	cmp	r0, r3
 800f1c2:	d007      	beq.n	800f1d4 <ui_browser_lever+0x64>
      browser_draw_button(old, NULL);       // clear old selection
 800f1c4:	2100      	movs	r1, #0
 800f1c6:	f7fe fa63 	bl	800d690 <browser_draw_button>
      browser_draw_button(selection, NULL); // draw new selection
 800f1ca:	f997 0000 	ldrsb.w	r0, [r7]
 800f1ce:	2100      	movs	r1, #0
 800f1d0:	f7fe fa5e 	bl	800d690 <browser_draw_button>
    chThdSleepMilliseconds(100);
 800f1d4:	f242 7010 	movw	r0, #10000	@ 0x2710
 800f1d8:	f7f1 fe5a 	bl	8000e90 <chThdSleep>
  } while ((status = btn_wait_release()) != 0);
 800f1dc:	f7fe f9b8 	bl	800d550 <btn_wait_release>
 800f1e0:	4601      	mov	r1, r0
 800f1e2:	2800      	cmp	r0, #0
 800f1e4:	d1d6      	bne.n	800f194 <ui_browser_lever+0x24>
}
 800f1e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f1e8:	200003f0 	.word	0x200003f0

0800f1ec <ui_touch_cal_exec>:
{
 800f1ec:	b570      	push	{r4, r5, r6, lr}
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 800f1ee:	4d0f      	ldr	r5, [pc, #60]	@ (800f22c <ui_touch_cal_exec+0x40>)
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
 800f1f0:	4a0f      	ldr	r2, [pc, #60]	@ (800f230 <ui_touch_cal_exec+0x44>)
 800f1f2:	8aab      	ldrh	r3, [r5, #20]
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 800f1f4:	f013 0320 	ands.w	r3, r3, #32
    p1 = 2, p2 = 0;
 800f1f8:	bf18      	it	ne
 800f1fa:	2302      	movne	r3, #2
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
 800f1fc:	f04f 010c 	mov.w	r1, #12
 800f200:	f103 0306 	add.w	r3, r3, #6
  uint16_t p1 = 0, p2 = 2;
 800f204:	bf0c      	ite	eq
 800f206:	2402      	moveq	r4, #2
    p1 = 2, p2 = 0;
 800f208:	2400      	movne	r4, #0
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
 800f20a:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800f20e:	4608      	mov	r0, r1
 800f210:	f7fe faa4 	bl	800d75c <getTouchPoint>
  getTouchPoint(x2, y2, "LOWER RIGHT", &config._touch_cal[p2]);
 800f214:	1da3      	adds	r3, r4, #6
 800f216:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800f21a:	4a06      	ldr	r2, [pc, #24]	@ (800f234 <ui_touch_cal_exec+0x48>)
}
 800f21c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  getTouchPoint(x2, y2, "LOWER RIGHT", &config._touch_cal[p2]);
 800f220:	f240 112b 	movw	r1, #299	@ 0x12b
 800f224:	f240 10cb 	movw	r0, #459	@ 0x1cb
 800f228:	f7fe ba98 	b.w	800d75c <getTouchPoint>
 800f22c:	20000318 	.word	0x20000318
 800f230:	08012b86 	.word	0x08012b86
 800f234:	08012b91 	.word	0x08012b91

0800f238 <ui_touch_draw_test>:
{
 800f238:	b5f0      	push	{r4, r5, r6, r7, lr}
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800f23a:	2100      	movs	r1, #0
 800f23c:	2001      	movs	r0, #1
{
 800f23e:	b087      	sub	sp, #28
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800f240:	f000 ff5e 	bl	8010100 <lcd_set_colors>
  lcd_clear_screen();
 800f244:	f000 fef6 	bl	8010034 <lcd_clear_screen>
  lcd_drawstring(OFFSETX, LCD_HEIGHT - FONT_GET_HEIGHT, "TOUCH TEST: DRAG PANEL, PRESS BUTTON TO FINISH");
 800f248:	4a19      	ldr	r2, [pc, #100]	@ (800f2b0 <ui_touch_draw_test+0x78>)
 800f24a:	f240 1135 	movw	r1, #309	@ 0x135
 800f24e:	200f      	movs	r0, #15
 800f250:	f000 ffe6 	bl	8010220 <lcd_printf>
    if (btn_check() & EVT_BUTTON_SINGLE_CLICK)
 800f254:	f7fe f956 	bl	800d504 <btn_check>
 800f258:	07c3      	lsls	r3, r0, #31
 800f25a:	d427      	bmi.n	800f2ac <ui_touch_draw_test+0x74>
    if (touch_check() == EVT_TOUCH_PRESSED)
 800f25c:	f7fe f90c 	bl	800d478 <touch_check>
 800f260:	2802      	cmp	r0, #2
 800f262:	d1f7      	bne.n	800f254 <ui_touch_draw_test+0x1c>
      touch_position(&x0, &y0);
 800f264:	a903      	add	r1, sp, #12
 800f266:	a802      	add	r0, sp, #8
 800f268:	f7fd ffde 	bl	800d228 <touch_position>
        lcd_printf(10, 30, "%3d %3d ", x0, y0);
 800f26c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800f270:	4a10      	ldr	r2, [pc, #64]	@ (800f2b4 <ui_touch_draw_test+0x7c>)
 800f272:	9700      	str	r7, [sp, #0]
 800f274:	4633      	mov	r3, r6
 800f276:	211e      	movs	r1, #30
 800f278:	200a      	movs	r0, #10
 800f27a:	f000 ffd1 	bl	8010220 <lcd_printf>
        chThdSleepMilliseconds(50);
 800f27e:	f241 3088 	movw	r0, #5000	@ 0x1388
 800f282:	f7f1 fe05 	bl	8000e90 <chThdSleep>
        touch_position(&x1, &y1);
 800f286:	a905      	add	r1, sp, #20
 800f288:	a804      	add	r0, sp, #16
 800f28a:	f7fd ffcd 	bl	800d228 <touch_position>
        lcd_line(x0, y0, x1, y1);
 800f28e:	e9dd 5404 	ldrd	r5, r4, [sp, #16]
 800f292:	4639      	mov	r1, r7
 800f294:	4623      	mov	r3, r4
 800f296:	462a      	mov	r2, r5
 800f298:	4630      	mov	r0, r6
 800f29a:	f000 fe77 	bl	800ff8c <lcd_line>
        y0 = y1;
 800f29e:	e9cd 5402 	strd	r5, r4, [sp, #8]
      } while (touch_check() != EVT_TOUCH_RELEASED);
 800f2a2:	f7fe f8e9 	bl	800d478 <touch_check>
 800f2a6:	2803      	cmp	r0, #3
 800f2a8:	d1e0      	bne.n	800f26c <ui_touch_draw_test+0x34>
 800f2aa:	e7d3      	b.n	800f254 <ui_touch_draw_test+0x1c>
}
 800f2ac:	b007      	add	sp, #28
 800f2ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f2b0:	08012b9d 	.word	0x08012b9d
 800f2b4:	08012bcc 	.word	0x08012bcc

0800f2b8 <menu_config_cb>:
{
 800f2b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  switch (data)
 800f2ba:	2804      	cmp	r0, #4
 800f2bc:	d877      	bhi.n	800f3ae <menu_config_cb+0xf6>
 800f2be:	e8df f000 	tbb	[pc, r0]
 800f2c2:	0603      	.short	0x0603
 800f2c4:	6a09      	.short	0x6a09
 800f2c6:	72          	.byte	0x72
 800f2c7:	00          	.byte	0x00
    ui_touch_cal_exec();
 800f2c8:	f7ff ff90 	bl	800f1ec <ui_touch_cal_exec>
    break;
 800f2cc:	e06f      	b.n	800f3ae <menu_config_cb+0xf6>
    ui_touch_draw_test();
 800f2ce:	f7ff ffb3 	bl	800f238 <ui_touch_draw_test>
    break;
 800f2d2:	e06c      	b.n	800f3ae <menu_config_cb+0xf6>
  lcd_clear_screen();
 800f2d4:	f000 feae 	bl	8010034 <lcd_clear_screen>
  lcd_set_colors(LCD_TRACE_1_COLOR, LCD_BG_COLOR);
 800f2d8:	2100      	movs	r1, #0
 800f2da:	2006      	movs	r0, #6
 800f2dc:	f000 ff10 	bl	8010100 <lcd_set_colors>
  lcd_drawstring_size("HB9IIU MLA ToolBox", x, y, 3);
 800f2e0:	2205      	movs	r2, #5
 800f2e2:	4611      	mov	r1, r2
 800f2e4:	4836      	ldr	r0, [pc, #216]	@ (800f3c0 <menu_config_cb+0x108>)
 800f2e6:	4f37      	ldr	r7, [pc, #220]	@ (800f3c4 <menu_config_cb+0x10c>)
 800f2e8:	2303      	movs	r3, #3
 800f2ea:	f001 f8b7 	bl	801045c <lcd_drawstring_size>
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800f2ee:	2100      	movs	r1, #0
 800f2f0:	2001      	movs	r0, #1
 800f2f2:	f000 ff05 	bl	8010100 <lcd_set_colors>
  uint16_t shift = 0b00010010000;
 800f2f6:	2690      	movs	r6, #144	@ 0x90
  y += FONT_GET_HEIGHT * 3 + 3 - 5;
 800f2f8:	2424      	movs	r4, #36	@ 0x24
  while (info_about[i])
 800f2fa:	f857 5f04 	ldr.w	r5, [r7, #4]!
 800f2fe:	b16d      	cbz	r5, 800f31c <menu_config_cb+0x64>
      shift >>= 1;
 800f300:	0876      	lsrs	r6, r6, #1
    } while (shift & 1);
 800f302:	07f1      	lsls	r1, r6, #31
 800f304:	4623      	mov	r3, r4
      y += 5;
 800f306:	f104 0405 	add.w	r4, r4, #5
    } while (shift & 1);
 800f30a:	d4f9      	bmi.n	800f300 <menu_config_cb+0x48>
    lcd_drawstring(x, y += str_height - 5, info_about[i++]);
 800f30c:	f103 040d 	add.w	r4, r3, #13
 800f310:	462a      	mov	r2, r5
 800f312:	b221      	sxth	r1, r4
 800f314:	2005      	movs	r0, #5
 800f316:	f000 ff83 	bl	8010220 <lcd_printf>
 800f31a:	e7ee      	b.n	800f2fa <menu_config_cb+0x42>
  uint32_t id0 = *(uint32_t *)0x1FFFF7AC; // MCU id0 address
 800f31c:	4b2a      	ldr	r3, [pc, #168]	@ (800f3c8 <menu_config_cb+0x110>)
  lcd_printf(x, y += str_height, "SN: %08x-%08x-%08x", id0, id1, id2);
 800f31e:	f8d3 27b4 	ldr.w	r2, [r3, #1972]	@ 0x7b4
 800f322:	9201      	str	r2, [sp, #4]
 800f324:	f8d3 27b0 	ldr.w	r2, [r3, #1968]	@ 0x7b0
 800f328:	9200      	str	r2, [sp, #0]
 800f32a:	f104 010d 	add.w	r1, r4, #13
 800f32e:	f8d3 37ac 	ldr.w	r3, [r3, #1964]	@ 0x7ac
 800f332:	4a26      	ldr	r2, [pc, #152]	@ (800f3cc <menu_config_cb+0x114>)
 800f334:	b209      	sxth	r1, r1
 800f336:	2005      	movs	r0, #5
 800f338:	f000 ff72 	bl	8010220 <lcd_printf>
  lcd_blitBitmapScale(LCD_WIDTH - 32 * 3, 240 - 5 - 32, 31, 31, 3, qr_code_map);
 800f33c:	4b24      	ldr	r3, [pc, #144]	@ (800f3d0 <menu_config_cb+0x118>)
 800f33e:	9301      	str	r3, [sp, #4]
 800f340:	2303      	movs	r3, #3
 800f342:	9300      	str	r3, [sp, #0]
 800f344:	231f      	movs	r3, #31
 800f346:	461a      	mov	r2, r3
 800f348:	21cb      	movs	r1, #203	@ 0xcb
 800f34a:	f44f 70c0 	mov.w	r0, #384	@ 0x180
 800f34e:	f000 ff8b 	bl	8010268 <lcd_blitBitmapScale>
    lcd_printf(x, y + str_height, "Batt: %d.%03d" S_VOLT, vbat / 1000, vbat % 1000);
 800f352:	3434      	adds	r4, #52	@ 0x34
 800f354:	b224      	sxth	r4, r4
    if (touch_check() == EVT_TOUCH_PRESSED)
 800f356:	f7fe f88f 	bl	800d478 <touch_check>
 800f35a:	2802      	cmp	r0, #2
 800f35c:	b2ae      	uxth	r6, r5
 800f35e:	d026      	beq.n	800f3ae <menu_config_cb+0xf6>
    if (btn_check() & EVT_BUTTON_SINGLE_CLICK)
 800f360:	f7fe f8d0 	bl	800d504 <btn_check>
 800f364:	07c2      	lsls	r2, r0, #31
 800f366:	d422      	bmi.n	800f3ae <menu_config_cb+0xf6>
    chThdSleepMilliseconds(40);
 800f368:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 800f36c:	f7f1 fd90 	bl	8000e90 <chThdSleep>
    if ((cnt++) & 0x07)
 800f370:	0773      	lsls	r3, r6, #29
 800f372:	d001      	beq.n	800f378 <menu_config_cb+0xc0>
 800f374:	3501      	adds	r5, #1
 800f376:	e7ee      	b.n	800f356 <menu_config_cb+0x9e>
    uint32_t vbat = adc_vbat_read();
 800f378:	f001 fba8 	bl	8010acc <adc_vbat_read>
    lcd_printf(x, y + str_height, "Batt: %d.%03d" S_VOLT, vbat / 1000, vbat % 1000);
 800f37c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800f380:	fbb0 f3f2 	udiv	r3, r0, r2
 800f384:	fb02 0013 	mls	r0, r2, r3, r0
 800f388:	9000      	str	r0, [sp, #0]
 800f38a:	4a12      	ldr	r2, [pc, #72]	@ (800f3d4 <menu_config_cb+0x11c>)
 800f38c:	4621      	mov	r1, r4
 800f38e:	2005      	movs	r0, #5
 800f390:	f000 ff46 	bl	8010220 <lcd_printf>
 800f394:	e7ee      	b.n	800f374 <menu_config_cb+0xbc>
    config_save();
 800f396:	f001 f9ff 	bl	8010798 <config_save>
    menu_move_back(true);
 800f39a:	2001      	movs	r0, #1
}
 800f39c:	b003      	add	sp, #12
 800f39e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    menu_move_back(true);
 800f3a2:	f7ff b951 	b.w	800e648 <menu_move_back>
    clear_all_config_prop_data();
 800f3a6:	f001 fab9 	bl	801091c <clear_all_config_prop_data>
    NVIC_SystemReset();
 800f3aa:	f7fd ff17 	bl	800d1dc <NVIC_SystemReset>
  ui_mode_normal();
 800f3ae:	f7fe fa01 	bl	800d7b4 <ui_mode_normal>
  request_to_redraw(REDRAW_ALL);
 800f3b2:	f240 301a 	movw	r0, #794	@ 0x31a
}
 800f3b6:	b003      	add	sp, #12
 800f3b8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  request_to_redraw(REDRAW_ALL);
 800f3bc:	f7fc ba18 	b.w	800b7f0 <request_to_redraw>
 800f3c0:	08012bd5 	.word	0x08012bd5
 800f3c4:	2000038c 	.word	0x2000038c
 800f3c8:	1ffff000 	.word	0x1ffff000
 800f3cc:	08012be8 	.word	0x08012be8
 800f3d0:	08014de4 	.word	0x08014de4
 800f3d4:	08012bfb 	.word	0x08012bfb

0800f3d8 <ui_enter_dfu>:
{
 800f3d8:	b508      	push	{r3, lr}
  touch_stop_watchdog();
 800f3da:	f7fd ffdd 	bl	800d398 <touch_stop_watchdog>
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800f3de:	2100      	movs	r1, #0
 800f3e0:	2001      	movs	r0, #1
 800f3e2:	f000 fe8d 	bl	8010100 <lcd_set_colors>
  lcd_clear_screen();
 800f3e6:	f000 fe25 	bl	8010034 <lcd_clear_screen>
  lcd_drawstring(x, y, "DFU: Device Firmware Update Mode\n"
 800f3ea:	4a04      	ldr	r2, [pc, #16]	@ (800f3fc <ui_enter_dfu+0x24>)
 800f3ec:	2114      	movs	r1, #20
 800f3ee:	2005      	movs	r0, #5
 800f3f0:	f000 ff16 	bl	8010220 <lcd_printf>
}
 800f3f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  boardDFUEnter();
 800f3f8:	f7f3 b80e 	b.w	8002418 <boardDFUEnter>
 800f3fc:	08012c0a 	.word	0x08012c0a

0800f400 <menu_dfu_cb>:
  ui_enter_dfu();
 800f400:	f7ff bfea 	b.w	800f3d8 <ui_enter_dfu>

0800f404 <apply_VNA_mode>:
{
 800f404:	b538      	push	{r3, r4, r5, lr}
  uint16_t old = config._vna_mode;
 800f406:	4d15      	ldr	r5, [pc, #84]	@ (800f45c <apply_VNA_mode+0x58>)
  uint16_t m = 1 << idx;
 800f408:	2301      	movs	r3, #1
  uint16_t old = config._vna_mode;
 800f40a:	8aaa      	ldrh	r2, [r5, #20]
{
 800f40c:	4604      	mov	r4, r0
  uint16_t m = 1 << idx;
 800f40e:	4083      	lsls	r3, r0
  if (operation == VNA_MODE_CLR)
 800f410:	b911      	cbnz	r1, 800f418 <apply_VNA_mode+0x14>
    config._vna_mode &= ~m; // clear
 800f412:	ea22 0303 	bic.w	r3, r2, r3
 800f416:	e004      	b.n	800f422 <apply_VNA_mode+0x1e>
  uint16_t m = 1 << idx;
 800f418:	b29b      	uxth	r3, r3
  else if (operation == VNA_MODE_SET)
 800f41a:	2901      	cmp	r1, #1
    config._vna_mode |= m; // set
 800f41c:	bf0c      	ite	eq
 800f41e:	4313      	orreq	r3, r2
    config._vna_mode ^= m; // toggle
 800f420:	4053      	eorne	r3, r2
  if (old == config._vna_mode)
 800f422:	429a      	cmp	r2, r3
    config._vna_mode &= ~m; // clear
 800f424:	82ab      	strh	r3, [r5, #20]
  if (old == config._vna_mode)
 800f426:	d017      	beq.n	800f458 <apply_VNA_mode+0x54>
  request_to_redraw(vna_mode_data[idx].update_flag);
 800f428:	4b0d      	ldr	r3, [pc, #52]	@ (800f460 <apply_VNA_mode+0x5c>)
 800f42a:	2206      	movs	r2, #6
 800f42c:	fb02 3304 	mla	r3, r2, r4, r3
 800f430:	8898      	ldrh	r0, [r3, #4]
 800f432:	f7fc f9dd 	bl	800b7f0 <request_to_redraw>
  switch (idx)
 800f436:	2c02      	cmp	r4, #2
 800f438:	d00a      	beq.n	800f450 <apply_VNA_mode+0x4c>
 800f43a:	2c05      	cmp	r4, #5
 800f43c:	d10c      	bne.n	800f458 <apply_VNA_mode+0x54>
    lcd_set_flip(VNA_MODE(VNA_MODE_FLIP_DISPLAY));
 800f43e:	7d28      	ldrb	r0, [r5, #20]
 800f440:	f3c0 1040 	ubfx	r0, r0, #5, #1
 800f444:	f000 fd22 	bl	800fe8c <lcd_set_flip>
}
 800f448:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    draw_all();
 800f44c:	f7fc b9f8 	b.w	800b840 <draw_all>
}
 800f450:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    marker_search();
 800f454:	f7fc b830 	b.w	800b4b8 <marker_search>
}
 800f458:	bd38      	pop	{r3, r4, r5, pc}
 800f45a:	bf00      	nop
 800f45c:	20000318 	.word	0x20000318
 800f460:	08014dac 	.word	0x08014dac

0800f464 <ui_show_no_resonance_hint>:
{
 800f464:	b508      	push	{r3, lr}
  if (no_resonance_visible)
 800f466:	4b11      	ldr	r3, [pc, #68]	@ (800f4ac <ui_show_no_resonance_hint+0x48>)
 800f468:	781a      	ldrb	r2, [r3, #0]
 800f46a:	b9ea      	cbnz	r2, 800f4a8 <ui_show_no_resonance_hint+0x44>
  no_resonance_visible = true;
 800f46c:	2201      	movs	r2, #1
  lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_MENU_COLOR);
 800f46e:	2103      	movs	r1, #3
 800f470:	2004      	movs	r0, #4
  no_resonance_visible = true;
 800f472:	701a      	strb	r2, [r3, #0]
  lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_MENU_COLOR);
 800f474:	f000 fe44 	bl	8010100 <lcd_set_colors>
  lcd_fill(x, y, w, h);
 800f478:	2332      	movs	r3, #50	@ 0x32
 800f47a:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800f47e:	2187      	movs	r1, #135	@ 0x87
 800f480:	2064      	movs	r0, #100	@ 0x64
 800f482:	f000 fd37 	bl	800fef4 <lcd_fill>
  lcd_printf(
 800f486:	4a0a      	ldr	r2, [pc, #40]	@ (800f4b0 <ui_show_no_resonance_hint+0x4c>)
 800f488:	218a      	movs	r1, #138	@ 0x8a
 800f48a:	20b1      	movs	r0, #177	@ 0xb1
 800f48c:	f000 fec8 	bl	8010220 <lcd_printf>
  lcd_printf(
 800f490:	4a08      	ldr	r2, [pc, #32]	@ (800f4b4 <ui_show_no_resonance_hint+0x50>)
 800f492:	219a      	movs	r1, #154	@ 0x9a
 800f494:	20af      	movs	r0, #175	@ 0xaf
 800f496:	f000 fec3 	bl	8010220 <lcd_printf>
}
 800f49a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  lcd_printf(
 800f49e:	4a06      	ldr	r2, [pc, #24]	@ (800f4b8 <ui_show_no_resonance_hint+0x54>)
 800f4a0:	21aa      	movs	r1, #170	@ 0xaa
 800f4a2:	20a9      	movs	r0, #169	@ 0xa9
 800f4a4:	f000 bebc 	b.w	8010220 <lcd_printf>
}
 800f4a8:	bd08      	pop	{r3, pc}
 800f4aa:	bf00      	nop
 800f4ac:	200089b3 	.word	0x200089b3
 800f4b0:	08012c5b 	.word	0x08012c5b
 800f4b4:	08012c6e 	.word	0x08012c6e
 800f4b8:	08012c80 	.word	0x08012c80

0800f4bc <ui_hide_check_amtenna_hint>:
{
 800f4bc:	b508      	push	{r3, lr}
  if (!checking_antenna_visible)
 800f4be:	4b0a      	ldr	r3, [pc, #40]	@ (800f4e8 <ui_hide_check_amtenna_hint+0x2c>)
 800f4c0:	781a      	ldrb	r2, [r3, #0]
 800f4c2:	b17a      	cbz	r2, 800f4e4 <ui_hide_check_amtenna_hint+0x28>
  checking_antenna_visible = false;
 800f4c4:	2000      	movs	r0, #0
 800f4c6:	7018      	strb	r0, [r3, #0]
  lcd_set_background(LCD_BG_COLOR);
 800f4c8:	f000 fe0e 	bl	80100e8 <lcd_set_background>
  lcd_fill(NO_RESONANCE_X, NO_RESONANCE_Y, NO_RESONANCE_W, NO_RESONANCE_H);
 800f4cc:	2332      	movs	r3, #50	@ 0x32
 800f4ce:	2064      	movs	r0, #100	@ 0x64
 800f4d0:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800f4d4:	2187      	movs	r1, #135	@ 0x87
 800f4d6:	f000 fd0d 	bl	800fef4 <lcd_fill>
}
 800f4da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_AREA | REDRAW_PLOT | REDRAW_MARKER);
 800f4de:	2023      	movs	r0, #35	@ 0x23
 800f4e0:	f7fc b986 	b.w	800b7f0 <request_to_redraw>
}
 800f4e4:	bd08      	pop	{r3, pc}
 800f4e6:	bf00      	nop
 800f4e8:	200089b2 	.word	0x200089b2

0800f4ec <ui_show_check_amtenna_hint>:
{
 800f4ec:	b508      	push	{r3, lr}
  if (!checking_antenna_visible)
 800f4ee:	4b10      	ldr	r3, [pc, #64]	@ (800f530 <ui_show_check_amtenna_hint+0x44>)
 800f4f0:	781a      	ldrb	r2, [r3, #0]
 800f4f2:	b90a      	cbnz	r2, 800f4f8 <ui_show_check_amtenna_hint+0xc>
    checking_antenna_visible = true;
 800f4f4:	2201      	movs	r2, #1
 800f4f6:	701a      	strb	r2, [r3, #0]
  lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_MENU_COLOR);
 800f4f8:	2103      	movs	r1, #3
 800f4fa:	2004      	movs	r0, #4
 800f4fc:	f000 fe00 	bl	8010100 <lcd_set_colors>
  lcd_fill(x, y, w, h);
 800f500:	2332      	movs	r3, #50	@ 0x32
 800f502:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800f506:	2187      	movs	r1, #135	@ 0x87
 800f508:	2064      	movs	r0, #100	@ 0x64
 800f50a:	f000 fcf3 	bl	800fef4 <lcd_fill>
  lcd_printf(
 800f50e:	4a09      	ldr	r2, [pc, #36]	@ (800f534 <ui_show_check_amtenna_hint+0x48>)
 800f510:	218a      	movs	r1, #138	@ 0x8a
 800f512:	207c      	movs	r0, #124	@ 0x7c
 800f514:	f000 fe84 	bl	8010220 <lcd_printf>
  lcd_printf(
 800f518:	4a07      	ldr	r2, [pc, #28]	@ (800f538 <ui_show_check_amtenna_hint+0x4c>)
 800f51a:	219a      	movs	r1, #154	@ 0x9a
 800f51c:	20b8      	movs	r0, #184	@ 0xb8
 800f51e:	f000 fe7f 	bl	8010220 <lcd_printf>
}
 800f522:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  lcd_printf(
 800f526:	4a05      	ldr	r2, [pc, #20]	@ (800f53c <ui_show_check_amtenna_hint+0x50>)
 800f528:	21aa      	movs	r1, #170	@ 0xaa
 800f52a:	20c0      	movs	r0, #192	@ 0xc0
 800f52c:	f000 be78 	b.w	8010220 <lcd_printf>
 800f530:	200089b2 	.word	0x200089b2
 800f534:	08012c95 	.word	0x08012c95
 800f538:	08012cb7 	.word	0x08012cb7
 800f53c:	08012cc7 	.word	0x08012cc7

0800f540 <ui_hide_no_resonance_hint>:
{
 800f540:	b508      	push	{r3, lr}
  if (!no_resonance_visible)
 800f542:	4b0a      	ldr	r3, [pc, #40]	@ (800f56c <ui_hide_no_resonance_hint+0x2c>)
 800f544:	781a      	ldrb	r2, [r3, #0]
 800f546:	b182      	cbz	r2, 800f56a <ui_hide_no_resonance_hint+0x2a>
  no_resonance_visible = false;
 800f548:	2000      	movs	r0, #0
 800f54a:	7018      	strb	r0, [r3, #0]
  lcd_set_background(LCD_BG_COLOR);
 800f54c:	f000 fdcc 	bl	80100e8 <lcd_set_background>
  lcd_fill(NO_RESONANCE_X, NO_RESONANCE_Y, NO_RESONANCE_W, NO_RESONANCE_H);
 800f550:	2332      	movs	r3, #50	@ 0x32
 800f552:	2064      	movs	r0, #100	@ 0x64
 800f554:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800f558:	2187      	movs	r1, #135	@ 0x87
 800f55a:	f000 fccb 	bl	800fef4 <lcd_fill>
}
 800f55e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_BACKUP | REDRAW_AREA);
 800f562:	f240 4002 	movw	r0, #1026	@ 0x402
 800f566:	f7fc b943 	b.w	800b7f0 <request_to_redraw>
}
 800f56a:	bd08      	pop	{r3, pc}
 800f56c:	200089b3 	.word	0x200089b3

0800f570 <keyboard_get_float>:
float keyboard_get_float(void) { return my_atof(kp_buf); }
 800f570:	4801      	ldr	r0, [pc, #4]	@ (800f578 <keyboard_get_float+0x8>)
 800f572:	f7f9 ba45 	b.w	8008a00 <my_atof>
 800f576:	bf00      	nop
 800f578:	200089c8 	.word	0x200089c8

0800f57c <input_var_delay>:
{
 800f57c:	b513      	push	{r0, r1, r4, lr}
 800f57e:	4c0e      	ldr	r4, [pc, #56]	@ (800f5b8 <input_var_delay+0x3c>)
  if (b)
 800f580:	b1a1      	cbz	r1, 800f5ac <input_var_delay+0x30>
    if (current_props._var_delay)
 800f582:	edd4 7a29 	vldr	s15, [r4, #164]	@ 0xa4
 800f586:	eef5 7a40 	vcmp.f32	s15, #0.0
 800f58a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f58e:	d011      	beq.n	800f5b4 <input_var_delay+0x38>
      plot_printf(b->label, sizeof(b->label), "JOG STEP\n " R_LINK_COLOR "%F" S_SECOND, current_props._var_delay);
 800f590:	ee17 0a90 	vmov	r0, s15
 800f594:	f101 0408 	add.w	r4, r1, #8
 800f598:	f7f1 f802 	bl	80005a0 <__aeabi_f2d>
 800f59c:	4a07      	ldr	r2, [pc, #28]	@ (800f5bc <input_var_delay+0x40>)
 800f59e:	e9cd 0100 	strd	r0, r1, [sp]
 800f5a2:	2120      	movs	r1, #32
 800f5a4:	4620      	mov	r0, r4
 800f5a6:	f7f3 fb8d 	bl	8002cc4 <plot_printf>
 800f5aa:	e003      	b.n	800f5b4 <input_var_delay+0x38>
  current_props._var_delay = keyboard_get_float();
 800f5ac:	f7ff ffe0 	bl	800f570 <keyboard_get_float>
 800f5b0:	ed84 0a29 	vstr	s0, [r4, #164]	@ 0xa4
}
 800f5b4:	b002      	add	sp, #8
 800f5b6:	bd10      	pop	{r4, pc}
 800f5b8:	20000aa8 	.word	0x20000aa8
 800f5bc:	08012cd5 	.word	0x08012cd5

0800f5c0 <input_amplitude>:
{
 800f5c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800f5c2:	ed2d 8b02 	vpush	{d8}
  int type = trace[current_trace].type;
 800f5c6:	4d38      	ldr	r5, [pc, #224]	@ (800f6a8 <input_amplitude+0xe8>)
 800f5c8:	f995 301c 	ldrsb.w	r3, [r5, #28]
 800f5cc:	220c      	movs	r2, #12
 800f5ce:	fb02 5303 	mla	r3, r2, r3, r5
  float ref = get_trace_refpos(current_trace);
 800f5d2:	ed93 7a0c 	vldr	s14, [r3, #48]	@ 0x30
  float scale = get_trace_scale(current_trace);
 800f5d6:	edd3 7a0b 	vldr	s15, [r3, #44]	@ 0x2c
  int type = trace[current_trace].type;
 800f5da:	f893 6029 	ldrb.w	r6, [r3, #41]	@ 0x29
  float top = (NGRIDY - ref) * scale;
 800f5de:	eef2 8a00 	vmov.f32	s17, #32	@ 0x41000000  8.0
 800f5e2:	ee78 8ac7 	vsub.f32	s17, s17, s14
 800f5e6:	ee27 8a67 	vnmul.f32	s16, s14, s15
 800f5ea:	ee68 8aa7 	vmul.f32	s17, s17, s15
{
 800f5ee:	b085      	sub	sp, #20
 800f5f0:	4604      	mov	r4, r0
  if (b)
 800f5f2:	b331      	cbz	r1, 800f642 <input_amplitude+0x82>
    float val = data == 0 ? top : bot;
 800f5f4:	2800      	cmp	r0, #0
 800f5f6:	bf08      	it	eq
 800f5f8:	eeb0 8a68 	vmoveq.f32	s16, s17
    plot_printf(b->label, sizeof(b->label), "%s\n " R_LINK_COLOR "%.4F%s", data == 0 ? "TOP" : "BOTTOM", val, trace_info_list[type].symbol);
 800f5fc:	4b2b      	ldr	r3, [pc, #172]	@ (800f6ac <input_amplitude+0xec>)
 800f5fe:	4f2c      	ldr	r7, [pc, #176]	@ (800f6b0 <input_amplitude+0xf0>)
    if (type == TRC_SWR)
 800f600:	2e06      	cmp	r6, #6
      val += 1.0f;
 800f602:	bf04      	itt	eq
 800f604:	eef7 7a00 	vmoveq.f32	s15, #112	@ 0x3f800000  1.0
 800f608:	ee38 8a27 	vaddeq.f32	s16, s16, s15
    plot_printf(b->label, sizeof(b->label), "%s\n " R_LINK_COLOR "%.4F%s", data == 0 ? "TOP" : "BOTTOM", val, trace_info_list[type].symbol);
 800f60c:	2800      	cmp	r0, #0
 800f60e:	bf08      	it	eq
 800f610:	461f      	moveq	r7, r3
 800f612:	4b28      	ldr	r3, [pc, #160]	@ (800f6b4 <input_amplitude+0xf4>)
 800f614:	221c      	movs	r2, #28
 800f616:	fb02 3306 	mla	r3, r2, r6, r3
 800f61a:	ee18 0a10 	vmov	r0, s16
 800f61e:	68db      	ldr	r3, [r3, #12]
 800f620:	9302      	str	r3, [sp, #8]
 800f622:	f101 0508 	add.w	r5, r1, #8
 800f626:	f7f0 ffbb 	bl	80005a0 <__aeabi_f2d>
 800f62a:	4a23      	ldr	r2, [pc, #140]	@ (800f6b8 <input_amplitude+0xf8>)
 800f62c:	e9cd 0100 	strd	r0, r1, [sp]
 800f630:	463b      	mov	r3, r7
 800f632:	2120      	movs	r1, #32
 800f634:	4628      	mov	r0, r5
 800f636:	f7f3 fb45 	bl	8002cc4 <plot_printf>
}
 800f63a:	b005      	add	sp, #20
 800f63c:	ecbd 8b02 	vpop	{d8}
 800f640:	bdf0      	pop	{r4, r5, r6, r7, pc}
  float value = keyboard_get_float();
 800f642:	f7ff ff95 	bl	800f570 <keyboard_get_float>
  if (type == TRC_SWR)
 800f646:	2e06      	cmp	r6, #6
    value -= 1.0f; // Hack for SWR trace!
 800f648:	bf08      	it	eq
 800f64a:	eeb7 7a00 	vmoveq.f32	s14, #112	@ 0x3f800000  1.0
  float value = keyboard_get_float();
 800f64e:	eef0 7a40 	vmov.f32	s15, s0
    value -= 1.0f; // Hack for SWR trace!
 800f652:	bf08      	it	eq
 800f654:	ee70 7a47 	vsubeq.f32	s15, s0, s14
    top = value; // top value input
 800f658:	2c00      	cmp	r4, #0
 800f65a:	bf08      	it	eq
 800f65c:	eef0 8a67 	vmoveq.f32	s17, s15
 800f660:	bf18      	it	ne
 800f662:	eeb0 8a67 	vmovne.f32	s16, s15
  scale = (top - bot) / NGRIDY;
 800f666:	ee38 0ac8 	vsub.f32	s0, s17, s16
  ref = (top == bot) ? -value : -bot / scale;
 800f66a:	eeb4 8a68 	vcmp.f32	s16, s17
  scale = (top - bot) / NGRIDY;
 800f66e:	eeb4 7a00 	vmov.f32	s14, #64	@ 0x3e000000  0.125
  ref = (top == bot) ? -value : -bot / scale;
 800f672:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  scale = (top - bot) / NGRIDY;
 800f676:	ee20 0a07 	vmul.f32	s0, s0, s14
  ref = (top == bot) ? -value : -bot / scale;
 800f67a:	bf1c      	itt	ne
 800f67c:	eeb1 8a48 	vnegne.f32	s16, s16
 800f680:	eec8 8a00 	vdivne.f32	s17, s16, s0
  set_trace_scale(current_trace, scale);
 800f684:	f995 001c 	ldrsb.w	r0, [r5, #28]
  ref = (top == bot) ? -value : -bot / scale;
 800f688:	bf08      	it	eq
 800f68a:	eef1 8a67 	vnegeq.f32	s17, s15
  set_trace_scale(current_trace, scale);
 800f68e:	f7f8 f853 	bl	8007738 <set_trace_scale>
  set_trace_refpos(current_trace, ref);
 800f692:	f995 001c 	ldrsb.w	r0, [r5, #28]
 800f696:	eeb0 0a68 	vmov.f32	s0, s17
}
 800f69a:	b005      	add	sp, #20
 800f69c:	ecbd 8b02 	vpop	{d8}
 800f6a0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  set_trace_refpos(current_trace, ref);
 800f6a4:	f7f8 b85c 	b.w	8007760 <set_trace_refpos>
 800f6a8:	20000aa8 	.word	0x20000aa8
 800f6ac:	08012ce5 	.word	0x08012ce5
 800f6b0:	08012ce9 	.word	0x08012ce9
 800f6b4:	08014540 	.word	0x08014540
 800f6b8:	08012cf0 	.word	0x08012cf0

0800f6bc <input_scale>:
  if (b)
 800f6bc:	b951      	cbnz	r1, 800f6d4 <input_scale+0x18>
{
 800f6be:	b510      	push	{r4, lr}
  set_trace_scale(current_trace, keyboard_get_float());
 800f6c0:	4b05      	ldr	r3, [pc, #20]	@ (800f6d8 <input_scale+0x1c>)
 800f6c2:	f993 401c 	ldrsb.w	r4, [r3, #28]
 800f6c6:	f7ff ff53 	bl	800f570 <keyboard_get_float>
 800f6ca:	4620      	mov	r0, r4
}
 800f6cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_trace_scale(current_trace, keyboard_get_float());
 800f6d0:	f7f8 b832 	b.w	8007738 <set_trace_scale>
 800f6d4:	4770      	bx	lr
 800f6d6:	bf00      	nop
 800f6d8:	20000aa8 	.word	0x20000aa8

0800f6dc <input_ref>:
  if (b)
 800f6dc:	b951      	cbnz	r1, 800f6f4 <input_ref+0x18>
{
 800f6de:	b510      	push	{r4, lr}
  set_trace_refpos(current_trace, keyboard_get_float());
 800f6e0:	4b05      	ldr	r3, [pc, #20]	@ (800f6f8 <input_ref+0x1c>)
 800f6e2:	f993 401c 	ldrsb.w	r4, [r3, #28]
 800f6e6:	f7ff ff43 	bl	800f570 <keyboard_get_float>
 800f6ea:	4620      	mov	r0, r4
}
 800f6ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_trace_refpos(current_trace, keyboard_get_float());
 800f6f0:	f7f8 b836 	b.w	8007760 <set_trace_refpos>
 800f6f4:	4770      	bx	lr
 800f6f6:	bf00      	nop
 800f6f8:	20000aa8 	.word	0x20000aa8

0800f6fc <input_edelay>:
  if (current_trace == TRACE_INVALID)
 800f6fc:	4a14      	ldr	r2, [pc, #80]	@ (800f750 <input_edelay+0x54>)
 800f6fe:	f992 301c 	ldrsb.w	r3, [r2, #28]
 800f702:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f706:	d021      	beq.n	800f74c <input_edelay+0x50>
{
 800f708:	b573      	push	{r0, r1, r4, r5, r6, lr}
  int ch = trace[current_trace].channel;
 800f70a:	200c      	movs	r0, #12
 800f70c:	fb00 2303 	mla	r3, r0, r3, r2
 800f710:	f893 502a 	ldrb.w	r5, [r3, #42]	@ 0x2a
  if (b)
 800f714:	b191      	cbz	r1, 800f73c <input_edelay+0x40>
    plot_printf(b->label, sizeof(b->label), "E-DELAY S%d1\n " R_LINK_COLOR "%.7F" S_SECOND, ch + 1, current_props._electrical_delay[ch]);
 800f716:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 800f71a:	f101 0408 	add.w	r4, r1, #8
 800f71e:	f8d2 009c 	ldr.w	r0, [r2, #156]	@ 0x9c
 800f722:	f7f0 ff3d 	bl	80005a0 <__aeabi_f2d>
 800f726:	1c6e      	adds	r6, r5, #1
 800f728:	e9cd 0100 	strd	r0, r1, [sp]
 800f72c:	4a09      	ldr	r2, [pc, #36]	@ (800f754 <input_edelay+0x58>)
 800f72e:	4633      	mov	r3, r6
 800f730:	2120      	movs	r1, #32
 800f732:	4620      	mov	r0, r4
 800f734:	f7f3 fac6 	bl	8002cc4 <plot_printf>
}
 800f738:	b002      	add	sp, #8
 800f73a:	bd70      	pop	{r4, r5, r6, pc}
  set_electrical_delay(ch, keyboard_get_float());
 800f73c:	f7ff ff18 	bl	800f570 <keyboard_get_float>
 800f740:	4628      	mov	r0, r5
}
 800f742:	b002      	add	sp, #8
 800f744:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  set_electrical_delay(ch, keyboard_get_float());
 800f748:	f7f8 bf72 	b.w	8008630 <set_electrical_delay>
 800f74c:	4770      	bx	lr
 800f74e:	bf00      	nop
 800f750:	20000aa8 	.word	0x20000aa8
 800f754:	08012cfd 	.word	0x08012cfd

0800f758 <input_s21_offset>:
{
 800f758:	b508      	push	{r3, lr}
  if (b)
 800f75a:	b121      	cbz	r1, 800f766 <input_s21_offset+0xe>
    b->p1.f = s21_offset;
 800f75c:	4b05      	ldr	r3, [pc, #20]	@ (800f774 <input_s21_offset+0x1c>)
 800f75e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800f762:	604b      	str	r3, [r1, #4]
}
 800f764:	bd08      	pop	{r3, pc}
  set_s21_offset(keyboard_get_float());
 800f766:	f7ff ff03 	bl	800f570 <keyboard_get_float>
}
 800f76a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_s21_offset(keyboard_get_float());
 800f76e:	f7f8 bfaf 	b.w	80086d0 <set_s21_offset>
 800f772:	bf00      	nop
 800f774:	20000aa8 	.word	0x20000aa8

0800f778 <input_cable_len>:
{
 800f778:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800f77a:	4c10      	ldr	r4, [pc, #64]	@ (800f7bc <input_cable_len+0x44>)
  if (b)
 800f77c:	b1b9      	cbz	r1, 800f7ae <input_cable_len+0x36>
    if (real_cable_len == 0.0f)
 800f77e:	edd4 7a00 	vldr	s15, [r4]
 800f782:	eef5 7a40 	vcmp.f32	s15, #0.0
 800f786:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f78a:	d014      	beq.n	800f7b6 <input_cable_len+0x3e>
    plot_printf(b->label, sizeof(b->label), "%s\n " R_LINK_COLOR "%.4F%s", "CABLE LENGTH", real_cable_len, S_METRE);
 800f78c:	4b0c      	ldr	r3, [pc, #48]	@ (800f7c0 <input_cable_len+0x48>)
 800f78e:	9302      	str	r3, [sp, #8]
 800f790:	ee17 0a90 	vmov	r0, s15
 800f794:	f101 0408 	add.w	r4, r1, #8
 800f798:	f7f0 ff02 	bl	80005a0 <__aeabi_f2d>
 800f79c:	4b09      	ldr	r3, [pc, #36]	@ (800f7c4 <input_cable_len+0x4c>)
 800f79e:	4a0a      	ldr	r2, [pc, #40]	@ (800f7c8 <input_cable_len+0x50>)
 800f7a0:	e9cd 0100 	strd	r0, r1, [sp]
 800f7a4:	2120      	movs	r1, #32
 800f7a6:	4620      	mov	r0, r4
 800f7a8:	f7f3 fa8c 	bl	8002cc4 <plot_printf>
    return;
 800f7ac:	e003      	b.n	800f7b6 <input_cable_len+0x3e>
  real_cable_len = keyboard_get_float();
 800f7ae:	f7ff fedf 	bl	800f570 <keyboard_get_float>
 800f7b2:	ed84 0a00 	vstr	s0, [r4]
}
 800f7b6:	b004      	add	sp, #16
 800f7b8:	bd10      	pop	{r4, pc}
 800f7ba:	bf00      	nop
 800f7bc:	200069b0 	.word	0x200069b0
 800f7c0:	08012d20 	.word	0x08012d20
 800f7c4:	08012d13 	.word	0x08012d13
 800f7c8:	08012cf0 	.word	0x08012cf0

0800f7cc <input_measure_r>:
{
 800f7cc:	b510      	push	{r4, lr}
 800f7ce:	4c05      	ldr	r4, [pc, #20]	@ (800f7e4 <input_measure_r+0x18>)
  if (b)
 800f7d0:	b111      	cbz	r1, 800f7d8 <input_measure_r+0xc>
    b->p1.f = config._measure_r;
 800f7d2:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
 800f7d4:	604b      	str	r3, [r1, #4]
    return;
 800f7d6:	e003      	b.n	800f7e0 <input_measure_r+0x14>
  config._measure_r = keyboard_get_float();
 800f7d8:	f7ff feca 	bl	800f570 <keyboard_get_float>
 800f7dc:	ed84 0a1a 	vstr	s0, [r4, #104]	@ 0x68
}
 800f7e0:	bd10      	pop	{r4, pc}
 800f7e2:	bf00      	nop
 800f7e4:	20000318 	.word	0x20000318

0800f7e8 <input_rtc_cal>:
{
 800f7e8:	b510      	push	{r4, lr}
  if (b)
 800f7ea:	b129      	cbz	r1, 800f7f8 <input_rtc_cal+0x10>
 800f7ec:	460c      	mov	r4, r1
    b->p1.f = rtc_get_cal();
 800f7ee:	f001 fb13 	bl	8010e18 <rtc_get_cal>
 800f7f2:	ed84 0a01 	vstr	s0, [r4, #4]
}
 800f7f6:	bd10      	pop	{r4, pc}
  rtc_set_cal(keyboard_get_float());
 800f7f8:	f7ff feba 	bl	800f570 <keyboard_get_float>
}
 800f7fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  rtc_set_cal(keyboard_get_float());
 800f800:	f001 baea 	b.w	8010dd8 <rtc_set_cal>

0800f804 <keyboard_get_freq>:
freq_t keyboard_get_freq(void) { return my_atoui(kp_buf); }
 800f804:	4801      	ldr	r0, [pc, #4]	@ (800f80c <keyboard_get_freq+0x8>)
 800f806:	f7f9 b8d5 	b.w	80089b4 <my_atoui>
 800f80a:	bf00      	nop
 800f80c:	200089c8 	.word	0x200089c8

0800f810 <input_freq>:
{
 800f810:	b510      	push	{r4, lr}
 800f812:	4604      	mov	r4, r0
  if (b)
 800f814:	b309      	cbz	r1, 800f85a <input_freq+0x4a>
    if (data == ST_VAR && var_freq)
 800f816:	2c06      	cmp	r4, #6
 800f818:	4608      	mov	r0, r1
 800f81a:	d109      	bne.n	800f830 <input_freq+0x20>
 800f81c:	4b13      	ldr	r3, [pc, #76]	@ (800f86c <input_freq+0x5c>)
 800f81e:	695b      	ldr	r3, [r3, #20]
 800f820:	b31b      	cbz	r3, 800f86a <input_freq+0x5a>
}
 800f822:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      plot_printf(b->label, sizeof(b->label), "JOG STEP\n " R_LINK_COLOR "%.3q" S_Hz, var_freq);
 800f826:	4a12      	ldr	r2, [pc, #72]	@ (800f870 <input_freq+0x60>)
 800f828:	2120      	movs	r1, #32
 800f82a:	3008      	adds	r0, #8
 800f82c:	f7f3 ba4a 	b.w	8002cc4 <plot_printf>
    if (data == ST_STEP)
 800f830:	2c05      	cmp	r4, #5
 800f832:	d11a      	bne.n	800f86a <input_freq+0x5a>
    case ST_SPAN:   return frequency1 - frequency0;
 800f834:	4a0d      	ldr	r2, [pc, #52]	@ (800f86c <input_freq+0x5c>)
 800f836:	e9d2 1301 	ldrd	r1, r3, [r2, #4]
 800f83a:	1a5b      	subs	r3, r3, r1
      b->p1.f = (float)get_sweep_frequency(ST_SPAN) / (sweep_points - 1);
 800f83c:	ee07 3a90 	vmov	s15, r3
 800f840:	8b53      	ldrh	r3, [r2, #26]
 800f842:	3b01      	subs	r3, #1
 800f844:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800f848:	ee07 3a90 	vmov	s15, r3
 800f84c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800f850:	eec7 6a27 	vdiv.f32	s13, s14, s15
 800f854:	edc0 6a01 	vstr	s13, [r0, #4]
 800f858:	e007      	b.n	800f86a <input_freq+0x5a>
  set_sweep_frequency(data, keyboard_get_freq());
 800f85a:	f7ff ffd3 	bl	800f804 <keyboard_get_freq>
 800f85e:	4601      	mov	r1, r0
 800f860:	4620      	mov	r0, r4
}
 800f862:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_sweep_frequency(data, keyboard_get_freq());
 800f866:	f7f7 bcd9 	b.w	800721c <set_sweep_frequency>
}
 800f86a:	bd10      	pop	{r4, pc}
 800f86c:	20000aa8 	.word	0x20000aa8
 800f870:	08012d22 	.word	0x08012d22

0800f874 <input_vbat>:
{
 800f874:	b510      	push	{r4, lr}
 800f876:	4c04      	ldr	r4, [pc, #16]	@ (800f888 <input_vbat+0x14>)
  if (b)
 800f878:	b111      	cbz	r1, 800f880 <input_vbat+0xc>
    b->p1.u = config._vbat_offset;
 800f87a:	8b23      	ldrh	r3, [r4, #24]
 800f87c:	604b      	str	r3, [r1, #4]
    return;
 800f87e:	e002      	b.n	800f886 <input_vbat+0x12>
  config._vbat_offset = keyboard_get_uint();
 800f880:	f7ff ffc0 	bl	800f804 <keyboard_get_freq>
 800f884:	8320      	strh	r0, [r4, #24]
}
 800f886:	bd10      	pop	{r4, pc}
 800f888:	20000318 	.word	0x20000318

0800f88c <input_harmonic>:
{
 800f88c:	b510      	push	{r4, lr}
 800f88e:	4c04      	ldr	r4, [pc, #16]	@ (800f8a0 <input_harmonic+0x14>)
  if (b)
 800f890:	b111      	cbz	r1, 800f898 <input_harmonic+0xc>
    b->p1.u = config._harmonic_freq_threshold;
 800f892:	6863      	ldr	r3, [r4, #4]
 800f894:	604b      	str	r3, [r1, #4]
    return;
 800f896:	e002      	b.n	800f89e <input_harmonic+0x12>
  config._harmonic_freq_threshold = keyboard_get_uint();
 800f898:	f7ff ffb4 	bl	800f804 <keyboard_get_freq>
 800f89c:	6060      	str	r0, [r4, #4]
}
 800f89e:	bd10      	pop	{r4, pc}
 800f8a0:	20000318 	.word	0x20000318

0800f8a4 <input_xtal>:
{
 800f8a4:	b508      	push	{r3, lr}
  if (b)
 800f8a6:	b119      	cbz	r1, 800f8b0 <input_xtal+0xc>
    b->p1.u = config._xtal_freq;
 800f8a8:	4b04      	ldr	r3, [pc, #16]	@ (800f8bc <input_xtal+0x18>)
 800f8aa:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800f8ac:	604b      	str	r3, [r1, #4]
}
 800f8ae:	bd08      	pop	{r3, pc}
  si5351_set_tcxo(keyboard_get_uint());
 800f8b0:	f7ff ffa8 	bl	800f804 <keyboard_get_freq>
}
 800f8b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  si5351_set_tcxo(keyboard_get_uint());
 800f8b8:	f7f9 bb24 	b.w	8008f04 <si5351_set_tcxo>
 800f8bc:	20000318 	.word	0x20000318

0800f8c0 <input_velocity>:
{
 800f8c0:	b510      	push	{r4, lr}
 800f8c2:	4c05      	ldr	r4, [pc, #20]	@ (800f8d8 <input_velocity+0x18>)
  if (b)
 800f8c4:	b119      	cbz	r1, 800f8ce <input_velocity+0xe>
    b->p1.u = velocity_factor;
 800f8c6:	f894 3099 	ldrb.w	r3, [r4, #153]	@ 0x99
 800f8ca:	604b      	str	r3, [r1, #4]
    return;
 800f8cc:	e003      	b.n	800f8d6 <input_velocity+0x16>
  velocity_factor = keyboard_get_uint();
 800f8ce:	f7ff ff99 	bl	800f804 <keyboard_get_freq>
 800f8d2:	f884 0099 	strb.w	r0, [r4, #153]	@ 0x99
}
 800f8d6:	bd10      	pop	{r4, pc}
 800f8d8:	20000aa8 	.word	0x20000aa8

0800f8dc <input_points>:
{
 800f8dc:	b508      	push	{r3, lr}
  if (b)
 800f8de:	b119      	cbz	r1, 800f8e8 <input_points+0xc>
    b->p1.u = sweep_points;
 800f8e0:	4b05      	ldr	r3, [pc, #20]	@ (800f8f8 <input_points+0x1c>)
 800f8e2:	8b5b      	ldrh	r3, [r3, #26]
 800f8e4:	604b      	str	r3, [r1, #4]
}
 800f8e6:	bd08      	pop	{r3, pc}
  set_sweep_points(keyboard_get_uint());
 800f8e8:	f7ff ff8c 	bl	800f804 <keyboard_get_freq>
}
 800f8ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_sweep_points(keyboard_get_uint());
 800f8f0:	b280      	uxth	r0, r0
 800f8f2:	f7f7 bc05 	b.w	8007100 <set_sweep_points>
 800f8f6:	bf00      	nop
 800f8f8:	20000aa8 	.word	0x20000aa8

0800f8fc <ui_process>:
    ui_handler[ui_mode].touch(touch_x, touch_y);
  }
}

void ui_process(void)
{
 800f8fc:	b513      	push	{r0, r1, r4, lr}
  // if (ui_mode >= UI_END) return; // for safe

  if (operation_requested & OP_LEVER)
 800f8fe:	4c14      	ldr	r4, [pc, #80]	@ (800f950 <ui_process+0x54>)
 800f900:	7823      	ldrb	r3, [r4, #0]
 800f902:	07da      	lsls	r2, r3, #31
 800f904:	d508      	bpl.n	800f918 <ui_process+0x1c>
  uint16_t status = btn_check();
 800f906:	f7fd fdfd 	bl	800d504 <btn_check>
  if (status)
 800f90a:	b128      	cbz	r0, 800f918 <ui_process+0x1c>
    ui_handler[ui_mode].button(status);
 800f90c:	4b11      	ldr	r3, [pc, #68]	@ (800f954 <ui_process+0x58>)
 800f90e:	781a      	ldrb	r2, [r3, #0]
 800f910:	4b11      	ldr	r3, [pc, #68]	@ (800f958 <ui_process+0x5c>)
 800f912:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 800f916:	4798      	blx	r3
    ui_process_lever();
  if (operation_requested & OP_TOUCH)
 800f918:	7823      	ldrb	r3, [r4, #0]
 800f91a:	079b      	lsls	r3, r3, #30
 800f91c:	d511      	bpl.n	800f942 <ui_process+0x46>
  int status = touch_check();
 800f91e:	f7fd fdab 	bl	800d478 <touch_check>
  if (status == EVT_TOUCH_PRESSED || status == EVT_TOUCH_DOWN)
 800f922:	3801      	subs	r0, #1
 800f924:	2801      	cmp	r0, #1
 800f926:	d80c      	bhi.n	800f942 <ui_process+0x46>
    touch_position(&touch_x, &touch_y);
 800f928:	a901      	add	r1, sp, #4
 800f92a:	4668      	mov	r0, sp
 800f92c:	f7fd fc7c 	bl	800d228 <touch_position>
    ui_handler[ui_mode].touch(touch_x, touch_y);
 800f930:	4b08      	ldr	r3, [pc, #32]	@ (800f954 <ui_process+0x58>)
 800f932:	781a      	ldrb	r2, [r3, #0]
 800f934:	4b08      	ldr	r3, [pc, #32]	@ (800f958 <ui_process+0x5c>)
 800f936:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f93a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800f93e:	685b      	ldr	r3, [r3, #4]
 800f940:	4798      	blx	r3
    ui_process_touch();

  touch_start_watchdog();
 800f942:	f7fe fb97 	bl	800e074 <touch_start_watchdog>
  operation_requested = OP_NONE;
 800f946:	2300      	movs	r3, #0
 800f948:	7023      	strb	r3, [r4, #0]
}
 800f94a:	b002      	add	sp, #8
 800f94c:	bd10      	pop	{r4, pc}
 800f94e:	bf00      	nop
 800f950:	200089db 	.word	0x200089db
 800f954:	200089c4 	.word	0x200089c4
 800f958:	08014888 	.word	0x08014888

0800f95c <handle_button_interrupt>:

void handle_button_interrupt(uint16_t channel)
{
  (void)channel;
  operation_requested |= OP_LEVER;
 800f95c:	4a02      	ldr	r2, [pc, #8]	@ (800f968 <handle_button_interrupt+0xc>)
 800f95e:	7813      	ldrb	r3, [r2, #0]
 800f960:	f043 0301 	orr.w	r3, r3, #1
 800f964:	7013      	strb	r3, [r2, #0]
  // cur_button = READ_PORT() & BUTTON_MASK;
}
 800f966:	4770      	bx	lr
 800f968:	200089db 	.word	0x200089db

0800f96c <handle_touch_interrupt>:
// static systime_t t_time = 0;
//  Triggered touch interrupt call
void handle_touch_interrupt(void)
{

  if (targetting_mode)
 800f96c:	4b04      	ldr	r3, [pc, #16]	@ (800f980 <handle_touch_interrupt+0x14>)
 800f96e:	781b      	ldrb	r3, [r3, #0]
 800f970:	b923      	cbnz	r3, 800f97c <handle_touch_interrupt+0x10>
    return;

  operation_requested |= OP_TOUCH;
 800f972:	4a04      	ldr	r2, [pc, #16]	@ (800f984 <handle_touch_interrupt+0x18>)
 800f974:	7813      	ldrb	r3, [r2, #0]
 800f976:	f043 0302 	orr.w	r3, r3, #2
 800f97a:	7013      	strb	r3, [r2, #0]
  //  systime_t n_time = chVTGetSystemTimeX();
  //  shell_printf("%d\r\n", n_time - t_time);
  //  t_time = n_time;
}
 800f97c:	4770      	bx	lr
 800f97e:	bf00      	nop
 800f980:	200003d6 	.word	0x200003d6
 800f984:	200089db 	.word	0x200089db

0800f988 <remote_touch_set>:
  touch_remote = state;
 800f988:	4b05      	ldr	r3, [pc, #20]	@ (800f9a0 <remote_touch_set+0x18>)
 800f98a:	7018      	strb	r0, [r3, #0]
  if (x != -1)
 800f98c:	1c48      	adds	r0, r1, #1
    last_touch_x = x;
 800f98e:	bf1c      	itt	ne
 800f990:	4b04      	ldrne	r3, [pc, #16]	@ (800f9a4 <remote_touch_set+0x1c>)
 800f992:	8019      	strhne	r1, [r3, #0]
  if (y != -1)
 800f994:	1c53      	adds	r3, r2, #1
    last_touch_y = y;
 800f996:	bf1c      	itt	ne
 800f998:	4b03      	ldrne	r3, [pc, #12]	@ (800f9a8 <remote_touch_set+0x20>)
 800f99a:	801a      	strhne	r2, [r3, #0]
  handle_touch_interrupt();
 800f99c:	f7ff bfe6 	b.w	800f96c <handle_touch_interrupt>
 800f9a0:	200089bc 	.word	0x200089bc
 800f9a4:	200089de 	.word	0x200089de
 800f9a8:	200089dc 	.word	0x200089dc

0800f9ac <ui_init>:
  ext_channel_enable(3, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
}
#endif

void ui_init()
{
 800f9ac:	b508      	push	{r3, lr}
  adc_init();
 800f9ae:	f001 f82f 	bl	8010a10 <adc_init>
  extStart();
 800f9b2:	f001 fbb3 	bl	801111c <extStart>
  ext_channel_enable(1, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
 800f9b6:	2101      	movs	r1, #1
 800f9b8:	4608      	mov	r0, r1
 800f9ba:	f001 fbbf 	bl	801113c <ext_channel_enable>
  ext_channel_enable(2, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
 800f9be:	2101      	movs	r1, #1
 800f9c0:	2002      	movs	r0, #2
 800f9c2:	f001 fbbb 	bl	801113c <ext_channel_enable>
  ext_channel_enable(3, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
 800f9c6:	2101      	movs	r1, #1
 800f9c8:	2003      	movs	r0, #3
 800f9ca:	f001 fbb7 	bl	801113c <ext_channel_enable>
  touch_prepare_sense();
 800f9ce:	f7fd fcef 	bl	800d3b0 <touch_prepare_sense>
  initTimers();
 800f9d2:	f001 fbef 	bl	80111b4 <initTimers>
  startTimer(TIM3, 10); // Start timer 10ms period (use 1kHz clock)
 800f9d6:	4808      	ldr	r0, [pc, #32]	@ (800f9f8 <ui_init+0x4c>)
 800f9d8:	210a      	movs	r1, #10
 800f9da:	f001 fbff 	bl	80111dc <startTimer>
  touch_start_watchdog(); // Start ADC watchdog (measure by timer 3 interval and trigger interrupt if touch pressed)
 800f9de:	f7fe fb49 	bl	800e074 <touch_start_watchdog>
  init_EXT();
  // Init touch subsystem
  touch_init();
  // Set LCD display brightness
#ifdef __LCD_BRIGHTNESS__
  lcd_setBrightness(config._brightness);
 800f9e2:	4b06      	ldr	r3, [pc, #24]	@ (800f9fc <ui_init+0x50>)
 800f9e4:	7f58      	ldrb	r0, [r3, #29]
  dac_setvalue_ch2(700 + b * (4000 - 700) / 100);
 800f9e6:	eb00 1040 	add.w	r0, r0, r0, lsl #5
#endif
}
 800f9ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  dac_setvalue_ch2(700 + b * (4000 - 700) / 100);
 800f9ee:	f500 702f 	add.w	r0, r0, #700	@ 0x2bc
 800f9f2:	f001 ba39 	b.w	8010e68 <dac_setvalue_ch2>
 800f9f6:	bf00      	nop
 800f9f8:	40000400 	.word	0x40000400
 800f9fc:	20000318 	.word	0x20000318

0800fa00 <ui_close_all>:

// Close any UI overlay (menu/keypad/browser), and reset menu stack to top.
void ui_close_all(void)
{
 800fa00:	b508      	push	{r3, lr}
  // Reset menu navigation stack
  menu_current_level = 0;
 800fa02:	4b0e      	ldr	r3, [pc, #56]	@ (800fa3c <ui_close_all+0x3c>)
  menu_stack[0] = menu_top;
 800fa04:	4a0e      	ldr	r2, [pc, #56]	@ (800fa40 <ui_close_all+0x40>)
  menu_current_level = 0;
 800fa06:	2100      	movs	r1, #0
 800fa08:	7019      	strb	r1, [r3, #0]
  menu_stack[0] = menu_top;
 800fa0a:	4b0e      	ldr	r3, [pc, #56]	@ (800fa44 <ui_close_all+0x44>)
  for (int i = 1; i < MENU_STACK_DEPTH_MAX; i++)
    menu_stack[i] = NULL;
 800fa0c:	e9c3 2100 	strd	r2, r1, [r3]
 800fa10:	e9c3 1102 	strd	r1, r1, [r3, #8]
 800fa14:	6119      	str	r1, [r3, #16]

  selection = -1;
 800fa16:	4b0c      	ldr	r3, [pc, #48]	@ (800fa48 <ui_close_all+0x48>)
 800fa18:	22ff      	movs	r2, #255	@ 0xff
 800fa1a:	701a      	strb	r2, [r3, #0]
  ensure_selection(); // recompute menu_button_height safely
 800fa1c:	f7fe fdaa 	bl	800e574 <ensure_selection>

  // Leave any UI overlay state
  ui_mode = UI_NORMAL; // force "normal"
 800fa20:	4b0a      	ldr	r3, [pc, #40]	@ (800fa4c <ui_close_all+0x4c>)
  set_area_size(AREA_WIDTH_NORMAL, AREA_HEIGHT_NORMAL);
 800fa22:	f240 10d1 	movw	r0, #465	@ 0x1d1
  ui_mode = UI_NORMAL; // force "normal"
 800fa26:	7019      	strb	r1, [r3, #0]
  set_area_size(AREA_WIDTH_NORMAL, AREA_HEIGHT_NORMAL);
 800fa28:	f240 1131 	movw	r1, #305	@ 0x131
 800fa2c:	f7fb fed6 	bl	800b7dc <set_area_size>
  // kp_buf[0] = 0;
  // keypads = NULL;
  // keypad_mode = KM_NONE;

  request_to_redraw(REDRAW_ALL);
}
 800fa30:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_ALL);
 800fa34:	f240 301a 	movw	r0, #794	@ 0x31a
 800fa38:	f7fb beda 	b.w	800b7f0 <request_to_redraw>
 800fa3c:	200089bd 	.word	0x200089bd
 800fa40:	08014b74 	.word	0x08014b74
 800fa44:	200003dc 	.word	0x200003dc
 800fa48:	200003f0 	.word	0x200003f0
 800fa4c:	200089c4 	.word	0x200089c4

0800fa50 <dmaChannelWaitCompletionRxTx>:
    dmaChannelWaitCompletion(LCD_DMA_TX);
}

// Wait DMA Rx completion
static void dmaChannelWaitCompletionRxTx(void) {
  dmaChannelWaitCompletion(LCD_DMA_TX);
 800fa50:	4905      	ldr	r1, [pc, #20]	@ (800fa68 <dmaChannelWaitCompletionRxTx+0x18>)
 800fa52:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 800fa54:	2b00      	cmp	r3, #0
 800fa56:	d1fc      	bne.n	800fa52 <dmaChannelWaitCompletionRxTx+0x2>
  dmaChannelWaitCompletion(LCD_DMA_RX);
 800fa58:	4a03      	ldr	r2, [pc, #12]	@ (800fa68 <dmaChannelWaitCompletionRxTx+0x18>)
  dmaChannelWaitCompletion(LCD_DMA_TX);
 800fa5a:	630b      	str	r3, [r1, #48]	@ 0x30
  dmaChannelWaitCompletion(LCD_DMA_RX);
 800fa5c:	6a13      	ldr	r3, [r2, #32]
 800fa5e:	2b00      	cmp	r3, #0
 800fa60:	d1fc      	bne.n	800fa5c <dmaChannelWaitCompletionRxTx+0xc>
 800fa62:	61d3      	str	r3, [r2, #28]
//  while (SPI_IS_BUSY(LCD_SPI));   // Wait SPI tx/rx
}
 800fa64:	4770      	bx	lr
 800fa66:	bf00      	nop
 800fa68:	40020000 	.word	0x40020000

0800fa6c <SD_Select_SPI>:
//               SD card SPI functions
//*******************************************************
#define SD_CS_LOW     palClearPad(GPIOB, GPIOB_SD_CS)
#define SD_CS_HIGH    palSetPad(GPIOB, GPIOB_SD_CS)

static void SD_Select_SPI(uint32_t speed) {
 800fa6c:	b410      	push	{r4}
  while (SPI_IS_BUSY(LCD_SPI));
 800fa6e:	4a09      	ldr	r2, [pc, #36]	@ (800fa94 <SD_Select_SPI+0x28>)
 800fa70:	6893      	ldr	r3, [r2, #8]
 800fa72:	061b      	lsls	r3, r3, #24
 800fa74:	d4fc      	bmi.n	800fa70 <SD_Select_SPI+0x4>
  LCD_CS_HIGH;               // Unselect LCD
 800fa76:	4908      	ldr	r1, [pc, #32]	@ (800fa98 <SD_Select_SPI+0x2c>)
 800fa78:	2340      	movs	r3, #64	@ 0x40
 800fa7a:	618b      	str	r3, [r1, #24]
  SPI_BR_SET(SD_SPI, speed); // Set Baud rate control for SD card
 800fa7c:	6813      	ldr	r3, [r2, #0]
 800fa7e:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
  SD_CS_LOW;                 // Select SD Card
 800fa82:	f04f 6400 	mov.w	r4, #134217728	@ 0x8000000
  SPI_BR_SET(SD_SPI, speed); // Set Baud rate control for SD card
 800fa86:	4303      	orrs	r3, r0
 800fa88:	6013      	str	r3, [r2, #0]
  SD_CS_LOW;                 // Select SD Card
 800fa8a:	618c      	str	r4, [r1, #24]
}
 800fa8c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800fa90:	4770      	bx	lr
 800fa92:	bf00      	nop
 800fa94:	40013000 	.word	0x40013000
 800fa98:	48000400 	.word	0x48000400

0800fa9c <spi_TxByte>:
  while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 800fa9c:	4a02      	ldr	r2, [pc, #8]	@ (800faa8 <spi_TxByte+0xc>)
 800fa9e:	6893      	ldr	r3, [r2, #8]
 800faa0:	079b      	lsls	r3, r3, #30
 800faa2:	d5fc      	bpl.n	800fa9e <spi_TxByte+0x2>
  SPI_WRITE_8BIT(LCD_SPI, data);
 800faa4:	7310      	strb	r0, [r2, #12]
}
 800faa6:	4770      	bx	lr
 800faa8:	40013000 	.word	0x40013000

0800faac <spi_TxBuffer>:
  while(len--) {
 800faac:	1e4b      	subs	r3, r1, #1
 800faae:	b29b      	uxth	r3, r3
 800fab0:	b151      	cbz	r1, 800fac8 <spi_TxBuffer+0x1c>
 800fab2:	3301      	adds	r3, #1
    while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 800fab4:	4a05      	ldr	r2, [pc, #20]	@ (800facc <spi_TxBuffer+0x20>)
 800fab6:	18c1      	adds	r1, r0, r3
 800fab8:	6893      	ldr	r3, [r2, #8]
 800faba:	079b      	lsls	r3, r3, #30
 800fabc:	d5fc      	bpl.n	800fab8 <spi_TxBuffer+0xc>
    SPI_WRITE_8BIT(LCD_SPI, *buffer++);
 800fabe:	f810 3b01 	ldrb.w	r3, [r0], #1
 800fac2:	7313      	strb	r3, [r2, #12]
  while(len--) {
 800fac4:	4288      	cmp	r0, r1
 800fac6:	d1f7      	bne.n	800fab8 <spi_TxBuffer+0xc>
}
 800fac8:	4770      	bx	lr
 800faca:	bf00      	nop
 800facc:	40013000 	.word	0x40013000

0800fad0 <lcd_send_command>:
static void lcd_send_command(uint8_t cmd, uint16_t len, const uint8_t *data) {
 800fad0:	b430      	push	{r4, r5}
  while (SPI_IS_BUSY(LCD_SPI));
 800fad2:	4c0c      	ldr	r4, [pc, #48]	@ (800fb04 <lcd_send_command+0x34>)
static void lcd_send_command(uint8_t cmd, uint16_t len, const uint8_t *data) {
 800fad4:	4684      	mov	ip, r0
 800fad6:	4610      	mov	r0, r2
  while (SPI_IS_BUSY(LCD_SPI));
 800fad8:	68a3      	ldr	r3, [r4, #8]
 800fada:	061a      	lsls	r2, r3, #24
 800fadc:	d4fc      	bmi.n	800fad8 <lcd_send_command+0x8>
  LCD_CS_LOW;
 800fade:	4b0a      	ldr	r3, [pc, #40]	@ (800fb08 <lcd_send_command+0x38>)
  while (SPI_IS_BUSY(LCD_SPI));
 800fae0:	4d08      	ldr	r5, [pc, #32]	@ (800fb04 <lcd_send_command+0x34>)
  LCD_CS_LOW;
 800fae2:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 800fae6:	619a      	str	r2, [r3, #24]
  LCD_DC_CMD;
 800fae8:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 800faec:	619a      	str	r2, [r3, #24]
  SPI_WRITE_8BIT(LCD_SPI, cmd);
 800faee:	f884 c00c 	strb.w	ip, [r4, #12]
  while (SPI_IS_BUSY(LCD_SPI));
 800faf2:	68ab      	ldr	r3, [r5, #8]
 800faf4:	061b      	lsls	r3, r3, #24
 800faf6:	d4fc      	bmi.n	800faf2 <lcd_send_command+0x22>
  LCD_DC_DATA;
 800faf8:	4b03      	ldr	r3, [pc, #12]	@ (800fb08 <lcd_send_command+0x38>)
 800fafa:	2280      	movs	r2, #128	@ 0x80
}
 800fafc:	bc30      	pop	{r4, r5}
  LCD_DC_DATA;
 800fafe:	619a      	str	r2, [r3, #24]
  spi_TxBuffer(data, len);
 800fb00:	f7ff bfd4 	b.w	800faac <spi_TxBuffer>
 800fb04:	40013000 	.word	0x40013000
 800fb08:	48000400 	.word	0x48000400

0800fb0c <spi_RxByte>:
  SPI_WRITE_8BIT(LCD_SPI, 0xFF);
 800fb0c:	4a03      	ldr	r2, [pc, #12]	@ (800fb1c <spi_RxByte+0x10>)
 800fb0e:	23ff      	movs	r3, #255	@ 0xff
 800fb10:	7313      	strb	r3, [r2, #12]
  while (SPI_RX_IS_EMPTY(LCD_SPI));
 800fb12:	6893      	ldr	r3, [r2, #8]
 800fb14:	07db      	lsls	r3, r3, #31
 800fb16:	d5fc      	bpl.n	800fb12 <spi_RxByte+0x6>
  return SPI_READ_8BIT(LCD_SPI);
 800fb18:	7b10      	ldrb	r0, [r2, #12]
}
 800fb1a:	4770      	bx	lr
 800fb1c:	40013000 	.word	0x40013000

0800fb20 <SD_Unselect_SPI>:

static void SD_Unselect_SPI(void) {
 800fb20:	b508      	push	{r3, lr}
  while (SPI_IS_BUSY(SD_SPI));
 800fb22:	4907      	ldr	r1, [pc, #28]	@ (800fb40 <SD_Unselect_SPI+0x20>)
 800fb24:	688b      	ldr	r3, [r1, #8]
 800fb26:	061b      	lsls	r3, r3, #24
 800fb28:	d4fc      	bmi.n	800fb24 <SD_Unselect_SPI+0x4>
  SD_CS_HIGH;                         // Unselect SD Card
 800fb2a:	4b06      	ldr	r3, [pc, #24]	@ (800fb44 <SD_Unselect_SPI+0x24>)
 800fb2c:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 800fb30:	619a      	str	r2, [r3, #24]
  spi_RxByte();                       // Dummy read/write one Byte recommend for SD after CS up
 800fb32:	f7ff ffeb 	bl	800fb0c <spi_RxByte>
  SPI_BR_SET(LCD_SPI, LCD_SPI_SPEED); // Restore Baud rate for LCD
 800fb36:	680b      	ldr	r3, [r1, #0]
 800fb38:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
 800fb3c:	600b      	str	r3, [r1, #0]
}
 800fb3e:	bd08      	pop	{r3, pc}
 800fb40:	40013000 	.word	0x40013000
 800fb44:	48000400 	.word	0x48000400

0800fb48 <spi_RxBuffer>:
void spi_RxBuffer(uint8_t *buffer, uint16_t len) {
 800fb48:	1e4b      	subs	r3, r1, #1
 800fb4a:	b29b      	uxth	r3, r3
 800fb4c:	3301      	adds	r3, #1
    SPI_WRITE_8BIT(LCD_SPI, 0xFF);
 800fb4e:	4a07      	ldr	r2, [pc, #28]	@ (800fb6c <spi_RxBuffer+0x24>)
 800fb50:	18c1      	adds	r1, r0, r3
 800fb52:	f04f 3cff 	mov.w	ip, #4294967295
 800fb56:	f882 c00c 	strb.w	ip, [r2, #12]
    while (SPI_RX_IS_EMPTY(LCD_SPI));
 800fb5a:	6893      	ldr	r3, [r2, #8]
 800fb5c:	07db      	lsls	r3, r3, #31
 800fb5e:	d5fc      	bpl.n	800fb5a <spi_RxBuffer+0x12>
    *buffer++ = SPI_READ_8BIT(LCD_SPI);
 800fb60:	7b13      	ldrb	r3, [r2, #12]
 800fb62:	f800 3b01 	strb.w	r3, [r0], #1
  }while(--len);
 800fb66:	4288      	cmp	r0, r1
 800fb68:	d1f5      	bne.n	800fb56 <spi_RxBuffer+0xe>
}
 800fb6a:	4770      	bx	lr
 800fb6c:	40013000 	.word	0x40013000

0800fb70 <spi_DropRx>:
  while (SPI_RX_IS_NOT_EMPTY(LCD_SPI)||SPI_IS_BUSY(LCD_SPI))
 800fb70:	4b05      	ldr	r3, [pc, #20]	@ (800fb88 <spi_DropRx+0x18>)
 800fb72:	e000      	b.n	800fb76 <spi_DropRx+0x6>
    (void)SPI_READ_8BIT(LCD_SPI);
 800fb74:	7b1a      	ldrb	r2, [r3, #12]
  while (SPI_RX_IS_NOT_EMPTY(LCD_SPI)||SPI_IS_BUSY(LCD_SPI))
 800fb76:	689a      	ldr	r2, [r3, #8]
 800fb78:	07d1      	lsls	r1, r2, #31
 800fb7a:	d4fb      	bmi.n	800fb74 <spi_DropRx+0x4>
 800fb7c:	689a      	ldr	r2, [r3, #8]
 800fb7e:	0612      	lsls	r2, r2, #24
 800fb80:	d4f8      	bmi.n	800fb74 <spi_DropRx+0x4>
  (void)SPI_READ_8BIT(LCD_SPI);
 800fb82:	7b1b      	ldrb	r3, [r3, #12]
}
 800fb84:	4770      	bx	lr
 800fb86:	bf00      	nop
 800fb88:	40013000 	.word	0x40013000

0800fb8c <SD_WaitNotBusy>:
    ;
  return res&0x1F;
}

// Wait no Busy answer from SD (wait time in systick)
static uint8_t SD_WaitNotBusy(uint32_t wait_time) {
 800fb8c:	b570      	push	{r4, r5, r6, lr}
 800fb8e:	f04f 4580 	mov.w	r5, #1073741824	@ 0x40000000
 800fb92:	4604      	mov	r4, r0
 800fb94:	6a6e      	ldr	r6, [r5, #36]	@ 0x24
  uint8_t res;
  uint32_t time = chVTGetSystemTimeX();
  spi_DropRx();
 800fb96:	f7ff ffeb 	bl	800fb70 <spi_DropRx>
 800fb9a:	e003      	b.n	800fba4 <SD_WaitNotBusy+0x18>
 800fb9c:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  do {
    if ((res = spi_RxByte()) == 0xFF)
      return res;
  } while(chVTGetSystemTimeX() - time < wait_time);
 800fb9e:	1b9b      	subs	r3, r3, r6
 800fba0:	42a3      	cmp	r3, r4
 800fba2:	d204      	bcs.n	800fbae <SD_WaitNotBusy+0x22>
    if ((res = spi_RxByte()) == 0xFF)
 800fba4:	f7ff ffb2 	bl	800fb0c <spi_RxByte>
 800fba8:	28ff      	cmp	r0, #255	@ 0xff
 800fbaa:	d1f7      	bne.n	800fb9c <SD_WaitNotBusy+0x10>
  return 0;
}
 800fbac:	bd70      	pop	{r4, r5, r6, pc}
  return 0;
 800fbae:	2000      	movs	r0, #0
}
 800fbb0:	bd70      	pop	{r4, r5, r6, pc}
 800fbb2:	bf00      	nop

0800fbb4 <SD_TxDataBlock.constprop.0>:
#endif
  return TRUE;
}

// Transmit data block to SD
static bool SD_TxDataBlock(const uint8_t *buff, uint16_t len, uint8_t token) {
 800fbb4:	b508      	push	{r3, lr}
 800fbb6:	4603      	mov	r3, r0
  uint8_t r1;
  // Transmit token
  spi_TxByte(token);
 800fbb8:	4608      	mov	r0, r1
static bool SD_TxDataBlock(const uint8_t *buff, uint16_t len, uint8_t token) {
 800fbba:	4619      	mov	r1, r3
  spi_TxByte(token);
 800fbbc:	f7ff ff6e 	bl	800fa9c <spi_TxByte>
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 800fbc0:	4a12      	ldr	r2, [pc, #72]	@ (800fc0c <SD_TxDataBlock.constprop.0+0x58>)
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 800fbc2:	f44f 7000 	mov.w	r0, #512	@ 0x200
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fbc6:	f241 0391 	movw	r3, #4241	@ 0x1091
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 800fbca:	63d1      	str	r1, [r2, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 800fbcc:	6350      	str	r0, [r2, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fbce:	6313      	str	r3, [r2, #48]	@ 0x30
  uint16_t bcrc = crc16(buff, len);
#else
  uint16_t bcrc = 0xFFFF;
#endif
#ifdef __USE_SDCARD_DMA__
  dmaChannelWaitCompletion(SD_DMA_TX);
 800fbd0:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 800fbd2:	2b00      	cmp	r3, #0
 800fbd4:	d1fc      	bne.n	800fbd0 <SD_TxDataBlock.constprop.0+0x1c>
 800fbd6:	6313      	str	r3, [r2, #48]	@ 0x30
#endif
  spi_TxByte((bcrc>>0) & 0xFF); // Send CRC
 800fbd8:	20ff      	movs	r0, #255	@ 0xff
 800fbda:	f7ff ff5f 	bl	800fa9c <spi_TxByte>
  spi_TxByte((bcrc>>8) & 0xFF);
 800fbde:	f7ff ff5d 	bl	800fa9c <spi_TxByte>
  spi_DropRx();
 800fbe2:	f7ff ffc5 	bl	800fb70 <spi_DropRx>
  while((res = spi_RxByte()) == 0xFF && --cnt)
 800fbe6:	2164      	movs	r1, #100	@ 0x64
 800fbe8:	e001      	b.n	800fbee <SD_TxDataBlock.constprop.0+0x3a>
 800fbea:	3901      	subs	r1, #1
 800fbec:	d00b      	beq.n	800fc06 <SD_TxDataBlock.constprop.0+0x52>
 800fbee:	f7ff ff8d 	bl	800fb0c <spi_RxByte>
 800fbf2:	28ff      	cmp	r0, #255	@ 0xff
 800fbf4:	d0f9      	beq.n	800fbea <SD_TxDataBlock.constprop.0+0x36>
  // Receive transmit data response token on next 8 bytes
  if ((r1 = SD_WaitDataAccept(100)) != SD_TOKEN_DATA_ACCEPTED) {
 800fbf6:	f000 001f 	and.w	r0, r0, #31
 800fbfa:	f1a0 0005 	sub.w	r0, r0, #5
 800fbfe:	fab0 f080 	clz	r0, r0
 800fc02:	0940      	lsrs	r0, r0, #5
    return FALSE;
  }
#endif
  // Continue execute, wait not busy on next command
  return TRUE;
}
 800fc04:	bd08      	pop	{r3, pc}
 800fc06:	4608      	mov	r0, r1
 800fc08:	bd08      	pop	{r3, pc}
 800fc0a:	bf00      	nop
 800fc0c:	40020000 	.word	0x40020000

0800fc10 <SD_RxDataBlock.constprop.0>:
static bool SD_RxDataBlock(uint8_t *buff, uint16_t len, uint8_t token) {
 800fc10:	b570      	push	{r4, r5, r6, lr}
 800fc12:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
 800fc16:	b082      	sub	sp, #8
 800fc18:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 800fc1a:	4606      	mov	r6, r0
  spi_DropRx();
 800fc1c:	f7ff ffa8 	bl	800fb70 <spi_DropRx>
  while((res = spi_RxByte()) != token && chVTGetSystemTimeX() - time < wait_time)
 800fc20:	f242 710f 	movw	r1, #9999	@ 0x270f
 800fc24:	e003      	b.n	800fc2e <SD_RxDataBlock.constprop.0+0x1e>
 800fc26:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 800fc28:	1b5b      	subs	r3, r3, r5
 800fc2a:	428b      	cmp	r3, r1
 800fc2c:	d81b      	bhi.n	800fc66 <SD_RxDataBlock.constprop.0+0x56>
 800fc2e:	f7ff ff6d 	bl	800fb0c <spi_RxByte>
 800fc32:	28fe      	cmp	r0, #254	@ 0xfe
 800fc34:	d1f7      	bne.n	800fc26 <SD_RxDataBlock.constprop.0+0x16>
  dmaChannelSetMemory(LCD_DMA_RX, buffer);
 800fc36:	4b0d      	ldr	r3, [pc, #52]	@ (800fc6c <SD_RxDataBlock.constprop.0+0x5c>)
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 800fc38:	480d      	ldr	r0, [pc, #52]	@ (800fc70 <SD_RxDataBlock.constprop.0+0x60>)
  dmaChannelSetMemory(LCD_DMA_RX, buffer);
 800fc3a:	629e      	str	r6, [r3, #40]	@ 0x28
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 800fc3c:	f44f 7200 	mov.w	r2, #512	@ 0x200
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 800fc40:	f241 0111 	movw	r1, #4113	@ 0x1011
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fc44:	f241 0481 	movw	r4, #4225	@ 0x1081
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 800fc48:	621a      	str	r2, [r3, #32]
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fc4a:	61dc      	str	r4, [r3, #28]
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 800fc4c:	63d8      	str	r0, [r3, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 800fc4e:	635a      	str	r2, [r3, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 800fc50:	6319      	str	r1, [r3, #48]	@ 0x30
    dmaChannelWaitCompletionRxTx();
 800fc52:	f7ff fefd 	bl	800fa50 <dmaChannelWaitCompletionRxTx>
  uint16_t crc; spi_RxBuffer((uint8_t*)&crc, 2);
 800fc56:	f10d 0006 	add.w	r0, sp, #6
 800fc5a:	2102      	movs	r1, #2
 800fc5c:	f7ff ff74 	bl	800fb48 <spi_RxBuffer>
  return TRUE;
 800fc60:	2001      	movs	r0, #1
}
 800fc62:	b002      	add	sp, #8
 800fc64:	bd70      	pop	{r4, r5, r6, pc}
    return FALSE;
 800fc66:	2000      	movs	r0, #0
}
 800fc68:	b002      	add	sp, #8
 800fc6a:	bd70      	pop	{r4, r5, r6, pc}
 800fc6c:	40020000 	.word	0x40020000
 800fc70:	08019a2c 	.word	0x08019a2c

0800fc74 <SD_SendCmd>:

// Transmit command to SD
static uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg) {
 800fc74:	b530      	push	{r4, r5, lr}
  uint8_t buf[6];
  uint8_t r1;
  // Advanced command (ACMD__), need send CMD55 before
  if ((cmd & 0x80) && (r1 = SD_SendCmd(CMD55, 0)) > 1) return r1;
 800fc76:	0602      	lsls	r2, r0, #24
static uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg) {
 800fc78:	b083      	sub	sp, #12
 800fc7a:	4604      	mov	r4, r0
 800fc7c:	460d      	mov	r5, r1
  if ((cmd & 0x80) && (r1 = SD_SendCmd(CMD55, 0)) > 1) return r1;
 800fc7e:	d42f      	bmi.n	800fce0 <SD_SendCmd+0x6c>
  // wait SD ready after last Tx (recommended timeout is 250ms (500ms for SDXC) set 250ms
  if ((r1 = SD_WaitNotBusy(MS2ST(500))) != 0xFF) {
 800fc80:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800fc84:	f7ff ff82 	bl	800fb8c <SD_WaitNotBusy>
 800fc88:	28ff      	cmp	r0, #255	@ 0xff
 800fc8a:	d135      	bne.n	800fcf8 <SD_SendCmd+0x84>
    DEBUG_PRINT(" SD_WaitNotBusy CMD%d err, %02x\r\n", cmd-0x40, (uint32_t)r1);
    return 0xFF;
  }
  // Transmit command
  buf[0] = cmd & 0x7F;
 800fc8c:	f004 027f 	and.w	r2, r4, #127	@ 0x7f
 800fc90:	2300      	movs	r3, #0
 800fc92:	f362 0307 	bfi	r3, r2, #0, #8
  buf[1] = (arg >> 24)&0xFF;
 800fc96:	0e2a      	lsrs	r2, r5, #24
  buf[0] = cmd & 0x7F;
 800fc98:	f362 230f 	bfi	r3, r2, #8, #8
  buf[2] = (arg >> 16)&0xFF;
 800fc9c:	0c2a      	lsrs	r2, r5, #16
  buf[0] = cmd & 0x7F;
 800fc9e:	f362 4317 	bfi	r3, r2, #16, #8
  buf[3] = (arg >>  8)&0xFF;
 800fca2:	0a2a      	lsrs	r2, r5, #8
  buf[0] = cmd & 0x7F;
 800fca4:	f362 631f 	bfi	r3, r2, #24, #8
  buf[4] = (arg >>  0)&0xFF;
#ifdef SD_USE_COMMAND_CRC
  buf[5] = crc7(buf, 5)|0x01;
#else
  uint8_t crc = 0x01;              // Dummy CRC + Stop
       if (cmd == CMD0) crc = 0x95;// Valid CRC for CMD0(0)
 800fca8:	2c40      	cmp	r4, #64	@ 0x40
  buf[0] = cmd & 0x7F;
 800fcaa:	9300      	str	r3, [sp, #0]
  buf[4] = (arg >>  0)&0xFF;
 800fcac:	f88d 5004 	strb.w	r5, [sp, #4]
       if (cmd == CMD0) crc = 0x95;// Valid CRC for CMD0(0)
 800fcb0:	d025      	beq.n	800fcfe <SD_SendCmd+0x8a>
  else if (cmd == CMD8) crc = 0x87;// Valid CRC for CMD8(0x1AA)
 800fcb2:	2c48      	cmp	r4, #72	@ 0x48
 800fcb4:	d02e      	beq.n	800fd14 <SD_SendCmd+0xa0>
  buf[5] = crc;
 800fcb6:	2301      	movs	r3, #1
#endif
  spi_TxBuffer(buf, 6);
 800fcb8:	2106      	movs	r1, #6
 800fcba:	4668      	mov	r0, sp
  buf[5] = crc;
 800fcbc:	f88d 3005 	strb.w	r3, [sp, #5]
  spi_TxBuffer(buf, 6);
 800fcc0:	f7ff fef4 	bl	800faac <spi_TxBuffer>
// Skip a stuff byte when STOP_TRANSMISSION
  if (cmd == CMD12) spi_RxByte();
 800fcc4:	2c4c      	cmp	r4, #76	@ 0x4c
 800fcc6:	d022      	beq.n	800fd0e <SD_SendCmd+0x9a>
  spi_DropRx();
 800fcc8:	f7ff ff52 	bl	800fb70 <spi_DropRx>
  while(((r1=spi_RxByte())&0x80) && --cnt)
 800fccc:	2164      	movs	r1, #100	@ 0x64
 800fcce:	e001      	b.n	800fcd4 <SD_SendCmd+0x60>
 800fcd0:	3901      	subs	r1, #1
 800fcd2:	d003      	beq.n	800fcdc <SD_SendCmd+0x68>
 800fcd4:	f7ff ff1a 	bl	800fb0c <spi_RxByte>
 800fcd8:	0603      	lsls	r3, r0, #24
 800fcda:	d4f9      	bmi.n	800fcd0 <SD_SendCmd+0x5c>
    return r1;
  }
  if (r1&(~SD_R1_IDLE))
    DEBUG_PRINT(" SD_SendCmd CMD%d, 0x%x, 0x%08x\r\n", (uint32_t)cmd-0x40, (uint32_t)r1, arg);
  return r1;
}
 800fcdc:	b003      	add	sp, #12
 800fcde:	bd30      	pop	{r4, r5, pc}
  if ((cmd & 0x80) && (r1 = SD_SendCmd(CMD55, 0)) > 1) return r1;
 800fce0:	2100      	movs	r1, #0
 800fce2:	2077      	movs	r0, #119	@ 0x77
 800fce4:	f7ff ffc6 	bl	800fc74 <SD_SendCmd>
 800fce8:	2801      	cmp	r0, #1
 800fcea:	d8f7      	bhi.n	800fcdc <SD_SendCmd+0x68>
  if ((r1 = SD_WaitNotBusy(MS2ST(500))) != 0xFF) {
 800fcec:	f24c 3050 	movw	r0, #50000	@ 0xc350
 800fcf0:	f7ff ff4c 	bl	800fb8c <SD_WaitNotBusy>
 800fcf4:	28ff      	cmp	r0, #255	@ 0xff
 800fcf6:	d0c9      	beq.n	800fc8c <SD_SendCmd+0x18>
    return 0xFF;
 800fcf8:	20ff      	movs	r0, #255	@ 0xff
}
 800fcfa:	b003      	add	sp, #12
 800fcfc:	bd30      	pop	{r4, r5, pc}
  buf[5] = crc;
 800fcfe:	2395      	movs	r3, #149	@ 0x95
  spi_TxBuffer(buf, 6);
 800fd00:	2106      	movs	r1, #6
 800fd02:	4668      	mov	r0, sp
  buf[5] = crc;
 800fd04:	f88d 3005 	strb.w	r3, [sp, #5]
  spi_TxBuffer(buf, 6);
 800fd08:	f7ff fed0 	bl	800faac <spi_TxBuffer>
  if (cmd == CMD12) spi_RxByte();
 800fd0c:	e7dc      	b.n	800fcc8 <SD_SendCmd+0x54>
 800fd0e:	f7ff fefd 	bl	800fb0c <spi_RxByte>
 800fd12:	e7d9      	b.n	800fcc8 <SD_SendCmd+0x54>
  buf[5] = crc;
 800fd14:	2387      	movs	r3, #135	@ 0x87
  spi_TxBuffer(buf, 6);
 800fd16:	2106      	movs	r1, #6
 800fd18:	4668      	mov	r0, sp
  buf[5] = crc;
 800fd1a:	f88d 3005 	strb.w	r3, [sp, #5]
  spi_TxBuffer(buf, 6);
 800fd1e:	f7ff fec5 	bl	800faac <spi_TxBuffer>
  if (cmd == CMD12) spi_RxByte();
 800fd22:	e7d1      	b.n	800fcc8 <SD_SendCmd+0x54>

0800fd24 <lcd_get_cell_buffer>:
  return &spi_buffer[(LCD_dma_status&LCD_BUFFER_1) ? SPI_BUFFER_SIZE/2 : 0];
 800fd24:	4b03      	ldr	r3, [pc, #12]	@ (800fd34 <lcd_get_cell_buffer+0x10>)
 800fd26:	4804      	ldr	r0, [pc, #16]	@ (800fd38 <lcd_get_cell_buffer+0x14>)
 800fd28:	781b      	ldrb	r3, [r3, #0]
 800fd2a:	02db      	lsls	r3, r3, #11
 800fd2c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
}
 800fd30:	4418      	add	r0, r3
 800fd32:	4770      	bx	lr
 800fd34:	200089ef 	.word	0x200089ef
 800fd38:	200089f4 	.word	0x200089f4

0800fd3c <lcd_set_rotation>:
  lcd_send_command(LCD_MADCTL, 1, &ST7796S_rotation_const[r]);
 800fd3c:	4a02      	ldr	r2, [pc, #8]	@ (800fd48 <lcd_set_rotation+0xc>)
 800fd3e:	2101      	movs	r1, #1
 800fd40:	4402      	add	r2, r0
 800fd42:	2036      	movs	r0, #54	@ 0x36
 800fd44:	f7ff bec4 	b.w	800fad0 <lcd_send_command>
 800fd48:	08014ef8 	.word	0x08014ef8

0800fd4c <lcd_setWindow>:
void lcd_setWindow(int x, int y, int w, int h, uint16_t cmd) {
 800fd4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fd4e:	4617      	mov	r7, r2
 800fd50:	b083      	sub	sp, #12
  uint32_t xx = __REV16(x | ((x + w - 1) << 16));
 800fd52:	4407      	add	r7, r0
 800fd54:	3f01      	subs	r7, #1
void lcd_setWindow(int x, int y, int w, int h, uint16_t cmd) {
 800fd56:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 800fd5a:	460c      	mov	r4, r1
 800fd5c:	461d      	mov	r5, r3
  uint32_t xx = __REV16(x | ((x + w - 1) << 16));
 800fd5e:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
  dmaChannelWaitCompletionRxTx();
 800fd62:	f7ff fe75 	bl	800fa50 <dmaChannelWaitCompletionRxTx>
  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 800fd66:	ba40      	rev16	r0, r0
  uint32_t yy = __REV16(y | ((y + h - 1) << 16));
 800fd68:	4425      	add	r5, r4
 800fd6a:	3d01      	subs	r5, #1
  uint32_t xx = __REV16(x | ((x + w - 1) << 16));
 800fd6c:	9000      	str	r0, [sp, #0]
  uint32_t yy = __REV16(y | ((y + h - 1) << 16));
 800fd6e:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800fd72:	ba64      	rev16	r4, r4
  lcd_send_command(LCD_CASET, 4, (uint8_t *)&xx);
 800fd74:	2104      	movs	r1, #4
 800fd76:	466a      	mov	r2, sp
 800fd78:	202a      	movs	r0, #42	@ 0x2a
  uint32_t yy = __REV16(y | ((y + h - 1) << 16));
 800fd7a:	9401      	str	r4, [sp, #4]
  lcd_send_command(LCD_CASET, 4, (uint8_t *)&xx);
 800fd7c:	f7ff fea8 	bl	800fad0 <lcd_send_command>
  lcd_send_command(LCD_RASET, 4, (uint8_t *)&yy);
 800fd80:	2104      	movs	r1, #4
 800fd82:	eb0d 0201 	add.w	r2, sp, r1
 800fd86:	202b      	movs	r0, #43	@ 0x2b
 800fd88:	f7ff fea2 	bl	800fad0 <lcd_send_command>
  lcd_send_command(cmd, 0, NULL);
 800fd8c:	2200      	movs	r2, #0
 800fd8e:	4611      	mov	r1, r2
 800fd90:	b2f0      	uxtb	r0, r6
}
 800fd92:	b003      	add	sp, #12
 800fd94:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  lcd_send_command(cmd, 0, NULL);
 800fd98:	f7ff be9a 	b.w	800fad0 <lcd_send_command>

0800fd9c <lcd_bulk_buffer>:
static void lcd_bulk_buffer(int x, int y, int w, int h, pixel_t *buffer) {
 800fd9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fda0:	b086      	sub	sp, #24
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 800fda2:	242c      	movs	r4, #44	@ 0x2c
 800fda4:	9400      	str	r4, [sp, #0]
static void lcd_bulk_buffer(int x, int y, int w, int h, pixel_t *buffer) {
 800fda6:	4615      	mov	r5, r2
 800fda8:	461c      	mov	r4, r3
 800fdaa:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 800fdac:	460f      	mov	r7, r1
 800fdae:	4680      	mov	r8, r0
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 800fdb0:	f7ff ffcc 	bl	800fd4c <lcd_setWindow>
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 800fdb4:	4b16      	ldr	r3, [pc, #88]	@ (800fe10 <lcd_bulk_buffer+0x74>)
  if (sweep_mode & SWEEP_REMOTE) {
 800fdb6:	4a17      	ldr	r2, [pc, #92]	@ (800fe14 <lcd_bulk_buffer+0x78>)
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 800fdb8:	63de      	str	r6, [r3, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, w * h);
 800fdba:	fb04 f105 	mul.w	r1, r4, r5
 800fdbe:	6359      	str	r1, [r3, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | LCD_DMA_MODE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fdc0:	f241 5191 	movw	r1, #5521	@ 0x1591
 800fdc4:	6319      	str	r1, [r3, #48]	@ 0x30
  if (sweep_mode & SWEEP_REMOTE) {
 800fdc6:	7813      	ldrb	r3, [r2, #0]
 800fdc8:	065b      	lsls	r3, r3, #25
 800fdca:	d402      	bmi.n	800fdd2 <lcd_bulk_buffer+0x36>
}
 800fdcc:	b006      	add	sp, #24
 800fdce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 800fdd2:	4a11      	ldr	r2, [pc, #68]	@ (800fe18 <lcd_bulk_buffer+0x7c>)
 800fdd4:	e892 0003 	ldmia.w	r2, {r0, r1}
 800fdd8:	2300      	movs	r3, #0
 800fdda:	f8ad 100c 	strh.w	r1, [sp, #12]
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 800fdde:	fb15 f204 	smulbb	r2, r5, r4
 800fde2:	4631      	mov	r1, r6
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 800fde4:	461e      	mov	r6, r3
 800fde6:	f365 060f 	bfi	r6, r5, #0, #16
 800fdea:	f368 030f 	bfi	r3, r8, #0, #16
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 800fdee:	0052      	lsls	r2, r2, #1
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 800fdf0:	9002      	str	r0, [sp, #8]
 800fdf2:	f367 431f 	bfi	r3, r7, #16, #16
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 800fdf6:	b292      	uxth	r2, r2
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 800fdf8:	f364 461f 	bfi	r6, r4, #16, #16
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 800fdfc:	a802      	add	r0, sp, #8
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 800fdfe:	f8cd 300e 	str.w	r3, [sp, #14]
 800fe02:	f8cd 6012 	str.w	r6, [sp, #18]
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 800fe06:	f7f8 fc7f 	bl	8008708 <send_region>
}
 800fe0a:	b006      	add	sp, #24
 800fe0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fe10:	40020000 	.word	0x40020000
 800fe14:	200003c4 	.word	0x200003c4
 800fe18:	08012818 	.word	0x08012818

0800fe1c <lcd_read_memory>:
void lcd_read_memory(int x, int y, int w, int h, uint16_t *out) {
 800fe1c:	b570      	push	{r4, r5, r6, lr}
 800fe1e:	b082      	sub	sp, #8
  lcd_setWindow(x, y, w, h, LCD_RAMRD);
 800fe20:	252e      	movs	r5, #46	@ 0x2e
 800fe22:	9500      	str	r5, [sp, #0]
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_RX_SPEED);
 800fe24:	4d15      	ldr	r5, [pc, #84]	@ (800fe7c <lcd_read_memory+0x60>)
void lcd_read_memory(int x, int y, int w, int h, uint16_t *out) {
 800fe26:	461e      	mov	r6, r3
 800fe28:	4614      	mov	r4, r2
  lcd_setWindow(x, y, w, h, LCD_RAMRD);
 800fe2a:	f7ff ff8f 	bl	800fd4c <lcd_setWindow>
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_RX_SPEED);
 800fe2e:	682a      	ldr	r2, [r5, #0]
 800fe30:	f022 0238 	bic.w	r2, r2, #56	@ 0x38
 800fe34:	f042 0208 	orr.w	r2, r2, #8
 800fe38:	602a      	str	r2, [r5, #0]
  spi_DropRx();         // Skip data from rx buffer
 800fe3a:	f7ff fe99 	bl	800fb70 <spi_DropRx>
  spi_RxByte();         // require 8bit dummy clock
 800fe3e:	f7ff fe65 	bl	800fb0c <spi_RxByte>
  spi_DMARxBuffer((uint8_t *)out, len * 2, true);
 800fe42:	fb14 f206 	smulbb	r2, r4, r6
  dmaChannelSetMemory(LCD_DMA_RX, buffer);
 800fe46:	490e      	ldr	r1, [pc, #56]	@ (800fe80 <lcd_read_memory+0x64>)
 800fe48:	9806      	ldr	r0, [sp, #24]
 800fe4a:	6288      	str	r0, [r1, #40]	@ 0x28
  spi_DMARxBuffer((uint8_t *)out, len * 2, true);
 800fe4c:	0052      	lsls	r2, r2, #1
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 800fe4e:	b292      	uxth	r2, r2
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fe50:	f241 0381 	movw	r3, #4225	@ 0x1081
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 800fe54:	620a      	str	r2, [r1, #32]
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 800fe56:	480b      	ldr	r0, [pc, #44]	@ (800fe84 <lcd_read_memory+0x68>)
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 800fe58:	61cb      	str	r3, [r1, #28]
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 800fe5a:	f241 0311 	movw	r3, #4113	@ 0x1011
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 800fe5e:	63c8      	str	r0, [r1, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 800fe60:	634a      	str	r2, [r1, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 800fe62:	630b      	str	r3, [r1, #48]	@ 0x30
    dmaChannelWaitCompletionRxTx();
 800fe64:	f7ff fdf4 	bl	800fa50 <dmaChannelWaitCompletionRxTx>
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_SPEED);
 800fe68:	682b      	ldr	r3, [r5, #0]
  LCD_CS_HIGH;
 800fe6a:	4a07      	ldr	r2, [pc, #28]	@ (800fe88 <lcd_read_memory+0x6c>)
 800fe6c:	2140      	movs	r1, #64	@ 0x40
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_SPEED);
 800fe6e:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
 800fe72:	602b      	str	r3, [r5, #0]
  LCD_CS_HIGH;
 800fe74:	6191      	str	r1, [r2, #24]
}
 800fe76:	b002      	add	sp, #8
 800fe78:	bd70      	pop	{r4, r5, r6, pc}
 800fe7a:	bf00      	nop
 800fe7c:	40013000 	.word	0x40013000
 800fe80:	40020000 	.word	0x40020000
 800fe84:	08019a2c 	.word	0x08019a2c
 800fe88:	48000400 	.word	0x48000400

0800fe8c <lcd_set_flip>:
void lcd_set_flip(bool flip) {
 800fe8c:	b508      	push	{r3, lr}
  lcd_set_rotation(flip ? DISPLAY_ROTATION_180 : DISPLAY_ROTATION_0);
 800fe8e:	0040      	lsls	r0, r0, #1
  dmaChannelWaitCompletionRxTx();
 800fe90:	f7ff fdde 	bl	800fa50 <dmaChannelWaitCompletionRxTx>
  lcd_set_rotation(flip ? DISPLAY_ROTATION_180 : DISPLAY_ROTATION_0);
 800fe94:	f000 00fe 	and.w	r0, r0, #254	@ 0xfe
}
 800fe98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  lcd_set_rotation(flip ? DISPLAY_ROTATION_180 : DISPLAY_ROTATION_0);
 800fe9c:	f7ff bf4e 	b.w	800fd3c <lcd_set_rotation>

0800fea0 <lcd_bulk_finish>:
  dmaChannelWaitCompletion(LCD_DMA_TX);  // Wait DMA
 800fea0:	4a02      	ldr	r2, [pc, #8]	@ (800feac <lcd_bulk_finish+0xc>)
 800fea2:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 800fea4:	2b00      	cmp	r3, #0
 800fea6:	d1fc      	bne.n	800fea2 <lcd_bulk_finish+0x2>
 800fea8:	6313      	str	r3, [r2, #48]	@ 0x30
}
 800feaa:	4770      	bx	lr
 800feac:	40020000 	.word	0x40020000

0800feb0 <lcd_bulk_continue>:
void lcd_bulk_continue(int x, int y, int w, int h) {
 800feb0:	b530      	push	{r4, r5, lr}
 800feb2:	b083      	sub	sp, #12
 800feb4:	4604      	mov	r4, r0
 800feb6:	461d      	mov	r5, r3
  lcd_bulk_buffer(x, y, w, h, lcd_get_cell_buffer());  // Send new cell data
 800feb8:	f7ff ff34 	bl	800fd24 <lcd_get_cell_buffer>
 800febc:	462b      	mov	r3, r5
 800febe:	9000      	str	r0, [sp, #0]
 800fec0:	4620      	mov	r0, r4
 800fec2:	f7ff ff6b 	bl	800fd9c <lcd_bulk_buffer>
  LCD_dma_status^=LCD_BUFFER_1;                        // Switch buffer
 800fec6:	4a03      	ldr	r2, [pc, #12]	@ (800fed4 <lcd_bulk_continue+0x24>)
 800fec8:	7813      	ldrb	r3, [r2, #0]
 800feca:	f083 0301 	eor.w	r3, r3, #1
 800fece:	7013      	strb	r3, [r2, #0]
}
 800fed0:	b003      	add	sp, #12
 800fed2:	bd30      	pop	{r4, r5, pc}
 800fed4:	200089ef 	.word	0x200089ef

0800fed8 <lcd_bulk>:
void lcd_bulk(int x, int y, int w, int h) {
 800fed8:	b510      	push	{r4, lr}
 800feda:	b082      	sub	sp, #8
  lcd_bulk_buffer(x, y, w, h, spi_buffer);  // Send data
 800fedc:	4c04      	ldr	r4, [pc, #16]	@ (800fef0 <lcd_bulk+0x18>)
 800fede:	9400      	str	r4, [sp, #0]
 800fee0:	f7ff ff5c 	bl	800fd9c <lcd_bulk_buffer>
}
 800fee4:	b002      	add	sp, #8
 800fee6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  lcd_bulk_finish();                        // Wait
 800feea:	f7ff bfd9 	b.w	800fea0 <lcd_bulk_finish>
 800feee:	bf00      	nop
 800fef0:	200089f4 	.word	0x200089f4

0800fef4 <lcd_fill>:
void lcd_fill(int x, int y, int w, int h) {
 800fef4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800fef8:	b086      	sub	sp, #24
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 800fefa:	242c      	movs	r4, #44	@ 0x2c
 800fefc:	9400      	str	r4, [sp, #0]
void lcd_fill(int x, int y, int w, int h) {
 800fefe:	4615      	mov	r5, r2
 800ff00:	461c      	mov	r4, r3
 800ff02:	4688      	mov	r8, r1
 800ff04:	4607      	mov	r7, r0
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 800ff06:	f7ff ff21 	bl	800fd4c <lcd_setWindow>
  dmaChannelSetMemory(LCD_DMA_TX, &background_color);
 800ff0a:	4a1c      	ldr	r2, [pc, #112]	@ (800ff7c <lcd_fill+0x88>)
 800ff0c:	4b1c      	ldr	r3, [pc, #112]	@ (800ff80 <lcd_fill+0x8c>)
 800ff0e:	63d3      	str	r3, [r2, #60]	@ 0x3c
  uint32_t len = w * h;
 800ff10:	fb04 f105 	mul.w	r1, r4, r5
  while(len) {
 800ff14:	b179      	cbz	r1, 800ff36 <lcd_fill+0x42>
    uint32_t delta = len > 0xFFFF ? 0xFFFF : len; // DMA can send only 65535 data in one run
 800ff16:	f64f 7eff 	movw	lr, #65535	@ 0xffff
    dmaChannelSetMode(LCD_DMA_TX, txdmamode | LCD_DMA_MODE | STM32_DMA_CR_EN);
 800ff1a:	f241 5611 	movw	r6, #5393	@ 0x1511
    uint32_t delta = len > 0xFFFF ? 0xFFFF : len; // DMA can send only 65535 data in one run
 800ff1e:	4571      	cmp	r1, lr
 800ff20:	4608      	mov	r0, r1
 800ff22:	bf28      	it	cs
 800ff24:	4670      	movcs	r0, lr
    dmaChannelSetTransactionSize(LCD_DMA_TX, delta);
 800ff26:	6350      	str	r0, [r2, #52]	@ 0x34
    dmaChannelSetMode(LCD_DMA_TX, txdmamode | LCD_DMA_MODE | STM32_DMA_CR_EN);
 800ff28:	6316      	str	r6, [r2, #48]	@ 0x30
    dmaChannelWaitCompletion(LCD_DMA_TX);
 800ff2a:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 800ff2c:	2b00      	cmp	r3, #0
 800ff2e:	d1fc      	bne.n	800ff2a <lcd_fill+0x36>
  while(len) {
 800ff30:	1a09      	subs	r1, r1, r0
    dmaChannelWaitCompletion(LCD_DMA_TX);
 800ff32:	6313      	str	r3, [r2, #48]	@ 0x30
  while(len) {
 800ff34:	d1f3      	bne.n	800ff1e <lcd_fill+0x2a>
  if (sweep_mode & SWEEP_REMOTE) {
 800ff36:	4b13      	ldr	r3, [pc, #76]	@ (800ff84 <lcd_fill+0x90>)
 800ff38:	781b      	ldrb	r3, [r3, #0]
 800ff3a:	065b      	lsls	r3, r3, #25
 800ff3c:	d402      	bmi.n	800ff44 <lcd_fill+0x50>
}
 800ff3e:	b006      	add	sp, #24
 800ff40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    remote_region_t rd = {"fill\r\n", x, y, w, h};
 800ff44:	4a10      	ldr	r2, [pc, #64]	@ (800ff88 <lcd_fill+0x94>)
 800ff46:	2300      	movs	r3, #0
 800ff48:	e892 0003 	ldmia.w	r2, {r0, r1}
 800ff4c:	469c      	mov	ip, r3
 800ff4e:	f365 0c0f 	bfi	ip, r5, #0, #16
 800ff52:	f367 030f 	bfi	r3, r7, #0, #16
 800ff56:	9002      	str	r0, [sp, #8]
 800ff58:	f8ad 100c 	strh.w	r1, [sp, #12]
 800ff5c:	f368 431f 	bfi	r3, r8, #16, #16
 800ff60:	f364 4c1f 	bfi	ip, r4, #16, #16
    send_region(&rd, (uint8_t *)&background_color, sizeof(pixel_t));
 800ff64:	4906      	ldr	r1, [pc, #24]	@ (800ff80 <lcd_fill+0x8c>)
    remote_region_t rd = {"fill\r\n", x, y, w, h};
 800ff66:	f8cd 300e 	str.w	r3, [sp, #14]
    send_region(&rd, (uint8_t *)&background_color, sizeof(pixel_t));
 800ff6a:	2202      	movs	r2, #2
 800ff6c:	a802      	add	r0, sp, #8
    remote_region_t rd = {"fill\r\n", x, y, w, h};
 800ff6e:	f8cd c012 	str.w	ip, [sp, #18]
    send_region(&rd, (uint8_t *)&background_color, sizeof(pixel_t));
 800ff72:	f7f8 fbc9 	bl	8008708 <send_region>
}
 800ff76:	b006      	add	sp, #24
 800ff78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ff7c:	40020000 	.word	0x40020000
 800ff80:	200089f0 	.word	0x200089f0
 800ff84:	200003c4 	.word	0x200003c4
 800ff88:	08012820 	.word	0x08012820

0800ff8c <lcd_line>:
void lcd_line(int x0, int y0, int x1, int y1) {
 800ff8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (x1 < x0) { SWAP(int, x0, x1); SWAP(int, y0, y1); }      // Need draw from left to right
 800ff90:	4282      	cmp	r2, r0
void lcd_line(int x0, int y0, int x1, int y1) {
 800ff92:	468a      	mov	sl, r1
 800ff94:	b085      	sub	sp, #20
 800ff96:	4607      	mov	r7, r0
 800ff98:	4693      	mov	fp, r2
 800ff9a:	4619      	mov	r1, r3
  if (x1 < x0) { SWAP(int, x0, x1); SWAP(int, y0, y1); }      // Need draw from left to right
 800ff9c:	db05      	blt.n	800ffaa <lcd_line+0x1e>
 800ff9e:	461a      	mov	r2, r3
 800ffa0:	465b      	mov	r3, fp
 800ffa2:	4651      	mov	r1, sl
 800ffa4:	4683      	mov	fp, r0
 800ffa6:	4692      	mov	sl, r2
 800ffa8:	461f      	mov	r7, r3
  int dy = (y1 - y0), sy = 1; if (dy < 0) {dy = -dy; sy = -1;}
 800ffaa:	ebba 0601 	subs.w	r6, sl, r1
  int dx =-(x1 - x0), sx = 1;
 800ffae:	ebab 0807 	sub.w	r8, fp, r7
  int dy = (y1 - y0), sy = 1; if (dy < 0) {dy = -dy; sy = -1;}
 800ffb2:	bf46      	itte	mi
 800ffb4:	eba1 060a 	submi.w	r6, r1, sl
 800ffb8:	f04f 33ff 	movmi.w	r3, #4294967295
 800ffbc:	2301      	movpl	r3, #1
  int err = -((dx + dy) < 0 ? dx : dy) / 2;
 800ffbe:	eb16 0f08 	cmn.w	r6, r8
  int dy = (y1 - y0), sy = 1; if (dy < 0) {dy = -dy; sy = -1;}
 800ffc2:	9303      	str	r3, [sp, #12]
  int err = -((dx + dy) < 0 ? dx : dy) / 2;
 800ffc4:	d42c      	bmi.n	8010020 <lcd_line+0x94>
 800ffc6:	eb06 75d6 	add.w	r5, r6, r6, lsr #31
 800ffca:	106d      	asrs	r5, r5, #1
 800ffcc:	426d      	negs	r5, r5
 800ffce:	f8df 9060 	ldr.w	r9, [pc, #96]	@ 8010030 <lcd_line+0xa4>
      while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 800ffd2:	4c16      	ldr	r4, [pc, #88]	@ (801002c <lcd_line+0xa0>)
    lcd_setWindow(x0, y0, LCD_WIDTH-x0, 1, LCD_RAMWR);        // prepare send Horizontal line
 800ffd4:	9102      	str	r1, [sp, #8]
 800ffd6:	232c      	movs	r3, #44	@ 0x2c
 800ffd8:	9300      	str	r3, [sp, #0]
 800ffda:	f5cb 72f0 	rsb	r2, fp, #480	@ 0x1e0
 800ffde:	2301      	movs	r3, #1
 800ffe0:	4658      	mov	r0, fp
 800ffe2:	f7ff feb3 	bl	800fd4c <lcd_setWindow>
 800ffe6:	9902      	ldr	r1, [sp, #8]
      while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 800ffe8:	68a3      	ldr	r3, [r4, #8]
 800ffea:	079b      	lsls	r3, r3, #30
 800ffec:	d5fc      	bpl.n	800ffe8 <lcd_line+0x5c>
      SPI_WRITE_16BIT(LCD_SPI, foreground_color);             // Send color
 800ffee:	f8b9 3000 	ldrh.w	r3, [r9]
 800fff2:	81a3      	strh	r3, [r4, #12]
      if (x0 == x1 && y0 == y1)
 800fff4:	455f      	cmp	r7, fp
 800fff6:	d009      	beq.n	801000c <lcd_line+0x80>
      if (e2 > dx) { err-= dy; x0+= sx; }
 800fff8:	45a8      	cmp	r8, r5
 800fffa:	bfba      	itte	lt
 800fffc:	1bab      	sublt	r3, r5, r6
 800fffe:	f10b 0b01 	addlt.w	fp, fp, #1
 8010002:	462b      	movge	r3, r5
      if (e2 < dy) { err-= dx; y0+= sy; break;}               // Y coordinate change, next horizontal line
 8010004:	42ae      	cmp	r6, r5
 8010006:	dc06      	bgt.n	8010016 <lcd_line+0x8a>
 8010008:	461d      	mov	r5, r3
 801000a:	e7ed      	b.n	800ffe8 <lcd_line+0x5c>
      if (x0 == x1 && y0 == y1)
 801000c:	4551      	cmp	r1, sl
 801000e:	d1f3      	bne.n	800fff8 <lcd_line+0x6c>
}
 8010010:	b005      	add	sp, #20
 8010012:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (e2 < dy) { err-= dx; y0+= sy; break;}               // Y coordinate change, next horizontal line
 8010016:	eba3 0508 	sub.w	r5, r3, r8
 801001a:	9b03      	ldr	r3, [sp, #12]
 801001c:	4419      	add	r1, r3
    lcd_setWindow(x0, y0, LCD_WIDTH-x0, 1, LCD_RAMWR);        // prepare send Horizontal line
 801001e:	e7d9      	b.n	800ffd4 <lcd_line+0x48>
  int err = -((dx + dy) < 0 ? dx : dy) / 2;
 8010020:	eb08 75d8 	add.w	r5, r8, r8, lsr #31
 8010024:	106d      	asrs	r5, r5, #1
 8010026:	426d      	negs	r5, r5
 8010028:	e7d1      	b.n	800ffce <lcd_line+0x42>
 801002a:	bf00      	nop
 801002c:	40013000 	.word	0x40013000
 8010030:	200089f2 	.word	0x200089f2

08010034 <lcd_clear_screen>:
  lcd_fill(0, 0, LCD_WIDTH, LCD_HEIGHT);
 8010034:	2100      	movs	r1, #0
 8010036:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 801003a:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 801003e:	4608      	mov	r0, r1
 8010040:	f7ff bf58 	b.w	800fef4 <lcd_fill>

08010044 <lcd_init>:
void lcd_init(void) {
 8010044:	b538      	push	{r3, r4, r5, lr}
  rccEnableSPI1(FALSE);
 8010046:	4c1d      	ldr	r4, [pc, #116]	@ (80100bc <lcd_init+0x78>)
  LCD_SPI->CR1 = 0;
 8010048:	4b1d      	ldr	r3, [pc, #116]	@ (80100c0 <lcd_init+0x7c>)
  rccEnableSPI1(FALSE);
 801004a:	69a2      	ldr	r2, [r4, #24]
  dmaChannelSetPeripheral(LCD_DMA_TX, &LCD_SPI->DR); // DMA Peripheral Tx
 801004c:	491d      	ldr	r1, [pc, #116]	@ (80100c4 <lcd_init+0x80>)
 801004e:	481e      	ldr	r0, [pc, #120]	@ (80100c8 <lcd_init+0x84>)
  rccEnableSPI1(FALSE);
 8010050:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8010054:	61a2      	str	r2, [r4, #24]
  LCD_SPI->CR1 = 0;
 8010056:	2500      	movs	r5, #0
  LCD_SPI->CR1 = SPI_CR1_MSTR      // SPI is MASTER
 8010058:	f240 3207 	movw	r2, #775	@ 0x307
  LCD_SPI->CR1 = 0;
 801005c:	601d      	str	r5, [r3, #0]
  LCD_SPI->CR1 = SPI_CR1_MSTR      // SPI is MASTER
 801005e:	601a      	str	r2, [r3, #0]
  LCD_SPI->CR2 = SPI_CR2_8BIT      // SPI data size, set to 8 bit
 8010060:	f241 7203 	movw	r2, #5891	@ 0x1703
 8010064:	605a      	str	r2, [r3, #4]
  dmaChannelSetPeripheral(LCD_DMA_TX, &LCD_SPI->DR); // DMA Peripheral Tx
 8010066:	6388      	str	r0, [r1, #56]	@ 0x38
  dmaChannelSetPeripheral(LCD_DMA_RX, &LCD_SPI->DR); // DMA Peripheral Rx
 8010068:	6248      	str	r0, [r1, #36]	@ 0x24
  LCD_SPI->CR1|= SPI_CR1_SPE;       //SPI enable
 801006a:	681a      	ldr	r2, [r3, #0]
  LCD_RESET_ASSERT;
 801006c:	f04f 4490 	mov.w	r4, #1207959552	@ 0x48000000
 8010070:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
  LCD_SPI->CR1|= SPI_CR1_SPE;       //SPI enable
 8010074:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8010078:	601a      	str	r2, [r3, #0]
  chThdSleepMilliseconds(5);
 801007a:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  LCD_RESET_ASSERT;
 801007e:	61a1      	str	r1, [r4, #24]
  chThdSleepMilliseconds(5);
 8010080:	f7f0 ff06 	bl	8000e90 <chThdSleep>
  LCD_RESET_NEGATE;
 8010084:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  chThdSleepMilliseconds(5); // need time before LCD ready after reset
 8010088:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  LCD_RESET_NEGATE;
 801008c:	61a3      	str	r3, [r4, #24]
  chThdSleepMilliseconds(5); // need time before LCD ready after reset
 801008e:	f7f0 feff 	bl	8000e90 <chThdSleep>
  const uint8_t *p = get_lcd_init();
 8010092:	4c0e      	ldr	r4, [pc, #56]	@ (80100cc <lcd_init+0x88>)
  while (*p) {
 8010094:	2001      	movs	r0, #1
  chThdSleepMilliseconds(5); // need time before LCD ready after reset
 8010096:	4629      	mov	r1, r5
 8010098:	e000      	b.n	801009c <lcd_init+0x58>
    lcd_send_command(p[0], p[1], &p[2]);
 801009a:	7861      	ldrb	r1, [r4, #1]
 801009c:	1ca2      	adds	r2, r4, #2
 801009e:	f7ff fd17 	bl	800fad0 <lcd_send_command>
    p += 2 + p[1];
 80100a2:	7863      	ldrb	r3, [r4, #1]
 80100a4:	3302      	adds	r3, #2
 80100a6:	441c      	add	r4, r3
    chThdSleepMilliseconds(2);
 80100a8:	20c8      	movs	r0, #200	@ 0xc8
 80100aa:	f7f0 fef1 	bl	8000e90 <chThdSleep>
  while (*p) {
 80100ae:	7820      	ldrb	r0, [r4, #0]
 80100b0:	2800      	cmp	r0, #0
 80100b2:	d1f2      	bne.n	801009a <lcd_init+0x56>
}
 80100b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  lcd_clear_screen();
 80100b8:	f7ff bfbc 	b.w	8010034 <lcd_clear_screen>
 80100bc:	40021000 	.word	0x40021000
 80100c0:	40013000 	.word	0x40013000
 80100c4:	40020000 	.word	0x40020000
 80100c8:	4001300c 	.word	0x4001300c
 80100cc:	080199fc 	.word	0x080199fc

080100d0 <lcd_set_foreground>:
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 80100d0:	4b03      	ldr	r3, [pc, #12]	@ (80100e0 <lcd_set_foreground+0x10>)
 80100d2:	4a04      	ldr	r2, [pc, #16]	@ (80100e4 <lcd_set_foreground+0x14>)
 80100d4:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80100d8:	8bdb      	ldrh	r3, [r3, #30]
 80100da:	8013      	strh	r3, [r2, #0]
}
 80100dc:	4770      	bx	lr
 80100de:	bf00      	nop
 80100e0:	20000318 	.word	0x20000318
 80100e4:	200089f2 	.word	0x200089f2

080100e8 <lcd_set_background>:
  background_color = GET_PALTETTE_COLOR(bg_idx);
 80100e8:	4b03      	ldr	r3, [pc, #12]	@ (80100f8 <lcd_set_background+0x10>)
 80100ea:	4a04      	ldr	r2, [pc, #16]	@ (80100fc <lcd_set_background+0x14>)
 80100ec:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80100f0:	8bdb      	ldrh	r3, [r3, #30]
 80100f2:	8013      	strh	r3, [r2, #0]
}
 80100f4:	4770      	bx	lr
 80100f6:	bf00      	nop
 80100f8:	20000318 	.word	0x20000318
 80100fc:	200089f0 	.word	0x200089f0

08010100 <lcd_set_colors>:
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 8010100:	4b05      	ldr	r3, [pc, #20]	@ (8010118 <lcd_set_colors+0x18>)
  background_color = GET_PALTETTE_COLOR(bg_idx);
 8010102:	4a06      	ldr	r2, [pc, #24]	@ (801011c <lcd_set_colors+0x1c>)
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 8010104:	eb03 0040 	add.w	r0, r3, r0, lsl #1
  background_color = GET_PALTETTE_COLOR(bg_idx);
 8010108:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 801010c:	4904      	ldr	r1, [pc, #16]	@ (8010120 <lcd_set_colors+0x20>)
 801010e:	8bc0      	ldrh	r0, [r0, #30]
  background_color = GET_PALTETTE_COLOR(bg_idx);
 8010110:	8bdb      	ldrh	r3, [r3, #30]
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 8010112:	8008      	strh	r0, [r1, #0]
  background_color = GET_PALTETTE_COLOR(bg_idx);
 8010114:	8013      	strh	r3, [r2, #0]
}
 8010116:	4770      	bx	lr
 8010118:	20000318 	.word	0x20000318
 801011c:	200089f0 	.word	0x200089f0
 8010120:	200089f2 	.word	0x200089f2

08010124 <lcd_blitBitmap>:
void lcd_blitBitmap(uint16_t x, uint16_t y, uint16_t width, uint16_t height, const uint8_t *b) {
 8010124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010128:	9e09      	ldr	r6, [sp, #36]	@ 0x24
  for (uint32_t c = 0; c < height; c++) {
 801012a:	b35b      	cbz	r3, 8010184 <lcd_blitBitmap+0x60>
      *buf++ = (0x80 & bits) ? foreground_color : background_color;
 801012c:	4c17      	ldr	r4, [pc, #92]	@ (801018c <lcd_blitBitmap+0x68>)
 801012e:	8827      	ldrh	r7, [r4, #0]
 8010130:	4c17      	ldr	r4, [pc, #92]	@ (8010190 <lcd_blitBitmap+0x6c>)
 8010132:	f8b4 8000 	ldrh.w	r8, [r4]
    for (uint32_t r = 0; r < width; r++) {
 8010136:	b32a      	cbz	r2, 8010184 <lcd_blitBitmap+0x60>
 8010138:	f04f 0900 	mov.w	r9, #0
 801013c:	f8df a054 	ldr.w	sl, [pc, #84]	@ 8010194 <lcd_blitBitmap+0x70>
 8010140:	46cc      	mov	ip, r9
 8010142:	ea4f 0b42 	mov.w	fp, r2, lsl #1
 8010146:	4655      	mov	r5, sl
 8010148:	f04f 0e00 	mov.w	lr, #0
      if ((r&7) == 0) bits = *b++;
 801014c:	4634      	mov	r4, r6
 801014e:	f01e 0f07 	tst.w	lr, #7
 8010152:	bf08      	it	eq
 8010154:	f814 cb01 	ldrbeq.w	ip, [r4], #1
    for (uint32_t r = 0; r < width; r++) {
 8010158:	f10e 0e01 	add.w	lr, lr, #1
      if ((r&7) == 0) bits = *b++;
 801015c:	bf08      	it	eq
 801015e:	4626      	moveq	r6, r4
      *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8010160:	f01c 0f80 	tst.w	ip, #128	@ 0x80
 8010164:	bf14      	ite	ne
 8010166:	4644      	movne	r4, r8
 8010168:	463c      	moveq	r4, r7
      bits <<= 1;
 801016a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    for (uint32_t r = 0; r < width; r++) {
 801016e:	4596      	cmp	lr, r2
      *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8010170:	f825 4b02 	strh.w	r4, [r5], #2
      bits <<= 1;
 8010174:	fa5f fc8c 	uxtb.w	ip, ip
    for (uint32_t r = 0; r < width; r++) {
 8010178:	d1e8      	bne.n	801014c <lcd_blitBitmap+0x28>
  for (uint32_t c = 0; c < height; c++) {
 801017a:	f109 0901 	add.w	r9, r9, #1
 801017e:	454b      	cmp	r3, r9
 8010180:	44da      	add	sl, fp
 8010182:	d1e0      	bne.n	8010146 <lcd_blitBitmap+0x22>
}
 8010184:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  lcd_bulk(x, y, width, height);
 8010188:	f7ff bea6 	b.w	800fed8 <lcd_bulk>
 801018c:	200089f0 	.word	0x200089f0
 8010190:	200089f2 	.word	0x200089f2
 8010194:	200089f4 	.word	0x200089f4

08010198 <lcd_put>:
static msg_t lcd_put(void *ip, uint8_t ch) {
 8010198:	b530      	push	{r4, r5, lr}
  if (ps->state) {
 801019a:	8983      	ldrh	r3, [r0, #12]
static msg_t lcd_put(void *ip, uint8_t ch) {
 801019c:	b083      	sub	sp, #12
 801019e:	4604      	mov	r4, r0
  if (ps->state) {
 80101a0:	bb1b      	cbnz	r3, 80101ea <lcd_put+0x52>
  } else if (ch < 0x09) {
 80101a2:	2908      	cmp	r1, #8
 80101a4:	d803      	bhi.n	80101ae <lcd_put+0x16>
    ps->state = ch;
 80101a6:	8181      	strh	r1, [r0, #12]
}
 80101a8:	2000      	movs	r0, #0
 80101aa:	b003      	add	sp, #12
 80101ac:	bd30      	pop	{r4, r5, pc}
  if (ch == '\n') {ps->x = ps->start_x; ps->y+=FONT_STR_HEIGHT; return;}
 80101ae:	290a      	cmp	r1, #10
 80101b0:	8942      	ldrh	r2, [r0, #10]
 80101b2:	d023      	beq.n	80101fc <lcd_put+0x64>
  uint16_t w = FONT_GET_WIDTH(ch);
 80101b4:	f1a1 0316 	sub.w	r3, r1, #22
 80101b8:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 80101bc:	4817      	ldr	r0, [pc, #92]	@ (801021c <lcd_put+0x84>)
 80101be:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 80101c2:	4611      	mov	r1, r2
  uint16_t w = FONT_GET_WIDTH(ch);
 80101c4:	5cc5      	ldrb	r5, [r0, r3]
 80101c6:	f005 0507 	and.w	r5, r5, #7
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 80101ca:	4403      	add	r3, r0
  uint16_t w = FONT_GET_WIDTH(ch);
 80101cc:	f1c5 0508 	rsb	r5, r5, #8
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 80101d0:	9300      	str	r3, [sp, #0]
  uint16_t w = FONT_GET_WIDTH(ch);
 80101d2:	b2ad      	uxth	r5, r5
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 80101d4:	8920      	ldrh	r0, [r4, #8]
 80101d6:	462a      	mov	r2, r5
 80101d8:	230b      	movs	r3, #11
 80101da:	f7ff ffa3 	bl	8010124 <lcd_blitBitmap>
  ps->x+= w;
 80101de:	8923      	ldrh	r3, [r4, #8]
}
 80101e0:	2000      	movs	r0, #0
  ps->x+= w;
 80101e2:	441d      	add	r5, r3
 80101e4:	8125      	strh	r5, [r4, #8]
}
 80101e6:	b003      	add	sp, #12
 80101e8:	bd30      	pop	{r4, r5, pc}
         if (ps->state == R_BGCOLOR[0]) lcd_set_background(ch);
 80101ea:	2b01      	cmp	r3, #1
 80101ec:	d00d      	beq.n	801020a <lcd_put+0x72>
    else if (ps->state == R_FGCOLOR[0]) lcd_set_foreground(ch);
 80101ee:	2b02      	cmp	r3, #2
 80101f0:	d00f      	beq.n	8010212 <lcd_put+0x7a>
    ps->state = 0;
 80101f2:	2300      	movs	r3, #0
}
 80101f4:	2000      	movs	r0, #0
    ps->state = 0;
 80101f6:	81a3      	strh	r3, [r4, #12]
}
 80101f8:	b003      	add	sp, #12
 80101fa:	bd30      	pop	{r4, r5, pc}
  if (ch == '\n') {ps->x = ps->start_x; ps->y+=FONT_STR_HEIGHT; return;}
 80101fc:	8883      	ldrh	r3, [r0, #4]
 80101fe:	8103      	strh	r3, [r0, #8]
 8010200:	320b      	adds	r2, #11
 8010202:	8142      	strh	r2, [r0, #10]
}
 8010204:	2000      	movs	r0, #0
 8010206:	b003      	add	sp, #12
 8010208:	bd30      	pop	{r4, r5, pc}
         if (ps->state == R_BGCOLOR[0]) lcd_set_background(ch);
 801020a:	4608      	mov	r0, r1
 801020c:	f7ff ff6c 	bl	80100e8 <lcd_set_background>
 8010210:	e7ef      	b.n	80101f2 <lcd_put+0x5a>
    else if (ps->state == R_FGCOLOR[0]) lcd_set_foreground(ch);
 8010212:	4608      	mov	r0, r1
 8010214:	f7ff ff5c 	bl	80100d0 <lcd_set_foreground>
 8010218:	e7eb      	b.n	80101f2 <lcd_put+0x5a>
 801021a:	bf00      	nop
 801021c:	0801356c 	.word	0x0801356c

08010220 <lcd_printf>:
int lcd_printf(int16_t x, int16_t y, const char *fmt, ...) {
 8010220:	b40c      	push	{r2, r3}
 8010222:	b510      	push	{r4, lr}
 8010224:	b08a      	sub	sp, #40	@ 0x28
 8010226:	aa0c      	add	r2, sp, #48	@ 0x30
 8010228:	2300      	movs	r3, #0
 801022a:	f852 4b04 	ldr.w	r4, [r2], #4
  va_start(ap, fmt);
 801022e:	9201      	str	r2, [sp, #4]
 8010230:	f360 030f 	bfi	r3, r0, #0, #16
 8010234:	f361 431f 	bfi	r3, r1, #16, #16
  } lcd_vmt = {NULL, NULL, lcd_put, NULL};
 8010238:	2000      	movs	r0, #0
 801023a:	e9cd 0002 	strd	r0, r0, [sp, #8]
  lcdPrintStream ps = {&lcd_vmt, x, y, x, y, 0};
 801023e:	e9cd 3307 	strd	r3, r3, [sp, #28]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8010242:	4621      	mov	r1, r4
  } lcd_vmt = {NULL, NULL, lcd_put, NULL};
 8010244:	9005      	str	r0, [sp, #20]
  lcdPrintStream ps = {&lcd_vmt, x, y, x, y, 0};
 8010246:	f8ad 0024 	strh.w	r0, [sp, #36]	@ 0x24
 801024a:	ab02      	add	r3, sp, #8
  } lcd_vmt = {NULL, NULL, lcd_put, NULL};
 801024c:	4c05      	ldr	r4, [pc, #20]	@ (8010264 <lcd_printf+0x44>)
 801024e:	9404      	str	r4, [sp, #16]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8010250:	a806      	add	r0, sp, #24
  lcdPrintStream ps = {&lcd_vmt, x, y, x, y, 0};
 8010252:	9306      	str	r3, [sp, #24]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8010254:	f7f2 f98c 	bl	8002570 <chvprintf>
}
 8010258:	b00a      	add	sp, #40	@ 0x28
 801025a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801025e:	b002      	add	sp, #8
 8010260:	4770      	bx	lr
 8010262:	bf00      	nop
 8010264:	08010199 	.word	0x08010199

08010268 <lcd_blitBitmapScale>:
void lcd_blitBitmapScale(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t size, const uint8_t *b) {
 8010268:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801026c:	b085      	sub	sp, #20
 801026e:	461e      	mov	r6, r3
 8010270:	f8bd 4038 	ldrh.w	r4, [sp, #56]	@ 0x38
  lcd_setWindow(x, y, w * size, h * size, LCD_RAMWR);
 8010274:	232c      	movs	r3, #44	@ 0x2c
void lcd_blitBitmapScale(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t size, const uint8_t *b) {
 8010276:	4615      	mov	r5, r2
  lcd_setWindow(x, y, w * size, h * size, LCD_RAMWR);
 8010278:	9300      	str	r3, [sp, #0]
 801027a:	fb04 f202 	mul.w	r2, r4, r2
 801027e:	fb06 f304 	mul.w	r3, r6, r4
 8010282:	f7ff fd63 	bl	800fd4c <lcd_setWindow>
  for (int c = 0; c < h; c++) {
 8010286:	b126      	cbz	r6, 8010292 <lcd_blitBitmapScale+0x2a>
 8010288:	2200      	movs	r2, #0
    for (int i = 0; i < size; i++) {
 801028a:	b92c      	cbnz	r4, 8010298 <lcd_blitBitmapScale+0x30>
  for (int c = 0; c < h; c++) {
 801028c:	3201      	adds	r2, #1
 801028e:	4296      	cmp	r6, r2
 8010290:	d1fc      	bne.n	801028c <lcd_blitBitmapScale+0x24>
}
 8010292:	b005      	add	sp, #20
 8010294:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8010298:	4b22      	ldr	r3, [pc, #136]	@ (8010324 <lcd_blitBitmapScale+0xbc>)
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 801029a:	f8df e090 	ldr.w	lr, [pc, #144]	@ 801032c <lcd_blitBitmapScale+0xc4>
 801029e:	4f22      	ldr	r7, [pc, #136]	@ (8010328 <lcd_blitBitmapScale+0xc0>)
 80102a0:	4630      	mov	r0, r6
      for (int r = 0; r < w; r++, bits <<= 1) {
 80102a2:	2d00      	cmp	r5, #0
 80102a4:	d036      	beq.n	8010314 <lcd_blitBitmapScale+0xac>
 80102a6:	2100      	movs	r1, #0
 80102a8:	460e      	mov	r6, r1
 80102aa:	4692      	mov	sl, r2
      ptr = b;
 80102ac:	f8dd 903c 	ldr.w	r9, [sp, #60]	@ 0x3c
      for (int r = 0; r < w; r++, bits <<= 1) {
 80102b0:	46d3      	mov	fp, sl
 80102b2:	f04f 0800 	mov.w	r8, #0
 80102b6:	468a      	mov	sl, r1
        if ((r&7) == 0) bits = *ptr++;
 80102b8:	f018 0f07 	tst.w	r8, #7
 80102bc:	bf08      	it	eq
 80102be:	f819 6b01 	ldrbeq.w	r6, [r9], #1
        for (int j = 0; j < size; j++) {
 80102c2:	9003      	str	r0, [sp, #12]
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 80102c4:	b272      	sxtb	r2, r6
        for (int j = 0; j < size; j++) {
 80102c6:	f04f 0c00 	mov.w	ip, #0
          while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 80102ca:	6899      	ldr	r1, [r3, #8]
 80102cc:	0789      	lsls	r1, r1, #30
 80102ce:	d5fc      	bpl.n	80102ca <lcd_blitBitmapScale+0x62>
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 80102d0:	2a00      	cmp	r2, #0
 80102d2:	bfb4      	ite	lt
 80102d4:	8839      	ldrhlt	r1, [r7, #0]
 80102d6:	f8be 1000 	ldrhge.w	r1, [lr]
 80102da:	4608      	mov	r0, r1
        for (int j = 0; j < size; j++) {
 80102dc:	f10c 0101 	add.w	r1, ip, #1
 80102e0:	428c      	cmp	r4, r1
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 80102e2:	8198      	strh	r0, [r3, #12]
        for (int j = 0; j < size; j++) {
 80102e4:	d001      	beq.n	80102ea <lcd_blitBitmapScale+0x82>
 80102e6:	468c      	mov	ip, r1
 80102e8:	e7ef      	b.n	80102ca <lcd_blitBitmapScale+0x62>
      for (int r = 0; r < w; r++, bits <<= 1) {
 80102ea:	f108 0801 	add.w	r8, r8, #1
 80102ee:	0076      	lsls	r6, r6, #1
 80102f0:	4545      	cmp	r5, r8
 80102f2:	9803      	ldr	r0, [sp, #12]
 80102f4:	b2f6      	uxtb	r6, r6
 80102f6:	d1df      	bne.n	80102b8 <lcd_blitBitmapScale+0x50>
    for (int i = 0; i < size; i++) {
 80102f8:	4652      	mov	r2, sl
 80102fa:	4562      	cmp	r2, ip
 80102fc:	46da      	mov	sl, fp
 80102fe:	f102 0101 	add.w	r1, r2, #1
 8010302:	d1d3      	bne.n	80102ac <lcd_blitBitmapScale+0x44>
 8010304:	465a      	mov	r2, fp
  for (int c = 0; c < h; c++) {
 8010306:	3201      	adds	r2, #1
 8010308:	4290      	cmp	r0, r2
 801030a:	d0c2      	beq.n	8010292 <lcd_blitBitmapScale+0x2a>
 801030c:	f8cd 903c 	str.w	r9, [sp, #60]	@ 0x3c
      for (int r = 0; r < w; r++, bits <<= 1) {
 8010310:	2d00      	cmp	r5, #0
 8010312:	d1c8      	bne.n	80102a6 <lcd_blitBitmapScale+0x3e>
 8010314:	4606      	mov	r6, r0
  for (int c = 0; c < h; c++) {
 8010316:	3201      	adds	r2, #1
 8010318:	4296      	cmp	r6, r2
 801031a:	d1fc      	bne.n	8010316 <lcd_blitBitmapScale+0xae>
}
 801031c:	b005      	add	sp, #20
 801031e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010322:	bf00      	nop
 8010324:	40013000 	.word	0x40013000
 8010328:	200089f2 	.word	0x200089f2
 801032c:	200089f0 	.word	0x200089f0

08010330 <lcd_drawchar_size>:
  const uint8_t *char_buf = FONT_GET_DATA(ch);
 8010330:	3816      	subs	r0, #22
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 8010332:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const uint8_t *char_buf = FONT_GET_DATA(ch);
 8010336:	eb00 0480 	add.w	r4, r0, r0, lsl #2
 801033a:	eb00 0444 	add.w	r4, r0, r4, lsl #1
 801033e:	4e37      	ldr	r6, [pc, #220]	@ (801041c <lcd_drawchar_size+0xec>)
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 8010340:	468c      	mov	ip, r1
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8010342:	4937      	ldr	r1, [pc, #220]	@ (8010420 <lcd_drawchar_size+0xf0>)
  uint16_t w = FONT_GET_WIDTH(ch);
 8010344:	5d35      	ldrb	r5, [r6, r4]
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8010346:	880f      	ldrh	r7, [r1, #0]
 8010348:	4936      	ldr	r1, [pc, #216]	@ (8010424 <lcd_drawchar_size+0xf4>)
  uint16_t w = FONT_GET_WIDTH(ch);
 801034a:	f005 0507 	and.w	r5, r5, #7
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 801034e:	f8b1 8000 	ldrh.w	r8, [r1]
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 8010352:	4610      	mov	r0, r2
  uint16_t w = FONT_GET_WIDTH(ch);
 8010354:	f1c5 0508 	rsb	r5, r5, #8
  const uint8_t *char_buf = FONT_GET_DATA(ch);
 8010358:	19a2      	adds	r2, r4, r6
  uint16_t w = FONT_GET_WIDTH(ch);
 801035a:	1e59      	subs	r1, r3, #1
 801035c:	005e      	lsls	r6, r3, #1
 801035e:	b2ad      	uxth	r5, r5
  for (uint32_t c = 0; c < FONT_GET_HEIGHT; c++, char_buf++) {
 8010360:	fb06 f101 	mul.w	r1, r6, r1
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 8010364:	b089      	sub	sp, #36	@ 0x24
 8010366:	fb03 f405 	mul.w	r4, r3, r5
 801036a:	fb05 f101 	mul.w	r1, r5, r1
    for (uint32_t i = 0; i < size; i++) {
 801036e:	fb06 fa05 	mul.w	sl, r6, r5
 8010372:	2b00      	cmp	r3, #0
 8010374:	d042      	beq.n	80103fc <lcd_drawchar_size+0xcc>
 8010376:	3c01      	subs	r4, #1
 8010378:	0064      	lsls	r4, r4, #1
 801037a:	3102      	adds	r1, #2
 801037c:	eb01 0e04 	add.w	lr, r1, r4
 8010380:	e9cd c003 	strd	ip, r0, [sp, #12]
 8010384:	4c28      	ldr	r4, [pc, #160]	@ (8010428 <lcd_drawchar_size+0xf8>)
 8010386:	4671      	mov	r1, lr
 8010388:	f102 0b0b 	add.w	fp, r2, #11
 801038c:	46a6      	mov	lr, r4
 801038e:	460c      	mov	r4, r1
 8010390:	e9cd 2b06 	strd	r2, fp, [sp, #24]
      uint8_t bits = *char_buf;
 8010394:	f892 9000 	ldrb.w	r9, [r2]
    for (uint32_t i = 0; i < size; i++) {
 8010398:	f8cd e014 	str.w	lr, [sp, #20]
      uint8_t bits = *char_buf;
 801039c:	4670      	mov	r0, lr
    for (uint32_t i = 0; i < size; i++) {
 801039e:	2100      	movs	r1, #0
 80103a0:	f8cd 9008 	str.w	r9, [sp, #8]
 80103a4:	46a4      	mov	ip, r4
      uint8_t bits = *char_buf;
 80103a6:	f8dd e008 	ldr.w	lr, [sp, #8]
 80103aa:	9101      	str	r1, [sp, #4]
 80103ac:	4683      	mov	fp, r0
      for (uint32_t r = 0; r < w; r++, bits <<= 1)
 80103ae:	f04f 0900 	mov.w	r9, #0
        for (uint32_t j = 0; j < size; j++)
 80103b2:	f01e 0f80 	tst.w	lr, #128	@ 0x80
 80103b6:	bf14      	ite	ne
 80103b8:	4644      	movne	r4, r8
 80103ba:	463c      	moveq	r4, r7
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 80103bc:	4659      	mov	r1, fp
        for (uint32_t j = 0; j < size; j++)
 80103be:	2200      	movs	r2, #0
 80103c0:	3201      	adds	r2, #1
 80103c2:	429a      	cmp	r2, r3
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 80103c4:	f821 4b02 	strh.w	r4, [r1], #2
        for (uint32_t j = 0; j < size; j++)
 80103c8:	d1fa      	bne.n	80103c0 <lcd_drawchar_size+0x90>
      for (uint32_t r = 0; r < w; r++, bits <<= 1)
 80103ca:	f109 0901 	add.w	r9, r9, #1
 80103ce:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 80103d2:	454d      	cmp	r5, r9
 80103d4:	44b3      	add	fp, r6
 80103d6:	fa5f fe8e 	uxtb.w	lr, lr
 80103da:	d1ea      	bne.n	80103b2 <lcd_drawchar_size+0x82>
    for (uint32_t i = 0; i < size; i++) {
 80103dc:	9901      	ldr	r1, [sp, #4]
 80103de:	3101      	adds	r1, #1
 80103e0:	4299      	cmp	r1, r3
 80103e2:	4450      	add	r0, sl
 80103e4:	d1df      	bne.n	80103a6 <lcd_drawchar_size+0x76>
  for (uint32_t c = 0; c < FONT_GET_HEIGHT; c++, char_buf++) {
 80103e6:	e9dd e205 	ldrd	lr, r2, [sp, #20]
 80103ea:	f8dd b01c 	ldr.w	fp, [sp, #28]
 80103ee:	3201      	adds	r2, #1
 80103f0:	455a      	cmp	r2, fp
 80103f2:	4664      	mov	r4, ip
 80103f4:	44e6      	add	lr, ip
 80103f6:	d1cb      	bne.n	8010390 <lcd_drawchar_size+0x60>
 80103f8:	e9dd c003 	ldrd	ip, r0, [sp, #12]
  lcd_bulk(x, y, w * size, FONT_GET_HEIGHT * size);
 80103fc:	fb15 f503 	smulbb	r5, r5, r3
 8010400:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8010404:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8010408:	4601      	mov	r1, r0
 801040a:	462a      	mov	r2, r5
 801040c:	4660      	mov	r0, ip
 801040e:	f7ff fd63 	bl	800fed8 <lcd_bulk>
}
 8010412:	4628      	mov	r0, r5
 8010414:	b009      	add	sp, #36	@ 0x24
 8010416:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801041a:	bf00      	nop
 801041c:	0801356c 	.word	0x0801356c
 8010420:	200089f0 	.word	0x200089f0
 8010424:	200089f2 	.word	0x200089f2
 8010428:	200089f4 	.word	0x200089f4

0801042c <lcd_drawfont>:
void lcd_drawfont(uint8_t ch, int x, int y) {
 801042c:	b500      	push	{lr}
  lcd_blitBitmap(x, y, NUM_FONT_GET_WIDTH, NUM_FONT_GET_HEIGHT, NUM_FONT_GET_DATA(ch));
 801042e:	eb00 0c80 	add.w	ip, r0, r0, lsl #2
 8010432:	4b09      	ldr	r3, [pc, #36]	@ (8010458 <lcd_drawfont+0x2c>)
void lcd_drawfont(uint8_t ch, int x, int y) {
 8010434:	b083      	sub	sp, #12
  lcd_blitBitmap(x, y, NUM_FONT_GET_WIDTH, NUM_FONT_GET_HEIGHT, NUM_FONT_GET_DATA(ch));
 8010436:	eb00 004c 	add.w	r0, r0, ip, lsl #1
 801043a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
void lcd_drawfont(uint8_t ch, int x, int y) {
 801043e:	468c      	mov	ip, r1
 8010440:	4611      	mov	r1, r2
  lcd_blitBitmap(x, y, NUM_FONT_GET_WIDTH, NUM_FONT_GET_HEIGHT, NUM_FONT_GET_DATA(ch));
 8010442:	9300      	str	r3, [sp, #0]
 8010444:	2210      	movs	r2, #16
 8010446:	2316      	movs	r3, #22
 8010448:	b289      	uxth	r1, r1
 801044a:	fa1f f08c 	uxth.w	r0, ip
 801044e:	f7ff fe69 	bl	8010124 <lcd_blitBitmap>
}
 8010452:	b003      	add	sp, #12
 8010454:	f85d fb04 	ldr.w	pc, [sp], #4
 8010458:	08013178 	.word	0x08013178

0801045c <lcd_drawstring_size>:
void lcd_drawstring_size(const char *str, int x, int y, uint8_t size) {
 801045c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  while (*str)
 8010460:	7805      	ldrb	r5, [r0, #0]
 8010462:	b175      	cbz	r5, 8010482 <lcd_drawstring_size+0x26>
 8010464:	4606      	mov	r6, r0
 8010466:	460c      	mov	r4, r1
 8010468:	4690      	mov	r8, r2
 801046a:	461f      	mov	r7, r3
    x += lcd_drawchar_size(*str++, x, y, size);
 801046c:	4621      	mov	r1, r4
 801046e:	4628      	mov	r0, r5
 8010470:	463b      	mov	r3, r7
 8010472:	4642      	mov	r2, r8
 8010474:	f7ff ff5c 	bl	8010330 <lcd_drawchar_size>
  while (*str)
 8010478:	f816 5f01 	ldrb.w	r5, [r6, #1]!
    x += lcd_drawchar_size(*str++, x, y, size);
 801047c:	4404      	add	r4, r0
  while (*str)
 801047e:	2d00      	cmp	r5, #0
 8010480:	d1f4      	bne.n	801046c <lcd_drawstring_size+0x10>
}
 8010482:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010486:	bf00      	nop

08010488 <get_fattime>:
//       diskio.c functions for file system library
//*******************************************************
// If enable RTC - get RTC time
#if FF_FS_NORTC == 0
DWORD get_fattime (void) {
  return rtc_get_FAT();
 8010488:	f000 bc1a 	b.w	8010cc0 <rtc_get_FAT>

0801048c <disk_initialize>:
  r_cnt = 0;
  r_time = 0;
  crc_time = 0;
  total_time = chVTGetSystemTimeX();
#endif
  if (pdrv != 0) return disk_status(pdrv);
 801048c:	2800      	cmp	r0, #0
 801048e:	d147      	bne.n	8010520 <disk_initialize+0x94>
DSTATUS disk_initialize(BYTE pdrv) {
 8010490:	b570      	push	{r4, r5, r6, lr}
  // Start init SD card
  CardStatus = 0;
  LCD_CS_HIGH;
 8010492:	4b3d      	ldr	r3, [pc, #244]	@ (8010588 <disk_initialize+0xfc>)
  CardStatus = 0;
 8010494:	4e3d      	ldr	r6, [pc, #244]	@ (801058c <disk_initialize+0x100>)
  LCD_CS_HIGH;
 8010496:	2240      	movs	r2, #64	@ 0x40
DSTATUS disk_initialize(BYTE pdrv) {
 8010498:	b082      	sub	sp, #8
  LCD_CS_HIGH;
 801049a:	240a      	movs	r4, #10
  CardStatus = 0;
 801049c:	7030      	strb	r0, [r6, #0]
  LCD_CS_HIGH;
 801049e:	619a      	str	r2, [r3, #24]
  // Power on, try detect on bus, set card to idle state:
  //   Dummy TxRx 80 bits for power up SD
  for(int n = 0; n < 10; n++)
    spi_RxByte();
 80104a0:	f7ff fb34 	bl	800fb0c <spi_RxByte>
  for(int n = 0; n < 10; n++)
 80104a4:	3c01      	subs	r4, #1
 80104a6:	d1fb      	bne.n	80104a0 <disk_initialize+0x14>
  // check disk type
  uint8_t  type = 0;
  uint32_t cnt = 100;
  // Set low SPI bus speed = PLL/256 (on 72MHz =281.250kHz)
  SD_Select_SPI(SD_INIT_SPI_SPEED);
 80104a8:	2038      	movs	r0, #56	@ 0x38
 80104aa:	f7ff fadf 	bl	800fa6c <SD_Select_SPI>
  // send GO_IDLE_STATE command
  if (SD_SendCmd(CMD0, 0) == SD_R1_IDLE) {
 80104ae:	4621      	mov	r1, r4
 80104b0:	2040      	movs	r0, #64	@ 0x40
 80104b2:	f7ff fbdf 	bl	800fc74 <SD_SendCmd>
 80104b6:	2801      	cmp	r0, #1
 80104b8:	d004      	beq.n	80104c4 <disk_initialize+0x38>
      if (cnt && SD_SendCmd(CMD16, SD_SECTOR_SIZE) == 0)          // SET_BLOCKLEN and set type
        type = cmd == ACMD41 ? CT_SD1 : CT_MMC;
      DEBUG_PRINT(" CMD16 %d %d\r\n", cnt, type);
    }
  }
  SD_Unselect_SPI();
 80104ba:	f7ff fb31 	bl	800fb20 <SD_Unselect_SPI>
  DEBUG_PRINT("CardType %d\r\n", type);
  if (type)
 80104be:	2001      	movs	r0, #1
    CardStatus = CT_POWER_ON | type;
  return disk_status(pdrv);
}
 80104c0:	b002      	add	sp, #8
 80104c2:	bd70      	pop	{r4, r5, r6, pc}
    if (SD_SendCmd(CMD8, 0x00001AAU) == SD_R1_IDLE) {
 80104c4:	f44f 71d5 	mov.w	r1, #426	@ 0x1aa
 80104c8:	2048      	movs	r0, #72	@ 0x48
 80104ca:	f7ff fbd3 	bl	800fc74 <SD_SendCmd>
 80104ce:	2801      	cmp	r0, #1
 80104d0:	d028      	beq.n	8010524 <disk_initialize+0x98>
      uint8_t cmd = (SD_SendCmd(ACMD41, 0) <= 1) ? ACMD41 : CMD1; // cmd for idle state
 80104d2:	4621      	mov	r1, r4
 80104d4:	20e9      	movs	r0, #233	@ 0xe9
 80104d6:	f7ff fbcd 	bl	800fc74 <SD_SendCmd>
 80104da:	2801      	cmp	r0, #1
 80104dc:	bf8c      	ite	hi
 80104de:	2541      	movhi	r5, #65	@ 0x41
 80104e0:	25e9      	movls	r5, #233	@ 0xe9
  uint32_t cnt = 100;
 80104e2:	2464      	movs	r4, #100	@ 0x64
      while(SD_SendCmd(cmd, 0) && --cnt)                          // Wait idle state (depend from card type)
 80104e4:	e003      	b.n	80104ee <disk_initialize+0x62>
 80104e6:	3c01      	subs	r4, #1
 80104e8:	d046      	beq.n	8010578 <disk_initialize+0xec>
        chThdSleepMilliseconds(10);
 80104ea:	f7f0 fcd1 	bl	8000e90 <chThdSleep>
      while(SD_SendCmd(cmd, 0) && --cnt)                          // Wait idle state (depend from card type)
 80104ee:	2100      	movs	r1, #0
 80104f0:	4628      	mov	r0, r5
 80104f2:	f7ff fbbf 	bl	800fc74 <SD_SendCmd>
 80104f6:	4603      	mov	r3, r0
        chThdSleepMilliseconds(10);
 80104f8:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
      while(SD_SendCmd(cmd, 0) && --cnt)                          // Wait idle state (depend from card type)
 80104fc:	2b00      	cmp	r3, #0
 80104fe:	d1f2      	bne.n	80104e6 <disk_initialize+0x5a>
      if (cnt && SD_SendCmd(CMD16, SD_SECTOR_SIZE) == 0)          // SET_BLOCKLEN and set type
 8010500:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8010504:	2050      	movs	r0, #80	@ 0x50
 8010506:	f7ff fbb5 	bl	800fc74 <SD_SendCmd>
 801050a:	2800      	cmp	r0, #0
 801050c:	d134      	bne.n	8010578 <disk_initialize+0xec>
        type = cmd == ACMD41 ? CT_SD1 : CT_MMC;
 801050e:	2de9      	cmp	r5, #233	@ 0xe9
 8010510:	bf14      	ite	ne
 8010512:	2481      	movne	r4, #129	@ 0x81
 8010514:	2482      	moveq	r4, #130	@ 0x82
  SD_Unselect_SPI();
 8010516:	f7ff fb03 	bl	800fb20 <SD_Unselect_SPI>
    CardStatus = CT_POWER_ON | type;
 801051a:	7034      	strb	r4, [r6, #0]
 801051c:	2000      	movs	r0, #0
  return disk_status(pdrv);
 801051e:	e7cf      	b.n	80104c0 <disk_initialize+0x34>
  if (pdrv != 0) return disk_status(pdrv);
 8010520:	2001      	movs	r0, #1
}
 8010522:	4770      	bx	lr
      uint32_t ocr; spi_RxBuffer((uint8_t *)&ocr, 4);
 8010524:	2104      	movs	r1, #4
 8010526:	4668      	mov	r0, sp
 8010528:	f7ff fb0e 	bl	800fb48 <spi_RxBuffer>
      if (ocr == _OCR(0x00001AAU)) {
 801052c:	4b18      	ldr	r3, [pc, #96]	@ (8010590 <disk_initialize+0x104>)
 801052e:	9a00      	ldr	r2, [sp, #0]
 8010530:	429a      	cmp	r2, r3
 8010532:	d1c2      	bne.n	80104ba <disk_initialize+0x2e>
  uint32_t cnt = 100;
 8010534:	2464      	movs	r4, #100	@ 0x64
 8010536:	e003      	b.n	8010540 <disk_initialize+0xb4>
        while (SD_SendCmd(ACMD41, SD_OCR_CAPACITY) != 0 && --cnt)   // Check OCR
 8010538:	3c01      	subs	r4, #1
 801053a:	d01d      	beq.n	8010578 <disk_initialize+0xec>
          chThdSleepMilliseconds(10);
 801053c:	f7f0 fca8 	bl	8000e90 <chThdSleep>
        while (SD_SendCmd(ACMD41, SD_OCR_CAPACITY) != 0 && --cnt)   // Check OCR
 8010540:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8010544:	20e9      	movs	r0, #233	@ 0xe9
 8010546:	f7ff fb95 	bl	800fc74 <SD_SendCmd>
 801054a:	4601      	mov	r1, r0
          chThdSleepMilliseconds(10);
 801054c:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
        while (SD_SendCmd(ACMD41, SD_OCR_CAPACITY) != 0 && --cnt)   // Check OCR
 8010550:	2900      	cmp	r1, #0
 8010552:	d1f1      	bne.n	8010538 <disk_initialize+0xac>
        if (cnt && SD_SendCmd(CMD58, 0) == 0) {
 8010554:	207a      	movs	r0, #122	@ 0x7a
 8010556:	f7ff fb8d 	bl	800fc74 <SD_SendCmd>
 801055a:	b968      	cbnz	r0, 8010578 <disk_initialize+0xec>
          DWORD ocr; spi_RxBuffer((uint8_t *)&ocr, 4);
 801055c:	2104      	movs	r1, #4
 801055e:	eb0d 0001 	add.w	r0, sp, r1
 8010562:	f7ff faf1 	bl	800fb48 <spi_RxBuffer>
          type = (ocr & _OCR(SD_OCR_CAPACITY)) ? CT_SD2 | CT_BLOCK : CT_SD2;
 8010566:	9b01      	ldr	r3, [sp, #4]
 8010568:	f013 0f40 	tst.w	r3, #64	@ 0x40
 801056c:	bf0c      	ite	eq
 801056e:	2484      	moveq	r4, #132	@ 0x84
 8010570:	248c      	movne	r4, #140	@ 0x8c
  SD_Unselect_SPI();
 8010572:	f7ff fad5 	bl	800fb20 <SD_Unselect_SPI>
  if (type)
 8010576:	e7d0      	b.n	801051a <disk_initialize+0x8e>
  SD_Unselect_SPI();
 8010578:	f7ff fad2 	bl	800fb20 <SD_Unselect_SPI>

// diskio.c - Return disk status
DSTATUS disk_status(BYTE pdrv) {
  if (pdrv != 0) return STA_NOINIT;
  return CardStatus == 0 ? STA_NOINIT : 0;
 801057c:	7830      	ldrb	r0, [r6, #0]
 801057e:	fab0 f080 	clz	r0, r0
 8010582:	0940      	lsrs	r0, r0, #5
}
 8010584:	b002      	add	sp, #8
 8010586:	bd70      	pop	{r4, r5, r6, pc}
 8010588:	48000400 	.word	0x48000400
 801058c:	200089ee 	.word	0x200089ee
 8010590:	aa010000 	.word	0xaa010000

08010594 <disk_status>:
  if (pdrv != 0) return STA_NOINIT;
 8010594:	b928      	cbnz	r0, 80105a2 <disk_status+0xe>
  return CardStatus == 0 ? STA_NOINIT : 0;
 8010596:	4b04      	ldr	r3, [pc, #16]	@ (80105a8 <disk_status+0x14>)
 8010598:	7818      	ldrb	r0, [r3, #0]
 801059a:	fab0 f080 	clz	r0, r0
 801059e:	0940      	lsrs	r0, r0, #5
 80105a0:	4770      	bx	lr
  if (pdrv != 0) return STA_NOINIT;
 80105a2:	2001      	movs	r0, #1
}
 80105a4:	4770      	bx	lr
 80105a6:	bf00      	nop
 80105a8:	200089ee 	.word	0x200089ee

080105ac <disk_read>:

// diskio.c - Read sector
DRESULT disk_read(BYTE pdrv, BYTE* buff, DWORD sector, UINT count) {
 80105ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // No disk or wrong block count
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80105ae:	b9e0      	cbnz	r0, 80105ea <disk_read+0x3e>
 80105b0:	461c      	mov	r4, r3
 80105b2:	4b1e      	ldr	r3, [pc, #120]	@ (801062c <disk_read+0x80>)
 80105b4:	4615      	mov	r5, r2
 80105b6:	f993 2000 	ldrsb.w	r2, [r3]
 80105ba:	781f      	ldrb	r7, [r3, #0]
 80105bc:	2a00      	cmp	r2, #0
 80105be:	da14      	bge.n	80105ea <disk_read+0x3e>
#if DEBUG == 1
  r_cnt+= count;
  r_time-= chVTGetSystemTimeX();
#endif
  SD_Select_SPI(SD_SPI_RX_SPEED);
 80105c0:	460e      	mov	r6, r1
 80105c2:	f7ff fa53 	bl	800fa6c <SD_Select_SPI>
  // convert to byte address if no block mode
  if (!(CardStatus & CT_BLOCK)) sector*= SD_SECTOR_SIZE;
 80105c6:	073b      	lsls	r3, r7, #28
 80105c8:	bf58      	it	pl
 80105ca:	026d      	lslpl	r5, r5, #9
  if (count == 1) {                               // Read single block
 80105cc:	2c01      	cmp	r4, #1
    if (SD_SendCmd(CMD17, sector) == 0 && SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 80105ce:	4629      	mov	r1, r5
  if (count == 1) {                               // Read single block
 80105d0:	d01f      	beq.n	8010612 <disk_read+0x66>
      count--;
  } else if (SD_SendCmd(CMD18, sector) == 0) {    // Read multiple blocks
 80105d2:	2052      	movs	r0, #82	@ 0x52
 80105d4:	f7ff fb4e 	bl	800fc74 <SD_SendCmd>
 80105d8:	4605      	mov	r5, r0
 80105da:	b168      	cbz	r0, 80105f8 <disk_read+0x4c>
      DEBUG_PRINT("\r\n");
    }
  }
#endif
#endif
  return count ? RES_ERROR : RES_OK;
 80105dc:	1e25      	subs	r5, r4, #0
 80105de:	bf18      	it	ne
 80105e0:	2501      	movne	r5, #1
  SD_Unselect_SPI();
 80105e2:	f7ff fa9d 	bl	800fb20 <SD_Unselect_SPI>
}
 80105e6:	4628      	mov	r0, r5
 80105e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80105ea:	2503      	movs	r5, #3
}
 80105ec:	4628      	mov	r0, r5
 80105ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while(SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK) && --count)
 80105f0:	3c01      	subs	r4, #1
 80105f2:	d009      	beq.n	8010608 <disk_read+0x5c>
      buff+= SD_SECTOR_SIZE;
 80105f4:	f506 7600 	add.w	r6, r6, #512	@ 0x200
    while(SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK) && --count)
 80105f8:	4630      	mov	r0, r6
 80105fa:	f7ff fb09 	bl	800fc10 <SD_RxDataBlock.constprop.0>
 80105fe:	2800      	cmp	r0, #0
 8010600:	d1f6      	bne.n	80105f0 <disk_read+0x44>
  return count ? RES_ERROR : RES_OK;
 8010602:	1e25      	subs	r5, r4, #0
 8010604:	bf18      	it	ne
 8010606:	2501      	movne	r5, #1
    SD_SendCmd(CMD12, 0);                         // Finish multiple block read
 8010608:	2100      	movs	r1, #0
 801060a:	204c      	movs	r0, #76	@ 0x4c
 801060c:	f7ff fb32 	bl	800fc74 <SD_SendCmd>
 8010610:	e7e7      	b.n	80105e2 <disk_read+0x36>
    if (SD_SendCmd(CMD17, sector) == 0 && SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 8010612:	2051      	movs	r0, #81	@ 0x51
 8010614:	f7ff fb2e 	bl	800fc74 <SD_SendCmd>
 8010618:	b108      	cbz	r0, 801061e <disk_read+0x72>
 801061a:	4625      	mov	r5, r4
 801061c:	e7e1      	b.n	80105e2 <disk_read+0x36>
 801061e:	4630      	mov	r0, r6
 8010620:	f7ff faf6 	bl	800fc10 <SD_RxDataBlock.constprop.0>
 8010624:	f080 0501 	eor.w	r5, r0, #1
  return count ? RES_ERROR : RES_OK;
 8010628:	b2ed      	uxtb	r5, r5
 801062a:	e7da      	b.n	80105e2 <disk_read+0x36>
 801062c:	200089ee 	.word	0x200089ee

08010630 <disk_write>:

// diskio.c - Write sector
DRESULT disk_write(BYTE pdrv, const BYTE* buff, DWORD sector, UINT count) {
 8010630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // No disk or wrong block count
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 8010632:	2800      	cmp	r0, #0
 8010634:	d139      	bne.n	80106aa <disk_write+0x7a>
 8010636:	461c      	mov	r4, r3
 8010638:	4b24      	ldr	r3, [pc, #144]	@ (80106cc <disk_write+0x9c>)
 801063a:	4616      	mov	r6, r2
 801063c:	f993 2000 	ldrsb.w	r2, [r3]
 8010640:	781f      	ldrb	r7, [r3, #0]
 8010642:	2a00      	cmp	r2, #0
 8010644:	da31      	bge.n	80106aa <disk_write+0x7a>
  // Write protection
  if (CardStatus & CT_WRPROTECT) return RES_WRPRT;
 8010646:	067a      	lsls	r2, r7, #25
 8010648:	d42c      	bmi.n	80106a4 <disk_write+0x74>
    }
#endif
  w_cnt+=count;
  w_time-= chVTGetSystemTimeX();
#endif
  SD_Select_SPI(SD_SPI_SPEED);
 801064a:	460d      	mov	r5, r1
 801064c:	f7ff fa0e 	bl	800fa6c <SD_Select_SPI>
#if 1                                                 // Write multiple block mode
  // convert to byte address if no block mode
  if (!(CardStatus & CT_BLOCK)) sector*= SD_SECTOR_SIZE;
 8010650:	073b      	lsls	r3, r7, #28
 8010652:	bf58      	it	pl
 8010654:	0276      	lslpl	r6, r6, #9
  if (count == 1) {                                   // Write single block
 8010656:	2c01      	cmp	r4, #1
    if (SD_SendCmd(CMD24, sector) == 0 && SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 8010658:	4631      	mov	r1, r6
  if (count == 1) {                                   // Write single block
 801065a:	d029      	beq.n	80106b0 <disk_write+0x80>
      count--;
  } else if (SD_SendCmd(CMD25, sector) == 0) {        // Write multiple blocks, wait busy
 801065c:	2059      	movs	r0, #89	@ 0x59
 801065e:	f7ff fb09 	bl	800fc74 <SD_SendCmd>
 8010662:	4606      	mov	r6, r0
 8010664:	b170      	cbz	r0, 8010684 <disk_write+0x54>
  w_time+= chVTGetSystemTimeX();
  if (count)
    DEBUG_PRINT(" WRITE_BLOCK %d 0x%08x\r\n", count, sector);
#endif

  return count ? RES_ERROR : RES_OK;
 8010666:	1e26      	subs	r6, r4, #0
 8010668:	bf18      	it	ne
 801066a:	2601      	movne	r6, #1
  SD_Unselect_SPI();
 801066c:	f7ff fa58 	bl	800fb20 <SD_Unselect_SPI>
}
 8010670:	4630      	mov	r0, r6
 8010672:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while (SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_M_BLOCK) && SD_WaitNotBusy(MS2ST(250)) == 0xFF && --count)
 8010674:	f7ff fa8a 	bl	800fb8c <SD_WaitNotBusy>
 8010678:	28ff      	cmp	r0, #255	@ 0xff
 801067a:	d10c      	bne.n	8010696 <disk_write+0x66>
 801067c:	3c01      	subs	r4, #1
 801067e:	d00d      	beq.n	801069c <disk_write+0x6c>
      buff+= SD_SECTOR_SIZE;
 8010680:	f505 7500 	add.w	r5, r5, #512	@ 0x200
    while (SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_M_BLOCK) && SD_WaitNotBusy(MS2ST(250)) == 0xFF && --count)
 8010684:	21fc      	movs	r1, #252	@ 0xfc
 8010686:	4628      	mov	r0, r5
 8010688:	f7ff fa94 	bl	800fbb4 <SD_TxDataBlock.constprop.0>
 801068c:	4603      	mov	r3, r0
 801068e:	f246 10a8 	movw	r0, #25000	@ 0x61a8
 8010692:	2b00      	cmp	r3, #0
 8010694:	d1ee      	bne.n	8010674 <disk_write+0x44>
  return count ? RES_ERROR : RES_OK;
 8010696:	1e26      	subs	r6, r4, #0
 8010698:	bf18      	it	ne
 801069a:	2601      	movne	r6, #1
    spi_TxByte(SD_TOKEN_STOP_M_BLOCK);                // Finish multiple block write
 801069c:	20fd      	movs	r0, #253	@ 0xfd
 801069e:	f7ff f9fd 	bl	800fa9c <spi_TxByte>
 80106a2:	e7e3      	b.n	801066c <disk_write+0x3c>
  if (CardStatus & CT_WRPROTECT) return RES_WRPRT;
 80106a4:	2602      	movs	r6, #2
}
 80106a6:	4630      	mov	r0, r6
 80106a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80106aa:	2603      	movs	r6, #3
}
 80106ac:	4630      	mov	r0, r6
 80106ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (SD_SendCmd(CMD24, sector) == 0 && SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 80106b0:	2058      	movs	r0, #88	@ 0x58
 80106b2:	f7ff fadf 	bl	800fc74 <SD_SendCmd>
 80106b6:	b108      	cbz	r0, 80106bc <disk_write+0x8c>
 80106b8:	4626      	mov	r6, r4
 80106ba:	e7d7      	b.n	801066c <disk_write+0x3c>
 80106bc:	21fe      	movs	r1, #254	@ 0xfe
 80106be:	4628      	mov	r0, r5
 80106c0:	f7ff fa78 	bl	800fbb4 <SD_TxDataBlock.constprop.0>
 80106c4:	f080 0601 	eor.w	r6, r0, #1
  return count ? RES_ERROR : RES_OK;
 80106c8:	b2f6      	uxtb	r6, r6
 80106ca:	e7cf      	b.n	801066c <disk_write+0x3c>
 80106cc:	200089ee 	.word	0x200089ee

080106d0 <disk_ioctl>:

// The disk_ioctl function is called to control device specific features and miscellaneous functions other than generic read/write.
// Implement only five device independent commands used by FatFS module
DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void* buff) {
 80106d0:	b510      	push	{r4, lr}
  (void)buff;
  DRESULT res = RES_PARERR;
  // No disk or not ready
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80106d2:	b968      	cbnz	r0, 80106f0 <disk_ioctl+0x20>
 80106d4:	4b0d      	ldr	r3, [pc, #52]	@ (801070c <disk_ioctl+0x3c>)
 80106d6:	f993 3000 	ldrsb.w	r3, [r3]
 80106da:	2b00      	cmp	r3, #0
 80106dc:	da08      	bge.n	80106f0 <disk_ioctl+0x20>
  SD_Select_SPI(SD_SPI_RX_SPEED);
 80106de:	460c      	mov	r4, r1
 80106e0:	f7ff f9c4 	bl	800fa6c <SD_Select_SPI>
  switch (cmd){
 80106e4:	b13c      	cbz	r4, 80106f6 <disk_ioctl+0x26>
  DRESULT res = RES_PARERR;
 80106e6:	2404      	movs	r4, #4
      }
    }
    break;
#endif
  }
  SD_Unselect_SPI();
 80106e8:	f7ff fa1a 	bl	800fb20 <SD_Unselect_SPI>
  DEBUG_PRINT("disk_ioctl(%d) = %d,\r\n", cmd, res);
#if DEBUG == 1
  testLog();
#endif
  return res;
}
 80106ec:	4620      	mov	r0, r4
 80106ee:	bd10      	pop	{r4, pc}
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80106f0:	2403      	movs	r4, #3
}
 80106f2:	4620      	mov	r0, r4
 80106f4:	bd10      	pop	{r4, pc}
      if (SD_WaitNotBusy(MS2ST(200)) == 0xFF) res = RES_OK;
 80106f6:	f644 6020 	movw	r0, #20000	@ 0x4e20
 80106fa:	f7ff fa47 	bl	800fb8c <SD_WaitNotBusy>
 80106fe:	f1b0 04ff 	subs.w	r4, r0, #255	@ 0xff
 8010702:	bf18      	it	ne
 8010704:	2401      	movne	r4, #1
 8010706:	00a4      	lsls	r4, r4, #2
 8010708:	e7ee      	b.n	80106e8 <disk_ioctl+0x18>
 801070a:	bf00      	nop
 801070c:	200089ee 	.word	0x200089ee

08010710 <lcd_show_logo>:

#include "HB9IIUlogo.h"   // make sure this path is correct for your project

// Draw centered 1bpp logo (no arguments)
void lcd_show_logo(void)
{
 8010710:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010714:	4d1d      	ldr	r5, [pc, #116]	@ (801078c <lcd_show_logo+0x7c>)
 8010716:	4f1e      	ldr	r7, [pc, #120]	@ (8010790 <lcd_show_logo+0x80>)
 8010718:	b083      	sub	sp, #12
 801071a:	23ff      	movs	r3, #255	@ 0xff
  const pixel_t bg = RGB565(255,255,255); // white
  const pixel_t fg = RGB565(0,0,0);       // black

  const int bytes_per_row = (w + 7) >> 3;

  for (int y = 0; y < h; y++) {
 801071c:	f04f 0900 	mov.w	r9, #0
 8010720:	f1a5 043c 	sub.w	r4, r5, #60	@ 0x3c
 8010724:	f1c5 0800 	rsb	r8, r5, #0
 8010728:	463e      	mov	r6, r7

      for (int i = 0; i < chunk; i++) {
        int px = x + i;
        int byte_i = px >> 3;
        int bit_i  = 7 - (px & 7);        // MSB-first
        int on = (row[byte_i] >> bit_i) & 1;
 801072a:	11db      	asrs	r3, r3, #7
        spi_buffer[i] = on ? fg : bg;
 801072c:	3b01      	subs	r3, #1
 801072e:	4818      	ldr	r0, [pc, #96]	@ (8010790 <lcd_show_logo+0x80>)
 8010730:	803b      	strh	r3, [r7, #0]
 8010732:	eb08 0c05 	add.w	ip, r8, r5
      for (int i = 0; i < chunk; i++) {
 8010736:	4637      	mov	r7, r6
 8010738:	2201      	movs	r2, #1
        int on = (row[byte_i] >> bit_i) & 1;
 801073a:	eb0c 03e2 	add.w	r3, ip, r2, asr #3
        int bit_i  = 7 - (px & 7);        // MSB-first
 801073e:	43d1      	mvns	r1, r2
        int on = (row[byte_i] >> bit_i) & 1;
 8010740:	5ce3      	ldrb	r3, [r4, r3]
        int bit_i  = 7 - (px & 7);        // MSB-first
 8010742:	f001 0107 	and.w	r1, r1, #7
        int on = (row[byte_i] >> bit_i) & 1;
 8010746:	410b      	asrs	r3, r1
 8010748:	f003 0301 	and.w	r3, r3, #1
      for (int i = 0; i < chunk; i++) {
 801074c:	3201      	adds	r2, #1
        spi_buffer[i] = on ? fg : bg;
 801074e:	3b01      	subs	r3, #1
      for (int i = 0; i < chunk; i++) {
 8010750:	f5b2 7ff0 	cmp.w	r2, #480	@ 0x1e0
        spi_buffer[i] = on ? fg : bg;
 8010754:	f820 3f02 	strh.w	r3, [r0, #2]!
      for (int i = 0; i < chunk; i++) {
 8010758:	d1ef      	bne.n	801073a <lcd_show_logo+0x2a>
      }

      lcd_bulk_buffer(x0 + x, y0 + y, chunk, 1, spi_buffer);
 801075a:	2301      	movs	r3, #1
 801075c:	4649      	mov	r1, r9
 801075e:	9600      	str	r6, [sp, #0]
 8010760:	2000      	movs	r0, #0
  for (int y = 0; y < h; y++) {
 8010762:	f109 0901 	add.w	r9, r9, #1
      lcd_bulk_buffer(x0 + x, y0 + y, chunk, 1, spi_buffer);
 8010766:	f7ff fb19 	bl	800fd9c <lcd_bulk_buffer>
      lcd_bulk_finish();
 801076a:	f7ff fb99 	bl	800fea0 <lcd_bulk_finish>
  for (int y = 0; y < h; y++) {
 801076e:	f5b9 7fa0 	cmp.w	r9, #320	@ 0x140
 8010772:	f105 053c 	add.w	r5, r5, #60	@ 0x3c
 8010776:	d002      	beq.n	801077e <lcd_show_logo+0x6e>
        int on = (row[byte_i] >> bit_i) & 1;
 8010778:	f815 3c3c 	ldrb.w	r3, [r5, #-60]
 801077c:	e7d5      	b.n	801072a <lcd_show_logo+0x1a>
      x += chunk;
    }
  }
  chThdSleepMilliseconds(3000);
 801077e:	4805      	ldr	r0, [pc, #20]	@ (8010794 <lcd_show_logo+0x84>)
}
 8010780:	b003      	add	sp, #12
 8010782:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  chThdSleepMilliseconds(3000);
 8010786:	f7f0 bb83 	b.w	8000e90 <chThdSleep>
 801078a:	bf00      	nop
 801078c:	08014f38 	.word	0x08014f38
 8010790:	200089f4 	.word	0x200089f4
 8010794:	000493e0 	.word	0x000493e0

08010798 <config_save>:
  while (len-- > 0)
    value = __ROR(value, 31) + *p++;
  return value;
}

int config_save(void) {
 8010798:	b538      	push	{r3, r4, r5, lr}
  // Apply magic word and calculate checksum
  config.magic = CONFIG_MAGIC;
 801079a:	4d0a      	ldr	r5, [pc, #40]	@ (80107c4 <config_save+0x2c>)
 801079c:	4b0a      	ldr	r3, [pc, #40]	@ (80107c8 <config_save+0x30>)
 801079e:	602b      	str	r3, [r5, #0]
  uint32_t value = 0;
 80107a0:	2400      	movs	r4, #0
  uint32_t *p = (uint32_t*)start;
 80107a2:	462b      	mov	r3, r5
 80107a4:	f105 0170 	add.w	r1, r5, #112	@ 0x70
    value = __ROR(value, 31) + *p++;
 80107a8:	f853 2b04 	ldr.w	r2, [r3], #4
  while (len-- > 0)
 80107ac:	428b      	cmp	r3, r1
    value = __ROR(value, 31) + *p++;
 80107ae:	eb02 74f4 	add.w	r4, r2, r4, ror #31
  while (len-- > 0)
 80107b2:	d1f9      	bne.n	80107a8 <config_save+0x10>
  config.checksum = checksum(&config, sizeof config - sizeof config.checksum);

  // write to flash
  flash_program_half_word_buffer((uint16_t*)SAVE_CONFIG_ADDR, (uint16_t*)&config, sizeof(config_t));
 80107b4:	4903      	ldr	r1, [pc, #12]	@ (80107c4 <config_save+0x2c>)
 80107b6:	4805      	ldr	r0, [pc, #20]	@ (80107cc <config_save+0x34>)
  config.checksum = checksum(&config, sizeof config - sizeof config.checksum);
 80107b8:	672c      	str	r4, [r5, #112]	@ 0x70
  flash_program_half_word_buffer((uint16_t*)SAVE_CONFIG_ADDR, (uint16_t*)&config, sizeof(config_t));
 80107ba:	2274      	movs	r2, #116	@ 0x74
 80107bc:	f000 fbaa 	bl	8010f14 <flash_program_half_word_buffer>
  return 0;
}
 80107c0:	2000      	movs	r0, #0
 80107c2:	bd38      	pop	{r3, r4, r5, pc}
 80107c4:	20000318 	.word	0x20000318
 80107c8:	434f4e56 	.word	0x434f4e56
 80107cc:	0803f800 	.word	0x0803f800

080107d0 <config_recall>:

int config_recall(void) {
 80107d0:	b508      	push	{r3, lr}
  const config_t *src = (const config_t*)SAVE_CONFIG_ADDR;

  if (src->magic != CONFIG_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 80107d2:	4b0d      	ldr	r3, [pc, #52]	@ (8010808 <config_recall+0x38>)
 80107d4:	4a0d      	ldr	r2, [pc, #52]	@ (801080c <config_recall+0x3c>)
 80107d6:	6819      	ldr	r1, [r3, #0]
 80107d8:	4291      	cmp	r1, r2
 80107da:	d112      	bne.n	8010802 <config_recall+0x32>
  while (len-- > 0)
 80107dc:	480c      	ldr	r0, [pc, #48]	@ (8010810 <config_recall+0x40>)
  uint32_t value = 0;
 80107de:	2200      	movs	r2, #0
    \param [in]    value  Number of Bits to rotate
    \return               Rotated value
 */
__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  return (op1 >> op2) | (op1 << (32 - op2));
 80107e0:	4619      	mov	r1, r3
    value = __ROR(value, 31) + *p++;
 80107e2:	3304      	adds	r3, #4
 80107e4:	6809      	ldr	r1, [r1, #0]
  while (len-- > 0)
 80107e6:	4283      	cmp	r3, r0
    value = __ROR(value, 31) + *p++;
 80107e8:	eb01 72f2 	add.w	r2, r1, r2, ror #31
  while (len-- > 0)
 80107ec:	d1f8      	bne.n	80107e0 <config_recall+0x10>
  if (src->magic != CONFIG_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 80107ee:	4906      	ldr	r1, [pc, #24]	@ (8010808 <config_recall+0x38>)
 80107f0:	6f0b      	ldr	r3, [r1, #112]	@ 0x70
 80107f2:	4293      	cmp	r3, r2
 80107f4:	d105      	bne.n	8010802 <config_recall+0x32>
    return -1;
  // duplicated saved data onto sram to be able to modify marker/trace
  memcpy(&config, src, sizeof(config_t));
 80107f6:	2274      	movs	r2, #116	@ 0x74
 80107f8:	4806      	ldr	r0, [pc, #24]	@ (8010814 <config_recall+0x44>)
 80107fa:	f001 f833 	bl	8011864 <memcpy>
  return 0;
 80107fe:	2000      	movs	r0, #0
}
 8010800:	bd08      	pop	{r3, pc}
    return -1;
 8010802:	f04f 30ff 	mov.w	r0, #4294967295
}
 8010806:	bd08      	pop	{r3, pc}
 8010808:	0803f800 	.word	0x0803f800
 801080c:	434f4e56 	.word	0x434f4e56
 8010810:	0803f870 	.word	0x0803f870
 8010814:	20000318 	.word	0x20000318

08010818 <caldata_save>:

int caldata_save(uint32_t id) {
  if (id >= SAVEAREA_MAX)
 8010818:	2806      	cmp	r0, #6
 801081a:	d81d      	bhi.n	8010858 <caldata_save+0x40>
int caldata_save(uint32_t id) {
 801081c:	b538      	push	{r3, r4, r5, lr}
    return -1;

  // Apply magic word and calculate checksum
  current_props.magic = PROPERTIES_MAGIC;
 801081e:	4b10      	ldr	r3, [pc, #64]	@ (8010860 <caldata_save+0x48>)
 8010820:	4a10      	ldr	r2, [pc, #64]	@ (8010864 <caldata_save+0x4c>)
 8010822:	4c11      	ldr	r4, [pc, #68]	@ (8010868 <caldata_save+0x50>)
 8010824:	601a      	str	r2, [r3, #0]
 8010826:	4605      	mov	r5, r0
  uint32_t value = 0;
 8010828:	2200      	movs	r2, #0
    value = __ROR(value, 31) + *p++;
 801082a:	f853 1b04 	ldr.w	r1, [r3], #4
  while (len-- > 0)
 801082e:	42a3      	cmp	r3, r4
    value = __ROR(value, 31) + *p++;
 8010830:	eb01 72f2 	add.w	r2, r1, r2, ror #31
  while (len-- > 0)
 8010834:	d1f9      	bne.n	801082a <caldata_save+0x12>
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 8010836:	4b0d      	ldr	r3, [pc, #52]	@ (801086c <caldata_save+0x54>)
  current_props.checksum = checksum(&current_props, sizeof current_props - sizeof current_props.checksum);
 8010838:	490d      	ldr	r1, [pc, #52]	@ (8010870 <caldata_save+0x58>)
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 801083a:	b228      	sxth	r0, r5

  // write to flash
  uint16_t *dst = (uint16_t*)calibration_slot_area(id);
  flash_program_half_word_buffer(dst, (uint16_t*)&current_props, sizeof(properties_t));
 801083c:	eb03 3080 	add.w	r0, r3, r0, lsl #14
  current_props.checksum = checksum(&current_props, sizeof current_props - sizeof current_props.checksum);
 8010840:	f8c1 2f78 	str.w	r2, [r1, #3960]	@ 0xf78
  flash_program_half_word_buffer(dst, (uint16_t*)&current_props, sizeof(properties_t));
 8010844:	f5a1 5140 	sub.w	r1, r1, #12288	@ 0x3000
 8010848:	f643 727c 	movw	r2, #16252	@ 0x3f7c
 801084c:	f000 fb62 	bl	8010f14 <flash_program_half_word_buffer>

  lastsaveid = id;
 8010850:	4b08      	ldr	r3, [pc, #32]	@ (8010874 <caldata_save+0x5c>)
  return 0;
 8010852:	2000      	movs	r0, #0
  lastsaveid = id;
 8010854:	801d      	strh	r5, [r3, #0]
}
 8010856:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 8010858:	f04f 30ff 	mov.w	r0, #4294967295
}
 801085c:	4770      	bx	lr
 801085e:	bf00      	nop
 8010860:	20000aa8 	.word	0x20000aa8
 8010864:	434f4e54 	.word	0x434f4e54
 8010868:	20004a20 	.word	0x20004a20
 801086c:	08023800 	.word	0x08023800
 8010870:	20003aa8 	.word	0x20003aa8
 8010874:	200099f6 	.word	0x200099f6

08010878 <get_properties>:

const properties_t * get_properties(uint32_t id) {
  if (id >= SAVEAREA_MAX)
 8010878:	2806      	cmp	r0, #6
 801087a:	d82b      	bhi.n	80108d4 <get_properties+0x5c>
const properties_t * get_properties(uint32_t id) {
 801087c:	b530      	push	{r4, r5, lr}
    return NULL;
  // point to saved area on the flash memory
  properties_t *src = (properties_t*)calibration_slot_area(id);
  // Check crc cache mask (made it only 1 time)
  if (checksum_ok&(1<<id))
 801087e:	4d16      	ldr	r5, [pc, #88]	@ (80108d8 <get_properties+0x60>)
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 8010880:	4a16      	ldr	r2, [pc, #88]	@ (80108dc <get_properties+0x64>)
  if (checksum_ok&(1<<id))
 8010882:	f895 e000 	ldrb.w	lr, [r5]
 8010886:	4601      	mov	r1, r0
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 8010888:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 801088c:	fb11 2000 	smlabb	r0, r1, r0, r2
  if (checksum_ok&(1<<id))
 8010890:	fa4e f201 	asr.w	r2, lr, r1
 8010894:	f012 0201 	ands.w	r2, r2, #1
 8010898:	d119      	bne.n	80108ce <get_properties+0x56>
    return src;
  if (src->magic != PROPERTIES_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 801089a:	4b11      	ldr	r3, [pc, #68]	@ (80108e0 <get_properties+0x68>)
 801089c:	6804      	ldr	r4, [r0, #0]
 801089e:	429c      	cmp	r4, r3
 80108a0:	d116      	bne.n	80108d0 <get_properties+0x58>
 80108a2:	4b10      	ldr	r3, [pc, #64]	@ (80108e4 <get_properties+0x6c>)
 80108a4:	eb03 3c81 	add.w	ip, r3, r1, lsl #14
  uint32_t *p = (uint32_t*)start;
 80108a8:	4603      	mov	r3, r0
 80108aa:	461c      	mov	r4, r3
    value = __ROR(value, 31) + *p++;
 80108ac:	3304      	adds	r3, #4
 80108ae:	6824      	ldr	r4, [r4, #0]
  while (len-- > 0)
 80108b0:	459c      	cmp	ip, r3
    value = __ROR(value, 31) + *p++;
 80108b2:	eb04 72f2 	add.w	r2, r4, r2, ror #31
  while (len-- > 0)
 80108b6:	d1f8      	bne.n	80108aa <get_properties+0x32>
  if (src->magic != PROPERTIES_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 80108b8:	f500 5340 	add.w	r3, r0, #12288	@ 0x3000
 80108bc:	f8d3 3f78 	ldr.w	r3, [r3, #3960]	@ 0xf78
 80108c0:	4293      	cmp	r3, r2
 80108c2:	d105      	bne.n	80108d0 <get_properties+0x58>
    return NULL;
  checksum_ok|=1<<id;
 80108c4:	2301      	movs	r3, #1
 80108c6:	408b      	lsls	r3, r1
 80108c8:	ea4e 0303 	orr.w	r3, lr, r3
 80108cc:	702b      	strb	r3, [r5, #0]
  return src;
}
 80108ce:	bd30      	pop	{r4, r5, pc}
    return NULL;
 80108d0:	2000      	movs	r0, #0
}
 80108d2:	bd30      	pop	{r4, r5, pc}
    return NULL;
 80108d4:	2000      	movs	r0, #0
}
 80108d6:	4770      	bx	lr
 80108d8:	200099f4 	.word	0x200099f4
 80108dc:	08023800 	.word	0x08023800
 80108e0:	434f4e54 	.word	0x434f4e54
 80108e4:	08027778 	.word	0x08027778

080108e8 <caldata_recall>:

int caldata_recall(uint32_t id) {
 80108e8:	b538      	push	{r3, r4, r5, lr}
  lastsaveid = NO_SAVE_SLOT;
 80108ea:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80108ee:	4d09      	ldr	r5, [pc, #36]	@ (8010914 <caldata_recall+0x2c>)
  if (id == NO_SAVE_SLOT)
 80108f0:	4298      	cmp	r0, r3
  lastsaveid = NO_SAVE_SLOT;
 80108f2:	802b      	strh	r3, [r5, #0]
  if (id == NO_SAVE_SLOT)
 80108f4:	d00a      	beq.n	801090c <caldata_recall+0x24>
    return 0;
  // point to saved area on the flash memory
  const properties_t *src = get_properties(id);
 80108f6:	4604      	mov	r4, r0
 80108f8:	f7ff ffbe 	bl	8010878 <get_properties>
  if (src == NULL){
 80108fc:	4601      	mov	r1, r0
 80108fe:	b138      	cbz	r0, 8010910 <caldata_recall+0x28>
    return 1;
  }
  // active configuration points to save data on flash memory
  lastsaveid = id;
  // duplicated saved data onto sram to be able to modify marker/trace
  memcpy(&current_props, src, sizeof(properties_t));
 8010900:	4805      	ldr	r0, [pc, #20]	@ (8010918 <caldata_recall+0x30>)
  lastsaveid = id;
 8010902:	802c      	strh	r4, [r5, #0]
  memcpy(&current_props, src, sizeof(properties_t));
 8010904:	f643 727c 	movw	r2, #16252	@ 0x3f7c
 8010908:	f000 ffac 	bl	8011864 <memcpy>
    return 0;
 801090c:	2000      	movs	r0, #0
  return 0;
}
 801090e:	bd38      	pop	{r3, r4, r5, pc}
    return 1;
 8010910:	2001      	movs	r0, #1
}
 8010912:	bd38      	pop	{r3, r4, r5, pc}
 8010914:	200099f6 	.word	0x200099f6
 8010918:	20000aa8 	.word	0x20000aa8

0801091c <clear_all_config_prop_data>:

void clear_all_config_prop_data(void) {
  lastsaveid = NO_SAVE_SLOT;
  checksum_ok = 0;
 801091c:	4b07      	ldr	r3, [pc, #28]	@ (801093c <clear_all_config_prop_data+0x20>)
  // unlock and erase flash pages
  flash_erase_pages(SAVE_PROP_CONFIG_ADDR, SAVE_FULL_AREA_SIZE);
 801091e:	4808      	ldr	r0, [pc, #32]	@ (8010940 <clear_all_config_prop_data+0x24>)
void clear_all_config_prop_data(void) {
 8010920:	b410      	push	{r4}
  checksum_ok = 0;
 8010922:	2200      	movs	r2, #0
  lastsaveid = NO_SAVE_SLOT;
 8010924:	4c07      	ldr	r4, [pc, #28]	@ (8010944 <clear_all_config_prop_data+0x28>)
  checksum_ok = 0;
 8010926:	701a      	strb	r2, [r3, #0]
  lastsaveid = NO_SAVE_SLOT;
 8010928:	f64f 7cff 	movw	ip, #65535	@ 0xffff
 801092c:	f8a4 c000 	strh.w	ip, [r4]
  flash_erase_pages(SAVE_PROP_CONFIG_ADDR, SAVE_FULL_AREA_SIZE);
 8010930:	f44f 31e4 	mov.w	r1, #116736	@ 0x1c800
}
 8010934:	f85d 4b04 	ldr.w	r4, [sp], #4
  flash_erase_pages(SAVE_PROP_CONFIG_ADDR, SAVE_FULL_AREA_SIZE);
 8010938:	f000 bac2 	b.w	8010ec0 <flash_erase_pages>
 801093c:	200099f4 	.word	0x200099f4
 8010940:	08023800 	.word	0x08023800
 8010944:	200099f6 	.word	0x200099f6

08010948 <adcStartMeasure>:
//nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
//ADC3_4_COMMON->CCR = STM32_ADC_ADC34_CLOCK_MODE;
}

#define ADC_AVERAGE_N 4
static void adcStartMeasure(ADC_TypeDef *adc, uint32_t sqr0, uint16_t *samples) {
 8010948:	b570      	push	{r4, r5, r6, lr}
 801094a:	4603      	mov	r3, r0
 801094c:	4615      	mov	r5, r2
  // ADC setup
  adc->ISR   = adc->ISR;            // reset interrupts
 801094e:	6800      	ldr	r0, [r0, #0]
 8010950:	6018      	str	r0, [r3, #0]
  adc->IER   = 0;                   // disable interrupts
 8010952:	2200      	movs	r2, #0
//adc->SQR3  = sqr2;
//adc->SQR4  = sqr3;
  adc->CFGR = ADC_CFGR1_RES_12BIT;  // ADC configuration.
  // Starting conversion.
  uint16_t count = sqr0 & 0xF;
  for (uint16_t i = 0; i <= count; i++) samples[i] = 0;
 8010954:	f011 060f 	ands.w	r6, r1, #15
  adc->IER   = 0;                   // disable interrupts
 8010958:	605a      	str	r2, [r3, #4]
  adc->TR1   = ADC_TR(0, 0);        // reset threshold
 801095a:	eb05 0c46 	add.w	ip, r5, r6, lsl #1
 801095e:	621a      	str	r2, [r3, #32]
static void adcStartMeasure(ADC_TypeDef *adc, uint32_t sqr0, uint16_t *samples) {
 8010960:	f04f 0e10 	mov.w	lr, #16
  adc->SQR1  = sqr0;                // set measure sequence
 8010964:	6319      	str	r1, [r3, #48]	@ 0x30
  adc->CFGR = ADC_CFGR1_RES_12BIT;  // ADC configuration.
 8010966:	f1a5 0402 	sub.w	r4, r5, #2
 801096a:	60da      	str	r2, [r3, #12]
  for (uint16_t i = 0; i <= count; i++) samples[i] = 0;
 801096c:	802a      	strh	r2, [r5, #0]
 801096e:	bf18      	it	ne
 8010970:	806a      	strhne	r2, [r5, #2]
  int j = 1<<ADC_AVERAGE_N;
  do {
    adc->CR|= ADC_CR_ADSTART;
 8010972:	689a      	ldr	r2, [r3, #8]
 8010974:	f042 0204 	orr.w	r2, r2, #4
 8010978:	4621      	mov	r1, r4
 801097a:	609a      	str	r2, [r3, #8]
    for (uint16_t i = 0; i <= count; i++) {
 801097c:	e002      	b.n	8010984 <adcStartMeasure+0x3c>
      while((adc->ISR & ADC_ISR_EOC) == 0 && adc->CR & ADC_CR_ADSTART); // wait one sample ready
 801097e:	689a      	ldr	r2, [r3, #8]
 8010980:	0752      	lsls	r2, r2, #29
 8010982:	d502      	bpl.n	801098a <adcStartMeasure+0x42>
 8010984:	681a      	ldr	r2, [r3, #0]
 8010986:	0750      	lsls	r0, r2, #29
 8010988:	d5f9      	bpl.n	801097e <adcStartMeasure+0x36>
      samples[i]+= adc->DR;
 801098a:	f831 0f02 	ldrh.w	r0, [r1, #2]!
 801098e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    for (uint16_t i = 0; i <= count; i++) {
 8010990:	4561      	cmp	r1, ip
      samples[i]+= adc->DR;
 8010992:	4402      	add	r2, r0
 8010994:	800a      	strh	r2, [r1, #0]
    for (uint16_t i = 0; i <= count; i++) {
 8010996:	d1f5      	bne.n	8010984 <adcStartMeasure+0x3c>
    }
  } while (--j);
 8010998:	f1be 0e01 	subs.w	lr, lr, #1
 801099c:	d1e9      	bne.n	8010972 <adcStartMeasure+0x2a>
  for (uint16_t i = 0; i <= count; i++) samples[i]>>= ADC_AVERAGE_N;
 801099e:	882b      	ldrh	r3, [r5, #0]
 80109a0:	091b      	lsrs	r3, r3, #4
 80109a2:	802b      	strh	r3, [r5, #0]
 80109a4:	b116      	cbz	r6, 80109ac <adcStartMeasure+0x64>
 80109a6:	886b      	ldrh	r3, [r5, #2]
 80109a8:	091b      	lsrs	r3, r3, #4
 80109aa:	806b      	strh	r3, [r5, #2]
}
 80109ac:	bd70      	pop	{r4, r5, r6, pc}
 80109ae:	bf00      	nop

080109b0 <rtc_enter_init>:
  RTC->ISR &= ~RTC_ISR_INIT;
}

// Beginning of configuration procedure.
static bool rtc_enter_init(void){
  RTC->ISR |= RTC_ISR_INIT;
 80109b0:	4a07      	ldr	r2, [pc, #28]	@ (80109d0 <rtc_enter_init+0x20>)
 80109b2:	4808      	ldr	r0, [pc, #32]	@ (80109d4 <rtc_enter_init+0x24>)
 80109b4:	68d3      	ldr	r3, [r2, #12]
 80109b6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80109ba:	60d3      	str	r3, [r2, #12]
  uint32_t count = 4*65536;
  while (--count)
 80109bc:	e001      	b.n	80109c2 <rtc_enter_init+0x12>
 80109be:	3801      	subs	r0, #1
 80109c0:	d004      	beq.n	80109cc <rtc_enter_init+0x1c>
    if (RTC->ISR & RTC_ISR_INITF)
 80109c2:	68d3      	ldr	r3, [r2, #12]
 80109c4:	065b      	lsls	r3, r3, #25
 80109c6:	d5fa      	bpl.n	80109be <rtc_enter_init+0xe>
      return true;
 80109c8:	2001      	movs	r0, #1
  return false;
}
 80109ca:	4770      	bx	lr
 80109cc:	4770      	bx	lr
 80109ce:	bf00      	nop
 80109d0:	40002800 	.word	0x40002800
 80109d4:	0003ffff 	.word	0x0003ffff

080109d8 <rtc_start_source>:
#else
#define STM32_LSE_BYPASS     0
#endif

// Startup LSE or if not work, LSI generator
static void rtc_start_source(void){
 80109d8:	b510      	push	{r4, lr}
  // LSE already work (enabled and ready)
  if ((RCC->BDCR & (RCC_BDCR_LSEON|RCC_BDCR_LSERDY|STM32_LSE_BYPASS)) == (RCC_BDCR_LSEON|RCC_BDCR_LSERDY|STM32_LSE_BYPASS))
 80109da:	4c0c      	ldr	r4, [pc, #48]	@ (8010a0c <rtc_start_source+0x34>)
 80109dc:	6a23      	ldr	r3, [r4, #32]
 80109de:	f003 0303 	and.w	r3, r3, #3
 80109e2:	2b03      	cmp	r3, #3
 80109e4:	d011      	beq.n	8010a0a <rtc_start_source+0x32>
    return;

  // If LSE not enabled, try startup
  RCC->BDCR |= STM32_LSEDRV | STM32_LSE_BYPASS | RCC_BDCR_LSEON;
 80109e6:	6a23      	ldr	r3, [r4, #32]
 80109e8:	f043 0319 	orr.w	r3, r3, #25
 80109ec:	6223      	str	r3, [r4, #32]
  // Waits until LSE is stable (need ~150ms for startup).
  chThdSleepMilliseconds(200);
 80109ee:	f644 6020 	movw	r0, #20000	@ 0x4e20
 80109f2:	f7f0 fa4d 	bl	8000e90 <chThdSleep>
  if (RCC->BDCR & RCC_BDCR_LSERDY) return;
 80109f6:	6a23      	ldr	r3, [r4, #32]
 80109f8:	079a      	lsls	r2, r3, #30
 80109fa:	d406      	bmi.n	8010a0a <rtc_start_source+0x32>

  // Startup LSI if not allow start LSE
  RCC->CSR |= RCC_CSR_LSION;
 80109fc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80109fe:	f043 0301 	orr.w	r3, r3, #1
 8010a02:	6263      	str	r3, [r4, #36]	@ 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0);
 8010a04:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8010a06:	079b      	lsls	r3, r3, #30
 8010a08:	d5fc      	bpl.n	8010a04 <rtc_start_source+0x2c>
}
 8010a0a:	bd10      	pop	{r4, pc}
 8010a0c:	40021000 	.word	0x40021000

08010a10 <adc_init>:
  rccEnableADC12(FALSE);
 8010a10:	4921      	ldr	r1, [pc, #132]	@ (8010a98 <adc_init+0x88>)
 8010a12:	694b      	ldr	r3, [r1, #20]
  adc->CR = 0;                            // Master ADC calibration.
 8010a14:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
 8010a18:	b510      	push	{r4, lr}
  rccEnableADC12(FALSE);
 8010a1a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
  adc->CR = 0;                            // Master ADC calibration.
 8010a1e:	2400      	movs	r4, #0
  adc->CR = ADC_CR_ADVREGEN_0;
 8010a20:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
  rccEnableADC12(FALSE);
 8010a24:	614b      	str	r3, [r1, #20]
  adc->CR = 0;                            // Master ADC calibration.
 8010a26:	6094      	str	r4, [r2, #8]
  adc->CR = ADC_CR_ADVREGEN_0;
 8010a28:	6090      	str	r0, [r2, #8]
  adc->CR|= ADC_CR_ADCAL;
 8010a2a:	6893      	ldr	r3, [r2, #8]
 8010a2c:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8010a30:	6093      	str	r3, [r2, #8]
  while (adc->CR & ADC_CR_ADCAL);
 8010a32:	6893      	ldr	r3, [r2, #8]
 8010a34:	2b00      	cmp	r3, #0
 8010a36:	dbfc      	blt.n	8010a32 <adc_init+0x22>
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 8010a38:	6893      	ldr	r3, [r2, #8]
 8010a3a:	f043 0301 	orr.w	r3, r3, #1
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 8010a3e:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 8010a42:	6093      	str	r3, [r2, #8]
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 8010a44:	680b      	ldr	r3, [r1, #0]
 8010a46:	07da      	lsls	r2, r3, #31
 8010a48:	d5fc      	bpl.n	8010a44 <adc_init+0x34>
  adc->CR = 0;                            // Master ADC calibration.
 8010a4a:	4a14      	ldr	r2, [pc, #80]	@ (8010a9c <adc_init+0x8c>)
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8010a4c:	4b14      	ldr	r3, [pc, #80]	@ (8010aa0 <adc_init+0x90>)
  adc->SMPR1 = ADC_SMPR1_SMP_AN3(ADC_TOUCH_SMP_TIME) | ADC_SMPR1_SMP_AN4(ADC_TOUCH_SMP_TIME);
 8010a4e:	f44f 44fc 	mov.w	r4, #32256	@ 0x7e00
 8010a52:	614c      	str	r4, [r1, #20]
  adc->CR = 0;                            // Master ADC calibration.
 8010a54:	2000      	movs	r0, #0
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8010a56:	618b      	str	r3, [r1, #24]
  adc->CR = ADC_CR_ADVREGEN_0;
 8010a58:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
  adc->CR = 0;                            // Master ADC calibration.
 8010a5c:	6090      	str	r0, [r2, #8]
  adc->CR = ADC_CR_ADVREGEN_0;
 8010a5e:	6093      	str	r3, [r2, #8]
  adc->CR|= ADC_CR_ADCAL;
 8010a60:	6893      	ldr	r3, [r2, #8]
 8010a62:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8010a66:	6093      	str	r3, [r2, #8]
  while (adc->CR & ADC_CR_ADCAL);
 8010a68:	6893      	ldr	r3, [r2, #8]
 8010a6a:	2b00      	cmp	r3, #0
 8010a6c:	dbfc      	blt.n	8010a68 <adc_init+0x58>
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 8010a6e:	6893      	ldr	r3, [r2, #8]
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 8010a70:	480a      	ldr	r0, [pc, #40]	@ (8010a9c <adc_init+0x8c>)
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 8010a72:	f043 0301 	orr.w	r3, r3, #1
 8010a76:	6093      	str	r3, [r2, #8]
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 8010a78:	6803      	ldr	r3, [r0, #0]
 8010a7a:	07db      	lsls	r3, r3, #31
 8010a7c:	d5fc      	bpl.n	8010a78 <adc_init+0x68>
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8010a7e:	4b08      	ldr	r3, [pc, #32]	@ (8010aa0 <adc_init+0x90>)
  adc->SMPR1 = ADC_SMPR1_SMP_AN3(ADC_TOUCH_SMP_TIME) | ADC_SMPR1_SMP_AN4(ADC_TOUCH_SMP_TIME);
 8010a80:	f44f 42fc 	mov.w	r2, #32256	@ 0x7e00
 8010a84:	6142      	str	r2, [r0, #20]
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY); // ADC 1 and 2 interrupt
 8010a86:	2102      	movs	r1, #2
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8010a88:	6183      	str	r3, [r0, #24]
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY); // ADC 1 and 2 interrupt
 8010a8a:	2012      	movs	r0, #18
 8010a8c:	f7f1 f934 	bl	8001cf8 <nvicEnableVector>
  ADC1_2_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_CCR_VBAT_ENABLE | ADC_CCR_VREF_ENABLE;
 8010a90:	4b04      	ldr	r3, [pc, #16]	@ (8010aa4 <adc_init+0x94>)
 8010a92:	4a05      	ldr	r2, [pc, #20]	@ (8010aa8 <adc_init+0x98>)
 8010a94:	609a      	str	r2, [r3, #8]
}
 8010a96:	bd10      	pop	{r4, pc}
 8010a98:	40021000 	.word	0x40021000
 8010a9c:	50000100 	.word	0x50000100
 8010aa0:	07fc0000 	.word	0x07fc0000
 8010aa4:	50000300 	.word	0x50000300
 8010aa8:	01410000 	.word	0x01410000

08010aac <adc_single_read>:

uint16_t adc_single_read(uint32_t chsel)
{
 8010aac:	b500      	push	{lr}
 8010aae:	4601      	mov	r1, r0
 8010ab0:	b083      	sub	sp, #12
  uint16_t samples[1];
  adcStartMeasure(TOUCH_ADC, ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(chsel), samples);
 8010ab2:	4805      	ldr	r0, [pc, #20]	@ (8010ac8 <adc_single_read+0x1c>)
 8010ab4:	aa01      	add	r2, sp, #4
 8010ab6:	0189      	lsls	r1, r1, #6
 8010ab8:	f7ff ff46 	bl	8010948 <adcStartMeasure>
  return samples[0];
}
 8010abc:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8010ac0:	b003      	add	sp, #12
 8010ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ac6:	bf00      	nop
 8010ac8:	50000100 	.word	0x50000100

08010acc <adc_vbat_read>:
{
  static int16_t   vbat_raw = 0;
#ifdef VBAT_MEASURE_INTERVAL
  static systime_t vbat_time = -VBAT_MEASURE_INTERVAL-1;
  systime_t _time = chVTGetSystemTimeX();
  if (_time - vbat_time < VBAT_MEASURE_INTERVAL)
 8010acc:	4a20      	ldr	r2, [pc, #128]	@ (8010b50 <adc_vbat_read+0x84>)
 8010ace:	4821      	ldr	r0, [pc, #132]	@ (8010b54 <adc_vbat_read+0x88>)
 8010ad0:	6813      	ldr	r3, [r2, #0]
 8010ad2:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8010ad6:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8010ad8:	1acb      	subs	r3, r1, r3
 8010ada:	4283      	cmp	r3, r0
 8010adc:	d80a      	bhi.n	8010af4 <adc_vbat_read+0x28>
  // vbat_raw = (3300 * 2 * vbat / 4095) * (VREFINT_CAL / vrefint)
  // uint16_t vbat_raw = (VREFINT * VREFINT_CAL * (float)vbat * 2 / (vrefint * ((1<<12)-1)));
  // For speed divide not on 4095, divide on 4096, get little error, but no matter
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
return_cached:
  if (vbat_raw < 100) {
 8010ade:	4b1e      	ldr	r3, [pc, #120]	@ (8010b58 <adc_vbat_read+0x8c>)
 8010ae0:	f9b3 0000 	ldrsh.w	r0, [r3]
 8010ae4:	2863      	cmp	r0, #99	@ 0x63
 8010ae6:	dd2a      	ble.n	8010b3e <adc_vbat_read+0x72>
    // maybe D2 is not installed
    return -1;
  }
  return vbat_raw + config._vbat_offset;
 8010ae8:	4b1c      	ldr	r3, [pc, #112]	@ (8010b5c <adc_vbat_read+0x90>)
 8010aea:	8b1b      	ldrh	r3, [r3, #24]
 8010aec:	4418      	add	r0, r3
 8010aee:	b280      	uxth	r0, r0
}
 8010af0:	b200      	sxth	r0, r0
 8010af2:	4770      	bx	lr
{
 8010af4:	b510      	push	{r4, lr}
  const uint16_t VREFINT_CAL = (*((uint16_t*)0x1FFFF7BA));
 8010af6:	4b1a      	ldr	r3, [pc, #104]	@ (8010b60 <adc_vbat_read+0x94>)
{
 8010af8:	b082      	sub	sp, #8
  adcStartMeasure(BAT_ADC, ADC_SQR1_NUM_CH(N_CH_VBAT) | ADC_SQR1_SQ1_N(17) | ADC_SQR1_SQ2_N(18)/*| ADC_SQR1_SQ3_N(16)*/, samplesVBAT);
 8010afa:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  vbat_time = _time;
 8010afe:	6011      	str	r1, [r2, #0]
  adcStartMeasure(BAT_ADC, ADC_SQR1_NUM_CH(N_CH_VBAT) | ADC_SQR1_SQ1_N(17) | ADC_SQR1_SQ2_N(18)/*| ADC_SQR1_SQ3_N(16)*/, samplesVBAT);
 8010b00:	4918      	ldr	r1, [pc, #96]	@ (8010b64 <adc_vbat_read+0x98>)
  const uint16_t VREFINT_CAL = (*((uint16_t*)0x1FFFF7BA));
 8010b02:	f8b3 40ba 	ldrh.w	r4, [r3, #186]	@ 0xba
  adcStartMeasure(BAT_ADC, ADC_SQR1_NUM_CH(N_CH_VBAT) | ADC_SQR1_SQ1_N(17) | ADC_SQR1_SQ2_N(18)/*| ADC_SQR1_SQ3_N(16)*/, samplesVBAT);
 8010b06:	aa01      	add	r2, sp, #4
 8010b08:	f7ff ff1e 	bl	8010948 <adcStartMeasure>
  uint32_t vbat    = samplesVBAT[0];
 8010b0c:	f8bd 0004 	ldrh.w	r0, [sp, #4]
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
 8010b10:	4b11      	ldr	r3, [pc, #68]	@ (8010b58 <adc_vbat_read+0x8c>)
  uint32_t vrefint = samplesVBAT[1];
 8010b12:	f8bd 2006 	ldrh.w	r2, [sp, #6]
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
 8010b16:	f641 11c8 	movw	r1, #6600	@ 0x19c8
 8010b1a:	fb01 f000 	mul.w	r0, r1, r0
 8010b1e:	0b00      	lsrs	r0, r0, #12
 8010b20:	fb04 f000 	mul.w	r0, r4, r0
 8010b24:	fbb0 f0f2 	udiv	r0, r0, r2
 8010b28:	b200      	sxth	r0, r0
  if (vbat_raw < 100) {
 8010b2a:	2863      	cmp	r0, #99	@ 0x63
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
 8010b2c:	8018      	strh	r0, [r3, #0]
  if (vbat_raw < 100) {
 8010b2e:	dd0a      	ble.n	8010b46 <adc_vbat_read+0x7a>
  return vbat_raw + config._vbat_offset;
 8010b30:	4b0a      	ldr	r3, [pc, #40]	@ (8010b5c <adc_vbat_read+0x90>)
 8010b32:	8b1b      	ldrh	r3, [r3, #24]
 8010b34:	4418      	add	r0, r3
 8010b36:	b280      	uxth	r0, r0
}
 8010b38:	b200      	sxth	r0, r0
 8010b3a:	b002      	add	sp, #8
 8010b3c:	bd10      	pop	{r4, pc}
 8010b3e:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 8010b42:	b200      	sxth	r0, r0
 8010b44:	4770      	bx	lr
 8010b46:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 8010b4a:	b200      	sxth	r0, r0
 8010b4c:	b002      	add	sp, #8
 8010b4e:	bd10      	pop	{r4, pc}
 8010b50:	200003f4 	.word	0x200003f4
 8010b54:	0007a11f 	.word	0x0007a11f
 8010b58:	200099f8 	.word	0x200099f8
 8010b5c:	20000318 	.word	0x20000318
 8010b60:	1ffff700 	.word	0x1ffff700
 8010b64:	00012441 	.word	0x00012441

08010b68 <adc_start_analog_watchdog>:

void adc_start_analog_watchdog(void)
{
  ADC_TypeDef *adc = TOUCH_ADC;                                 // ADC setup
  adc->ISR  = adc->ISR;                                         // reset interrupts
 8010b68:	4b0a      	ldr	r3, [pc, #40]	@ (8010b94 <adc_start_analog_watchdog+0x2c>)
  adc->IER = /*ADC_ISR_OVR |*/ ADC_IER_AWD1;                    // enable watchdog interrupt (ignore overflow)
  adc->TR1  = ADC_TR(0, TOUCH_THRESHOLD);                       // Threshold
  adc->SQR1 = ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(ADC_TOUCH_Y); // Set channel, and count
  adc->CFGR = ADC_CFGR1_RES_12BIT                               // 12 bit mode
 8010b6a:	4a0b      	ldr	r2, [pc, #44]	@ (8010b98 <adc_start_analog_watchdog+0x30>)
{
 8010b6c:	b410      	push	{r4}
  adc->IER = /*ADC_ISR_OVR |*/ ADC_IER_AWD1;                    // enable watchdog interrupt (ignore overflow)
 8010b6e:	2180      	movs	r1, #128	@ 0x80
  adc->ISR  = adc->ISR;                                         // reset interrupts
 8010b70:	681c      	ldr	r4, [r3, #0]
 8010b72:	601c      	str	r4, [r3, #0]
  adc->TR1  = ADC_TR(0, TOUCH_THRESHOLD);                       // Threshold
 8010b74:	f04f 60fa 	mov.w	r0, #131072000	@ 0x7d00000
  adc->IER = /*ADC_ISR_OVR |*/ ADC_IER_AWD1;                    // enable watchdog interrupt (ignore overflow)
 8010b78:	6059      	str	r1, [r3, #4]
  adc->SQR1 = ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(ADC_TOUCH_Y); // Set channel, and count
 8010b7a:	f44f 7180 	mov.w	r1, #256	@ 0x100
  adc->TR1  = ADC_TR(0, TOUCH_THRESHOLD);                       // Threshold
 8010b7e:	6218      	str	r0, [r3, #32]
  adc->SQR1 = ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(ADC_TOUCH_Y); // Set channel, and count
 8010b80:	6319      	str	r1, [r3, #48]	@ 0x30
  adc->CFGR = ADC_CFGR1_RES_12BIT                               // 12 bit mode
 8010b82:	60da      	str	r2, [r3, #12]
          | ADC_CFGR_EXTEN_0                                    // rising edge of external trigger
          | ADC_CFGR_EXTSEL_2                                   // EXT4 0x1000 event (TIM3_TRGO)
          | ADC_CFGR_AWD1EN                                     // Enable Analog watchdog check interrupt
          | ADC_CFGR_OVRMOD                                     // Overrun Mode
          ;
  adc->CR|= ADC_CR_ADSTART;                                     // Starting watchdog
 8010b84:	689a      	ldr	r2, [r3, #8]
}
 8010b86:	f85d 4b04 	ldr.w	r4, [sp], #4
  adc->CR|= ADC_CR_ADSTART;                                     // Starting watchdog
 8010b8a:	f042 0204 	orr.w	r2, r2, #4
 8010b8e:	609a      	str	r2, [r3, #8]
}
 8010b90:	4770      	bx	lr
 8010b92:	bf00      	nop
 8010b94:	50000100 	.word	0x50000100
 8010b98:	00801500 	.word	0x00801500

08010b9c <adc_stop_analog_watchdog>:

void adc_stop_analog_watchdog(void)
{
  ADC_TypeDef *adc = TOUCH_ADC;  // ADC setup
  if (adc->CR & ADC_CR_ADSTART) {
 8010b9c:	4a05      	ldr	r2, [pc, #20]	@ (8010bb4 <adc_stop_analog_watchdog+0x18>)
 8010b9e:	6893      	ldr	r3, [r2, #8]
 8010ba0:	0759      	lsls	r1, r3, #29
 8010ba2:	d506      	bpl.n	8010bb2 <adc_stop_analog_watchdog+0x16>
    adc->CR|= ADC_CR_ADSTP;
 8010ba4:	6893      	ldr	r3, [r2, #8]
 8010ba6:	f043 0310 	orr.w	r3, r3, #16
 8010baa:	6093      	str	r3, [r2, #8]
    while (adc->CR & ADC_CR_ADSTP);
 8010bac:	6893      	ldr	r3, [r2, #8]
 8010bae:	06db      	lsls	r3, r3, #27
 8010bb0:	d4fc      	bmi.n	8010bac <adc_stop_analog_watchdog+0x10>
  }
}
 8010bb2:	4770      	bx	lr
 8010bb4:	50000100 	.word	0x50000100

08010bb8 <Vector88>:

static inline void adc_interrupt(void)
{
  ADC_TypeDef *adc = TOUCH_ADC;
  uint32_t isr = adc->ISR;
 8010bb8:	4a07      	ldr	r2, [pc, #28]	@ (8010bd8 <Vector88+0x20>)
    handle_touch_interrupt();
  }
}

OSAL_IRQ_HANDLER(STM32_ADC2_HANDLER)
{
 8010bba:	b508      	push	{r3, lr}
  uint32_t isr = adc->ISR;
 8010bbc:	6813      	ldr	r3, [r2, #0]
  adc->ISR = isr;
 8010bbe:	6013      	str	r3, [r2, #0]
  if (isr & ADC_ISR_AWD1) {  // Analog watchdog error.
 8010bc0:	061b      	lsls	r3, r3, #24
 8010bc2:	d403      	bmi.n	8010bcc <Vector88+0x14>
  OSAL_IRQ_PROLOGUE();

  adc_interrupt();

  OSAL_IRQ_EPILOGUE();
}
 8010bc4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8010bc8:	f7f0 b9b4 	b.w	8000f34 <_port_irq_epilogue>
    handle_touch_interrupt();
 8010bcc:	f7fe fece 	bl	800f96c <handle_touch_interrupt>
}
 8010bd0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8010bd4:	f7f0 b9ae 	b.w	8000f34 <_port_irq_epilogue>
 8010bd8:	50000100 	.word	0x50000100

08010bdc <i2c_set_timings>:
#define VNA_I2C                         I2C1
#define I2C_CR2_SADD_7BIT_SHIFT         1
#define I2C_CR2_NBYTES_SHIFT            16

void i2c_set_timings(uint32_t timings) {
  VNA_I2C->CR1&=~I2C_CR1_PE;
 8010bdc:	4b05      	ldr	r3, [pc, #20]	@ (8010bf4 <i2c_set_timings+0x18>)
 8010bde:	681a      	ldr	r2, [r3, #0]
 8010be0:	f022 0201 	bic.w	r2, r2, #1
 8010be4:	601a      	str	r2, [r3, #0]
  VNA_I2C->TIMINGR = timings;
 8010be6:	6118      	str	r0, [r3, #16]
  VNA_I2C->CR1|= I2C_CR1_PE;
 8010be8:	681a      	ldr	r2, [r3, #0]
 8010bea:	f042 0201 	orr.w	r2, r2, #1
 8010bee:	601a      	str	r2, [r3, #0]
}
 8010bf0:	4770      	bx	lr
 8010bf2:	bf00      	nop
 8010bf4:	40005400 	.word	0x40005400

08010bf8 <i2c_start>:

void i2c_start(void) {
  rccEnableI2C1(FALSE);
 8010bf8:	4a03      	ldr	r2, [pc, #12]	@ (8010c08 <i2c_start+0x10>)
  i2c_set_timings(STM32_I2C_INIT_T);
 8010bfa:	4804      	ldr	r0, [pc, #16]	@ (8010c0c <i2c_start+0x14>)
  rccEnableI2C1(FALSE);
 8010bfc:	69d3      	ldr	r3, [r2, #28]
 8010bfe:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8010c02:	61d3      	str	r3, [r2, #28]
  i2c_set_timings(STM32_I2C_INIT_T);
 8010c04:	f7ff bfea 	b.w	8010bdc <i2c_set_timings>
 8010c08:	40021000 	.word	0x40021000
 8010c0c:	01545064 	.word	0x01545064

08010c10 <i2c_transfer>:
}

// I2C TX only (compact version)
bool i2c_transfer(uint8_t addr, const uint8_t *w, size_t wn)
{
 8010c10:	b410      	push	{r4}
  //if (wn == 0) return false;
  while(VNA_I2C->ISR & I2C_ISR_BUSY); // wait last transaction
 8010c12:	4c14      	ldr	r4, [pc, #80]	@ (8010c64 <i2c_transfer+0x54>)
 8010c14:	69a3      	ldr	r3, [r4, #24]
 8010c16:	041b      	lsls	r3, r3, #16
 8010c18:	d4fc      	bmi.n	8010c14 <i2c_transfer+0x4>
  VNA_I2C->CR1|= I2C_CR1_PE;
 8010c1a:	6823      	ldr	r3, [r4, #0]
 8010c1c:	f043 0301 	orr.w	r3, r3, #1
 8010c20:	6023      	str	r3, [r4, #0]
  VNA_I2C->CR2 = (addr << I2C_CR2_SADD_7BIT_SHIFT) | (wn << I2C_CR2_NBYTES_SHIFT) | I2C_CR2_AUTOEND | I2C_CR2_START;
 8010c22:	0413      	lsls	r3, r2, #16
 8010c24:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
 8010c28:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8010c2c:	468c      	mov	ip, r1
 8010c2e:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
  do {
    while ((VNA_I2C->ISR & (I2C_ISR_TXE|I2C_ISR_NACKF)) == 0);
 8010c32:	490c      	ldr	r1, [pc, #48]	@ (8010c64 <i2c_transfer+0x54>)
  VNA_I2C->CR2 = (addr << I2C_CR2_SADD_7BIT_SHIFT) | (wn << I2C_CR2_NBYTES_SHIFT) | I2C_CR2_AUTOEND | I2C_CR2_START;
 8010c34:	6063      	str	r3, [r4, #4]
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
    VNA_I2C->TXDR = *w++;
  } while (--wn);
 8010c36:	4462      	add	r2, ip
    while ((VNA_I2C->ISR & (I2C_ISR_TXE|I2C_ISR_NACKF)) == 0);
 8010c38:	698b      	ldr	r3, [r1, #24]
 8010c3a:	f013 0f11 	tst.w	r3, #17
 8010c3e:	d0fb      	beq.n	8010c38 <i2c_transfer+0x28>
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
 8010c40:	698b      	ldr	r3, [r1, #24]
 8010c42:	06db      	lsls	r3, r3, #27
 8010c44:	d408      	bmi.n	8010c58 <i2c_transfer+0x48>
    VNA_I2C->TXDR = *w++;
 8010c46:	f81c 3b01 	ldrb.w	r3, [ip], #1
 8010c4a:	628b      	str	r3, [r1, #40]	@ 0x28
  } while (--wn);
 8010c4c:	4594      	cmp	ip, r2
 8010c4e:	d1f3      	bne.n	8010c38 <i2c_transfer+0x28>
  return true;
 8010c50:	2001      	movs	r0, #1
}
 8010c52:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010c56:	4770      	bx	lr
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
 8010c58:	2000      	movs	r0, #0
}
 8010c5a:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
 8010c5e:	6008      	str	r0, [r1, #0]
}
 8010c60:	4770      	bx	lr
 8010c62:	bf00      	nop
 8010c64:	40005400 	.word	0x40005400

08010c68 <rtc_get_tr_bin>:
  uint32_t tr = RTC->TR;
 8010c68:	4b07      	ldr	r3, [pc, #28]	@ (8010c88 <rtc_get_tr_bin+0x20>)
  uint32_t v = (tr&0x0F0F0F) + ((tr&0x707070)>>1) + ((tr&0x707070)>>3);
 8010c6a:	4808      	ldr	r0, [pc, #32]	@ (8010c8c <rtc_get_tr_bin+0x24>)
  uint32_t tr = RTC->TR;
 8010c6c:	681b      	ldr	r3, [r3, #0]
  uint32_t v = (tr&0x0F0F0F) + ((tr&0x707070)>>1) + ((tr&0x707070)>>3);
 8010c6e:	4a08      	ldr	r2, [pc, #32]	@ (8010c90 <rtc_get_tr_bin+0x28>)
 8010c70:	ea00 0053 	and.w	r0, r0, r3, lsr #1
 8010c74:	ea02 02d3 	and.w	r2, r2, r3, lsr #3
 8010c78:	f003 330f 	and.w	r3, r3, #252645135	@ 0xf0f0f0f
 8010c7c:	4410      	add	r0, r2
 8010c7e:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
}
 8010c82:	4418      	add	r0, r3
 8010c84:	4770      	bx	lr
 8010c86:	bf00      	nop
 8010c88:	40002800 	.word	0x40002800
 8010c8c:	00383838 	.word	0x00383838
 8010c90:	000e0e0e 	.word	0x000e0e0e

08010c94 <rtc_get_dr_bin>:
  uint32_t dr = RTC->DR;
 8010c94:	4b07      	ldr	r3, [pc, #28]	@ (8010cb4 <rtc_get_dr_bin+0x20>)
  uint32_t v = (dr&0x000F0F0F) + ((dr&0x00F01030)>>1) + ((dr&0x00F01030)>>3);
 8010c96:	4808      	ldr	r0, [pc, #32]	@ (8010cb8 <rtc_get_dr_bin+0x24>)
  uint32_t dr = RTC->DR;
 8010c98:	685b      	ldr	r3, [r3, #4]
  uint32_t v = (dr&0x000F0F0F) + ((dr&0x00F01030)>>1) + ((dr&0x00F01030)>>3);
 8010c9a:	4a08      	ldr	r2, [pc, #32]	@ (8010cbc <rtc_get_dr_bin+0x28>)
 8010c9c:	ea00 0053 	and.w	r0, r0, r3, lsr #1
 8010ca0:	ea02 02d3 	and.w	r2, r2, r3, lsr #3
 8010ca4:	f003 330f 	and.w	r3, r3, #252645135	@ 0xf0f0f0f
 8010ca8:	4410      	add	r0, r2
 8010caa:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
}
 8010cae:	4418      	add	r0, r3
 8010cb0:	4770      	bx	lr
 8010cb2:	bf00      	nop
 8010cb4:	40002800 	.word	0x40002800
 8010cb8:	00780818 	.word	0x00780818
 8010cbc:	001e0206 	.word	0x001e0206

08010cc0 <rtc_get_FAT>:
uint32_t rtc_get_FAT(void) {
 8010cc0:	b508      	push	{r3, lr}
  uint32_t tr = rtc_get_tr_bin();
 8010cc2:	f7ff ffd1 	bl	8010c68 <rtc_get_tr_bin>
 8010cc6:	4601      	mov	r1, r0
  uint32_t dr = rtc_get_dr_bin();
 8010cc8:	f7ff ffe4 	bl	8010c94 <rtc_get_dr_bin>
  fattime |= ((tr>>16)&0xFF) << 11U; // Hour
 8010ccc:	ea4f 4c11 	mov.w	ip, r1, lsr #16
  fattime  = ((tr>> 0)&0xFF) >>  1U; // Seconds / 2
 8010cd0:	f3c1 0246 	ubfx	r2, r1, #1, #7
  fattime |= ((dr>> 0)&0xFF) << 16U; // Day
 8010cd4:	0403      	lsls	r3, r0, #16
 8010cd6:	ea42 22cc 	orr.w	r2, r2, ip, lsl #11
 8010cda:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  fattime |= ((tr>> 8)&0xFF) <<  5U; // Minutes
 8010cde:	08c9      	lsrs	r1, r1, #3
 8010ce0:	431a      	orrs	r2, r3
 8010ce2:	f401 51ff 	and.w	r1, r1, #8160	@ 0x1fe0
  fattime |= ((dr>> 8)&0xFF) << 21U; // Month
 8010ce6:	0343      	lsls	r3, r0, #13
  fattime |= ((dr>> 0)&0xFF) << 16U; // Day
 8010ce8:	4311      	orrs	r1, r2
  fattime |= ((dr>> 8)&0xFF) << 21U; // Month
 8010cea:	f003 53ff 	and.w	r3, r3, #534773760	@ 0x1fe00000
  fattime |= (((dr>>16)&0xFF) + RTC_START_YEAR - 1980) << 25U; // Local year begin from 2000, fat from 1980
 8010cee:	0c00      	lsrs	r0, r0, #16
  fattime |= ((dr>> 8)&0xFF) << 21U; // Month
 8010cf0:	430b      	orrs	r3, r1
  fattime |= (((dr>>16)&0xFF) + RTC_START_YEAR - 1980) << 25U; // Local year begin from 2000, fat from 1980
 8010cf2:	3014      	adds	r0, #20
}
 8010cf4:	ea43 6040 	orr.w	r0, r3, r0, lsl #25
 8010cf8:	bd08      	pop	{r3, pc}
 8010cfa:	bf00      	nop

08010cfc <rtc_set_time>:
void rtc_set_time(uint32_t dr, uint32_t tr) {
 8010cfc:	b510      	push	{r4, lr}
 8010cfe:	4604      	mov	r4, r0
  if (rtc_enter_init()){
 8010d00:	f7ff fe56 	bl	80109b0 <rtc_enter_init>
 8010d04:	b110      	cbz	r0, 8010d0c <rtc_set_time+0x10>
    RTC->TR = tr;     // Write TR register
 8010d06:	4b04      	ldr	r3, [pc, #16]	@ (8010d18 <rtc_set_time+0x1c>)
 8010d08:	6019      	str	r1, [r3, #0]
    RTC->DR = dr;     // Write TD register
 8010d0a:	605c      	str	r4, [r3, #4]
  RTC->ISR &= ~RTC_ISR_INIT;
 8010d0c:	4a02      	ldr	r2, [pc, #8]	@ (8010d18 <rtc_set_time+0x1c>)
 8010d0e:	68d3      	ldr	r3, [r2, #12]
 8010d10:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8010d14:	60d3      	str	r3, [r2, #12]
}
 8010d16:	bd10      	pop	{r4, pc}
 8010d18:	40002800 	.word	0x40002800

08010d1c <auto_backup_domain_init>:

void auto_backup_domain_init(void){
  // Init Backup domain, RTC clock source
  uint32_t rtc_drv;
  // Backup domain access enabled and left open.
  PWR->CR |= PWR_CR_DBP;
 8010d1c:	4a10      	ldr	r2, [pc, #64]	@ (8010d60 <auto_backup_domain_init+0x44>)
void auto_backup_domain_init(void){
 8010d1e:	b538      	push	{r3, r4, r5, lr}
  PWR->CR |= PWR_CR_DBP;
 8010d20:	6813      	ldr	r3, [r2, #0]
  // Start/check source
  rtc_start_source();
  // Check LSE ready, if ok, select as source
  rtc_drv = RCC->BDCR & RCC_BDCR_LSERDY ? STM32_RTCSEL_LSE|RCC_BDCR_RTCEN :  // Select LSE as source
 8010d22:	4c10      	ldr	r4, [pc, #64]	@ (8010d64 <auto_backup_domain_init+0x48>)
  PWR->CR |= PWR_CR_DBP;
 8010d24:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8010d28:	6013      	str	r3, [r2, #0]
  rtc_start_source();
 8010d2a:	f7ff fe55 	bl	80109d8 <rtc_start_source>
  rtc_drv = RCC->BDCR & RCC_BDCR_LSERDY ? STM32_RTCSEL_LSE|RCC_BDCR_RTCEN :  // Select LSE as source
 8010d2e:	6a22      	ldr	r2, [r4, #32]
                                          STM32_RTCSEL_LSI|RCC_BDCR_RTCEN;   // Select LSI as source
  // If the backup domain hasn't been initialized yet or work on different source, then proceed with initialization
  if ((RCC->BDCR & (STM32_RTCSEL_MASK|RCC_BDCR_RTCEN)) != rtc_drv)
 8010d30:	6a23      	ldr	r3, [r4, #32]
  rtc_drv = RCC->BDCR & RCC_BDCR_LSERDY ? STM32_RTCSEL_LSE|RCC_BDCR_RTCEN :  // Select LSE as source
 8010d32:	f012 0f02 	tst.w	r2, #2
 8010d36:	bf0c      	ite	eq
 8010d38:	f44f 4502 	moveq.w	r5, #33280	@ 0x8200
 8010d3c:	f44f 4501 	movne.w	r5, #33024	@ 0x8100
  if ((RCC->BDCR & (STM32_RTCSEL_MASK|RCC_BDCR_RTCEN)) != rtc_drv)
 8010d40:	f403 4303 	and.w	r3, r3, #33536	@ 0x8300
 8010d44:	42ab      	cmp	r3, r5
 8010d46:	d100      	bne.n	8010d4a <auto_backup_domain_init+0x2e>
  if (rtc_enter_init())
    rtc_exit_init();
  else
    resetBCDR(STM32_RTCSEL_LSI|RCC_BDCR_RTCEN);
*/
}
 8010d48:	bd38      	pop	{r3, r4, r5, pc}
  RCC->BDCR = 0;
 8010d4a:	2300      	movs	r3, #0
  RCC->BDCR = RCC_BDCR_BDRST;
 8010d4c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8010d50:	6222      	str	r2, [r4, #32]
  RCC->BDCR = 0;
 8010d52:	6223      	str	r3, [r4, #32]
  rtc_start_source();
 8010d54:	f7ff fe40 	bl	80109d8 <rtc_start_source>
  RCC->BDCR|= rtc_drv;
 8010d58:	6a23      	ldr	r3, [r4, #32]
 8010d5a:	431d      	orrs	r5, r3
 8010d5c:	6225      	str	r5, [r4, #32]
}
 8010d5e:	bd38      	pop	{r3, r4, r5, pc}
 8010d60:	40007000 	.word	0x40007000
 8010d64:	40021000 	.word	0x40021000

08010d68 <rtc_init>:
#endif

// Initiate RTC clock
void rtc_init(void){
 8010d68:	b508      	push	{r3, lr}
#ifdef VNA_AUTO_SELECT_RTC_SOURCE
  // Auto start LSE or LSI source for RTC
  auto_backup_domain_init();
 8010d6a:	f7ff ffd7 	bl	8010d1c <auto_backup_domain_init>
  // ChibiOS init BDCR LSE or LSI source by self from user defined in mcuconf.h source
  // For add auto select RTC source need rewrite it
  // see hal_lld_backup_domain_init() in hal_lld.c for every CPU
  // Default RTC clock is LSE, but it possible not launch if no quartz installed
#endif
  uint32_t src = RCC->BDCR & STM32_RTCSEL_MASK;
 8010d6e:	4b16      	ldr	r3, [pc, #88]	@ (8010dc8 <rtc_init+0x60>)
 8010d70:	6a1b      	ldr	r3, [r3, #32]
  if (src == STM32_RTCSEL_NOCLOCK) return;
 8010d72:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 8010d76:	d021      	beq.n	8010dbc <rtc_init+0x54>
  // If calendar has not been initialized yet or different PRER settings then proceed with the initial setup.
  // Disable write protection.
  RTC->WPR = 0xCA;
 8010d78:	4a14      	ldr	r2, [pc, #80]	@ (8010dcc <rtc_init+0x64>)
  RTC->WPR = 0x53;
  uint32_t rtc_prer = (src == STM32_RTCSEL_LSE) ? STM32_RTC_LSE_PRER :
 8010d7a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  RTC->WPR = 0x53;
 8010d7e:	f04f 0153 	mov.w	r1, #83	@ 0x53
                                                  STM32_RTC_LSI_PRER;
  // If calendar has not been initialized yet then proceed with the initial setup.
  if ((RTC->ISR & RTC_ISR_INITS) == 0 || RTC->PRER != rtc_prer) {
 8010d82:	4b12      	ldr	r3, [pc, #72]	@ (8010dcc <rtc_init+0x64>)
  RTC->WPR = 0xCA;
 8010d84:	f04f 00ca 	mov.w	r0, #202	@ 0xca
 8010d88:	6250      	str	r0, [r2, #36]	@ 0x24
  RTC->WPR = 0x53;
 8010d8a:	6251      	str	r1, [r2, #36]	@ 0x24
  if ((RTC->ISR & RTC_ISR_INITS) == 0 || RTC->PRER != rtc_prer) {
 8010d8c:	68da      	ldr	r2, [r3, #12]
  uint32_t rtc_prer = (src == STM32_RTCSEL_LSE) ? STM32_RTC_LSE_PRER :
 8010d8e:	bf0c      	ite	eq
 8010d90:	490f      	ldreq	r1, [pc, #60]	@ (8010dd0 <rtc_init+0x68>)
 8010d92:	4910      	ldrne	r1, [pc, #64]	@ (8010dd4 <rtc_init+0x6c>)
  if ((RTC->ISR & RTC_ISR_INITS) == 0 || RTC->PRER != rtc_prer) {
 8010d94:	06d2      	lsls	r2, r2, #27
 8010d96:	d502      	bpl.n	8010d9e <rtc_init+0x36>
 8010d98:	691a      	ldr	r2, [r3, #16]
 8010d9a:	428a      	cmp	r2, r1
 8010d9c:	d00f      	beq.n	8010dbe <rtc_init+0x56>
    if (rtc_enter_init()){
 8010d9e:	f7ff fe07 	bl	80109b0 <rtc_enter_init>
 8010da2:	b130      	cbz	r0, 8010db2 <rtc_init+0x4a>
      RTC->CR   = 0
 8010da4:	4b09      	ldr	r3, [pc, #36]	@ (8010dcc <rtc_init+0x64>)
 8010da6:	2000      	movs	r0, #0
//              | RTC_CR_COSEL    // RTC output 1Hz (or 512Hz if disabled)
                 ;
      RTC->ISR  = RTC_ISR_INIT;     // Clearing all but RTC_ISR_INIT.
 8010da8:	2280      	movs	r2, #128	@ 0x80
      RTC->CR   = 0
 8010daa:	6098      	str	r0, [r3, #8]
      RTC->ISR  = RTC_ISR_INIT;     // Clearing all but RTC_ISR_INIT.
 8010dac:	60da      	str	r2, [r3, #12]
      RTC->PRER = rtc_prer;         // Prescaler value loaded in registers 2 times
 8010dae:	6119      	str	r1, [r3, #16]
      RTC->PRER = rtc_prer;
 8010db0:	6119      	str	r1, [r3, #16]
  RTC->ISR &= ~RTC_ISR_INIT;
 8010db2:	4a06      	ldr	r2, [pc, #24]	@ (8010dcc <rtc_init+0x64>)
 8010db4:	68d3      	ldr	r3, [r2, #12]
 8010db6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8010dba:	60d3      	str	r3, [r2, #12]
    // Finalizing of configuration procedure.
    rtc_exit_init();
  }
  else
    RTC->ISR &= ~RTC_ISR_RSF;
}
 8010dbc:	bd08      	pop	{r3, pc}
    RTC->ISR &= ~RTC_ISR_RSF;
 8010dbe:	68da      	ldr	r2, [r3, #12]
 8010dc0:	f022 0220 	bic.w	r2, r2, #32
 8010dc4:	60da      	str	r2, [r3, #12]
}
 8010dc6:	bd08      	pop	{r3, pc}
 8010dc8:	40021000 	.word	0x40021000
 8010dcc:	40002800 	.word	0x40002800
 8010dd0:	007f00ff 	.word	0x007f00ff
 8010dd4:	002703e7 	.word	0x002703e7

08010dd8 <rtc_set_cal>:

void rtc_set_cal(float ppm) {
  int32_t cal = ppm * (1<<20) / 1000000.0f + 511.5f;
  if ((RTC->ISR & RTC_ISR_RECALPF) || (uint32_t)cal > 1024)
 8010dd8:	4a0c      	ldr	r2, [pc, #48]	@ (8010e0c <rtc_set_cal+0x34>)
 8010dda:	68d3      	ldr	r3, [r2, #12]
 8010ddc:	03db      	lsls	r3, r3, #15
 8010dde:	d413      	bmi.n	8010e08 <rtc_set_cal+0x30>
  int32_t cal = ppm * (1<<20) / 1000000.0f + 511.5f;
 8010de0:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 8010e10 <rtc_set_cal+0x38>
 8010de4:	eddf 7a0b 	vldr	s15, [pc, #44]	@ 8010e14 <rtc_set_cal+0x3c>
 8010de8:	eee0 7a07 	vfma.f32	s15, s0, s14
 8010dec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8010df0:	ee17 3a90 	vmov	r3, s15
  if ((RTC->ISR & RTC_ISR_RECALPF) || (uint32_t)cal > 1024)
 8010df4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8010df8:	d806      	bhi.n	8010e08 <rtc_set_cal+0x30>
    return;
  RTC->CALR = ((511 - cal) & (RTC_CALR_CALP | RTC_CALR_CALM));
 8010dfa:	f5c3 73ff 	rsb	r3, r3, #510	@ 0x1fe
 8010dfe:	3301      	adds	r3, #1
 8010e00:	f248 11ff 	movw	r1, #33279	@ 0x81ff
 8010e04:	400b      	ands	r3, r1
 8010e06:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
 8010e08:	4770      	bx	lr
 8010e0a:	bf00      	nop
 8010e0c:	40002800 	.word	0x40002800
 8010e10:	3f8637bd 	.word	0x3f8637bd
 8010e14:	43ffc000 	.word	0x43ffc000

08010e18 <rtc_get_cal>:

float rtc_get_cal(void) {
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8010e18:	4a09      	ldr	r2, [pc, #36]	@ (8010e40 <rtc_get_cal+0x28>)
  if (RTC->CALR & RTC_CALR_CALP)
    cal += 512;
  return cal * (1000000.0f / (1<<20));
 8010e1a:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 8010e44 <rtc_get_cal+0x2c>
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8010e1e:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
  if (RTC->CALR & RTC_CALR_CALP)
 8010e20:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8010e22:	f3c3 0308 	ubfx	r3, r3, #0, #9
  if (RTC->CALR & RTC_CALR_CALP)
 8010e26:	0412      	lsls	r2, r2, #16
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8010e28:	bf54      	ite	pl
 8010e2a:	425b      	negpl	r3, r3
    cal += 512;
 8010e2c:	f5c3 7300 	rsbmi	r3, r3, #512	@ 0x200
 8010e30:	ee00 3a10 	vmov	s0, r3
  return cal * (1000000.0f / (1<<20));
 8010e34:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
}
 8010e38:	ee20 0a27 	vmul.f32	s0, s0, s15
 8010e3c:	4770      	bx	lr
 8010e3e:	bf00      	nop
 8010e40:	40002800 	.word	0x40002800
 8010e44:	3f742400 	.word	0x3f742400

08010e48 <dac_init>:
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

void dac_init(void) {
  rccEnableDAC1(false); // Use DAC1
 8010e48:	4905      	ldr	r1, [pc, #20]	@ (8010e60 <dac_init+0x18>)
  DAC->CR|= DAC_CR_EN2; // Enable DAC1 ch2
 8010e4a:	4a06      	ldr	r2, [pc, #24]	@ (8010e64 <dac_init+0x1c>)
  rccEnableDAC1(false); // Use DAC1
 8010e4c:	69cb      	ldr	r3, [r1, #28]
 8010e4e:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8010e52:	61cb      	str	r3, [r1, #28]
  DAC->CR|= DAC_CR_EN2; // Enable DAC1 ch2
 8010e54:	6813      	ldr	r3, [r2, #0]
 8010e56:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8010e5a:	6013      	str	r3, [r2, #0]
}
 8010e5c:	4770      	bx	lr
 8010e5e:	bf00      	nop
 8010e60:	40021000 	.word	0x40021000
 8010e64:	40007400 	.word	0x40007400

08010e68 <dac_setvalue_ch2>:

void dac_setvalue_ch1(uint16_t v) {DAC->DHR12R1 = v;}
void dac_setvalue_ch2(uint16_t v) {DAC->DHR12R2 = v;}
 8010e68:	4b01      	ldr	r3, [pc, #4]	@ (8010e70 <dac_setvalue_ch2+0x8>)
 8010e6a:	6158      	str	r0, [r3, #20]
 8010e6c:	4770      	bx	lr
 8010e6e:	bf00      	nop
 8010e70:	40007400 	.word	0x40007400

08010e74 <initI2S>:
#define SPI_I2S_PCM_MODE       (SPI_I2SCFGR_I2SSTD_0 | SPI_I2SCFGR_I2SSTD_1)

/*
 * Run I2S bus in Circular mode, fill buffer, and handle read in I2S DMA RX interrupt
 */
void initI2S(void *buffer, uint16_t count) {
 8010e74:	b538      	push	{r3, r4, r5, lr}
 8010e76:	4604      	mov	r4, r0
 8010e78:	460d      	mov	r5, r1
    | STM32_DMA_CR_HTIE        // Half transfer complete interrupt enable
    | STM32_DMA_CR_TCIE        // Full transfer complete interrupt enable
//  | STM32_DMA_CR_TEIE        // Transfer error interrupt enable
    ;
  // I2S RX DMA setup.
  nvicEnableVector(STM32_SPI2_RX_DMA_IRQ_NUMBER, STM32_I2S_SPI2_IRQ_PRIORITY);
 8010e7a:	200e      	movs	r0, #14
 8010e7c:	2103      	movs	r1, #3
 8010e7e:	f7f0 ff3b 	bl	8001cf8 <nvicEnableVector>
  dmaChannelSetTransactionSize(I2S_DMA_RX, count);                 // number of data register
 8010e82:	4b0c      	ldr	r3, [pc, #48]	@ (8010eb4 <initI2S+0x40>)
  dmaChannelSetPeripheral(I2S_DMA_RX, &SPI2->DR);                  // peripheral address register
  dmaChannelSetMemory(I2S_DMA_RX, buffer);                         // memory address register
  dmaChannelSetMode(I2S_DMA_RX, I2S_DMA_RX_ccr | STM32_DMA_CR_EN); // configuration register

  // Starting I2S
  rccEnableSPI2(FALSE);           // Enabling I2S unit clock.
 8010e84:	480c      	ldr	r0, [pc, #48]	@ (8010eb8 <initI2S+0x44>)
  dmaChannelSetPeripheral(I2S_DMA_RX, &SPI2->DR);                  // peripheral address register
 8010e86:	490d      	ldr	r1, [pc, #52]	@ (8010ebc <initI2S+0x48>)
  dmaChannelSetTransactionSize(I2S_DMA_RX, count);                 // number of data register
 8010e88:	649d      	str	r5, [r3, #72]	@ 0x48
  dmaChannelSetMode(I2S_DMA_RX, I2S_DMA_RX_ccr | STM32_DMA_CR_EN); // configuration register
 8010e8a:	f243 52a7 	movw	r2, #13735	@ 0x35a7
  dmaChannelSetPeripheral(I2S_DMA_RX, &SPI2->DR);                  // peripheral address register
 8010e8e:	64d9      	str	r1, [r3, #76]	@ 0x4c
  dmaChannelSetMemory(I2S_DMA_RX, buffer);                         // memory address register
 8010e90:	651c      	str	r4, [r3, #80]	@ 0x50
  dmaChannelSetMode(I2S_DMA_RX, I2S_DMA_RX_ccr | STM32_DMA_CR_EN); // configuration register
 8010e92:	645a      	str	r2, [r3, #68]	@ 0x44
  rccEnableSPI2(FALSE);           // Enabling I2S unit clock.
 8010e94:	69c2      	ldr	r2, [r0, #28]
  SPI2->CR1 = 0;                  // CRs settings
 8010e96:	f5a3 33e4 	sub.w	r3, r3, #116736	@ 0x1c800
  rccEnableSPI2(FALSE);           // Enabling I2S unit clock.
 8010e9a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8010e9e:	61c2      	str	r2, [r0, #28]
  SPI2->CR1 = 0;                  // CRs settings
 8010ea0:	2100      	movs	r1, #0
  SPI2->CR2 = SPI_CR2_RXDMAEN;    // Enable RX DMA
 8010ea2:	2401      	movs	r4, #1
  SPI2->I2SPR   = 0;              // I2S (re)configuration.
  SPI2->I2SCFGR = 0
 8010ea4:	f44f 625b 	mov.w	r2, #3504	@ 0xdb0
  SPI2->CR1 = 0;                  // CRs settings
 8010ea8:	6019      	str	r1, [r3, #0]
  SPI2->CR2 = SPI_CR2_RXDMAEN;    // Enable RX DMA
 8010eaa:	605c      	str	r4, [r3, #4]
  SPI2->I2SPR   = 0;              // I2S (re)configuration.
 8010eac:	6219      	str	r1, [r3, #32]
  SPI2->I2SCFGR = 0
 8010eae:	61da      	str	r2, [r3, #28]
    | SPI_I2SCFGR_I2SMOD          // I2S mode is selected
    | SPI_I2S_PCM_MODE            // I2S PCM standard (aic3204 use DSP mode, short sync)
    | SPI_I2SCFGR_PCMSYNC         // Short sync
    | SPI_I2SCFGR_I2SE            // I2S enable
    ;
}
 8010eb0:	bd38      	pop	{r3, r4, r5, pc}
 8010eb2:	bf00      	nop
 8010eb4:	40020000 	.word	0x40020000
 8010eb8:	40021000 	.word	0x40021000
 8010ebc:	4000380c 	.word	0x4000380c

08010ec0 <flash_erase_pages>:
}

static inline void flash_unlock(void)
{
  // unlock sequence
  FLASH->KEYR = FLASH_KEY1;
 8010ec0:	4b11      	ldr	r3, [pc, #68]	@ (8010f08 <flash_erase_pages+0x48>)
  FLASH->KEYR = FLASH_KEY2;
 8010ec2:	4a12      	ldr	r2, [pc, #72]	@ (8010f0c <flash_erase_pages+0x4c>)
void flash_erase_pages(uint32_t page_address, uint32_t size)
{
  // Unlock for erase
  flash_unlock();
  // erase flash pages
  size+=page_address;
 8010ec4:	4401      	add	r1, r0
{
 8010ec6:	b410      	push	{r4}
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8010ec8:	4288      	cmp	r0, r1
  FLASH->KEYR = FLASH_KEY1;
 8010eca:	4c11      	ldr	r4, [pc, #68]	@ (8010f10 <flash_erase_pages+0x50>)
 8010ecc:	605c      	str	r4, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 8010ece:	605a      	str	r2, [r3, #4]
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8010ed0:	d216      	bcs.n	8010f00 <flash_erase_pages+0x40>
  while (FLASH->SR == FLASH_SR_BSY) {
 8010ed2:	68da      	ldr	r2, [r3, #12]
 8010ed4:	2a01      	cmp	r2, #1
 8010ed6:	d0fc      	beq.n	8010ed2 <flash_erase_pages+0x12>
  FLASH->CR|= FLASH_CR_PER;
 8010ed8:	691a      	ldr	r2, [r3, #16]
 8010eda:	f042 0202 	orr.w	r2, r2, #2
 8010ede:	611a      	str	r2, [r3, #16]
  FLASH->AR = page_address;
 8010ee0:	6158      	str	r0, [r3, #20]
  FLASH->CR|= FLASH_CR_STRT;
 8010ee2:	691a      	ldr	r2, [r3, #16]
 8010ee4:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8010ee8:	611a      	str	r2, [r3, #16]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010eea:	68da      	ldr	r2, [r3, #12]
 8010eec:	2a01      	cmp	r2, #1
 8010eee:	d0fc      	beq.n	8010eea <flash_erase_pages+0x2a>
  FLASH->CR&=~FLASH_CR_PER;
 8010ef0:	691a      	ldr	r2, [r3, #16]
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8010ef2:	f500 6000 	add.w	r0, r0, #2048	@ 0x800
  FLASH->CR&=~FLASH_CR_PER;
 8010ef6:	f022 0202 	bic.w	r2, r2, #2
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8010efa:	4281      	cmp	r1, r0
  FLASH->CR&=~FLASH_CR_PER;
 8010efc:	611a      	str	r2, [r3, #16]
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8010efe:	d8e8      	bhi.n	8010ed2 <flash_erase_pages+0x12>
    flash_erase_page0(page_address);
}
 8010f00:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010f04:	4770      	bx	lr
 8010f06:	bf00      	nop
 8010f08:	40022000 	.word	0x40022000
 8010f0c:	cdef89ab 	.word	0xcdef89ab
 8010f10:	45670123 	.word	0x45670123

08010f14 <flash_program_half_word_buffer>:

void flash_program_half_word_buffer(uint16_t* dst, uint16_t *data, uint16_t size)
{
 8010f14:	b570      	push	{r4, r5, r6, lr}
 8010f16:	4616      	mov	r6, r2
 8010f18:	460c      	mov	r4, r1
  uint32_t i;
  // unlock, and erase flash pages for buffer (aligned to FLASH_PAGESIZE)
  flash_erase_pages((uint32_t)dst, size);
 8010f1a:	4611      	mov	r1, r2
 8010f1c:	4605      	mov	r5, r0
 8010f1e:	f7ff ffcf 	bl	8010ec0 <flash_erase_pages>
  // Save buffer
  __IO uint16_t* p = dst;
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8010f22:	0870      	lsrs	r0, r6, #1
 8010f24:	d018      	beq.n	8010f58 <flash_program_half_word_buffer+0x44>
  while (FLASH->SR == FLASH_SR_BSY) {
 8010f26:	4b0d      	ldr	r3, [pc, #52]	@ (8010f5c <flash_program_half_word_buffer+0x48>)
 8010f28:	4621      	mov	r1, r4
 8010f2a:	eb04 0040 	add.w	r0, r4, r0, lsl #1
 8010f2e:	68da      	ldr	r2, [r3, #12]
 8010f30:	2a01      	cmp	r2, #1
 8010f32:	d0fc      	beq.n	8010f2e <flash_program_half_word_buffer+0x1a>
    flash_wait_for_last_operation();
    FLASH->CR|= FLASH_CR_PG;
 8010f34:	691a      	ldr	r2, [r3, #16]
    p[i] = data[i];
 8010f36:	f831 4b02 	ldrh.w	r4, [r1], #2
    FLASH->CR|= FLASH_CR_PG;
 8010f3a:	f042 0201 	orr.w	r2, r2, #1
 8010f3e:	611a      	str	r2, [r3, #16]
    p[i] = data[i];
 8010f40:	802c      	strh	r4, [r5, #0]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010f42:	68da      	ldr	r2, [r3, #12]
 8010f44:	2a01      	cmp	r2, #1
 8010f46:	d0fc      	beq.n	8010f42 <flash_program_half_word_buffer+0x2e>
    flash_wait_for_last_operation();
    FLASH->CR&=~FLASH_CR_PG;
 8010f48:	691a      	ldr	r2, [r3, #16]
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8010f4a:	4281      	cmp	r1, r0
    FLASH->CR&=~FLASH_CR_PG;
 8010f4c:	f022 0201 	bic.w	r2, r2, #1
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8010f50:	f105 0502 	add.w	r5, r5, #2
    FLASH->CR&=~FLASH_CR_PG;
 8010f54:	611a      	str	r2, [r3, #16]
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8010f56:	d1ea      	bne.n	8010f2e <flash_program_half_word_buffer+0x1a>
  }
}
 8010f58:	bd70      	pop	{r4, r5, r6, pc}
 8010f5a:	bf00      	nop
 8010f5c:	40022000 	.word	0x40022000

08010f60 <initPal>:
  port->AFR[0]  = config->afrl;
  port->AFR[1]  = config->afrh;
  port->MODER   = config->moder;
}

void initPal(void) {
 8010f60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rccEnableAHB(STM32_GPIO_EN_MASK, TRUE);
 8010f64:	4c1f      	ldr	r4, [pc, #124]	@ (8010fe4 <initPal+0x84>)
  port->OSPEEDR = config->ospeedr;
 8010f66:	4d20      	ldr	r5, [pc, #128]	@ (8010fe8 <initPal+0x88>)
  rccEnableAHB(STM32_GPIO_EN_MASK, TRUE);
 8010f68:	6963      	ldr	r3, [r4, #20]
  port->OTYPER  = config->otyper;
 8010f6a:	4a20      	ldr	r2, [pc, #128]	@ (8010fec <initPal+0x8c>)
  port->AFR[1]  = config->afrh;
 8010f6c:	f8df a090 	ldr.w	sl, [pc, #144]	@ 8011000 <initPal+0xa0>
  port->MODER   = config->moder;
 8010f70:	f8df 9090 	ldr.w	r9, [pc, #144]	@ 8011004 <initPal+0xa4>
  port->PUPDR   = config->pupdr;
 8010f74:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 8011008 <initPal+0xa8>
  port->AFR[0]  = config->afrl;
 8010f78:	f8df e090 	ldr.w	lr, [pc, #144]	@ 801100c <initPal+0xac>
  port->AFR[1]  = config->afrh;
 8010f7c:	f8df c090 	ldr.w	ip, [pc, #144]	@ 8011010 <initPal+0xb0>
  port->MODER   = config->moder;
 8010f80:	4f1b      	ldr	r7, [pc, #108]	@ (8010ff0 <initPal+0x90>)
  port->OTYPER  = config->otyper;
 8010f82:	f04f 4190 	mov.w	r1, #1207959552	@ 0x48000000
 8010f86:	2000      	movs	r0, #0
  rccEnableAHB(STM32_GPIO_EN_MASK, TRUE);
 8010f88:	f443 03fc 	orr.w	r3, r3, #8257536	@ 0x7e0000
 8010f8c:	6163      	str	r3, [r4, #20]
  port->ODR     = config->odr;
 8010f8e:	f64f 1bdf 	movw	fp, #63967	@ 0xf9df
  port->OTYPER  = config->otyper;
 8010f92:	6048      	str	r0, [r1, #4]
  port->OSPEEDR = config->ospeedr;
 8010f94:	608d      	str	r5, [r1, #8]
  port->PUPDR   = config->pupdr;
 8010f96:	4d17      	ldr	r5, [pc, #92]	@ (8010ff4 <initPal+0x94>)
 8010f98:	60cd      	str	r5, [r1, #12]
  port->OTYPER  = config->otyper;
 8010f9a:	4b17      	ldr	r3, [pc, #92]	@ (8010ff8 <initPal+0x98>)
  port->ODR     = config->odr;
 8010f9c:	f8c1 b014 	str.w	fp, [r1, #20]
 8010fa0:	f64f 74ff 	movw	r4, #65535	@ 0xffff
  port->AFR[0]  = config->afrl;
 8010fa4:	6208      	str	r0, [r1, #32]
  port->AFR[1]  = config->afrh;
 8010fa6:	f8c1 a024 	str.w	sl, [r1, #36]	@ 0x24
  port->MODER   = config->moder;
 8010faa:	f8c1 9000 	str.w	r9, [r1]
  port->OSPEEDR = config->ospeedr;
 8010fae:	f06f 010f 	mvn.w	r1, #15
  port->OTYPER  = config->otyper;
 8010fb2:	6050      	str	r0, [r2, #4]
  port->PUPDR   = config->pupdr;
 8010fb4:	4d11      	ldr	r5, [pc, #68]	@ (8010ffc <initPal+0x9c>)
  port->OSPEEDR = config->ospeedr;
 8010fb6:	6091      	str	r1, [r2, #8]
 8010fb8:	f04f 36ff 	mov.w	r6, #4294967295
  port->PUPDR   = config->pupdr;
 8010fbc:	f8c2 800c 	str.w	r8, [r2, #12]
  port->ODR     = config->odr;
 8010fc0:	6154      	str	r4, [r2, #20]
  port->AFR[0]  = config->afrl;
 8010fc2:	f8c2 e020 	str.w	lr, [r2, #32]
  port->AFR[1]  = config->afrh;
 8010fc6:	f8c2 c024 	str.w	ip, [r2, #36]	@ 0x24
  port->MODER   = config->moder;
 8010fca:	6017      	str	r7, [r2, #0]
 8010fcc:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
  port->OTYPER  = config->otyper;
 8010fd0:	6058      	str	r0, [r3, #4]
  port->OSPEEDR = config->ospeedr;
 8010fd2:	609e      	str	r6, [r3, #8]
  port->PUPDR   = config->pupdr;
 8010fd4:	60dd      	str	r5, [r3, #12]
  port->ODR     = config->odr;
 8010fd6:	615c      	str	r4, [r3, #20]
  port->AFR[0]  = config->afrl;
 8010fd8:	6218      	str	r0, [r3, #32]
  port->AFR[1]  = config->afrh;
 8010fda:	6258      	str	r0, [r3, #36]	@ 0x24
  port->MODER   = config->moder;
 8010fdc:	601a      	str	r2, [r3, #0]
  initgpio(GPIOA, &pal_config[0]);
  initgpio(GPIOB, &pal_config[1]);
  initgpio(GPIOC, &pal_config[2]);
//  initgpio(GPIOD, &pal_config[3]);
}
 8010fde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010fe2:	bf00      	nop
 8010fe4:	40021000 	.word	0x40021000
 8010fe8:	ffff0000 	.word	0xffff0000
 8010fec:	48000400 	.word	0x48000400
 8010ff0:	aa5a5a9f 	.word	0xaa5a5a9f
 8010ff4:	a80101aa 	.word	0xa80101aa
 8010ff8:	48000800 	.word	0x48000800
 8010ffc:	01555555 	.word	0x01555555
 8011000:	000ee770 	.word	0x000ee770
 8011004:	6aaafc00 	.word	0x6aaafc00
 8011008:	55555550 	.word	0x55555550
 801100c:	00555000 	.word	0x00555000
 8011010:	50550044 	.word	0x50550044

08011014 <palSetPadMode>:
    moder <<= 2;
    bit++;
  }
}

void palSetPadMode(GPIO_TypeDef *port, int bit, uint32_t mode) {
 8011014:	b530      	push	{r4, r5, lr}
  uint32_t pupdr   = ((mode & PAL_STM32_PUPDR_MASK)  >> 5)<<(bit*2);
  uint32_t moder   = ((mode & PAL_STM32_MODE_MASK)   >> 0)<<(bit*2);
  uint32_t m1 = 0x1 << (bit * 1);
  uint32_t m2 = 0x3 << (bit * 2);

  port->OTYPER  = (port->OTYPER  & ~m1) | otyper;
 8011016:	6843      	ldr	r3, [r0, #4]
  uint32_t m1 = 0x1 << (bit * 1);
 8011018:	2401      	movs	r4, #1
 801101a:	408c      	lsls	r4, r1
  port->OTYPER  = (port->OTYPER  & ~m1) | otyper;
 801101c:	ea23 0304 	bic.w	r3, r3, r4
  uint32_t otyper  = ((mode & PAL_STM32_OTYPE_MASK)  >> 2)<<(bit*1);
 8011020:	f3c2 0480 	ubfx	r4, r2, #2, #1
 8011024:	408c      	lsls	r4, r1
  port->OTYPER  = (port->OTYPER  & ~m1) | otyper;
 8011026:	4323      	orrs	r3, r4
 8011028:	6043      	str	r3, [r0, #4]
  uint32_t ospeedr = ((mode & PAL_STM32_OSPEED_MASK) >> 3)<<(bit*2);
 801102a:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 801102e:	6885      	ldr	r5, [r0, #8]
  uint32_t m2 = 0x3 << (bit * 2);
 8011030:	2303      	movs	r3, #3
 8011032:	fa03 f30c 	lsl.w	r3, r3, ip
  uint32_t ospeedr = ((mode & PAL_STM32_OSPEED_MASK) >> 3)<<(bit*2);
 8011036:	f3c2 04c1 	ubfx	r4, r2, #3, #2
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 801103a:	ea25 0503 	bic.w	r5, r5, r3
  uint32_t ospeedr = ((mode & PAL_STM32_OSPEED_MASK) >> 3)<<(bit*2);
 801103e:	fa04 f40c 	lsl.w	r4, r4, ip
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8011042:	432c      	orrs	r4, r5
 8011044:	6084      	str	r4, [r0, #8]
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 8011046:	68c5      	ldr	r5, [r0, #12]
  uint32_t pupdr   = ((mode & PAL_STM32_PUPDR_MASK)  >> 5)<<(bit*2);
 8011048:	f3c2 1441 	ubfx	r4, r2, #5, #2
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 801104c:	ea25 0503 	bic.w	r5, r5, r3
  uint32_t pupdr   = ((mode & PAL_STM32_PUPDR_MASK)  >> 5)<<(bit*2);
 8011050:	fa04 f40c 	lsl.w	r4, r4, ip
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 8011054:	432c      	orrs	r4, r5
  uint32_t moder   = ((mode & PAL_STM32_MODE_MASK)   >> 0)<<(bit*2);
 8011056:	f002 0e03 	and.w	lr, r2, #3
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 801105a:	60c4      	str	r4, [r0, #12]
#if 0
  port->MODER   = (port->MODER & ~m2) | moder;
#else
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 801105c:	f001 0407 	and.w	r4, r1, #7
  uint32_t moder   = ((mode & PAL_STM32_MODE_MASK)   >> 0)<<(bit*2);
 8011060:	fa0e fe0c 	lsl.w	lr, lr, ip
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 8011064:	00a4      	lsls	r4, r4, #2
  uint32_t m4       = 0xF << ((bit&7) * 4);
 8011066:	f04f 0c0f 	mov.w	ip, #15
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 801106a:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  if (moder == PAL_STM32_MODE_ALTERNATE) {
    // If going in alternate mode then the alternate number is set before switching mode in order to avoid glitches.
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 801106e:	f3c1 01c0 	ubfx	r1, r1, #3, #1
  uint32_t m4       = 0xF << ((bit&7) * 4);
 8011072:	fa0c fc04 	lsl.w	ip, ip, r4
  if (moder == PAL_STM32_MODE_ALTERNATE) {
 8011076:	f1be 0f02 	cmp.w	lr, #2
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 801107a:	ea6f 0303 	mvn.w	r3, r3
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 801107e:	fa02 f204 	lsl.w	r2, r2, r4
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 8011082:	ea6f 0c0c 	mvn.w	ip, ip
 8011086:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  if (moder == PAL_STM32_MODE_ALTERNATE) {
 801108a:	d00a      	beq.n	80110a2 <palSetPadMode+0x8e>
    port->MODER = (port->MODER   & ~m2) | moder;
  }
  else {
    // If going into a non-alternate mode then the mode is switched before setting the alternate mode in order to avoid glitches.
    port->MODER = (port->MODER   & ~m2) | moder;
 801108c:	6804      	ldr	r4, [r0, #0]
 801108e:	4023      	ands	r3, r4
 8011090:	ea43 030e 	orr.w	r3, r3, lr
 8011094:	6003      	str	r3, [r0, #0]
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 8011096:	6a0b      	ldr	r3, [r1, #32]
 8011098:	ea03 030c 	and.w	r3, r3, ip
 801109c:	4313      	orrs	r3, r2
 801109e:	620b      	str	r3, [r1, #32]
  }
#endif
}
 80110a0:	bd30      	pop	{r4, r5, pc}
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 80110a2:	6a0c      	ldr	r4, [r1, #32]
 80110a4:	ea04 040c 	and.w	r4, r4, ip
 80110a8:	4322      	orrs	r2, r4
 80110aa:	620a      	str	r2, [r1, #32]
    port->MODER = (port->MODER   & ~m2) | moder;
 80110ac:	6802      	ldr	r2, [r0, #0]
 80110ae:	4013      	ands	r3, r2
 80110b0:	f043 0302 	orr.w	r3, r3, #2
 80110b4:	6003      	str	r3, [r0, #0]
}
 80110b6:	bd30      	pop	{r4, r5, pc}

080110b8 <Vector78>:
}
#endif

#if defined(DMA1_CH4_HANDLER_FUNC) || defined(DMA1_USE_ALL_HANDLERS)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags = DMA1->ISR; DMA1->IFCR = flags;  // reset interrupt vector
 80110b8:	4b05      	ldr	r3, [pc, #20]	@ (80110d0 <Vector78+0x18>)
 80110ba:	6818      	ldr	r0, [r3, #0]
 80110bc:	6058      	str	r0, [r3, #4]
#ifdef DMA1_CH4_HANDLER_FUNC
  if (flags & (STM32_DMA_ISR_MASK<<12)) DMA1_CH4_HANDLER_FUNC((flags>>12)&STM32_DMA_ISR_MASK); // DMA Channel 4 handler
 80110be:	f410 4f70 	tst.w	r0, #61440	@ 0xf000
 80110c2:	d100      	bne.n	80110c6 <Vector78+0xe>
#endif
}
 80110c4:	4770      	bx	lr
  if (flags & (STM32_DMA_ISR_MASK<<12)) DMA1_CH4_HANDLER_FUNC((flags>>12)&STM32_DMA_ISR_MASK); // DMA Channel 4 handler
 80110c6:	f3c0 3003 	ubfx	r0, r0, #12, #4
 80110ca:	f7f5 b9f1 	b.w	80064b0 <i2s_lld_serve_rx_interrupt>
 80110ce:	bf00      	nop
 80110d0:	40020000 	.word	0x40020000

080110d4 <Vector5C>:
}
#endif

#if defined(EXT_CH1_HANDLER_FUNC)
OSAL_IRQ_HANDLER(Vector5C) {  // EXTI[1] interrupt handler.
  uint32_t pr = EXTI->PR & (1U << 1);
 80110d4:	4a04      	ldr	r2, [pc, #16]	@ (80110e8 <Vector5C+0x14>)
 80110d6:	6953      	ldr	r3, [r2, #20]
 80110d8:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 80110dc:	6153      	str	r3, [r2, #20]
#ifdef EXT_CH1_HANDLER_FUNC
  if (pr & (1U << 1)) EXT_CH1_HANDLER_FUNC(1);
 80110de:	b903      	cbnz	r3, 80110e2 <Vector5C+0xe>
#endif
}
 80110e0:	4770      	bx	lr
  if (pr & (1U << 1)) EXT_CH1_HANDLER_FUNC(1);
 80110e2:	2001      	movs	r0, #1
 80110e4:	f7fe bc3a 	b.w	800f95c <handle_button_interrupt>
 80110e8:	40010400 	.word	0x40010400

080110ec <Vector60>:
#endif

#if defined(EXT_CH2_HANDLER_FUNC)
OSAL_IRQ_HANDLER(Vector60) {  // EXTI[2] interrupt handler.
  uint32_t pr = EXTI->PR & (1U << 2);
 80110ec:	4a04      	ldr	r2, [pc, #16]	@ (8011100 <Vector60+0x14>)
 80110ee:	6953      	ldr	r3, [r2, #20]
 80110f0:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 80110f4:	6153      	str	r3, [r2, #20]
#ifdef EXT_CH2_HANDLER_FUNC
  if (pr & (1U << 2)) EXT_CH2_HANDLER_FUNC(2);
 80110f6:	b903      	cbnz	r3, 80110fa <Vector60+0xe>
#endif
}
 80110f8:	4770      	bx	lr
  if (pr & (1U << 2)) EXT_CH2_HANDLER_FUNC(2);
 80110fa:	2002      	movs	r0, #2
 80110fc:	f7fe bc2e 	b.w	800f95c <handle_button_interrupt>
 8011100:	40010400 	.word	0x40010400

08011104 <Vector64>:
#endif

#if defined(EXT_CH3_HANDLER_FUNC)
OSAL_IRQ_HANDLER(Vector64) {  // EXTI[3] interrupt handler.
  uint32_t pr = EXTI->PR & (1U << 3);
 8011104:	4a04      	ldr	r2, [pc, #16]	@ (8011118 <Vector64+0x14>)
 8011106:	6953      	ldr	r3, [r2, #20]
 8011108:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 801110c:	6153      	str	r3, [r2, #20]
#ifdef EXT_CH3_HANDLER_FUNC
  if (pr & (1U << 3)) EXT_CH3_HANDLER_FUNC(3);
 801110e:	b903      	cbnz	r3, 8011112 <Vector64+0xe>
#endif
}
 8011110:	4770      	bx	lr
  if (pr & (1U << 3)) EXT_CH3_HANDLER_FUNC(3);
 8011112:	2003      	movs	r0, #3
 8011114:	f7fe bc22 	b.w	800f95c <handle_button_interrupt>
 8011118:	40010400 	.word	0x40010400

0801111c <extStart>:
  if (pr & (1U << 15)) EXT_CH15_HANDLER_FUNC(15);
#endif
}
#endif

void extStart(void) {
 801111c:	b508      	push	{r3, lr}
#ifdef EXT_CH0_HANDLER_FUNC
  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
#endif
#ifdef EXT_CH1_HANDLER_FUNC
  nvicEnableVector(EXTI1_IRQn, STM32_EXT_EXTI1_IRQ_PRIORITY);
 801111e:	2106      	movs	r1, #6
 8011120:	2007      	movs	r0, #7
 8011122:	f7f0 fde9 	bl	8001cf8 <nvicEnableVector>
#endif
#ifdef EXT_CH2_HANDLER_FUNC
  nvicEnableVector(EXTI2_TSC_IRQn, STM32_EXT_EXTI2_IRQ_PRIORITY);
 8011126:	2106      	movs	r1, #6
 8011128:	2008      	movs	r0, #8
 801112a:	f7f0 fde5 	bl	8001cf8 <nvicEnableVector>
    defined(EXT_CH13_HANDLER_FUNC) || defined(EXT_CH14_HANDLER_FUNC) || defined(EXTI_CH15_HANDLER_FUNC)
  nvicEnableVector(EXTI15_10_IRQn, STM32_EXT_EXTI10_15_IRQ_PRIORITY);
#endif
//  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
//  nvicEnableVector(RTC_Alarm_IRQn, STM32_EXT_EXTI17_IRQ_PRIORITY);
}
 801112e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  nvicEnableVector(EXTI3_IRQn, STM32_EXT_EXTI3_IRQ_PRIORITY);
 8011132:	2106      	movs	r1, #6
 8011134:	2009      	movs	r0, #9
 8011136:	f7f0 bddf 	b.w	8001cf8 <nvicEnableVector>
 801113a:	bf00      	nop

0801113c <ext_channel_enable>:

void ext_channel_enable(uint16_t channel, uint16_t mode) {
  // Setting the associated GPIO for external channels.
  if (channel < 16) {
 801113c:	280f      	cmp	r0, #15
void ext_channel_enable(uint16_t channel, uint16_t mode) {
 801113e:	b510      	push	{r4, lr}
  if (channel < 16) {
 8011140:	d816      	bhi.n	8011170 <ext_channel_enable+0x34>
    uint16_t port =  (mode & EXT_MODE_GPIO_MASK) >> EXT_MODE_GPIO_OFF;
    uint32_t old_reg = SYSCFG->EXTICR[channel>>2] & ~(0xF << ((channel & 3) * 4));
 8011142:	0883      	lsrs	r3, r0, #2
 8011144:	009b      	lsls	r3, r3, #2
 8011146:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801114a:	f503 3380 	add.w	r3, r3, #65536	@ 0x10000
 801114e:	f000 0203 	and.w	r2, r0, #3
 8011152:	689c      	ldr	r4, [r3, #8]
 8011154:	0092      	lsls	r2, r2, #2
 8011156:	f04f 0c0f 	mov.w	ip, #15
 801115a:	fa0c fc02 	lsl.w	ip, ip, r2
 801115e:	ea24 0e0c 	bic.w	lr, r4, ip
    SYSCFG->EXTICR[channel>>2] = old_reg          |  (port<< ((channel & 3) * 4));
 8011162:	f3c1 1c03 	ubfx	ip, r1, #4, #4
 8011166:	fa0c f202 	lsl.w	r2, ip, r2
 801116a:	ea42 020e 	orr.w	r2, r2, lr
 801116e:	609a      	str	r2, [r3, #8]
  }
  uint32_t cmask = (1 << (channel & 0x1F));
  // Programming edge registers.
  if (mode & EXT_CH_MODE_RISING_EDGE)  EXTI->RTSR|= cmask;
 8011170:	4a0f      	ldr	r2, [pc, #60]	@ (80111b0 <ext_channel_enable+0x74>)
  uint32_t cmask = (1 << (channel & 0x1F));
 8011172:	f000 031f 	and.w	r3, r0, #31
 8011176:	2001      	movs	r0, #1
 8011178:	4098      	lsls	r0, r3
  if (mode & EXT_CH_MODE_RISING_EDGE)  EXTI->RTSR|= cmask;
 801117a:	6893      	ldr	r3, [r2, #8]
  else                                 EXTI->RTSR&=~cmask;
 801117c:	ea6f 0c00 	mvn.w	ip, r0
  if (mode & EXT_CH_MODE_RISING_EDGE)  EXTI->RTSR|= cmask;
 8011180:	07cc      	lsls	r4, r1, #31
 8011182:	bf4c      	ite	mi
 8011184:	4303      	orrmi	r3, r0
  else                                 EXTI->RTSR&=~cmask;
 8011186:	ea03 030c 	andpl.w	r3, r3, ip
 801118a:	6093      	str	r3, [r2, #8]
  if (mode & EXT_CH_MODE_FALLING_EDGE) EXTI->FTSR|= cmask;
 801118c:	4a08      	ldr	r2, [pc, #32]	@ (80111b0 <ext_channel_enable+0x74>)
 801118e:	68d3      	ldr	r3, [r2, #12]
 8011190:	0789      	lsls	r1, r1, #30
 8011192:	bf4c      	ite	mi
 8011194:	4303      	orrmi	r3, r0
  else                                 EXTI->FTSR&=~cmask;
 8011196:	ea03 030c 	andpl.w	r3, r3, ip
 801119a:	60d3      	str	r3, [r2, #12]
  // Programming interrupt and event registers.
  EXTI->IMR|= cmask;
 801119c:	4b04      	ldr	r3, [pc, #16]	@ (80111b0 <ext_channel_enable+0x74>)
 801119e:	681a      	ldr	r2, [r3, #0]
 80111a0:	4302      	orrs	r2, r0
 80111a2:	601a      	str	r2, [r3, #0]
  EXTI->EMR&=~cmask;
 80111a4:	685a      	ldr	r2, [r3, #4]
 80111a6:	ea02 020c 	and.w	r2, r2, ip
 80111aa:	605a      	str	r2, [r3, #4]
}
 80111ac:	bd10      	pop	{r4, pc}
 80111ae:	bf00      	nop
 80111b0:	40010400 	.word	0x40010400

080111b4 <initTimers>:
#if HAL_USE_GPT == FALSE
// Run TIM2 as us timer counter (used as STM32_ST_TIM timer in ChibiOS)
// Run TIM3 as ms timer counter
void initTimers(void) {
//  rccEnableTIM2(FALSE);
  rccEnableTIM3(FALSE);
 80111b4:	4906      	ldr	r1, [pc, #24]	@ (80111d0 <initTimers+0x1c>)
  // TIM2 use AHB1 bus clock (32 bit timer), use STM32_TIMCLK1 clock source
//  TIM2->PSC = STM32_TIMCLK1 / (1000000U) - 1; // 1MHz tick
  // TIM3 use AHB1 bus clock (16 bit timer), used in touch period handler
  TIM3->PSC = STM32_TIMCLK1 / (1000U) - 1;    // 1kHz tick
 80111b6:	4a07      	ldr	r2, [pc, #28]	@ (80111d4 <initTimers+0x20>)
  rccEnableTIM3(FALSE);
 80111b8:	69cb      	ldr	r3, [r1, #28]
void initTimers(void) {
 80111ba:	b410      	push	{r4}
  rccEnableTIM3(FALSE);
 80111bc:	f043 0302 	orr.w	r3, r3, #2
  TIM3->PSC = STM32_TIMCLK1 / (1000U) - 1;    // 1kHz tick
 80111c0:	4c05      	ldr	r4, [pc, #20]	@ (80111d8 <initTimers+0x24>)
  rccEnableTIM3(FALSE);
 80111c2:	61cb      	str	r3, [r1, #28]
  TIM3->CR2 = 0x20;                          // Generate TRIGO event for ADC watchdog
 80111c4:	2020      	movs	r0, #32
  TIM3->PSC = STM32_TIMCLK1 / (1000U) - 1;    // 1kHz tick
 80111c6:	6294      	str	r4, [r2, #40]	@ 0x28
}
 80111c8:	f85d 4b04 	ldr.w	r4, [sp], #4
  TIM3->CR2 = 0x20;                          // Generate TRIGO event for ADC watchdog
 80111cc:	6050      	str	r0, [r2, #4]
}
 80111ce:	4770      	bx	lr
 80111d0:	40021000 	.word	0x40021000
 80111d4:	40000400 	.word	0x40000400
 80111d8:	0001193f 	.word	0x0001193f

080111dc <startTimer>:

//
void startTimer(TIM_TypeDef *timer, uint32_t period) {
 80111dc:	b410      	push	{r4}
  timer->ARR = period - 1;
 80111de:	3901      	subs	r1, #1
  timer->EGR = STM32_TIM_EGR_UG;
 80111e0:	2401      	movs	r4, #1
  timer->CNT = 0;
 80111e2:	2200      	movs	r2, #0
  timer->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80111e4:	2305      	movs	r3, #5
  timer->ARR = period - 1;
 80111e6:	62c1      	str	r1, [r0, #44]	@ 0x2c
  timer->EGR = STM32_TIM_EGR_UG;
 80111e8:	6144      	str	r4, [r0, #20]
  timer->CNT = 0;
 80111ea:	6242      	str	r2, [r0, #36]	@ 0x24
}
 80111ec:	f85d 4b04 	ldr.w	r4, [sp], #4
  timer->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80111f0:	6003      	str	r3, [r0, #0]
}
 80111f2:	4770      	bx	lr

080111f4 <vna_sincosf>:
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 80111f4:	eef0 7ac0 	vabs.f32	s15, s0
  float f1, f2, d1, d2;     // Two nearest output values
  float fract, temp;

  // Round angle to range 0.0 to 1.0
  temp = vna_fabsf(angle);
  temp-= (uint32_t)temp;
 80111f8:	eebc 7ae7 	vcvt.u32.f32	s14, s15

  // Scale input from range 0.0 to 1.0 to table size
  temp*= FAST_MATH_TABLE_SIZE;
 80111fc:	eddf 6a44 	vldr	s13, [pc, #272]	@ 8011310 <vna_sincosf+0x11c>
  temp-= (uint32_t)temp;
 8011200:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
 8011204:	b510      	push	{r4, lr}
  temp-= (uint32_t)temp;
 8011206:	ee77 7ac7 	vsub.f32	s15, s15, s14
  temp*= FAST_MATH_TABLE_SIZE;
 801120a:	ee67 7aa6 	vmul.f32	s15, s15, s13

  indexS = temp;
 801120e:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 8011212:	ee17 3a10 	vmov	r3, s14
 8011216:	b29b      	uxth	r3, r3
  indexC = indexS + (FAST_MATH_TABLE_SIZE / 4); // cosine add 0.25 (pi/2) to read from sine table
  // Calculation of fractional value
  fract  = temp - indexS;
 8011218:	ee07 3a10 	vmov	s14, r3
  indexC = indexS + (FAST_MATH_TABLE_SIZE / 4); // cosine add 0.25 (pi/2) to read from sine table
 801121c:	f103 0280 	add.w	r2, r3, #128	@ 0x80
  fract  = temp - indexS;
 8011220:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  f1 = GET_SIN_TABLE(indexC  );
  f2 = GET_SIN_TABLE(indexC+1);
  d1 = GET_SIN_TABLE(indexS  );
  d2 = GET_SIN_TABLE(indexS+1);
#else
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 8011224:	f412 7f80 	tst.w	r2, #256	@ 0x100
 8011228:	f3c2 0c08 	ubfx	ip, r2, #0, #9
  fract  = temp - indexS;
 801122c:	ee77 7ac7 	vsub.f32	s15, s15, s14
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 8011230:	4a38      	ldr	r2, [pc, #224]	@ (8011314 <vna_sincosf+0x120>)
  indexS&= (FAST_MATH_TABLE_SIZE-1);
 8011232:	f3c3 0e08 	ubfx	lr, r3, #0, #9
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 8011236:	d148      	bne.n	80112ca <vna_sincosf+0xd6>
 8011238:	eb02 048c 	add.w	r4, r2, ip, lsl #2
  else             {f1 =-sin_table_512[indexC-256+0];f2 =-sin_table_512[indexC-256+1];}
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 801123c:	05db      	lsls	r3, r3, #23
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 801123e:	ed94 6a00 	vldr	s12, [r4]
 8011242:	edd4 4a01 	vldr	s9, [r4, #4]
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 8011246:	d452      	bmi.n	80112ee <vna_sincosf+0xfa>
 8011248:	eb02 038e 	add.w	r3, r2, lr, lsl #2
 801124c:	edd3 5a00 	vldr	s11, [r3]
 8011250:	ed93 4a01 	vldr	s8, [r3, #4]
 8011254:	469e      	mov	lr, r3
#if 1
  // 1e-7 error on 512 size table
  const float Dn = 2 * VNA_PI / FAST_MATH_TABLE_SIZE; // delta between the two points in table (fixed);
  float Df;
  // Calculation of cos value
  Df = f2 - f1; // delta between the values of the functions
 8011256:	ee74 6ac6 	vsub.f32	s13, s9, s12
  temp = Dn * (d1 + d2) + 2 * Df;
  temp = Df + (d1 * Dn + temp - fract * temp);
  temp = fract * temp - d1 * Dn;
  *pCosVal = f1 + fract * temp;
  // Calculation of sin value
  Df = d1 - d2; // delta between the values of the functions
 801125a:	ee35 7ac4 	vsub.f32	s14, s11, s8
  temp = Dn * (d1 + d2) + 2 * Df;
 801125e:	ed9f 5a2e 	vldr	s10, [pc, #184]	@ 8011318 <vna_sincosf+0x124>
 8011262:	ee35 4a84 	vadd.f32	s8, s11, s8
 8011266:	ee36 3aa6 	vadd.f32	s6, s13, s13
  temp = Dn * (f1 + f2) + 2 * Df;
 801126a:	ee77 3a07 	vadd.f32	s7, s14, s14
 801126e:	ee76 4a24 	vadd.f32	s9, s12, s9
  temp = Dn * (d1 + d2) + 2 * Df;
 8011272:	eea4 3a05 	vfma.f32	s6, s8, s10
  temp = Dn * (f1 + f2) + 2 * Df;
 8011276:	eeb0 4a63 	vmov.f32	s8, s7
 801127a:	eea4 4a85 	vfma.f32	s8, s9, s10
 801127e:	eea6 7a05 	vfma.f32	s14, s12, s10
 8011282:	eee5 6a85 	vfma.f32	s13, s11, s10
 8011286:	ee34 7a07 	vadd.f32	s14, s8, s14
 801128a:	ee73 6a26 	vadd.f32	s13, s6, s13
  temp = Df + (f1 * Dn + temp - fract * temp);
 801128e:	eea7 7ac4 	vfms.f32	s14, s15, s8
  temp = Df + (d1 * Dn + temp - fract * temp);
 8011292:	eee7 6ac3 	vfms.f32	s13, s15, s6
  temp = fract * temp - f1 * Dn;
 8011296:	ee27 7a87 	vmul.f32	s14, s15, s14
  temp = fract * temp - d1 * Dn;
 801129a:	ee67 6aa6 	vmul.f32	s13, s15, s13
  temp = fract * temp - f1 * Dn;
 801129e:	eea6 7a45 	vfms.f32	s14, s12, s10
  temp = fract * temp - d1 * Dn;
 80112a2:	eee5 6ac5 	vfms.f32	s13, s11, s10
  // 1e-5 error  on 512 size table
  // Calculation of sin and cos value, use simple linear interpolation
  *pCosVal = fract * (f2 - f1) + f1;
  *pSinVal = fract * (d2 - d1) + d1;
#endif
  if (angle < 0)
 80112a6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
  *pCosVal = f1 + fract * temp;
 80112aa:	eea7 6aa6 	vfma.f32	s12, s15, s13
  *pSinVal = d1 - fract * temp;
 80112ae:	ee67 7a87 	vmul.f32	s15, s15, s14
  if (angle < 0)
 80112b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  *pSinVal = d1 - fract * temp;
 80112b6:	bf54      	ite	pl
 80112b8:	ee75 7ae7 	vsubpl.f32	s15, s11, s15
    *pSinVal = -*pSinVal;
 80112bc:	ee77 7ae5 	vsubmi.f32	s15, s15, s11
  *pCosVal = f1 + fract * temp;
 80112c0:	ed81 6a00 	vstr	s12, [r1]
  *pSinVal = d1 - fract * temp;
 80112c4:	edc0 7a00 	vstr	s15, [r0]
#endif
}
 80112c8:	bd10      	pop	{r4, pc}
  else             {f1 =-sin_table_512[indexC-256+0];f2 =-sin_table_512[indexC-256+1];}
 80112ca:	f5ac 7480 	sub.w	r4, ip, #256	@ 0x100
 80112ce:	f1ac 0cff 	sub.w	ip, ip, #255	@ 0xff
 80112d2:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 80112d6:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 80112da:	ed94 6a00 	vldr	s12, [r4]
 80112de:	eddc 4a00 	vldr	s9, [ip]
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 80112e2:	05db      	lsls	r3, r3, #23
  else             {f1 =-sin_table_512[indexC-256+0];f2 =-sin_table_512[indexC-256+1];}
 80112e4:	eeb1 6a46 	vneg.f32	s12, s12
 80112e8:	eef1 4a64 	vneg.f32	s9, s9
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 80112ec:	d5ac      	bpl.n	8011248 <vna_sincosf+0x54>
  else             {d1 =-sin_table_512[indexS-256+0];d2 =-sin_table_512[indexS-256+1];}
 80112ee:	f5ae 7380 	sub.w	r3, lr, #256	@ 0x100
 80112f2:	f1ae 0eff 	sub.w	lr, lr, #255	@ 0xff
 80112f6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80112fa:	eb02 028e 	add.w	r2, r2, lr, lsl #2
 80112fe:	edd3 5a00 	vldr	s11, [r3]
 8011302:	ed92 4a00 	vldr	s8, [r2]
 8011306:	eef1 5a65 	vneg.f32	s11, s11
 801130a:	eeb1 4a44 	vneg.f32	s8, s8
 801130e:	e7a2      	b.n	8011256 <vna_sincosf+0x62>
 8011310:	44000000 	.word	0x44000000
 8011314:	08019a30 	.word	0x08019a30
 8011318:	3c490fdb 	.word	0x3c490fdb

0801131c <vna_logf>:

//**********************************************************************************
// logf
//**********************************************************************************
float vna_logf(float x)
{
 801131c:	ee10 3a10 	vmov	r3, s0
  // Give up to 0.00005 error (2x faster original code)
  // fast log2f approximation, give 0.0002 error
  union { float f; uint32_t i; } vx = { x };
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
  // if <=0 return NAN
  if (vx.i <=0) return -1/(x*x);
 8011320:	1e1a      	subs	r2, r3, #0
 8011322:	d01e      	beq.n	8011362 <vna_logf+0x46>
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
 8011324:	f3c2 0316 	ubfx	r3, r2, #0, #23
  return vx.i * (MULTIPLIER / (1 << 23)) - (124.22544637f * MULTIPLIER) - (1.498030302f * MULTIPLIER) * mx.f - (1.72587999f * MULTIPLIER) / (0.3520887068f + mx.f);
 8011328:	f043 537c 	orr.w	r3, r3, #1056964608	@ 0x3f000000
 801132c:	ee07 3a10 	vmov	s14, r3
 8011330:	eddf 6a0f 	vldr	s13, [pc, #60]	@ 8011370 <vna_logf+0x54>
 8011334:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 8011374 <vna_logf+0x58>
 8011338:	ed9f 0a0f 	vldr	s0, [pc, #60]	@ 8011378 <vna_logf+0x5c>
 801133c:	ee77 6a26 	vadd.f32	s13, s14, s13
 8011340:	ee07 2a90 	vmov	s15, r2
 8011344:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 8011348:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801134c:	eddf 5a0b 	vldr	s11, [pc, #44]	@ 801137c <vna_logf+0x60>
 8011350:	eddf 6a0b 	vldr	s13, [pc, #44]	@ 8011380 <vna_logf+0x64>
 8011354:	eea7 0aa5 	vfma.f32	s0, s15, s11
 8011358:	ee30 0a46 	vsub.f32	s0, s0, s12
 801135c:	eea7 0a66 	vfms.f32	s0, s14, s13
  R = t2 + t1;
  hfsq = 0.5f * f * f;
  dk = k;
  return s*(hfsq+R) + dk*ln2_lo - hfsq + f + dk*ln2_hi;
#endif
}
 8011360:	4770      	bx	lr
  if (vx.i <=0) return -1/(x*x);
 8011362:	ee60 7a00 	vmul.f32	s15, s0, s0
 8011366:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 801136a:	ee87 0a27 	vdiv.f32	s0, s14, s15
 801136e:	4770      	bx	lr
 8011370:	3eb444f9 	.word	0x3eb444f9
 8011374:	3f991ffe 	.word	0x3f991ffe
 8011378:	c2ac368a 	.word	0xc2ac368a
 801137c:	33b17218 	.word	0x33b17218
 8011380:	3f84e8d5 	.word	0x3f84e8d5

08011384 <vna_log10f_x_10>:

float vna_log10f_x_10(float x)
{
 8011384:	ee10 3a10 	vmov	r3, s0
  // Give up to 0.0001 error (2x faster original code)
  // fast log2f approximation, give 0.0004 error
  union { float f; uint32_t i; } vx = { x };
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
  // if <=0 return NAN
  if (vx.i <=0) return -1/(x*x);
 8011388:	1e1a      	subs	r2, r3, #0
 801138a:	d01e      	beq.n	80113ca <vna_log10f_x_10+0x46>
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
 801138c:	f3c2 0316 	ubfx	r3, r2, #0, #23
  return vx.i * (MULTIPLIER / (1 << 23)) - (124.22544637f * MULTIPLIER) - (1.498030302f * MULTIPLIER) * mx.f - (1.72587999f * MULTIPLIER) / (0.3520887068f + mx.f);
 8011390:	f043 537c 	orr.w	r3, r3, #1056964608	@ 0x3f000000
 8011394:	ee07 3a10 	vmov	s14, r3
 8011398:	eddf 6a0f 	vldr	s13, [pc, #60]	@ 80113d8 <vna_log10f_x_10+0x54>
 801139c:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 80113dc <vna_log10f_x_10+0x58>
 80113a0:	ed9f 0a0f 	vldr	s0, [pc, #60]	@ 80113e0 <vna_log10f_x_10+0x5c>
 80113a4:	ee77 6a26 	vadd.f32	s13, s14, s13
 80113a8:	ee07 2a90 	vmov	s15, r2
 80113ac:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 80113b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80113b4:	eddf 5a0b 	vldr	s11, [pc, #44]	@ 80113e4 <vna_log10f_x_10+0x60>
 80113b8:	eddf 6a0b 	vldr	s13, [pc, #44]	@ 80113e8 <vna_log10f_x_10+0x64>
 80113bc:	eea7 0aa5 	vfma.f32	s0, s15, s11
 80113c0:	ee30 0a46 	vsub.f32	s0, s0, s12
 80113c4:	eea7 0a66 	vfms.f32	s0, s14, s13
#endif
}
 80113c8:	4770      	bx	lr
  if (vx.i <=0) return -1/(x*x);
 80113ca:	ee60 7a00 	vmul.f32	s15, s0, s0
 80113ce:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 80113d2:	ee87 0a27 	vdiv.f32	s0, s14, s15
 80113d6:	4770      	bx	lr
 80113d8:	3eb444f9 	.word	0x3eb444f9
 80113dc:	40a640da 	.word	0x40a640da
 80113e0:	c3bafa5a 	.word	0xc3bafa5a
 80113e4:	34c0a8c1 	.word	0x34c0a8c1
 80113e8:	40904dfe 	.word	0x40904dfe

080113ec <vna_atan2f>:
#else
// Polynomial approximation to atan2f
float vna_atan2f(float y, float x)
{
  union {float f; int32_t i;} ux = {x};
  union {float f; int32_t i;} uy = {y};
 80113ec:	ee10 3a10 	vmov	r3, s0
  union {float f; int32_t i;} ux = {x};
 80113f0:	ee10 2a90 	vmov	r2, s1
  if (ux.i == 0 && uy.i == 0)
 80113f4:	ea53 0102 	orrs.w	r1, r3, r2
 80113f8:	d042      	beq.n	8011480 <vna_atan2f+0x94>
 80113fa:	eef0 0ae0 	vabs.f32	s1, s1
 80113fe:	eeb0 0ac0 	vabs.f32	s0, s0
    return 0.0f;

  float ax, ay, r, s;
  ax = vna_fabsf(x);
  ay = vna_fabsf(y);
  r = (ay < ax) ? ay / ax : ax / ay;
 8011402:	eef4 0ac0 	vcmpe.f32	s1, s0
 8011406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801140a:	dc21      	bgt.n	8011450 <vna_atan2f+0x64>
 801140c:	eec0 7a80 	vdiv.f32	s15, s1, s0
  r*= 0.994949366116654f - s * (0.287060635532652f - 0.078037176446441f * s);
  //r*= vna_fmaf(-s, vna_fmaf(-s, 0.078037176446441f, 0.287060635532652f), 0.994949366116654f);
  //r*= 0.995354f  s * (0.288679f + 0.079331f * s);
#else
  // give 0.005 degree error
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 8011410:	eddf 5a1d 	vldr	s11, [pc, #116]	@ 8011488 <vna_atan2f+0x9c>
 8011414:	ed9f 6a1d 	vldr	s12, [pc, #116]	@ 801148c <vna_atan2f+0xa0>
 8011418:	eddf 6a1d 	vldr	s13, [pc, #116]	@ 8011490 <vna_atan2f+0xa4>
 801141c:	ed9f 0a1d 	vldr	s0, [pc, #116]	@ 8011494 <vna_atan2f+0xa8>
  s = r * r;
 8011420:	ee27 7aa7 	vmul.f32	s14, s15, s15
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 8011424:	eea7 6a65 	vfms.f32	s12, s14, s11
 8011428:	eee6 6a07 	vfma.f32	s13, s12, s14
 801142c:	eea6 0a87 	vfma.f32	s0, s13, s14
 8011430:	ee20 0a27 	vmul.f32	s0, s0, s15
  //r*= vna_fmaf(-s, vna_fmaf(-s, vna_fmaf(-s, 0.038254464970299f, 0.144982490144465f), 0.320533292381664f), 0.999133448222780f);
#endif
  // Map to full circle
  if (ay  > ax) r = VNA_PI/2.0f - r;
 8011434:	bf44      	itt	mi
 8011436:	eddf 7a18 	vldrmi	s15, [pc, #96]	@ 8011498 <vna_atan2f+0xac>
 801143a:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
  if (ux.i < 0) r = VNA_PI      - r;
 801143e:	2a00      	cmp	r2, #0
 8011440:	bfbc      	itt	lt
 8011442:	eddf 7a16 	vldrlt	s15, [pc, #88]	@ 801149c <vna_atan2f+0xb0>
 8011446:	ee37 0ac0 	vsublt.f32	s0, s15, s0
  if (uy.i < 0) r = -r;
 801144a:	2b00      	cmp	r3, #0
 801144c:	db15      	blt.n	801147a <vna_atan2f+0x8e>
  return r;
}
 801144e:	4770      	bx	lr
  r = (ay < ax) ? ay / ax : ax / ay;
 8011450:	eec0 7a20 	vdiv.f32	s15, s0, s1
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 8011454:	ed9f 5a0c 	vldr	s10, [pc, #48]	@ 8011488 <vna_atan2f+0x9c>
 8011458:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 801148c <vna_atan2f+0xa0>
 801145c:	ed9f 6a0c 	vldr	s12, [pc, #48]	@ 8011490 <vna_atan2f+0xa4>
 8011460:	ed9f 7a0c 	vldr	s14, [pc, #48]	@ 8011494 <vna_atan2f+0xa8>
  s = r * r;
 8011464:	ee67 6aa7 	vmul.f32	s13, s15, s15
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 8011468:	eee6 5ac5 	vfms.f32	s11, s13, s10
 801146c:	eea5 6aa6 	vfma.f32	s12, s11, s13
 8011470:	eea6 7a26 	vfma.f32	s14, s12, s13
 8011474:	ee27 0a87 	vmul.f32	s0, s15, s14
  if (ay  > ax) r = VNA_PI/2.0f - r;
 8011478:	e7e1      	b.n	801143e <vna_atan2f+0x52>
  if (uy.i < 0) r = -r;
 801147a:	eeb1 0a40 	vneg.f32	s0, s0
 801147e:	4770      	bx	lr
    return 0.0f;
 8011480:	ed9f 0a07 	vldr	s0, [pc, #28]	@ 80114a0 <vna_atan2f+0xb4>
}
 8011484:	4770      	bx	lr
 8011486:	bf00      	nop
 8011488:	3d1cb0b7 	.word	0x3d1cb0b7
 801148c:	3e14764a 	.word	0x3e14764a
 8011490:	bea41cf1 	.word	0xbea41cf1
 8011494:	3f7fc736 	.word	0x3f7fc736
 8011498:	3fc90fdb 	.word	0x3fc90fdb
 801149c:	40490fdb 	.word	0x40490fdb
 80114a0:	00000000 	.word	0x00000000

080114a4 <vna_expf>:
// Fast expf approximation
//**********************************************************************************
float vna_expf(float x)
{
  union { float f; int32_t i; } v;
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 80114a4:	eddf 7a12 	vldr	s15, [pc, #72]	@ 80114f0 <vna_expf+0x4c>
 80114a8:	ee20 0a27 	vmul.f32	s0, s0, s15
  int32_t m = (v.i >> 7) & 0xFFFF;  // copy mantissa
#if 1
  // cubic spline approximation, empirical values for small maximum relative error (8.34e-5):
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 80114ac:	f240 40fd 	movw	r0, #1277	@ 0x4fd
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 80114b0:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 80114b4:	f643 13e9 	movw	r3, #14825	@ 0x39e9
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 80114b8:	ee17 2a90 	vmov	r2, s15
  int32_t m = (v.i >> 7) & 0xFFFF;  // copy mantissa
 80114bc:	f3c2 11cf 	ubfx	r1, r2, #7, #16
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 80114c0:	fb01 f000 	mul.w	r0, r1, r0
 80114c4:	eb03 33a0 	add.w	r3, r3, r0, asr #14
 80114c8:	fb01 f303 	mul.w	r3, r1, r3
 80114cc:	139b      	asrs	r3, r3, #14
 80114ce:	f46f 70c2 	mvn.w	r0, #388	@ 0x184
 80114d2:	f5a3 339b 	sub.w	r3, r3, #79360	@ 0x13600
 80114d6:	4403      	add	r3, r0
 80114d8:	fb01 f303 	mul.w	r3, r1, r3
 80114dc:	12db      	asrs	r3, r3, #11
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 80114de:	f102 527e 	add.w	r2, r2, #1065353216	@ 0x3f800000
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 80114e2:	f2a3 2372 	subw	r3, r3, #626	@ 0x272
#else
  // quartic spline approximation, empirical values for small maximum relative error (1.21e-5):
  v.i += (((((((((((3537*m) >> 16) + 13668)*m) >> 18) + 15817)*m) >> 14) - 80470)*m) >> 11);
#endif
  return v.f;
 80114e6:	4413      	add	r3, r2
 80114e8:	ee00 3a10 	vmov	s0, r3
}
 80114ec:	4770      	bx	lr
 80114ee:	bf00      	nop
 80114f0:	4b38aa3b 	.word	0x4b38aa3b

080114f4 <infinityf>:
 80114f4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 80114fc <infinityf+0x8>
 80114f8:	4770      	bx	lr
 80114fa:	bf00      	nop
 80114fc:	7f800000 	.word	0x7f800000

08011500 <__udivmoddi4>:
 8011500:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011504:	9d08      	ldr	r5, [sp, #32]
 8011506:	460f      	mov	r7, r1
 8011508:	4604      	mov	r4, r0
 801150a:	468c      	mov	ip, r1
 801150c:	2b00      	cmp	r3, #0
 801150e:	d148      	bne.n	80115a2 <__udivmoddi4+0xa2>
 8011510:	428a      	cmp	r2, r1
 8011512:	4616      	mov	r6, r2
 8011514:	d961      	bls.n	80115da <__udivmoddi4+0xda>
 8011516:	fab2 f382 	clz	r3, r2
 801151a:	b14b      	cbz	r3, 8011530 <__udivmoddi4+0x30>
 801151c:	f1c3 0220 	rsb	r2, r3, #32
 8011520:	fa01 fc03 	lsl.w	ip, r1, r3
 8011524:	fa20 f202 	lsr.w	r2, r0, r2
 8011528:	409e      	lsls	r6, r3
 801152a:	ea42 0c0c 	orr.w	ip, r2, ip
 801152e:	409c      	lsls	r4, r3
 8011530:	ea4f 4e16 	mov.w	lr, r6, lsr #16
 8011534:	b2b7      	uxth	r7, r6
 8011536:	fbbc f1fe 	udiv	r1, ip, lr
 801153a:	0c22      	lsrs	r2, r4, #16
 801153c:	fb0e cc11 	mls	ip, lr, r1, ip
 8011540:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 8011544:	fb01 f007 	mul.w	r0, r1, r7
 8011548:	4290      	cmp	r0, r2
 801154a:	d909      	bls.n	8011560 <__udivmoddi4+0x60>
 801154c:	18b2      	adds	r2, r6, r2
 801154e:	f101 3cff 	add.w	ip, r1, #4294967295
 8011552:	f080 80ee 	bcs.w	8011732 <__udivmoddi4+0x232>
 8011556:	4290      	cmp	r0, r2
 8011558:	f240 80eb 	bls.w	8011732 <__udivmoddi4+0x232>
 801155c:	3902      	subs	r1, #2
 801155e:	4432      	add	r2, r6
 8011560:	1a12      	subs	r2, r2, r0
 8011562:	b2a4      	uxth	r4, r4
 8011564:	fbb2 f0fe 	udiv	r0, r2, lr
 8011568:	fb0e 2210 	mls	r2, lr, r0, r2
 801156c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8011570:	fb00 f707 	mul.w	r7, r0, r7
 8011574:	42a7      	cmp	r7, r4
 8011576:	d909      	bls.n	801158c <__udivmoddi4+0x8c>
 8011578:	1934      	adds	r4, r6, r4
 801157a:	f100 32ff 	add.w	r2, r0, #4294967295
 801157e:	f080 80da 	bcs.w	8011736 <__udivmoddi4+0x236>
 8011582:	42a7      	cmp	r7, r4
 8011584:	f240 80d7 	bls.w	8011736 <__udivmoddi4+0x236>
 8011588:	4434      	add	r4, r6
 801158a:	3802      	subs	r0, #2
 801158c:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8011590:	1be4      	subs	r4, r4, r7
 8011592:	2100      	movs	r1, #0
 8011594:	b11d      	cbz	r5, 801159e <__udivmoddi4+0x9e>
 8011596:	40dc      	lsrs	r4, r3
 8011598:	2300      	movs	r3, #0
 801159a:	e9c5 4300 	strd	r4, r3, [r5]
 801159e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80115a2:	428b      	cmp	r3, r1
 80115a4:	d906      	bls.n	80115b4 <__udivmoddi4+0xb4>
 80115a6:	b10d      	cbz	r5, 80115ac <__udivmoddi4+0xac>
 80115a8:	e9c5 0100 	strd	r0, r1, [r5]
 80115ac:	2100      	movs	r1, #0
 80115ae:	4608      	mov	r0, r1
 80115b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80115b4:	fab3 f183 	clz	r1, r3
 80115b8:	2900      	cmp	r1, #0
 80115ba:	d148      	bne.n	801164e <__udivmoddi4+0x14e>
 80115bc:	42bb      	cmp	r3, r7
 80115be:	d302      	bcc.n	80115c6 <__udivmoddi4+0xc6>
 80115c0:	4282      	cmp	r2, r0
 80115c2:	f200 8107 	bhi.w	80117d4 <__udivmoddi4+0x2d4>
 80115c6:	1a84      	subs	r4, r0, r2
 80115c8:	eb67 0203 	sbc.w	r2, r7, r3
 80115cc:	2001      	movs	r0, #1
 80115ce:	4694      	mov	ip, r2
 80115d0:	2d00      	cmp	r5, #0
 80115d2:	d0e4      	beq.n	801159e <__udivmoddi4+0x9e>
 80115d4:	e9c5 4c00 	strd	r4, ip, [r5]
 80115d8:	e7e1      	b.n	801159e <__udivmoddi4+0x9e>
 80115da:	2a00      	cmp	r2, #0
 80115dc:	f000 8092 	beq.w	8011704 <__udivmoddi4+0x204>
 80115e0:	fab2 f382 	clz	r3, r2
 80115e4:	2b00      	cmp	r3, #0
 80115e6:	f040 80a8 	bne.w	801173a <__udivmoddi4+0x23a>
 80115ea:	1a8a      	subs	r2, r1, r2
 80115ec:	ea4f 4e16 	mov.w	lr, r6, lsr #16
 80115f0:	fa1f fc86 	uxth.w	ip, r6
 80115f4:	2101      	movs	r1, #1
 80115f6:	0c20      	lsrs	r0, r4, #16
 80115f8:	fbb2 f7fe 	udiv	r7, r2, lr
 80115fc:	fb0e 2217 	mls	r2, lr, r7, r2
 8011600:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
 8011604:	fb0c f007 	mul.w	r0, ip, r7
 8011608:	4290      	cmp	r0, r2
 801160a:	d907      	bls.n	801161c <__udivmoddi4+0x11c>
 801160c:	18b2      	adds	r2, r6, r2
 801160e:	f107 38ff 	add.w	r8, r7, #4294967295
 8011612:	d202      	bcs.n	801161a <__udivmoddi4+0x11a>
 8011614:	4290      	cmp	r0, r2
 8011616:	f200 80e2 	bhi.w	80117de <__udivmoddi4+0x2de>
 801161a:	4647      	mov	r7, r8
 801161c:	1a12      	subs	r2, r2, r0
 801161e:	b2a4      	uxth	r4, r4
 8011620:	fbb2 f0fe 	udiv	r0, r2, lr
 8011624:	fb0e 2210 	mls	r2, lr, r0, r2
 8011628:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 801162c:	fb0c fc00 	mul.w	ip, ip, r0
 8011630:	45a4      	cmp	ip, r4
 8011632:	d907      	bls.n	8011644 <__udivmoddi4+0x144>
 8011634:	1934      	adds	r4, r6, r4
 8011636:	f100 32ff 	add.w	r2, r0, #4294967295
 801163a:	d202      	bcs.n	8011642 <__udivmoddi4+0x142>
 801163c:	45a4      	cmp	ip, r4
 801163e:	f200 80cb 	bhi.w	80117d8 <__udivmoddi4+0x2d8>
 8011642:	4610      	mov	r0, r2
 8011644:	eba4 040c 	sub.w	r4, r4, ip
 8011648:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 801164c:	e7a2      	b.n	8011594 <__udivmoddi4+0x94>
 801164e:	f1c1 0620 	rsb	r6, r1, #32
 8011652:	408b      	lsls	r3, r1
 8011654:	fa22 fc06 	lsr.w	ip, r2, r6
 8011658:	ea4c 0c03 	orr.w	ip, ip, r3
 801165c:	fa07 f401 	lsl.w	r4, r7, r1
 8011660:	fa20 f306 	lsr.w	r3, r0, r6
 8011664:	40f7      	lsrs	r7, r6
 8011666:	ea4f 491c 	mov.w	r9, ip, lsr #16
 801166a:	4323      	orrs	r3, r4
 801166c:	fa00 f801 	lsl.w	r8, r0, r1
 8011670:	fa1f fe8c 	uxth.w	lr, ip
 8011674:	fbb7 f0f9 	udiv	r0, r7, r9
 8011678:	0c1c      	lsrs	r4, r3, #16
 801167a:	fb09 7710 	mls	r7, r9, r0, r7
 801167e:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 8011682:	fb00 f70e 	mul.w	r7, r0, lr
 8011686:	42a7      	cmp	r7, r4
 8011688:	fa02 f201 	lsl.w	r2, r2, r1
 801168c:	d90a      	bls.n	80116a4 <__udivmoddi4+0x1a4>
 801168e:	eb1c 0404 	adds.w	r4, ip, r4
 8011692:	f100 3aff 	add.w	sl, r0, #4294967295
 8011696:	f080 809b 	bcs.w	80117d0 <__udivmoddi4+0x2d0>
 801169a:	42a7      	cmp	r7, r4
 801169c:	f240 8098 	bls.w	80117d0 <__udivmoddi4+0x2d0>
 80116a0:	3802      	subs	r0, #2
 80116a2:	4464      	add	r4, ip
 80116a4:	1be4      	subs	r4, r4, r7
 80116a6:	b29f      	uxth	r7, r3
 80116a8:	fbb4 f3f9 	udiv	r3, r4, r9
 80116ac:	fb09 4413 	mls	r4, r9, r3, r4
 80116b0:	ea47 4404 	orr.w	r4, r7, r4, lsl #16
 80116b4:	fb03 fe0e 	mul.w	lr, r3, lr
 80116b8:	45a6      	cmp	lr, r4
 80116ba:	d909      	bls.n	80116d0 <__udivmoddi4+0x1d0>
 80116bc:	eb1c 0404 	adds.w	r4, ip, r4
 80116c0:	f103 37ff 	add.w	r7, r3, #4294967295
 80116c4:	f080 8082 	bcs.w	80117cc <__udivmoddi4+0x2cc>
 80116c8:	45a6      	cmp	lr, r4
 80116ca:	d97f      	bls.n	80117cc <__udivmoddi4+0x2cc>
 80116cc:	3b02      	subs	r3, #2
 80116ce:	4464      	add	r4, ip
 80116d0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80116d4:	eba4 040e 	sub.w	r4, r4, lr
 80116d8:	fba0 e702 	umull	lr, r7, r0, r2
 80116dc:	42bc      	cmp	r4, r7
 80116de:	4673      	mov	r3, lr
 80116e0:	46b9      	mov	r9, r7
 80116e2:	d363      	bcc.n	80117ac <__udivmoddi4+0x2ac>
 80116e4:	d060      	beq.n	80117a8 <__udivmoddi4+0x2a8>
 80116e6:	b15d      	cbz	r5, 8011700 <__udivmoddi4+0x200>
 80116e8:	ebb8 0203 	subs.w	r2, r8, r3
 80116ec:	eb64 0409 	sbc.w	r4, r4, r9
 80116f0:	fa04 f606 	lsl.w	r6, r4, r6
 80116f4:	fa22 f301 	lsr.w	r3, r2, r1
 80116f8:	431e      	orrs	r6, r3
 80116fa:	40cc      	lsrs	r4, r1
 80116fc:	e9c5 6400 	strd	r6, r4, [r5]
 8011700:	2100      	movs	r1, #0
 8011702:	e74c      	b.n	801159e <__udivmoddi4+0x9e>
 8011704:	0862      	lsrs	r2, r4, #1
 8011706:	0848      	lsrs	r0, r1, #1
 8011708:	ea42 71c1 	orr.w	r1, r2, r1, lsl #31
 801170c:	0c0b      	lsrs	r3, r1, #16
 801170e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8011712:	b28a      	uxth	r2, r1
 8011714:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 8011718:	fbb3 f1f6 	udiv	r1, r3, r6
 801171c:	07e4      	lsls	r4, r4, #31
 801171e:	46b4      	mov	ip, r6
 8011720:	4637      	mov	r7, r6
 8011722:	46b6      	mov	lr, r6
 8011724:	231f      	movs	r3, #31
 8011726:	fbb0 f0f6 	udiv	r0, r0, r6
 801172a:	1bd2      	subs	r2, r2, r7
 801172c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8011730:	e761      	b.n	80115f6 <__udivmoddi4+0xf6>
 8011732:	4661      	mov	r1, ip
 8011734:	e714      	b.n	8011560 <__udivmoddi4+0x60>
 8011736:	4610      	mov	r0, r2
 8011738:	e728      	b.n	801158c <__udivmoddi4+0x8c>
 801173a:	f1c3 0120 	rsb	r1, r3, #32
 801173e:	fa20 f201 	lsr.w	r2, r0, r1
 8011742:	409e      	lsls	r6, r3
 8011744:	fa27 f101 	lsr.w	r1, r7, r1
 8011748:	409f      	lsls	r7, r3
 801174a:	433a      	orrs	r2, r7
 801174c:	ea4f 4e16 	mov.w	lr, r6, lsr #16
 8011750:	fa1f fc86 	uxth.w	ip, r6
 8011754:	fbb1 f7fe 	udiv	r7, r1, lr
 8011758:	fb0e 1017 	mls	r0, lr, r7, r1
 801175c:	0c11      	lsrs	r1, r2, #16
 801175e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8011762:	fb07 f80c 	mul.w	r8, r7, ip
 8011766:	4588      	cmp	r8, r1
 8011768:	fa04 f403 	lsl.w	r4, r4, r3
 801176c:	d93a      	bls.n	80117e4 <__udivmoddi4+0x2e4>
 801176e:	1871      	adds	r1, r6, r1
 8011770:	f107 30ff 	add.w	r0, r7, #4294967295
 8011774:	d201      	bcs.n	801177a <__udivmoddi4+0x27a>
 8011776:	4588      	cmp	r8, r1
 8011778:	d81f      	bhi.n	80117ba <__udivmoddi4+0x2ba>
 801177a:	eba1 0108 	sub.w	r1, r1, r8
 801177e:	fbb1 f8fe 	udiv	r8, r1, lr
 8011782:	fb08 f70c 	mul.w	r7, r8, ip
 8011786:	fb0e 1118 	mls	r1, lr, r8, r1
 801178a:	b292      	uxth	r2, r2
 801178c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8011790:	42ba      	cmp	r2, r7
 8011792:	d22f      	bcs.n	80117f4 <__udivmoddi4+0x2f4>
 8011794:	18b2      	adds	r2, r6, r2
 8011796:	f108 31ff 	add.w	r1, r8, #4294967295
 801179a:	d2c6      	bcs.n	801172a <__udivmoddi4+0x22a>
 801179c:	42ba      	cmp	r2, r7
 801179e:	d2c4      	bcs.n	801172a <__udivmoddi4+0x22a>
 80117a0:	f1a8 0102 	sub.w	r1, r8, #2
 80117a4:	4432      	add	r2, r6
 80117a6:	e7c0      	b.n	801172a <__udivmoddi4+0x22a>
 80117a8:	45f0      	cmp	r8, lr
 80117aa:	d29c      	bcs.n	80116e6 <__udivmoddi4+0x1e6>
 80117ac:	ebbe 0302 	subs.w	r3, lr, r2
 80117b0:	eb67 070c 	sbc.w	r7, r7, ip
 80117b4:	3801      	subs	r0, #1
 80117b6:	46b9      	mov	r9, r7
 80117b8:	e795      	b.n	80116e6 <__udivmoddi4+0x1e6>
 80117ba:	eba6 0808 	sub.w	r8, r6, r8
 80117be:	4441      	add	r1, r8
 80117c0:	1eb8      	subs	r0, r7, #2
 80117c2:	fbb1 f8fe 	udiv	r8, r1, lr
 80117c6:	fb08 f70c 	mul.w	r7, r8, ip
 80117ca:	e7dc      	b.n	8011786 <__udivmoddi4+0x286>
 80117cc:	463b      	mov	r3, r7
 80117ce:	e77f      	b.n	80116d0 <__udivmoddi4+0x1d0>
 80117d0:	4650      	mov	r0, sl
 80117d2:	e767      	b.n	80116a4 <__udivmoddi4+0x1a4>
 80117d4:	4608      	mov	r0, r1
 80117d6:	e6fb      	b.n	80115d0 <__udivmoddi4+0xd0>
 80117d8:	4434      	add	r4, r6
 80117da:	3802      	subs	r0, #2
 80117dc:	e732      	b.n	8011644 <__udivmoddi4+0x144>
 80117de:	3f02      	subs	r7, #2
 80117e0:	4432      	add	r2, r6
 80117e2:	e71b      	b.n	801161c <__udivmoddi4+0x11c>
 80117e4:	eba1 0108 	sub.w	r1, r1, r8
 80117e8:	4638      	mov	r0, r7
 80117ea:	fbb1 f8fe 	udiv	r8, r1, lr
 80117ee:	fb08 f70c 	mul.w	r7, r8, ip
 80117f2:	e7c8      	b.n	8011786 <__udivmoddi4+0x286>
 80117f4:	4641      	mov	r1, r8
 80117f6:	e798      	b.n	801172a <__udivmoddi4+0x22a>

080117f8 <memmove>:
 80117f8:	4288      	cmp	r0, r1
 80117fa:	b510      	push	{r4, lr}
 80117fc:	eb01 0402 	add.w	r4, r1, r2
 8011800:	d902      	bls.n	8011808 <memmove+0x10>
 8011802:	4284      	cmp	r4, r0
 8011804:	4623      	mov	r3, r4
 8011806:	d807      	bhi.n	8011818 <memmove+0x20>
 8011808:	1e43      	subs	r3, r0, #1
 801180a:	42a1      	cmp	r1, r4
 801180c:	d007      	beq.n	801181e <memmove+0x26>
 801180e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8011812:	f803 2f01 	strb.w	r2, [r3, #1]!
 8011816:	e7f8      	b.n	801180a <memmove+0x12>
 8011818:	4402      	add	r2, r0
 801181a:	4282      	cmp	r2, r0
 801181c:	d100      	bne.n	8011820 <memmove+0x28>
 801181e:	bd10      	pop	{r4, pc}
 8011820:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 8011824:	f802 1d01 	strb.w	r1, [r2, #-1]!
 8011828:	e7f7      	b.n	801181a <memmove+0x22>
	...

0801182c <memset>:
 801182c:	4402      	add	r2, r0
 801182e:	4603      	mov	r3, r0
 8011830:	4293      	cmp	r3, r2
 8011832:	d100      	bne.n	8011836 <memset+0xa>
 8011834:	4770      	bx	lr
 8011836:	f803 1b01 	strb.w	r1, [r3], #1
 801183a:	e7f9      	b.n	8011830 <memset+0x4>

0801183c <strncpy>:
 801183c:	b510      	push	{r4, lr}
 801183e:	3901      	subs	r1, #1
 8011840:	4603      	mov	r3, r0
 8011842:	b132      	cbz	r2, 8011852 <strncpy+0x16>
 8011844:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8011848:	f803 4b01 	strb.w	r4, [r3], #1
 801184c:	3a01      	subs	r2, #1
 801184e:	2c00      	cmp	r4, #0
 8011850:	d1f7      	bne.n	8011842 <strncpy+0x6>
 8011852:	441a      	add	r2, r3
 8011854:	2100      	movs	r1, #0
 8011856:	4293      	cmp	r3, r2
 8011858:	d100      	bne.n	801185c <strncpy+0x20>
 801185a:	bd10      	pop	{r4, pc}
 801185c:	f803 1b01 	strb.w	r1, [r3], #1
 8011860:	e7f9      	b.n	8011856 <strncpy+0x1a>
	...

08011864 <memcpy>:
 8011864:	440a      	add	r2, r1
 8011866:	4291      	cmp	r1, r2
 8011868:	f100 33ff 	add.w	r3, r0, #4294967295
 801186c:	d100      	bne.n	8011870 <memcpy+0xc>
 801186e:	4770      	bx	lr
 8011870:	b510      	push	{r4, lr}
 8011872:	f811 4b01 	ldrb.w	r4, [r1], #1
 8011876:	f803 4f01 	strb.w	r4, [r3, #1]!
 801187a:	4291      	cmp	r1, r2
 801187c:	d1f9      	bne.n	8011872 <memcpy+0xe>
 801187e:	bd10      	pop	{r4, pc}
