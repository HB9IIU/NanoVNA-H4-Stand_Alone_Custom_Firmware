
build/H4.elf:     file format elf32-littlearm


Disassembly of section .text:

080001a0 <Reset_Handler>:
 80001a0:	b672      	cpsid	i
 80001a2:	4834      	ldr	r0, [pc, #208]	@ (8000274 <endfiniloop+0x4>)
 80001a4:	f380 8809 	msr	PSP, r0
 80001a8:	f240 0000 	movw	r0, #0
 80001ac:	f2cc 0000 	movt	r0, #49152	@ 0xc000
 80001b0:	f64e 7134 	movw	r1, #61236	@ 0xef34
 80001b4:	f2ce 0100 	movt	r1, #57344	@ 0xe000
 80001b8:	6008      	str	r0, [r1, #0]
 80001ba:	f3bf 8f4f 	dsb	sy
 80001be:	f3bf 8f6f 	isb	sy
 80001c2:	f240 0000 	movw	r0, #0
 80001c6:	f2c0 00f0 	movt	r0, #240	@ 0xf0
 80001ca:	f64e 5188 	movw	r1, #60808	@ 0xed88
 80001ce:	f2ce 0100 	movt	r1, #57344	@ 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	f3bf 8f4f 	dsb	sy
 80001d8:	f3bf 8f6f 	isb	sy
 80001dc:	f04f 0000 	mov.w	r0, #0
 80001e0:	eee1 0a10 	vmsr	fpscr, r0
 80001e4:	f64e 713c 	movw	r1, #61244	@ 0xef3c
 80001e8:	f2ce 0100 	movt	r1, #57344	@ 0xe000
 80001ec:	6008      	str	r0, [r1, #0]
 80001ee:	2006      	movs	r0, #6
 80001f0:	f380 8814 	msr	CONTROL, r0
 80001f4:	f3bf 8f6f 	isb	sy
 80001f8:	f000 fbaa 	bl	8000950 <__core_init>
 80001fc:	f002 f972 	bl	80024e4 <__early_init>
 8000200:	f04f 3055 	mov.w	r0, #1431655765	@ 0x55555555
 8000204:	491c      	ldr	r1, [pc, #112]	@ (8000278 <endfiniloop+0x8>)
 8000206:	4a1d      	ldr	r2, [pc, #116]	@ (800027c <endfiniloop+0xc>)

08000208 <msloop>:
 8000208:	4291      	cmp	r1, r2
 800020a:	bf3c      	itt	cc
 800020c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000210:	e7fa      	bcc.n	8000208 <msloop>
 8000212:	491b      	ldr	r1, [pc, #108]	@ (8000280 <endfiniloop+0x10>)
 8000214:	4a17      	ldr	r2, [pc, #92]	@ (8000274 <endfiniloop+0x4>)

08000216 <psloop>:
 8000216:	4291      	cmp	r1, r2
 8000218:	bf3c      	itt	cc
 800021a:	f841 0b04 	strcc.w	r0, [r1], #4
 800021e:	e7fa      	bcc.n	8000216 <psloop>
 8000220:	4918      	ldr	r1, [pc, #96]	@ (8000284 <endfiniloop+0x14>)
 8000222:	4a19      	ldr	r2, [pc, #100]	@ (8000288 <endfiniloop+0x18>)
 8000224:	4b19      	ldr	r3, [pc, #100]	@ (800028c <endfiniloop+0x1c>)

08000226 <dloop>:
 8000226:	429a      	cmp	r2, r3
 8000228:	bf3e      	ittt	cc
 800022a:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800022e:	f842 0b04 	strcc.w	r0, [r2], #4
 8000232:	e7f8      	bcc.n	8000226 <dloop>
 8000234:	2000      	movs	r0, #0
 8000236:	4916      	ldr	r1, [pc, #88]	@ (8000290 <endfiniloop+0x20>)
 8000238:	4a16      	ldr	r2, [pc, #88]	@ (8000294 <endfiniloop+0x24>)

0800023a <bloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <bloop>
 8000244:	f000 fb8a 	bl	800095c <__init_ram_areas>
 8000248:	f000 fb84 	bl	8000954 <__late_init>
 800024c:	4c12      	ldr	r4, [pc, #72]	@ (8000298 <endfiniloop+0x28>)
 800024e:	4d13      	ldr	r5, [pc, #76]	@ (800029c <endfiniloop+0x2c>)

08000250 <initloop>:
 8000250:	42ac      	cmp	r4, r5
 8000252:	da03      	bge.n	800025c <endinitloop>
 8000254:	f854 1b04 	ldr.w	r1, [r4], #4
 8000258:	4788      	blx	r1
 800025a:	e7f9      	b.n	8000250 <initloop>

0800025c <endinitloop>:
 800025c:	f009 f9b6 	bl	80095cc <main>
 8000260:	4c0f      	ldr	r4, [pc, #60]	@ (80002a0 <endfiniloop+0x30>)
 8000262:	4d10      	ldr	r5, [pc, #64]	@ (80002a4 <endfiniloop+0x34>)

08000264 <finiloop>:
 8000264:	42ac      	cmp	r4, r5
 8000266:	da03      	bge.n	8000270 <endfiniloop>
 8000268:	f854 1b04 	ldr.w	r1, [r4], #4
 800026c:	4788      	blx	r1
 800026e:	e7f9      	b.n	8000264 <finiloop>

08000270 <endfiniloop>:
 8000270:	f000 bb72 	b.w	8000958 <__default_exit>
 8000274:	20000300 	.word	0x20000300
 8000278:	20000000 	.word	0x20000000
 800027c:	20000100 	.word	0x20000100
 8000280:	20000100 	.word	0x20000100
 8000284:	0801be0c 	.word	0x0801be0c
 8000288:	20000300 	.word	0x20000300
 800028c:	200003f8 	.word	0x200003f8
 8000290:	200003f8 	.word	0x200003f8
 8000294:	20009a44 	.word	0x20009a44
 8000298:	080001a0 	.word	0x080001a0
 800029c:	080001a0 	.word	0x080001a0
 80002a0:	080001a0 	.word	0x080001a0
 80002a4:	080001a0 	.word	0x080001a0

080002a8 <_port_switch>:
 80002a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002ac:	ed2d 8a10 	vpush	{s16-s31}
 80002b0:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002b4:	68c3      	ldr	r3, [r0, #12]
 80002b6:	469d      	mov	sp, r3
 80002b8:	ecbd 8a10 	vpop	{s16-s31}
 80002bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002c0 <_port_thread_start>:
 80002c0:	2300      	movs	r3, #0
 80002c2:	f383 8811 	msr	BASEPRI, r3
 80002c6:	4628      	mov	r0, r5
 80002c8:	47a0      	blx	r4
 80002ca:	2000      	movs	r0, #0
 80002cc:	f000 fdda 	bl	8000e84 <chThdExit>

080002d0 <_port_switch_from_isr>:
 80002d0:	f000 fd66 	bl	8000da0 <chSchDoReschedule>

080002d4 <_port_exit_from_isr>:
 80002d4:	df00      	svc	0
 80002d6:	e7fe      	b.n	80002d6 <_port_exit_from_isr+0x2>

080002d8 <__aeabi_drsub>:
 80002d8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 80002dc:	e002      	b.n	80002e4 <__adddf3>
 80002de:	bf00      	nop

080002e0 <__aeabi_dsub>:
 80002e0:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

080002e4 <__adddf3>:
 80002e4:	b530      	push	{r4, r5, lr}
 80002e6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002ea:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002ee:	ea94 0f05 	teq	r4, r5
 80002f2:	bf08      	it	eq
 80002f4:	ea90 0f02 	teqeq	r0, r2
 80002f8:	bf1f      	itttt	ne
 80002fa:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002fe:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000302:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000306:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800030a:	f000 80e2 	beq.w	80004d2 <__adddf3+0x1ee>
 800030e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000312:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000316:	bfb8      	it	lt
 8000318:	426d      	neglt	r5, r5
 800031a:	dd0c      	ble.n	8000336 <__adddf3+0x52>
 800031c:	442c      	add	r4, r5
 800031e:	ea80 0202 	eor.w	r2, r0, r2
 8000322:	ea81 0303 	eor.w	r3, r1, r3
 8000326:	ea82 0000 	eor.w	r0, r2, r0
 800032a:	ea83 0101 	eor.w	r1, r3, r1
 800032e:	ea80 0202 	eor.w	r2, r0, r2
 8000332:	ea81 0303 	eor.w	r3, r1, r3
 8000336:	2d36      	cmp	r5, #54	@ 0x36
 8000338:	bf88      	it	hi
 800033a:	bd30      	pophi	{r4, r5, pc}
 800033c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000340:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000344:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000348:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800034c:	d002      	beq.n	8000354 <__adddf3+0x70>
 800034e:	4240      	negs	r0, r0
 8000350:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000354:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000358:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800035c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000360:	d002      	beq.n	8000368 <__adddf3+0x84>
 8000362:	4252      	negs	r2, r2
 8000364:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000368:	ea94 0f05 	teq	r4, r5
 800036c:	f000 80a7 	beq.w	80004be <__adddf3+0x1da>
 8000370:	f1a4 0401 	sub.w	r4, r4, #1
 8000374:	f1d5 0e20 	rsbs	lr, r5, #32
 8000378:	db0d      	blt.n	8000396 <__adddf3+0xb2>
 800037a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800037e:	fa22 f205 	lsr.w	r2, r2, r5
 8000382:	1880      	adds	r0, r0, r2
 8000384:	f141 0100 	adc.w	r1, r1, #0
 8000388:	fa03 f20e 	lsl.w	r2, r3, lr
 800038c:	1880      	adds	r0, r0, r2
 800038e:	fa43 f305 	asr.w	r3, r3, r5
 8000392:	4159      	adcs	r1, r3
 8000394:	e00e      	b.n	80003b4 <__adddf3+0xd0>
 8000396:	f1a5 0520 	sub.w	r5, r5, #32
 800039a:	f10e 0e20 	add.w	lr, lr, #32
 800039e:	2a01      	cmp	r2, #1
 80003a0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003a4:	bf28      	it	cs
 80003a6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003aa:	fa43 f305 	asr.w	r3, r3, r5
 80003ae:	18c0      	adds	r0, r0, r3
 80003b0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003b4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80003b8:	d507      	bpl.n	80003ca <__adddf3+0xe6>
 80003ba:	f04f 0e00 	mov.w	lr, #0
 80003be:	f1dc 0c00 	rsbs	ip, ip, #0
 80003c2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003c6:	eb6e 0101 	sbc.w	r1, lr, r1
 80003ca:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 80003ce:	d31b      	bcc.n	8000408 <__adddf3+0x124>
 80003d0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 80003d4:	d30c      	bcc.n	80003f0 <__adddf3+0x10c>
 80003d6:	0849      	lsrs	r1, r1, #1
 80003d8:	ea5f 0030 	movs.w	r0, r0, rrx
 80003dc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003e0:	f104 0401 	add.w	r4, r4, #1
 80003e4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003e8:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80003ec:	f080 809a 	bcs.w	8000524 <__adddf3+0x240>
 80003f0:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80003f4:	bf08      	it	eq
 80003f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003fa:	f150 0000 	adcs.w	r0, r0, #0
 80003fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000402:	ea41 0105 	orr.w	r1, r1, r5
 8000406:	bd30      	pop	{r4, r5, pc}
 8000408:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800040c:	4140      	adcs	r0, r0
 800040e:	eb41 0101 	adc.w	r1, r1, r1
 8000412:	3c01      	subs	r4, #1
 8000414:	bf28      	it	cs
 8000416:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 800041a:	d2e9      	bcs.n	80003f0 <__adddf3+0x10c>
 800041c:	f091 0f00 	teq	r1, #0
 8000420:	bf04      	itt	eq
 8000422:	4601      	moveq	r1, r0
 8000424:	2000      	moveq	r0, #0
 8000426:	fab1 f381 	clz	r3, r1
 800042a:	bf08      	it	eq
 800042c:	3320      	addeq	r3, #32
 800042e:	f1a3 030b 	sub.w	r3, r3, #11
 8000432:	f1b3 0220 	subs.w	r2, r3, #32
 8000436:	da0c      	bge.n	8000452 <__adddf3+0x16e>
 8000438:	320c      	adds	r2, #12
 800043a:	dd08      	ble.n	800044e <__adddf3+0x16a>
 800043c:	f102 0c14 	add.w	ip, r2, #20
 8000440:	f1c2 020c 	rsb	r2, r2, #12
 8000444:	fa01 f00c 	lsl.w	r0, r1, ip
 8000448:	fa21 f102 	lsr.w	r1, r1, r2
 800044c:	e00c      	b.n	8000468 <__adddf3+0x184>
 800044e:	f102 0214 	add.w	r2, r2, #20
 8000452:	bfd8      	it	le
 8000454:	f1c2 0c20 	rsble	ip, r2, #32
 8000458:	fa01 f102 	lsl.w	r1, r1, r2
 800045c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000460:	bfdc      	itt	le
 8000462:	ea41 010c 	orrle.w	r1, r1, ip
 8000466:	4090      	lslle	r0, r2
 8000468:	1ae4      	subs	r4, r4, r3
 800046a:	bfa2      	ittt	ge
 800046c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000470:	4329      	orrge	r1, r5
 8000472:	bd30      	popge	{r4, r5, pc}
 8000474:	ea6f 0404 	mvn.w	r4, r4
 8000478:	3c1f      	subs	r4, #31
 800047a:	da1c      	bge.n	80004b6 <__adddf3+0x1d2>
 800047c:	340c      	adds	r4, #12
 800047e:	dc0e      	bgt.n	800049e <__adddf3+0x1ba>
 8000480:	f104 0414 	add.w	r4, r4, #20
 8000484:	f1c4 0220 	rsb	r2, r4, #32
 8000488:	fa20 f004 	lsr.w	r0, r0, r4
 800048c:	fa01 f302 	lsl.w	r3, r1, r2
 8000490:	ea40 0003 	orr.w	r0, r0, r3
 8000494:	fa21 f304 	lsr.w	r3, r1, r4
 8000498:	ea45 0103 	orr.w	r1, r5, r3
 800049c:	bd30      	pop	{r4, r5, pc}
 800049e:	f1c4 040c 	rsb	r4, r4, #12
 80004a2:	f1c4 0220 	rsb	r2, r4, #32
 80004a6:	fa20 f002 	lsr.w	r0, r0, r2
 80004aa:	fa01 f304 	lsl.w	r3, r1, r4
 80004ae:	ea40 0003 	orr.w	r0, r0, r3
 80004b2:	4629      	mov	r1, r5
 80004b4:	bd30      	pop	{r4, r5, pc}
 80004b6:	fa21 f004 	lsr.w	r0, r1, r4
 80004ba:	4629      	mov	r1, r5
 80004bc:	bd30      	pop	{r4, r5, pc}
 80004be:	f094 0f00 	teq	r4, #0
 80004c2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 80004c6:	bf06      	itte	eq
 80004c8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 80004cc:	3401      	addeq	r4, #1
 80004ce:	3d01      	subne	r5, #1
 80004d0:	e74e      	b.n	8000370 <__adddf3+0x8c>
 80004d2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004d6:	bf18      	it	ne
 80004d8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004dc:	d029      	beq.n	8000532 <__adddf3+0x24e>
 80004de:	ea94 0f05 	teq	r4, r5
 80004e2:	bf08      	it	eq
 80004e4:	ea90 0f02 	teqeq	r0, r2
 80004e8:	d005      	beq.n	80004f6 <__adddf3+0x212>
 80004ea:	ea54 0c00 	orrs.w	ip, r4, r0
 80004ee:	bf04      	itt	eq
 80004f0:	4619      	moveq	r1, r3
 80004f2:	4610      	moveq	r0, r2
 80004f4:	bd30      	pop	{r4, r5, pc}
 80004f6:	ea91 0f03 	teq	r1, r3
 80004fa:	bf1e      	ittt	ne
 80004fc:	2100      	movne	r1, #0
 80004fe:	2000      	movne	r0, #0
 8000500:	bd30      	popne	{r4, r5, pc}
 8000502:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000506:	d105      	bne.n	8000514 <__adddf3+0x230>
 8000508:	0040      	lsls	r0, r0, #1
 800050a:	4149      	adcs	r1, r1
 800050c:	bf28      	it	cs
 800050e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 8000512:	bd30      	pop	{r4, r5, pc}
 8000514:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8000518:	bf3c      	itt	cc
 800051a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 800051e:	bd30      	popcc	{r4, r5, pc}
 8000520:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000524:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8000528:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800052c:	f04f 0000 	mov.w	r0, #0
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000536:	bf1a      	itte	ne
 8000538:	4619      	movne	r1, r3
 800053a:	4610      	movne	r0, r2
 800053c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000540:	bf1c      	itt	ne
 8000542:	460b      	movne	r3, r1
 8000544:	4602      	movne	r2, r0
 8000546:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800054a:	bf06      	itte	eq
 800054c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000550:	ea91 0f03 	teqeq	r1, r3
 8000554:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000558:	bd30      	pop	{r4, r5, pc}
 800055a:	bf00      	nop

0800055c <__aeabi_ui2d>:
 800055c:	f090 0f00 	teq	r0, #0
 8000560:	bf04      	itt	eq
 8000562:	2100      	moveq	r1, #0
 8000564:	4770      	bxeq	lr
 8000566:	b530      	push	{r4, r5, lr}
 8000568:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800056c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000570:	f04f 0500 	mov.w	r5, #0
 8000574:	f04f 0100 	mov.w	r1, #0
 8000578:	e750      	b.n	800041c <__adddf3+0x138>
 800057a:	bf00      	nop

0800057c <__aeabi_i2d>:
 800057c:	f090 0f00 	teq	r0, #0
 8000580:	bf04      	itt	eq
 8000582:	2100      	moveq	r1, #0
 8000584:	4770      	bxeq	lr
 8000586:	b530      	push	{r4, r5, lr}
 8000588:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800058c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000590:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 8000594:	bf48      	it	mi
 8000596:	4240      	negmi	r0, r0
 8000598:	f04f 0100 	mov.w	r1, #0
 800059c:	e73e      	b.n	800041c <__adddf3+0x138>
 800059e:	bf00      	nop

080005a0 <__aeabi_f2d>:
 80005a0:	0042      	lsls	r2, r0, #1
 80005a2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005a6:	ea4f 0131 	mov.w	r1, r1, rrx
 80005aa:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005ae:	bf1f      	itttt	ne
 80005b0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80005b4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 80005b8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 80005bc:	4770      	bxne	lr
 80005be:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 80005c2:	bf08      	it	eq
 80005c4:	4770      	bxeq	lr
 80005c6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 80005ca:	bf04      	itt	eq
 80005cc:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 80005d0:	4770      	bxeq	lr
 80005d2:	b530      	push	{r4, r5, lr}
 80005d4:	f44f 7460 	mov.w	r4, #896	@ 0x380
 80005d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80005dc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80005e0:	e71c      	b.n	800041c <__adddf3+0x138>
 80005e2:	bf00      	nop

080005e4 <__aeabi_ul2d>:
 80005e4:	ea50 0201 	orrs.w	r2, r0, r1
 80005e8:	bf08      	it	eq
 80005ea:	4770      	bxeq	lr
 80005ec:	b530      	push	{r4, r5, lr}
 80005ee:	f04f 0500 	mov.w	r5, #0
 80005f2:	e00a      	b.n	800060a <__aeabi_l2d+0x16>

080005f4 <__aeabi_l2d>:
 80005f4:	ea50 0201 	orrs.w	r2, r0, r1
 80005f8:	bf08      	it	eq
 80005fa:	4770      	bxeq	lr
 80005fc:	b530      	push	{r4, r5, lr}
 80005fe:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 8000602:	d502      	bpl.n	800060a <__aeabi_l2d+0x16>
 8000604:	4240      	negs	r0, r0
 8000606:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800060a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 800060e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000612:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000616:	f43f aed8 	beq.w	80003ca <__adddf3+0xe6>
 800061a:	f04f 0203 	mov.w	r2, #3
 800061e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000622:	bf18      	it	ne
 8000624:	3203      	addne	r2, #3
 8000626:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800062a:	bf18      	it	ne
 800062c:	3203      	addne	r2, #3
 800062e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000632:	f1c2 0320 	rsb	r3, r2, #32
 8000636:	fa00 fc03 	lsl.w	ip, r0, r3
 800063a:	fa20 f002 	lsr.w	r0, r0, r2
 800063e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000642:	ea40 000e 	orr.w	r0, r0, lr
 8000646:	fa21 f102 	lsr.w	r1, r1, r2
 800064a:	4414      	add	r4, r2
 800064c:	e6bd      	b.n	80003ca <__adddf3+0xe6>
 800064e:	bf00      	nop

08000650 <__aeabi_d2f>:
 8000650:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000654:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000658:	bf24      	itt	cs
 800065a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 800065e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000662:	d90d      	bls.n	8000680 <__aeabi_d2f+0x30>
 8000664:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000668:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 800066c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000670:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000674:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000678:	bf08      	it	eq
 800067a:	f020 0001 	biceq.w	r0, r0, #1
 800067e:	4770      	bx	lr
 8000680:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000684:	d121      	bne.n	80006ca <__aeabi_d2f+0x7a>
 8000686:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 800068a:	bfbc      	itt	lt
 800068c:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000690:	4770      	bxlt	lr
 8000692:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000696:	ea4f 5252 	mov.w	r2, r2, lsr #21
 800069a:	f1c2 0218 	rsb	r2, r2, #24
 800069e:	f1c2 0c20 	rsb	ip, r2, #32
 80006a2:	fa10 f30c 	lsls.w	r3, r0, ip
 80006a6:	fa20 f002 	lsr.w	r0, r0, r2
 80006aa:	bf18      	it	ne
 80006ac:	f040 0001 	orrne.w	r0, r0, #1
 80006b0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80006b4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80006b8:	fa03 fc0c 	lsl.w	ip, r3, ip
 80006bc:	ea40 000c 	orr.w	r0, r0, ip
 80006c0:	fa23 f302 	lsr.w	r3, r3, r2
 80006c4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80006c8:	e7cc      	b.n	8000664 <__aeabi_d2f+0x14>
 80006ca:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80006ce:	d107      	bne.n	80006e0 <__aeabi_d2f+0x90>
 80006d0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80006d4:	bf1e      	ittt	ne
 80006d6:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 80006da:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 80006de:	4770      	bxne	lr
 80006e0:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 80006e4:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 80006e8:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80006ec:	4770      	bx	lr
 80006ee:	bf00      	nop

080006f0 <__aeabi_frsub>:
 80006f0:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
 80006f4:	e002      	b.n	80006fc <__addsf3>
 80006f6:	bf00      	nop

080006f8 <__aeabi_fsub>:
 80006f8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

080006fc <__addsf3>:
 80006fc:	0042      	lsls	r2, r0, #1
 80006fe:	bf1f      	itttt	ne
 8000700:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000704:	ea92 0f03 	teqne	r2, r3
 8000708:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 800070c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000710:	d06a      	beq.n	80007e8 <__addsf3+0xec>
 8000712:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000716:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 800071a:	bfc1      	itttt	gt
 800071c:	18d2      	addgt	r2, r2, r3
 800071e:	4041      	eorgt	r1, r0
 8000720:	4048      	eorgt	r0, r1
 8000722:	4041      	eorgt	r1, r0
 8000724:	bfb8      	it	lt
 8000726:	425b      	neglt	r3, r3
 8000728:	2b19      	cmp	r3, #25
 800072a:	bf88      	it	hi
 800072c:	4770      	bxhi	lr
 800072e:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 8000732:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000736:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 800073a:	bf18      	it	ne
 800073c:	4240      	negne	r0, r0
 800073e:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000742:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 8000746:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
 800074a:	bf18      	it	ne
 800074c:	4249      	negne	r1, r1
 800074e:	ea92 0f03 	teq	r2, r3
 8000752:	d03f      	beq.n	80007d4 <__addsf3+0xd8>
 8000754:	f1a2 0201 	sub.w	r2, r2, #1
 8000758:	fa41 fc03 	asr.w	ip, r1, r3
 800075c:	eb10 000c 	adds.w	r0, r0, ip
 8000760:	f1c3 0320 	rsb	r3, r3, #32
 8000764:	fa01 f103 	lsl.w	r1, r1, r3
 8000768:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 800076c:	d502      	bpl.n	8000774 <__addsf3+0x78>
 800076e:	4249      	negs	r1, r1
 8000770:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000774:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 8000778:	d313      	bcc.n	80007a2 <__addsf3+0xa6>
 800077a:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 800077e:	d306      	bcc.n	800078e <__addsf3+0x92>
 8000780:	0840      	lsrs	r0, r0, #1
 8000782:	ea4f 0131 	mov.w	r1, r1, rrx
 8000786:	f102 0201 	add.w	r2, r2, #1
 800078a:	2afe      	cmp	r2, #254	@ 0xfe
 800078c:	d251      	bcs.n	8000832 <__addsf3+0x136>
 800078e:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 8000792:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000796:	bf08      	it	eq
 8000798:	f020 0001 	biceq.w	r0, r0, #1
 800079c:	ea40 0003 	orr.w	r0, r0, r3
 80007a0:	4770      	bx	lr
 80007a2:	0049      	lsls	r1, r1, #1
 80007a4:	eb40 0000 	adc.w	r0, r0, r0
 80007a8:	3a01      	subs	r2, #1
 80007aa:	bf28      	it	cs
 80007ac:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
 80007b0:	d2ed      	bcs.n	800078e <__addsf3+0x92>
 80007b2:	fab0 fc80 	clz	ip, r0
 80007b6:	f1ac 0c08 	sub.w	ip, ip, #8
 80007ba:	ebb2 020c 	subs.w	r2, r2, ip
 80007be:	fa00 f00c 	lsl.w	r0, r0, ip
 80007c2:	bfaa      	itet	ge
 80007c4:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80007c8:	4252      	neglt	r2, r2
 80007ca:	4318      	orrge	r0, r3
 80007cc:	bfbc      	itt	lt
 80007ce:	40d0      	lsrlt	r0, r2
 80007d0:	4318      	orrlt	r0, r3
 80007d2:	4770      	bx	lr
 80007d4:	f092 0f00 	teq	r2, #0
 80007d8:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
 80007dc:	bf06      	itte	eq
 80007de:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
 80007e2:	3201      	addeq	r2, #1
 80007e4:	3b01      	subne	r3, #1
 80007e6:	e7b5      	b.n	8000754 <__addsf3+0x58>
 80007e8:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80007ec:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80007f0:	bf18      	it	ne
 80007f2:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80007f6:	d021      	beq.n	800083c <__addsf3+0x140>
 80007f8:	ea92 0f03 	teq	r2, r3
 80007fc:	d004      	beq.n	8000808 <__addsf3+0x10c>
 80007fe:	f092 0f00 	teq	r2, #0
 8000802:	bf08      	it	eq
 8000804:	4608      	moveq	r0, r1
 8000806:	4770      	bx	lr
 8000808:	ea90 0f01 	teq	r0, r1
 800080c:	bf1c      	itt	ne
 800080e:	2000      	movne	r0, #0
 8000810:	4770      	bxne	lr
 8000812:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
 8000816:	d104      	bne.n	8000822 <__addsf3+0x126>
 8000818:	0040      	lsls	r0, r0, #1
 800081a:	bf28      	it	cs
 800081c:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
 8000820:	4770      	bx	lr
 8000822:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
 8000826:	bf3c      	itt	cc
 8000828:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
 800082c:	4770      	bxcc	lr
 800082e:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 8000832:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
 8000836:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 800083a:	4770      	bx	lr
 800083c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000840:	bf16      	itet	ne
 8000842:	4608      	movne	r0, r1
 8000844:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000848:	4601      	movne	r1, r0
 800084a:	0242      	lsls	r2, r0, #9
 800084c:	bf06      	itte	eq
 800084e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000852:	ea90 0f01 	teqeq	r0, r1
 8000856:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
 800085a:	4770      	bx	lr

0800085c <__aeabi_ui2f>:
 800085c:	f04f 0300 	mov.w	r3, #0
 8000860:	e004      	b.n	800086c <__aeabi_i2f+0x8>
 8000862:	bf00      	nop

08000864 <__aeabi_i2f>:
 8000864:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
 8000868:	bf48      	it	mi
 800086a:	4240      	negmi	r0, r0
 800086c:	ea5f 0c00 	movs.w	ip, r0
 8000870:	bf08      	it	eq
 8000872:	4770      	bxeq	lr
 8000874:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000
 8000878:	4601      	mov	r1, r0
 800087a:	f04f 0000 	mov.w	r0, #0
 800087e:	e01c      	b.n	80008ba <__aeabi_l2f+0x2a>

08000880 <__aeabi_ul2f>:
 8000880:	ea50 0201 	orrs.w	r2, r0, r1
 8000884:	bf08      	it	eq
 8000886:	4770      	bxeq	lr
 8000888:	f04f 0300 	mov.w	r3, #0
 800088c:	e00a      	b.n	80008a4 <__aeabi_l2f+0x14>
 800088e:	bf00      	nop

08000890 <__aeabi_l2f>:
 8000890:	ea50 0201 	orrs.w	r2, r0, r1
 8000894:	bf08      	it	eq
 8000896:	4770      	bxeq	lr
 8000898:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
 800089c:	d502      	bpl.n	80008a4 <__aeabi_l2f+0x14>
 800089e:	4240      	negs	r0, r0
 80008a0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80008a4:	ea5f 0c01 	movs.w	ip, r1
 80008a8:	bf02      	ittt	eq
 80008aa:	4684      	moveq	ip, r0
 80008ac:	4601      	moveq	r1, r0
 80008ae:	2000      	moveq	r0, #0
 80008b0:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
 80008b4:	bf08      	it	eq
 80008b6:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
 80008ba:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
 80008be:	fabc f28c 	clz	r2, ip
 80008c2:	3a08      	subs	r2, #8
 80008c4:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80008c8:	db10      	blt.n	80008ec <__aeabi_l2f+0x5c>
 80008ca:	fa01 fc02 	lsl.w	ip, r1, r2
 80008ce:	4463      	add	r3, ip
 80008d0:	fa00 fc02 	lsl.w	ip, r0, r2
 80008d4:	f1c2 0220 	rsb	r2, r2, #32
 80008d8:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80008dc:	fa20 f202 	lsr.w	r2, r0, r2
 80008e0:	eb43 0002 	adc.w	r0, r3, r2
 80008e4:	bf08      	it	eq
 80008e6:	f020 0001 	biceq.w	r0, r0, #1
 80008ea:	4770      	bx	lr
 80008ec:	f102 0220 	add.w	r2, r2, #32
 80008f0:	fa01 fc02 	lsl.w	ip, r1, r2
 80008f4:	f1c2 0220 	rsb	r2, r2, #32
 80008f8:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80008fc:	fa21 f202 	lsr.w	r2, r1, r2
 8000900:	eb43 0002 	adc.w	r0, r3, r2
 8000904:	bf08      	it	eq
 8000906:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 800090a:	4770      	bx	lr

0800090c <__aeabi_uldivmod>:
 800090c:	b953      	cbnz	r3, 8000924 <__aeabi_uldivmod+0x18>
 800090e:	b94a      	cbnz	r2, 8000924 <__aeabi_uldivmod+0x18>
 8000910:	2900      	cmp	r1, #0
 8000912:	bf08      	it	eq
 8000914:	2800      	cmpeq	r0, #0
 8000916:	bf1c      	itt	ne
 8000918:	f04f 31ff 	movne.w	r1, #4294967295
 800091c:	f04f 30ff 	movne.w	r0, #4294967295
 8000920:	f000 b80c 	b.w	800093c <__aeabi_idiv0>
 8000924:	f1ad 0c08 	sub.w	ip, sp, #8
 8000928:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800092c:	f011 fdc4 	bl	80124b8 <__udivmoddi4>
 8000930:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000934:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000938:	b004      	add	sp, #16
 800093a:	4770      	bx	lr

0800093c <__aeabi_idiv0>:
 800093c:	4770      	bx	lr
 800093e:	bf00      	nop

08000940 <strlen>:
 8000940:	4603      	mov	r3, r0
 8000942:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000946:	2a00      	cmp	r2, #0
 8000948:	d1fb      	bne.n	8000942 <strlen+0x2>
 800094a:	1a18      	subs	r0, r3, r0
 800094c:	3801      	subs	r0, #1
 800094e:	4770      	bx	lr

08000950 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000950:	4770      	bx	lr
 8000952:	bf00      	nop

08000954 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000954:	4770      	bx	lr
 8000956:	bf00      	nop

08000958 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8000958:	e7fe      	b.n	8000958 <__default_exit>
 800095a:	bf00      	nop

0800095c <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800095c:	b570      	push	{r4, r5, r6, lr}
 800095e:	4d13      	ldr	r5, [pc, #76]	@ (80009ac <__init_ram_areas+0x50>)
 8000960:	f105 0480 	add.w	r4, r5, #128	@ 0x80
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000964:	e955 0103 	ldrd	r0, r1, [r5, #-12]
 8000968:	4288      	cmp	r0, r1
    uint32_t *tp = rap->init_text_area;
 800096a:	f855 2c10 	ldr.w	r2, [r5, #-16]
    while (p < rap->clear_area) {
 800096e:	d20d      	bcs.n	800098c <__init_ram_areas+0x30>
 8000970:	3a04      	subs	r2, #4
    uint32_t *p = rap->init_area;
 8000972:	4603      	mov	r3, r0
      *p = *tp;
 8000974:	f852 6f04 	ldr.w	r6, [r2, #4]!
 8000978:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 800097c:	428b      	cmp	r3, r1
 800097e:	d3f9      	bcc.n	8000974 <__init_ram_areas+0x18>
 8000980:	3901      	subs	r1, #1
 8000982:	1a09      	subs	r1, r1, r0
 8000984:	f021 0103 	bic.w	r1, r1, #3
 8000988:	3004      	adds	r0, #4
 800098a:	4408      	add	r0, r1
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800098c:	f855 2c04 	ldr.w	r2, [r5, #-4]
 8000990:	4282      	cmp	r2, r0
 8000992:	d907      	bls.n	80009a4 <__init_ram_areas+0x48>
      *p = 0;
 8000994:	3a01      	subs	r2, #1
 8000996:	1a12      	subs	r2, r2, r0
 8000998:	f022 0203 	bic.w	r2, r2, #3
 800099c:	3204      	adds	r2, #4
 800099e:	2100      	movs	r1, #0
 80009a0:	f011 ff20 	bl	80127e4 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80009a4:	3510      	adds	r5, #16
 80009a6:	42a5      	cmp	r5, r4
 80009a8:	d1dc      	bne.n	8000964 <__init_ram_areas+0x8>
#endif
}
 80009aa:	bd70      	pop	{r4, r5, r6, pc}
 80009ac:	080128ac 	.word	0x080128ac

080009b0 <_unhandled_exception>:
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
 80009b0:	e7fe      	b.n	80009b0 <_unhandled_exception>
 80009b2:	bf00      	nop

080009b4 <_idle_thread>:
 */
static void _idle_thread(void *p) {

  (void)p;

  while (true) {
 80009b4:	e7fe      	b.n	80009b4 <_idle_thread>
 80009b6:	bf00      	nop

080009b8 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80009b8:	b538      	push	{r3, r4, r5, lr}
#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
#else
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 80009ba:	4d19      	ldr	r5, [pc, #100]	@ (8000a20 <chSysInit+0x68>)
  _scheduler_init();
 80009bc:	f000 f904 	bl	8000bc8 <_scheduler_init>
  _vt_init();
 80009c0:	f000 f880 	bl	8000ac4 <_vt_init>
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 80009c4:	4917      	ldr	r1, [pc, #92]	@ (8000a24 <chSysInit+0x6c>)
 80009c6:	2280      	movs	r2, #128	@ 0x80
 80009c8:	4628      	mov	r0, r5
 80009ca:	f000 f9eb 	bl	8000da4 <_thread_init>
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80009ce:	4b16      	ldr	r3, [pc, #88]	@ (8000a28 <chSysInit+0x70>)
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 80009d0:	4a16      	ldr	r2, [pc, #88]	@ (8000a2c <chSysInit+0x74>)
  currp = _thread_init(&ch.mainthread, "main", NORMALPRIO);
 80009d2:	f845 0c18 	str.w	r0, [r5, #-24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80009d6:	2101      	movs	r1, #1
 80009d8:	2400      	movs	r4, #0
 80009da:	7501      	strb	r1, [r0, #20]
    currp->wabase = &__main_thread_stack_base__;
 80009dc:	6102      	str	r2, [r0, #16]
 80009de:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80009e0:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80009e2:	4a13      	ldr	r2, [pc, #76]	@ (8000a30 <chSysInit+0x78>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80009e4:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
 80009e8:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 80009ea:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80009ec:	60da      	str	r2, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80009ee:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80009f2:	4910      	ldr	r1, [pc, #64]	@ (8000a34 <chSysInit+0x7c>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80009f4:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 80009f8:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80009fc:	680a      	ldr	r2, [r1, #0]
 80009fe:	f042 0201 	orr.w	r2, r2, #1
 8000a02:	600a      	str	r2, [r1, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000a04:	2010      	movs	r0, #16
 8000a06:	2220      	movs	r2, #32
 8000a08:	77d8      	strb	r0, [r3, #31]
 8000a0a:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a0e:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8000a12:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8000a14:	4808      	ldr	r0, [pc, #32]	@ (8000a38 <chSysInit+0x80>)
  }
#endif
}
 8000a16:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void) chThdCreate(&idle_descriptor);
 8000a1a:	f000 b9e3 	b.w	8000de4 <chThdCreate>
 8000a1e:	bf00      	nop
 8000a20:	20000558 	.word	0x20000558
 8000a24:	0801291c 	.word	0x0801291c
 8000a28:	e000ed00 	.word	0xe000ed00
 8000a2c:	20000100 	.word	0x20000100
 8000a30:	05fa0300 	.word	0x05fa0300
 8000a34:	e0001000 	.word	0xe0001000
 8000a38:	0801475c 	.word	0x0801475c

08000a3c <chSysHalt>:
  __ASM volatile ("cpsid i" : : : "memory");
 8000a3c:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000a3e:	4b01      	ldr	r3, [pc, #4]	@ (8000a44 <chSysHalt+0x8>)
 8000a40:	6258      	str	r0, [r3, #36]	@ 0x24

  /* Harmless infinite loop.*/
  while (true) {
 8000a42:	e7fe      	b.n	8000a42 <chSysHalt+0x6>
 8000a44:	20000530 	.word	0x20000530

08000a48 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000a48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000a4c:	4d1c      	ldr	r5, [pc, #112]	@ (8000ac0 <chSysTimerHandlerI+0x78>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000a4e:	f04f 4880 	mov.w	r8, #1073741824	@ 0x40000000
 8000a52:	696c      	ldr	r4, [r5, #20]
 8000a54:	f8d8 0024 	ldr.w	r0, [r8, #36]	@ 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000a58:	6a29      	ldr	r1, [r5, #32]
 8000a5a:	68a3      	ldr	r3, [r4, #8]
 8000a5c:	1a42      	subs	r2, r0, r1
 8000a5e:	4293      	cmp	r3, r2
 8000a60:	f105 0614 	add.w	r6, r5, #20
 8000a64:	d81e      	bhi.n	8000aa4 <chSysTimerHandlerI+0x5c>
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 8000a66:	2700      	movs	r7, #0
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a68:	f04f 0920 	mov.w	r9, #32
 8000a6c:	e00d      	b.n	8000a8a <chSysTimerHandlerI+0x42>
 8000a6e:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8000a72:	6920      	ldr	r0, [r4, #16]
 8000a74:	47d0      	blx	sl
 8000a76:	f389 8811 	msr	BASEPRI, r9
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8000a7a:	696c      	ldr	r4, [r5, #20]
 8000a7c:	f8d8 0024 	ldr.w	r0, [r8, #36]	@ 0x24
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000a80:	6a29      	ldr	r1, [r5, #32]
 8000a82:	68a3      	ldr	r3, [r4, #8]
 8000a84:	1a42      	subs	r2, r0, r1
 8000a86:	4293      	cmp	r3, r2
 8000a88:	d80c      	bhi.n	8000aa4 <chSysTimerHandlerI+0x5c>
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000a8a:	6822      	ldr	r2, [r4, #0]
    fn = vtp->func;
 8000a8c:	f8d4 a00c 	ldr.w	sl, [r4, #12]
    ch.vtlist.lasttime += vtp->delta;
 8000a90:	440b      	add	r3, r1
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000a92:	42b2      	cmp	r2, r6
    ch.vtlist.lasttime += vtp->delta;
 8000a94:	622b      	str	r3, [r5, #32]
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000a96:	6056      	str	r6, [r2, #4]
    ch.vtlist.next = vtp->next;
 8000a98:	616a      	str	r2, [r5, #20]
    vtp->func = NULL;
 8000a9a:	60e7      	str	r7, [r4, #12]
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000a9c:	d1e7      	bne.n	8000a6e <chSysTimerHandlerI+0x26>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8000a9e:	f000 fa93 	bl	8000fc8 <stStopAlarm>
}
 8000aa2:	e7e4      	b.n	8000a6e <chSysTimerHandlerI+0x26>
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000aa4:	42b4      	cmp	r4, r6
 8000aa6:	d009      	beq.n	8000abc <chSysTimerHandlerI+0x74>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8000aa8:	440b      	add	r3, r1
 8000aaa:	1a1b      	subs	r3, r3, r0
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
 8000aac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8000ab0:	2b02      	cmp	r3, #2
 8000ab2:	bf2c      	ite	cs
 8000ab4:	18c0      	addcs	r0, r0, r3
 8000ab6:	3002      	addcc	r0, #2
 8000ab8:	f000 ba8c 	b.w	8000fd4 <stSetAlarm>
 8000abc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000ac0:	20000530 	.word	0x20000530

08000ac4 <_vt_init>:
 * @brief   Virtual Timers initialization.
 * @note    Internal use only.
 *
 * @notapi
 */
void _vt_init(void) {
 8000ac4:	4a05      	ldr	r2, [pc, #20]	@ (8000adc <_vt_init+0x18>)

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000ac6:	4613      	mov	r3, r2
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8000ac8:	f04f 30ff 	mov.w	r0, #4294967295
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000acc:	f843 2914 	str.w	r2, [r3], #-20
  ch.vtlist.delta = (systime_t)-1;
 8000ad0:	2100      	movs	r1, #0
 8000ad2:	e9c3 2006 	strd	r2, r0, [r3, #24]
 8000ad6:	6219      	str	r1, [r3, #32]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000ad8:	4770      	bx	lr
 8000ada:	bf00      	nop
 8000adc:	20000544 	.word	0x20000544

08000ae0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000ae0:	b570      	push	{r4, r5, r6, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000ae2:	4e1c      	ldr	r6, [pc, #112]	@ (8000b54 <chVTDoSetI+0x74>)
 8000ae4:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000ae8:	2902      	cmp	r1, #2
 8000aea:	6a64      	ldr	r4, [r4, #36]	@ 0x24
  vtp->func = vtfunc;
 8000aec:	e9c0 2303 	strd	r2, r3, [r0, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000af0:	4632      	mov	r2, r6
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000af2:	bf38      	it	cc
 8000af4:	2102      	movcc	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000af6:	f852 3f14 	ldr.w	r3, [r2, #20]!
 8000afa:	4293      	cmp	r3, r2
                vtfunc_t vtfunc, void *par) {
 8000afc:	4605      	mov	r5, r0
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8000afe:	eb01 0004 	add.w	r0, r1, r4
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b02:	d01d      	beq.n	8000b40 <chVTDoSetI+0x60>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 8000b04:	6a34      	ldr	r4, [r6, #32]
    if (delta < ch.vtlist.next->delta) {
 8000b06:	689a      	ldr	r2, [r3, #8]
    delta = now + delay - ch.vtlist.lasttime;
 8000b08:	1b04      	subs	r4, r0, r4
    if (delta < ch.vtlist.next->delta) {
 8000b0a:	42a2      	cmp	r2, r4
 8000b0c:	d813      	bhi.n	8000b36 <chVTDoSetI+0x56>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
 8000b0e:	4294      	cmp	r4, r2
 8000b10:	d904      	bls.n	8000b1c <chVTDoSetI+0x3c>
    delta -= p->delta;
    p = p->next;
 8000b12:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 8000b14:	1aa4      	subs	r4, r4, r2
  while (p->delta < delta) {
 8000b16:	689a      	ldr	r2, [r3, #8]
 8000b18:	42a2      	cmp	r2, r4
 8000b1a:	d3fa      	bcc.n	8000b12 <chVTDoSetI+0x32>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000b1c:	685a      	ldr	r2, [r3, #4]
 8000b1e:	e9c5 3200 	strd	r3, r2, [r5]
  vtp->prev->next = vtp;
 8000b22:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 8000b24:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
 8000b26:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8000b28:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000b2a:	f04f 31ff 	mov.w	r1, #4294967295
  p->delta -= delta;
 8000b2e:	1b12      	subs	r2, r2, r4
 8000b30:	609a      	str	r2, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 8000b32:	61f1      	str	r1, [r6, #28]
}
 8000b34:	bd70      	pop	{r4, r5, r6, pc}
 8000b36:	f000 fa4d 	bl	8000fd4 <stSetAlarm>
  p = ch.vtlist.next;
 8000b3a:	6973      	ldr	r3, [r6, #20]
  while (p->delta < delta) {
 8000b3c:	689a      	ldr	r2, [r3, #8]
}
 8000b3e:	e7e6      	b.n	8000b0e <chVTDoSetI+0x2e>
      ch.vtlist.next = vtp;
 8000b40:	e9c6 5505 	strd	r5, r5, [r6, #20]
      ch.vtlist.lasttime = now;
 8000b44:	6234      	str	r4, [r6, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8000b46:	e9c5 3300 	strd	r3, r3, [r5]
      vtp->delta = delay;
 8000b4a:	60a9      	str	r1, [r5, #8]
}
 8000b4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  stStartAlarm(time);
 8000b50:	f000 ba32 	b.w	8000fb8 <stStartAlarm>
 8000b54:	20000530 	.word	0x20000530

08000b58 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000b58:	4a1a      	ldr	r2, [pc, #104]	@ (8000bc4 <chVTDoResetI+0x6c>)
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000b5a:	6803      	ldr	r3, [r0, #0]
  if (ch.vtlist.next != vtp) {
 8000b5c:	6951      	ldr	r1, [r2, #20]
 8000b5e:	4281      	cmp	r1, r0
void chVTDoResetI(virtual_timer_t *vtp) {
 8000b60:	b410      	push	{r4}
  if (ch.vtlist.next != vtp) {
 8000b62:	d00e      	beq.n	8000b82 <chVTDoResetI+0x2a>
    vtp->prev->next = vtp->next;
 8000b64:	6841      	ldr	r1, [r0, #4]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b66:	3214      	adds	r2, #20
    vtp->func = NULL;
 8000b68:	2400      	movs	r4, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b6a:	4293      	cmp	r3, r2
    vtp->prev->next = vtp->next;
 8000b6c:	600b      	str	r3, [r1, #0]
    vtp->next->prev = vtp->prev;
 8000b6e:	6059      	str	r1, [r3, #4]
    vtp->func = NULL;
 8000b70:	60c4      	str	r4, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b72:	d003      	beq.n	8000b7c <chVTDoResetI+0x24>
      vtp->next->delta += vtp->delta;
 8000b74:	689a      	ldr	r2, [r3, #8]
 8000b76:	6881      	ldr	r1, [r0, #8]
 8000b78:	440a      	add	r2, r1
 8000b7a:	609a      	str	r2, [r3, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000b7c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b80:	4770      	bx	lr
  ch.vtlist.next = vtp->next;
 8000b82:	4610      	mov	r0, r2
  vtp->func = NULL;
 8000b84:	2400      	movs	r4, #0
  ch.vtlist.next = vtp->next;
 8000b86:	f840 3f14 	str.w	r3, [r0, #20]!
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b8a:	4283      	cmp	r3, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000b8c:	6058      	str	r0, [r3, #4]
  vtp->func = NULL;
 8000b8e:	60cc      	str	r4, [r1, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b90:	d014      	beq.n	8000bbc <chVTDoResetI+0x64>
  ch.vtlist.next->delta += vtp->delta;
 8000b92:	6898      	ldr	r0, [r3, #8]
 8000b94:	6889      	ldr	r1, [r1, #8]
 8000b96:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
 8000b9a:	4401      	add	r1, r0
 8000b9c:	6099      	str	r1, [r3, #8]
 8000b9e:	6a60      	ldr	r0, [r4, #36]	@ 0x24
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000ba0:	6a13      	ldr	r3, [r2, #32]
 8000ba2:	1ac2      	subs	r2, r0, r3
  if (nowdelta >= ch.vtlist.next->delta) {
 8000ba4:	4291      	cmp	r1, r2
 8000ba6:	d9e9      	bls.n	8000b7c <chVTDoResetI+0x24>
  delta = ch.vtlist.next->delta - nowdelta;
 8000ba8:	1a1b      	subs	r3, r3, r0
 8000baa:	440b      	add	r3, r1
}
 8000bac:	f85d 4b04 	ldr.w	r4, [sp], #4
  stSetAlarm(time);
 8000bb0:	2b02      	cmp	r3, #2
 8000bb2:	bf2c      	ite	cs
 8000bb4:	18c0      	addcs	r0, r0, r3
 8000bb6:	3002      	addcc	r0, #2
 8000bb8:	f000 ba0c 	b.w	8000fd4 <stSetAlarm>
 8000bbc:	f85d 4b04 	ldr.w	r4, [sp], #4
  stStopAlarm();
 8000bc0:	f000 ba02 	b.w	8000fc8 <stStopAlarm>
 8000bc4:	20000530 	.word	0x20000530

08000bc8 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000bc8:	4b02      	ldr	r3, [pc, #8]	@ (8000bd4 <_scheduler_init+0xc>)

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000bca:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bcc:	e9c3 3300 	strd	r3, r3, [r3]
 8000bd0:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
  ch.rlist.older = (thread_t *)&ch.rlist;
#endif
}
 8000bd2:	4770      	bx	lr
 8000bd4:	20000530 	.word	0x20000530

08000bd8 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000bd8:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 8000bda:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000bdc:	4b05      	ldr	r3, [pc, #20]	@ (8000bf4 <chSchReadyI+0x1c>)
  tp->state = CH_STATE_READY;
 8000bde:	7502      	strb	r2, [r0, #20]
    cp = cp->queue.next;
 8000be0:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000be2:	689a      	ldr	r2, [r3, #8]
 8000be4:	428a      	cmp	r2, r1
 8000be6:	d2fb      	bcs.n	8000be0 <chSchReadyI+0x8>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000be8:	685a      	ldr	r2, [r3, #4]
 8000bea:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8000bee:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000bf0:	6058      	str	r0, [r3, #4]

  return tp;
}
 8000bf2:	4770      	bx	lr
 8000bf4:	20000530 	.word	0x20000530

08000bf8 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000bf8:	b508      	push	{r3, lr}
 8000bfa:	2320      	movs	r3, #32
 8000bfc:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8000c00:	7d03      	ldrb	r3, [r0, #20]
 8000c02:	2b03      	cmp	r3, #3
 8000c04:	d010      	beq.n	8000c28 <wakeup+0x30>
 8000c06:	2b04      	cmp	r3, #4
 8000c08:	d009      	beq.n	8000c1e <wakeup+0x26>
 8000c0a:	b12b      	cbz	r3, 8000c18 <wakeup+0x20>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000c0c:	f04f 33ff 	mov.w	r3, #4294967295
 8000c10:	6183      	str	r3, [r0, #24]
  (void) chSchReadyI(tp);
 8000c12:	f7ff ffe1 	bl	8000bd8 <chSchReadyI>
 8000c16:	2300      	movs	r3, #0
 8000c18:	f383 8811 	msr	BASEPRI, r3
  chSysUnlockFromISR();
}
 8000c1c:	bd08      	pop	{r3, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000c1e:	e9d0 3200 	ldrd	r3, r2, [r0]
 8000c22:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000c24:	605a      	str	r2, [r3, #4]

  return tp;
 8000c26:	e7f1      	b.n	8000c0c <wakeup+0x14>
    *tp->u.wttrp = NULL;
 8000c28:	6983      	ldr	r3, [r0, #24]
 8000c2a:	2200      	movs	r2, #0
 8000c2c:	601a      	str	r2, [r3, #0]
    break;
 8000c2e:	e7ed      	b.n	8000c0c <wakeup+0x14>

08000c30 <chSchReadyAheadI>:
  tp->state = CH_STATE_READY;
 8000c30:	2200      	movs	r2, #0
  } while (cp->prio > tp->prio);
 8000c32:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000c34:	4b05      	ldr	r3, [pc, #20]	@ (8000c4c <chSchReadyAheadI+0x1c>)
  tp->state = CH_STATE_READY;
 8000c36:	7502      	strb	r2, [r0, #20]
    cp = cp->queue.next;
 8000c38:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8000c3a:	689a      	ldr	r2, [r3, #8]
 8000c3c:	428a      	cmp	r2, r1
 8000c3e:	d8fb      	bhi.n	8000c38 <chSchReadyAheadI+0x8>
  tp->queue.prev             = cp->queue.prev;
 8000c40:	685a      	ldr	r2, [r3, #4]
 8000c42:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 8000c46:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000c48:	6058      	str	r0, [r3, #4]
}
 8000c4a:	4770      	bx	lr
 8000c4c:	20000530 	.word	0x20000530

08000c50 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8000c50:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8000c52:	4c10      	ldr	r4, [pc, #64]	@ (8000c94 <chSchGoSleepS+0x44>)
 8000c54:	6925      	ldr	r5, [r4, #16]
  thread_t *tp = tqp->next;
 8000c56:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
 8000c58:	7528      	strb	r0, [r5, #20]
  tqp->next             = tp->queue.next;
 8000c5a:	681a      	ldr	r2, [r3, #0]
 8000c5c:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8000c5e:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000c60:	6054      	str	r4, [r2, #4]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000c62:	6123      	str	r3, [r4, #16]
  currp->state = CH_STATE_CURRENT;
 8000c64:	7519      	strb	r1, [r3, #20]
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000c66:	f3ef 8209 	mrs	r2, PSP
  chSysSwitch(currp, otp);
 8000c6a:	6929      	ldr	r1, [r5, #16]
 8000c6c:	3a64      	subs	r2, #100	@ 0x64
 8000c6e:	4291      	cmp	r1, r2
 8000c70:	d805      	bhi.n	8000c7e <chSchGoSleepS+0x2e>
 8000c72:	4629      	mov	r1, r5
 8000c74:	4618      	mov	r0, r3
}
 8000c76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000c7a:	f7ff bb15 	b.w	80002a8 <_port_switch>
 8000c7e:	4806      	ldr	r0, [pc, #24]	@ (8000c98 <chSchGoSleepS+0x48>)
 8000c80:	f7ff fedc 	bl	8000a3c <chSysHalt>
 8000c84:	6923      	ldr	r3, [r4, #16]
 8000c86:	4629      	mov	r1, r5
 8000c88:	4618      	mov	r0, r3
}
 8000c8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000c8e:	f7ff bb0b 	b.w	80002a8 <_port_switch>
 8000c92:	bf00      	nop
 8000c94:	20000530 	.word	0x20000530
 8000c98:	0801292c 	.word	0x0801292c

08000c9c <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000c9c:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000c9e:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000ca0:	b087      	sub	sp, #28
  if (TIME_INFINITE != time) {
 8000ca2:	d012      	beq.n	8000cca <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000ca4:	4d0c      	ldr	r5, [pc, #48]	@ (8000cd8 <chSchGoSleepTimeoutS+0x3c>)
 8000ca6:	4a0d      	ldr	r2, [pc, #52]	@ (8000cdc <chSchGoSleepTimeoutS+0x40>)
 8000ca8:	692b      	ldr	r3, [r5, #16]
 8000caa:	4604      	mov	r4, r0
 8000cac:	a801      	add	r0, sp, #4
 8000cae:	f7ff ff17 	bl	8000ae0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000cb2:	4620      	mov	r0, r4
 8000cb4:	f7ff ffcc 	bl	8000c50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cb8:	9b04      	ldr	r3, [sp, #16]
 8000cba:	b113      	cbz	r3, 8000cc2 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8000cbc:	a801      	add	r0, sp, #4
 8000cbe:	f7ff ff4b 	bl	8000b58 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8000cc2:	692b      	ldr	r3, [r5, #16]
}
 8000cc4:	6998      	ldr	r0, [r3, #24]
 8000cc6:	b007      	add	sp, #28
 8000cc8:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
 8000cca:	4d03      	ldr	r5, [pc, #12]	@ (8000cd8 <chSchGoSleepTimeoutS+0x3c>)
 8000ccc:	f7ff ffc0 	bl	8000c50 <chSchGoSleepS>
  return currp->u.rdymsg;
 8000cd0:	692b      	ldr	r3, [r5, #16]
}
 8000cd2:	6998      	ldr	r0, [r3, #24]
 8000cd4:	b007      	add	sp, #28
 8000cd6:	bd30      	pop	{r4, r5, pc}
 8000cd8:	20000530 	.word	0x20000530
 8000cdc:	08000bf9 	.word	0x08000bf9

08000ce0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000ce0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8000ce2:	4e14      	ldr	r6, [pc, #80]	@ (8000d34 <chSchWakeupS+0x54>)
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000ce4:	6181      	str	r1, [r0, #24]
  thread_t *otp = currp;
 8000ce6:	6933      	ldr	r3, [r6, #16]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000ce8:	6881      	ldr	r1, [r0, #8]
 8000cea:	689a      	ldr	r2, [r3, #8]
 8000cec:	4291      	cmp	r1, r2
 8000cee:	d803      	bhi.n	8000cf8 <chSchWakeupS+0x18>
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8000cf0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chSchReadyI(ntp);
 8000cf4:	f7ff bf70 	b.w	8000bd8 <chSchReadyI>
 8000cf8:	4604      	mov	r4, r0
    otp = chSchReadyI(otp);
 8000cfa:	4618      	mov	r0, r3
 8000cfc:	f7ff ff6c 	bl	8000bd8 <chSchReadyI>
    ntp->state = CH_STATE_CURRENT;
 8000d00:	2301      	movs	r3, #1
    otp = chSchReadyI(otp);
 8000d02:	4605      	mov	r5, r0
    currp = ntp;
 8000d04:	6134      	str	r4, [r6, #16]
    ntp->state = CH_STATE_CURRENT;
 8000d06:	7523      	strb	r3, [r4, #20]
 8000d08:	f3ef 8309 	mrs	r3, PSP
    chSysSwitch(ntp, otp);
 8000d0c:	6902      	ldr	r2, [r0, #16]
 8000d0e:	3b64      	subs	r3, #100	@ 0x64
 8000d10:	429a      	cmp	r2, r3
 8000d12:	d805      	bhi.n	8000d20 <chSchWakeupS+0x40>
 8000d14:	4629      	mov	r1, r5
 8000d16:	4620      	mov	r0, r4
}
 8000d18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 8000d1c:	f7ff bac4 	b.w	80002a8 <_port_switch>
 8000d20:	4805      	ldr	r0, [pc, #20]	@ (8000d38 <chSchWakeupS+0x58>)
 8000d22:	f7ff fe8b 	bl	8000a3c <chSysHalt>
 8000d26:	4629      	mov	r1, r5
 8000d28:	4620      	mov	r0, r4
}
 8000d2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSysSwitch(ntp, otp);
 8000d2e:	f7ff babb 	b.w	80002a8 <_port_switch>
 8000d32:	bf00      	nop
 8000d34:	20000530 	.word	0x20000530
 8000d38:	0801292c 	.word	0x0801292c

08000d3c <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000d3c:	4b04      	ldr	r3, [pc, #16]	@ (8000d50 <chSchIsPreemptionRequired+0x14>)
 8000d3e:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->prio;
 8000d40:	691b      	ldr	r3, [r3, #16]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8000d42:	6890      	ldr	r0, [r2, #8]
 8000d44:	689b      	ldr	r3, [r3, #8]
#endif
}
 8000d46:	4298      	cmp	r0, r3
 8000d48:	bf94      	ite	ls
 8000d4a:	2000      	movls	r0, #0
 8000d4c:	2001      	movhi	r0, #1
 8000d4e:	4770      	bx	lr
 8000d50:	20000530 	.word	0x20000530

08000d54 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000d54:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8000d56:	4c10      	ldr	r4, [pc, #64]	@ (8000d98 <chSchDoRescheduleAhead+0x44>)
  thread_t *tp = tqp->next;
 8000d58:	6823      	ldr	r3, [r4, #0]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8000d5a:	6920      	ldr	r0, [r4, #16]
  tqp->next             = tp->queue.next;
 8000d5c:	681a      	ldr	r2, [r3, #0]
 8000d5e:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8000d60:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000d62:	6054      	str	r4, [r2, #4]
 8000d64:	7519      	strb	r1, [r3, #20]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000d66:	6123      	str	r3, [r4, #16]
  otp = chSchReadyAheadI(otp);
 8000d68:	f7ff ff62 	bl	8000c30 <chSchReadyAheadI>
 8000d6c:	4605      	mov	r5, r0
 8000d6e:	f3ef 8309 	mrs	r3, PSP

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000d72:	6902      	ldr	r2, [r0, #16]
 8000d74:	3b64      	subs	r3, #100	@ 0x64
 8000d76:	429a      	cmp	r2, r3
 8000d78:	d805      	bhi.n	8000d86 <chSchDoRescheduleAhead+0x32>
 8000d7a:	6920      	ldr	r0, [r4, #16]
 8000d7c:	4629      	mov	r1, r5
}
 8000d7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000d82:	f7ff ba91 	b.w	80002a8 <_port_switch>
 8000d86:	4805      	ldr	r0, [pc, #20]	@ (8000d9c <chSchDoRescheduleAhead+0x48>)
 8000d88:	f7ff fe58 	bl	8000a3c <chSysHalt>
 8000d8c:	6920      	ldr	r0, [r4, #16]
 8000d8e:	4629      	mov	r1, r5
}
 8000d90:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(currp, otp);
 8000d94:	f7ff ba88 	b.w	80002a8 <_port_switch>
 8000d98:	20000530 	.word	0x20000530
 8000d9c:	0801292c 	.word	0x0801292c

08000da0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000da0:	f7ff bfd8 	b.w	8000d54 <chSchDoRescheduleAhead>

08000da4 <_thread_init>:
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000da4:	2102      	movs	r1, #2
  tp->prio      = prio;
 8000da6:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 8000da8:	8281      	strh	r1, [r0, #20]
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 8000daa:	4770      	bx	lr

08000dac <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000dac:	b430      	push	{r4, r5}
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000dae:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000db2:	6902      	ldr	r2, [r0, #16]
 8000db4:	f843 2c44 	str.w	r2, [r3, #-68]
 8000db8:	f1a3 0584 	sub.w	r5, r3, #132	@ 0x84
  tp->state     = CH_STATE_WTSTART;
 8000dbc:	2202      	movs	r2, #2
  tp->wabase = tdp->wbase;
 8000dbe:	e943 5105 	strd	r5, r1, [r3, #-20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000dc2:	4c07      	ldr	r4, [pc, #28]	@ (8000de0 <chThdCreateSuspendedI+0x34>)
 8000dc4:	6945      	ldr	r5, [r0, #20]
  tp->prio      = prio;
 8000dc6:	68c1      	ldr	r1, [r0, #12]
  tp->state     = CH_STATE_WTSTART;
 8000dc8:	f823 2c0c 	strh.w	r2, [r3, #-12]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000dcc:	f843 5c40 	str.w	r5, [r3, #-64]
 8000dd0:	f843 4c24 	str.w	r4, [r3, #-36]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8000dd4:	f1a3 0020 	sub.w	r0, r3, #32
 8000dd8:	bc30      	pop	{r4, r5}
  tp->prio      = prio;
 8000dda:	f843 1c18 	str.w	r1, [r3, #-24]
}
 8000dde:	4770      	bx	lr
 8000de0:	080002c1 	.word	0x080002c1

08000de4 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8000de4:	b510      	push	{r4, lr}
 8000de6:	4604      	mov	r4, r0
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 8000de8:	6840      	ldr	r0, [r0, #4]
                  (uint8_t *)tdp->wend,
 8000dea:	68a2      	ldr	r2, [r4, #8]
  while (startp < endp) {
 8000dec:	4290      	cmp	r0, r2
 8000dee:	d203      	bcs.n	8000df8 <chThdCreate+0x14>
    *startp++ = v;
 8000df0:	1a12      	subs	r2, r2, r0
 8000df2:	2155      	movs	r1, #85	@ 0x55
 8000df4:	f011 fcf6 	bl	80127e4 <memset>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000df8:	2320      	movs	r3, #32
 8000dfa:	f383 8811 	msr	BASEPRI, r3
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8000dfe:	4620      	mov	r0, r4
 8000e00:	f7ff ffd4 	bl	8000dac <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8000e04:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
 8000e06:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8000e08:	f7ff ff6a 	bl	8000ce0 <chSchWakeupS>
 8000e0c:	2300      	movs	r3, #0
 8000e0e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8000e12:	4620      	mov	r0, r4
 8000e14:	bd10      	pop	{r4, pc}
 8000e16:	bf00      	nop

08000e18 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000e1a:	461f      	mov	r7, r3
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8000e1c:	1843      	adds	r3, r0, r1
  while (startp < endp) {
 8000e1e:	4298      	cmp	r0, r3
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000e20:	4605      	mov	r5, r0
 8000e22:	460c      	mov	r4, r1
 8000e24:	4616      	mov	r6, r2
  while (startp < endp) {
 8000e26:	d203      	bcs.n	8000e30 <chThdCreateStatic+0x18>
    *startp++ = v;
 8000e28:	460a      	mov	r2, r1
 8000e2a:	2155      	movs	r1, #85	@ 0x55
 8000e2c:	f011 fcda 	bl	80127e4 <memset>
 8000e30:	2320      	movs	r3, #32
 8000e32:	f383 8811 	msr	BASEPRI, r3
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8000e36:	3c20      	subs	r4, #32
 8000e38:	442c      	add	r4, r5
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e3a:	f1a4 0364 	sub.w	r3, r4, #100	@ 0x64
 8000e3e:	9906      	ldr	r1, [sp, #24]
 8000e40:	4a0a      	ldr	r2, [pc, #40]	@ (8000e6c <chThdCreateStatic+0x54>)
 8000e42:	60e3      	str	r3, [r4, #12]
  tp->state     = CH_STATE_WTSTART;
 8000e44:	2302      	movs	r3, #2
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e46:	f844 1c20 	str.w	r1, [r4, #-32]
  tp->state     = CH_STATE_WTSTART;
 8000e4a:	82a3      	strh	r3, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e4c:	f844 7c24 	str.w	r7, [r4, #-36]
  tp->wabase = (stkalign_t *)wsp;
 8000e50:	6125      	str	r5, [r4, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000e52:	f844 2c04 	str.w	r2, [r4, #-4]
  tp->prio      = prio;
 8000e56:	60a6      	str	r6, [r4, #8]

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000e58:	2100      	movs	r1, #0
 8000e5a:	4620      	mov	r0, r4
 8000e5c:	f7ff ff40 	bl	8000ce0 <chSchWakeupS>
 8000e60:	2300      	movs	r3, #0
 8000e62:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8000e66:	4620      	mov	r0, r4
 8000e68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e6a:	bf00      	nop
 8000e6c:	080002c1 	.word	0x080002c1

08000e70 <chThdExitS>:
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8000e70:	4b03      	ldr	r3, [pc, #12]	@ (8000e80 <chThdExitS+0x10>)

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8000e72:	691b      	ldr	r3, [r3, #16]
void chThdExitS(msg_t msg) {
 8000e74:	4602      	mov	r2, r0
  tp->u.exitcode = msg;
 8000e76:	619a      	str	r2, [r3, #24]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8000e78:	200f      	movs	r0, #15
 8000e7a:	f7ff bee9 	b.w	8000c50 <chSchGoSleepS>
 8000e7e:	bf00      	nop
 8000e80:	20000530 	.word	0x20000530

08000e84 <chThdExit>:
 8000e84:	2320      	movs	r3, #32
 8000e86:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 8000e8a:	f7ff bff1 	b.w	8000e70 <chThdExitS>
 8000e8e:	bf00      	nop

08000e90 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000e90:	b508      	push	{r3, lr}
 8000e92:	4601      	mov	r1, r0
 8000e94:	2320      	movs	r3, #32
 8000e96:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000e9a:	2008      	movs	r0, #8
 8000e9c:	f7ff fefe 	bl	8000c9c <chSchGoSleepTimeoutS>
 8000ea0:	2300      	movs	r3, #0
 8000ea2:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8000ea6:	bd08      	pop	{r3, pc}

08000ea8 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000ea8:	b169      	cbz	r1, 8000ec6 <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000eaa:	4a08      	ldr	r2, [pc, #32]	@ (8000ecc <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000eac:	b410      	push	{r4}
  queue_insert(currp, tqp);
 8000eae:	6912      	ldr	r2, [r2, #16]
  tp->queue.prev             = tqp->prev;
 8000eb0:	6844      	ldr	r4, [r0, #4]
 8000eb2:	4603      	mov	r3, r0
 8000eb4:	e9c2 3400 	strd	r3, r4, [r2]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000eb8:	2004      	movs	r0, #4
  tp->queue.prev->queue.next = tp;
 8000eba:	6022      	str	r2, [r4, #0]
}
 8000ebc:	f85d 4b04 	ldr.w	r4, [sp], #4
  tqp->prev                  = tp;
 8000ec0:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000ec2:	f7ff beeb 	b.w	8000c9c <chSchGoSleepTimeoutS>
}
 8000ec6:	f04f 30ff 	mov.w	r0, #4294967295
 8000eca:	4770      	bx	lr
 8000ecc:	20000530 	.word	0x20000530

08000ed0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8000ed0:	4603      	mov	r3, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000ed2:	6800      	ldr	r0, [r0, #0]

  if (queue_notempty(tqp)) {
 8000ed4:	4283      	cmp	r3, r0
 8000ed6:	d005      	beq.n	8000ee4 <chThdDequeueNextI+0x14>
  tqp->next             = tp->queue.next;
 8000ed8:	6802      	ldr	r2, [r0, #0]
 8000eda:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000edc:	6053      	str	r3, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000ede:	6181      	str	r1, [r0, #24]
  (void) chSchReadyI(tp);
 8000ee0:	f7ff be7a 	b.w	8000bd8 <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000ee4:	4770      	bx	lr
 8000ee6:	bf00      	nop

08000ee8 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8000ee8:	b538      	push	{r3, r4, r5, lr}
 8000eea:	4604      	mov	r4, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000eec:	6800      	ldr	r0, [r0, #0]

  while (queue_notempty(tqp)) {
 8000eee:	4284      	cmp	r4, r0
 8000ef0:	d009      	beq.n	8000f06 <chThdDequeueAllI+0x1e>
 8000ef2:	460d      	mov	r5, r1
  tqp->next             = tp->queue.next;
 8000ef4:	6803      	ldr	r3, [r0, #0]
 8000ef6:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ef8:	605c      	str	r4, [r3, #4]
  tp->u.rdymsg = msg;
 8000efa:	6185      	str	r5, [r0, #24]
  (void) chSchReadyI(tp);
 8000efc:	f7ff fe6c 	bl	8000bd8 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8000f00:	6820      	ldr	r0, [r4, #0]
 8000f02:	4284      	cmp	r4, r0
 8000f04:	d1f6      	bne.n	8000ef4 <chThdDequeueAllI+0xc>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8000f06:	bd38      	pop	{r3, r4, r5, pc}

08000f08 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8000f08:	b480      	push	{r7}
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000f0a:	4a09      	ldr	r2, [pc, #36]	@ (8000f30 <SVC_Handler+0x28>)
 8000f0c:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 8000f0e:	f023 0301 	bic.w	r3, r3, #1
void SVC_Handler(void) {
 8000f12:	af00      	add	r7, sp, #0
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000f14:	6353      	str	r3, [r2, #52]	@ 0x34
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000f16:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000f1a:	3368      	adds	r3, #104	@ 0x68
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000f1c:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000f20:	2300      	movs	r3, #0
 8000f22:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8000f26:	46bd      	mov	sp, r7
 8000f28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f2c:	4770      	bx	lr
 8000f2e:	bf00      	nop
 8000f30:	e000ef00 	.word	0xe000ef00

08000f34 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000f34:	b598      	push	{r3, r4, r7, lr}
 8000f36:	2320      	movs	r3, #32
 8000f38:	af00      	add	r7, sp, #0
 8000f3a:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000f3e:	4b11      	ldr	r3, [pc, #68]	@ (8000f84 <_port_irq_epilogue+0x50>)
 8000f40:	685b      	ldr	r3, [r3, #4]
 8000f42:	f413 6300 	ands.w	r3, r3, #2048	@ 0x800
 8000f46:	d102      	bne.n	8000f4e <_port_irq_epilogue+0x1a>
 8000f48:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000f4c:	bd98      	pop	{r3, r4, r7, pc}
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000f4e:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000f52:	f3ef 8409 	mrs	r4, PSP
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000f56:	4b0c      	ldr	r3, [pc, #48]	@ (8000f88 <_port_irq_epilogue+0x54>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8000f58:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000f5c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8000f5e:	f844 3c08 	str.w	r3, [r4, #-8]
    ctxp->xpsr = (regarm_t)0x01000000;
 8000f62:	f844 2c4c 	str.w	r2, [r4, #-76]
    ctxp--;
 8000f66:	f1a4 0368 	sub.w	r3, r4, #104	@ 0x68
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000f6a:	f383 8809 	msr	PSP, r3
    if (chSchIsPreemptionRequired()) {
 8000f6e:	f7ff fee5 	bl	8000d3c <chSchIsPreemptionRequired>
 8000f72:	b118      	cbz	r0, 8000f7c <_port_irq_epilogue+0x48>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000f74:	4b05      	ldr	r3, [pc, #20]	@ (8000f8c <_port_irq_epilogue+0x58>)
 8000f76:	f844 3c50 	str.w	r3, [r4, #-80]
}
 8000f7a:	bd98      	pop	{r3, r4, r7, pc}
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000f7c:	4b04      	ldr	r3, [pc, #16]	@ (8000f90 <_port_irq_epilogue+0x5c>)
 8000f7e:	f844 3c50 	str.w	r3, [r4, #-80]
}
 8000f82:	bd98      	pop	{r3, r4, r7, pc}
 8000f84:	e000ed00 	.word	0xe000ed00
 8000f88:	e000ef00 	.word	0xe000ef00
 8000f8c:	080002d1 	.word	0x080002d1
 8000f90:	080002d4 	.word	0x080002d4

08000f94 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000f94:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8000f96:	f000 fedb 	bl	8001d50 <hal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000f9a:	f000 faf5 	bl	8001588 <sdInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8000f9e:	f000 fcad 	bl	80018fc <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8000fa2:	f000 fb93 	bl	80016cc <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000fa6:	f001 fa9f 	bl	80024e8 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8000faa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stInit();
 8000fae:	f000 b801 	b.w	8000fb4 <stInit>
 8000fb2:	bf00      	nop

08000fb4 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8000fb4:	f000 bf48 	b.w	8001e48 <st_lld_init>

08000fb8 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fb8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  STM32_ST_TIM->SR     = 0;
 8000fbc:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000fbe:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fc0:	6358      	str	r0, [r3, #52]	@ 0x34
  STM32_ST_TIM->SR     = 0;
 8000fc2:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000fc4:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 8000fc6:	4770      	bx	lr

08000fc8 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000fc8:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000fcc:	2200      	movs	r2, #0
 8000fce:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000fd0:	4770      	bx	lr
 8000fd2:	bf00      	nop

08000fd4 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000fd4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000fd8:	6358      	str	r0, [r3, #52]	@ 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8000fda:	4770      	bx	lr

08000fdc <bqPrepareBuffer>:
}

static void bqPrepareBuffer(io_buffers_queue_t *bqp, size_t size)
{
  /* Writing size field in the buffer.*/
  *((size_t *)(void *)bqp->bwrptr) = size;
 8000fdc:	68c3      	ldr	r3, [r0, #12]
{
 8000fde:	b410      	push	{r4}

  /* Posting the buffer in the queue.*/
  bqp->bcounter++;
  bqp->bwrptr += bqp->bsize;
  if (bqp->bwrptr >= bqp->btop) {
 8000fe0:	6944      	ldr	r4, [r0, #20]
  *((size_t *)(void *)bqp->bwrptr) = size;
 8000fe2:	6019      	str	r1, [r3, #0]
  bqp->bwrptr += bqp->bsize;
 8000fe4:	6981      	ldr	r1, [r0, #24]
  bqp->bcounter++;
 8000fe6:	6882      	ldr	r2, [r0, #8]
  bqp->bwrptr += bqp->bsize;
 8000fe8:	440b      	add	r3, r1
  if (bqp->bwrptr >= bqp->btop) {
 8000fea:	42a3      	cmp	r3, r4
  bqp->bwrptr += bqp->bsize;
 8000fec:	60c3      	str	r3, [r0, #12]
  bqp->bcounter++;
 8000fee:	f102 0201 	add.w	r2, r2, #1
    bqp->bwrptr = bqp->buffers;
 8000ff2:	bf28      	it	cs
 8000ff4:	6a03      	ldrcs	r3, [r0, #32]
  }
}
 8000ff6:	f85d 4b04 	ldr.w	r4, [sp], #4
  bqp->bcounter++;
 8000ffa:	6082      	str	r2, [r0, #8]
    bqp->bwrptr = bqp->buffers;
 8000ffc:	bf28      	it	cs
 8000ffe:	60c3      	strcs	r3, [r0, #12]
}
 8001000:	4770      	bx	lr
 8001002:	bf00      	nop

08001004 <bqObjectInit>:

  osalThreadQueueObjectInit(&bqp->waiting);
  bqp->bcounter  = 0;
  bqp->brdptr    = bp;
  bqp->bwrptr    = bp;
  bqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8001004:	3204      	adds	r2, #4
                   bqnotify_t nfy, void *link) {
 8001006:	b410      	push	{r4}
  bqp->bsize     = size + sizeof (size_t);
  bqp->bn        = n;
  bqp->buffers   = bp;
 8001008:	e9c0 3107 	strd	r3, r1, [r0, #28]
  bqp->bsize     = size + sizeof (size_t);
 800100c:	6182      	str	r2, [r0, #24]
  bqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800100e:	fb03 1202 	mla	r2, r3, r2, r1
  bqp->bcounter  = 0;
 8001012:	2300      	movs	r3, #0
  bqp->ptr       = NULL;
  bqp->top       = NULL;
  bqp->notify    = nfy;
 8001014:	9c01      	ldr	r4, [sp, #4]
  bqp->bcounter  = 0;
 8001016:	6083      	str	r3, [r0, #8]
  bqp->top       = NULL;
 8001018:	e9c0 3309 	strd	r3, r3, [r0, #36]	@ 0x24
                   bqnotify_t nfy, void *link) {
 800101c:	9b02      	ldr	r3, [sp, #8]
  bqp->notify    = nfy;
 800101e:	62c4      	str	r4, [r0, #44]	@ 0x2c
  tqp->next = (thread_t *)tqp;
 8001020:	e9c0 0000 	strd	r0, r0, [r0]
  bqp->bwrptr    = bp;
 8001024:	e9c0 1103 	strd	r1, r1, [r0, #12]
  bqp->link      = link;
}
 8001028:	f85d 4b04 	ldr.w	r4, [sp], #4
  bqp->btop      = bp + ((size + sizeof (size_t)) * n);
 800102c:	6142      	str	r2, [r0, #20]
  bqp->link      = link;
 800102e:	6303      	str	r3, [r0, #48]	@ 0x30
}
 8001030:	4770      	bx	lr
 8001032:	bf00      	nop

08001034 <bqResetI>:
 * @iclass
 */
void bqResetI(io_buffers_queue_t *bqp) {
  osalDbgCheckClassI();

  bqp->bcounter  = 0;
 8001034:	6a01      	ldr	r1, [r0, #32]
 8001036:	2200      	movs	r2, #0
  bqp->brdptr    = bqp->buffers;
  bqp->bwrptr    = bqp->buffers;
 8001038:	e9c0 1103 	strd	r1, r1, [r0, #12]
  bqp->ptr       = NULL;
 800103c:	e9c0 2209 	strd	r2, r2, [r0, #36]	@ 0x24
  bqp->bcounter  = 0;
 8001040:	6082      	str	r2, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001042:	f06f 0101 	mvn.w	r1, #1
 8001046:	f7ff bf4f 	b.w	8000ee8 <chThdDequeueAllI>
 800104a:	bf00      	nop

0800104c <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 800104c:	b508      	push	{r3, lr}
  osalDbgCheckClassI();

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!bqIsFullI(ibqp), "buffers queue full");
  /* Prepare buffer for input */
  bqPrepareBuffer(ibqp, size);
 800104e:	f7ff ffc5 	bl	8000fdc <bqPrepareBuffer>
  /* Waking up one waiting thread, if any.*/
  bq_Restore(ibqp);
}
 8001052:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdDequeueNextI(tqp, msg);
 8001056:	2100      	movs	r1, #0
 8001058:	f7ff bf3a 	b.w	8000ed0 <chThdDequeueNextI>

0800105c <ibqGetFullBufferTimeoutS>:
  if (bqIsEmptyI(bqp))
 800105c:	6883      	ldr	r3, [r0, #8]
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @sclass
 */
msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp, systime_t timeout) {
 800105e:	b510      	push	{r4, lr}
 8001060:	4604      	mov	r4, r0
  if (bqIsEmptyI(bqp))
 8001062:	b13b      	cbz	r3, 8001074 <ibqGetFullBufferTimeoutS+0x18>
  msg_t msg = waitReadyTimeout(ibqp, timeout);
  if (msg == MSG_OK) {
    osalDbgAssert(!bqIsEmptyI(ibqp), "still empty");

    /* Setting up the "current" buffer and its boundary.*/
    ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001064:	6923      	ldr	r3, [r4, #16]
    ibqp->top = ibqp->ptr + *((size_t *)(void *)ibqp->brdptr);
 8001066:	681a      	ldr	r2, [r3, #0]
    ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8001068:	3304      	adds	r3, #4
    ibqp->top = ibqp->ptr + *((size_t *)(void *)ibqp->brdptr);
 800106a:	441a      	add	r2, r3
 800106c:	e9c4 3209 	strd	r3, r2, [r4, #36]	@ 0x24
 8001070:	2000      	movs	r0, #0
  }
  return msg;
}
 8001072:	bd10      	pop	{r4, pc}
  return chThdEnqueueTimeoutS(tqp, time);
 8001074:	f7ff ff18 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 8001078:	2800      	cmp	r0, #0
 800107a:	d0f3      	beq.n	8001064 <ibqGetFullBufferTimeoutS+0x8>
}
 800107c:	bd10      	pop	{r4, pc}
 800107e:	bf00      	nop

08001080 <ibqReleaseEmptyBufferS>:
  if (bqp->brdptr >= bqp->btop) {
 8001080:	e9d0 3104 	ldrd	r3, r1, [r0, #16]
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @sclass
 */
void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8001084:	b410      	push	{r4}
  bqp->brdptr += bqp->bsize;
 8001086:	6984      	ldr	r4, [r0, #24]
  bqp->bcounter--;
 8001088:	6882      	ldr	r2, [r0, #8]
  bqp->brdptr += bqp->bsize;
 800108a:	4423      	add	r3, r4
  if (bqp->brdptr >= bqp->btop) {
 800108c:	428b      	cmp	r3, r1
  bqp->brdptr += bqp->bsize;
 800108e:	6103      	str	r3, [r0, #16]
    bqp->brdptr = bqp->buffers;
 8001090:	bf24      	itt	cs
 8001092:	6a03      	ldrcs	r3, [r0, #32]
 8001094:	6103      	strcs	r3, [r0, #16]
  bqp->bcounter--;
 8001096:	3a01      	subs	r2, #1
  if (bqp->notify != NULL) bqp->notify(bqp);
 8001098:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  bqp->bcounter--;
 800109a:	6082      	str	r2, [r0, #8]

  /* Freeing a buffer slot in the queue.*/
  bqReleaseEmptyBuffer(ibqp);

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 800109c:	2200      	movs	r2, #0
 800109e:	6242      	str	r2, [r0, #36]	@ 0x24
  if (bqp->notify != NULL) bqp->notify(bqp);
 80010a0:	b113      	cbz	r3, 80010a8 <ibqReleaseEmptyBufferS+0x28>
  /* Notifying the buffer release.*/
  bq_Notify(ibqp);
}
 80010a2:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (bqp->notify != NULL) bqp->notify(bqp);
 80010a6:	4718      	bx	r3
}
 80010a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80010ac:	4770      	bx	lr
 80010ae:	bf00      	nop

080010b0 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 80010b0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80010b2:	2320      	movs	r3, #32
 80010b4:	4605      	mov	r5, r0
 80010b6:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 80010ba:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 80010bc:	b174      	cbz	r4, 80010dc <ibqGetTimeout+0x2c>
      return msg;
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 80010be:	f814 6b01 	ldrb.w	r6, [r4], #1
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 80010c2:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
  ibqp->ptr++;
 80010c4:	626c      	str	r4, [r5, #36]	@ 0x24
  if (ibqp->ptr >= ibqp->top) {
 80010c6:	4294      	cmp	r4, r2
 80010c8:	d204      	bcs.n	80010d4 <ibqGetTimeout+0x24>
 80010ca:	2300      	movs	r3, #0
 80010cc:	f383 8811 	msr	BASEPRI, r3
    ibqReleaseEmptyBufferS(ibqp);
  }

  osalSysUnlock();
  return msg;
}
 80010d0:	4630      	mov	r0, r6
 80010d2:	bd70      	pop	{r4, r5, r6, pc}
    ibqReleaseEmptyBufferS(ibqp);
 80010d4:	4628      	mov	r0, r5
 80010d6:	f7ff ffd3 	bl	8001080 <ibqReleaseEmptyBufferS>
 80010da:	e7f6      	b.n	80010ca <ibqGetTimeout+0x1a>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80010dc:	f7ff ffbe 	bl	800105c <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 80010e0:	4606      	mov	r6, r0
 80010e2:	b908      	cbnz	r0, 80010e8 <ibqGetTimeout+0x38>
  msg = (msg_t)*ibqp->ptr;
 80010e4:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
 80010e6:	e7ea      	b.n	80010be <ibqGetTimeout+0xe>
 80010e8:	f384 8811 	msr	BASEPRI, r4
      return msg;
 80010ec:	e7f0      	b.n	80010d0 <ibqGetTimeout+0x20>
 80010ee:	bf00      	nop

080010f0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80010f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80010f4:	4698      	mov	r8, r3
 80010f6:	4605      	mov	r5, r0
 80010f8:	460f      	mov	r7, r1
 80010fa:	4616      	mov	r6, r2
 80010fc:	2320      	movs	r3, #32
 80010fe:	f383 8811 	msr	BASEPRI, r3
  size_t c = 0, size;
 8001102:	f04f 0900 	mov.w	r9, #0
}
 8001106:	e016      	b.n	8001136 <ibqReadTimeout+0x46>
    size = (size_t)(bqp->top - bqp->ptr);
 8001108:	6aac      	ldr	r4, [r5, #40]	@ 0x28
    if (size > (n - c)) {
 800110a:	eba6 0309 	sub.w	r3, r6, r9
    size = (size_t)(bqp->top - bqp->ptr);
 800110e:	1a64      	subs	r4, r4, r1
    if (size > (n - c)) {
 8001110:	429c      	cmp	r4, r3
 8001112:	bf28      	it	cs
 8001114:	461c      	movcs	r4, r3
    else     memcpy(bp, bqp->ptr, size);     // from buffer (read)
 8001116:	4622      	mov	r2, r4
 8001118:	4638      	mov	r0, r7
 800111a:	f011 fb7f 	bl	801281c <memcpy>
    if (bqp->ptr >= bqp->top) {
 800111e:	e9d5 0309 	ldrd	r0, r3, [r5, #36]	@ 0x24
    bqp->ptr += size;
 8001122:	4420      	add	r0, r4
    if (bqp->ptr >= bqp->top) {
 8001124:	4298      	cmp	r0, r3
    bqp->ptr += size;
 8001126:	6268      	str	r0, [r5, #36]	@ 0x24
    c        += size;
 8001128:	44a1      	add	r9, r4
      else     ibqReleaseEmptyBufferS(bqp);                           // Read complete  (empty)
 800112a:	4628      	mov	r0, r5
    if (bqp->ptr >= bqp->top) {
 800112c:	d301      	bcc.n	8001132 <ibqReadTimeout+0x42>
      else     ibqReleaseEmptyBufferS(bqp);                           // Read complete  (empty)
 800112e:	f7ff ffa7 	bl	8001080 <ibqReleaseEmptyBufferS>
  } while(c < n);
 8001132:	454e      	cmp	r6, r9
 8001134:	d909      	bls.n	800114a <ibqReadTimeout+0x5a>
    if (bqp->ptr == NULL) {
 8001136:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 8001138:	2900      	cmp	r1, #0
 800113a:	d1e5      	bne.n	8001108 <ibqReadTimeout+0x18>
                        ibqGetFullBufferTimeoutS(bqp, timeout);
 800113c:	4641      	mov	r1, r8
 800113e:	4628      	mov	r0, r5
 8001140:	f7ff ff8c 	bl	800105c <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 8001144:	b908      	cbnz	r0, 800114a <ibqReadTimeout+0x5a>
    size = (size_t)(bqp->top - bqp->ptr);
 8001146:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 8001148:	e7de      	b.n	8001108 <ibqReadTimeout+0x18>
 800114a:	2300      	movs	r3, #0
 800114c:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(n > 0U);
  return bqCopyTimeout(ibqp, false, bp, n, timeout);
}
 8001150:	4648      	mov	r0, r9
 8001152:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001156:	bf00      	nop

08001158 <ibqGetEmptyBufferI>:
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  if (bqIsFullI(ibqp)) {
 8001158:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
 800115c:	4293      	cmp	r3, r2
 800115e:	d001      	beq.n	8001164 <ibqGetEmptyBufferI+0xc>
    return NULL;
  }

  return ibqp->bwrptr + sizeof (size_t);
 8001160:	1d18      	adds	r0, r3, #4
 8001162:	4770      	bx	lr
  if (bqIsFullI(ibqp)) {
 8001164:	6882      	ldr	r2, [r0, #8]
 8001166:	2a00      	cmp	r2, #0
 8001168:	d0fa      	beq.n	8001160 <ibqGetEmptyBufferI+0x8>
    return NULL;
 800116a:	2000      	movs	r0, #0
}
 800116c:	4770      	bx	lr
 800116e:	bf00      	nop

08001170 <obqGetFullBufferI>:
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp, size_t *sizep) {
  osalDbgCheckClassI();

  if (bqIsEmptyI(obqp)) {
 8001170:	6883      	ldr	r3, [r0, #8]
 8001172:	b123      	cbz	r3, 800117e <obqGetFullBufferI+0xe>
    return NULL;
  }
  /* Buffer size.*/
  *sizep = *((size_t *)(void *)obqp->brdptr);
 8001174:	6900      	ldr	r0, [r0, #16]
 8001176:	f850 3b04 	ldr.w	r3, [r0], #4
 800117a:	600b      	str	r3, [r1, #0]
  return obqp->brdptr + sizeof (size_t);
 800117c:	4770      	bx	lr
    return NULL;
 800117e:	4618      	mov	r0, r3
}
 8001180:	4770      	bx	lr
 8001182:	bf00      	nop

08001184 <obqReleaseEmptyBufferI>:
  if (bqp->brdptr >= bqp->btop) {
 8001184:	e9d0 3104 	ldrd	r3, r1, [r0, #16]
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8001188:	b410      	push	{r4}
  bqp->brdptr += bqp->bsize;
 800118a:	6984      	ldr	r4, [r0, #24]
  bqp->bcounter--;
 800118c:	6882      	ldr	r2, [r0, #8]
  bqp->brdptr += bqp->bsize;
 800118e:	4423      	add	r3, r4
  if (bqp->brdptr >= bqp->btop) {
 8001190:	428b      	cmp	r3, r1
  bqp->brdptr += bqp->bsize;
 8001192:	6103      	str	r3, [r0, #16]
  bqp->bcounter--;
 8001194:	f102 32ff 	add.w	r2, r2, #4294967295
    bqp->brdptr = bqp->buffers;
 8001198:	bf28      	it	cs
 800119a:	6a03      	ldrcs	r3, [r0, #32]
  osalDbgAssert(!bqIsEmptyI(obqp), "buffers queue empty");
  /* Freeing a buffer slot in the queue.*/
  bqReleaseEmptyBuffer(obqp);
  /* Waking up one waiting thread, if any.*/
  bq_Restore(obqp);
}
 800119c:	f85d 4b04 	ldr.w	r4, [sp], #4
  bqp->bcounter--;
 80011a0:	6082      	str	r2, [r0, #8]
    bqp->brdptr = bqp->buffers;
 80011a2:	bf28      	it	cs
 80011a4:	6103      	strcs	r3, [r0, #16]
  chThdDequeueNextI(tqp, msg);
 80011a6:	2100      	movs	r1, #0
 80011a8:	f7ff be92 	b.w	8000ed0 <chThdDequeueNextI>

080011ac <obqGetEmptyBufferTimeoutS>:
  if (bqIsFullI(bqp))
 80011ac:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
 80011b0:	4293      	cmp	r3, r2
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 80011b2:	b510      	push	{r4, lr}
 80011b4:	4604      	mov	r4, r0
  if (bqIsFullI(bqp))
 80011b6:	d006      	beq.n	80011c6 <obqGetEmptyBufferTimeoutS+0x1a>
  msg_t msg = waitFreeTimeout(obqp, timeout);
  if (msg == MSG_OK) {
    osalDbgAssert(!bqIsFullI(obqp), "still full");
    /* Setting up the "current" buffer and its boundary.*/
    obqp->ptr = obqp->bwrptr + sizeof (size_t);
    obqp->top = obqp->bwrptr + obqp->bsize;
 80011b8:	69a1      	ldr	r1, [r4, #24]
    obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80011ba:	1d1a      	adds	r2, r3, #4
    obqp->top = obqp->bwrptr + obqp->bsize;
 80011bc:	440b      	add	r3, r1
 80011be:	e9c4 2309 	strd	r2, r3, [r4, #36]	@ 0x24
 80011c2:	2000      	movs	r0, #0
  }
  return msg;
}
 80011c4:	bd10      	pop	{r4, pc}
  if (bqIsFullI(bqp))
 80011c6:	6882      	ldr	r2, [r0, #8]
 80011c8:	2a00      	cmp	r2, #0
 80011ca:	d0f5      	beq.n	80011b8 <obqGetEmptyBufferTimeoutS+0xc>
  return chThdEnqueueTimeoutS(tqp, time);
 80011cc:	f7ff fe6c 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 80011d0:	2800      	cmp	r0, #0
 80011d2:	d1f7      	bne.n	80011c4 <obqGetEmptyBufferTimeoutS+0x18>
    obqp->ptr = obqp->bwrptr + sizeof (size_t);
 80011d4:	68e3      	ldr	r3, [r4, #12]
 80011d6:	e7ef      	b.n	80011b8 <obqGetEmptyBufferTimeoutS+0xc>

080011d8 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80011d8:	b510      	push	{r4, lr}

  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!bqIsFullI(obqp), "buffers queue full");
  /* Prepare buffer for output */
  bqPrepareBuffer(obqp, size);
 80011da:	f7ff feff 	bl	8000fdc <bqPrepareBuffer>
  if (bqp->notify != NULL) bqp->notify(bqp);
 80011de:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80011e0:	2200      	movs	r2, #0
 80011e2:	6242      	str	r2, [r0, #36]	@ 0x24
  if (bqp->notify != NULL) bqp->notify(bqp);
 80011e4:	b113      	cbz	r3, 80011ec <obqPostFullBufferS+0x14>
  /* Notifying the buffer release.*/
  bq_Notify(obqp);
}
 80011e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (bqp->notify != NULL) bqp->notify(bqp);
 80011ea:	4718      	bx	r3
}
 80011ec:	bd10      	pop	{r4, pc}
 80011ee:	bf00      	nop

080011f0 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 80011f0:	b570      	push	{r4, r5, r6, lr}
 80011f2:	2320      	movs	r3, #32
 80011f4:	4604      	mov	r4, r0
 80011f6:	460d      	mov	r5, r1
 80011f8:	f383 8811 	msr	BASEPRI, r3
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 80011fc:	6a46      	ldr	r6, [r0, #36]	@ 0x24
 80011fe:	b186      	cbz	r6, 8001222 <obqPutTimeout+0x32>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8001200:	7035      	strb	r5, [r6, #0]
  obqp->ptr++;

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8001202:	e9d4 3209 	ldrd	r3, r2, [r4, #36]	@ 0x24
  obqp->ptr++;
 8001206:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
 8001208:	4293      	cmp	r3, r2
  obqp->ptr++;
 800120a:	6263      	str	r3, [r4, #36]	@ 0x24
  if (obqp->ptr >= obqp->top) {
 800120c:	d203      	bcs.n	8001216 <obqPutTimeout+0x26>
 800120e:	2000      	movs	r0, #0
 8001210:	f380 8811 	msr	BASEPRI, r0
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  }

  osalSysUnlock();
  return MSG_OK;
}
 8001214:	bd70      	pop	{r4, r5, r6, pc}
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8001216:	69a1      	ldr	r1, [r4, #24]
 8001218:	4620      	mov	r0, r4
 800121a:	3904      	subs	r1, #4
 800121c:	f7ff ffdc 	bl	80011d8 <obqPostFullBufferS>
 8001220:	e7f5      	b.n	800120e <obqPutTimeout+0x1e>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8001222:	4611      	mov	r1, r2
 8001224:	f7ff ffc2 	bl	80011ac <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8001228:	b908      	cbnz	r0, 800122e <obqPutTimeout+0x3e>
  *obqp->ptr = b;
 800122a:	6a66      	ldr	r6, [r4, #36]	@ 0x24
 800122c:	e7e8      	b.n	8001200 <obqPutTimeout+0x10>
 800122e:	f386 8811 	msr	BASEPRI, r6
}
 8001232:	bd70      	pop	{r4, r5, r6, pc}

08001234 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001234:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001238:	4699      	mov	r9, r3
 800123a:	4605      	mov	r5, r0
 800123c:	4688      	mov	r8, r1
 800123e:	4617      	mov	r7, r2
 8001240:	2320      	movs	r3, #32
 8001242:	f383 8811 	msr	BASEPRI, r3
  size_t c = 0, size;
 8001246:	2600      	movs	r6, #0
}
 8001248:	e018      	b.n	800127c <obqWriteTimeout+0x48>
    size = (size_t)(bqp->top - bqp->ptr);
 800124a:	6aac      	ldr	r4, [r5, #40]	@ 0x28
    if (size > (n - c)) {
 800124c:	1bbb      	subs	r3, r7, r6
    size = (size_t)(bqp->top - bqp->ptr);
 800124e:	1a24      	subs	r4, r4, r0
    if (size > (n - c)) {
 8001250:	429c      	cmp	r4, r3
 8001252:	bf28      	it	cs
 8001254:	461c      	movcs	r4, r3
    if (dir) memcpy(bqp->ptr, &bp[c], size); // to buffer (write)
 8001256:	4622      	mov	r2, r4
 8001258:	eb08 0106 	add.w	r1, r8, r6
 800125c:	f011 fade 	bl	801281c <memcpy>
    if (bqp->ptr >= bqp->top) {
 8001260:	e9d5 3209 	ldrd	r3, r2, [r5, #36]	@ 0x24
    bqp->ptr += size;
 8001264:	4423      	add	r3, r4
    if (bqp->ptr >= bqp->top) {
 8001266:	4293      	cmp	r3, r2
    bqp->ptr += size;
 8001268:	626b      	str	r3, [r5, #36]	@ 0x24
    c        += size;
 800126a:	4426      	add	r6, r4
      if (dir) obqPostFullBufferS(bqp, bqp->bsize - sizeof (size_t)); // Write complete (full)
 800126c:	4628      	mov	r0, r5
    if (bqp->ptr >= bqp->top) {
 800126e:	d303      	bcc.n	8001278 <obqWriteTimeout+0x44>
      if (dir) obqPostFullBufferS(bqp, bqp->bsize - sizeof (size_t)); // Write complete (full)
 8001270:	69a9      	ldr	r1, [r5, #24]
 8001272:	3904      	subs	r1, #4
 8001274:	f7ff ffb0 	bl	80011d8 <obqPostFullBufferS>
  } while(c < n);
 8001278:	42b7      	cmp	r7, r6
 800127a:	d909      	bls.n	8001290 <obqWriteTimeout+0x5c>
    if (bqp->ptr == NULL) {
 800127c:	6a68      	ldr	r0, [r5, #36]	@ 0x24
 800127e:	2800      	cmp	r0, #0
 8001280:	d1e3      	bne.n	800124a <obqWriteTimeout+0x16>
      msg_t msg = dir ? obqGetEmptyBufferTimeoutS(bqp, timeout) :
 8001282:	4649      	mov	r1, r9
 8001284:	4628      	mov	r0, r5
 8001286:	f7ff ff91 	bl	80011ac <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 800128a:	b908      	cbnz	r0, 8001290 <obqWriteTimeout+0x5c>
    size = (size_t)(bqp->top - bqp->ptr);
 800128c:	6a68      	ldr	r0, [r5, #36]	@ 0x24
 800128e:	e7dc      	b.n	800124a <obqWriteTimeout+0x16>
 8001290:	2300      	movs	r3, #0
 8001292:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(n > 0U);
  return bqCopyTimeout(obqp, true, (uint8_t *)bp, n, timeout);
}
 8001296:	4630      	mov	r0, r6
 8001298:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800129c <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 800129c:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (bqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 800129e:	6885      	ldr	r5, [r0, #8]
 80012a0:	b945      	cbnz	r5, 80012b4 <obqTryFlushI+0x18>
 80012a2:	6a41      	ldr	r1, [r0, #36]	@ 0x24
 80012a4:	4604      	mov	r4, r0
 80012a6:	b129      	cbz	r1, 80012b4 <obqTryFlushI+0x18>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80012a8:	68c3      	ldr	r3, [r0, #12]
 80012aa:	3904      	subs	r1, #4

    if (size > 0U) {
 80012ac:	1ac9      	subs	r1, r1, r3
 80012ae:	d103      	bne.n	80012b8 <obqTryFlushI+0x1c>
      /* No "current" buffer.*/
      obqp->ptr = NULL;
      return true;
    }
  }
  return false;
 80012b0:	4608      	mov	r0, r1
}
 80012b2:	bd38      	pop	{r3, r4, r5, pc}
  return false;
 80012b4:	2000      	movs	r0, #0
}
 80012b6:	bd38      	pop	{r3, r4, r5, pc}
      bqPrepareBuffer(obqp, size);
 80012b8:	f7ff fe90 	bl	8000fdc <bqPrepareBuffer>
      return true;
 80012bc:	2001      	movs	r0, #1
      obqp->ptr = NULL;
 80012be:	6265      	str	r5, [r4, #36]	@ 0x24
}
 80012c0:	bd38      	pop	{r3, r4, r5, pc}
 80012c2:	bf00      	nop

080012c4 <q_GetI>:
    return osalThreadEnqueueTimeoutS(&qp->q_waiting, timeout);
  return MSG_OK;
}

/* Getting the character from the queue.*/
static msg_t q_GetI(io_queue_t *qp) {
 80012c4:	4603      	mov	r3, r0
 80012c6:	b410      	push	{r4}
  qp->q_counter--;
 80012c8:	6919      	ldr	r1, [r3, #16]
  uint8_t b = qp->q_buffer[qp->q_rd++];
 80012ca:	69c0      	ldr	r0, [r0, #28]
 80012cc:	68dc      	ldr	r4, [r3, #12]
  qp->q_counter--;
 80012ce:	3901      	subs	r1, #1
 80012d0:	6119      	str	r1, [r3, #16]
  if (qp->q_rd >= qp->q_size) qp->q_rd = 0;
 80012d2:	6959      	ldr	r1, [r3, #20]
  uint8_t b = qp->q_buffer[qp->q_rd++];
 80012d4:	1c42      	adds	r2, r0, #1
 80012d6:	61da      	str	r2, [r3, #28]
  if (qp->q_rd >= qp->q_size) qp->q_rd = 0;
 80012d8:	428a      	cmp	r2, r1
 80012da:	bf28      	it	cs
 80012dc:	2200      	movcs	r2, #0
  uint8_t b = qp->q_buffer[qp->q_rd++];
 80012de:	5c20      	ldrb	r0, [r4, r0]
  if (qp->q_rd >= qp->q_size) qp->q_rd = 0;
 80012e0:	61da      	str	r2, [r3, #28]

  return (msg_t)b;
}
 80012e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80012e6:	4770      	bx	lr

080012e8 <q_PutI>:

/* Putting the character into the queue.*/
static void q_PutI(io_queue_t *qp, uint8_t b) {
  qp->q_counter++;
 80012e8:	6903      	ldr	r3, [r0, #16]
  qp->q_buffer[qp->q_wr++] = b;
 80012ea:	6982      	ldr	r2, [r0, #24]
  qp->q_counter++;
 80012ec:	3301      	adds	r3, #1
 80012ee:	6103      	str	r3, [r0, #16]
  qp->q_buffer[qp->q_wr++] = b;
 80012f0:	1c53      	adds	r3, r2, #1
 80012f2:	6183      	str	r3, [r0, #24]
 80012f4:	68c3      	ldr	r3, [r0, #12]
 80012f6:	5499      	strb	r1, [r3, r2]
  if (qp->q_wr >= qp->q_size) qp->q_wr = 0;
 80012f8:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 80012fc:	4293      	cmp	r3, r2
 80012fe:	bf28      	it	cs
 8001300:	2300      	movcs	r3, #0
 8001302:	6183      	str	r3, [r0, #24]
}
 8001304:	4770      	bx	lr
 8001306:	bf00      	nop

08001308 <qObjectInit>:
 *                      data is read from the queue. The value can be @p NULL.
 * @param[in] link      application defined pointer
 *
 * @init
 */
void qObjectInit(io_queue_t *iqp, uint8_t *bp, qsize_t size, qnotify_t infy) {
 8001308:	b410      	push	{r4}
  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800130a:	2400      	movs	r4, #0
  iqp->q_buffer  = bp;
 800130c:	e9c0 1403 	strd	r1, r4, [r0, #12]
  iqp->q_rd      = 0;
  iqp->q_wr      = 0;
 8001310:	e9c0 4406 	strd	r4, r4, [r0, #24]
 8001314:	e9c0 0000 	strd	r0, r0, [r0]
  iqp->q_size    = size;
  iqp->q_notify  = infy;
}
 8001318:	f85d 4b04 	ldr.w	r4, [sp], #4
  iqp->q_size    = size;
 800131c:	6142      	str	r2, [r0, #20]
  iqp->q_notify  = infy;
 800131e:	6083      	str	r3, [r0, #8]
}
 8001320:	4770      	bx	lr
 8001322:	bf00      	nop

08001324 <qResetI>:
 * @iclass
 */
void qResetI(io_queue_t *iqp) {
  osalDbgCheckClassI();
  iqp->q_rd      = 0;
  iqp->q_wr      = 0;
 8001324:	2200      	movs	r2, #0
 8001326:	e9c0 2206 	strd	r2, r2, [r0, #24]
  iqp->q_counter = 0;
 800132a:	6102      	str	r2, [r0, #16]
  chThdDequeueAllI(tqp, msg);
 800132c:	f06f 0101 	mvn.w	r1, #1
 8001330:	f7ff bdda 	b.w	8000ee8 <chThdDequeueAllI>

08001334 <qPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t qPutI(io_queue_t *iqp, uint8_t b) {
 8001334:	b508      	push	{r3, lr}
  osalDbgCheckClassI();
  if (qIsFullI(iqp)) {
 8001336:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 800133a:	429a      	cmp	r2, r3
 800133c:	d206      	bcs.n	800134c <qPutI+0x18>
    return MSG_TIMEOUT;
  }
  q_PutI(iqp, b);
 800133e:	f7ff ffd3 	bl	80012e8 <q_PutI>
  chThdDequeueNextI(tqp, msg);
 8001342:	2100      	movs	r1, #0
 8001344:	f7ff fdc4 	bl	8000ed0 <chThdDequeueNextI>
  q_Restore(iqp);
  return MSG_OK;
 8001348:	2000      	movs	r0, #0
}
 800134a:	bd08      	pop	{r3, pc}
    return MSG_TIMEOUT;
 800134c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8001350:	bd08      	pop	{r3, pc}
 8001352:	bf00      	nop

08001354 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001354:	b538      	push	{r3, r4, r5, lr}
 8001356:	4604      	mov	r4, r0
 8001358:	2320      	movs	r3, #32
 800135a:	f383 8811 	msr	BASEPRI, r3
  if (qIsEmptyI(qp))
 800135e:	6903      	ldr	r3, [r0, #16]
 8001360:	b163      	cbz	r3, 800137c <iqGetTimeout+0x28>
  osalSysLock();
  /* Waiting until there is a character available or a timeout occurs.*/
  msg_t msg = waitReadyTimeout(iqp, timeout);
  if (msg == MSG_OK) {
    /* Getting the character from the queue.*/
    msg = q_GetI(iqp);
 8001362:	4620      	mov	r0, r4
 8001364:	f7ff ffae 	bl	80012c4 <q_GetI>
  if (qp->q_notify != NULL) qp->q_notify(qp);
 8001368:	68a3      	ldr	r3, [r4, #8]
    msg = q_GetI(iqp);
 800136a:	4605      	mov	r5, r0
  if (qp->q_notify != NULL) qp->q_notify(qp);
 800136c:	b10b      	cbz	r3, 8001372 <iqGetTimeout+0x1e>
 800136e:	4620      	mov	r0, r4
 8001370:	4798      	blx	r3
 8001372:	2300      	movs	r3, #0
 8001374:	f383 8811 	msr	BASEPRI, r3
    /* Inform the low side that the queue has at least one slot available.*/
    q_Notify(iqp);
  }
  osalSysUnlock();
  return msg;
}
 8001378:	4628      	mov	r0, r5
 800137a:	bd38      	pop	{r3, r4, r5, pc}
  return chThdEnqueueTimeoutS(tqp, time);
 800137c:	f7ff fd94 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 8001380:	4605      	mov	r5, r0
 8001382:	2800      	cmp	r0, #0
 8001384:	d0ed      	beq.n	8001362 <iqGetTimeout+0xe>
 8001386:	2300      	movs	r3, #0
 8001388:	f383 8811 	msr	BASEPRI, r3
}
 800138c:	4628      	mov	r0, r5
 800138e:	bd38      	pop	{r3, r4, r5, pc}

08001390 <iqReadTimeout>:
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
qsize_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp, qsize_t n, systime_t timeout) {
 8001390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001394:	b083      	sub	sp, #12
 8001396:	4604      	mov	r4, r0
 8001398:	9301      	str	r3, [sp, #4]
 800139a:	4688      	mov	r8, r1
 800139c:	4617      	mov	r7, r2
 800139e:	2320      	movs	r3, #32
 80013a0:	f383 8811 	msr	BASEPRI, r3
  qsize_t r = 0;
 80013a4:	f04f 0a00 	mov.w	sl, #0
}
 80013a8:	e010      	b.n	80013cc <iqReadTimeout+0x3c>
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     n);
 80013aa:	462a      	mov	r2, r5
 80013ac:	4618      	mov	r0, r3
 80013ae:	f011 fa35 	bl	801281c <memcpy>
  iqp->q_rd      += n;
 80013b2:	69e6      	ldr	r6, [r4, #28]
 80013b4:	442e      	add	r6, r5
  iqp->q_counter -= n;
 80013b6:	6923      	ldr	r3, [r4, #16]
  iqp->q_rd      += n;
 80013b8:	61e6      	str	r6, [r4, #28]
  iqp->q_counter -= n;
 80013ba:	1b5b      	subs	r3, r3, r5
 80013bc:	6123      	str	r3, [r4, #16]
  osalSysLock();
  while (waitReadyTimeout(iqp, timeout) == MSG_OK) {
    qsize_t done = q_read(iqp, &bp[r], n - r);
    /* Inform the low side that the queue has at least one empty slot available.*/
    q_Notify(iqp);
    r += done;
 80013be:	44aa      	add	sl, r5
  if (qp->q_notify != NULL) qp->q_notify(qp);
 80013c0:	68a3      	ldr	r3, [r4, #8]
 80013c2:	b10b      	cbz	r3, 80013c8 <iqReadTimeout+0x38>
 80013c4:	4620      	mov	r0, r4
 80013c6:	4798      	blx	r3
    if (r >= n) break;
 80013c8:	4557      	cmp	r7, sl
 80013ca:	d929      	bls.n	8001420 <iqReadTimeout+0x90>
  if (qIsEmptyI(qp))
 80013cc:	6923      	ldr	r3, [r4, #16]
 80013ce:	b303      	cbz	r3, 8001412 <iqReadTimeout+0x82>
    qsize_t done = q_read(iqp, &bp[r], n - r);
 80013d0:	eba7 050a 	sub.w	r5, r7, sl
  if (n > s) n = s;
 80013d4:	429d      	cmp	r5, r3
 80013d6:	bf28      	it	cs
 80013d8:	461d      	movcs	r5, r3
  if (n == 0) return 0;
 80013da:	2d00      	cmp	r5, #0
 80013dc:	d0f0      	beq.n	80013c0 <iqReadTimeout+0x30>
  if (n == 1) {
 80013de:	2d01      	cmp	r5, #1
    qsize_t done = q_read(iqp, &bp[r], n - r);
 80013e0:	eb08 030a 	add.w	r3, r8, sl
  if (n == 1) {
 80013e4:	d023      	beq.n	800142e <iqReadTimeout+0x9e>
  s = iqp->q_size - iqp->q_rd;
 80013e6:	69e6      	ldr	r6, [r4, #28]
 80013e8:	f8d4 b014 	ldr.w	fp, [r4, #20]
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     n);
 80013ec:	68e1      	ldr	r1, [r4, #12]
  s = iqp->q_size - iqp->q_rd;
 80013ee:	ebab 0906 	sub.w	r9, fp, r6
  if (n < s) {
 80013f2:	454d      	cmp	r5, r9
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     n);
 80013f4:	4431      	add	r1, r6
  if (n < s) {
 80013f6:	d3d8      	bcc.n	80013aa <iqReadTimeout+0x1a>
    memcpy((void *)&bp[0], (void *)&iqp->q_buffer[iqp->q_rd],     s);
 80013f8:	464a      	mov	r2, r9
 80013fa:	4618      	mov	r0, r3
 80013fc:	f011 fa0e 	bl	801281c <memcpy>
    memcpy((void *)&bp[s], (void *)&iqp->q_buffer[0        ], n - s);
 8001400:	eba6 060b 	sub.w	r6, r6, fp
 8001404:	442e      	add	r6, r5
 8001406:	68e1      	ldr	r1, [r4, #12]
 8001408:	4448      	add	r0, r9
 800140a:	4632      	mov	r2, r6
 800140c:	f011 fa06 	bl	801281c <memcpy>
    iqp->q_rd = -s;
 8001410:	e7d1      	b.n	80013b6 <iqReadTimeout+0x26>
  return chThdEnqueueTimeoutS(tqp, time);
 8001412:	9901      	ldr	r1, [sp, #4]
 8001414:	4620      	mov	r0, r4
 8001416:	f7ff fd47 	bl	8000ea8 <chThdEnqueueTimeoutS>
  while (waitReadyTimeout(iqp, timeout) == MSG_OK) {
 800141a:	b908      	cbnz	r0, 8001420 <iqReadTimeout+0x90>
  qsize_t s = qGetFullI(iqp);
 800141c:	6923      	ldr	r3, [r4, #16]
 800141e:	e7d7      	b.n	80013d0 <iqReadTimeout+0x40>
 8001420:	2300      	movs	r3, #0
 8001422:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return r;
}
 8001426:	4650      	mov	r0, sl
 8001428:	b003      	add	sp, #12
 800142a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *bp = q_GetI(iqp);
 800142e:	4620      	mov	r0, r4
 8001430:	f7ff ff48 	bl	80012c4 <q_GetI>
 8001434:	f808 000a 	strb.w	r0, [r8, sl]
    r += done;
 8001438:	f10a 0a01 	add.w	sl, sl, #1
    return 1;
 800143c:	e7c0      	b.n	80013c0 <iqReadTimeout+0x30>
 800143e:	bf00      	nop

08001440 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001440:	b538      	push	{r3, r4, r5, lr}
 8001442:	4604      	mov	r4, r0
 8001444:	460d      	mov	r5, r1
 8001446:	2320      	movs	r3, #32
 8001448:	f383 8811 	msr	BASEPRI, r3
  if (qIsFullI(qp))
 800144c:	e9d0 1304 	ldrd	r1, r3, [r0, #16]
 8001450:	4299      	cmp	r1, r3
 8001452:	d20b      	bcs.n	800146c <oqPutTimeout+0x2c>
  osalSysLock();
  /* Waiting until there is a slot available or a timeout occurs.*/
  msg_t msg = waitFreeTimeout(oqp, timeout);
  if (msg == MSG_OK) {
    /* Putting the character into the queue.*/
    q_PutI(oqp, b);
 8001454:	4629      	mov	r1, r5
 8001456:	4620      	mov	r0, r4
 8001458:	f7ff ff46 	bl	80012e8 <q_PutI>
  if (qp->q_notify != NULL) qp->q_notify(qp);
 800145c:	68a3      	ldr	r3, [r4, #8]
 800145e:	b103      	cbz	r3, 8001462 <oqPutTimeout+0x22>
 8001460:	4798      	blx	r3
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001462:	2000      	movs	r0, #0
 8001464:	2300      	movs	r3, #0
 8001466:	f383 8811 	msr	BASEPRI, r3
    /* Inform the low side that the queue has at least one character available.*/
    q_Notify(oqp);
  }
  osalSysUnlock();
  return msg;
}
 800146a:	bd38      	pop	{r3, r4, r5, pc}
 800146c:	4611      	mov	r1, r2
 800146e:	f7ff fd1b 	bl	8000ea8 <chThdEnqueueTimeoutS>
  if (msg == MSG_OK) {
 8001472:	2800      	cmp	r0, #0
 8001474:	d0ee      	beq.n	8001454 <oqPutTimeout+0x14>
 8001476:	2300      	movs	r3, #0
 8001478:	f383 8811 	msr	BASEPRI, r3
}
 800147c:	bd38      	pop	{r3, r4, r5, pc}
 800147e:	bf00      	nop

08001480 <qGetI>:
 *
 * @iclass
 */
msg_t qGetI(io_queue_t *oqp) {
  osalDbgCheckClassI();
  if (qIsEmptyI(oqp))
 8001480:	6903      	ldr	r3, [r0, #16]
msg_t qGetI(io_queue_t *oqp) {
 8001482:	b510      	push	{r4, lr}
  if (qIsEmptyI(oqp))
 8001484:	b153      	cbz	r3, 800149c <qGetI+0x1c>
 8001486:	4604      	mov	r4, r0
    return MSG_TIMEOUT;
  msg_t b = q_GetI(oqp);
 8001488:	f7ff ff1c 	bl	80012c4 <q_GetI>
  chThdDequeueNextI(tqp, msg);
 800148c:	2100      	movs	r1, #0
 800148e:	4603      	mov	r3, r0
 8001490:	4620      	mov	r0, r4
 8001492:	461c      	mov	r4, r3
 8001494:	f7ff fd1c 	bl	8000ed0 <chThdDequeueNextI>
  q_Restore(oqp); // Restore on last byte
  return b;
}
 8001498:	4620      	mov	r0, r4
 800149a:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
 800149c:	f04f 34ff 	mov.w	r4, #4294967295
 80014a0:	e7fa      	b.n	8001498 <qGetI+0x18>
 80014a2:	bf00      	nop

080014a4 <oqWriteTimeout>:
 *                      .
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
qsize_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp, qsize_t n, systime_t timeout) {
 80014a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80014a8:	b083      	sub	sp, #12
 80014aa:	4605      	mov	r5, r0
 80014ac:	9301      	str	r3, [sp, #4]
 80014ae:	4688      	mov	r8, r1
 80014b0:	2320      	movs	r3, #32
 80014b2:	f383 8811 	msr	BASEPRI, r3
  qsize_t w = 0;
 80014b6:	2600      	movs	r6, #0
 80014b8:	4691      	mov	r9, r2
}
 80014ba:	e00f      	b.n	80014dc <oqWriteTimeout+0x38>
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     n);
 80014bc:	4622      	mov	r2, r4
 80014be:	f011 f9ad 	bl	801281c <memcpy>
  oqp->q_wr      += n;
 80014c2:	69af      	ldr	r7, [r5, #24]
 80014c4:	4427      	add	r7, r4
  oqp->q_counter += n;
 80014c6:	692b      	ldr	r3, [r5, #16]
  oqp->q_wr      += n;
 80014c8:	61af      	str	r7, [r5, #24]
  oqp->q_counter += n;
 80014ca:	4423      	add	r3, r4
 80014cc:	612b      	str	r3, [r5, #16]
  osalSysLock();
  while (waitFreeTimeout(oqp, timeout) == MSG_OK) {
    qsize_t done = q_write(oqp, &bp[w], n - w);
    /* Inform the low side that the queue has at least one character available.*/
    q_Notify(oqp);
    w += done;
 80014ce:	4426      	add	r6, r4
  if (qp->q_notify != NULL) qp->q_notify(qp);
 80014d0:	68ab      	ldr	r3, [r5, #8]
 80014d2:	b10b      	cbz	r3, 80014d8 <oqWriteTimeout+0x34>
 80014d4:	4628      	mov	r0, r5
 80014d6:	4798      	blx	r3
    if (w >= n) break;
 80014d8:	45b1      	cmp	r9, r6
 80014da:	d92e      	bls.n	800153a <oqWriteTimeout+0x96>
  if (qIsFullI(qp))
 80014dc:	e9d5 3704 	ldrd	r3, r7, [r5, #16]
 80014e0:	42bb      	cmp	r3, r7
 80014e2:	d222      	bcs.n	800152a <oqWriteTimeout+0x86>
    qsize_t done = q_write(oqp, &bp[w], n - w);
 80014e4:	eba9 0406 	sub.w	r4, r9, r6
  qsize_t s = qGetEmptyI(oqp);
 80014e8:	1afb      	subs	r3, r7, r3
  if (n > s) n = s;
 80014ea:	429c      	cmp	r4, r3
 80014ec:	bf28      	it	cs
 80014ee:	461c      	movcs	r4, r3
  if (n == 0) return 0;
 80014f0:	2c00      	cmp	r4, #0
 80014f2:	d0ed      	beq.n	80014d0 <oqWriteTimeout+0x2c>
  if (n == 1) {
 80014f4:	2c01      	cmp	r4, #1
    qsize_t done = q_write(oqp, &bp[w], n - w);
 80014f6:	eb08 0106 	add.w	r1, r8, r6
  if (n == 1) {
 80014fa:	d025      	beq.n	8001548 <oqWriteTimeout+0xa4>
  s = oqp->q_size - oqp->q_wr;
 80014fc:	f8d5 b018 	ldr.w	fp, [r5, #24]
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     n);
 8001500:	68e8      	ldr	r0, [r5, #12]
  s = oqp->q_size - oqp->q_wr;
 8001502:	eba7 0a0b 	sub.w	sl, r7, fp
  if (n < s) {
 8001506:	4554      	cmp	r4, sl
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     n);
 8001508:	4458      	add	r0, fp
  if (n < s) {
 800150a:	d3d7      	bcc.n	80014bc <oqWriteTimeout+0x18>
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     s);
 800150c:	4652      	mov	r2, sl
 800150e:	9100      	str	r1, [sp, #0]
    memcpy((void *)&oqp->q_buffer[0        ], (const void *)&bp[s], n - s);
 8001510:	ebab 0b07 	sub.w	fp, fp, r7
    memcpy((void *)&oqp->q_buffer[oqp->q_wr], (const void *)&bp[0],     s);
 8001514:	f011 f982 	bl	801281c <memcpy>
    memcpy((void *)&oqp->q_buffer[0        ], (const void *)&bp[s], n - s);
 8001518:	9900      	ldr	r1, [sp, #0]
 800151a:	68e8      	ldr	r0, [r5, #12]
 800151c:	eb0b 0704 	add.w	r7, fp, r4
 8001520:	463a      	mov	r2, r7
 8001522:	4451      	add	r1, sl
 8001524:	f011 f97a 	bl	801281c <memcpy>
    oqp->q_wr = -s;
 8001528:	e7cd      	b.n	80014c6 <oqWriteTimeout+0x22>
  return chThdEnqueueTimeoutS(tqp, time);
 800152a:	9901      	ldr	r1, [sp, #4]
 800152c:	4628      	mov	r0, r5
 800152e:	f7ff fcbb 	bl	8000ea8 <chThdEnqueueTimeoutS>
  while (waitFreeTimeout(oqp, timeout) == MSG_OK) {
 8001532:	b910      	cbnz	r0, 800153a <oqWriteTimeout+0x96>
  qsize_t s = qGetEmptyI(oqp);
 8001534:	e9d5 3704 	ldrd	r3, r7, [r5, #16]
 8001538:	e7d4      	b.n	80014e4 <oqWriteTimeout+0x40>
 800153a:	2300      	movs	r3, #0
 800153c:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return w;
}
 8001540:	4630      	mov	r0, r6
 8001542:	b003      	add	sp, #12
 8001544:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    q_PutI(oqp, *bp);
 8001548:	f818 1006 	ldrb.w	r1, [r8, r6]
 800154c:	4628      	mov	r0, r5
 800154e:	f7ff fecb 	bl	80012e8 <q_PutI>
    w += done;
 8001552:	3601      	adds	r6, #1
    return 1;
 8001554:	e7bc      	b.n	80014d0 <oqWriteTimeout+0x2c>
 8001556:	bf00      	nop

08001558 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001558:	f04f 31ff 	mov.w	r1, #4294967295
 800155c:	3008      	adds	r0, #8
 800155e:	f7ff bef9 	b.w	8001354 <iqGetTimeout>
 8001562:	bf00      	nop

08001564 <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001564:	f04f 32ff 	mov.w	r2, #4294967295
 8001568:	3028      	adds	r0, #40	@ 0x28
 800156a:	f7ff bf69 	b.w	8001440 <oqPutTimeout>
 800156e:	bf00      	nop

08001570 <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001570:	f04f 33ff 	mov.w	r3, #4294967295
 8001574:	3008      	adds	r0, #8
 8001576:	f7ff bf0b 	b.w	8001390 <iqReadTimeout>
 800157a:	bf00      	nop

0800157c <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800157c:	f04f 33ff 	mov.w	r3, #4294967295
 8001580:	3028      	adds	r0, #40	@ 0x28
 8001582:	f7ff bf8f 	b.w	80014a4 <oqWriteTimeout>
 8001586:	bf00      	nop

08001588 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8001588:	f000 bcc4 	b.w	8001f14 <sd_lld_init>

0800158c <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 800158c:	b570      	push	{r4, r5, r6, lr}
 800158e:	4604      	mov	r4, r0
 8001590:	460b      	mov	r3, r1
  sdp->vmt = &vmt;
 8001592:	480b      	ldr	r0, [pc, #44]	@ (80015c0 <sdObjectInit+0x34>)
 8001594:	6020      	str	r0, [r4, #0]
  //osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001596:	2101      	movs	r1, #1
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001598:	4615      	mov	r5, r2
  sdp->state = SD_STOP;
 800159a:	7121      	strb	r1, [r4, #4]
  qObjectInit(&sdp->iqueue, sdp->ib, sizeof(sdp->ib), inotify);
 800159c:	f104 0008 	add.w	r0, r4, #8
 80015a0:	f104 0148 	add.w	r1, r4, #72	@ 0x48
 80015a4:	2240      	movs	r2, #64	@ 0x40
 80015a6:	f7ff feaf 	bl	8001308 <qObjectInit>
  qObjectInit(&sdp->oqueue, sdp->ob, sizeof(sdp->ob), onotify);
 80015aa:	462b      	mov	r3, r5
 80015ac:	f104 0188 	add.w	r1, r4, #136	@ 0x88
 80015b0:	f104 0028 	add.w	r0, r4, #40	@ 0x28
 80015b4:	2240      	movs	r2, #64	@ 0x40
}
 80015b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  qObjectInit(&sdp->oqueue, sdp->ob, sizeof(sdp->ob), onotify);
 80015ba:	f7ff bea5 	b.w	8001308 <qObjectInit>
 80015be:	bf00      	nop
 80015c0:	08014774 	.word	0x08014774

080015c4 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80015c4:	b510      	push	{r4, lr}
 80015c6:	2320      	movs	r3, #32
 80015c8:	4604      	mov	r4, r0
 80015ca:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80015ce:	f000 fcc9 	bl	8001f64 <sd_lld_start>
  sdp->state = SD_READY;
 80015d2:	2202      	movs	r2, #2
 80015d4:	2300      	movs	r3, #0
 80015d6:	7122      	strb	r2, [r4, #4]
 80015d8:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 80015dc:	bd10      	pop	{r4, pc}
 80015de:	bf00      	nop

080015e0 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 80015e0:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 80015e2:	6b04      	ldr	r4, [r0, #48]	@ 0x30

  /* If the USB driver is not in the appropriate state then transactions must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80015e4:	f8d4 213c 	ldr.w	r2, [r4, #316]	@ 0x13c
 80015e8:	6813      	ldr	r3, [r2, #0]
 80015ea:	7819      	ldrb	r1, [r3, #0]
 80015ec:	2904      	cmp	r1, #4
static void obnotify(io_buffers_queue_t *bqp) {
 80015ee:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80015f0:	d102      	bne.n	80015f8 <obnotify+0x18>
 80015f2:	7921      	ldrb	r1, [r4, #4]
 80015f4:	2902      	cmp	r1, #2
 80015f6:	d001      	beq.n	80015fc <obnotify+0x1c>
  uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  if (buf == NULL)  return;

  /* Buffer found, starting a new transaction.*/
  usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
}
 80015f8:	b002      	add	sp, #8
 80015fa:	bd10      	pop	{r4, pc}
      usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80015fc:	7910      	ldrb	r0, [r2, #4]
 80015fe:	8919      	ldrh	r1, [r3, #8]
 8001600:	2201      	movs	r2, #1
 8001602:	fa02 f300 	lsl.w	r3, r2, r0
      (sdup->state != SDU_READY) ||
 8001606:	420b      	tst	r3, r1
 8001608:	d1f6      	bne.n	80015f8 <obnotify+0x18>
  uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800160a:	a901      	add	r1, sp, #4
 800160c:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 8001610:	f7ff fdae 	bl	8001170 <obqGetFullBufferI>
  if (buf == NULL)  return;
 8001614:	4602      	mov	r2, r0
 8001616:	2800      	cmp	r0, #0
 8001618:	d0ee      	beq.n	80015f8 <obnotify+0x18>
  usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800161a:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
 800161e:	9b01      	ldr	r3, [sp, #4]
 8001620:	7901      	ldrb	r1, [r0, #4]
 8001622:	6800      	ldr	r0, [r0, #0]
 8001624:	f000 f9ba 	bl	800199c <usbStartTransmitI>
 8001628:	e7e6      	b.n	80015f8 <obnotify+0x18>
 800162a:	bf00      	nop

0800162c <get>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, USB_READ_TIMEOUT);
 800162c:	f04f 31ff 	mov.w	r1, #4294967295
 8001630:	3008      	adds	r0, #8
 8001632:	f7ff bd3d 	b.w	80010b0 <ibqGetTimeout>
 8001636:	bf00      	nop

08001638 <put>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8001638:	f8d0 313c 	ldr.w	r3, [r0, #316]	@ 0x13c
 800163c:	681b      	ldr	r3, [r3, #0]
 800163e:	781b      	ldrb	r3, [r3, #0]
 8001640:	2b04      	cmp	r3, #4
 8001642:	d104      	bne.n	800164e <put+0x16>
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, USB_WRITE_TIMEOUT);
 8001644:	f04f 32ff 	mov.w	r2, #4294967295
 8001648:	303c      	adds	r0, #60	@ 0x3c
 800164a:	f7ff bdd1 	b.w	80011f0 <obqPutTimeout>
}
 800164e:	f06f 0001 	mvn.w	r0, #1
 8001652:	4770      	bx	lr

08001654 <read>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, USB_READ_TIMEOUT);
 8001654:	f04f 33ff 	mov.w	r3, #4294967295
 8001658:	3008      	adds	r0, #8
 800165a:	f7ff bd49 	b.w	80010f0 <ibqReadTimeout>
 800165e:	bf00      	nop

08001660 <write>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8001660:	f8d0 313c 	ldr.w	r3, [r0, #316]	@ 0x13c
 8001664:	681b      	ldr	r3, [r3, #0]
 8001666:	781b      	ldrb	r3, [r3, #0]
 8001668:	2b04      	cmp	r3, #4
 800166a:	d001      	beq.n	8001670 <write+0x10>
}
 800166c:	2000      	movs	r0, #0
 800166e:	4770      	bx	lr
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, USB_WRITE_TIMEOUT);
 8001670:	f04f 33ff 	mov.w	r3, #4294967295
 8001674:	303c      	adds	r0, #60	@ 0x3c
 8001676:	f7ff bddd 	b.w	8001234 <obqWriteTimeout>
 800167a:	bf00      	nop

0800167c <sdu_start_receive.isra.0>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) || (sdup->state != SDU_READY)) {
 800167c:	f8d0 213c 	ldr.w	r2, [r0, #316]	@ 0x13c
 8001680:	6813      	ldr	r3, [r2, #0]
 8001682:	7819      	ldrb	r1, [r3, #0]
 8001684:	2904      	cmp	r1, #4
 8001686:	d11c      	bne.n	80016c2 <sdu_start_receive.isra.0+0x46>
static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8001688:	b510      	push	{r4, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) || (sdup->state != SDU_READY)) {
 800168a:	7901      	ldrb	r1, [r0, #4]
 800168c:	2902      	cmp	r1, #2
 800168e:	4604      	mov	r4, r0
 8001690:	d000      	beq.n	8001694 <sdu_start_receive.isra.0+0x18>
}
 8001692:	bd10      	pop	{r4, pc}
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8001694:	7950      	ldrb	r0, [r2, #5]
 8001696:	8959      	ldrh	r1, [r3, #10]
 8001698:	2201      	movs	r2, #1
 800169a:	fa02 f300 	lsl.w	r3, r2, r0
 800169e:	420b      	tst	r3, r1
 80016a0:	d1f7      	bne.n	8001692 <sdu_start_receive.isra.0+0x16>
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 80016a2:	f104 0008 	add.w	r0, r4, #8
 80016a6:	f7ff fd57 	bl	8001158 <ibqGetEmptyBufferI>
  if (buf == NULL) {
 80016aa:	4602      	mov	r2, r0
 80016ac:	2800      	cmp	r0, #0
 80016ae:	d0f0      	beq.n	8001692 <sdu_start_receive.isra.0+0x16>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out, buf, SERIAL_USB_RX_BUFFERS_SIZE);
 80016b0:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
 80016b4:	2340      	movs	r3, #64	@ 0x40
 80016b6:	7941      	ldrb	r1, [r0, #5]
 80016b8:	6800      	ldr	r0, [r0, #0]
}
 80016ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out, buf, SERIAL_USB_RX_BUFFERS_SIZE);
 80016be:	f000 b957 	b.w	8001970 <usbStartReceiveI>
 80016c2:	4770      	bx	lr

080016c4 <ibnotify>:
  (void) sdu_start_receive(sdup);
 80016c4:	6b00      	ldr	r0, [r0, #48]	@ 0x30
 80016c6:	f7ff bfd9 	b.w	800167c <sdu_start_receive.isra.0>
 80016ca:	bf00      	nop

080016cc <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 80016cc:	4770      	bx	lr
 80016ce:	bf00      	nop

080016d0 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 80016d0:	b510      	push	{r4, lr}

  sdup->vmt = &vmt;
  //osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
  bqObjectInit(&sdup->ibqueue, sdup->ib,
 80016d2:	4a0e      	ldr	r2, [pc, #56]	@ (800170c <sduObjectInit+0x3c>)
  sdup->vmt = &vmt;
 80016d4:	490e      	ldr	r1, [pc, #56]	@ (8001710 <sduObjectInit+0x40>)
void sduObjectInit(SerialUSBDriver *sdup) {
 80016d6:	b082      	sub	sp, #8
  sdup->state = SDU_STOP;
 80016d8:	2301      	movs	r3, #1
void sduObjectInit(SerialUSBDriver *sdup) {
 80016da:	4604      	mov	r4, r0
  sdup->vmt = &vmt;
 80016dc:	6001      	str	r1, [r0, #0]
  sdup->state = SDU_STOP;
 80016de:	7103      	strb	r3, [r0, #4]
  bqObjectInit(&sdup->ibqueue, sdup->ib,
 80016e0:	f100 0170 	add.w	r1, r0, #112	@ 0x70
 80016e4:	e9cd 2000 	strd	r2, r0, [sp]
 80016e8:	2240      	movs	r2, #64	@ 0x40
 80016ea:	3008      	adds	r0, #8
 80016ec:	f7ff fc8a 	bl	8001004 <bqObjectInit>
               SERIAL_USB_RX_BUFFERS_SIZE, SERIAL_USB_RX_BUFFERS_NUMBER,
               ibnotify, sdup);
  bqObjectInit(&sdup->obqueue, sdup->ob,
 80016f0:	4a08      	ldr	r2, [pc, #32]	@ (8001714 <sduObjectInit+0x44>)
 80016f2:	2302      	movs	r3, #2
 80016f4:	e9cd 2400 	strd	r2, r4, [sp]
 80016f8:	f104 01b4 	add.w	r1, r4, #180	@ 0xb4
 80016fc:	2240      	movs	r2, #64	@ 0x40
 80016fe:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 8001702:	f7ff fc7f 	bl	8001004 <bqObjectInit>
               SERIAL_USB_TX_BUFFERS_SIZE, SERIAL_USB_TX_BUFFERS_NUMBER,
               obnotify, sdup);
}
 8001706:	b002      	add	sp, #8
 8001708:	bd10      	pop	{r4, pc}
 800170a:	bf00      	nop
 800170c:	080016c5 	.word	0x080016c5
 8001710:	08014794 	.word	0x08014794
 8001714:	080015e1 	.word	0x080015e1

08001718 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 8001718:	680b      	ldr	r3, [r1, #0]
 800171a:	2220      	movs	r2, #32
 800171c:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8001720:	790a      	ldrb	r2, [r1, #4]
 8001722:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8001726:	6290      	str	r0, [r2, #40]	@ 0x28
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8001728:	794a      	ldrb	r2, [r1, #5]
 800172a:	3211      	adds	r2, #17
 800172c:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 8001730:	798a      	ldrb	r2, [r1, #6]
 8001732:	b112      	cbz	r2, 800173a <sduStart+0x22>
    usbp->in_params[config->int_in - 1U]  = sdup;
 8001734:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8001738:	6298      	str	r0, [r3, #40]	@ 0x28
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 800173a:	2302      	movs	r3, #2
 800173c:	7103      	strb	r3, [r0, #4]
  sdup->config = config;
 800173e:	f8c0 113c 	str.w	r1, [r0, #316]	@ 0x13c
 8001742:	2300      	movs	r3, #0
 8001744:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8001748:	4770      	bx	lr
 800174a:	bf00      	nop

0800174c <sduDisconnectI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduDisconnectI(SerialUSBDriver *sdup) {
 800174c:	b510      	push	{r4, lr}
 800174e:	4604      	mov	r4, r0

  /* Queues reset in order to signal the driver stop to the application.*/
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
  bqResetI(&sdup->ibqueue);
 8001750:	3008      	adds	r0, #8
 8001752:	f7ff fc6f 	bl	8001034 <bqResetI>
  bqResetI(&sdup->obqueue);
 8001756:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
}
 800175a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  bqResetI(&sdup->obqueue);
 800175e:	f7ff bc69 	b.w	8001034 <bqResetI>
 8001762:	bf00      	nop

08001764 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8001764:	b510      	push	{r4, lr}
 8001766:	4604      	mov	r4, r0
  bqResetI(&sdup->ibqueue);
 8001768:	3008      	adds	r0, #8
 800176a:	f7ff fc63 	bl	8001034 <bqResetI>
  bqResetI(&sdup->obqueue);
 800176e:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 8001772:	f7ff fc5f 	bl	8001034 <bqResetI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
  (void) sdu_start_receive(sdup);
 8001776:	4620      	mov	r0, r4
}
 8001778:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  (void) sdu_start_receive(sdup);
 800177c:	f7ff bf7e 	b.w	800167c <sdu_start_receive.isra.0>

08001780 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup.bmRequestType & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8001780:	f890 3074 	ldrb.w	r3, [r0, #116]	@ 0x74
 8001784:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8001788:	2b20      	cmp	r3, #32
 800178a:	d001      	beq.n	8001790 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800178c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800178e:	4770      	bx	lr
    switch (usbp->setup.bRequest) {
 8001790:	f890 3075 	ldrb.w	r3, [r0, #117]	@ 0x75
 8001794:	2b21      	cmp	r3, #33	@ 0x21
 8001796:	d807      	bhi.n	80017a8 <sduRequestsHook+0x28>
 8001798:	2b1f      	cmp	r3, #31
 800179a:	d9f7      	bls.n	800178c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800179c:	4a05      	ldr	r2, [pc, #20]	@ (80017b4 <sduRequestsHook+0x34>)
 800179e:	2307      	movs	r3, #7
 80017a0:	e9c0 231a 	strd	r2, r3, [r0, #104]	@ 0x68
      return true;
 80017a4:	2001      	movs	r0, #1
 80017a6:	4770      	bx	lr
    switch (usbp->setup.bRequest) {
 80017a8:	2b22      	cmp	r3, #34	@ 0x22
 80017aa:	d1ef      	bne.n	800178c <sduRequestsHook+0xc>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80017ac:	2300      	movs	r3, #0
 80017ae:	e9c0 331a 	strd	r3, r3, [r0, #104]	@ 0x68
      return true;
 80017b2:	e7f7      	b.n	80017a4 <sduRequestsHook+0x24>
 80017b4:	20000300 	.word	0x20000300

080017b8 <sduSOFHookI>:
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80017b8:	f8d0 213c 	ldr.w	r2, [r0, #316]	@ 0x13c
 80017bc:	6813      	ldr	r3, [r2, #0]
 80017be:	7819      	ldrb	r1, [r3, #0]
 80017c0:	2904      	cmp	r1, #4
 80017c2:	d107      	bne.n	80017d4 <sduSOFHookI+0x1c>
void sduSOFHookI(SerialUSBDriver *sdup) {
 80017c4:	b530      	push	{r4, r5, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80017c6:	7901      	ldrb	r1, [r0, #4]
 80017c8:	2902      	cmp	r1, #2
void sduSOFHookI(SerialUSBDriver *sdup) {
 80017ca:	b083      	sub	sp, #12
 80017cc:	4604      	mov	r4, r0
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80017ce:	d002      	beq.n	80017d6 <sduSOFHookI+0x1e>

    osalDbgAssert(buf != NULL, "queue is empty");

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  }
}
 80017d0:	b003      	add	sp, #12
 80017d2:	bd30      	pop	{r4, r5, pc}
 80017d4:	4770      	bx	lr
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80017d6:	7910      	ldrb	r0, [r2, #4]
 80017d8:	8919      	ldrh	r1, [r3, #8]
 80017da:	2201      	movs	r2, #1
 80017dc:	fa02 f300 	lsl.w	r3, r2, r0
 80017e0:	420b      	tst	r3, r1
 80017e2:	d1f5      	bne.n	80017d0 <sduSOFHookI+0x18>
  if (obqTryFlushI(&sdup->obqueue)) {
 80017e4:	f104 053c 	add.w	r5, r4, #60	@ 0x3c
 80017e8:	4628      	mov	r0, r5
 80017ea:	f7ff fd57 	bl	800129c <obqTryFlushI>
 80017ee:	2800      	cmp	r0, #0
 80017f0:	d0ee      	beq.n	80017d0 <sduSOFHookI+0x18>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80017f2:	a901      	add	r1, sp, #4
 80017f4:	4628      	mov	r0, r5
 80017f6:	f7ff fcbb 	bl	8001170 <obqGetFullBufferI>
 80017fa:	4602      	mov	r2, r0
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80017fc:	f8d4 013c 	ldr.w	r0, [r4, #316]	@ 0x13c
 8001800:	9b01      	ldr	r3, [sp, #4]
 8001802:	7901      	ldrb	r1, [r0, #4]
 8001804:	6800      	ldr	r0, [r0, #0]
 8001806:	f000 f8c9 	bl	800199c <usbStartTransmitI>
 800180a:	e7e1      	b.n	80017d0 <sduSOFHookI+0x18>

0800180c <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800180c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800180e:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001812:	b083      	sub	sp, #12
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001814:	6a9e      	ldr	r6, [r3, #40]	@ 0x28

  if (sdup == NULL) {
 8001816:	b1ce      	cbz	r6, 800184c <sduDataTransmitted+0x40>
 8001818:	4604      	mov	r4, r0
 800181a:	460d      	mov	r5, r1
 800181c:	2320      	movs	r3, #32
 800181e:	f383 8811 	msr	BASEPRI, r3

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8001822:	eb00 0781 	add.w	r7, r0, r1, lsl #2
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8001826:	363c      	adds	r6, #60	@ 0x3c
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8001828:	68fb      	ldr	r3, [r7, #12]
 800182a:	695b      	ldr	r3, [r3, #20]
 800182c:	681b      	ldr	r3, [r3, #0]
 800182e:	b9db      	cbnz	r3, 8001868 <sduDataTransmitted+0x5c>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001830:	a901      	add	r1, sp, #4
 8001832:	4630      	mov	r0, r6
 8001834:	f7ff fc9c 	bl	8001170 <obqGetFullBufferI>

  if (buf != NULL) {
 8001838:	4602      	mov	r2, r0
 800183a:	b148      	cbz	r0, 8001850 <sduDataTransmitted+0x44>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800183c:	9b01      	ldr	r3, [sp, #4]
 800183e:	4629      	mov	r1, r5
 8001840:	4620      	mov	r0, r4
 8001842:	f000 f8ab 	bl	800199c <usbStartTransmitI>
 8001846:	2300      	movs	r3, #0
 8001848:	f383 8811 	msr	BASEPRI, r3
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 800184c:	b003      	add	sp, #12
 800184e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (usbp->epc[ep]->in_state->txsize == usbp->epc[ep]->in_maxsize) {
 8001850:	68fb      	ldr	r3, [r7, #12]
 8001852:	6959      	ldr	r1, [r3, #20]
 8001854:	8a1b      	ldrh	r3, [r3, #16]
 8001856:	6809      	ldr	r1, [r1, #0]
 8001858:	4299      	cmp	r1, r3
 800185a:	d1f4      	bne.n	8001846 <sduDataTransmitted+0x3a>
    usbStartTransmitI(usbp, ep, NULL, 0);
 800185c:	4603      	mov	r3, r0
 800185e:	4629      	mov	r1, r5
 8001860:	4620      	mov	r0, r4
 8001862:	f000 f89b 	bl	800199c <usbStartTransmitI>
 8001866:	e7ee      	b.n	8001846 <sduDataTransmitted+0x3a>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 8001868:	4630      	mov	r0, r6
 800186a:	f7ff fc8b 	bl	8001184 <obqReleaseEmptyBufferI>
 800186e:	e7df      	b.n	8001830 <sduDataTransmitted+0x24>

08001870 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t size;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001870:	3111      	adds	r1, #17
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 8001872:	b510      	push	{r4, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 8001874:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]

  if (sdup == NULL) {
 8001878:	b194      	cbz	r4, 80018a0 <sduDataReceived+0x30>
 800187a:	2320      	movs	r3, #32
 800187c:	f383 8811 	msr	BASEPRI, r3
    return;
  }

  osalSysLockFromISR();
  /* Checking for zero-size transactions.*/
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8001880:	f8d4 213c 	ldr.w	r2, [r4, #316]	@ 0x13c
 8001884:	6813      	ldr	r3, [r2, #0]
 8001886:	7952      	ldrb	r2, [r2, #5]
 8001888:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800188c:	68db      	ldr	r3, [r3, #12]
 800188e:	699b      	ldr	r3, [r3, #24]
 8001890:	6859      	ldr	r1, [r3, #4]
                                       sdup->config->bulk_out);
  if (size > (size_t)0) {
 8001892:	b931      	cbnz	r1, 80018a2 <sduDataReceived+0x32>
  }

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 8001894:	4620      	mov	r0, r4
 8001896:	f7ff fef1 	bl	800167c <sdu_start_receive.isra.0>
 800189a:	2300      	movs	r3, #0
 800189c:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlockFromISR();
}
 80018a0:	bd10      	pop	{r4, pc}
    ibqPostFullBufferI(&sdup->ibqueue, size);
 80018a2:	f104 0008 	add.w	r0, r4, #8
 80018a6:	f7ff fbd1 	bl	800104c <ibqPostFullBufferI>
 80018aa:	e7f3      	b.n	8001894 <sduDataReceived+0x24>

080018ac <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 80018ac:	4770      	bx	lr
 80018ae:	bf00      	nop

080018b0 <_usb_ep0_error>:

/*  Error response, the state machine goes into an error state, the low
 *  level layer will have to reset it to USB_EP0_WAITING_SETUP after
 *  receiving a SETUP packet.
 */
static void _usb_ep0_error(USBDriver *usbp) {
 80018b0:	b510      	push	{r4, lr}
  usb_lld_stall_in(usbp, 0);
 80018b2:	2100      	movs	r1, #0
static void _usb_ep0_error(USBDriver *usbp) {
 80018b4:	4604      	mov	r4, r0
  usb_lld_stall_in(usbp, 0);
 80018b6:	f000 fdc3 	bl	8002440 <usb_lld_stall_in>
  usb_lld_stall_out(usbp, 0);
 80018ba:	2100      	movs	r1, #0
 80018bc:	4620      	mov	r0, r4
 80018be:	f000 fdad 	bl	800241c <usb_lld_stall_out>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80018c2:	6863      	ldr	r3, [r4, #4]
 80018c4:	681b      	ldr	r3, [r3, #0]
 80018c6:	b113      	cbz	r3, 80018ce <_usb_ep0_error+0x1e>
 80018c8:	2105      	movs	r1, #5
 80018ca:	4620      	mov	r0, r4
 80018cc:	4798      	blx	r3
  usbp->ep0state = USB_EP0_ERROR;
 80018ce:	2306      	movs	r3, #6
 80018d0:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 80018d4:	bd10      	pop	{r4, pc}
 80018d6:	bf00      	nop

080018d8 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 80018d8:	b510      	push	{r4, lr}
  usbp->address = usbp->setup.wValue;
 80018da:	f8b0 3076 	ldrh.w	r3, [r0, #118]	@ 0x76
 80018de:	f880 307e 	strb.w	r3, [r0, #126]	@ 0x7e
static void set_address(USBDriver *usbp) {
 80018e2:	4604      	mov	r4, r0
  usb_lld_set_address(usbp);
 80018e4:	f000 fb9c 	bl	8002020 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80018e8:	6863      	ldr	r3, [r4, #4]
 80018ea:	681b      	ldr	r3, [r3, #0]
 80018ec:	b113      	cbz	r3, 80018f4 <set_address+0x1c>
 80018ee:	2101      	movs	r1, #1
 80018f0:	4620      	mov	r0, r4
 80018f2:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 80018f4:	2303      	movs	r3, #3
 80018f6:	7023      	strb	r3, [r4, #0]
}
 80018f8:	bd10      	pop	{r4, pc}
 80018fa:	bf00      	nop

080018fc <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 80018fc:	f000 bb64 	b.w	8001fc8 <usb_lld_init>

08001900 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8001900:	b538      	push	{r3, r4, r5, lr}
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8001902:	2500      	movs	r5, #0
void usbObjectInit(USBDriver *usbp) {
 8001904:	4604      	mov	r4, r0
  usbp->state        = USB_STOP;
 8001906:	2301      	movs	r3, #1
 8001908:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
 800190a:	6045      	str	r5, [r0, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800190c:	2238      	movs	r2, #56	@ 0x38
 800190e:	4629      	mov	r1, r5
 8001910:	302c      	adds	r0, #44	@ 0x2c
 8001912:	f010 ff67 	bl	80127e4 <memset>
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8001916:	60a5      	str	r5, [r4, #8]
  usbp->receiving    = 0;
}
 8001918:	bd38      	pop	{r3, r4, r5, pc}
 800191a:	bf00      	nop

0800191c <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 800191c:	b510      	push	{r4, lr}
 800191e:	460b      	mov	r3, r1
 8001920:	4604      	mov	r4, r0
 8001922:	2220      	movs	r2, #32
 8001924:	f382 8811 	msr	BASEPRI, r2
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8001928:	2100      	movs	r1, #0
  usbp->config = config;
 800192a:	6043      	str	r3, [r0, #4]
    usbp->epc[i] = NULL;
 800192c:	300c      	adds	r0, #12
 800192e:	f010 ff59 	bl	80127e4 <memset>
  }
  usb_lld_start(usbp);
 8001932:	4620      	mov	r0, r4
 8001934:	f000 fb4e 	bl	8001fd4 <usb_lld_start>
  usbp->state = USB_READY;
 8001938:	2202      	movs	r2, #2
 800193a:	2300      	movs	r3, #0
 800193c:	7022      	strb	r2, [r4, #0]
 800193e:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8001942:	bd10      	pop	{r4, pc}

08001944 <usbInitEndpointI>:

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8001944:	6953      	ldr	r3, [r2, #20]
  usbp->epc[ep] = epcp;
 8001946:	eb00 0c81 	add.w	ip, r0, r1, lsl #2
 800194a:	f8cc 200c 	str.w	r2, [ip, #12]
  if (epcp->in_state != NULL) {
 800194e:	b13b      	cbz	r3, 8001960 <usbInitEndpointI+0x1c>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8001950:	f04f 0c00 	mov.w	ip, #0
 8001954:	f8c3 c000 	str.w	ip, [r3]
 8001958:	f8c3 c004 	str.w	ip, [r3, #4]
 800195c:	f8c3 c008 	str.w	ip, [r3, #8]
  }
  if (epcp->out_state != NULL) {
 8001960:	6993      	ldr	r3, [r2, #24]
 8001962:	b11b      	cbz	r3, 800196c <usbInitEndpointI+0x28>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8001964:	2200      	movs	r2, #0
 8001966:	601a      	str	r2, [r3, #0]
 8001968:	605a      	str	r2, [r3, #4]
 800196a:	609a      	str	r2, [r3, #8]
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800196c:	f000 bb62 	b.w	8002034 <usb_lld_init_endpoint>

08001970 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8001970:	b570      	push	{r4, r5, r6, lr}
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8001972:	eb00 0581 	add.w	r5, r0, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001976:	8946      	ldrh	r6, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 8001978:	68ed      	ldr	r5, [r5, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800197a:	f04f 0e01 	mov.w	lr, #1
  osp = usbp->epc[ep]->out_state;
 800197e:	69ad      	ldr	r5, [r5, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001980:	fa0e fe01 	lsl.w	lr, lr, r1
 8001984:	ea4e 0e06 	orr.w	lr, lr, r6
 8001988:	f8a0 e00a 	strh.w	lr, [r0, #10]
  /*lint -restore*/
  osp->rxbuf  = buf;
 800198c:	60aa      	str	r2, [r5, #8]
  osp->rxsize = n;
  osp->rxcnt  = 0;
 800198e:	2200      	movs	r2, #0
 8001990:	e9c5 3200 	strd	r3, r2, [r5]
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
}
 8001994:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usb_lld_start_out(usbp, ep);
 8001998:	f000 bc00 	b.w	800219c <usb_lld_start_out>

0800199c <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 800199c:	b570      	push	{r4, r5, r6, lr}
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800199e:	eb00 0581 	add.w	r5, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019a2:	8906      	ldrh	r6, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 80019a4:	68ed      	ldr	r5, [r5, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019a6:	f04f 0e01 	mov.w	lr, #1
  isp = usbp->epc[ep]->in_state;
 80019aa:	696d      	ldr	r5, [r5, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80019ac:	fa0e fe01 	lsl.w	lr, lr, r1
 80019b0:	ea4e 0e06 	orr.w	lr, lr, r6
 80019b4:	f8a0 e008 	strh.w	lr, [r0, #8]
  /*lint -restore*/
  isp->txbuf  = buf;
 80019b8:	60aa      	str	r2, [r5, #8]
  isp->txsize = n;
  isp->txcnt  = 0;
 80019ba:	2200      	movs	r2, #0
 80019bc:	e9c5 3200 	strd	r3, r2, [r5]
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
}
 80019c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  usb_lld_start_in(usbp, ep);
 80019c4:	f000 bbfc 	b.w	80021c0 <usb_lld_start_in>

080019c8 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 80019c8:	b570      	push	{r4, r5, r6, lr}
  unsigned i;
  /* State transition.*/
  usbp->state         = USB_READY;
 80019ca:	2302      	movs	r3, #2
void _usb_reset(USBDriver *usbp) {
 80019cc:	4604      	mov	r4, r0
  /* Resetting internal state.*/
  usbp->status        = 0;
 80019ce:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 80019d0:	7003      	strb	r3, [r0, #0]
  usbp->status        = 0;
 80019d2:	67c5      	str	r5, [r0, #124]	@ 0x7c
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
 80019d4:	6085      	str	r5, [r0, #8]
  /* Invalidates all endpoints into the USBDriver structure.*/
#if USB_USE_WAIT == TRUE
  _usb_reset_all_threads(usbp);
#endif
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80019d6:	2220      	movs	r2, #32
 80019d8:	4629      	mov	r1, r5
 80019da:	300c      	adds	r0, #12
 80019dc:	f010 ff02 	bl	80127e4 <memset>
  }
  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80019e0:	f884 5064 	strb.w	r5, [r4, #100]	@ 0x64
  /* Low level reset.*/
  usb_lld_reset(usbp);
 80019e4:	4620      	mov	r0, r4
 80019e6:	f000 fb7b 	bl	80020e0 <usb_lld_reset>
  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80019ea:	6863      	ldr	r3, [r4, #4]
 80019ec:	681b      	ldr	r3, [r3, #0]
 80019ee:	b123      	cbz	r3, 80019fa <_usb_reset+0x32>
 80019f0:	4629      	mov	r1, r5
 80019f2:	4620      	mov	r0, r4
}
 80019f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80019f8:	4718      	bx	r3
}
 80019fa:	bd70      	pop	{r4, r5, r6, pc}

080019fc <_usb_suspend>:
 */
void _usb_suspend(USBDriver *usbp) {
  /* State transition.*/
  usbp->state = USB_SUSPENDED;
  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80019fc:	6842      	ldr	r2, [r0, #4]
  usbp->state = USB_SUSPENDED;
 80019fe:	2105      	movs	r1, #5
 8001a00:	7001      	strb	r1, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8001a02:	6813      	ldr	r3, [r2, #0]
 8001a04:	b10b      	cbz	r3, 8001a0a <_usb_suspend+0xe>
 8001a06:	2103      	movs	r1, #3
 8001a08:	4718      	bx	r3
  /* Signaling the event to threads waiting on endpoints.*/
#if USB_USE_WAIT == TRUE
  _usb_reset_all_threads(usbp);
#endif
}
 8001a0a:	4770      	bx	lr

08001a0c <_usb_wakeup>:
 */
void _usb_wakeup(USBDriver *usbp) {
  /* State transition.*/
  usbp->state = USB_ACTIVE;
  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8001a0c:	6842      	ldr	r2, [r0, #4]
  usbp->state = USB_ACTIVE;
 8001a0e:	2104      	movs	r1, #4
 8001a10:	7001      	strb	r1, [r0, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8001a12:	6813      	ldr	r3, [r2, #0]
 8001a14:	b103      	cbz	r3, 8001a18 <_usb_wakeup+0xc>
 8001a16:	4718      	bx	r3
}
 8001a18:	4770      	bx	lr
 8001a1a:	bf00      	nop

08001a1c <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8001a1c:	b538      	push	{r3, r4, r5, lr}
 8001a1e:	4604      	mov	r4, r0
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001a20:	2500      	movs	r5, #0
 8001a22:	f880 5064 	strb.w	r5, [r0, #100]	@ 0x64
  /* Read received setup packet from out endpoint */
  usbReadSetup(usbp, ep, (uint8_t *)&usbp->setup);
 8001a26:	f100 0274 	add.w	r2, r0, #116	@ 0x74
 8001a2a:	f000 fb93 	bl	8002154 <usb_lld_read_setup>
  /* Reset callback for usbSetupTransfer macro */
  usbp->ep0endcb = NULL;
  /* First verify if the application has an handler installed for this request.*/
  if ((usbp->config->requests_hook_cb == NULL) || !(usbp->config->requests_hook_cb(usbp))) {
 8001a2e:	6863      	ldr	r3, [r4, #4]
  usbp->ep0endcb = NULL;
 8001a30:	6725      	str	r5, [r4, #112]	@ 0x70
  if ((usbp->config->requests_hook_cb == NULL) || !(usbp->config->requests_hook_cb(usbp))) {
 8001a32:	689b      	ldr	r3, [r3, #8]
 8001a34:	b1eb      	cbz	r3, 8001a72 <_usb_ep0setup+0x56>
 8001a36:	4620      	mov	r0, r4
 8001a38:	4798      	blx	r3
 8001a3a:	b1d0      	cbz	r0, 8001a72 <_usb_ep0setup+0x56>
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > usbp->setup.wLength)
 8001a3c:	6ee2      	ldr	r2, [r4, #108]	@ 0x6c
 8001a3e:	f8b4 307a 	ldrh.w	r3, [r4, #122]	@ 0x7a
 8001a42:	4293      	cmp	r3, r2
    usbp->ep0n = usbp->setup.wLength;
 8001a44:	bf38      	it	cc
 8001a46:	66e3      	strcc	r3, [r4, #108]	@ 0x6c
 8001a48:	2320      	movs	r3, #32
 8001a4a:	f383 8811 	msr	BASEPRI, r3

  /* Process prepared ep0 ask / answer, disable ISR event for this time*/
  osalSysLockFromISR();
  if ((usbp->setup.bmRequestType & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001a4e:	f994 2074 	ldrsb.w	r2, [r4, #116]	@ 0x74
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8001a52:	6ee3      	ldr	r3, [r4, #108]	@ 0x6c
  if ((usbp->setup.bmRequestType & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001a54:	2a00      	cmp	r2, #0
 8001a56:	db23      	blt.n	8001aa0 <_usb_ep0setup+0x84>
      usb_lld_end_setup(usbp, ep);
#endif
      usbp->ep0state = USB_EP0_WAITING_STS;
    }
  } else { /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8001a58:	b37b      	cbz	r3, 8001aba <_usb_ep0setup+0x9e>
      /* Starts the receive phase.*/
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8001a5a:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
 8001a5c:	2100      	movs	r1, #0
 8001a5e:	4620      	mov	r0, r4
 8001a60:	f7ff ff86 	bl	8001970 <usbStartReceiveI>
      usbp->ep0state = USB_EP0_RX;
 8001a64:	2304      	movs	r3, #4
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001a66:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001a6a:	2300      	movs	r3, #0
 8001a6c:	f383 8811 	msr	BASEPRI, r3
#endif
      usbp->ep0state = USB_EP0_SENDING_STS;
    }
  }
  osalSysUnlockFromISR();
}
 8001a70:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t rtype = usbp->setup.bmRequestType;
 8001a72:	f894 3074 	ldrb.w	r3, [r4, #116]	@ 0x74
  if ((rtype & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_STD) {
 8001a76:	f013 0f60 	tst.w	r3, #96	@ 0x60
 8001a7a:	d12b      	bne.n	8001ad4 <_usb_ep0setup+0xb8>
    uint16_t request = usbp->setup.bRequest;
 8001a7c:	f003 031f 	and.w	r3, r3, #31
    switch (rtype & USB_RTYPE_RECIPIENT_MASK) {
 8001a80:	2b01      	cmp	r3, #1
    uint16_t request = usbp->setup.bRequest;
 8001a82:	f894 2075 	ldrb.w	r2, [r4, #117]	@ 0x75
    switch (rtype & USB_RTYPE_RECIPIENT_MASK) {
 8001a86:	d024      	beq.n	8001ad2 <_usb_ep0setup+0xb6>
 8001a88:	2b02      	cmp	r3, #2
 8001a8a:	d034      	beq.n	8001af6 <_usb_ep0setup+0xda>
 8001a8c:	bb13      	cbnz	r3, 8001ad4 <_usb_ep0setup+0xb8>
  switch (request) {
 8001a8e:	2a09      	cmp	r2, #9
 8001a90:	d820      	bhi.n	8001ad4 <_usb_ep0setup+0xb8>
 8001a92:	e8df f002 	tbb	[pc, r2]
 8001a96:	6d8a      	.short	0x6d8a
 8001a98:	b91f6d1f 	.word	0xb91f6d1f
 8001a9c:	90a11fa7 	.word	0x90a11fa7
    if (usbp->ep0n != 0U) {
 8001aa0:	b1eb      	cbz	r3, 8001ade <_usb_ep0setup+0xc2>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8001aa2:	6ea2      	ldr	r2, [r4, #104]	@ 0x68
 8001aa4:	2100      	movs	r1, #0
 8001aa6:	4620      	mov	r0, r4
 8001aa8:	f7ff ff78 	bl	800199c <usbStartTransmitI>
      usbp->ep0state = USB_EP0_TX;
 8001aac:	2301      	movs	r3, #1
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001aae:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001ab2:	2300      	movs	r3, #0
 8001ab4:	f383 8811 	msr	BASEPRI, r3
}
 8001ab8:	bd38      	pop	{r3, r4, r5, pc}
      usbStartTransmitI(usbp, 0, NULL, 0);
 8001aba:	461a      	mov	r2, r3
 8001abc:	4619      	mov	r1, r3
 8001abe:	4620      	mov	r0, r4
 8001ac0:	f7ff ff6c 	bl	800199c <usbStartTransmitI>
 8001ac4:	2305      	movs	r3, #5
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001ac6:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001aca:	2300      	movs	r3, #0
 8001acc:	f383 8811 	msr	BASEPRI, r3
}
 8001ad0:	bd38      	pop	{r3, r4, r5, pc}
  switch (request) {
 8001ad2:	b3aa      	cbz	r2, 8001b40 <_usb_ep0setup+0x124>
      _usb_ep0_error(usbp);
 8001ad4:	4620      	mov	r0, r4
}
 8001ad6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      _usb_ep0_error(usbp);
 8001ada:	f7ff bee9 	b.w	80018b0 <_usb_ep0_error>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8001ade:	461a      	mov	r2, r3
 8001ae0:	4619      	mov	r1, r3
 8001ae2:	4620      	mov	r0, r4
 8001ae4:	f7ff ff44 	bl	8001970 <usbStartReceiveI>
 8001ae8:	2303      	movs	r3, #3
      usbp->ep0state = USB_EP0_WAITING_STS;
 8001aea:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
 8001aee:	2300      	movs	r3, #0
 8001af0:	f383 8811 	msr	BASEPRI, r3
}
 8001af4:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t ep  = usbp->setup.wIndex & 0x0F;
 8001af6:	f8b4 3078 	ldrh.w	r3, [r4, #120]	@ 0x78
 8001afa:	f003 010f 	and.w	r1, r3, #15
  bool in_mode = usbp->setup.wIndex & 0x80;
 8001afe:	f003 0380 	and.w	r3, r3, #128	@ 0x80
  switch (request) {
 8001b02:	2a0c      	cmp	r2, #12
 8001b04:	d8e6      	bhi.n	8001ad4 <_usb_ep0setup+0xb8>
 8001b06:	a001      	add	r0, pc, #4	@ (adr r0, 8001b0c <_usb_ep0setup+0xf0>)
 8001b08:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8001b0c:	08001b8f 	.word	0x08001b8f
 8001b10:	08001b4d 	.word	0x08001b4d
 8001b14:	08001ad5 	.word	0x08001ad5
 8001b18:	08001b4d 	.word	0x08001b4d
 8001b1c:	08001ad5 	.word	0x08001ad5
 8001b20:	08001ad5 	.word	0x08001ad5
 8001b24:	08001ad5 	.word	0x08001ad5
 8001b28:	08001ad5 	.word	0x08001ad5
 8001b2c:	08001ad5 	.word	0x08001ad5
 8001b30:	08001ad5 	.word	0x08001ad5
 8001b34:	08001ad5 	.word	0x08001ad5
 8001b38:	08001ad5 	.word	0x08001ad5
 8001b3c:	08001b41 	.word	0x08001b41
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8001b40:	4a3d      	ldr	r2, [pc, #244]	@ (8001c38 <_usb_ep0setup+0x21c>)
 8001b42:	2302      	movs	r3, #2
 8001b44:	e9c4 231a 	strd	r2, r3, [r4, #104]	@ 0x68
      usbp->state = usbp->configuration != 0 ? USB_ACTIVE : USB_SELECTED;
 8001b48:	2202      	movs	r2, #2
 8001b4a:	e778      	b.n	8001a3e <_usb_ep0setup+0x22>
    if (usbp->setup.wValue != USB_FEATURE_ENDPOINT_HALT)
 8001b4c:	f8b4 0076 	ldrh.w	r0, [r4, #118]	@ 0x76
 8001b50:	2800      	cmp	r0, #0
 8001b52:	d1bf      	bne.n	8001ad4 <_usb_ep0setup+0xb8>
    if (ep == 0)
 8001b54:	2900      	cmp	r1, #0
 8001b56:	d0bd      	beq.n	8001ad4 <_usb_ep0setup+0xb8>
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001b58:	2a01      	cmp	r2, #1
    switch (in_mode ? usb_lld_get_status_in(usbp, ep) : usb_lld_get_status_out(usbp, ep))
 8001b5a:	b2c9      	uxtb	r1, r1
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001b5c:	4620      	mov	r0, r4
 8001b5e:	d061      	beq.n	8001c24 <_usb_ep0setup+0x208>
    else                                  {if (in_mode) usb_lld_stall_in(usbp, ep); else usb_lld_stall_out(usbp, ep);}
 8001b60:	2b00      	cmp	r3, #0
 8001b62:	d063      	beq.n	8001c2c <_usb_ep0setup+0x210>
 8001b64:	f000 fc6c 	bl	8002440 <usb_lld_stall_in>
        usbSetupTransfer(usbp, NULL, 0, NULL);
 8001b68:	2300      	movs	r3, #0
 8001b6a:	e9c4 331a 	strd	r3, r3, [r4, #104]	@ 0x68
        return true;
 8001b6e:	e76b      	b.n	8001a48 <_usb_ep0setup+0x2c>
      if (usbp->setup.wValue == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8001b70:	f8b4 3076 	ldrh.w	r3, [r4, #118]	@ 0x76
 8001b74:	2b01      	cmp	r3, #1
 8001b76:	d1ad      	bne.n	8001ad4 <_usb_ep0setup+0xb8>
        usbp->status&=~2U;
 8001b78:	f8b4 307c 	ldrh.w	r3, [r4, #124]	@ 0x7c
        if (request == USB_REQ_SET_FEATURE)
 8001b7c:	2a03      	cmp	r2, #3
        usbp->status&=~2U;
 8001b7e:	bf14      	ite	ne
 8001b80:	f023 0302 	bicne.w	r3, r3, #2
          usbp->status|= 2U;
 8001b84:	f043 0302 	orreq.w	r3, r3, #2
 8001b88:	f8a4 307c 	strh.w	r3, [r4, #124]	@ 0x7c
 8001b8c:	e7ec      	b.n	8001b68 <_usb_ep0setup+0x14c>
    switch (in_mode ? usb_lld_get_status_in(usbp, ep) : usb_lld_get_status_out(usbp, ep))
 8001b8e:	b2c9      	uxtb	r1, r1
 8001b90:	4620      	mov	r0, r4
 8001b92:	2b00      	cmp	r3, #0
 8001b94:	d03e      	beq.n	8001c14 <_usb_ep0setup+0x1f8>
 8001b96:	f000 facf 	bl	8002138 <usb_lld_get_status_in>
 8001b9a:	2801      	cmp	r0, #1
 8001b9c:	d03d      	beq.n	8001c1a <_usb_ep0setup+0x1fe>
 8001b9e:	2802      	cmp	r0, #2
 8001ba0:	d198      	bne.n	8001ad4 <_usb_ep0setup+0xb8>
      case EP_STATUS_ACTIVE: usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8001ba2:	4b26      	ldr	r3, [pc, #152]	@ (8001c3c <_usb_ep0setup+0x220>)
 8001ba4:	e9c4 301a 	strd	r3, r0, [r4, #104]	@ 0x68
        return true;
 8001ba8:	e7ce      	b.n	8001b48 <_usb_ep0setup+0x12c>
      usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8001baa:	f104 027c 	add.w	r2, r4, #124	@ 0x7c
 8001bae:	2302      	movs	r3, #2
 8001bb0:	e9c4 231a 	strd	r2, r3, [r4, #104]	@ 0x68
      return true;
 8001bb4:	e7c8      	b.n	8001b48 <_usb_ep0setup+0x12c>
      usbp->configuration = usbp->setup.wValue;
 8001bb6:	f894 3076 	ldrb.w	r3, [r4, #118]	@ 0x76
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001bba:	6862      	ldr	r2, [r4, #4]
      usbp->configuration = usbp->setup.wValue;
 8001bbc:	f884 307f 	strb.w	r3, [r4, #127]	@ 0x7f
      usbp->state = usbp->configuration != 0 ? USB_ACTIVE : USB_SELECTED;
 8001bc0:	2b00      	cmp	r3, #0
 8001bc2:	bf0c      	ite	eq
 8001bc4:	2103      	moveq	r1, #3
 8001bc6:	2104      	movne	r1, #4
 8001bc8:	7021      	strb	r1, [r4, #0]
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001bca:	6813      	ldr	r3, [r2, #0]
 8001bcc:	2b00      	cmp	r3, #0
 8001bce:	d0cb      	beq.n	8001b68 <_usb_ep0setup+0x14c>
 8001bd0:	2102      	movs	r1, #2
 8001bd2:	4620      	mov	r0, r4
 8001bd4:	4798      	blx	r3
 8001bd6:	e7c7      	b.n	8001b68 <_usb_ep0setup+0x14c>
      usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8001bd8:	2201      	movs	r2, #1
 8001bda:	f104 037f 	add.w	r3, r4, #127	@ 0x7f
 8001bde:	e9c4 321a 	strd	r3, r2, [r4, #104]	@ 0x68
      return true;
 8001be2:	e72c      	b.n	8001a3e <_usb_ep0setup+0x22>
                                        (usbp->setup.wValue>>8)&0xFF,
 8001be4:	f8b4 1076 	ldrh.w	r1, [r4, #118]	@ 0x76
        const USBDescriptor *dp = usbp->config->get_descriptor_cb(usbp,
 8001be8:	6862      	ldr	r2, [r4, #4]
 8001bea:	f8b4 3078 	ldrh.w	r3, [r4, #120]	@ 0x78
 8001bee:	6855      	ldr	r5, [r2, #4]
 8001bf0:	4620      	mov	r0, r4
 8001bf2:	b2ca      	uxtb	r2, r1
 8001bf4:	0a09      	lsrs	r1, r1, #8
 8001bf6:	47a8      	blx	r5
        if (dp == NULL) return false;
 8001bf8:	2800      	cmp	r0, #0
 8001bfa:	f43f af6b 	beq.w	8001ad4 <_usb_ep0setup+0xb8>
        usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8001bfe:	e9d0 2300 	ldrd	r2, r3, [r0]
 8001c02:	e9c4 321a 	strd	r3, r2, [r4, #104]	@ 0x68
        return true;
 8001c06:	e71a      	b.n	8001a3e <_usb_ep0setup+0x22>
      usbSetupTransfer(usbp, NULL, 0, set_address);
 8001c08:	4a0d      	ldr	r2, [pc, #52]	@ (8001c40 <_usb_ep0setup+0x224>)
 8001c0a:	6722      	str	r2, [r4, #112]	@ 0x70
 8001c0c:	2300      	movs	r3, #0
 8001c0e:	e9c4 331a 	strd	r3, r3, [r4, #104]	@ 0x68
      return true;
 8001c12:	e719      	b.n	8001a48 <_usb_ep0setup+0x2c>
    switch (in_mode ? usb_lld_get_status_in(usbp, ep) : usb_lld_get_status_out(usbp, ep))
 8001c14:	f000 fa82 	bl	800211c <usb_lld_get_status_out>
 8001c18:	e7bf      	b.n	8001b9a <_usb_ep0setup+0x17e>
      case EP_STATUS_STALLED:usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8001c1a:	4a0a      	ldr	r2, [pc, #40]	@ (8001c44 <_usb_ep0setup+0x228>)
 8001c1c:	2302      	movs	r3, #2
 8001c1e:	e9c4 231a 	strd	r2, r3, [r4, #104]	@ 0x68
        return true;
 8001c22:	e791      	b.n	8001b48 <_usb_ep0setup+0x12c>
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001c24:	b12b      	cbz	r3, 8001c32 <_usb_ep0setup+0x216>
 8001c26:	f000 fc35 	bl	8002494 <usb_lld_clear_in>
 8001c2a:	e79d      	b.n	8001b68 <_usb_ep0setup+0x14c>
    else                                  {if (in_mode) usb_lld_stall_in(usbp, ep); else usb_lld_stall_out(usbp, ep);}
 8001c2c:	f000 fbf6 	bl	800241c <usb_lld_stall_out>
 8001c30:	e79a      	b.n	8001b68 <_usb_ep0setup+0x14c>
    if (request == USB_REQ_CLEAR_FEATURE) {if (in_mode) usb_lld_clear_in(usbp, ep); else usb_lld_clear_out(usbp, ep);}
 8001c32:	f000 fc17 	bl	8002464 <usb_lld_clear_out>
 8001c36:	e797      	b.n	8001b68 <_usb_ep0setup+0x14c>
 8001c38:	080147bc 	.word	0x080147bc
 8001c3c:	080147b8 	.word	0x080147b8
 8001c40:	080018d9 	.word	0x080018d9
 8001c44:	080147b4 	.word	0x080147b4

08001c48 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001c48:	b538      	push	{r3, r4, r5, lr}
  (void)ep;
  switch (usbp->ep0state) {
 8001c4a:	f890 3064 	ldrb.w	r3, [r0, #100]	@ 0x64
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001c4e:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001c50:	2b06      	cmp	r3, #6
 8001c52:	d819      	bhi.n	8001c88 <_usb_ep0in+0x40>
 8001c54:	e8df f003 	tbb	[pc, r3]
 8001c58:	19090419 	.word	0x19090419
 8001c5c:	1d19      	.short	0x1d19
 8001c5e:	19          	.byte	0x19
 8001c5f:	00          	.byte	0x00
  case USB_EP0_TX:
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < usbp->setup.wLength) &&
 8001c60:	6ec5      	ldr	r5, [r0, #108]	@ 0x6c
 8001c62:	f8b0 207a 	ldrh.w	r2, [r0, #122]	@ 0x7a
 8001c66:	4295      	cmp	r5, r2
 8001c68:	d31a      	bcc.n	8001ca0 <_usb_ep0in+0x58>
 8001c6a:	2320      	movs	r3, #32
 8001c6c:	f383 8811 	msr	BASEPRI, r3
    __attribute__ ((fallthrough));
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 8001c70:	2300      	movs	r3, #0
 8001c72:	461a      	mov	r2, r3
 8001c74:	4619      	mov	r1, r3
 8001c76:	4620      	mov	r0, r4
 8001c78:	f7ff fe7a 	bl	8001970 <usbStartReceiveI>
 8001c7c:	2300      	movs	r3, #0
 8001c7e:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
#else
    /* Use hardware end phase send */
    usb_lld_end_setup(usbp, ep);
#endif
    usbp->ep0state = USB_EP0_WAITING_STS;
 8001c82:	2303      	movs	r3, #3
 8001c84:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
    _usb_ep0_error(usbp);
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001c88:	bd38      	pop	{r3, r4, r5, pc}
 8001c8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _usb_ep0_error(usbp);
 8001c8e:	f7ff be0f 	b.w	80018b0 <_usb_ep0_error>
    if (usbp->ep0endcb != NULL)
 8001c92:	6f03      	ldr	r3, [r0, #112]	@ 0x70
 8001c94:	b103      	cbz	r3, 8001c98 <_usb_ep0in+0x50>
      usbp->ep0endcb(usbp);
 8001c96:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001c98:	2300      	movs	r3, #0
 8001c9a:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 8001c9e:	bd38      	pop	{r3, r4, r5, pc}
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8001ca0:	68c2      	ldr	r2, [r0, #12]
 8001ca2:	8a12      	ldrh	r2, [r2, #16]
 8001ca4:	fbb5 f1f2 	udiv	r1, r5, r2
 8001ca8:	fb02 5511 	mls	r5, r2, r1, r5
    if ((usbp->ep0n < usbp->setup.wLength) &&
 8001cac:	2d00      	cmp	r5, #0
 8001cae:	d1dc      	bne.n	8001c6a <_usb_ep0in+0x22>
 8001cb0:	2320      	movs	r3, #32
 8001cb2:	f383 8811 	msr	BASEPRI, r3
      usbStartTransmitI(usbp, 0, NULL, 0);
 8001cb6:	462b      	mov	r3, r5
 8001cb8:	462a      	mov	r2, r5
 8001cba:	4629      	mov	r1, r5
 8001cbc:	f7ff fe6e 	bl	800199c <usbStartTransmitI>
 8001cc0:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8001cc4:	2302      	movs	r3, #2
 8001cc6:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 8001cca:	bd38      	pop	{r3, r4, r5, pc}

08001ccc <_usb_ep0out>:
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  (void)ep;
  switch (usbp->ep0state) {
 8001ccc:	f890 3064 	ldrb.w	r3, [r0, #100]	@ 0x64
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001cd0:	b510      	push	{r4, lr}
 8001cd2:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8001cd4:	2b06      	cmp	r3, #6
 8001cd6:	d813      	bhi.n	8001d00 <_usb_ep0out+0x34>
 8001cd8:	e8df f003 	tbb	[pc, r3]
 8001cdc:	17131313 	.word	0x17131313
 8001ce0:	1304      	.short	0x1304
 8001ce2:	13          	.byte	0x13
 8001ce3:	00          	.byte	0x00
 8001ce4:	2320      	movs	r3, #32
 8001ce6:	f383 8811 	msr	BASEPRI, r3
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 8001cea:	2300      	movs	r3, #0
 8001cec:	461a      	mov	r2, r3
 8001cee:	4619      	mov	r1, r3
 8001cf0:	f7ff fe54 	bl	800199c <usbStartTransmitI>
 8001cf4:	2300      	movs	r3, #0
 8001cf6:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
#else
    /* Use hardware end phase send */
    usb_lld_end_setup(usbp, ep);
#endif
    usbp->ep0state = USB_EP0_SENDING_STS;
 8001cfa:	2305      	movs	r3, #5
 8001cfc:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
    _usb_ep0_error(usbp);
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8001d00:	bd10      	pop	{r4, pc}
 8001d02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    _usb_ep0_error(usbp);
 8001d06:	f7ff bdd3 	b.w	80018b0 <_usb_ep0_error>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8001d0a:	68c3      	ldr	r3, [r0, #12]
 8001d0c:	699b      	ldr	r3, [r3, #24]
 8001d0e:	685b      	ldr	r3, [r3, #4]
 8001d10:	2b00      	cmp	r3, #0
 8001d12:	d1f5      	bne.n	8001d00 <_usb_ep0out+0x34>
    if (usbp->ep0endcb != NULL)
 8001d14:	6f03      	ldr	r3, [r0, #112]	@ 0x70
 8001d16:	b103      	cbz	r3, 8001d1a <_usb_ep0out+0x4e>
      usbp->ep0endcb(usbp);
 8001d18:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001d1a:	2300      	movs	r3, #0
 8001d1c:	f884 3064 	strb.w	r3, [r4, #100]	@ 0x64
}
 8001d20:	bd10      	pop	{r4, pc}
 8001d22:	bf00      	nop

08001d24 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d24:	0943      	lsrs	r3, r0, #5
 8001d26:	009b      	lsls	r3, r3, #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001d28:	f100 4c60 	add.w	ip, r0, #3758096384	@ 0xe0000000
 8001d2c:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 8001d30:	f503 4361 	add.w	r3, r3, #57600	@ 0xe100
 8001d34:	0109      	lsls	r1, r1, #4
 8001d36:	f50c 4c61 	add.w	ip, ip, #57600	@ 0xe100
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d3a:	f000 001f 	and.w	r0, r0, #31
 8001d3e:	2201      	movs	r2, #1
 8001d40:	4082      	lsls	r2, r0
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001d42:	b2c9      	uxtb	r1, r1
 8001d44:	f88c 1300 	strb.w	r1, [ip, #768]	@ 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001d48:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001d4c:	601a      	str	r2, [r3, #0]
}
 8001d4e:	4770      	bx	lr

08001d50 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8001d50:	4b0d      	ldr	r3, [pc, #52]	@ (8001d88 <hal_lld_init+0x38>)
 8001d52:	f04f 31ff 	mov.w	r1, #4294967295
 8001d56:	2200      	movs	r2, #0
 8001d58:	6a98      	ldr	r0, [r3, #40]	@ 0x28
 8001d5a:	6299      	str	r1, [r3, #40]	@ 0x28
 8001d5c:	629a      	str	r2, [r3, #40]	@ 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001d5e:	6918      	ldr	r0, [r3, #16]
 8001d60:	6119      	str	r1, [r3, #16]
 8001d62:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8001d64:	68d8      	ldr	r0, [r3, #12]
 8001d66:	60d9      	str	r1, [r3, #12]
 8001d68:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001d6a:	69da      	ldr	r2, [r3, #28]
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8001d6c:	4907      	ldr	r1, [pc, #28]	@ (8001d8c <hal_lld_init+0x3c>)
  rccEnablePWRInterface(FALSE);
 8001d6e:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8001d72:	61da      	str	r2, [r3, #28]
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001d74:	699a      	ldr	r2, [r3, #24]
 8001d76:	f042 0201 	orr.w	r2, r2, #1
 8001d7a:	619a      	str	r2, [r3, #24]
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8001d7c:	680b      	ldr	r3, [r1, #0]
 8001d7e:	f043 0320 	orr.w	r3, r3, #32
 8001d82:	600b      	str	r3, [r1, #0]
#endif
}
 8001d84:	4770      	bx	lr
 8001d86:	bf00      	nop
 8001d88:	40021000 	.word	0x40021000
 8001d8c:	40010000 	.word	0x40010000

08001d90 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001d90:	4a1f      	ldr	r2, [pc, #124]	@ (8001e10 <stm32_clock_init+0x80>)
 8001d92:	6813      	ldr	r3, [r2, #0]
 8001d94:	f043 0301 	orr.w	r3, r3, #1
 8001d98:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001d9a:	6813      	ldr	r3, [r2, #0]
 8001d9c:	0798      	lsls	r0, r3, #30
 8001d9e:	d5fc      	bpl.n	8001d9a <stm32_clock_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001da0:	6853      	ldr	r3, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001da2:	491b      	ldr	r1, [pc, #108]	@ (8001e10 <stm32_clock_init+0x80>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001da4:	f023 0303 	bic.w	r3, r3, #3
 8001da8:	6053      	str	r3, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001daa:	6853      	ldr	r3, [r2, #4]
 8001dac:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001dae:	684b      	ldr	r3, [r1, #4]
 8001db0:	f013 030c 	ands.w	r3, r3, #12
 8001db4:	d1fb      	bne.n	8001dae <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001db6:	6808      	ldr	r0, [r1, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001db8:	4a15      	ldr	r2, [pc, #84]	@ (8001e10 <stm32_clock_init+0x80>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001dba:	f000 00f9 	and.w	r0, r0, #249	@ 0xf9
 8001dbe:	6008      	str	r0, [r1, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001dc0:	604b      	str	r3, [r1, #4]
  RCC->CR |= RCC_CR_HSEON;
 8001dc2:	680b      	ldr	r3, [r1, #0]
 8001dc4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001dc8:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001dca:	6813      	ldr	r3, [r2, #0]
 8001dcc:	0399      	lsls	r1, r3, #14
 8001dce:	d5fc      	bpl.n	8001dca <stm32_clock_init+0x3a>

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001dd0:	f242 1110 	movw	r1, #8464	@ 0x2110
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001dd4:	2330      	movs	r3, #48	@ 0x30
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8001dd6:	480f      	ldr	r0, [pc, #60]	@ (8001e14 <stm32_clock_init+0x84>)
 8001dd8:	6050      	str	r0, [r2, #4]
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001dda:	62d1      	str	r1, [r2, #44]	@ 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001ddc:	6313      	str	r3, [r2, #48]	@ 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001dde:	6813      	ldr	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001de0:	490b      	ldr	r1, [pc, #44]	@ (8001e10 <stm32_clock_init+0x80>)
  RCC->CR   |= RCC_CR_PLLON;
 8001de2:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001de6:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001de8:	680b      	ldr	r3, [r1, #0]
 8001dea:	019b      	lsls	r3, r3, #6
 8001dec:	d5fc      	bpl.n	8001de8 <stm32_clock_init+0x58>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001dee:	4b0a      	ldr	r3, [pc, #40]	@ (8001e18 <stm32_clock_init+0x88>)
 8001df0:	2212      	movs	r2, #18
 8001df2:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001df4:	684b      	ldr	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001df6:	4a06      	ldr	r2, [pc, #24]	@ (8001e10 <stm32_clock_init+0x80>)
  RCC->CFGR |= STM32_SW;
 8001df8:	f043 0302 	orr.w	r3, r3, #2
 8001dfc:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001dfe:	6853      	ldr	r3, [r2, #4]
 8001e00:	f003 030c 	and.w	r3, r3, #12
 8001e04:	2b08      	cmp	r3, #8
 8001e06:	d1fa      	bne.n	8001dfe <stm32_clock_init+0x6e>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 8001e08:	6b13      	ldr	r3, [r2, #48]	@ 0x30
 8001e0a:	6313      	str	r3, [r2, #48]	@ 0x30
#endif /* !STM32_NO_INIT */
}
 8001e0c:	4770      	bx	lr
 8001e0e:	bf00      	nop
 8001e10:	40021000 	.word	0x40021000
 8001e14:	071d0400 	.word	0x071d0400
 8001e18:	40022000 	.word	0x40022000

08001e1c <VectorB0>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001e1c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8001e20:	691a      	ldr	r2, [r3, #16]
 8001e22:	0792      	lsls	r2, r2, #30
 8001e24:	d401      	bmi.n	8001e2a <VectorB0+0xe>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001e26:	f7ff b885 	b.w	8000f34 <_port_irq_epilogue>
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001e2a:	b510      	push	{r4, lr}
    STM32_ST_TIM->SR = 0U;
 8001e2c:	2400      	movs	r4, #0
 8001e2e:	611c      	str	r4, [r3, #16]
 8001e30:	2320      	movs	r3, #32
 8001e32:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 8001e36:	f7fe fe07 	bl	8000a48 <chSysTimerHandlerI>
 8001e3a:	f384 8811 	msr	BASEPRI, r4
}
 8001e3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001e42:	f7ff b877 	b.w	8000f34 <_port_irq_epilogue>
 8001e46:	bf00      	nop

08001e48 <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001e48:	490f      	ldr	r1, [pc, #60]	@ (8001e88 <st_lld_init+0x40>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001e4a:	4810      	ldr	r0, [pc, #64]	@ (8001e8c <st_lld_init+0x44>)
  ST_ENABLE_CLOCK();
 8001e4c:	69ca      	ldr	r2, [r1, #28]
 8001e4e:	f042 0201 	orr.w	r2, r2, #1
void st_lld_init(void) {
 8001e52:	b430      	push	{r4, r5}
  ST_ENABLE_CLOCK();
 8001e54:	61ca      	str	r2, [r1, #28]
  ST_ENABLE_STOP();
 8001e56:	6881      	ldr	r1, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001e58:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8001e5c:	f240 24cf 	movw	r4, #719	@ 0x2cf
  ST_ENABLE_STOP();
 8001e60:	f041 0101 	orr.w	r1, r1, #1
 8001e64:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001e66:	2200      	movs	r2, #0
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001e68:	629c      	str	r4, [r3, #40]	@ 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001e6a:	f04f 35ff 	mov.w	r5, #4294967295
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001e6e:	2401      	movs	r4, #1
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001e70:	62dd      	str	r5, [r3, #44]	@ 0x2c
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e72:	2102      	movs	r1, #2
  STM32_ST_TIM->CCMR1  = 0;
 8001e74:	619a      	str	r2, [r3, #24]
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e76:	201c      	movs	r0, #28
  STM32_ST_TIM->CCR[0] = 0;
 8001e78:	635a      	str	r2, [r3, #52]	@ 0x34
  STM32_ST_TIM->DIER   = 0;
 8001e7a:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001e7c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001e7e:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001e80:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001e82:	bc30      	pop	{r4, r5}
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e84:	f7ff bf4e 	b.w	8001d24 <nvicEnableVector>
 8001e88:	40021000 	.word	0x40021000
 8001e8c:	e0042000 	.word	0xe0042000

08001e90 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8001e90:	4a02      	ldr	r2, [pc, #8]	@ (8001e9c <notify1+0xc>)
 8001e92:	6813      	ldr	r3, [r2, #0]
 8001e94:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8001e98:	6013      	str	r3, [r2, #0]
}
 8001e9a:	4770      	bx	lr
 8001e9c:	40013800 	.word	0x40013800

08001ea0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001ea0:	b570      	push	{r4, r5, r6, lr}
  USART_TypeDef *u = sdp->usart;
 8001ea2:	4b1a      	ldr	r3, [pc, #104]	@ (8001f0c <VectorD4+0x6c>)
 8001ea4:	f8d3 40c8 	ldr.w	r4, [r3, #200]	@ 0xc8
  uint32_t cr1 = u->CR1;
 8001ea8:	6826      	ldr	r6, [r4, #0]
  uint32_t isr = u->ISR;
 8001eaa:	69e5      	ldr	r5, [r4, #28]
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001eac:	b082      	sub	sp, #8
 8001eae:	2220      	movs	r2, #32
  u->ICR = isr;
 8001eb0:	6225      	str	r5, [r4, #32]
 8001eb2:	f382 8811 	msr	BASEPRI, r2
  while (isr & USART_ISR_RXNE) {
 8001eb6:	06aa      	lsls	r2, r5, #26
 8001eb8:	d509      	bpl.n	8001ece <VectorD4+0x2e>
    qPutI(&sdp->iqueue, (uint8_t)u->RDR);
 8001eba:	3308      	adds	r3, #8
 8001ebc:	9301      	str	r3, [sp, #4]
 8001ebe:	8ca1      	ldrh	r1, [r4, #36]	@ 0x24
 8001ec0:	9801      	ldr	r0, [sp, #4]
 8001ec2:	b2c9      	uxtb	r1, r1
 8001ec4:	f7ff fa36 	bl	8001334 <qPutI>
    isr = u->ISR;
 8001ec8:	69e5      	ldr	r5, [r4, #28]
  while (isr & USART_ISR_RXNE) {
 8001eca:	06ab      	lsls	r3, r5, #26
 8001ecc:	d4f7      	bmi.n	8001ebe <VectorD4+0x1e>
  if (cr1 & USART_CR1_TXEIE) {
 8001ece:	0630      	lsls	r0, r6, #24
 8001ed0:	d410      	bmi.n	8001ef4 <VectorD4+0x54>
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 8001ed2:	0672      	lsls	r2, r6, #25
 8001ed4:	d504      	bpl.n	8001ee0 <VectorD4+0x40>
 8001ed6:	066b      	lsls	r3, r5, #25
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001ed8:	bf44      	itt	mi
 8001eda:	f026 0640 	bicmi.w	r6, r6, #64	@ 0x40
 8001ede:	6026      	strmi	r6, [r4, #0]
 8001ee0:	2300      	movs	r3, #0
 8001ee2:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8001ee6:	b002      	add	sp, #8
 8001ee8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
 8001eec:	f7ff b822 	b.w	8000f34 <_port_irq_epilogue>
      u->TDR = b;
 8001ef0:	8520      	strh	r0, [r4, #40]	@ 0x28
      isr = u->ISR;
 8001ef2:	69e5      	ldr	r5, [r4, #28]
    while (isr & USART_ISR_TXE) {
 8001ef4:	0629      	lsls	r1, r5, #24
 8001ef6:	d5ec      	bpl.n	8001ed2 <VectorD4+0x32>
      msg_t b = qGetI(&sdp->oqueue);
 8001ef8:	4805      	ldr	r0, [pc, #20]	@ (8001f10 <VectorD4+0x70>)
 8001efa:	f7ff fac1 	bl	8001480 <qGetI>
      if (b < MSG_OK) {
 8001efe:	2800      	cmp	r0, #0
      u->TDR = b;
 8001f00:	b280      	uxth	r0, r0
      if (b < MSG_OK) {
 8001f02:	daf5      	bge.n	8001ef0 <VectorD4+0x50>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8001f04:	f026 0380 	bic.w	r3, r6, #128	@ 0x80
 8001f08:	6023      	str	r3, [r4, #0]
        break;
 8001f0a:	e7e2      	b.n	8001ed2 <VectorD4+0x32>
 8001f0c:	20000574 	.word	0x20000574
 8001f10:	2000059c 	.word	0x2000059c

08001f14 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8001f14:	b510      	push	{r4, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8001f16:	4a08      	ldr	r2, [pc, #32]	@ (8001f38 <sd_lld_init+0x24>)
 8001f18:	4808      	ldr	r0, [pc, #32]	@ (8001f3c <sd_lld_init+0x28>)
  SD1.usart = USART1;
 8001f1a:	4c08      	ldr	r4, [pc, #32]	@ (8001f3c <sd_lld_init+0x28>)
  sdObjectInit(&SD1, NULL, notify1);
 8001f1c:	2100      	movs	r1, #0
 8001f1e:	f7ff fb35 	bl	800158c <sdObjectInit>
  SD1.usart = USART1;
 8001f22:	4a07      	ldr	r2, [pc, #28]	@ (8001f40 <sd_lld_init+0x2c>)
  SD1.clock = STM32_USART1CLK;
 8001f24:	4b07      	ldr	r3, [pc, #28]	@ (8001f44 <sd_lld_init+0x30>)
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001f26:	2102      	movs	r1, #2
  SD1.clock = STM32_USART1CLK;
 8001f28:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001f2c:	2025      	movs	r0, #37	@ 0x25
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8001f2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001f32:	f7ff bef7 	b.w	8001d24 <nvicEnableVector>
 8001f36:	bf00      	nop
 8001f38:	08001e91 	.word	0x08001e91
 8001f3c:	20000574 	.word	0x20000574
 8001f40:	40013800 	.word	0x40013800
 8001f44:	044aa200 	.word	0x044aa200

08001f48 <sd_lld_setbaudrate>:
}

void sd_lld_setbaudrate(SerialDriver *sdp, uint32_t baud) {
  USART_TypeDef *u = sdp->usart;
  u->CR1&=~USART_CR1_UE;
  u->BRR = (uint32_t)(sdp->clock / baud);
 8001f48:	e9d0 3232 	ldrd	r3, r2, [r0, #200]	@ 0xc8
  u->CR1&=~USART_CR1_UE;
 8001f4c:	6818      	ldr	r0, [r3, #0]
  u->BRR = (uint32_t)(sdp->clock / baud);
 8001f4e:	fbb2 f2f1 	udiv	r2, r2, r1
  u->CR1&=~USART_CR1_UE;
 8001f52:	f020 0001 	bic.w	r0, r0, #1
 8001f56:	6018      	str	r0, [r3, #0]
  u->BRR = (uint32_t)(sdp->clock / baud);
 8001f58:	60da      	str	r2, [r3, #12]
  u->CR1|= USART_CR1_UE;
 8001f5a:	681a      	ldr	r2, [r3, #0]
 8001f5c:	f042 0201 	orr.w	r2, r2, #1
 8001f60:	601a      	str	r2, [r3, #0]
}
 8001f62:	4770      	bx	lr

08001f64 <sd_lld_start>:
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001f64:	b570      	push	{r4, r5, r6, lr}
  if (config == NULL)
 8001f66:	b311      	cbz	r1, 8001fae <sd_lld_start+0x4a>
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001f68:	e9d1 3501 	ldrd	r3, r5, [r1, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001f6c:	68ca      	ldr	r2, [r1, #12]
  sd_lld_setbaudrate(sdp, config->speed);
 8001f6e:	6809      	ldr	r1, [r1, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001f70:	f443 7396 	orr.w	r3, r3, #300	@ 0x12c
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001f74:	f045 0540 	orr.w	r5, r5, #64	@ 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001f78:	f042 0201 	orr.w	r2, r2, #1
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001f7c:	f043 0301 	orr.w	r3, r3, #1
  if (sdp->state == SD_STOP) {
 8001f80:	7904      	ldrb	r4, [r0, #4]
 8001f82:	2c01      	cmp	r4, #1
 8001f84:	d00a      	beq.n	8001f9c <sd_lld_start+0x38>
  USART_TypeDef *u = sdp->usart;
 8001f86:	f8d0 40c8 	ldr.w	r4, [r0, #200]	@ 0xc8
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001f8a:	6065      	str	r5, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001f8c:	60a2      	str	r2, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001f8e:	6023      	str	r3, [r4, #0]
  sd_lld_setbaudrate(sdp, config->speed);
 8001f90:	f7ff ffda 	bl	8001f48 <sd_lld_setbaudrate>
  u->ICR = 0xFFFFFFFFU;
 8001f94:	f04f 33ff 	mov.w	r3, #4294967295
 8001f98:	6223      	str	r3, [r4, #32]
}
 8001f9a:	bd70      	pop	{r4, r5, r6, pc}
    if (&SD1 == sdp) {
 8001f9c:	4c08      	ldr	r4, [pc, #32]	@ (8001fc0 <sd_lld_start+0x5c>)
 8001f9e:	42a0      	cmp	r0, r4
 8001fa0:	d1f1      	bne.n	8001f86 <sd_lld_start+0x22>
      rccEnableUSART1(FALSE);
 8001fa2:	4e08      	ldr	r6, [pc, #32]	@ (8001fc4 <sd_lld_start+0x60>)
 8001fa4:	69b4      	ldr	r4, [r6, #24]
 8001fa6:	f444 4480 	orr.w	r4, r4, #16384	@ 0x4000
 8001faa:	61b4      	str	r4, [r6, #24]
 8001fac:	e7eb      	b.n	8001f86 <sd_lld_start+0x22>
 8001fae:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
 8001fb2:	f240 132d 	movw	r3, #301	@ 0x12d
 8001fb6:	2201      	movs	r2, #1
 8001fb8:	f244 0540 	movw	r5, #16448	@ 0x4040
 8001fbc:	e7e0      	b.n	8001f80 <sd_lld_start+0x1c>
 8001fbe:	bf00      	nop
 8001fc0:	20000574 	.word	0x20000574
 8001fc4:	40021000 	.word	0x40021000

08001fc8 <usb_lld_init>:
 *
 * @notapi
 */
void usb_lld_init(void) {
  /* Driver initialization.*/
  usbObjectInit(&USBD1);
 8001fc8:	4801      	ldr	r0, [pc, #4]	@ (8001fd0 <usb_lld_init+0x8>)
 8001fca:	f7ff bc99 	b.w	8001900 <usbObjectInit>
 8001fce:	bf00      	nop
 8001fd0:	20000650 	.word	0x20000650

08001fd4 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8001fd4:	b538      	push	{r3, r4, r5, lr}

  if (usbp->state == USB_STOP) {
 8001fd6:	7803      	ldrb	r3, [r0, #0]
 8001fd8:	2b01      	cmp	r3, #1
 8001fda:	d000      	beq.n	8001fde <usb_lld_start+0xa>
    }
#endif
    /* Reset procedure enforced on driver start.*/
    _usb_reset(usbp);
  }
}
 8001fdc:	bd38      	pop	{r3, r4, r5, pc}
    if (&USBD1 == usbp) {
 8001fde:	4a0d      	ldr	r2, [pc, #52]	@ (8002014 <usb_lld_start+0x40>)
 8001fe0:	4290      	cmp	r0, r2
 8001fe2:	4604      	mov	r4, r0
 8001fe4:	d004      	beq.n	8001ff0 <usb_lld_start+0x1c>
    _usb_reset(usbp);
 8001fe6:	4620      	mov	r0, r4
}
 8001fe8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    _usb_reset(usbp);
 8001fec:	f7ff bcec 	b.w	80019c8 <_usb_reset>
      rccEnableUSB(FALSE);
 8001ff0:	4909      	ldr	r1, [pc, #36]	@ (8002018 <usb_lld_start+0x44>)
      STM32_USB->CNTR = CNTR_FRES;
 8001ff2:	4d0a      	ldr	r5, [pc, #40]	@ (800201c <usb_lld_start+0x48>)
      rccEnableUSB(FALSE);
 8001ff4:	69ca      	ldr	r2, [r1, #28]
 8001ff6:	f442 0200 	orr.w	r2, r2, #8388608	@ 0x800000
 8001ffa:	61ca      	str	r2, [r1, #28]
      nvicEnableVector(STM32_USB1_HP_NUMBER, STM32_USB_USB1_HP_IRQ_PRIORITY);
 8001ffc:	204a      	movs	r0, #74	@ 0x4a
      STM32_USB->CNTR = CNTR_FRES;
 8001ffe:	642b      	str	r3, [r5, #64]	@ 0x40
      nvicEnableVector(STM32_USB1_HP_NUMBER, STM32_USB_USB1_HP_IRQ_PRIORITY);
 8002000:	210d      	movs	r1, #13
 8002002:	f7ff fe8f 	bl	8001d24 <nvicEnableVector>
      nvicEnableVector(STM32_USB1_LP_NUMBER, STM32_USB_USB1_LP_IRQ_PRIORITY);
 8002006:	2103      	movs	r1, #3
 8002008:	204b      	movs	r0, #75	@ 0x4b
 800200a:	f7ff fe8b 	bl	8001d24 <nvicEnableVector>
      STM32_USB->CNTR = 0;
 800200e:	2300      	movs	r3, #0
 8002010:	642b      	str	r3, [r5, #64]	@ 0x40
 8002012:	e7e8      	b.n	8001fe6 <usb_lld_start+0x12>
 8002014:	20000650 	.word	0x20000650
 8002018:	40021000 	.word	0x40021000
 800201c:	40005c00 	.word	0x40005c00

08002020 <usb_lld_set_address>:
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 8002020:	f890 307e 	ldrb.w	r3, [r0, #126]	@ 0x7e
 8002024:	4a02      	ldr	r2, [pc, #8]	@ (8002030 <usb_lld_set_address+0x10>)
 8002026:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800202a:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 800202c:	4770      	bx	lr
 800202e:	bf00      	nop
 8002030:	40005c00 	.word	0x40005c00

08002034 <usb_lld_init_endpoint>:
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint16_t epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8002034:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8002038:	b5f0      	push	{r4, r5, r6, r7, lr}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 800203a:	68dc      	ldr	r4, [r3, #12]
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  dp = USB_GET_DESCRIPTOR(ep);
 800203c:	4a27      	ldr	r2, [pc, #156]	@ (80020dc <usb_lld_init_endpoint+0xa8>)
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 800203e:	6823      	ldr	r3, [r4, #0]
  dp = USB_GET_DESCRIPTOR(ep);
 8002040:	6d12      	ldr	r2, [r2, #80]	@ 0x50

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 8002042:	6965      	ldr	r5, [r4, #20]
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8002044:	f003 0303 	and.w	r3, r3, #3
 8002048:	2b03      	cmp	r3, #3
 800204a:	bf18      	it	ne
 800204c:	fab3 f383 	clzne	r3, r3
  dp = USB_GET_DESCRIPTOR(ep);
 8002050:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8002054:	bf18      	it	ne
 8002056:	095b      	lsrne	r3, r3, #5
  dp = USB_GET_DESCRIPTOR(ep);
 8002058:	f502 42c0 	add.w	r2, r2, #24576	@ 0x6000
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 800205c:	bf14      	ite	ne
 800205e:	025b      	lslne	r3, r3, #9
 8002060:	f44f 63c0 	moveq.w	r3, #1536	@ 0x600
  dp = USB_GET_DESCRIPTOR(ep);
 8002064:	ea4f 1e01 	mov.w	lr, r1, lsl #4
 8002068:	eb02 1c01 	add.w	ip, r2, r1, lsl #4
  if (epcp->in_state != NULL) {
 800206c:	b17d      	cbz	r5, 800208e <usb_lld_init_endpoint+0x5a>
    dp->TXCOUNT0 = 0;
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 800206e:	8a25      	ldrh	r5, [r4, #16]
  next = usbp->pmnext;
 8002070:	f8d0 6080 	ldr.w	r6, [r0, #128]	@ 0x80
  usbp->pmnext += (size + 1) & ~1;
 8002074:	3501      	adds	r5, #1
 8002076:	f025 0501 	bic.w	r5, r5, #1
 800207a:	4435      	add	r5, r6
    dp->TXCOUNT0 = 0;
 800207c:	2700      	movs	r7, #0
 800207e:	f8cc 7004 	str.w	r7, [ip, #4]
  usbp->pmnext += (size + 1) & ~1;
 8002082:	f8c0 5080 	str.w	r5, [r0, #128]	@ 0x80
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8002086:	f84e 6002 	str.w	r6, [lr, r2]
    }
    else {
      epr |= EPR_STAT_TX_NAK;
    }
#else
    epr |= EPR_STAT_TX_NAK;
 800208a:	f043 0320 	orr.w	r3, r3, #32
#endif
  }

  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
 800208e:	69a2      	ldr	r2, [r4, #24]
 8002090:	b192      	cbz	r2, 80020b8 <usb_lld_init_endpoint+0x84>
    uint16_t nblocks;
    /* Endpoint size and address initialization.*/
    /* > 62 Round up, div by 32 and sub 1 == (size + 31)/32 - 1 == (size-1)/32)*/
    if (epcp->out_maxsize > 62)
 8002092:	8a62      	ldrh	r2, [r4, #18]
 8002094:	2a3e      	cmp	r2, #62	@ 0x3e
 8002096:	d819      	bhi.n	80020cc <usb_lld_init_endpoint+0x98>
      nblocks = ((epcp->out_maxsize - 1) >> 5) | (1<<5);
    else
      nblocks = ((epcp->out_maxsize + 1) >> 1);
 8002098:	3201      	adds	r2, #1
 800209a:	0854      	lsrs	r4, r2, #1
    dp->RXCOUNT0 = nblocks << 10;
 800209c:	02a4      	lsls	r4, r4, #10
 800209e:	f8cc 400c 	str.w	r4, [ip, #12]
  next = usbp->pmnext;
 80020a2:	f8d0 4080 	ldr.w	r4, [r0, #128]	@ 0x80
  usbp->pmnext += (size + 1) & ~1;
 80020a6:	f022 0201 	bic.w	r2, r2, #1
 80020aa:	4422      	add	r2, r4
 80020ac:	f8c0 2080 	str.w	r2, [r0, #128]	@ 0x80
    }
    else {
      epr |= EPR_STAT_RX_NAK;
    }
#else
    epr |= EPR_STAT_RX_NAK;
 80020b0:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 80020b4:	f8cc 4008 	str.w	r4, [ip, #8]
#endif
  }

  /* CHEPxR register cleared and initialized.*/
  STM32_USB->EPR[ep] = STM32_USB->EPR[ep];
 80020b8:	008a      	lsls	r2, r1, #2
 80020ba:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 80020be:	f502 42b8 	add.w	r2, r2, #23552	@ 0x5c00
  STM32_USB->EPR[ep] = epr | ep;
 80020c2:	430b      	orrs	r3, r1
  STM32_USB->EPR[ep] = STM32_USB->EPR[ep];
 80020c4:	6811      	ldr	r1, [r2, #0]
 80020c6:	6011      	str	r1, [r2, #0]
  STM32_USB->EPR[ep] = epr | ep;
 80020c8:	6013      	str	r3, [r2, #0]
}
 80020ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
      nblocks = ((epcp->out_maxsize - 1) >> 5) | (1<<5);
 80020cc:	1e54      	subs	r4, r2, #1
 80020ce:	f3c4 144f 	ubfx	r4, r4, #5, #16
 80020d2:	f044 0420 	orr.w	r4, r4, #32
 80020d6:	3201      	adds	r2, #1
 80020d8:	e7e0      	b.n	800209c <usb_lld_init_endpoint+0x68>
 80020da:	bf00      	nop
 80020dc:	40005c00 	.word	0x40005c00

080020e0 <usb_lld_reset>:
  STM32_USB->BTABLE = BTABLE_ADDR;
 80020e0:	4a0c      	ldr	r2, [pc, #48]	@ (8002114 <usb_lld_reset+0x34>)
void usb_lld_reset(USBDriver *usbp) {
 80020e2:	b410      	push	{r4}
  STM32_USB->BTABLE = BTABLE_ADDR;
 80020e4:	2100      	movs	r1, #0
  STM32_USB->DADDR  = DADDR_EF;
 80020e6:	2480      	movs	r4, #128	@ 0x80
  STM32_USB->BTABLE = BTABLE_ADDR;
 80020e8:	6511      	str	r1, [r2, #80]	@ 0x50
  STM32_USB->ISTR   = 0;
 80020ea:	6451      	str	r1, [r2, #68]	@ 0x44
  STM32_USB->DADDR  = DADDR_EF;
 80020ec:	64d4      	str	r4, [r2, #76]	@ 0x4c
  if (usbp->config->sof_cb != NULL)
 80020ee:	6844      	ldr	r4, [r0, #4]
 80020f0:	68e4      	ldr	r4, [r4, #12]
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
 80020f2:	428c      	cmp	r4, r1
 80020f4:	bf14      	ite	ne
 80020f6:	f44f 441e 	movne.w	r4, #40448	@ 0x9e00
 80020fa:	f44f 441c 	moveq.w	r4, #39936	@ 0x9c00
  STM32_USB->CNTR = cntr;
 80020fe:	6414      	str	r4, [r2, #64]	@ 0x40
  usbp->pmnext = 64;
 8002100:	2440      	movs	r4, #64	@ 0x40
  usbp->epc[0] = &ep0config;
 8002102:	4a05      	ldr	r2, [pc, #20]	@ (8002118 <usb_lld_reset+0x38>)
  usbp->pmnext = 64;
 8002104:	f8c0 4080 	str.w	r4, [r0, #128]	@ 0x80
  usbp->epc[0] = &ep0config;
 8002108:	60c2      	str	r2, [r0, #12]
}
 800210a:	f85d 4b04 	ldr.w	r4, [sp], #4
  usb_lld_init_endpoint(usbp, 0);
 800210e:	f7ff bf91 	b.w	8002034 <usb_lld_init_endpoint>
 8002112:	bf00      	nop
 8002114:	40005c00 	.word	0x40005c00
 8002118:	080147c0 	.word	0x080147c0

0800211c <usb_lld_get_status_out>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 800211c:	4b05      	ldr	r3, [pc, #20]	@ (8002134 <usb_lld_get_status_out+0x18>)
 800211e:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 8002122:	f410 5040 	ands.w	r0, r0, #12288	@ 0x3000
 8002126:	d004      	beq.n	8002132 <usb_lld_get_status_out+0x16>
  case EPR_STAT_RX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_RX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8002128:	f5b0 5f80 	cmp.w	r0, #4096	@ 0x1000
 800212c:	bf0c      	ite	eq
 800212e:	2001      	moveq	r0, #1
 8002130:	2002      	movne	r0, #2
  }
}
 8002132:	4770      	bx	lr
 8002134:	40005c00 	.word	0x40005c00

08002138 <usb_lld_get_status_in>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8002138:	4b05      	ldr	r3, [pc, #20]	@ (8002150 <usb_lld_get_status_in+0x18>)
 800213a:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 800213e:	f010 0030 	ands.w	r0, r0, #48	@ 0x30
 8002142:	d003      	beq.n	800214c <usb_lld_get_status_in+0x14>
  case EPR_STAT_TX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_TX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8002144:	2810      	cmp	r0, #16
 8002146:	bf0c      	ite	eq
 8002148:	2001      	moveq	r0, #1
 800214a:	2002      	movne	r0, #2
  }
}
 800214c:	4770      	bx	lr
 800214e:	bf00      	nop
 8002150:	40005c00 	.word	0x40005c00

08002154 <usb_lld_read_setup>:
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
  (void)usbp;

  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002154:	4b10      	ldr	r3, [pc, #64]	@ (8002198 <usb_lld_read_setup+0x44>)
 8002156:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8002158:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 800215c:	f503 43c0 	add.w	r3, r3, #24576	@ 0x6000
 8002160:	eb03 1301 	add.w	r3, r3, r1, lsl #4
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8002164:	b410      	push	{r4}
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002166:	689b      	ldr	r3, [r3, #8]
 8002168:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 800216c:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8002170:	005b      	lsls	r3, r3, #1
  uint32_t n;
  for (n = 0; n < 4; n++)
    ((uint16_t *)buf)[n] = pmap[n];
 8002172:	2000      	movs	r0, #0
 8002174:	681c      	ldr	r4, [r3, #0]
 8002176:	4601      	mov	r1, r0
 8002178:	f364 000f 	bfi	r0, r4, #0, #16
 800217c:	685c      	ldr	r4, [r3, #4]
 800217e:	f364 401f 	bfi	r0, r4, #16, #16
 8002182:	e9d3 4302 	ldrd	r4, r3, [r3, #8]
 8002186:	f364 010f 	bfi	r1, r4, #0, #16
 800218a:	f363 411f 	bfi	r1, r3, #16, #16
}
 800218e:	f85d 4b04 	ldr.w	r4, [sp], #4
    ((uint16_t *)buf)[n] = pmap[n];
 8002192:	6010      	str	r0, [r2, #0]
 8002194:	6051      	str	r1, [r2, #4]
}
 8002196:	4770      	bx	lr
 8002198:	40005c00 	.word	0x40005c00

0800219c <usb_lld_start_out>:
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800219c:	4a07      	ldr	r2, [pc, #28]	@ (80021bc <usb_lld_start_out+0x20>)
 800219e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80021a2:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 80021a6:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 80021aa:	f483 5340 	eor.w	r3, r3, #12288	@ 0x3000
 80021ae:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80021b2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80021b6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 80021ba:	4770      	bx	lr
 80021bc:	40005c00 	.word	0x40005c00

080021c0 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80021c0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 80021c4:	b470      	push	{r4, r5, r6}
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80021c6:	68c3      	ldr	r3, [r0, #12]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80021c8:	4a1d      	ldr	r2, [pc, #116]	@ (8002240 <usb_lld_start_in+0x80>)
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80021ca:	695d      	ldr	r5, [r3, #20]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80021cc:	6d10      	ldr	r0, [r2, #80]	@ 0x50
 // if (isp->txsize < isp->txcnt) return;
  /* Get data count for send */
  size_t n = isp->txsize - isp->txcnt;
  /* Limit by max size */
  if (n > epcp->in_maxsize)
 80021ce:	8a1b      	ldrh	r3, [r3, #16]
  size_t n = isp->txsize - isp->txcnt;
 80021d0:	e9d5 4600 	ldrd	r4, r6, [r5]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80021d4:	f100 4080 	add.w	r0, r0, #1073741824	@ 0x40000000
  size_t n = isp->txsize - isp->txcnt;
 80021d8:	1ba4      	subs	r4, r4, r6
  if (n > epcp->in_maxsize)
 80021da:	429c      	cmp	r4, r3
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80021dc:	f500 40c0 	add.w	r0, r0, #24576	@ 0x6000
 80021e0:	ea4f 1201 	mov.w	r2, r1, lsl #4
  if (n > epcp->in_maxsize)
 80021e4:	bf28      	it	cs
 80021e6:	461c      	movcs	r4, r3
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80021e8:	5812      	ldr	r2, [r2, r0]
    n = epcp->in_maxsize;
  usb_packet_write_from_buffer(ep, &isp->txbuf[isp->txcnt], n);
 80021ea:	68ab      	ldr	r3, [r5, #8]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80021ec:	eb00 1001 	add.w	r0, r0, r1, lsl #4
  for (size_t i = 0; i < ((n+1)>>1); i++)
 80021f0:	f104 0c01 	add.w	ip, r4, #1
 80021f4:	ea5f 0c5c 	movs.w	ip, ip, lsr #1
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 80021f8:	6044      	str	r4, [r0, #4]
  for (size_t i = 0; i < ((n+1)>>1); i++)
 80021fa:	d00d      	beq.n	8002218 <usb_lld_start_in+0x58>
 80021fc:	f102 5200 	add.w	r2, r2, #536870912	@ 0x20000000
 8002200:	f502 5240 	add.w	r2, r2, #12288	@ 0x3000
 8002204:	4433      	add	r3, r6
 8002206:	0052      	lsls	r2, r2, #1
 8002208:	eb03 0c4c 	add.w	ip, r3, ip, lsl #1
    pmap[i] = ((uint16_t *)buf)[i];
 800220c:	f833 0b02 	ldrh.w	r0, [r3], #2
 8002210:	f842 0b04 	str.w	r0, [r2], #4
  for (size_t i = 0; i < ((n+1)>>1); i++)
 8002214:	4563      	cmp	r3, ip
 8002216:	d1f9      	bne.n	800220c <usb_lld_start_in+0x4c>
  /* Transaction data updated.*/
  isp->txcnt+= n;
  /* Starting IN operation.*/
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002218:	4a09      	ldr	r2, [pc, #36]	@ (8002240 <usb_lld_start_in+0x80>)
 800221a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 800221e:	f423 43f0 	bic.w	r3, r3, #30720	@ 0x7800
 8002222:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8002226:	f083 0330 	eor.w	r3, r3, #48	@ 0x30
 800222a:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
  isp->txcnt+= n;
 800222e:	4434      	add	r4, r6
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002230:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
  isp->txcnt+= n;
 8002234:	606c      	str	r4, [r5, #4]
}
 8002236:	bc70      	pop	{r4, r5, r6}
  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8002238:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 800223c:	4770      	bx	lr
 800223e:	bf00      	nop
 8002240:	40005c00 	.word	0x40005c00

08002244 <Vector16C>:
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8002244:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t istr = STM32_USB->ISTR;
 8002248:	4b71      	ldr	r3, [pc, #452]	@ (8002410 <Vector16C+0x1cc>)
 800224a:	6c5c      	ldr	r4, [r3, #68]	@ 0x44
  STM32_USB->ISTR = ~istr;
 800224c:	43e2      	mvns	r2, r4
  if ((istr & ISTR_RESET) != 0U) {
 800224e:	0561      	lsls	r1, r4, #21
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8002250:	b087      	sub	sp, #28
  STM32_USB->ISTR = ~istr;
 8002252:	645a      	str	r2, [r3, #68]	@ 0x44
  if ((istr & ISTR_RESET) != 0U) {
 8002254:	f100 80c4 	bmi.w	80023e0 <Vector16C+0x19c>
  if ((istr & ISTR_SUSP) != 0U) {
 8002258:	0522      	lsls	r2, r4, #20
 800225a:	f100 80c7 	bmi.w	80023ec <Vector16C+0x1a8>
  if ((istr & ISTR_WKUP) != 0U) {
 800225e:	04e3      	lsls	r3, r4, #19
 8002260:	d504      	bpl.n	800226c <Vector16C+0x28>
    uint32_t fnr = STM32_USB->FNR;
 8002262:	4b6b      	ldr	r3, [pc, #428]	@ (8002410 <Vector16C+0x1cc>)
 8002264:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
    if ((fnr & FNR_RXDP) == 0U) {
 8002266:	0417      	lsls	r7, r2, #16
 8002268:	f140 80c9 	bpl.w	80023fe <Vector16C+0x1ba>
  if ((istr & ISTR_SOF) != 0U) {
 800226c:	05a6      	lsls	r6, r4, #22
 800226e:	d507      	bpl.n	8002280 <Vector16C+0x3c>
    _usb_isr_invoke_sof_cb(usbp);
 8002270:	f8df b1a4 	ldr.w	fp, [pc, #420]	@ 8002418 <Vector16C+0x1d4>
 8002274:	f8db 3004 	ldr.w	r3, [fp, #4]
 8002278:	68db      	ldr	r3, [r3, #12]
 800227a:	b10b      	cbz	r3, 8002280 <Vector16C+0x3c>
 800227c:	4658      	mov	r0, fp
 800227e:	4798      	blx	r3
  while ((istr & ISTR_CTR) != 0U) {
 8002280:	0425      	lsls	r5, r4, #16
 8002282:	d53e      	bpl.n	8002302 <Vector16C+0xbe>
 8002284:	f8df b190 	ldr.w	fp, [pc, #400]	@ 8002418 <Vector16C+0x1d4>
    EPR_CLEAR_CTR_RX(ep);
 8002288:	4f62      	ldr	r7, [pc, #392]	@ (8002414 <Vector16C+0x1d0>)
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800228a:	f8df a184 	ldr.w	sl, [pc, #388]	@ 8002410 <Vector16C+0x1cc>
 800228e:	e01a      	b.n	80022c6 <Vector16C+0x82>
    USBInEndpointState *isp = epcp->in_state;
 8002290:	6970      	ldr	r0, [r6, #20]
    EPR_CLEAR_CTR_TX(ep);
 8002292:	6819      	ldr	r1, [r3, #0]
    if (isp->txcnt < isp->txsize) { /* Transfer not completed, there are more packets to send.*/
 8002294:	e9d0 0400 	ldrd	r0, r4, [r0]
    EPR_CLEAR_CTR_TX(ep);
 8002298:	4039      	ands	r1, r7
 800229a:	f441 4100 	orr.w	r1, r1, #32768	@ 0x8000
    if (isp->txcnt < isp->txsize) { /* Transfer not completed, there are more packets to send.*/
 800229e:	4284      	cmp	r4, r0
    EPR_CLEAR_CTR_TX(ep);
 80022a0:	6019      	str	r1, [r3, #0]
    if (isp->txcnt < isp->txsize) { /* Transfer not completed, there are more packets to send.*/
 80022a2:	d333      	bcc.n	800230c <Vector16C+0xc8>
      _usb_isr_invoke_in_cb(usbp, ep);
 80022a4:	f8bb 3008 	ldrh.w	r3, [fp, #8]
 80022a8:	68b4      	ldr	r4, [r6, #8]
 80022aa:	2101      	movs	r1, #1
 80022ac:	4091      	lsls	r1, r2
 80022ae:	ea23 0301 	bic.w	r3, r3, r1
 80022b2:	f8ab 3008 	strh.w	r3, [fp, #8]
 80022b6:	b114      	cbz	r4, 80022be <Vector16C+0x7a>
 80022b8:	4857      	ldr	r0, [pc, #348]	@ (8002418 <Vector16C+0x1d4>)
 80022ba:	4611      	mov	r1, r2
 80022bc:	47a0      	blx	r4
    istr = STM32_USB->ISTR;
 80022be:	f8da 4044 	ldr.w	r4, [sl, #68]	@ 0x44
  while ((istr & ISTR_CTR) != 0U) {
 80022c2:	0423      	lsls	r3, r4, #16
 80022c4:	d51d      	bpl.n	8002302 <Vector16C+0xbe>
  uint32_t ep = istr & ISTR_EP_ID_MASK;
 80022c6:	f004 020f 	and.w	r2, r4, #15
  uint32_t epr = STM32_USB->EPR[ep];
 80022ca:	0093      	lsls	r3, r2, #2
 80022cc:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80022d0:	f102 0c02 	add.w	ip, r2, #2
 80022d4:	f503 43b8 	add.w	r3, r3, #23552	@ 0x5c00
 80022d8:	eb0b 018c 	add.w	r1, fp, ip, lsl #2
  if ((istr & ISTR_DIR) == 0U) {
 80022dc:	06e4      	lsls	r4, r4, #27
  uint32_t epr = STM32_USB->EPR[ep];
 80022de:	681d      	ldr	r5, [r3, #0]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80022e0:	684e      	ldr	r6, [r1, #4]
  if ((istr & ISTR_DIR) == 0U) {
 80022e2:	d5d5      	bpl.n	8002290 <Vector16C+0x4c>
    EPR_CLEAR_CTR_RX(ep);
 80022e4:	6818      	ldr	r0, [r3, #0]
 80022e6:	4038      	ands	r0, r7
 80022e8:	f040 0080 	orr.w	r0, r0, #128	@ 0x80
 80022ec:	6018      	str	r0, [r3, #0]
    if (epr & EPR_SETUP) {
 80022ee:	0528      	lsls	r0, r5, #20
      usb_lld_start_in(usbp, ep);
 80022f0:	b2d1      	uxtb	r1, r2
    if (epr & EPR_SETUP) {
 80022f2:	d510      	bpl.n	8002316 <Vector16C+0xd2>
      _usb_isr_invoke_setup_cb(usbp, ep);
 80022f4:	6873      	ldr	r3, [r6, #4]
 80022f6:	4848      	ldr	r0, [pc, #288]	@ (8002418 <Vector16C+0x1d4>)
 80022f8:	4798      	blx	r3
    istr = STM32_USB->ISTR;
 80022fa:	f8da 4044 	ldr.w	r4, [sl, #68]	@ 0x44
  while ((istr & ISTR_CTR) != 0U) {
 80022fe:	0423      	lsls	r3, r4, #16
 8002300:	d4e1      	bmi.n	80022c6 <Vector16C+0x82>
}
 8002302:	b007      	add	sp, #28
 8002304:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8002308:	f7fe be14 	b.w	8000f34 <_port_irq_epilogue>
      usb_lld_start_in(usbp, ep);
 800230c:	4842      	ldr	r0, [pc, #264]	@ (8002418 <Vector16C+0x1d4>)
 800230e:	4611      	mov	r1, r2
 8002310:	f7ff ff56 	bl	80021c0 <usb_lld_start_in>
 8002314:	e7d3      	b.n	80022be <Vector16C+0x7a>
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8002316:	f8da 0050 	ldr.w	r0, [sl, #80]	@ 0x50
      USBOutEndpointState *osp = epcp->out_state;
 800231a:	f8d6 e018 	ldr.w	lr, [r6, #24]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800231e:	f100 4080 	add.w	r0, r0, #1073741824	@ 0x40000000
 8002322:	f500 40c0 	add.w	r0, r0, #24576	@ 0x6000
 8002326:	eb00 1002 	add.w	r0, r0, r2, lsl #4
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 800232a:	6884      	ldr	r4, [r0, #8]
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 800232c:	f8d0 800c 	ldr.w	r8, [r0, #12]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002330:	f104 5000 	add.w	r0, r4, #536870912	@ 0x20000000
 8002334:	f500 5040 	add.w	r0, r0, #12288	@ 0x3000
 8002338:	0044      	lsls	r4, r0, #1
      n = usb_packet_read_to_buffer(ep, &osp->rxbuf[osp->rxcnt]);
 800233a:	f8de 0004 	ldr.w	r0, [lr, #4]
 800233e:	9001      	str	r0, [sp, #4]
 8002340:	4605      	mov	r5, r0
 8002342:	f8de 0008 	ldr.w	r0, [lr, #8]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8002346:	9405      	str	r4, [sp, #20]
      n = usb_packet_read_to_buffer(ep, &osp->rxbuf[osp->rxcnt]);
 8002348:	4428      	add	r0, r5
 800234a:	9002      	str	r0, [sp, #8]
  for (i = 0; i < (n>>1); i++)
 800234c:	f3c8 0548 	ubfx	r5, r8, #1, #9
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8002350:	f3c8 0009 	ubfx	r0, r8, #0, #10
 8002354:	9003      	str	r0, [sp, #12]
  for (i = 0; i < (n>>1); i++)
 8002356:	b15d      	cbz	r5, 8002370 <Vector16C+0x12c>
 8002358:	9802      	ldr	r0, [sp, #8]
 800235a:	9204      	str	r2, [sp, #16]
 800235c:	3802      	subs	r0, #2
 800235e:	eb00 0945 	add.w	r9, r0, r5, lsl #1
    ((uint16_t *)buf)[i] = pmap[i];
 8002362:	f854 2b04 	ldr.w	r2, [r4], #4
 8002366:	f820 2f02 	strh.w	r2, [r0, #2]!
  for (i = 0; i < (n>>1); i++)
 800236a:	4581      	cmp	r9, r0
 800236c:	d1f9      	bne.n	8002362 <Vector16C+0x11e>
 800236e:	9a04      	ldr	r2, [sp, #16]
  if (n&1) buf[i*2] = (uint8_t)pmap[i];
 8002370:	f018 0f01 	tst.w	r8, #1
 8002374:	d008      	beq.n	8002388 <Vector16C+0x144>
 8002376:	9805      	ldr	r0, [sp, #20]
 8002378:	9c02      	ldr	r4, [sp, #8]
 800237a:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
 800237e:	f804 0015 	strb.w	r0, [r4, r5, lsl #1]
      osp->rxcnt += n;
 8002382:	f8de 0004 	ldr.w	r0, [lr, #4]
 8002386:	9001      	str	r0, [sp, #4]
 8002388:	9801      	ldr	r0, [sp, #4]
 800238a:	9d03      	ldr	r5, [sp, #12]
      if (osp->rxcnt >= osp->rxsize || n < epcp->out_maxsize) {
 800238c:	f8de 4000 	ldr.w	r4, [lr]
      osp->rxcnt += n;
 8002390:	4428      	add	r0, r5
      if (osp->rxcnt >= osp->rxsize || n < epcp->out_maxsize) {
 8002392:	42a0      	cmp	r0, r4
      osp->rxcnt += n;
 8002394:	f8ce 0004 	str.w	r0, [lr, #4]
      if (osp->rxcnt >= osp->rxsize || n < epcp->out_maxsize) {
 8002398:	d202      	bcs.n	80023a0 <Vector16C+0x15c>
 800239a:	8a70      	ldrh	r0, [r6, #18]
 800239c:	42a8      	cmp	r0, r5
 800239e:	d912      	bls.n	80023c6 <Vector16C+0x182>
        _usb_isr_invoke_out_cb(usbp, ep);
 80023a0:	eb0b 0c8c 	add.w	ip, fp, ip, lsl #2
 80023a4:	2001      	movs	r0, #1
 80023a6:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80023aa:	68dc      	ldr	r4, [r3, #12]
 80023ac:	f8bb 300a 	ldrh.w	r3, [fp, #10]
 80023b0:	4090      	lsls	r0, r2
 80023b2:	ea23 0300 	bic.w	r3, r3, r0
 80023b6:	f8ab 300a 	strh.w	r3, [fp, #10]
 80023ba:	2c00      	cmp	r4, #0
 80023bc:	f43f af7f 	beq.w	80022be <Vector16C+0x7a>
 80023c0:	4815      	ldr	r0, [pc, #84]	@ (8002418 <Vector16C+0x1d4>)
 80023c2:	47a0      	blx	r4
 80023c4:	e77b      	b.n	80022be <Vector16C+0x7a>
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 80023c6:	681a      	ldr	r2, [r3, #0]
 80023c8:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 80023cc:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 80023d0:	f482 5240 	eor.w	r2, r2, #12288	@ 0x3000
 80023d4:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80023d8:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 80023dc:	601a      	str	r2, [r3, #0]
 80023de:	e76e      	b.n	80022be <Vector16C+0x7a>
    _usb_reset(usbp);
 80023e0:	480d      	ldr	r0, [pc, #52]	@ (8002418 <Vector16C+0x1d4>)
 80023e2:	f7ff faf1 	bl	80019c8 <_usb_reset>
  if ((istr & ISTR_SUSP) != 0U) {
 80023e6:	0522      	lsls	r2, r4, #20
 80023e8:	f57f af39 	bpl.w	800225e <Vector16C+0x1a>
    STM32_USB->CNTR |= CNTR_FSUSP;
 80023ec:	4a08      	ldr	r2, [pc, #32]	@ (8002410 <Vector16C+0x1cc>)
    _usb_suspend(usbp);
 80023ee:	480a      	ldr	r0, [pc, #40]	@ (8002418 <Vector16C+0x1d4>)
    STM32_USB->CNTR |= CNTR_FSUSP;
 80023f0:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 80023f2:	f043 0308 	orr.w	r3, r3, #8
 80023f6:	6413      	str	r3, [r2, #64]	@ 0x40
    _usb_suspend(usbp);
 80023f8:	f7ff fb00 	bl	80019fc <_usb_suspend>
 80023fc:	e72f      	b.n	800225e <Vector16C+0x1a>
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 80023fe:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
      _usb_wakeup(usbp);
 8002400:	4805      	ldr	r0, [pc, #20]	@ (8002418 <Vector16C+0x1d4>)
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8002402:	f022 0208 	bic.w	r2, r2, #8
 8002406:	641a      	str	r2, [r3, #64]	@ 0x40
      _usb_wakeup(usbp);
 8002408:	f7ff fb00 	bl	8001a0c <_usb_wakeup>
 800240c:	e72e      	b.n	800226c <Vector16C+0x28>
 800240e:	bf00      	nop
 8002410:	40005c00 	.word	0x40005c00
 8002414:	ffff070f 	.word	0xffff070f
 8002418:	20000650 	.word	0x20000650

0800241c <usb_lld_stall_out>:
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 800241c:	4a07      	ldr	r2, [pc, #28]	@ (800243c <usb_lld_stall_out+0x20>)
 800241e:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8002422:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 8002426:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800242a:	f483 5380 	eor.w	r3, r3, #4096	@ 0x1000
 800242e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8002432:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002436:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 800243a:	4770      	bx	lr
 800243c:	40005c00 	.word	0x40005c00

08002440 <usb_lld_stall_in>:
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8002440:	4a07      	ldr	r2, [pc, #28]	@ (8002460 <usb_lld_stall_in+0x20>)
 8002442:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8002446:	f423 43f0 	bic.w	r3, r3, #30720	@ 0x7800
 800244a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800244e:	f083 0310 	eor.w	r3, r3, #16
 8002452:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8002456:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800245a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 800245e:	4770      	bx	lr
 8002460:	40005c00 	.word	0x40005c00

08002464 <usb_lld_clear_out>:
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
  (void)usbp;
  /* Makes sure to not put to NAK an endpoint that is already transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 8002464:	0089      	lsls	r1, r1, #2
 8002466:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 800246a:	f501 41b8 	add.w	r1, r1, #23552	@ 0x5c00
 800246e:	680b      	ldr	r3, [r1, #0]
 8002470:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 8002474:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8002478:	d00b      	beq.n	8002492 <usb_lld_clear_out+0x2e>
    EPR_SET_STAT_RX(ep, EPR_STAT_RX_NAK);
 800247a:	680b      	ldr	r3, [r1, #0]
 800247c:	f423 4390 	bic.w	r3, r3, #18432	@ 0x4800
 8002480:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8002484:	f483 5300 	eor.w	r3, r3, #8192	@ 0x2000
 8002488:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800248c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8002490:	600b      	str	r3, [r1, #0]
}
 8002492:	4770      	bx	lr

08002494 <usb_lld_clear_in>:
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
  (void)usbp;
  /* Makes sure to not put to NAK an endpoint that is already transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8002494:	0089      	lsls	r1, r1, #2
 8002496:	f101 4180 	add.w	r1, r1, #1073741824	@ 0x40000000
 800249a:	f501 41b8 	add.w	r1, r1, #23552	@ 0x5c00
 800249e:	680b      	ldr	r3, [r1, #0]
 80024a0:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 80024a4:	2b30      	cmp	r3, #48	@ 0x30
 80024a6:	d00b      	beq.n	80024c0 <usb_lld_clear_in+0x2c>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 80024a8:	680b      	ldr	r3, [r1, #0]
 80024aa:	f423 43f0 	bic.w	r3, r3, #30720	@ 0x7800
 80024ae:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80024b2:	f083 0320 	eor.w	r3, r3, #32
 80024b6:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80024ba:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80024be:	600b      	str	r3, [r1, #0]
}
 80024c0:	4770      	bx	lr
 80024c2:	bf00      	nop

080024c4 <boardDFUEnter>:
   VAL_GPIOI_ODR,   VAL_GPIOI_AFRL,   VAL_GPIOI_AFRH}
#endif
};
#endif

void boardDFUEnter(void) {
 80024c4:	b480      	push	{r7}
  __set_MSP(*((uint32_t *)(STM32F303xC_SYSTEM_MEMORY)));
 80024c6:	4b06      	ldr	r3, [pc, #24]	@ (80024e0 <boardDFUEnter+0x1c>)
void boardDFUEnter(void) {
 80024c8:	af00      	add	r7, sp, #0
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 80024ca:	f8d3 2800 	ldr.w	r2, [r3, #2048]	@ 0x800
 80024ce:	f382 8808 	msr	MSP, r2
  ((void (*)(void))(*((uint32_t *)(STM32F303xC_SYSTEM_MEMORY + 4))))(); // jump to DFU
 80024d2:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
}
 80024d6:	46bd      	mov	sp, r7
 80024d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  ((void (*)(void))(*((uint32_t *)(STM32F303xC_SYSTEM_MEMORY + 4))))(); // jump to DFU
 80024dc:	4718      	bx	r3
 80024de:	bf00      	nop
 80024e0:	1fffd000 	.word	0x1fffd000

080024e4 <__early_init>:
 * Early initialization code.
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {
  stm32_clock_init();
 80024e4:	f7ff bc54 	b.w	8001d90 <stm32_clock_init>

080024e8 <boardInit>:
/*
 * Board-specific initialization code.
 */
void boardInit(void) {
  // Speedup flash latency
  FLASH->ACR= FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY_0;
 80024e8:	4b01      	ldr	r3, [pc, #4]	@ (80024f0 <boardInit+0x8>)
 80024ea:	2211      	movs	r2, #17
 80024ec:	601a      	str	r2, [r3, #0]
}
 80024ee:	4770      	bx	lr
 80024f0:	40022000 	.word	0x40022000

080024f4 <long_to_string_with_divisor>:
#pragma pack(pop)

static char *long_to_string_with_divisor(char *p,
                                         longval_t num,
                                         uint32_t radix,
                                         int      precision) {
 80024f4:	b5f0      	push	{r4, r5, r6, r7, lr}
  char *q = p + MAX_FILLER;
  char *b = q;
  // convert to string from end buffer to begin
  do {
    uint8_t c = num % radix;
 80024f6:	fbb1 fef2 	udiv	lr, r1, r2
 80024fa:	fb02 141e 	mls	r4, r2, lr, r1
    num /= radix;
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 80024fe:	2c09      	cmp	r4, #9
 8002500:	bf8c      	ite	hi
 8002502:	2537      	movhi	r5, #55	@ 0x37
 8002504:	2530      	movls	r5, #48	@ 0x30
 8002506:	fa55 f484 	uxtab	r4, r5, r4
  char *q = p + MAX_FILLER;
 800250a:	f100 060b 	add.w	r6, r0, #11
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 800250e:	7284      	strb	r4, [r0, #10]
 8002510:	f100 0c0a 	add.w	ip, r0, #10
  }while((precision && --precision) || num);
 8002514:	b33b      	cbz	r3, 8002566 <long_to_string_with_divisor+0x72>
 8002516:	3b01      	subs	r3, #1
 8002518:	d025      	beq.n	8002566 <long_to_string_with_divisor+0x72>
    uint8_t c = num % radix;
 800251a:	fbbe f7f2 	udiv	r7, lr, r2
 800251e:	fb02 e517 	mls	r5, r2, r7, lr
 8002522:	b2ec      	uxtb	r4, r5
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 8002524:	2d09      	cmp	r5, #9
 8002526:	f104 0530 	add.w	r5, r4, #48	@ 0x30
 800252a:	f104 0437 	add.w	r4, r4, #55	@ 0x37
 800252e:	bf94      	ite	ls
 8002530:	f80c 5d01 	strbls.w	r5, [ip, #-1]!
 8002534:	f80c 4d01 	strbhi.w	r4, [ip, #-1]!
  }while((precision && --precision) || num);
 8002538:	3b01      	subs	r3, #1
    uint8_t c = num % radix;
 800253a:	4671      	mov	r1, lr
    num /= radix;
 800253c:	46be      	mov	lr, r7
  }while((precision && --precision) || num);
 800253e:	d1ec      	bne.n	800251a <long_to_string_with_divisor+0x26>
 8002540:	428a      	cmp	r2, r1
    uint8_t c = num % radix;
 8002542:	4671      	mov	r1, lr
  }while((precision && --precision) || num);
 8002544:	d812      	bhi.n	800256c <long_to_string_with_divisor+0x78>
    uint8_t c = num % radix;
 8002546:	fbbe f5f2 	udiv	r5, lr, r2
 800254a:	fb02 e415 	mls	r4, r2, r5, lr
 800254e:	b2e3      	uxtb	r3, r4
    *--q = c + ((c > 9) ? ('A'-10) : '0');
 8002550:	2c09      	cmp	r4, #9
 8002552:	f103 0437 	add.w	r4, r3, #55	@ 0x37
 8002556:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 800255a:	bf8c      	ite	hi
 800255c:	f80c 4d01 	strbhi.w	r4, [ip, #-1]!
 8002560:	f80c 3d01 	strbls.w	r3, [ip, #-1]!
    num /= radix;
 8002564:	46ae      	mov	lr, r5
  }while((precision && --precision) || num);
 8002566:	428a      	cmp	r2, r1
    uint8_t c = num % radix;
 8002568:	4671      	mov	r1, lr
  }while((precision && --precision) || num);
 800256a:	d9ec      	bls.n	8002546 <long_to_string_with_divisor+0x52>
  // copy string at begin
  int i = (int)(b - q);
 800256c:	1e43      	subs	r3, r0, #1
 800256e:	eba6 010c 	sub.w	r1, r6, ip
  do
    *p++ = *q++;
 8002572:	f81c 2b01 	ldrb.w	r2, [ip], #1
 8002576:	f803 2f01 	strb.w	r2, [r3, #1]!
  while (--i);
 800257a:	4566      	cmp	r6, ip
 800257c:	d1f9      	bne.n	8002572 <long_to_string_with_divisor+0x7e>
  return p;
}
 800257e:	4408      	add	r0, r1
 8002580:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002582:	bf00      	nop

08002584 <ftoa>:
}

#if CHPRINTF_USE_FLOAT
static char *ftoa(char *p, float num, int precision) {
  // Check precision limit
  if (precision > FLOAT_PRECISION)
 8002584:	2909      	cmp	r1, #9
static char *ftoa(char *p, float num, int precision) {
 8002586:	b570      	push	{r4, r5, r6, lr}
    precision = FLOAT_PRECISION;
  uint32_t multi = pow10[precision];
  uint32_t l = num;
 8002588:	eefc 7ac0 	vcvt.u32.f32	s15, s0
  if (precision > FLOAT_PRECISION)
 800258c:	460e      	mov	r6, r1
  uint32_t multi = pow10[precision];
 800258e:	4b1b      	ldr	r3, [pc, #108]	@ (80025fc <ftoa+0x78>)
  if (precision > FLOAT_PRECISION)
 8002590:	bfa8      	it	ge
 8002592:	2609      	movge	r6, #9
  // Round value
  uint32_t k = ((num-l)*multi+0.5);
 8002594:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  uint32_t multi = pow10[precision];
 8002598:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
  uint32_t k = ((num-l)*multi+0.5);
 800259c:	ee30 0a47 	vsub.f32	s0, s0, s14
 80025a0:	ee07 3a10 	vmov	s14, r3
 80025a4:	eef8 6a47 	vcvt.f32.u32	s13, s14
 80025a8:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 80025ac:	eea0 7a26 	vfma.f32	s14, s0, s13
static char *ftoa(char *p, float num, int precision) {
 80025b0:	460d      	mov	r5, r1
  uint32_t k = ((num-l)*multi+0.5);
 80025b2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 80025b6:	ee17 4a10 	vmov	r4, s14
  // Fix rounding error if get
  if (k>=multi){k-=multi;l++;}
 80025ba:	42a3      	cmp	r3, r4
 80025bc:	d805      	bhi.n	80025ca <ftoa+0x46>
 80025be:	1ae4      	subs	r4, r4, r3
 80025c0:	ee17 3a90 	vmov	r3, s15
 80025c4:	3301      	adds	r3, #1
 80025c6:	ee07 3a90 	vmov	s15, r3
  p = long_to_string_with_divisor(p, l, 10, 0);
 80025ca:	ee17 1a90 	vmov	r1, s15
 80025ce:	2300      	movs	r3, #0
 80025d0:	220a      	movs	r2, #10
 80025d2:	f7ff ff8f 	bl	80024f4 <long_to_string_with_divisor>
  if (precision) {
 80025d6:	b17d      	cbz	r5, 80025f8 <ftoa+0x74>
    *p++ = DIGIT_SEPARATOR;
 80025d8:	4a09      	ldr	r2, [pc, #36]	@ (8002600 <ftoa+0x7c>)
 80025da:	8a92      	ldrh	r2, [r2, #20]
 80025dc:	f012 0f80 	tst.w	r2, #128	@ 0x80
 80025e0:	bf0c      	ite	eq
 80025e2:	222e      	moveq	r2, #46	@ 0x2e
 80025e4:	222c      	movne	r2, #44	@ 0x2c
 80025e6:	f800 2b01 	strb.w	r2, [r0], #1
    p=long_to_string_with_divisor(p, k, 10, precision);
 80025ea:	4633      	mov	r3, r6
 80025ec:	4621      	mov	r1, r4
 80025ee:	220a      	movs	r2, #10
  }
  return p;
}
 80025f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    p=long_to_string_with_divisor(p, k, 10, precision);
 80025f4:	f7ff bf7e 	b.w	80024f4 <long_to_string_with_divisor>
}
 80025f8:	bd70      	pop	{r4, r5, r6, pc}
 80025fa:	bf00      	nop
 80025fc:	08014804 	.word	0x08014804
 8002600:	20000318 	.word	0x20000318

08002604 <put>:
  uint16_t size;
} printStream;

static msg_t put(void *ip, uint8_t b) {
  printStream *ps = ip;
  if (ps->size > 1){
 8002604:	8903      	ldrh	r3, [r0, #8]
 8002606:	2b01      	cmp	r3, #1
 8002608:	d906      	bls.n	8002618 <put+0x14>
   *(ps->buffer++) = b;
 800260a:	6843      	ldr	r3, [r0, #4]
 800260c:	1c5a      	adds	r2, r3, #1
 800260e:	6042      	str	r2, [r0, #4]
 8002610:	7019      	strb	r1, [r3, #0]
   ps->size--;
 8002612:	8903      	ldrh	r3, [r0, #8]
 8002614:	3b01      	subs	r3, #1
 8002616:	8103      	strh	r3, [r0, #8]
  }
  return MSG_OK;
}
 8002618:	2000      	movs	r0, #0
 800261a:	4770      	bx	lr

0800261c <chvprintf>:
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 800261c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002620:	ed2d 8b02 	vpush	{d8}
    c = *fmt++;
 8002624:	460c      	mov	r4, r1
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8002626:	b08b      	sub	sp, #44	@ 0x2c
    c = *fmt++;
 8002628:	f814 1b01 	ldrb.w	r1, [r4], #1
    if (c == 0)
 800262c:	2900      	cmp	r1, #0
 800262e:	f000 829c 	beq.w	8002b6a <chvprintf+0x54e>
 8002632:	4691      	mov	r9, r2
  int n = 0;
 8002634:	2300      	movs	r3, #0
  char *p, *s, c, filler=' ';
 8002636:	2220      	movs	r2, #32
 8002638:	4606      	mov	r6, r0
 800263a:	4693      	mov	fp, r2
 800263c:	469a      	mov	sl, r3
 800263e:	e00a      	b.n	8002656 <chvprintf+0x3a>
      streamPut(chp, (uint8_t)c);
 8002640:	6833      	ldr	r3, [r6, #0]
 8002642:	4630      	mov	r0, r6
 8002644:	689b      	ldr	r3, [r3, #8]
 8002646:	4798      	blx	r3
      n++;
 8002648:	f10a 0a01 	add.w	sl, sl, #1
    c = *fmt++;
 800264c:	f814 1b01 	ldrb.w	r1, [r4], #1
    if (c == 0)
 8002650:	2900      	cmp	r1, #0
 8002652:	f000 8089 	beq.w	8002768 <chvprintf+0x14c>
    if (c != '%') {
 8002656:	2925      	cmp	r1, #37	@ 0x25
 8002658:	d1f2      	bne.n	8002640 <chvprintf+0x24>
 800265a:	4623      	mov	r3, r4
    state = 0;
 800265c:	f04f 0800 	mov.w	r8, #0
 8002660:	461c      	mov	r4, r3
      if (*fmt == '-')
 8002662:	f813 2b01 	ldrb.w	r2, [r3], #1
 8002666:	2a30      	cmp	r2, #48	@ 0x30
 8002668:	d86b      	bhi.n	8002742 <chvprintf+0x126>
 800266a:	2a1f      	cmp	r2, #31
 800266c:	d90d      	bls.n	800268a <chvprintf+0x6e>
 800266e:	3a20      	subs	r2, #32
 8002670:	2a10      	cmp	r2, #16
 8002672:	d80a      	bhi.n	800268a <chvprintf+0x6e>
 8002674:	e8df f002 	tbb	[pc, r2]
 8002678:	09090972 	.word	0x09090972
 800267c:	09090909 	.word	0x09090909
 8002680:	6f090909 	.word	0x6f090909
 8002684:	09096c09 	.word	0x09096c09
 8002688:	5e          	.byte	0x5e
 8002689:	00          	.byte	0x00
 800268a:	2500      	movs	r5, #0
 800268c:	e005      	b.n	800269a <chvprintf+0x7e>
        c = va_arg(ap, int);
 800268e:	f851 2b04 	ldr.w	r2, [r1], #4
 8002692:	b2d2      	uxtb	r2, r2
 8002694:	4689      	mov	r9, r1
      width = width * 10 + c;
 8002696:	eb02 0540 	add.w	r5, r2, r0, lsl #1
      c = *fmt++;
 800269a:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c >= '0' && c <= '9')
 800269e:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80026a2:	b2d2      	uxtb	r2, r2
 80026a4:	2a09      	cmp	r2, #9
        c = va_arg(ap, int);
 80026a6:	4649      	mov	r1, r9
      width = width * 10 + c;
 80026a8:	eb05 0085 	add.w	r0, r5, r5, lsl #2
      if (c >= '0' && c <= '9')
 80026ac:	d9f3      	bls.n	8002696 <chvprintf+0x7a>
      else if (c == '*')
 80026ae:	2b2a      	cmp	r3, #42	@ 0x2a
 80026b0:	d0ed      	beq.n	800268e <chvprintf+0x72>
    if (c == '.') {
 80026b2:	2b2e      	cmp	r3, #46	@ 0x2e
 80026b4:	f000 8172 	beq.w	800299c <chvprintf+0x380>
      state|=DEFAULT_PRESCISION;
 80026b8:	f048 0840 	orr.w	r8, r8, #64	@ 0x40
    precision = 0;
 80026bc:	2700      	movs	r7, #0
    switch (c) {
 80026be:	f1a3 0244 	sub.w	r2, r3, #68	@ 0x44
 80026c2:	2a34      	cmp	r2, #52	@ 0x34
 80026c4:	d857      	bhi.n	8002776 <chvprintf+0x15a>
 80026c6:	e8df f012 	tbh	[pc, r2, lsl #1]
 80026ca:	0092      	.short	0x0092
 80026cc:	00a10056 	.word	0x00a10056
 80026d0:	00560056 	.word	0x00560056
 80026d4:	00560092 	.word	0x00560092
 80026d8:	00560056 	.word	0x00560056
 80026dc:	00560056 	.word	0x00560056
 80026e0:	00560187 	.word	0x00560187
 80026e4:	00560056 	.word	0x00560056
 80026e8:	00560056 	.word	0x00560056
 80026ec:	005600c1 	.word	0x005600c1
 80026f0:	01850056 	.word	0x01850056
 80026f4:	00560056 	.word	0x00560056
 80026f8:	00560056 	.word	0x00560056
 80026fc:	00560056 	.word	0x00560056
 8002700:	00560056 	.word	0x00560056
 8002704:	00560056 	.word	0x00560056
 8002708:	009200d8 	.word	0x009200d8
 800270c:	00a10056 	.word	0x00a10056
 8002710:	00560056 	.word	0x00560056
 8002714:	00560092 	.word	0x00560092
 8002718:	00560056 	.word	0x00560056
 800271c:	00560056 	.word	0x00560056
 8002720:	00560187 	.word	0x00560187
 8002724:	00560124 	.word	0x00560124
 8002728:	005600e9 	.word	0x005600e9
 800272c:	005600c1 	.word	0x005600c1
 8002730:	01850056 	.word	0x01850056
        state|=PAD_ZERO;
 8002734:	461c      	mov	r4, r3
      if (*fmt == '-')
 8002736:	f813 2b01 	ldrb.w	r2, [r3], #1
 800273a:	2a30      	cmp	r2, #48	@ 0x30
        state|=PAD_ZERO;
 800273c:	f048 0810 	orr.w	r8, r8, #16
      if (*fmt == '-')
 8002740:	d993      	bls.n	800266a <chvprintf+0x4e>
 8002742:	2a62      	cmp	r2, #98	@ 0x62
 8002744:	d00d      	beq.n	8002762 <chvprintf+0x146>
 8002746:	2a6a      	cmp	r2, #106	@ 0x6a
 8002748:	d19f      	bne.n	800268a <chvprintf+0x6e>
        state|=COMPLEX;
 800274a:	f048 0880 	orr.w	r8, r8, #128	@ 0x80
 800274e:	e787      	b.n	8002660 <chvprintf+0x44>
        state|=LEFT_ALIGN;
 8002750:	f048 0802 	orr.w	r8, r8, #2
 8002754:	e784      	b.n	8002660 <chvprintf+0x44>
        state|=POSITIVE;
 8002756:	f048 0804 	orr.w	r8, r8, #4
 800275a:	e781      	b.n	8002660 <chvprintf+0x44>
        state|=PLUS_SPACE;
 800275c:	f048 0820 	orr.w	r8, r8, #32
 8002760:	e77e      	b.n	8002660 <chvprintf+0x44>
        state|=SHORT_FLOAT;
 8002762:	f448 7880 	orr.w	r8, r8, #256	@ 0x100
      if (*fmt == '-')
 8002766:	e77b      	b.n	8002660 <chvprintf+0x44>
 8002768:	4653      	mov	r3, sl
}
 800276a:	4618      	mov	r0, r3
 800276c:	b00b      	add	sp, #44	@ 0x2c
 800276e:	ecbd 8b02 	vpop	{d8}
 8002772:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *p++ = c;
 8002776:	f88d 3010 	strb.w	r3, [sp, #16]
 800277a:	f10d 0711 	add.w	r7, sp, #17
      break;
 800277e:	2301      	movs	r3, #1
    if ((width -=(int)(p - s)) < 0)
 8002780:	1aeb      	subs	r3, r5, r3
 8002782:	d470      	bmi.n	8002866 <chvprintf+0x24a>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002784:	f018 0f10 	tst.w	r8, #16
 8002788:	f000 811d 	beq.w	80029c6 <chvprintf+0x3aa>
    if (!(state&LEFT_ALIGN)) {
 800278c:	f018 0f02 	tst.w	r8, #2
 8002790:	f000 81cd 	beq.w	8002b2e <chvprintf+0x512>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002794:	f04f 0b30 	mov.w	fp, #48	@ 0x30
    if (!(state&LEFT_ALIGN)) {
 8002798:	a904      	add	r1, sp, #16
    while (s < p) {
 800279a:	42b9      	cmp	r1, r7
 800279c:	d219      	bcs.n	80027d2 <chvprintf+0x1b6>
    s = tmpbuf;
 800279e:	9401      	str	r4, [sp, #4]
 80027a0:	460d      	mov	r5, r1
 80027a2:	4634      	mov	r4, r6
 80027a4:	4688      	mov	r8, r1
 80027a6:	461e      	mov	r6, r3
      streamPut(chp, (uint8_t)*s++);
 80027a8:	6822      	ldr	r2, [r4, #0]
 80027aa:	f815 1b01 	ldrb.w	r1, [r5], #1
 80027ae:	6892      	ldr	r2, [r2, #8]
 80027b0:	4620      	mov	r0, r4
 80027b2:	4790      	blx	r2
    while (s < p) {
 80027b4:	42bd      	cmp	r5, r7
 80027b6:	d3f7      	bcc.n	80027a8 <chvprintf+0x18c>
 80027b8:	4633      	mov	r3, r6
 80027ba:	4626      	mov	r6, r4
 80027bc:	9c01      	ldr	r4, [sp, #4]
 80027be:	4641      	mov	r1, r8
 80027c0:	1e7a      	subs	r2, r7, #1
 80027c2:	1a52      	subs	r2, r2, r1
 80027c4:	3101      	adds	r1, #1
 80027c6:	428f      	cmp	r7, r1
 80027c8:	bf38      	it	cc
 80027ca:	2200      	movcc	r2, #0
 80027cc:	f10a 0a01 	add.w	sl, sl, #1
 80027d0:	4492      	add	sl, r2
    while (width) {
 80027d2:	2b00      	cmp	r3, #0
 80027d4:	f43f af3a 	beq.w	800264c <chvprintf+0x30>
 80027d8:	461d      	mov	r5, r3
 80027da:	461f      	mov	r7, r3
      streamPut(chp, (uint8_t)filler);
 80027dc:	6833      	ldr	r3, [r6, #0]
 80027de:	4659      	mov	r1, fp
 80027e0:	689b      	ldr	r3, [r3, #8]
 80027e2:	4630      	mov	r0, r6
 80027e4:	4798      	blx	r3
    while (width) {
 80027e6:	3d01      	subs	r5, #1
 80027e8:	d1f8      	bne.n	80027dc <chvprintf+0x1c0>
 80027ea:	44ba      	add	sl, r7
 80027ec:	e72e      	b.n	800264c <chvprintf+0x30>
        value.l = va_arg(ap, int32_t);
 80027ee:	f859 1b04 	ldr.w	r1, [r9], #4
      if (value.l < 0) {
 80027f2:	2900      	cmp	r1, #0
 80027f4:	f2c0 8134 	blt.w	8002a60 <chvprintf+0x444>
      else if (state & POSITIVE)
 80027f8:	f018 0f04 	tst.w	r8, #4
 80027fc:	f040 81d9 	bne.w	8002bb2 <chvprintf+0x596>
      else if (state & PLUS_SPACE)
 8002800:	f018 0f20 	tst.w	r8, #32
 8002804:	f000 81ec 	beq.w	8002be0 <chvprintf+0x5c4>
 8002808:	2320      	movs	r3, #32
 800280a:	e1d3      	b.n	8002bb4 <chvprintf+0x598>
      if (state & SHORT_FLOAT)
 800280c:	f418 7f80 	tst.w	r8, #256	@ 0x100
 8002810:	f040 80e4 	bne.w	80029dc <chvprintf+0x3c0>
        value.f = va_arg(ap, double);
 8002814:	f109 0907 	add.w	r9, r9, #7
 8002818:	f029 0907 	bic.w	r9, r9, #7
 800281c:	e8f9 0102 	ldrd	r0, r1, [r9], #8
 8002820:	9301      	str	r3, [sp, #4]
 8002822:	f7fd ff15 	bl	8000650 <__aeabi_d2f>
 8002826:	ee08 0a10 	vmov	s16, r0
      if (value.f < 0) {
 800282a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800282e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        value.f = va_arg(ap, double);
 8002832:	9b01      	ldr	r3, [sp, #4]
      if (value.f < 0) {
 8002834:	f100 80da 	bmi.w	80029ec <chvprintf+0x3d0>
      else if (state & POSITIVE)
 8002838:	f018 0f04 	tst.w	r8, #4
 800283c:	f040 81c1 	bne.w	8002bc2 <chvprintf+0x5a6>
      else if (state & PLUS_SPACE)
 8002840:	f018 0f20 	tst.w	r8, #32
 8002844:	f000 81c9 	beq.w	8002bda <chvprintf+0x5be>
 8002848:	2220      	movs	r2, #32
 800284a:	e1bb      	b.n	8002bc4 <chvprintf+0x5a8>
      goto unsigned_common;
 800284c:	220a      	movs	r2, #10
      p = long_to_string_with_divisor(p, value.u, c, 0);
 800284e:	a804      	add	r0, sp, #16
 8002850:	2300      	movs	r3, #0
 8002852:	f859 1b04 	ldr.w	r1, [r9], #4
 8002856:	9001      	str	r0, [sp, #4]
 8002858:	f7ff fe4c 	bl	80024f4 <long_to_string_with_divisor>
    if ((width -=(int)(p - s)) < 0)
 800285c:	9b01      	ldr	r3, [sp, #4]
 800285e:	1ac3      	subs	r3, r0, r3
 8002860:	1aeb      	subs	r3, r5, r3
      p = long_to_string_with_divisor(p, value.u, c, 0);
 8002862:	4607      	mov	r7, r0
    if ((width -=(int)(p - s)) < 0)
 8002864:	d58e      	bpl.n	8002784 <chvprintf+0x168>
    if (!(state&LEFT_ALIGN)) {
 8002866:	f018 0302 	ands.w	r3, r8, #2
 800286a:	f000 8168 	beq.w	8002b3e <chvprintf+0x522>
 800286e:	a904      	add	r1, sp, #16
    while (s < p) {
 8002870:	428f      	cmp	r7, r1
 8002872:	bf88      	it	hi
 8002874:	2300      	movhi	r3, #0
 8002876:	d892      	bhi.n	800279e <chvprintf+0x182>
 8002878:	e6e8      	b.n	800264c <chvprintf+0x30>
      *p++ = va_arg(ap, int);
 800287a:	f859 3b04 	ldr.w	r3, [r9], #4
 800287e:	f88d 3010 	strb.w	r3, [sp, #16]
    if ((width -=(int)(p - s)) < 0)
 8002882:	1e6b      	subs	r3, r5, #1
 8002884:	f100 80dc 	bmi.w	8002a40 <chvprintf+0x424>
    if (!(state&LEFT_ALIGN)) {
 8002888:	f018 0f02 	tst.w	r8, #2
 800288c:	f000 8207 	beq.w	8002c9e <chvprintf+0x682>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002890:	f04f 0b20 	mov.w	fp, #32
      *p++ = va_arg(ap, int);
 8002894:	f10d 0711 	add.w	r7, sp, #17
    s = tmpbuf;
 8002898:	a904      	add	r1, sp, #16
 800289a:	e780      	b.n	800279e <chvprintf+0x182>
      if ((s = va_arg(ap, char *)) == 0)
 800289c:	f859 1b04 	ldr.w	r1, [r9], #4
 80028a0:	2900      	cmp	r1, #0
 80028a2:	f000 80f5 	beq.w	8002a90 <chvprintf+0x474>
      for (p = s; *p && (--precision >= 0); p++)
 80028a6:	780b      	ldrb	r3, [r1, #0]
        precision = 32767;
 80028a8:	f018 0f40 	tst.w	r8, #64	@ 0x40
 80028ac:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 80028b0:	bf18      	it	ne
 80028b2:	4617      	movne	r7, r2
      for (p = s; *p && (--precision >= 0); p++)
 80028b4:	2b00      	cmp	r3, #0
 80028b6:	f000 8223 	beq.w	8002d00 <chvprintf+0x6e4>
 80028ba:	1e4a      	subs	r2, r1, #1
 80028bc:	443a      	add	r2, r7
        s = (char*)"(null)";
 80028be:	460f      	mov	r7, r1
 80028c0:	e002      	b.n	80028c8 <chvprintf+0x2ac>
      for (p = s; *p && (--precision >= 0); p++)
 80028c2:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 80028c6:	b113      	cbz	r3, 80028ce <chvprintf+0x2b2>
 80028c8:	1bd3      	subs	r3, r2, r7
 80028ca:	2b00      	cmp	r3, #0
 80028cc:	daf9      	bge.n	80028c2 <chvprintf+0x2a6>
    if ((width -=(int)(p - s)) < 0)
 80028ce:	1a7b      	subs	r3, r7, r1
 80028d0:	1aeb      	subs	r3, r5, r3
 80028d2:	d4cd      	bmi.n	8002870 <chvprintf+0x254>
      state&=~PAD_ZERO;
 80028d4:	f028 0810 	bic.w	r8, r8, #16
    if (!(state&LEFT_ALIGN)) {
 80028d8:	f018 0f02 	tst.w	r8, #2
 80028dc:	d177      	bne.n	80029ce <chvprintf+0x3b2>
    if ((width -=(int)(p - s)) < 0)
 80028de:	461d      	mov	r5, r3
      filler = (state&PAD_ZERO) ? '0' : ' ';
 80028e0:	f04f 0b20 	mov.w	fp, #32
      while (width){
 80028e4:	2b00      	cmp	r3, #0
 80028e6:	d0c3      	beq.n	8002870 <chvprintf+0x254>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 80028e8:	9401      	str	r4, [sp, #4]
 80028ea:	46a8      	mov	r8, r5
 80028ec:	4634      	mov	r4, r6
 80028ee:	460e      	mov	r6, r1
        streamPut(chp, (uint8_t)filler);
 80028f0:	6822      	ldr	r2, [r4, #0]
 80028f2:	4659      	mov	r1, fp
 80028f4:	6892      	ldr	r2, [r2, #8]
 80028f6:	4620      	mov	r0, r4
 80028f8:	4790      	blx	r2
      while (width){
 80028fa:	f1b8 0801 	subs.w	r8, r8, #1
 80028fe:	d1f7      	bne.n	80028f0 <chvprintf+0x2d4>
 8002900:	4631      	mov	r1, r6
    while (s < p) {
 8002902:	42b9      	cmp	r1, r7
 8002904:	4626      	mov	r6, r4
 8002906:	4643      	mov	r3, r8
 8002908:	9c01      	ldr	r4, [sp, #4]
 800290a:	44aa      	add	sl, r5
 800290c:	f4ff af47 	bcc.w	800279e <chvprintf+0x182>
 8002910:	e69c      	b.n	800264c <chvprintf+0x30>
      p=ulong_freq(p, va_arg(ap, pfreq_t), precision);
 8002912:	4649      	mov	r1, r9
 8002914:	f851 2b04 	ldr.w	r2, [r1], #4
  if (precision == 0)
 8002918:	2f00      	cmp	r7, #0
 800291a:	f000 808c 	beq.w	8002a36 <chvprintf+0x41a>
  if (precision == 0 || precision > MAX_FREQ_PRESCISION)
 800291e:	2f0e      	cmp	r7, #14
 8002920:	bfa8      	it	ge
 8002922:	270e      	movge	r7, #14
 8002924:	46b9      	mov	r9, r7
  uint8_t flag = FREQ_PSET;
 8002926:	f04f 0c01 	mov.w	ip, #1
    freq/= 10;
 800292a:	4baf      	ldr	r3, [pc, #700]	@ (8002be8 <chvprintf+0x5cc>)
 800292c:	fba3 3002 	umull	r3, r0, r3, r2
 8002930:	08c0      	lsrs	r0, r0, #3
    uint32_t c = freq % 10;
 8002932:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 8002936:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
    *--q = c + '0';
 800293a:	3330      	adds	r3, #48	@ 0x30
 800293c:	b2db      	uxtb	r3, r3
    if (freq == 0) break;
 800293e:	2a09      	cmp	r2, #9
    *--q = c + '0';
 8002940:	f88d 301d 	strb.w	r3, [sp, #29]
    if (freq == 0) break;
 8002944:	f240 81c7 	bls.w	8002cd6 <chvprintf+0x6ba>
  uint32_t s = 0;
 8002948:	2300      	movs	r3, #0
 800294a:	e9cd 4501 	strd	r4, r5, [sp, #4]
  uint32_t format = 0b100100100100100;
 800294e:	f644 1e24 	movw	lr, #18724	@ 0x4924
    *--q = c + '0';
 8002952:	f10d 021d 	add.w	r2, sp, #29
  char *q = p + MAX_FREQ_PRESCISION;
 8002956:	f10d 071e 	add.w	r7, sp, #30
 800295a:	461d      	mov	r5, r3
 800295c:	e019      	b.n	8002992 <chvprintf+0x376>
      *--q = ' ';
 800295e:	f04f 0320 	mov.w	r3, #32
 8002962:	f807 3c02 	strb.w	r3, [r7, #-2]
      s++;
 8002966:	3501      	adds	r5, #1
      *--q = ' ';
 8002968:	3f02      	subs	r7, #2
    freq/= 10;
 800296a:	4b9f      	ldr	r3, [pc, #636]	@ (8002be8 <chvprintf+0x5cc>)
 800296c:	fba3 3400 	umull	r3, r4, r3, r0
 8002970:	08e4      	lsrs	r4, r4, #3
    uint32_t c = freq % 10;
 8002972:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 8002976:	eba0 0343 	sub.w	r3, r0, r3, lsl #1
    *--q = c + '0';
 800297a:	3330      	adds	r3, #48	@ 0x30
 800297c:	b2db      	uxtb	r3, r3
    if (freq == 0) break;
 800297e:	2809      	cmp	r0, #9
    *--q = c + '0';
 8002980:	f807 3c01 	strb.w	r3, [r7, #-1]
    format >>= 1;
 8002984:	ea4f 0e5e 	mov.w	lr, lr, lsr #1
    *--q = c + '0';
 8002988:	f107 32ff 	add.w	r2, r7, #4294967295
    if (freq == 0) break;
 800298c:	f240 8088 	bls.w	8002aa0 <chvprintf+0x484>
 8002990:	4620      	mov	r0, r4
    if (format & 1) {
 8002992:	f01e 0f01 	tst.w	lr, #1
 8002996:	d1e2      	bne.n	800295e <chvprintf+0x342>
    *--q = c + '0';
 8002998:	4617      	mov	r7, r2
 800299a:	e7e6      	b.n	800296a <chvprintf+0x34e>
    precision = 0;
 800299c:	2700      	movs	r7, #0
 800299e:	e005      	b.n	80029ac <chvprintf+0x390>
          c = va_arg(ap, int);
 80029a0:	f851 2b04 	ldr.w	r2, [r1], #4
 80029a4:	b2d2      	uxtb	r2, r2
 80029a6:	4689      	mov	r9, r1
        precision = precision * 10 + c;
 80029a8:	eb02 0740 	add.w	r7, r2, r0, lsl #1
        c = *fmt++;
 80029ac:	f814 3b01 	ldrb.w	r3, [r4], #1
        if (c >= '0' && c <= '9')
 80029b0:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80029b4:	b2d2      	uxtb	r2, r2
 80029b6:	2a09      	cmp	r2, #9
          c = va_arg(ap, int);
 80029b8:	4649      	mov	r1, r9
        precision = precision * 10 + c;
 80029ba:	eb07 0087 	add.w	r0, r7, r7, lsl #2
        if (c >= '0' && c <= '9')
 80029be:	d9f3      	bls.n	80029a8 <chvprintf+0x38c>
        else if (c == '*')
 80029c0:	2b2a      	cmp	r3, #42	@ 0x2a
 80029c2:	d0ed      	beq.n	80029a0 <chvprintf+0x384>
 80029c4:	e67b      	b.n	80026be <chvprintf+0xa2>
 80029c6:	a904      	add	r1, sp, #16
    if (!(state&LEFT_ALIGN)) {
 80029c8:	f018 0f02 	tst.w	r8, #2
 80029cc:	d087      	beq.n	80028de <chvprintf+0x2c2>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 80029ce:	f04f 0b20 	mov.w	fp, #32
 80029d2:	e6e2      	b.n	800279a <chvprintf+0x17e>
    switch (c) {
 80029d4:	2210      	movs	r2, #16
 80029d6:	e73a      	b.n	800284e <chvprintf+0x232>
 80029d8:	2208      	movs	r2, #8
 80029da:	e738      	b.n	800284e <chvprintf+0x232>
      if (value.f < 0) {
 80029dc:	ecb9 8a01 	vldmia	r9!, {s16}
 80029e0:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80029e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80029e8:	f57f af26 	bpl.w	8002838 <chvprintf+0x21c>
        *p++ = '-';
 80029ec:	222d      	movs	r2, #45	@ 0x2d
 80029ee:	f88d 2010 	strb.w	r2, [sp, #16]
 80029f2:	aa04      	add	r2, sp, #16
        state|=NEGATIVE;
 80029f4:	f048 0808 	orr.w	r8, r8, #8
        value.f = -value.f;
 80029f8:	eeb1 8a48 	vneg.f32	s16, s16
        *p++ = '-';
 80029fc:	f10d 0011 	add.w	r0, sp, #17
 8002a00:	9201      	str	r2, [sp, #4]
      if (state & COMPLEX)
 8002a02:	f018 0f80 	tst.w	r8, #128	@ 0x80
        *p++ = 'j';
 8002a06:	bf1c      	itt	ne
 8002a08:	226a      	movne	r2, #106	@ 0x6a
 8002a0a:	f800 2b01 	strbne.w	r2, [r0], #1
 8002a0e:	e9cd 0302 	strd	r0, r3, [sp, #8]
      if (value.f == infinityf()){
 8002a12:	f00f fd4b 	bl	80124ac <infinityf>
 8002a16:	eeb4 0a48 	vcmp.f32	s0, s16
 8002a1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002a1e:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
 8002a22:	f040 80a9 	bne.w	8002b78 <chvprintf+0x55c>
        *p++ = S_INFINITY[0]; *p++ = ' ';
 8002a26:	4607      	mov	r7, r0
 8002a28:	f242 0319 	movw	r3, #8217	@ 0x2019
 8002a2c:	f827 3b02 	strh.w	r3, [r7], #2
    if ((width -=(int)(p - s)) < 0)
 8002a30:	9b01      	ldr	r3, [sp, #4]
 8002a32:	1afb      	subs	r3, r7, r3
        break;
 8002a34:	e6a4      	b.n	8002780 <chvprintf+0x164>
    flag|=FREQ_PREFIX_SPACE;
 8002a36:	f04f 0c03 	mov.w	ip, #3
    precision = MAX_FREQ_PRESCISION;
 8002a3a:	f04f 090e 	mov.w	r9, #14
 8002a3e:	e774      	b.n	800292a <chvprintf+0x30e>
    if (!(state&LEFT_ALIGN)) {
 8002a40:	f018 0302 	ands.w	r3, r8, #2
 8002a44:	f000 8143 	beq.w	8002cce <chvprintf+0x6b2>
      streamPut(chp, (uint8_t)*s++);
 8002a48:	6833      	ldr	r3, [r6, #0]
 8002a4a:	f89d 1010 	ldrb.w	r1, [sp, #16]
 8002a4e:	689b      	ldr	r3, [r3, #8]
 8002a50:	4630      	mov	r0, r6
 8002a52:	ad04      	add	r5, sp, #16
 8002a54:	4798      	blx	r3
      *p++ = va_arg(ap, int);
 8002a56:	f10d 0711 	add.w	r7, sp, #17
    s = tmpbuf;
 8002a5a:	4629      	mov	r1, r5
      streamPut(chp, (uint8_t)*s++);
 8002a5c:	2300      	movs	r3, #0
 8002a5e:	e6af      	b.n	80027c0 <chvprintf+0x1a4>
        *p++ = '-';
 8002a60:	232d      	movs	r3, #45	@ 0x2d
 8002a62:	f88d 3010 	strb.w	r3, [sp, #16]
 8002a66:	ab04      	add	r3, sp, #16
        state|=NEGATIVE;
 8002a68:	f048 0808 	orr.w	r8, r8, #8
        value.l = -value.l;
 8002a6c:	4249      	negs	r1, r1
        *p++ = '-';
 8002a6e:	f10d 0011 	add.w	r0, sp, #17
 8002a72:	9301      	str	r3, [sp, #4]
      if (state & COMPLEX)
 8002a74:	f018 0f80 	tst.w	r8, #128	@ 0x80
        *p++ = 'j';
 8002a78:	bf1c      	itt	ne
 8002a7a:	236a      	movne	r3, #106	@ 0x6a
 8002a7c:	f800 3b01 	strbne.w	r3, [r0], #1
      p = long_to_string_with_divisor(p, value.l, 10, 0);
 8002a80:	220a      	movs	r2, #10
 8002a82:	2300      	movs	r3, #0
 8002a84:	f7ff fd36 	bl	80024f4 <long_to_string_with_divisor>
    if ((width -=(int)(p - s)) < 0)
 8002a88:	9b01      	ldr	r3, [sp, #4]
      p = long_to_string_with_divisor(p, value.l, 10, 0);
 8002a8a:	4607      	mov	r7, r0
    if ((width -=(int)(p - s)) < 0)
 8002a8c:	1ac3      	subs	r3, r0, r3
      break;
 8002a8e:	e677      	b.n	8002780 <chvprintf+0x164>
      if (state&DEFAULT_PRESCISION)
 8002a90:	f018 0f40 	tst.w	r8, #64	@ 0x40
        s = (char*)"(null)";
 8002a94:	4955      	ldr	r1, [pc, #340]	@ (8002bec <chvprintf+0x5d0>)
      if (state&DEFAULT_PRESCISION)
 8002a96:	f43f af10 	beq.w	80028ba <chvprintf+0x29e>
        precision = 32767;
 8002a9a:	f647 77ff 	movw	r7, #32767	@ 0x7fff
 8002a9e:	e70c      	b.n	80028ba <chvprintf+0x29e>
  int i = (b - q);
 8002aa0:	f10d 001e 	add.w	r0, sp, #30
 8002aa4:	462f      	mov	r7, r5
 8002aa6:	eba0 0e02 	sub.w	lr, r0, r2
  s = bigPrefix[s];
 8002aaa:	4851      	ldr	r0, [pc, #324]	@ (8002bf0 <chvprintf+0x5d4>)
  int i = (b - q);
 8002aac:	9c01      	ldr	r4, [sp, #4]
 8002aae:	9d02      	ldr	r5, [sp, #8]
  s = bigPrefix[s];
 8002ab0:	5dc0      	ldrb	r0, [r0, r7]
    *--q = c + '0';
 8002ab2:	af04      	add	r7, sp, #16
 8002ab4:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8002ab8:	9701      	str	r7, [sp, #4]
  } while (--i);
 8002aba:	44be      	add	lr, r7
 8002abc:	e006      	b.n	8002acc <chvprintf+0x4b0>
    if (!(flag & FREQ_PSET) && precision-- < 0) break;
 8002abe:	462a      	mov	r2, r5
 8002ac0:	b17c      	cbz	r4, 8002ae2 <chvprintf+0x4c6>
    *p++ = c;
 8002ac2:	f807 3b01 	strb.w	r3, [r7], #1
  } while (--i);
 8002ac6:	4577      	cmp	r7, lr
 8002ac8:	d015      	beq.n	8002af6 <chvprintf+0x4da>
    char c = *q++;
 8002aca:	7813      	ldrb	r3, [r2, #0]
    if (c == ' ') {
 8002acc:	2b20      	cmp	r3, #32
    char c = *q++;
 8002ace:	f102 0501 	add.w	r5, r2, #1
    if (c == ' ') {
 8002ad2:	f00c 0401 	and.w	r4, ip, #1
 8002ad6:	d1f2      	bne.n	8002abe <chvprintf+0x4a2>
      if (flag & FREQ_PSET) {
 8002ad8:	b1fc      	cbz	r4, 8002b1a <chvprintf+0x4fe>
        flag &= ~FREQ_PSET;
 8002ada:	f00c 0cfe 	and.w	ip, ip, #254	@ 0xfe
    char c = *q++;
 8002ade:	462a      	mov	r2, r5
        c = '.';
 8002ae0:	232e      	movs	r3, #46	@ 0x2e
    if (!(flag & FREQ_PSET) && precision-- < 0) break;
 8002ae2:	f1b9 0f00 	cmp.w	r9, #0
 8002ae6:	f109 34ff 	add.w	r4, r9, #4294967295
 8002aea:	db5c      	blt.n	8002ba6 <chvprintf+0x58a>
    *p++ = c;
 8002aec:	f807 3b01 	strb.w	r3, [r7], #1
  } while (--i);
 8002af0:	4577      	cmp	r7, lr
    if (!(flag & FREQ_PSET) && precision-- < 0) break;
 8002af2:	46a1      	mov	r9, r4
  } while (--i);
 8002af4:	d1e9      	bne.n	8002aca <chvprintf+0x4ae>
 8002af6:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8002afa:	f00c 0c02 	and.w	ip, ip, #2
  if ((flag & FREQ_PREFIX_SPACE) && s != ' ')
 8002afe:	f1bc 0f00 	cmp.w	ip, #0
 8002b02:	d004      	beq.n	8002b0e <chvprintf+0x4f2>
 8002b04:	2820      	cmp	r0, #32
    *p++ = ' ';
 8002b06:	bf1c      	itt	ne
 8002b08:	2320      	movne	r3, #32
 8002b0a:	f807 3b01 	strbne.w	r3, [r7], #1
  *p++ = s;
 8002b0e:	f807 0b01 	strb.w	r0, [r7], #1
    if ((width -=(int)(p - s)) < 0)
 8002b12:	9b01      	ldr	r3, [sp, #4]
      p=ulong_freq(p, va_arg(ap, pfreq_t), precision);
 8002b14:	4689      	mov	r9, r1
    if ((width -=(int)(p - s)) < 0)
 8002b16:	1afb      	subs	r3, r7, r3
      break;
 8002b18:	e632      	b.n	8002780 <chvprintf+0x164>
      } else if (!(flag & FREQ_PREFIX_SPACE))
 8002b1a:	f1bc 0f00 	cmp.w	ip, #0
 8002b1e:	d102      	bne.n	8002b26 <chvprintf+0x50a>
        c = *q++;
 8002b20:	7853      	ldrb	r3, [r2, #1]
 8002b22:	3202      	adds	r2, #2
 8002b24:	e7dd      	b.n	8002ae2 <chvprintf+0x4c6>
    char c = *q++;
 8002b26:	462a      	mov	r2, r5
 8002b28:	f04f 0c02 	mov.w	ip, #2
 8002b2c:	e7d9      	b.n	8002ae2 <chvprintf+0x4c6>
      if ((state&(NEGATIVE|POSITIVE|PLUS_SPACE)) && (state&PAD_ZERO)) {
 8002b2e:	f018 0f2c 	tst.w	r8, #44	@ 0x2c
 8002b32:	d13b      	bne.n	8002bac <chvprintf+0x590>
    if ((width -=(int)(p - s)) < 0)
 8002b34:	461d      	mov	r5, r3
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002b36:	f04f 0b30 	mov.w	fp, #48	@ 0x30
      if ((state&(NEGATIVE|POSITIVE|PLUS_SPACE)) && (state&PAD_ZERO)) {
 8002b3a:	a904      	add	r1, sp, #16
 8002b3c:	e6d2      	b.n	80028e4 <chvprintf+0x2c8>
 8002b3e:	f018 0f2c 	tst.w	r8, #44	@ 0x2c
 8002b42:	f43f ae94 	beq.w	800286e <chvprintf+0x252>
 8002b46:	f018 0f10 	tst.w	r8, #16
 8002b4a:	f43f ae90 	beq.w	800286e <chvprintf+0x252>
        streamPut(chp, (uint8_t)*s++);
 8002b4e:	6832      	ldr	r2, [r6, #0]
 8002b50:	f89d 1010 	ldrb.w	r1, [sp, #16]
 8002b54:	6892      	ldr	r2, [r2, #8]
 8002b56:	9301      	str	r3, [sp, #4]
 8002b58:	4630      	mov	r0, r6
 8002b5a:	4790      	blx	r2
        n++;
 8002b5c:	9b01      	ldr	r3, [sp, #4]
 8002b5e:	f10a 0a01 	add.w	sl, sl, #1
 8002b62:	461d      	mov	r5, r3
        streamPut(chp, (uint8_t)*s++);
 8002b64:	f10d 0111 	add.w	r1, sp, #17
 8002b68:	e6bc      	b.n	80028e4 <chvprintf+0x2c8>
  int n = 0;
 8002b6a:	460b      	mov	r3, r1
}
 8002b6c:	4618      	mov	r0, r3
 8002b6e:	b00b      	add	sp, #44	@ 0x2c
 8002b70:	ecbd 8b02 	vpop	{d8}
 8002b74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (state&DEFAULT_PRESCISION)
 8002b78:	f018 0f40 	tst.w	r8, #64	@ 0x40
 8002b7c:	d029      	beq.n	8002bd2 <chvprintf+0x5b6>
        precision = (c=='F') ? FLOAT_PREFIX_PRECISION : FLOAT_PRECISION;
 8002b7e:	2b46      	cmp	r3, #70	@ 0x46
 8002b80:	d03e      	beq.n	8002c00 <chvprintf+0x5e4>
 8002b82:	2709      	movs	r7, #9
      p = (c=='F') ? ftoaS(p, value.f, precision) : ftoa(p, value.f, precision);
 8002b84:	4639      	mov	r1, r7
 8002b86:	eeb0 0a48 	vmov.f32	s0, s16
 8002b8a:	f7ff fcfb 	bl	8002584 <ftoa>
 8002b8e:	4607      	mov	r7, r0
      if (state & PAD_ZERO) { // remove zeros at end
 8002b90:	f018 0f10 	tst.w	r8, #16
 8002b94:	f040 808a 	bne.w	8002cac <chvprintf+0x690>
    if ((width -=(int)(p - s)) < 0)
 8002b98:	9901      	ldr	r1, [sp, #4]
 8002b9a:	1a7b      	subs	r3, r7, r1
 8002b9c:	1aeb      	subs	r3, r5, r3
 8002b9e:	f57f af13 	bpl.w	80029c8 <chvprintf+0x3ac>
    s = tmpbuf;
 8002ba2:	9901      	ldr	r1, [sp, #4]
 8002ba4:	e664      	b.n	8002870 <chvprintf+0x254>
 8002ba6:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8002baa:	e7a8      	b.n	8002afe <chvprintf+0x4e2>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002bac:	f04f 0b30 	mov.w	fp, #48	@ 0x30
 8002bb0:	e7cd      	b.n	8002b4e <chvprintf+0x532>
 8002bb2:	232b      	movs	r3, #43	@ 0x2b
        *p++ = ' ';
 8002bb4:	f88d 3010 	strb.w	r3, [sp, #16]
 8002bb8:	ab04      	add	r3, sp, #16
        *p++ = '+';
 8002bba:	f10d 0011 	add.w	r0, sp, #17
 8002bbe:	9301      	str	r3, [sp, #4]
 8002bc0:	e758      	b.n	8002a74 <chvprintf+0x458>
 8002bc2:	222b      	movs	r2, #43	@ 0x2b
        *p++ = ' ';
 8002bc4:	f88d 2010 	strb.w	r2, [sp, #16]
 8002bc8:	aa04      	add	r2, sp, #16
        *p++ = '+';
 8002bca:	f10d 0011 	add.w	r0, sp, #17
 8002bce:	9201      	str	r2, [sp, #4]
 8002bd0:	e717      	b.n	8002a02 <chvprintf+0x3e6>
      p = (c=='F') ? ftoaS(p, value.f, precision) : ftoa(p, value.f, precision);
 8002bd2:	2b46      	cmp	r3, #70	@ 0x46
 8002bd4:	d1d6      	bne.n	8002b84 <chvprintf+0x568>
 8002bd6:	b23b      	sxth	r3, r7
 8002bd8:	e014      	b.n	8002c04 <chvprintf+0x5e8>
    p = tmpbuf;
 8002bda:	a804      	add	r0, sp, #16
 8002bdc:	9001      	str	r0, [sp, #4]
 8002bde:	e710      	b.n	8002a02 <chvprintf+0x3e6>
 8002be0:	a804      	add	r0, sp, #16
 8002be2:	9001      	str	r0, [sp, #4]
 8002be4:	e746      	b.n	8002a74 <chvprintf+0x458>
 8002be6:	bf00      	nop
 8002be8:	cccccccd 	.word	0xcccccccd
 8002bec:	0801293c 	.word	0x0801293c
 8002bf0:	080147f8 	.word	0x080147f8
 8002bf4:	447a0000 	.word	0x447a0000
 8002bf8:	3a83126f 	.word	0x3a83126f
 8002bfc:	497423ff 	.word	0x497423ff
 8002c00:	2703      	movs	r7, #3
        precision = (c=='F') ? FLOAT_PREFIX_PRECISION : FLOAT_PRECISION;
 8002c02:	463b      	mov	r3, r7
  if (num >= 1000.0f){
 8002c04:	ed1f 7a05 	vldr	s14, [pc, #-20]	@ 8002bf4 <chvprintf+0x5d8>
 8002c08:	eeb4 8ac7 	vcmpe.f32	s16, s14
 8002c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c10:	db67      	blt.n	8002ce2 <chvprintf+0x6c6>
    for (ptr = bigPrefix+1; *ptr && num >= 1000.0f; num/=1000.0f, ptr++)
 8002c12:	ed5f 6a07 	vldr	s13, [pc, #-28]	@ 8002bf8 <chvprintf+0x5dc>
 8002c16:	ed1f 7a07 	vldr	s14, [pc, #-28]	@ 8002bfc <chvprintf+0x5e0>
 8002c1a:	4a50      	ldr	r2, [pc, #320]	@ (8002d5c <chvprintf+0x740>)
 8002c1c:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8002c20:	eef0 7a48 	vmov.f32	s15, s16
 8002c24:	ee28 8a26 	vmul.f32	s16, s16, s13
 8002c28:	b121      	cbz	r1, 8002c34 <chvprintf+0x618>
 8002c2a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002c2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002c32:	daf3      	bge.n	8002c1c <chvprintf+0x600>
    prefix = ptr[-1];
 8002c34:	f812 2c01 	ldrb.w	r2, [r2, #-1]
  if (prefix)
 8002c38:	b10a      	cbz	r2, 8002c3e <chvprintf+0x622>
    precision--;
 8002c3a:	3f01      	subs	r7, #1
 8002c3c:	b23b      	sxth	r3, r7
  uint32_t l = num;
 8002c3e:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 8002c42:	ee17 1a90 	vmov	r1, s15
  if (l >= 100)
 8002c46:	2963      	cmp	r1, #99	@ 0x63
 8002c48:	d954      	bls.n	8002cf4 <chvprintf+0x6d8>
    precision-=2;
 8002c4a:	3b02      	subs	r3, #2
 8002c4c:	b21b      	sxth	r3, r3
  p=ftoa(p, num, precision);
 8002c4e:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
 8002c52:	eeb0 0a48 	vmov.f32	s0, s16
 8002c56:	9203      	str	r2, [sp, #12]
 8002c58:	9302      	str	r3, [sp, #8]
 8002c5a:	f7ff fc93 	bl	8002584 <ftoa>
  if (precision){
 8002c5e:	9b02      	ldr	r3, [sp, #8]
 8002c60:	9a03      	ldr	r2, [sp, #12]
 8002c62:	2b00      	cmp	r3, #0
  p=ftoa(p, num, precision);
 8002c64:	4607      	mov	r7, r0
  if (precision){
 8002c66:	dd14      	ble.n	8002c92 <chvprintf+0x676>
    while (p[-1]=='0') p--;
 8002c68:	f810 1c01 	ldrb.w	r1, [r0, #-1]
 8002c6c:	2930      	cmp	r1, #48	@ 0x30
 8002c6e:	d105      	bne.n	8002c7c <chvprintf+0x660>
 8002c70:	1e43      	subs	r3, r0, #1
 8002c72:	461f      	mov	r7, r3
 8002c74:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 8002c78:	2930      	cmp	r1, #48	@ 0x30
 8002c7a:	d0fa      	beq.n	8002c72 <chvprintf+0x656>
    if (p[-1]==DIGIT_SEPARATOR) p--;
 8002c7c:	4b38      	ldr	r3, [pc, #224]	@ (8002d60 <chvprintf+0x744>)
 8002c7e:	8a9b      	ldrh	r3, [r3, #20]
 8002c80:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8002c84:	bf0c      	ite	eq
 8002c86:	232e      	moveq	r3, #46	@ 0x2e
 8002c88:	232c      	movne	r3, #44	@ 0x2c
 8002c8a:	4299      	cmp	r1, r3
 8002c8c:	bf08      	it	eq
 8002c8e:	f107 37ff 	addeq.w	r7, r7, #4294967295
  if (prefix)
 8002c92:	2a00      	cmp	r2, #0
 8002c94:	f43f af7c 	beq.w	8002b90 <chvprintf+0x574>
    *p++ = prefix;
 8002c98:	f807 2b01 	strb.w	r2, [r7], #1
 8002c9c:	e778      	b.n	8002b90 <chvprintf+0x574>
    if ((width -=(int)(p - s)) < 0)
 8002c9e:	461d      	mov	r5, r3
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002ca0:	f04f 0b20 	mov.w	fp, #32
      *p++ = va_arg(ap, int);
 8002ca4:	f10d 0711 	add.w	r7, sp, #17
    s = tmpbuf;
 8002ca8:	a904      	add	r1, sp, #16
 8002caa:	e61b      	b.n	80028e4 <chvprintf+0x2c8>
        while (p[-1]=='0') p--;
 8002cac:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 8002cb0:	2a30      	cmp	r2, #48	@ 0x30
        state^= PAD_ZERO;
 8002cb2:	f088 0810 	eor.w	r8, r8, #16
        while (p[-1]=='0') p--;
 8002cb6:	d105      	bne.n	8002cc4 <chvprintf+0x6a8>
 8002cb8:	1e7b      	subs	r3, r7, #1
 8002cba:	461f      	mov	r7, r3
 8002cbc:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8002cc0:	2a30      	cmp	r2, #48	@ 0x30
 8002cc2:	d0fa      	beq.n	8002cba <chvprintf+0x69e>
        if (p[-1]=='.') p--;
 8002cc4:	2a2e      	cmp	r2, #46	@ 0x2e
 8002cc6:	bf08      	it	eq
 8002cc8:	f107 37ff 	addeq.w	r7, r7, #4294967295
 8002ccc:	e764      	b.n	8002b98 <chvprintf+0x57c>
    if (!(state&LEFT_ALIGN)) {
 8002cce:	f10d 0711 	add.w	r7, sp, #17
 8002cd2:	a904      	add	r1, sp, #16
 8002cd4:	e563      	b.n	800279e <chvprintf+0x182>
    if (freq == 0) break;
 8002cd6:	f04f 0e01 	mov.w	lr, #1
 8002cda:	2020      	movs	r0, #32
    *--q = c + '0';
 8002cdc:	f10d 021d 	add.w	r2, sp, #29
 8002ce0:	e6e7      	b.n	8002ab2 <chvprintf+0x496>
  else if (num < 1.0f){
 8002ce2:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8002ce6:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8002cea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002cee:	d411      	bmi.n	8002d14 <chvprintf+0x6f8>
  char prefix=0;
 8002cf0:	2200      	movs	r2, #0
 8002cf2:	e7a4      	b.n	8002c3e <chvprintf+0x622>
  else if (l >= 10)
 8002cf4:	2909      	cmp	r1, #9
    precision-=1;
 8002cf6:	bf84      	itt	hi
 8002cf8:	f103 33ff 	addhi.w	r3, r3, #4294967295
 8002cfc:	b21b      	sxthhi	r3, r3
 8002cfe:	e7a6      	b.n	8002c4e <chvprintf+0x632>
    if ((width -=(int)(p - s)) < 0)
 8002d00:	2d00      	cmp	r5, #0
 8002d02:	f6ff aca3 	blt.w	800264c <chvprintf+0x30>
    if (!(state&LEFT_ALIGN)) {
 8002d06:	f018 0f02 	tst.w	r8, #2
 8002d0a:	d01e      	beq.n	8002d4a <chvprintf+0x72e>
    if ((width -=(int)(p - s)) < 0)
 8002d0c:	462b      	mov	r3, r5
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002d0e:	f04f 0b20 	mov.w	fp, #32
 8002d12:	e55e      	b.n	80027d2 <chvprintf+0x1b6>
    for (ptr = smallPrefix; *ptr && num < 1.0f; num*=1000.0f, ptr++)
 8002d14:	eddf 6a13 	vldr	s13, [pc, #76]	@ 8002d64 <chvprintf+0x748>
 8002d18:	4913      	ldr	r1, [pc, #76]	@ (8002d68 <chvprintf+0x74c>)
 8002d1a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8002d1e:	eef0 7a48 	vmov.f32	s15, s16
 8002d22:	ee28 8a07 	vmul.f32	s16, s16, s14
 8002d26:	b13a      	cbz	r2, 8002d38 <chvprintf+0x71c>
 8002d28:	eef4 7ae6 	vcmpe.f32	s15, s13
 8002d2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002d30:	d4f3      	bmi.n	8002d1a <chvprintf+0x6fe>
    prefix = num > 1e-3 ? ptr[-1] : 0;
 8002d32:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 8002d36:	e77f      	b.n	8002c38 <chvprintf+0x61c>
 8002d38:	ed9f 7a0c 	vldr	s14, [pc, #48]	@ 8002d6c <chvprintf+0x750>
 8002d3c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002d40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002d44:	f77f af7b 	ble.w	8002c3e <chvprintf+0x622>
 8002d48:	e7f3      	b.n	8002d32 <chvprintf+0x716>
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002d4a:	f04f 0b20 	mov.w	fp, #32
      while (width){
 8002d4e:	2d00      	cmp	r5, #0
 8002d50:	f43f ac7c 	beq.w	800264c <chvprintf+0x30>
 8002d54:	460f      	mov	r7, r1
      filler = (state&PAD_ZERO) ? '0' : ' ';
 8002d56:	f04f 0b20 	mov.w	fp, #32
 8002d5a:	e5c5      	b.n	80028e8 <chvprintf+0x2cc>
 8002d5c:	080147f9 	.word	0x080147f9
 8002d60:	20000318 	.word	0x20000318
 8002d64:	3a83126f 	.word	0x3a83126f
 8002d68:	080147ec 	.word	0x080147ec
 8002d6c:	358637bd 	.word	0x358637bd

08002d70 <plot_printf>:

static const struct printStreamVMT vmt = {NULL, NULL, put, NULL};
// Simple print in buffer function
int plot_printf(char *str, int size, const char *fmt, ...) {
 8002d70:	b40c      	push	{r2, r3}
 8002d72:	b510      	push	{r4, lr}
  va_list ap;
  printStream ps;
  int retval;
  if (size <= 0) return 0;
 8002d74:	1e0c      	subs	r4, r1, #0
int plot_printf(char *str, int size, const char *fmt, ...) {
 8002d76:	b084      	sub	sp, #16
  if (size <= 0) return 0;
 8002d78:	dd15      	ble.n	8002da6 <plot_printf+0x36>
  // Init small memory stream for print
  ps.vmt    = &vmt;
 8002d7a:	4b0e      	ldr	r3, [pc, #56]	@ (8002db4 <plot_printf+0x44>)
  ps.buffer = (uint8_t *)str;
  ps.size   = size;
  // Performing the print operation using the common code.
  va_start(ap, fmt);
  retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8002d7c:	9906      	ldr	r1, [sp, #24]
  ps.size   = size;
 8002d7e:	f8ad 400c 	strh.w	r4, [sp, #12]
  ps.buffer = (uint8_t *)str;
 8002d82:	e9cd 3001 	strd	r3, r0, [sp, #4]
  va_start(ap, fmt);
 8002d86:	aa07      	add	r2, sp, #28
  retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8002d88:	a801      	add	r0, sp, #4
  va_start(ap, fmt);
 8002d8a:	9200      	str	r2, [sp, #0]
  retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8002d8c:	f7ff fc46 	bl	800261c <chvprintf>
  va_end(ap);
  *(ps.buffer)=0;
 8002d90:	9b02      	ldr	r3, [sp, #8]
 8002d92:	2200      	movs	r2, #0
  if (retval > size-1) retval = size-1;
 8002d94:	4284      	cmp	r4, r0
  *(ps.buffer)=0;
 8002d96:	701a      	strb	r2, [r3, #0]
  if (retval > size-1) retval = size-1;
 8002d98:	dc00      	bgt.n	8002d9c <plot_printf+0x2c>
 8002d9a:	1e60      	subs	r0, r4, #1
  // Return number of bytes that would have been written.
  return retval;
}
 8002d9c:	b004      	add	sp, #16
 8002d9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8002da2:	b002      	add	sp, #8
 8002da4:	4770      	bx	lr
  if (size <= 0) return 0;
 8002da6:	2000      	movs	r0, #0
}
 8002da8:	b004      	add	sp, #16
 8002daa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8002dae:	b002      	add	sp, #8
 8002db0:	4770      	bx	lr
 8002db2:	bf00      	nop
 8002db4:	080147dc 	.word	0x080147dc

08002db8 <mem_cpy>:
static void mem_cpy (void* dst, const void* src, UINT cnt)
{
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

	if (cnt != 0) {
 8002db8:	3801      	subs	r0, #1
 8002dba:	440a      	add	r2, r1
		do {
			*d++ = *s++;
 8002dbc:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002dc0:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 8002dc4:	4291      	cmp	r1, r2
 8002dc6:	d1f9      	bne.n	8002dbc <mem_cpy+0x4>
	}
}
 8002dc8:	4770      	bx	lr
	...

08002dcc <mem_set>:

/* Fill memory block */
static void mem_set (void* dst, int val, UINT cnt)
{
	BYTE *d = (BYTE*)dst;
 8002dcc:	4402      	add	r2, r0

	do {
		*d++ = (BYTE)val;
 8002dce:	f800 1b01 	strb.w	r1, [r0], #1
	} while (--cnt);
 8002dd2:	4290      	cmp	r0, r2
 8002dd4:	d1fb      	bne.n	8002dce <mem_set+0x2>
}
 8002dd6:	4770      	bx	lr

08002dd8 <mem_cmp>:


/* Compare memory block */
static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
{
 8002dd8:	b510      	push	{r4, lr}
 8002dda:	4603      	mov	r3, r0
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;
 8002ddc:	4402      	add	r2, r0

	do {
		r = *d++ - *s++;
 8002dde:	f813 0b01 	ldrb.w	r0, [r3], #1
 8002de2:	f811 4b01 	ldrb.w	r4, [r1], #1
	} while (--cnt && r == 0);
 8002de6:	4293      	cmp	r3, r2
		r = *d++ - *s++;
 8002de8:	eba0 0004 	sub.w	r0, r0, r4
	} while (--cnt && r == 0);
 8002dec:	d001      	beq.n	8002df2 <mem_cmp+0x1a>
 8002dee:	2800      	cmp	r0, #0
 8002df0:	d0f5      	beq.n	8002dde <mem_cmp+0x6>

	return r;
}
 8002df2:	bd10      	pop	{r4, pc}

08002df4 <clst2sect>:
	FATFS* fs,		/* Filesystem object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;		/* Cluster number is origin from 2 */
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002df4:	69c3      	ldr	r3, [r0, #28]
	clst -= 2;		/* Cluster number is origin from 2 */
 8002df6:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002df8:	3b02      	subs	r3, #2
 8002dfa:	428b      	cmp	r3, r1
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
 8002dfc:	bf83      	ittte	hi
 8002dfe:	8943      	ldrhhi	r3, [r0, #10]
 8002e00:	6b00      	ldrhi	r0, [r0, #48]	@ 0x30
 8002e02:	fb01 0003 	mlahi	r0, r1, r3, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002e06:	2000      	movls	r0, #0
}
 8002e08:	4770      	bx	lr
	...

08002e0c <sum_sfn>:
/*-----------------------------------------------------------------------*/

static BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 8002e0c:	4603      	mov	r3, r0
 8002e0e:	f100 010b 	add.w	r1, r0, #11
	BYTE sum = 0;
 8002e12:	2000      	movs	r0, #0
	UINT n = 11;

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8002e14:	01c2      	lsls	r2, r0, #7
 8002e16:	ea42 0250 	orr.w	r2, r2, r0, lsr #1
 8002e1a:	f813 0b01 	ldrb.w	r0, [r3], #1
 8002e1e:	fa50 f282 	uxtab	r2, r0, r2
	} while (--n);
 8002e22:	428b      	cmp	r3, r1
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8002e24:	b2d0      	uxtb	r0, r2
	} while (--n);
 8002e26:	d1f5      	bne.n	8002e14 <sum_sfn+0x8>
	return sum;
}
 8002e28:	4770      	bx	lr
	...

08002e2c <xdir_sum>:
/*-----------------------------------------------------------------------*/

static WORD xdir_sum (	/* Get checksum of the directoly entry block */
	const BYTE* dir		/* Directory entry block to be calculated */
)
{
 8002e2c:	b510      	push	{r4, lr}
	UINT i, szblk;
	WORD sum;


	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 8002e2e:	7842      	ldrb	r2, [r0, #1]
{
 8002e30:	4604      	mov	r4, r0
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 8002e32:	3201      	adds	r2, #1
	for (i = sum = 0; i < szblk; i++) {
 8002e34:	2000      	movs	r0, #0
	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 8002e36:	0152      	lsls	r2, r2, #5
	for (i = sum = 0; i < szblk; i++) {
 8002e38:	4603      	mov	r3, r0
 8002e3a:	2b02      	cmp	r3, #2
 8002e3c:	bf08      	it	eq
 8002e3e:	2304      	moveq	r3, #4
		if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
			i++;
		} else {
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 8002e40:	03c1      	lsls	r1, r0, #15
 8002e42:	ea41 0150 	orr.w	r1, r1, r0, lsr #1
 8002e46:	5ce0      	ldrb	r0, [r4, r3]
	for (i = sum = 0; i < szblk; i++) {
 8002e48:	3301      	adds	r3, #1
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 8002e4a:	fa10 f181 	uxtah	r1, r0, r1
	for (i = sum = 0; i < szblk; i++) {
 8002e4e:	429a      	cmp	r2, r3
			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
 8002e50:	b288      	uxth	r0, r1
	for (i = sum = 0; i < szblk; i++) {
 8002e52:	d8f2      	bhi.n	8002e3a <xdir_sum+0xe>
		}
	}
	return sum;
}
 8002e54:	bd10      	pop	{r4, pc}
	...

08002e58 <get_achar>:
	chr = tchar2uni(ptr);
	if (chr == 0xFFFFFFFF) chr = 0;		/* Wrong UTF encoding is recognized as end of the string */
	chr = ff_wtoupper(chr);

#else									/* ANSI/OEM input */
	chr = (BYTE)*(*ptr)++;				/* Get a byte */
 8002e58:	6803      	ldr	r3, [r0, #0]
 8002e5a:	1c5a      	adds	r2, r3, #1
 8002e5c:	6002      	str	r2, [r0, #0]
 8002e5e:	7818      	ldrb	r0, [r3, #0]
	if (IsLower(chr)) chr -= 0x20;		/* To upper ASCII char */
 8002e60:	f1a0 0361 	sub.w	r3, r0, #97	@ 0x61
 8002e64:	2b19      	cmp	r3, #25
 8002e66:	d801      	bhi.n	8002e6c <get_achar+0x14>
 8002e68:	3820      	subs	r0, #32
#if FF_CODE_PAGE == 0
	if (ExCvt && chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
#elif FF_CODE_PAGE < 900
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 8002e6a:	4770      	bx	lr
 8002e6c:	287f      	cmp	r0, #127	@ 0x7f
 8002e6e:	d903      	bls.n	8002e78 <get_achar+0x20>
 8002e70:	4b02      	ldr	r3, [pc, #8]	@ (8002e7c <get_achar+0x24>)
 8002e72:	4403      	add	r3, r0
 8002e74:	f813 0c80 	ldrb.w	r0, [r3, #-128]
	}
#endif

#endif
	return chr;
}
 8002e78:	4770      	bx	lr
 8002e7a:	bf00      	nop
 8002e7c:	08014cac 	.word	0x08014cac

08002e80 <pattern_match>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	UINT skip,			/* Number of pre-skip chars (number of ?s, b8:infinite (* specified)) */
	UINT recur			/* Recursion count */
)
{
 8002e80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002e82:	b085      	sub	sp, #20
 8002e84:	4605      	mov	r5, r0
 8002e86:	9101      	str	r1, [sp, #4]
 8002e88:	4614      	mov	r4, r2
 8002e8a:	461e      	mov	r6, r3
	const TCHAR *pptr, *nptr;
	DWORD pchr, nchr;
	UINT sk;


	while ((skip & 0xFF) != 0) {		/* Pre-skip name chars */
 8002e8c:	b2e3      	uxtb	r3, r4
 8002e8e:	b13b      	cbz	r3, 8002ea0 <pattern_match+0x20>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 8002e90:	a801      	add	r0, sp, #4
 8002e92:	f7ff ffe1 	bl	8002e58 <get_achar>
 8002e96:	b908      	cbnz	r0, 8002e9c <pattern_match+0x1c>
 8002e98:	2000      	movs	r0, #0
 8002e9a:	e042      	b.n	8002f22 <pattern_match+0xa2>
		skip--;
 8002e9c:	3c01      	subs	r4, #1
 8002e9e:	e7f5      	b.n	8002e8c <pattern_match+0xc>
	}
	if (*pat == 0 && skip) return 1;	/* Matched? (short circuit) */
 8002ea0:	782b      	ldrb	r3, [r5, #0]
 8002ea2:	b993      	cbnz	r3, 8002eca <pattern_match+0x4a>
 8002ea4:	b18c      	cbz	r4, 8002eca <pattern_match+0x4a>
 8002ea6:	2001      	movs	r0, #1
 8002ea8:	e03b      	b.n	8002f22 <pattern_match+0xa2>
				if (recur == 0) return 0;	/* Too many wildcard terms? */
				sk = 0;
				do {	/* Analyze the wildcard term */
					if (*pptr++ == '?') sk++; else sk |= 0x100;
				} while (*pptr == '?' || *pptr == '*');
				if (pattern_match(pptr, nptr, sk, recur - 1)) return 1;	/* Test new branch (recursive call) */
 8002eaa:	9f03      	ldr	r7, [sp, #12]
 8002eac:	9002      	str	r0, [sp, #8]
 8002eae:	1e73      	subs	r3, r6, #1
 8002eb0:	4639      	mov	r1, r7
 8002eb2:	f7ff ffe5 	bl	8002e80 <pattern_match>
 8002eb6:	2800      	cmp	r0, #0
 8002eb8:	d1f5      	bne.n	8002ea6 <pattern_match+0x26>
				nchr = *nptr; break;	/* Branch mismatched */
 8002eba:	7839      	ldrb	r1, [r7, #0]
			pchr = get_achar(&pptr);	/* Get a pattern char */
			nchr = get_achar(&nptr);	/* Get a name char */
			if (pchr != nchr) break;	/* Branch mismatched? */
			if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
		}
		get_achar(&nam);			/* nam++ */
 8002ebc:	a801      	add	r0, sp, #4
 8002ebe:	f7ff ffcb 	bl	8002e58 <get_achar>
	} while (skip && nchr);		/* Retry until end of name if infinite search is specified */
 8002ec2:	2c00      	cmp	r4, #0
 8002ec4:	d0e8      	beq.n	8002e98 <pattern_match+0x18>
 8002ec6:	2900      	cmp	r1, #0
 8002ec8:	d0e6      	beq.n	8002e98 <pattern_match+0x18>
		pptr = pat; nptr = nam;			/* Top of pattern and name to match */
 8002eca:	9b01      	ldr	r3, [sp, #4]
 8002ecc:	9502      	str	r5, [sp, #8]
 8002ece:	9303      	str	r3, [sp, #12]
			if (*pptr == '?' || *pptr == '*') {	/* Wildcard term? */
 8002ed0:	9802      	ldr	r0, [sp, #8]
 8002ed2:	7802      	ldrb	r2, [r0, #0]
 8002ed4:	2a3f      	cmp	r2, #63	@ 0x3f
 8002ed6:	d001      	beq.n	8002edc <pattern_match+0x5c>
 8002ed8:	2a2a      	cmp	r2, #42	@ 0x2a
 8002eda:	d115      	bne.n	8002f08 <pattern_match+0x88>
				if (recur == 0) return 0;	/* Too many wildcard terms? */
 8002edc:	2e00      	cmp	r6, #0
 8002ede:	d0db      	beq.n	8002e98 <pattern_match+0x18>
 8002ee0:	3001      	adds	r0, #1
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8002ee2:	2a3f      	cmp	r2, #63	@ 0x3f
 8002ee4:	4603      	mov	r3, r0
 8002ee6:	f04f 0200 	mov.w	r2, #0
 8002eea:	d104      	bne.n	8002ef6 <pattern_match+0x76>
 8002eec:	3201      	adds	r2, #1
 8002eee:	e004      	b.n	8002efa <pattern_match+0x7a>
				} while (*pptr == '?' || *pptr == '*');
 8002ef0:	292a      	cmp	r1, #42	@ 0x2a
 8002ef2:	d1da      	bne.n	8002eaa <pattern_match+0x2a>
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8002ef4:	4618      	mov	r0, r3
 8002ef6:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
				} while (*pptr == '?' || *pptr == '*');
 8002efa:	7801      	ldrb	r1, [r0, #0]
 8002efc:	293f      	cmp	r1, #63	@ 0x3f
 8002efe:	f103 0301 	add.w	r3, r3, #1
 8002f02:	d1f5      	bne.n	8002ef0 <pattern_match+0x70>
					if (*pptr++ == '?') sk++; else sk |= 0x100;
 8002f04:	4618      	mov	r0, r3
 8002f06:	e7f1      	b.n	8002eec <pattern_match+0x6c>
			pchr = get_achar(&pptr);	/* Get a pattern char */
 8002f08:	a802      	add	r0, sp, #8
 8002f0a:	f7ff ffa5 	bl	8002e58 <get_achar>
 8002f0e:	4607      	mov	r7, r0
			nchr = get_achar(&nptr);	/* Get a name char */
 8002f10:	a803      	add	r0, sp, #12
 8002f12:	f7ff ffa1 	bl	8002e58 <get_achar>
			if (pchr != nchr) break;	/* Branch mismatched? */
 8002f16:	4287      	cmp	r7, r0
			nchr = get_achar(&nptr);	/* Get a name char */
 8002f18:	4601      	mov	r1, r0
			if (pchr != nchr) break;	/* Branch mismatched? */
 8002f1a:	d1cf      	bne.n	8002ebc <pattern_match+0x3c>
			if (pchr == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 8002f1c:	2f00      	cmp	r7, #0
 8002f1e:	d1d7      	bne.n	8002ed0 <pattern_match+0x50>
 8002f20:	e7c1      	b.n	8002ea6 <pattern_match+0x26>

	return 0;
}
 8002f22:	b005      	add	sp, #20
 8002f24:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08002f28 <get_ldnumber>:
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
 8002f28:	6803      	ldr	r3, [r0, #0]
	if (!tp) return vol;	/* Invalid path name? */
 8002f2a:	b17b      	cbz	r3, 8002f4c <get_ldnumber+0x24>
	tt = tp = *path;
 8002f2c:	461a      	mov	r2, r3
	do tc = *tt++; while (!IsTerminator(tc) && tc != ':');	/* Find a colon in the path */
 8002f2e:	f812 1b01 	ldrb.w	r1, [r2], #1
 8002f32:	291f      	cmp	r1, #31
 8002f34:	d908      	bls.n	8002f48 <get_ldnumber+0x20>
 8002f36:	293a      	cmp	r1, #58	@ 0x3a
 8002f38:	d1f9      	bne.n	8002f2e <get_ldnumber+0x6>

	if (tc == ':') {	/* DOS/Windows style volume ID? */
		i = FF_VOLUMES;
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 8002f3a:	7819      	ldrb	r1, [r3, #0]
 8002f3c:	2930      	cmp	r1, #48	@ 0x30
 8002f3e:	d105      	bne.n	8002f4c <get_ldnumber+0x24>
 8002f40:	3302      	adds	r3, #2
 8002f42:	429a      	cmp	r2, r3
 8002f44:	d102      	bne.n	8002f4c <get_ldnumber+0x24>
			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
		}
#endif
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
			vol = i;		/* Drive number */
			*path = tt;		/* Snip the drive prefix off */
 8002f46:	6002      	str	r2, [r0, #0]
			vol = i;		/* Drive number */
 8002f48:	2000      	movs	r0, #0
 8002f4a:	4770      	bx	lr
	if (!tp) return vol;	/* Invalid path name? */
 8002f4c:	f04f 30ff 	mov.w	r0, #4294967295
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
}
 8002f50:	4770      	bx	lr
	...

08002f54 <validate>:

static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
 8002f54:	b538      	push	{r3, r4, r5, lr}
 8002f56:	460d      	mov	r5, r1
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8002f58:	b910      	cbnz	r0, 8002f60 <validate+0xc>
	FRESULT res = FR_INVALID_OBJECT;
 8002f5a:	2009      	movs	r0, #9
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8002f5c:	2300      	movs	r3, #0
 8002f5e:	e011      	b.n	8002f84 <validate+0x30>
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8002f60:	6803      	ldr	r3, [r0, #0]
 8002f62:	4604      	mov	r4, r0
 8002f64:	2b00      	cmp	r3, #0
 8002f66:	d0f8      	beq.n	8002f5a <validate+0x6>
 8002f68:	781a      	ldrb	r2, [r3, #0]
 8002f6a:	2a00      	cmp	r2, #0
 8002f6c:	d0f5      	beq.n	8002f5a <validate+0x6>
 8002f6e:	8881      	ldrh	r1, [r0, #4]
 8002f70:	88da      	ldrh	r2, [r3, #6]
 8002f72:	4291      	cmp	r1, r2
 8002f74:	d1f1      	bne.n	8002f5a <validate+0x6>
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8002f76:	7858      	ldrb	r0, [r3, #1]
 8002f78:	f00e fae8 	bl	801154c <disk_status>
 8002f7c:	f010 0001 	ands.w	r0, r0, #1
 8002f80:	d1eb      	bne.n	8002f5a <validate+0x6>
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8002f82:	6823      	ldr	r3, [r4, #0]
 8002f84:	602b      	str	r3, [r5, #0]
	return res;
}
 8002f86:	bd38      	pop	{r3, r4, r5, pc}

08002f88 <sync_window>:
{
 8002f88:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Is the disk access window dirty? */
 8002f8a:	78c3      	ldrb	r3, [r0, #3]
 8002f8c:	b1cb      	cbz	r3, 8002fc2 <sync_window+0x3a>
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
 8002f8e:	f100 053c 	add.w	r5, r0, #60	@ 0x3c
 8002f92:	6b82      	ldr	r2, [r0, #56]	@ 0x38
 8002f94:	4604      	mov	r4, r0
 8002f96:	2301      	movs	r3, #1
 8002f98:	7840      	ldrb	r0, [r0, #1]
 8002f9a:	4629      	mov	r1, r5
 8002f9c:	f00e fb24 	bl	80115e8 <disk_write>
 8002fa0:	b988      	cbnz	r0, 8002fc6 <sync_window+0x3e>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8002fa2:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8002fa4:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 8002fa6:	6a22      	ldr	r2, [r4, #32]
			fs->wflag = 0;	/* Clear window dirty flag */
 8002fa8:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8002faa:	1acb      	subs	r3, r1, r3
 8002fac:	4293      	cmp	r3, r2
 8002fae:	d208      	bcs.n	8002fc2 <sync_window+0x3a>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8002fb0:	78a3      	ldrb	r3, [r4, #2]
 8002fb2:	2b02      	cmp	r3, #2
 8002fb4:	d105      	bne.n	8002fc2 <sync_window+0x3a>
 8002fb6:	440a      	add	r2, r1
 8002fb8:	7860      	ldrb	r0, [r4, #1]
 8002fba:	2301      	movs	r3, #1
 8002fbc:	4629      	mov	r1, r5
 8002fbe:	f00e fb13 	bl	80115e8 <disk_write>
	FRESULT res = FR_OK;
 8002fc2:	2000      	movs	r0, #0
 8002fc4:	e000      	b.n	8002fc8 <sync_window+0x40>
			res = FR_DISK_ERR;
 8002fc6:	2001      	movs	r0, #1
}
 8002fc8:	bd38      	pop	{r3, r4, r5, pc}
	...

08002fcc <move_window>:
{
 8002fcc:	b538      	push	{r3, r4, r5, lr}
	if (sect != fs->winsect) {	/* Window offset changed? */
 8002fce:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8002fd0:	428b      	cmp	r3, r1
 8002fd2:	d011      	beq.n	8002ff8 <move_window+0x2c>
 8002fd4:	4604      	mov	r4, r0
 8002fd6:	460d      	mov	r5, r1
		res = sync_window(fs);		/* Flush the window */
 8002fd8:	f7ff ffd6 	bl	8002f88 <sync_window>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8002fdc:	b968      	cbnz	r0, 8002ffa <move_window+0x2e>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
 8002fde:	7860      	ldrb	r0, [r4, #1]
 8002fe0:	2301      	movs	r3, #1
 8002fe2:	462a      	mov	r2, r5
 8002fe4:	f104 013c 	add.w	r1, r4, #60	@ 0x3c
 8002fe8:	f00e fabc 	bl	8011564 <disk_read>
 8002fec:	b110      	cbz	r0, 8002ff4 <move_window+0x28>
				res = FR_DISK_ERR;
 8002fee:	2001      	movs	r0, #1
				sect = (LBA_t)0 - 1;	/* Invalidate window if read data is not valid */
 8002ff0:	f04f 35ff 	mov.w	r5, #4294967295
			fs->winsect = sect;
 8002ff4:	63a5      	str	r5, [r4, #56]	@ 0x38
 8002ff6:	e000      	b.n	8002ffa <move_window+0x2e>
	FRESULT res = FR_OK;
 8002ff8:	2000      	movs	r0, #0
}
 8002ffa:	bd38      	pop	{r3, r4, r5, pc}

08002ffc <check_fs>:
{
 8002ffc:	b538      	push	{r3, r4, r5, lr}
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
 8002ffe:	2300      	movs	r3, #0
 8003000:	70c3      	strb	r3, [r0, #3]
 8003002:	f04f 33ff 	mov.w	r3, #4294967295
 8003006:	6383      	str	r3, [r0, #56]	@ 0x38
{
 8003008:	4604      	mov	r4, r0
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 800300a:	f7ff ffdf 	bl	8002fcc <move_window>
 800300e:	2800      	cmp	r0, #0
 8003010:	d148      	bne.n	80030a4 <check_fs+0xa8>
	sign = ld_word(fs->win + BS_55AA);
 8003012:	f8b4 523a 	ldrh.w	r5, [r4, #570]	@ 0x23a
	if (sign == 0xAA55 && !memcmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is an exFAT VBR */
 8003016:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 800301a:	429d      	cmp	r5, r3
 800301c:	d107      	bne.n	800302e <check_fs+0x32>
 800301e:	4924      	ldr	r1, [pc, #144]	@ (80030b0 <check_fs+0xb4>)
 8003020:	220b      	movs	r2, #11
 8003022:	f104 003c 	add.w	r0, r4, #60	@ 0x3c
 8003026:	f7ff fed7 	bl	8002dd8 <mem_cmp>
 800302a:	2800      	cmp	r0, #0
 800302c:	d03c      	beq.n	80030a8 <check_fs+0xac>
	b = fs->win[BS_JmpBoot];
 800302e:	f894 303c 	ldrb.w	r3, [r4, #60]	@ 0x3c
	if (b == 0xEB || b == 0xE9 || b == 0xE8) {	/* Valid JumpBoot code? (short jump, near jump or near call) */
 8003032:	2beb      	cmp	r3, #235	@ 0xeb
 8003034:	d003      	beq.n	800303e <check_fs+0x42>
 8003036:	3318      	adds	r3, #24
 8003038:	b2db      	uxtb	r3, r3
 800303a:	2b01      	cmp	r3, #1
 800303c:	d82b      	bhi.n	8003096 <check_fs+0x9a>
		if (sign == 0xAA55 && !memcmp(fs->win + BS_FilSysType32, "FAT32   ", 8)) {
 800303e:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 8003042:	429d      	cmp	r5, r3
 8003044:	d106      	bne.n	8003054 <check_fs+0x58>
 8003046:	491b      	ldr	r1, [pc, #108]	@ (80030b4 <check_fs+0xb8>)
 8003048:	2208      	movs	r2, #8
 800304a:	f104 008e 	add.w	r0, r4, #142	@ 0x8e
 800304e:	f7ff fec3 	bl	8002dd8 <mem_cmp>
 8003052:	b360      	cbz	r0, 80030ae <check_fs+0xb2>
		if ((w & (w - 1)) == 0 && w >= FF_MIN_SS && w <= FF_MAX_SS	/* Properness of sector size (512-4096 and 2^n) */
 8003054:	f8b4 3047 	ldrh.w	r3, [r4, #71]	@ 0x47
 8003058:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800305c:	d11b      	bne.n	8003096 <check_fs+0x9a>
		b = fs->win[BPB_SecPerClus];
 800305e:	f894 3049 	ldrb.w	r3, [r4, #73]	@ 0x49
			&& b != 0 && (b & (b - 1)) == 0				/* Properness of cluster size (2^n) */
 8003062:	b1c3      	cbz	r3, 8003096 <check_fs+0x9a>
 8003064:	1e5a      	subs	r2, r3, #1
 8003066:	421a      	tst	r2, r3
 8003068:	d115      	bne.n	8003096 <check_fs+0x9a>
			&& ld_word(fs->win + BPB_RsvdSecCnt) != 0	/* Properness of reserved sectors (MNBZ) */
 800306a:	f8b4 304a 	ldrh.w	r3, [r4, #74]	@ 0x4a
 800306e:	b193      	cbz	r3, 8003096 <check_fs+0x9a>
			&& (UINT)fs->win[BPB_NumFATs] - 1 <= 1		/* Properness of FATs (1 or 2) */
 8003070:	f894 304c 	ldrb.w	r3, [r4, #76]	@ 0x4c
 8003074:	3b01      	subs	r3, #1
 8003076:	2b01      	cmp	r3, #1
 8003078:	d80d      	bhi.n	8003096 <check_fs+0x9a>
			&& ld_word(fs->win + BPB_RootEntCnt) != 0	/* Properness of root dir entries (MNBZ) */
 800307a:	f8b4 304d 	ldrh.w	r3, [r4, #77]	@ 0x4d
 800307e:	b153      	cbz	r3, 8003096 <check_fs+0x9a>
			&& (ld_word(fs->win + BPB_TotSec16) >= 128 || ld_dword(fs->win + BPB_TotSec32) >= 0x10000)	/* Properness of volume sectors (>=128) */
 8003080:	f8b4 304f 	ldrh.w	r3, [r4, #79]	@ 0x4f
 8003084:	2b7f      	cmp	r3, #127	@ 0x7f
 8003086:	d803      	bhi.n	8003090 <check_fs+0x94>
 8003088:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
 800308a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800308e:	d302      	bcc.n	8003096 <check_fs+0x9a>
			&& ld_word(fs->win + BPB_FATSz16) != 0) {	/* Properness of FAT size (MNBZ) */
 8003090:	f8b4 3052 	ldrh.w	r3, [r4, #82]	@ 0x52
 8003094:	b953      	cbnz	r3, 80030ac <check_fs+0xb0>
	return sign == 0xAA55 ? 2 : 3;	/* Not an FAT VBR (valid or invalid BS) */
 8003096:	f64a 2055 	movw	r0, #43605	@ 0xaa55
 800309a:	4285      	cmp	r5, r0
 800309c:	bf14      	ite	ne
 800309e:	2003      	movne	r0, #3
 80030a0:	2002      	moveq	r0, #2
 80030a2:	e004      	b.n	80030ae <check_fs+0xb2>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
 80030a4:	2004      	movs	r0, #4
 80030a6:	e002      	b.n	80030ae <check_fs+0xb2>
	if (sign == 0xAA55 && !memcmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* It is an exFAT VBR */
 80030a8:	2001      	movs	r0, #1
 80030aa:	e000      	b.n	80030ae <check_fs+0xb2>
			return 0;	/* It is an FAT32 VBR */
 80030ac:	2000      	movs	r0, #0
}
 80030ae:	bd38      	pop	{r3, r4, r5, pc}
 80030b0:	0801482c 	.word	0x0801482c
 80030b4:	08014838 	.word	0x08014838

080030b8 <change_bitmap>:
	clst -= 2;	/* The first bit corresponds to cluster #2 */
 80030b8:	3902      	subs	r1, #2
{
 80030ba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
 80030be:	6b46      	ldr	r6, [r0, #52]	@ 0x34
	bm = 1 << (clst % 8);					/* Bit mask in the byte */
 80030c0:	f001 0407 	and.w	r4, r1, #7
 80030c4:	f04f 0a01 	mov.w	sl, #1
 80030c8:	fa0a f404 	lsl.w	r4, sl, r4
{
 80030cc:	4605      	mov	r5, r0
 80030ce:	4617      	mov	r7, r2
 80030d0:	4698      	mov	r8, r3
	sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
 80030d2:	eb06 3611 	add.w	r6, r6, r1, lsr #12
	i = clst / 8 % SS(fs);					/* Byte offset in the sector */
 80030d6:	f3c1 09c8 	ubfx	r9, r1, #3, #9
	bm = 1 << (clst % 8);					/* Bit mask in the byte */
 80030da:	b2e4      	uxtb	r4, r4
		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
 80030dc:	4631      	mov	r1, r6
 80030de:	4628      	mov	r0, r5
 80030e0:	3601      	adds	r6, #1
 80030e2:	f7ff ff73 	bl	8002fcc <move_window>
 80030e6:	bb08      	cbnz	r0, 800312c <change_bitmap+0x74>
				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
 80030e8:	eb05 0109 	add.w	r1, r5, r9
 80030ec:	f891 303c 	ldrb.w	r3, [r1, #60]	@ 0x3c
 80030f0:	ea03 0204 	and.w	r2, r3, r4
 80030f4:	3a00      	subs	r2, #0
 80030f6:	bf18      	it	ne
 80030f8:	2201      	movne	r2, #1
 80030fa:	4542      	cmp	r2, r8
 80030fc:	d015      	beq.n	800312a <change_bitmap+0x72>
				fs->win[i] ^= bm;	/* Flip the bit */
 80030fe:	4063      	eors	r3, r4
				if (--ncl == 0) return FR_OK;	/* All bits processed? */
 8003100:	3f01      	subs	r7, #1
				fs->win[i] ^= bm;	/* Flip the bit */
 8003102:	f881 303c 	strb.w	r3, [r1, #60]	@ 0x3c
				fs->wflag = 1;
 8003106:	f885 a003 	strb.w	sl, [r5, #3]
				if (--ncl == 0) return FR_OK;	/* All bits processed? */
 800310a:	d00f      	beq.n	800312c <change_bitmap+0x74>
			} while (bm <<= 1);		/* Next bit */
 800310c:	0064      	lsls	r4, r4, #1
 800310e:	f014 04ff 	ands.w	r4, r4, #255	@ 0xff
 8003112:	d1e9      	bne.n	80030e8 <change_bitmap+0x30>
		} while (++i < SS(fs));		/* Next byte */
 8003114:	f109 0301 	add.w	r3, r9, #1
 8003118:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
			bm = 1;
 800311c:	f04f 0401 	mov.w	r4, #1
		i = 0;
 8003120:	f04f 0900 	mov.w	r9, #0
		} while (++i < SS(fs));		/* Next byte */
 8003124:	d2da      	bcs.n	80030dc <change_bitmap+0x24>
 8003126:	4699      	mov	r9, r3
 8003128:	e7de      	b.n	80030e8 <change_bitmap+0x30>
				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
 800312a:	2002      	movs	r0, #2
}
 800312c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08003130 <put_fat>:
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8003130:	2901      	cmp	r1, #1
 8003132:	d96f      	bls.n	8003214 <put_fat+0xe4>
{
 8003134:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8003138:	69c3      	ldr	r3, [r0, #28]
 800313a:	428b      	cmp	r3, r1
 800313c:	4605      	mov	r5, r0
 800313e:	460c      	mov	r4, r1
 8003140:	d96a      	bls.n	8003218 <put_fat+0xe8>
		switch (fs->fs_type) {
 8003142:	7803      	ldrb	r3, [r0, #0]
 8003144:	2b02      	cmp	r3, #2
 8003146:	4616      	mov	r6, r2
 8003148:	d03e      	beq.n	80031c8 <put_fat+0x98>
 800314a:	d802      	bhi.n	8003152 <put_fat+0x22>
 800314c:	2b01      	cmp	r3, #1
 800314e:	d004      	beq.n	800315a <put_fat+0x2a>
 8003150:	e062      	b.n	8003218 <put_fat+0xe8>
 8003152:	3b03      	subs	r3, #3
 8003154:	2b01      	cmp	r3, #1
 8003156:	d944      	bls.n	80031e2 <put_fat+0xb2>
 8003158:	e05e      	b.n	8003218 <put_fat+0xe8>
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 800315a:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800315e:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 8003160:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8003164:	f7ff ff32 	bl	8002fcc <move_window>
			if (res != FR_OK) break;
 8003168:	b108      	cbz	r0, 800316e <put_fat+0x3e>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800316a:	2001      	movs	r0, #1
 800316c:	e055      	b.n	800321a <put_fat+0xea>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 800316e:	f014 0401 	ands.w	r4, r4, #1
			p = fs->win + bc++ % SS(fs);
 8003172:	f107 0801 	add.w	r8, r7, #1
 8003176:	f105 093c 	add.w	r9, r5, #60	@ 0x3c
 800317a:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;	/* Update 1st byte */
 800317e:	b2f3      	uxtb	r3, r6
 8003180:	d006      	beq.n	8003190 <put_fat+0x60>
 8003182:	f819 2007 	ldrb.w	r2, [r9, r7]
 8003186:	f002 020f 	and.w	r2, r2, #15
 800318a:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 800318e:	b2db      	uxtb	r3, r3
 8003190:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003194:	6aa9      	ldr	r1, [r5, #40]	@ 0x28
			fs->wflag = 1;
 8003196:	2301      	movs	r3, #1
 8003198:	70eb      	strb	r3, [r5, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 800319a:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 800319e:	4628      	mov	r0, r5
 80031a0:	f7ff ff14 	bl	8002fcc <move_window>
			if (res != FR_OK) break;
 80031a4:	2800      	cmp	r0, #0
 80031a6:	d1e0      	bne.n	800316a <put_fat+0x3a>
			p = fs->win + bc % SS(fs);
 80031a8:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
 80031ac:	b114      	cbz	r4, 80031b4 <put_fat+0x84>
 80031ae:	f3c6 1607 	ubfx	r6, r6, #4, #8
 80031b2:	e006      	b.n	80031c2 <put_fat+0x92>
 80031b4:	f819 3008 	ldrb.w	r3, [r9, r8]
 80031b8:	f3c6 2603 	ubfx	r6, r6, #8, #4
 80031bc:	f023 030f 	bic.w	r3, r3, #15
 80031c0:	431e      	orrs	r6, r3
 80031c2:	f809 6008 	strb.w	r6, [r9, r8]
			fs->wflag = 1;
 80031c6:	e021      	b.n	800320c <put_fat+0xdc>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 80031c8:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80031ca:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 80031ce:	f7ff fefd 	bl	8002fcc <move_window>
			if (res != FR_OK) break;
 80031d2:	2800      	cmp	r0, #0
 80031d4:	d1c9      	bne.n	800316a <put_fat+0x3a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 80031d6:	0064      	lsls	r4, r4, #1
 80031d8:	f404 74ff 	and.w	r4, r4, #510	@ 0x1fe
 80031dc:	442c      	add	r4, r5
 80031de:	87a6      	strh	r6, [r4, #60]	@ 0x3c
			fs->wflag = 1;
 80031e0:	e014      	b.n	800320c <put_fat+0xdc>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 80031e2:	6a81      	ldr	r1, [r0, #40]	@ 0x28
 80031e4:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 80031e8:	f7ff fef0 	bl	8002fcc <move_window>
			if (res != FR_OK) break;
 80031ec:	2800      	cmp	r0, #0
 80031ee:	d1bc      	bne.n	800316a <put_fat+0x3a>
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 80031f0:	782b      	ldrb	r3, [r5, #0]
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 80031f2:	00a4      	lsls	r4, r4, #2
 80031f4:	f404 74fe 	and.w	r4, r4, #508	@ 0x1fc
			if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 80031f8:	2b04      	cmp	r3, #4
 80031fa:	442c      	add	r4, r5
 80031fc:	d005      	beq.n	800320a <put_fat+0xda>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 80031fe:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003200:	f026 4670 	bic.w	r6, r6, #4026531840	@ 0xf0000000
 8003204:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 8003208:	431e      	orrs	r6, r3
			st_dword(fs->win + clst * 4 % SS(fs), val);
 800320a:	63e6      	str	r6, [r4, #60]	@ 0x3c
			fs->wflag = 1;
 800320c:	2301      	movs	r3, #1
 800320e:	70eb      	strb	r3, [r5, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003210:	2000      	movs	r0, #0
 8003212:	e002      	b.n	800321a <put_fat+0xea>
	FRESULT res = FR_INT_ERR;
 8003214:	2002      	movs	r0, #2
}
 8003216:	4770      	bx	lr
	FRESULT res = FR_INT_ERR;
 8003218:	2002      	movs	r0, #2
}
 800321a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08003220 <fill_last_frag>:
{
 8003220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003222:	4604      	mov	r4, r0
 8003224:	460f      	mov	r7, r1
 8003226:	4616      	mov	r6, r2
	while (obj->n_frag > 0) {	/* Create the chain of last fragment */
 8003228:	69e3      	ldr	r3, [r4, #28]
 800322a:	b173      	cbz	r3, 800324a <fill_last_frag+0x2a>
		res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
 800322c:	2b01      	cmp	r3, #1
 800322e:	eba7 0503 	sub.w	r5, r7, r3
 8003232:	bf14      	ite	ne
 8003234:	1caa      	addne	r2, r5, #2
 8003236:	4632      	moveq	r2, r6
 8003238:	6820      	ldr	r0, [r4, #0]
 800323a:	1c69      	adds	r1, r5, #1
 800323c:	f7ff ff78 	bl	8003130 <put_fat>
		if (res != FR_OK) return res;
 8003240:	b920      	cbnz	r0, 800324c <fill_last_frag+0x2c>
		obj->n_frag--;
 8003242:	69e3      	ldr	r3, [r4, #28]
 8003244:	3b01      	subs	r3, #1
 8003246:	61e3      	str	r3, [r4, #28]
 8003248:	e7ee      	b.n	8003228 <fill_last_frag+0x8>
	return FR_OK;
 800324a:	4618      	mov	r0, r3
}
 800324c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003250 <fill_first_frag>:
	if (obj->stat == 3) {	/* Has the object been changed 'fragmented' in this session? */
 8003250:	79c3      	ldrb	r3, [r0, #7]
 8003252:	2b03      	cmp	r3, #3
 8003254:	d112      	bne.n	800327c <fill_first_frag+0x2c>
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 8003256:	6881      	ldr	r1, [r0, #8]
 8003258:	6983      	ldr	r3, [r0, #24]
{
 800325a:	b570      	push	{r4, r5, r6, lr}
 800325c:	4604      	mov	r4, r0
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 800325e:	18cd      	adds	r5, r1, r3
 8003260:	42a9      	cmp	r1, r5
 8003262:	d007      	beq.n	8003274 <fill_first_frag+0x24>
			res = put_fat(obj->fs, cl, cl + 1);
 8003264:	1c4e      	adds	r6, r1, #1
 8003266:	6820      	ldr	r0, [r4, #0]
 8003268:	4632      	mov	r2, r6
 800326a:	f7ff ff61 	bl	8003130 <put_fat>
			if (res != FR_OK) return res;
 800326e:	b920      	cbnz	r0, 800327a <fill_first_frag+0x2a>
		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
 8003270:	4631      	mov	r1, r6
 8003272:	e7f5      	b.n	8003260 <fill_first_frag+0x10>
		obj->stat = 0;	/* Change status 'FAT chain is valid' */
 8003274:	2300      	movs	r3, #0
 8003276:	71e3      	strb	r3, [r4, #7]
	return FR_OK;
 8003278:	2000      	movs	r0, #0
}
 800327a:	bd70      	pop	{r4, r5, r6, pc}
	return FR_OK;
 800327c:	2000      	movs	r0, #0
}
 800327e:	4770      	bx	lr

08003280 <get_fat>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8003280:	2901      	cmp	r1, #1
 8003282:	f240 8087 	bls.w	8003394 <get_fat+0x114>
{
 8003286:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = obj->fs;
 8003288:	6806      	ldr	r6, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800328a:	69f3      	ldr	r3, [r6, #28]
 800328c:	428b      	cmp	r3, r1
 800328e:	460c      	mov	r4, r1
 8003290:	f240 8082 	bls.w	8003398 <get_fat+0x118>
		switch (fs->fs_type) {
 8003294:	7833      	ldrb	r3, [r6, #0]
 8003296:	3b01      	subs	r3, #1
 8003298:	2b03      	cmp	r3, #3
 800329a:	d87d      	bhi.n	8003398 <get_fat+0x118>
 800329c:	e8df f003 	tbb	[pc, r3]
 80032a0:	47372902 	.word	0x47372902
			bc = (UINT)clst; bc += bc / 2;
 80032a4:	eb01 0551 	add.w	r5, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80032a8:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80032aa:	4630      	mov	r0, r6
 80032ac:	eb01 2155 	add.w	r1, r1, r5, lsr #9
 80032b0:	f7ff fe8c 	bl	8002fcc <move_window>
 80032b4:	b110      	cbz	r0, 80032bc <get_fat+0x3c>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80032b6:	f04f 30ff 	mov.w	r0, #4294967295
 80032ba:	e071      	b.n	80033a0 <get_fat+0x120>
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 80032bc:	1c6f      	adds	r7, r5, #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80032be:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 80032c0:	f3c5 0508 	ubfx	r5, r5, #0, #9
 80032c4:	4435      	add	r5, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80032c6:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 80032ca:	4630      	mov	r0, r6
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 80032cc:	f895 503c 	ldrb.w	r5, [r5, #60]	@ 0x3c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80032d0:	f7ff fe7c 	bl	8002fcc <move_window>
 80032d4:	2800      	cmp	r0, #0
 80032d6:	d1ee      	bne.n	80032b6 <get_fat+0x36>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 80032d8:	f3c7 0708 	ubfx	r7, r7, #0, #9
 80032dc:	4437      	add	r7, r6
 80032de:	f897 303c 	ldrb.w	r3, [r7, #60]	@ 0x3c
 80032e2:	ea45 2003 	orr.w	r0, r5, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 80032e6:	07e3      	lsls	r3, r4, #31
 80032e8:	bf4c      	ite	mi
 80032ea:	0900      	lsrmi	r0, r0, #4
 80032ec:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 80032f0:	e056      	b.n	80033a0 <get_fat+0x120>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80032f2:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 80032f4:	4630      	mov	r0, r6
 80032f6:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 80032fa:	f7ff fe67 	bl	8002fcc <move_window>
 80032fe:	2800      	cmp	r0, #0
 8003300:	d1d9      	bne.n	80032b6 <get_fat+0x36>
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 8003302:	0064      	lsls	r4, r4, #1
 8003304:	f404 74ff 	and.w	r4, r4, #510	@ 0x1fe
 8003308:	4434      	add	r4, r6
 800330a:	8fa0      	ldrh	r0, [r4, #60]	@ 0x3c
			break;
 800330c:	e048      	b.n	80033a0 <get_fat+0x120>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800330e:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8003310:	4630      	mov	r0, r6
 8003312:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8003316:	f7ff fe59 	bl	8002fcc <move_window>
 800331a:	2800      	cmp	r0, #0
 800331c:	d1cb      	bne.n	80032b6 <get_fat+0x36>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 800331e:	00a4      	lsls	r4, r4, #2
 8003320:	f404 74fe 	and.w	r4, r4, #508	@ 0x1fc
 8003324:	4434      	add	r4, r6
 8003326:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8003328:	f020 4070 	bic.w	r0, r0, #4026531840	@ 0xf0000000
			break;
 800332c:	e038      	b.n	80033a0 <get_fat+0x120>
			if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must have valid data length */
 800332e:	e9d0 3104 	ldrd	r3, r1, [r0, #16]
 8003332:	ea53 0201 	orrs.w	r2, r3, r1
 8003336:	79c5      	ldrb	r5, [r0, #7]
 8003338:	d001      	beq.n	800333e <get_fat+0xbe>
 800333a:	6882      	ldr	r2, [r0, #8]
 800333c:	b902      	cbnz	r2, 8003340 <get_fat+0xc0>
 800333e:	bb5d      	cbnz	r5, 8003398 <get_fat+0x118>
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 8003340:	6882      	ldr	r2, [r0, #8]
				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 8003342:	2d02      	cmp	r5, #2
				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 8003344:	eba4 0202 	sub.w	r2, r4, r2
				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 8003348:	d10d      	bne.n	8003366 <get_fat+0xe6>
				DWORD clen = (DWORD)((LBA_t)((obj->objsize - 1) / SS(fs)) / fs->csize);	/* Number of clusters - 1 */
 800334a:	3b01      	subs	r3, #1
 800334c:	f141 31ff 	adc.w	r1, r1, #4294967295
 8003350:	0a5b      	lsrs	r3, r3, #9
 8003352:	ea43 53c1 	orr.w	r3, r3, r1, lsl #23
 8003356:	8971      	ldrh	r1, [r6, #10]
 8003358:	fbb3 f3f1 	udiv	r3, r3, r1
				if (obj->stat == 2 && cofs <= clen) {	/* Is it a contiguous chain? */
 800335c:	429a      	cmp	r2, r3
 800335e:	d81b      	bhi.n	8003398 <get_fat+0x118>
					val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
 8003360:	d01c      	beq.n	800339c <get_fat+0x11c>
 8003362:	1c60      	adds	r0, r4, #1
 8003364:	e01c      	b.n	80033a0 <get_fat+0x120>
				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the 1st fragment? */
 8003366:	2d03      	cmp	r5, #3
 8003368:	d102      	bne.n	8003370 <get_fat+0xf0>
 800336a:	6983      	ldr	r3, [r0, #24]
 800336c:	4293      	cmp	r3, r2
 800336e:	d8f8      	bhi.n	8003362 <get_fat+0xe2>
					if (obj->n_frag != 0) {	/* Is it on the growing edge? */
 8003370:	69c3      	ldr	r3, [r0, #28]
 8003372:	b99b      	cbnz	r3, 800339c <get_fat+0x11c>
						if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8003374:	6ab1      	ldr	r1, [r6, #40]	@ 0x28
 8003376:	4630      	mov	r0, r6
 8003378:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 800337c:	f7ff fe26 	bl	8002fcc <move_window>
 8003380:	2800      	cmp	r0, #0
 8003382:	d198      	bne.n	80032b6 <get_fat+0x36>
						val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x7FFFFFFF;
 8003384:	00a4      	lsls	r4, r4, #2
 8003386:	f404 74fe 	and.w	r4, r4, #508	@ 0x1fc
 800338a:	4426      	add	r6, r4
 800338c:	6bf0      	ldr	r0, [r6, #60]	@ 0x3c
 800338e:	f020 4000 	bic.w	r0, r0, #2147483648	@ 0x80000000
 8003392:	e005      	b.n	80033a0 <get_fat+0x120>
 8003394:	2001      	movs	r0, #1
}
 8003396:	4770      	bx	lr
 8003398:	2001      	movs	r0, #1
 800339a:	e001      	b.n	80033a0 <get_fat+0x120>
					val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* No data on the FAT, generate the value */
 800339c:	f06f 4000 	mvn.w	r0, #2147483648	@ 0x80000000
}
 80033a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080033a4 <dir_sdi>:
{
 80033a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	FATFS *fs = dp->obj.fs;
 80033a6:	6805      	ldr	r5, [r0, #0]
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 80033a8:	782b      	ldrb	r3, [r5, #0]
 80033aa:	2b04      	cmp	r3, #4
 80033ac:	bf14      	ite	ne
 80033ae:	f44f 1200 	movne.w	r2, #2097152	@ 0x200000
 80033b2:	f04f 5280 	moveq.w	r2, #268435456	@ 0x10000000
 80033b6:	428a      	cmp	r2, r1
 80033b8:	d801      	bhi.n	80033be <dir_sdi+0x1a>
		return FR_INT_ERR;
 80033ba:	2002      	movs	r0, #2
 80033bc:	e038      	b.n	8003430 <dir_sdi+0x8c>
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 80033be:	06ca      	lsls	r2, r1, #27
 80033c0:	460c      	mov	r4, r1
 80033c2:	d1fa      	bne.n	80033ba <dir_sdi+0x16>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 80033c4:	6882      	ldr	r2, [r0, #8]
	dp->dptr = ofs;				/* Set current offset */
 80033c6:	6301      	str	r1, [r0, #48]	@ 0x30
 80033c8:	4606      	mov	r6, r0
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 80033ca:	b95a      	cbnz	r2, 80033e4 <dir_sdi+0x40>
 80033cc:	2b02      	cmp	r3, #2
 80033ce:	d805      	bhi.n	80033dc <dir_sdi+0x38>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 80033d0:	892b      	ldrh	r3, [r5, #8]
 80033d2:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
 80033d6:	d9f0      	bls.n	80033ba <dir_sdi+0x16>
		dp->sect = fs->dirbase;
 80033d8:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
 80033da:	e01a      	b.n	8003412 <dir_sdi+0x6e>
		clst = (DWORD)fs->dirbase;
 80033dc:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
		if (FF_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
 80033de:	71c2      	strb	r2, [r0, #7]
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 80033e0:	b90b      	cbnz	r3, 80033e6 <dir_sdi+0x42>
 80033e2:	e7f5      	b.n	80033d0 <dir_sdi+0x2c>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 80033e4:	4613      	mov	r3, r2
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80033e6:	896f      	ldrh	r7, [r5, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 80033e8:	461a      	mov	r2, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80033ea:	027f      	lsls	r7, r7, #9
		while (ofs >= csz) {				/* Follow cluster chain */
 80033ec:	42bc      	cmp	r4, r7
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80033ee:	4611      	mov	r1, r2
		while (ofs >= csz) {				/* Follow cluster chain */
 80033f0:	d30c      	bcc.n	800340c <dir_sdi+0x68>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80033f2:	4630      	mov	r0, r6
 80033f4:	f7ff ff44 	bl	8003280 <get_fat>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80033f8:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80033fa:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80033fc:	d017      	beq.n	800342e <dir_sdi+0x8a>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 80033fe:	2801      	cmp	r0, #1
 8003400:	d9db      	bls.n	80033ba <dir_sdi+0x16>
 8003402:	69eb      	ldr	r3, [r5, #28]
 8003404:	4283      	cmp	r3, r0
 8003406:	d9d8      	bls.n	80033ba <dir_sdi+0x16>
			ofs -= csz;
 8003408:	1be4      	subs	r4, r4, r7
 800340a:	e7ef      	b.n	80033ec <dir_sdi+0x48>
		dp->sect = clst2sect(fs, clst);
 800340c:	4628      	mov	r0, r5
 800340e:	f7ff fcf1 	bl	8002df4 <clst2sect>
	dp->clust = clst;					/* Current cluster# */
 8003412:	e9c6 200d 	strd	r2, r0, [r6, #52]	@ 0x34
	if (dp->sect == 0) return FR_INT_ERR;
 8003416:	2800      	cmp	r0, #0
 8003418:	d0cf      	beq.n	80033ba <dir_sdi+0x16>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800341a:	eb00 2054 	add.w	r0, r0, r4, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800341e:	353c      	adds	r5, #60	@ 0x3c
 8003420:	f3c4 0408 	ubfx	r4, r4, #0, #9
 8003424:	4425      	add	r5, r4
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8003426:	63b0      	str	r0, [r6, #56]	@ 0x38
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8003428:	63f5      	str	r5, [r6, #60]	@ 0x3c
	return FR_OK;
 800342a:	2000      	movs	r0, #0
 800342c:	e000      	b.n	8003430 <dir_sdi+0x8c>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800342e:	2001      	movs	r0, #1
}
 8003430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003434 <remove_chain>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8003434:	2901      	cmp	r1, #1
{
 8003436:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs = obj->fs;
 800343a:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800343c:	d801      	bhi.n	8003442 <remove_chain+0xe>
 800343e:	2002      	movs	r0, #2
 8003440:	e077      	b.n	8003532 <remove_chain+0xfe>
 8003442:	69eb      	ldr	r3, [r5, #28]
 8003444:	428b      	cmp	r3, r1
 8003446:	460c      	mov	r4, r1
 8003448:	d9f9      	bls.n	800343e <remove_chain+0xa>
 800344a:	4606      	mov	r6, r0
 800344c:	4617      	mov	r7, r2
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800344e:	b90a      	cbnz	r2, 8003454 <remove_chain+0x20>
{
 8003450:	46a1      	mov	r9, r4
 8003452:	e027      	b.n	80034a4 <remove_chain+0x70>
	if (pclst != 0 && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 8003454:	782b      	ldrb	r3, [r5, #0]
 8003456:	2b04      	cmp	r3, #4
 8003458:	d102      	bne.n	8003460 <remove_chain+0x2c>
 800345a:	79c3      	ldrb	r3, [r0, #7]
 800345c:	2b02      	cmp	r3, #2
 800345e:	d0f7      	beq.n	8003450 <remove_chain+0x1c>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 8003460:	f04f 32ff 	mov.w	r2, #4294967295
 8003464:	4639      	mov	r1, r7
 8003466:	4628      	mov	r0, r5
 8003468:	f7ff fe62 	bl	8003130 <put_fat>
		if (res != FR_OK) return res;
 800346c:	2800      	cmp	r0, #0
 800346e:	d0ef      	beq.n	8003450 <remove_chain+0x1c>
 8003470:	e05f      	b.n	8003532 <remove_chain+0xfe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8003472:	2801      	cmp	r0, #1
 8003474:	d0e3      	beq.n	800343e <remove_chain+0xa>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8003476:	1c42      	adds	r2, r0, #1
 8003478:	d02d      	beq.n	80034d6 <remove_chain+0xa2>
		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {
 800347a:	782b      	ldrb	r3, [r5, #0]
 800347c:	2b04      	cmp	r3, #4
 800347e:	d12c      	bne.n	80034da <remove_chain+0xa6>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 8003480:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
 8003484:	3a02      	subs	r2, #2
 8003486:	4293      	cmp	r3, r2
 8003488:	d205      	bcs.n	8003496 <remove_chain+0x62>
			fs->free_clst++;
 800348a:	3301      	adds	r3, #1
 800348c:	61ab      	str	r3, [r5, #24]
			fs->fsi_flag |= 1;
 800348e:	792b      	ldrb	r3, [r5, #4]
 8003490:	f043 0301 	orr.w	r3, r3, #1
 8003494:	712b      	strb	r3, [r5, #4]
		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
 8003496:	f108 0201 	add.w	r2, r8, #1
 800349a:	42a2      	cmp	r2, r4
 800349c:	d125      	bne.n	80034ea <remove_chain+0xb6>
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 800349e:	69eb      	ldr	r3, [r5, #28]
 80034a0:	42a3      	cmp	r3, r4
 80034a2:	d907      	bls.n	80034b4 <remove_chain+0x80>
		nxt = get_fat(obj, clst);			/* Get cluster status */
 80034a4:	4621      	mov	r1, r4
 80034a6:	4630      	mov	r0, r6
 80034a8:	f7ff feea 	bl	8003280 <get_fat>
		if (nxt == 0) break;				/* Empty cluster? */
 80034ac:	46a0      	mov	r8, r4
 80034ae:	4604      	mov	r4, r0
 80034b0:	2800      	cmp	r0, #0
 80034b2:	d1de      	bne.n	8003472 <remove_chain+0x3e>
	if (fs->fs_type == FS_EXFAT) {
 80034b4:	782b      	ldrb	r3, [r5, #0]
 80034b6:	2b04      	cmp	r3, #4
 80034b8:	d129      	bne.n	800350e <remove_chain+0xda>
 80034ba:	e025      	b.n	8003508 <remove_chain+0xd4>
			if (obj->stat == 0) {	/* Is it a fragmented chain from the beginning of this session? */
 80034bc:	79f3      	ldrb	r3, [r6, #7]
 80034be:	bb63      	cbnz	r3, 800351a <remove_chain+0xe6>
				clst = obj->sclust;		/* Follow the chain to check if it gets contiguous */
 80034c0:	68b4      	ldr	r4, [r6, #8]
				while (clst != pclst) {
 80034c2:	42bc      	cmp	r4, r7
 80034c4:	d032      	beq.n	800352c <remove_chain+0xf8>
					nxt = get_fat(obj, clst);
 80034c6:	4621      	mov	r1, r4
 80034c8:	4630      	mov	r0, r6
 80034ca:	f7ff fed9 	bl	8003280 <get_fat>
					if (nxt < 2) return FR_INT_ERR;
 80034ce:	2801      	cmp	r0, #1
 80034d0:	d9b5      	bls.n	800343e <remove_chain+0xa>
					if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
 80034d2:	1c43      	adds	r3, r0, #1
 80034d4:	d11d      	bne.n	8003512 <remove_chain+0xde>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 80034d6:	2001      	movs	r0, #1
 80034d8:	e02b      	b.n	8003532 <remove_chain+0xfe>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 80034da:	2200      	movs	r2, #0
 80034dc:	4641      	mov	r1, r8
 80034de:	4628      	mov	r0, r5
 80034e0:	f7ff fe26 	bl	8003130 <put_fat>
			if (res != FR_OK) return res;
 80034e4:	2800      	cmp	r0, #0
 80034e6:	d0cb      	beq.n	8003480 <remove_chain+0x4c>
 80034e8:	e023      	b.n	8003532 <remove_chain+0xfe>
			if (fs->fs_type == FS_EXFAT) {
 80034ea:	782b      	ldrb	r3, [r5, #0]
 80034ec:	2b04      	cmp	r3, #4
 80034ee:	d001      	beq.n	80034f4 <remove_chain+0xc0>
			scl = ecl = nxt;
 80034f0:	46a1      	mov	r9, r4
 80034f2:	e7d4      	b.n	800349e <remove_chain+0x6a>
				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
 80034f4:	2300      	movs	r3, #0
 80034f6:	eba2 0209 	sub.w	r2, r2, r9
 80034fa:	4649      	mov	r1, r9
 80034fc:	4628      	mov	r0, r5
 80034fe:	f7ff fddb 	bl	80030b8 <change_bitmap>
				if (res != FR_OK) return res;
 8003502:	2800      	cmp	r0, #0
 8003504:	d0f4      	beq.n	80034f0 <remove_chain+0xbc>
 8003506:	e014      	b.n	8003532 <remove_chain+0xfe>
		if (pclst == 0) {	/* Has the entire chain been removed? */
 8003508:	2f00      	cmp	r7, #0
 800350a:	d1d7      	bne.n	80034bc <remove_chain+0x88>
			obj->stat = 0;		/* Change the chain status 'initial' */
 800350c:	71f7      	strb	r7, [r6, #7]
	return FR_OK;
 800350e:	2000      	movs	r0, #0
 8003510:	e00f      	b.n	8003532 <remove_chain+0xfe>
					if (nxt != clst + 1) break;	/* Not contiguous? */
 8003512:	3401      	adds	r4, #1
 8003514:	4284      	cmp	r4, r0
 8003516:	d0d4      	beq.n	80034c2 <remove_chain+0x8e>
 8003518:	e7f9      	b.n	800350e <remove_chain+0xda>
				if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Was the chain fragmented in this session and got contiguous again? */
 800351a:	2b03      	cmp	r3, #3
 800351c:	d1f7      	bne.n	800350e <remove_chain+0xda>
 800351e:	68b3      	ldr	r3, [r6, #8]
 8003520:	42bb      	cmp	r3, r7
 8003522:	d8f4      	bhi.n	800350e <remove_chain+0xda>
 8003524:	69b2      	ldr	r2, [r6, #24]
 8003526:	4413      	add	r3, r2
 8003528:	42bb      	cmp	r3, r7
 800352a:	d3f0      	bcc.n	800350e <remove_chain+0xda>
					obj->stat = 2;		/* Change the chain status 'contiguous' */
 800352c:	2302      	movs	r3, #2
 800352e:	71f3      	strb	r3, [r6, #7]
 8003530:	e7ed      	b.n	800350e <remove_chain+0xda>
}
 8003532:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08003538 <dir_clear>:
{
 8003538:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800353c:	4605      	mov	r5, r0
 800353e:	460e      	mov	r6, r1
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8003540:	f7ff fd22 	bl	8002f88 <sync_window>
 8003544:	4604      	mov	r4, r0
 8003546:	bb00      	cbnz	r0, 800358a <dir_clear+0x52>
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 8003548:	4631      	mov	r1, r6
 800354a:	4628      	mov	r0, r5
 800354c:	f7ff fc52 	bl	8002df4 <clst2sect>
	memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 8003550:	f105 083c 	add.w	r8, r5, #60	@ 0x3c
	fs->winsect = sect;				/* Set window to top of the cluster */
 8003554:	63a8      	str	r0, [r5, #56]	@ 0x38
	sect = clst2sect(fs, clst);		/* Top of the cluster */
 8003556:	4607      	mov	r7, r0
	memset(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 8003558:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800355c:	4621      	mov	r1, r4
 800355e:	4640      	mov	r0, r8
 8003560:	f7ff fc34 	bl	8002dcc <mem_set>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8003564:	4626      	mov	r6, r4
 8003566:	896b      	ldrh	r3, [r5, #10]
 8003568:	42b3      	cmp	r3, r6
 800356a:	d804      	bhi.n	8003576 <dir_clear+0x3e>
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
 800356c:	896c      	ldrh	r4, [r5, #10]
 800356e:	1ba4      	subs	r4, r4, r6
 8003570:	bf18      	it	ne
 8003572:	2401      	movne	r4, #1
 8003574:	e009      	b.n	800358a <dir_clear+0x52>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8003576:	7868      	ldrb	r0, [r5, #1]
 8003578:	2301      	movs	r3, #1
 800357a:	19f2      	adds	r2, r6, r7
 800357c:	4641      	mov	r1, r8
 800357e:	f00e f833 	bl	80115e8 <disk_write>
 8003582:	2800      	cmp	r0, #0
 8003584:	d1f2      	bne.n	800356c <dir_clear+0x34>
 8003586:	3601      	adds	r6, #1
 8003588:	e7ed      	b.n	8003566 <dir_clear+0x2e>
}
 800358a:	4620      	mov	r0, r4
 800358c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003590 <put_utf>:
{
 8003590:	b538      	push	{r3, r4, r5, lr}
 8003592:	460d      	mov	r5, r1
	wc = ff_uni2oem(chr, CODEPAGE);
 8003594:	f240 3162 	movw	r1, #866	@ 0x362
{
 8003598:	4614      	mov	r4, r2
	wc = ff_uni2oem(chr, CODEPAGE);
 800359a:	f001 fe75 	bl	8005288 <ff_uni2oem>
	if (wc >= 0x100) {	/* Is this a DBC? */
 800359e:	28ff      	cmp	r0, #255	@ 0xff
 80035a0:	d906      	bls.n	80035b0 <put_utf+0x20>
		if (szb < 2) return 0;
 80035a2:	2c01      	cmp	r4, #1
 80035a4:	d909      	bls.n	80035ba <put_utf+0x2a>
		*buf++ = (char)(wc >> 8);	/* Store DBC 1st byte */
 80035a6:	0a03      	lsrs	r3, r0, #8
 80035a8:	702b      	strb	r3, [r5, #0]
		*buf++ = (TCHAR)wc;			/* Store DBC 2nd byte */
 80035aa:	7068      	strb	r0, [r5, #1]
		return 2;
 80035ac:	2402      	movs	r4, #2
 80035ae:	e007      	b.n	80035c0 <put_utf+0x30>
	if (wc == 0 || szb < 1) return 0;	/* Invalid char or buffer overflow? */
 80035b0:	b128      	cbz	r0, 80035be <put_utf+0x2e>
 80035b2:	b12c      	cbz	r4, 80035c0 <put_utf+0x30>
	*buf++ = (TCHAR)wc;					/* Store the character */
 80035b4:	7028      	strb	r0, [r5, #0]
	return 1;
 80035b6:	2401      	movs	r4, #1
 80035b8:	e002      	b.n	80035c0 <put_utf+0x30>
		if (szb < 2) return 0;
 80035ba:	2400      	movs	r4, #0
 80035bc:	e000      	b.n	80035c0 <put_utf+0x30>
 80035be:	4604      	mov	r4, r0
}
 80035c0:	4620      	mov	r0, r4
 80035c2:	bd38      	pop	{r3, r4, r5, pc}

080035c4 <get_fileinfo>:
{
 80035c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	fno->fname[0] = 0;			/* Invaidate file info */
 80035c8:	2500      	movs	r5, #0
	FATFS *fs = dp->obj.fs;
 80035ca:	6807      	ldr	r7, [r0, #0]
	fno->fname[0] = 0;			/* Invaidate file info */
 80035cc:	768d      	strb	r5, [r1, #26]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
 80035ce:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 80035d0:	2b00      	cmp	r3, #0
 80035d2:	f000 80c3 	beq.w	800375c <get_fileinfo+0x198>
	if (fs->fs_type == FS_EXFAT) {	/* exFAT volume */
 80035d6:	783b      	ldrb	r3, [r7, #0]
 80035d8:	2b04      	cmp	r3, #4
 80035da:	460c      	mov	r4, r1
 80035dc:	d145      	bne.n	800366a <get_fileinfo+0xa6>
		hs = 0;
 80035de:	462b      	mov	r3, r5
		si = SZDIRE * 2; di = 0;	/* 1st C1 entry in the entry block */
 80035e0:	462e      	mov	r6, r5
 80035e2:	f04f 0840 	mov.w	r8, #64	@ 0x40
		while (nc < fs->dirbuf[XDIR_NumName]) {
 80035e6:	693a      	ldr	r2, [r7, #16]
 80035e8:	f892 1023 	ldrb.w	r1, [r2, #35]	@ 0x23
 80035ec:	42a9      	cmp	r1, r5
 80035ee:	d921      	bls.n	8003634 <get_fileinfo+0x70>
			if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
 80035f0:	f1b8 0f7f 	cmp.w	r8, #127	@ 0x7f
 80035f4:	d820      	bhi.n	8003638 <get_fileinfo+0x74>
			if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
 80035f6:	f018 0f1f 	tst.w	r8, #31
 80035fa:	bf08      	it	eq
 80035fc:	f108 0802 	addeq.w	r8, r8, #2
			wc = ld_word(fs->dirbuf + si); si += 2; nc++;	/* Get a character */
 8003600:	3501      	adds	r5, #1
 8003602:	f832 0008 	ldrh.w	r0, [r2, r8]
 8003606:	f108 0802 	add.w	r8, r8, #2
			if (hs == 0 && IsSurrogate(wc)) {		/* Is it a surrogate? */
 800360a:	b92b      	cbnz	r3, 8003618 <get_fileinfo+0x54>
 800360c:	f500 5220 	add.w	r2, r0, #10240	@ 0x2800
 8003610:	b292      	uxth	r2, r2
 8003612:	f5b2 6f00 	cmp.w	r2, #2048	@ 0x800
 8003616:	d30b      	bcc.n	8003630 <get_fileinfo+0x6c>
			nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
 8003618:	f106 011a 	add.w	r1, r6, #26
 800361c:	f1c6 0220 	rsb	r2, r6, #32
 8003620:	4421      	add	r1, r4
 8003622:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8003626:	f7ff ffb3 	bl	8003590 <put_utf>
			if (nw == 0) { di = 0; break; }			/* Buffer overflow or wrong char? */
 800362a:	b128      	cbz	r0, 8003638 <get_fileinfo+0x74>
			di += nw;
 800362c:	4406      	add	r6, r0
			hs = 0;
 800362e:	2000      	movs	r0, #0
 8003630:	4603      	mov	r3, r0
 8003632:	e7d8      	b.n	80035e6 <get_fileinfo+0x22>
		if (hs != 0) di = 0;					/* Broken surrogate pair? */
 8003634:	b903      	cbnz	r3, 8003638 <get_fileinfo+0x74>
		if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
 8003636:	b916      	cbnz	r6, 800363e <get_fileinfo+0x7a>
 8003638:	233f      	movs	r3, #63	@ 0x3f
 800363a:	76a3      	strb	r3, [r4, #26]
 800363c:	2601      	movs	r6, #1
		fno->fname[di] = 0;						/* Terminate the name */
 800363e:	4426      	add	r6, r4
 8003640:	2300      	movs	r3, #0
 8003642:	76b3      	strb	r3, [r6, #26]
		fno->altname[0] = 0;					/* exFAT does not support SFN */
 8003644:	7363      	strb	r3, [r4, #13]
		fno->fattrib = fs->dirbuf[XDIR_Attr] & AM_MASKX;		/* Attribute */
 8003646:	693b      	ldr	r3, [r7, #16]
 8003648:	791a      	ldrb	r2, [r3, #4]
 800364a:	f002 0137 	and.w	r1, r2, #55	@ 0x37
 800364e:	7321      	strb	r1, [r4, #12]
		fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 8003650:	06d2      	lsls	r2, r2, #27
 8003652:	bf58      	it	pl
 8003654:	e9d3 010e 	ldrdpl	r0, r1, [r3, #56]	@ 0x38
		fno->ftime = ld_word(fs->dirbuf + XDIR_ModTime + 0);	/* Time */
 8003658:	899a      	ldrh	r2, [r3, #12]
 800365a:	8162      	strh	r2, [r4, #10]
		fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 800365c:	bf44      	itt	mi
 800365e:	2000      	movmi	r0, #0
 8003660:	2100      	movmi	r1, #0
 8003662:	e9c4 0100 	strd	r0, r1, [r4]
		fno->fdate = ld_word(fs->dirbuf + XDIR_ModTime + 2);	/* Date */
 8003666:	89db      	ldrh	r3, [r3, #14]
 8003668:	e077      	b.n	800375a <get_fileinfo+0x196>
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 800366a:	6cc3      	ldr	r3, [r0, #76]	@ 0x4c
 800366c:	3301      	adds	r3, #1
 800366e:	4606      	mov	r6, r0
 8003670:	d024      	beq.n	80036bc <get_fileinfo+0xf8>
			hs = 0;
 8003672:	46a9      	mov	r9, r5
			si = di = 0;
 8003674:	46a8      	mov	r8, r5
			while (fs->lfnbuf[si] != 0) {
 8003676:	68fb      	ldr	r3, [r7, #12]
 8003678:	5b58      	ldrh	r0, [r3, r5]
 800367a:	b1b8      	cbz	r0, 80036ac <get_fileinfo+0xe8>
				if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
 800367c:	f1b9 0f00 	cmp.w	r9, #0
 8003680:	d105      	bne.n	800368e <get_fileinfo+0xca>
 8003682:	f500 5320 	add.w	r3, r0, #10240	@ 0x2800
 8003686:	b29b      	uxth	r3, r3
 8003688:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800368c:	d30b      	bcc.n	80036a6 <get_fileinfo+0xe2>
				nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
 800368e:	f108 011a 	add.w	r1, r8, #26
 8003692:	f1c8 0220 	rsb	r2, r8, #32
 8003696:	4421      	add	r1, r4
 8003698:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800369c:	f7ff ff78 	bl	8003590 <put_utf>
				if (nw == 0) { di = 0; break; }	/* Buffer overflow or wrong char? */
 80036a0:	b128      	cbz	r0, 80036ae <get_fileinfo+0xea>
				di += nw;
 80036a2:	4480      	add	r8, r0
				hs = 0;
 80036a4:	2000      	movs	r0, #0
 80036a6:	3502      	adds	r5, #2
 80036a8:	4681      	mov	r9, r0
 80036aa:	e7e4      	b.n	8003676 <get_fileinfo+0xb2>
 80036ac:	4640      	mov	r0, r8
			if (hs != 0) di = 0;	/* Broken surrogate pair? */
 80036ae:	f1b9 0f00 	cmp.w	r9, #0
 80036b2:	bf18      	it	ne
 80036b4:	2000      	movne	r0, #0
			fno->fname[di] = 0;		/* Terminate the LFN (null string means LFN is invalid) */
 80036b6:	1823      	adds	r3, r4, r0
 80036b8:	2200      	movs	r2, #0
 80036ba:	769a      	strb	r2, [r3, #26]
		wc = dp->dir[si++];			/* Get a char */
 80036bc:	6bf1      	ldr	r1, [r6, #60]	@ 0x3c
 80036be:	2300      	movs	r3, #0
 80036c0:	1e4d      	subs	r5, r1, #1
 80036c2:	4618      	mov	r0, r3
 80036c4:	f815 2f01 	ldrb.w	r2, [r5, #1]!
		if (wc == ' ') continue;	/* Skip padding spaces */
 80036c8:	2a20      	cmp	r2, #32
		wc = dp->dir[si++];			/* Get a char */
 80036ca:	f100 0001 	add.w	r0, r0, #1
		if (wc == ' ') continue;	/* Skip padding spaces */
 80036ce:	d00d      	beq.n	80036ec <get_fileinfo+0x128>
		if (wc == RDDEM) wc = DDEM;	/* Restore replaced DDEM character */
 80036d0:	2a05      	cmp	r2, #5
 80036d2:	bf08      	it	eq
 80036d4:	22e5      	moveq	r2, #229	@ 0xe5
		if (si == 9 && di < FF_SFN_BUF) fno->altname[di++] = '.';	/* Insert a . if extension is exist */
 80036d6:	2809      	cmp	r0, #9
 80036d8:	d105      	bne.n	80036e6 <get_fileinfo+0x122>
 80036da:	2b0b      	cmp	r3, #11
 80036dc:	d803      	bhi.n	80036e6 <get_fileinfo+0x122>
 80036de:	18e6      	adds	r6, r4, r3
 80036e0:	272e      	movs	r7, #46	@ 0x2e
 80036e2:	7377      	strb	r7, [r6, #13]
 80036e4:	3301      	adds	r3, #1
		fno->altname[di++] = (TCHAR)wc;	/* Store it without any conversion */
 80036e6:	18e6      	adds	r6, r4, r3
 80036e8:	3301      	adds	r3, #1
 80036ea:	7372      	strb	r2, [r6, #13]
	while (si < 11) {		/* Get SFN from SFN entry */
 80036ec:	280b      	cmp	r0, #11
 80036ee:	d1e9      	bne.n	80036c4 <get_fileinfo+0x100>
	fno->altname[di] = 0;	/* Terminate the SFN  (null string means SFN is invalid) */
 80036f0:	18e2      	adds	r2, r4, r3
 80036f2:	2000      	movs	r0, #0
 80036f4:	7350      	strb	r0, [r2, #13]
	if (fno->fname[0] == 0) {	/* If LFN is invalid, altname[] needs to be copied to fname[] */
 80036f6:	7ea2      	ldrb	r2, [r4, #26]
 80036f8:	bb22      	cbnz	r2, 8003744 <get_fileinfo+0x180>
		if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
 80036fa:	b11b      	cbz	r3, 8003704 <get_fileinfo+0x140>
 80036fc:	f104 030c 	add.w	r3, r4, #12
			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 8003700:	2008      	movs	r0, #8
 8003702:	e00b      	b.n	800371c <get_fileinfo+0x158>
			fno->fname[di++] = '?';
 8003704:	233f      	movs	r3, #63	@ 0x3f
 8003706:	76a3      	strb	r3, [r4, #26]
 8003708:	2301      	movs	r3, #1
 800370a:	e015      	b.n	8003738 <get_fileinfo+0x174>
				if (wc == '.') lcf = NS_EXT;
 800370c:	2a2e      	cmp	r2, #46	@ 0x2e
				wc = (WCHAR)fno->altname[si];
 800370e:	4613      	mov	r3, r2
				if (wc == '.') lcf = NS_EXT;
 8003710:	d00e      	beq.n	8003730 <get_fileinfo+0x16c>
				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
 8003712:	3a41      	subs	r2, #65	@ 0x41
 8003714:	2a19      	cmp	r2, #25
 8003716:	d906      	bls.n	8003726 <get_fileinfo+0x162>
				fno->fname[di] = (TCHAR)wc;
 8003718:	736b      	strb	r3, [r5, #13]
 800371a:	462b      	mov	r3, r5
			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 800371c:	785a      	ldrb	r2, [r3, #1]
 800371e:	1c5d      	adds	r5, r3, #1
 8003720:	2a00      	cmp	r2, #0
 8003722:	d1f3      	bne.n	800370c <get_fileinfo+0x148>
 8003724:	e006      	b.n	8003734 <get_fileinfo+0x170>
				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
 8003726:	7b0a      	ldrb	r2, [r1, #12]
 8003728:	4210      	tst	r0, r2
 800372a:	d0f5      	beq.n	8003718 <get_fileinfo+0x154>
 800372c:	3320      	adds	r3, #32
 800372e:	e7f3      	b.n	8003718 <get_fileinfo+0x154>
				if (wc == '.') lcf = NS_EXT;
 8003730:	2010      	movs	r0, #16
 8003732:	e7f1      	b.n	8003718 <get_fileinfo+0x154>
 8003734:	1b1b      	subs	r3, r3, r4
 8003736:	3b0c      	subs	r3, #12
		fno->fname[di] = 0;	/* Terminate the LFN */
 8003738:	4423      	add	r3, r4
 800373a:	2200      	movs	r2, #0
 800373c:	769a      	strb	r2, [r3, #26]
		if (!dp->dir[DIR_NTres]) fno->altname[0] = 0;	/* Altname is not needed if neither LFN nor case info is exist. */
 800373e:	7b0b      	ldrb	r3, [r1, #12]
 8003740:	b903      	cbnz	r3, 8003744 <get_fileinfo+0x180>
 8003742:	7363      	strb	r3, [r4, #13]
	fno->fattrib = dp->dir[DIR_Attr] & AM_MASK;			/* Attribute */
 8003744:	7acb      	ldrb	r3, [r1, #11]
 8003746:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800374a:	7323      	strb	r3, [r4, #12]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
 800374c:	69cb      	ldr	r3, [r1, #28]
 800374e:	6023      	str	r3, [r4, #0]
 8003750:	2300      	movs	r3, #0
 8003752:	6063      	str	r3, [r4, #4]
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
 8003754:	8acb      	ldrh	r3, [r1, #22]
 8003756:	8163      	strh	r3, [r4, #10]
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
 8003758:	8b0b      	ldrh	r3, [r1, #24]
 800375a:	8123      	strh	r3, [r4, #8]
}
 800375c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08003760 <xname_sum>:
{
 8003760:	b538      	push	{r3, r4, r5, lr}
 8003762:	4605      	mov	r5, r0
	WORD sum = 0;
 8003764:	2400      	movs	r4, #0
	while ((chr = *name++) != 0) {
 8003766:	f835 0b02 	ldrh.w	r0, [r5], #2
 800376a:	b188      	cbz	r0, 8003790 <xname_sum+0x30>
		chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
 800376c:	f001 fdbc 	bl	80052e8 <ff_wtoupper>
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 8003770:	03e3      	lsls	r3, r4, #15
 8003772:	ea43 0354 	orr.w	r3, r3, r4, lsr #1
 8003776:	b2c2      	uxtb	r2, r0
 8003778:	fa12 f383 	uxtah	r3, r2, r3
		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 800377c:	f3c3 044e 	ubfx	r4, r3, #1, #15
 8003780:	ea44 34c3 	orr.w	r4, r4, r3, lsl #15
 8003784:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8003788:	fa10 f484 	uxtah	r4, r0, r4
 800378c:	b2a4      	uxth	r4, r4
 800378e:	e7ea      	b.n	8003766 <xname_sum+0x6>
}
 8003790:	4620      	mov	r0, r4
 8003792:	bd38      	pop	{r3, r4, r5, pc}

08003794 <sync_fs>:
{
 8003794:	b570      	push	{r4, r5, r6, lr}
 8003796:	4604      	mov	r4, r0
	res = sync_window(fs);
 8003798:	f7ff fbf6 	bl	8002f88 <sync_window>
	if (res == FR_OK) {
 800379c:	bb88      	cbnz	r0, 8003802 <sync_fs+0x6e>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 800379e:	7823      	ldrb	r3, [r4, #0]
 80037a0:	2b03      	cmp	r3, #3
 80037a2:	d126      	bne.n	80037f2 <sync_fs+0x5e>
 80037a4:	7923      	ldrb	r3, [r4, #4]
 80037a6:	2b01      	cmp	r3, #1
 80037a8:	d123      	bne.n	80037f2 <sync_fs+0x5e>
			memset(fs->win, 0, sizeof fs->win);
 80037aa:	f104 063c 	add.w	r6, r4, #60	@ 0x3c
 80037ae:	4601      	mov	r1, r0
 80037b0:	4605      	mov	r5, r0
 80037b2:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80037b6:	4630      	mov	r0, r6
 80037b8:	f7ff fb08 	bl	8002dcc <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);					/* Boot signature */
 80037bc:	f64a 2255 	movw	r2, #43605	@ 0xaa55
 80037c0:	f8a4 223a 	strh.w	r2, [r4, #570]	@ 0x23a
			st_dword(fs->win + FSI_LeadSig, 0x41615252);		/* Leading signature */
 80037c4:	4a0f      	ldr	r2, [pc, #60]	@ (8003804 <sync_fs+0x70>)
 80037c6:	63e2      	str	r2, [r4, #60]	@ 0x3c
			st_dword(fs->win + FSI_StrucSig, 0x61417272);		/* Structure signature */
 80037c8:	f102 52ff 	add.w	r2, r2, #534773760	@ 0x1fe00000
 80037cc:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 80037d0:	3220      	adds	r2, #32
 80037d2:	f8c4 2220 	str.w	r2, [r4, #544]	@ 0x220
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);	/* Number of free clusters */
 80037d6:	69a2      	ldr	r2, [r4, #24]
 80037d8:	f8c4 2224 	str.w	r2, [r4, #548]	@ 0x224
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);	/* Last allocated culuster */
 80037dc:	6962      	ldr	r2, [r4, #20]
 80037de:	f8c4 2228 	str.w	r2, [r4, #552]	@ 0x228
			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
 80037e2:	6a62      	ldr	r2, [r4, #36]	@ 0x24
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 80037e4:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;						/* Write it into the FSInfo sector (Next to VBR) */
 80037e6:	3201      	adds	r2, #1
 80037e8:	63a2      	str	r2, [r4, #56]	@ 0x38
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
 80037ea:	4631      	mov	r1, r6
 80037ec:	f00d fefc 	bl	80115e8 <disk_write>
			fs->fsi_flag = 0;
 80037f0:	7125      	strb	r5, [r4, #4]
		if (disk_ioctl(fs->pdrv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 80037f2:	2200      	movs	r2, #0
 80037f4:	7860      	ldrb	r0, [r4, #1]
 80037f6:	4611      	mov	r1, r2
 80037f8:	f00d ff46 	bl	8011688 <disk_ioctl>
 80037fc:	3800      	subs	r0, #0
 80037fe:	bf18      	it	ne
 8003800:	2001      	movne	r0, #1
}
 8003802:	bd70      	pop	{r4, r5, r6, pc}
 8003804:	41615252 	.word	0x41615252

08003808 <mount_volume>:
{
 8003808:	b5f0      	push	{r4, r5, r6, r7, lr}
	*rfs = 0;
 800380a:	2300      	movs	r3, #0
{
 800380c:	b085      	sub	sp, #20
	*rfs = 0;
 800380e:	600b      	str	r3, [r1, #0]
{
 8003810:	460e      	mov	r6, r1
 8003812:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
 8003814:	f7ff fb88 	bl	8002f28 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003818:	3001      	adds	r0, #1
 800381a:	f000 8111 	beq.w	8003a40 <mount_volume+0x238>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 800381e:	4b8b      	ldr	r3, [pc, #556]	@ (8003a4c <mount_volume+0x244>)
 8003820:	681c      	ldr	r4, [r3, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 8003822:	2c00      	cmp	r4, #0
 8003824:	f000 810e 	beq.w	8003a44 <mount_volume+0x23c>
	*rfs = fs;							/* Return pointer to the filesystem object */
 8003828:	6034      	str	r4, [r6, #0]
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 800382a:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 800382c:	f005 05fe 	and.w	r5, r5, #254	@ 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 8003830:	b15b      	cbz	r3, 800384a <mount_volume+0x42>
		stat = disk_status(fs->pdrv);
 8003832:	7860      	ldrb	r0, [r4, #1]
 8003834:	f00d fe8a 	bl	801154c <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8003838:	07c3      	lsls	r3, r0, #31
 800383a:	d406      	bmi.n	800384a <mount_volume+0x42>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 800383c:	b90d      	cbnz	r5, 8003842 <mount_volume+0x3a>
			return FR_OK;				/* The filesystem object is already valid */
 800383e:	2000      	movs	r0, #0
 8003840:	e186      	b.n	8003b50 <mount_volume+0x348>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8003842:	0747      	lsls	r7, r0, #29
 8003844:	d5fb      	bpl.n	800383e <mount_volume+0x36>
				return FR_WRITE_PROTECTED;
 8003846:	200a      	movs	r0, #10
 8003848:	e182      	b.n	8003b50 <mount_volume+0x348>
	fs->fs_type = 0;					/* Clear the filesystem object */
 800384a:	2000      	movs	r0, #0
 800384c:	8020      	strh	r0, [r4, #0]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 800384e:	f00d fdf9 	bl	8011444 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 8003852:	07c6      	lsls	r6, r0, #31
 8003854:	f100 80f8 	bmi.w	8003a48 <mount_volume+0x240>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8003858:	b10d      	cbz	r5, 800385e <mount_volume+0x56>
 800385a:	0741      	lsls	r1, r0, #29
 800385c:	d4f3      	bmi.n	8003846 <mount_volume+0x3e>
	fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD format */
 800385e:	2100      	movs	r1, #0
 8003860:	4620      	mov	r0, r4
 8003862:	f7ff fbcb 	bl	8002ffc <check_fs>
	if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is an FAT VBR as auto scan, not a BS or disk error */
 8003866:	2802      	cmp	r0, #2
 8003868:	d11b      	bne.n	80038a2 <mount_volume+0x9a>
		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 800386a:	f8d4 3202 	ldr.w	r3, [r4, #514]	@ 0x202
 800386e:	9300      	str	r3, [sp, #0]
 8003870:	f8d4 3212 	ldr.w	r3, [r4, #530]	@ 0x212
 8003874:	9301      	str	r3, [sp, #4]
 8003876:	f8d4 3222 	ldr.w	r3, [r4, #546]	@ 0x222
 800387a:	9302      	str	r3, [sp, #8]
 800387c:	f8d4 3232 	ldr.w	r3, [r4, #562]	@ 0x232
 8003880:	9303      	str	r3, [sp, #12]
	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
 8003882:	466e      	mov	r6, sp
		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
 8003884:	2500      	movs	r5, #0
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
 8003886:	f856 1b04 	ldr.w	r1, [r6], #4
 800388a:	b129      	cbz	r1, 8003898 <mount_volume+0x90>
 800388c:	4620      	mov	r0, r4
 800388e:	f7ff fbb5 	bl	8002ffc <check_fs>
	} while (part == 0 && fmt >= 2 && ++i < 4);
 8003892:	2801      	cmp	r0, #1
 8003894:	d801      	bhi.n	800389a <mount_volume+0x92>
 8003896:	e00b      	b.n	80038b0 <mount_volume+0xa8>
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
 8003898:	2003      	movs	r0, #3
	} while (part == 0 && fmt >= 2 && ++i < 4);
 800389a:	3501      	adds	r5, #1
 800389c:	2d04      	cmp	r5, #4
 800389e:	d1f2      	bne.n	8003886 <mount_volume+0x7e>
 80038a0:	e152      	b.n	8003b48 <mount_volume+0x340>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80038a2:	2804      	cmp	r0, #4
 80038a4:	f000 80ca 	beq.w	8003a3c <mount_volume+0x234>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 80038a8:	2801      	cmp	r0, #1
 80038aa:	d901      	bls.n	80038b0 <mount_volume+0xa8>
 80038ac:	200d      	movs	r0, #13
 80038ae:	e14f      	b.n	8003b50 <mount_volume+0x348>
	if (fmt == 1) {
 80038b0:	2801      	cmp	r0, #1
	bsect = fs->winsect;					/* Volume offset */
 80038b2:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
	if (fmt == 1) {
 80038b4:	d10a      	bne.n	80038cc <mount_volume+0xc4>
 80038b6:	f104 0246 	add.w	r2, r4, #70	@ 0x46
		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
 80038ba:	230b      	movs	r3, #11
 80038bc:	f812 5f01 	ldrb.w	r5, [r2, #1]!
 80038c0:	2d00      	cmp	r5, #0
 80038c2:	d1f3      	bne.n	80038ac <mount_volume+0xa4>
 80038c4:	3301      	adds	r3, #1
 80038c6:	2b40      	cmp	r3, #64	@ 0x40
 80038c8:	d1f8      	bne.n	80038bc <mount_volume+0xb4>
 80038ca:	e0cb      	b.n	8003a64 <mount_volume+0x25c>
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 80038cc:	f8b4 3047 	ldrh.w	r3, [r4, #71]	@ 0x47
 80038d0:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80038d4:	d1ea      	bne.n	80038ac <mount_volume+0xa4>
		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 80038d6:	f8b4 6052 	ldrh.w	r6, [r4, #82]	@ 0x52
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 80038da:	b906      	cbnz	r6, 80038de <mount_volume+0xd6>
 80038dc:	6e26      	ldr	r6, [r4, #96]	@ 0x60
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 80038de:	f894 704c 	ldrb.w	r7, [r4, #76]	@ 0x4c
		fs->fsize = fasize;
 80038e2:	6226      	str	r6, [r4, #32]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 80038e4:	1e7b      	subs	r3, r7, #1
 80038e6:	2b01      	cmp	r3, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 80038e8:	70a7      	strb	r7, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 80038ea:	d8df      	bhi.n	80038ac <mount_volume+0xa4>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 80038ec:	f894 5049 	ldrb.w	r5, [r4, #73]	@ 0x49
 80038f0:	8165      	strh	r5, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 80038f2:	2d00      	cmp	r5, #0
 80038f4:	d0da      	beq.n	80038ac <mount_volume+0xa4>
 80038f6:	1e6b      	subs	r3, r5, #1
 80038f8:	422b      	tst	r3, r5
 80038fa:	d1d7      	bne.n	80038ac <mount_volume+0xa4>
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 80038fc:	f8b4 c04d 	ldrh.w	ip, [r4, #77]	@ 0x4d
 8003900:	f8a4 c008 	strh.w	ip, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8003904:	f01c 0f0f 	tst.w	ip, #15
 8003908:	d1d0      	bne.n	80038ac <mount_volume+0xa4>
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 800390a:	f8b4 304f 	ldrh.w	r3, [r4, #79]	@ 0x4f
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 800390e:	b903      	cbnz	r3, 8003912 <mount_volume+0x10a>
 8003910:	6de3      	ldr	r3, [r4, #92]	@ 0x5c
		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 8003912:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8003916:	2a00      	cmp	r2, #0
 8003918:	d0c8      	beq.n	80038ac <mount_volume+0xa4>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 800391a:	4377      	muls	r7, r6
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 800391c:	eb02 101c 	add.w	r0, r2, ip, lsr #4
 8003920:	4438      	add	r0, r7
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8003922:	4283      	cmp	r3, r0
 8003924:	d3c2      	bcc.n	80038ac <mount_volume+0xa4>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8003926:	1a1b      	subs	r3, r3, r0
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8003928:	42ab      	cmp	r3, r5
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 800392a:	fbb3 fef5 	udiv	lr, r3, r5
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 800392e:	d3bd      	bcc.n	80038ac <mount_volume+0xa4>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 8003930:	4b47      	ldr	r3, [pc, #284]	@ (8003a50 <mount_volume+0x248>)
 8003932:	459e      	cmp	lr, r3
 8003934:	d8ba      	bhi.n	80038ac <mount_volume+0xa4>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8003936:	f64f 73f5 	movw	r3, #65525	@ 0xfff5
 800393a:	459e      	cmp	lr, r3
 800393c:	d806      	bhi.n	800394c <mount_volume+0x144>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 800393e:	f640 75f5 	movw	r5, #4085	@ 0xff5
 8003942:	45ae      	cmp	lr, r5
 8003944:	bf8c      	ite	hi
 8003946:	2502      	movhi	r5, #2
 8003948:	2501      	movls	r5, #1
 800394a:	e000      	b.n	800394e <mount_volume+0x146>
 800394c:	2503      	movs	r5, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800394e:	f10e 0302 	add.w	r3, lr, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8003952:	440a      	add	r2, r1
		fs->database = bsect + sysect;					/* Data start sector */
 8003954:	4408      	add	r0, r1
		if (fmt == FS_FAT32) {
 8003956:	2d03      	cmp	r5, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8003958:	61e3      	str	r3, [r4, #28]
		fs->volbase = bsect;							/* Volume start sector */
 800395a:	6261      	str	r1, [r4, #36]	@ 0x24
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800395c:	62a2      	str	r2, [r4, #40]	@ 0x28
		fs->database = bsect + sysect;					/* Data start sector */
 800395e:	6320      	str	r0, [r4, #48]	@ 0x30
		if (fmt == FS_FAT32) {
 8003960:	d107      	bne.n	8003972 <mount_volume+0x16a>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8003962:	f8b4 2066 	ldrh.w	r2, [r4, #102]	@ 0x66
 8003966:	ea5c 0202 	orrs.w	r2, ip, r2
 800396a:	d19f      	bne.n	80038ac <mount_volume+0xa4>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 800396c:	6ea7      	ldr	r7, [r4, #104]	@ 0x68
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 800396e:	009b      	lsls	r3, r3, #2
 8003970:	e00d      	b.n	800398e <mount_volume+0x186>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8003972:	f1bc 0f00 	cmp.w	ip, #0
 8003976:	d099      	beq.n	80038ac <mount_volume+0xa4>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003978:	2d02      	cmp	r5, #2
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800397a:	4417      	add	r7, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 800397c:	ea4f 0243 	mov.w	r2, r3, lsl #1
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003980:	bf1b      	ittet	ne
 8003982:	18d2      	addne	r2, r2, r3
 8003984:	f003 0301 	andne.w	r3, r3, #1
 8003988:	4613      	moveq	r3, r2
 800398a:	eb03 0352 	addne.w	r3, r3, r2, lsr #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800398e:	f203 13ff 	addw	r3, r3, #511	@ 0x1ff
 8003992:	ebb6 2f53 	cmp.w	r6, r3, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 8003996:	62e7      	str	r7, [r4, #44]	@ 0x2c
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8003998:	d388      	bcc.n	80038ac <mount_volume+0xa4>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800399a:	f04f 33ff 	mov.w	r3, #4294967295
 800399e:	e9c4 3305 	strd	r3, r3, [r4, #20]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 80039a2:	2d03      	cmp	r5, #3
		fs->fsi_flag = 0x80;
 80039a4:	f04f 0380 	mov.w	r3, #128	@ 0x80
 80039a8:	7123      	strb	r3, [r4, #4]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
 80039aa:	d122      	bne.n	80039f2 <mount_volume+0x1ea>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 80039ac:	f8b4 306c 	ldrh.w	r3, [r4, #108]	@ 0x6c
 80039b0:	2b01      	cmp	r3, #1
 80039b2:	d11e      	bne.n	80039f2 <mount_volume+0x1ea>
			&& move_window(fs, bsect + 1) == FR_OK)
 80039b4:	3101      	adds	r1, #1
 80039b6:	4620      	mov	r0, r4
 80039b8:	f7ff fb08 	bl	8002fcc <move_window>
 80039bc:	b9c8      	cbnz	r0, 80039f2 <mount_volume+0x1ea>
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 80039be:	f8b4 223a 	ldrh.w	r2, [r4, #570]	@ 0x23a
			fs->fsi_flag = 0;
 80039c2:	7120      	strb	r0, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 80039c4:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 80039c8:	429a      	cmp	r2, r3
 80039ca:	d112      	bne.n	80039f2 <mount_volume+0x1ea>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80039cc:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 80039ce:	4b21      	ldr	r3, [pc, #132]	@ (8003a54 <mount_volume+0x24c>)
 80039d0:	429a      	cmp	r2, r3
 80039d2:	d10e      	bne.n	80039f2 <mount_volume+0x1ea>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80039d4:	f103 53ff 	add.w	r3, r3, #534773760	@ 0x1fe00000
 80039d8:	f8d4 2220 	ldr.w	r2, [r4, #544]	@ 0x220
 80039dc:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 80039e0:	3320      	adds	r3, #32
 80039e2:	429a      	cmp	r2, r3
 80039e4:	d105      	bne.n	80039f2 <mount_volume+0x1ea>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 80039e6:	f8d4 3224 	ldr.w	r3, [r4, #548]	@ 0x224
 80039ea:	61a3      	str	r3, [r4, #24]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 80039ec:	f8d4 3228 	ldr.w	r3, [r4, #552]	@ 0x228
 80039f0:	6163      	str	r3, [r4, #20]
	fs->id = ++Fsid;		/* Volume mount ID */
 80039f2:	4a19      	ldr	r2, [pc, #100]	@ (8003a58 <mount_volume+0x250>)
	fs->fs_type = (BYTE)fmt;/* FAT sub-type */
 80039f4:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 80039f6:	8813      	ldrh	r3, [r2, #0]
 80039f8:	3301      	adds	r3, #1
 80039fa:	b29b      	uxth	r3, r3
 80039fc:	8013      	strh	r3, [r2, #0]
 80039fe:	80e3      	strh	r3, [r4, #6]
	fs->lfnbuf = LfnBuf;	/* Static LFN working buffer */
 8003a00:	4b16      	ldr	r3, [pc, #88]	@ (8003a5c <mount_volume+0x254>)
 8003a02:	60e3      	str	r3, [r4, #12]
	fs->dirbuf = DirBuf;	/* Static directory block scratchpad buuffer */
 8003a04:	4b16      	ldr	r3, [pc, #88]	@ (8003a60 <mount_volume+0x258>)
 8003a06:	6123      	str	r3, [r4, #16]
	return FR_OK;
 8003a08:	e719      	b.n	800383e <mount_volume+0x36>
		bcl = ld_dword(fs->win + i + 20);				/* Bitmap cluster */
 8003a0a:	f104 063c 	add.w	r6, r4, #60	@ 0x3c
 8003a0e:	4435      	add	r5, r6
 8003a10:	696d      	ldr	r5, [r5, #20]
		if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;	/* (Wrong cluster#) */
 8003a12:	2d01      	cmp	r5, #1
 8003a14:	f67f af4a 	bls.w	80038ac <mount_volume+0xa4>
 8003a18:	69e3      	ldr	r3, [r4, #28]
 8003a1a:	42ab      	cmp	r3, r5
 8003a1c:	f67f af46 	bls.w	80038ac <mount_volume+0xa4>
		fs->bitbase = fs->database + fs->csize * (bcl - 2);	/* Bitmap sector */
 8003a20:	8961      	ldrh	r1, [r4, #10]
 8003a22:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003a24:	1eaa      	subs	r2, r5, #2
 8003a26:	fb02 3301 	mla	r3, r2, r1, r3
 8003a2a:	6363      	str	r3, [r4, #52]	@ 0x34
			if (move_window(fs, fs->fatbase + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;
 8003a2c:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 8003a2e:	4620      	mov	r0, r4
 8003a30:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
 8003a34:	f7ff faca 	bl	8002fcc <move_window>
 8003a38:	2800      	cmp	r0, #0
 8003a3a:	d076      	beq.n	8003b2a <mount_volume+0x322>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003a3c:	2001      	movs	r0, #1
 8003a3e:	e087      	b.n	8003b50 <mount_volume+0x348>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003a40:	200b      	movs	r0, #11
 8003a42:	e085      	b.n	8003b50 <mount_volume+0x348>
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 8003a44:	200c      	movs	r0, #12
 8003a46:	e083      	b.n	8003b50 <mount_volume+0x348>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8003a48:	2003      	movs	r0, #3
 8003a4a:	e081      	b.n	8003b50 <mount_volume+0x348>
 8003a4c:	20000788 	.word	0x20000788
 8003a50:	0ffffff5 	.word	0x0ffffff5
 8003a54:	41615252 	.word	0x41615252
 8003a58:	20000784 	.word	0x20000784
 8003a5c:	200006d4 	.word	0x200006d4
 8003a60:	20000704 	.word	0x20000704
		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT version (must be version 1.0) */
 8003a64:	f8b4 30a4 	ldrh.w	r3, [r4, #164]	@ 0xa4
 8003a68:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8003a6c:	f47f af1e 	bne.w	80038ac <mount_volume+0xa4>
		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs)) {	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
 8003a70:	f894 30a8 	ldrb.w	r3, [r4, #168]	@ 0xa8
 8003a74:	2b09      	cmp	r3, #9
 8003a76:	f47f af19 	bne.w	80038ac <mount_volume+0xa4>
		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA of the volume + 1 */
 8003a7a:	e9d4 0621 	ldrd	r0, r6, [r4, #132]	@ 0x84
		if (!FF_LBA64 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be accessed in 32-bit LBA) */
 8003a7e:	f04f 33ff 	mov.w	r3, #4294967295
		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Last LBA of the volume + 1 */
 8003a82:	1808      	adds	r0, r1, r0
 8003a84:	f146 0600 	adc.w	r6, r6, #0
		if (!FF_LBA64 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be accessed in 32-bit LBA) */
 8003a88:	4283      	cmp	r3, r0
 8003a8a:	eb75 0306 	sbcs.w	r3, r5, r6
 8003a8e:	f4ff af0d 	bcc.w	80038ac <mount_volume+0xa4>
		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
 8003a92:	f8d4 3090 	ldr.w	r3, [r4, #144]	@ 0x90
 8003a96:	6223      	str	r3, [r4, #32]
		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
 8003a98:	f894 30aa 	ldrb.w	r3, [r4, #170]	@ 0xaa
 8003a9c:	70a3      	strb	r3, [r4, #2]
		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Supports only 1 FAT) */
 8003a9e:	2b01      	cmp	r3, #1
 8003aa0:	f47f af04 	bne.w	80038ac <mount_volume+0xa4>
		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
 8003aa4:	f894 20a9 	ldrb.w	r2, [r4, #169]	@ 0xa9
 8003aa8:	4093      	lsls	r3, r2
 8003aaa:	b29a      	uxth	r2, r3
 8003aac:	8162      	strh	r2, [r4, #10]
		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768 sectors) */
 8003aae:	2a00      	cmp	r2, #0
 8003ab0:	f43f aefc 	beq.w	80038ac <mount_volume+0xa4>
		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
 8003ab4:	f8d4 c098 	ldr.w	ip, [r4, #152]	@ 0x98
		if (nclst > MAX_EXFAT) return FR_NO_FILESYSTEM;	/* (Too many clusters) */
 8003ab8:	4a26      	ldr	r2, [pc, #152]	@ (8003b54 <mount_volume+0x34c>)
 8003aba:	4594      	cmp	ip, r2
 8003abc:	f63f aef6 	bhi.w	80038ac <mount_volume+0xa4>
		fs->n_fatent = nclst + 2;
 8003ac0:	f10c 0202 	add.w	r2, ip, #2
 8003ac4:	61e2      	str	r2, [r4, #28]
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8003ac6:	f8d4 2094 	ldr.w	r2, [r4, #148]	@ 0x94
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8003aca:	f8d4 708c 	ldr.w	r7, [r4, #140]	@ 0x8c
		fs->volbase = bsect;
 8003ace:	6261      	str	r1, [r4, #36]	@ 0x24
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003ad0:	b29b      	uxth	r3, r3
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8003ad2:	440a      	add	r2, r1
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003ad4:	fb0c f303 	mul.w	r3, ip, r3
 8003ad8:	189b      	adds	r3, r3, r2
		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
 8003ada:	6322      	str	r2, [r4, #48]	@ 0x30
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003adc:	eb45 0205 	adc.w	r2, r5, r5
 8003ae0:	4298      	cmp	r0, r3
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8003ae2:	440f      	add	r7, r1
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003ae4:	eb76 0202 	sbcs.w	r2, r6, r2
		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
 8003ae8:	62a7      	str	r7, [r4, #40]	@ 0x28
		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 8003aea:	f4ff aedf 	bcc.w	80038ac <mount_volume+0xa4>
		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
 8003aee:	f8d4 309c 	ldr.w	r3, [r4, #156]	@ 0x9c
 8003af2:	62e3      	str	r3, [r4, #44]	@ 0x2c
		so = i = 0;
 8003af4:	462e      	mov	r6, r5
			if (i == 0) {
 8003af6:	b975      	cbnz	r5, 8003b16 <mount_volume+0x30e>
				if (so >= fs->csize) return FR_NO_FILESYSTEM;	/* Not found? */
 8003af8:	8963      	ldrh	r3, [r4, #10]
 8003afa:	42b3      	cmp	r3, r6
 8003afc:	f67f aed6 	bls.w	80038ac <mount_volume+0xa4>
				if (move_window(fs, clst2sect(fs, (DWORD)fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;
 8003b00:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8003b02:	4620      	mov	r0, r4
 8003b04:	f7ff f976 	bl	8002df4 <clst2sect>
 8003b08:	1981      	adds	r1, r0, r6
 8003b0a:	4620      	mov	r0, r4
 8003b0c:	f7ff fa5e 	bl	8002fcc <move_window>
 8003b10:	2800      	cmp	r0, #0
 8003b12:	d193      	bne.n	8003a3c <mount_volume+0x234>
				so++;
 8003b14:	3601      	adds	r6, #1
			if (fs->win[i] == ET_BITMAP) break;			/* Is it a bitmap entry? */
 8003b16:	1963      	adds	r3, r4, r5
 8003b18:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8003b1c:	2b81      	cmp	r3, #129	@ 0x81
 8003b1e:	f43f af74 	beq.w	8003a0a <mount_volume+0x202>
			i = (i + SZDIRE) % SS(fs);	/* Next entry */
 8003b22:	3520      	adds	r5, #32
 8003b24:	f3c5 0508 	ubfx	r5, r5, #0, #9
			if (i == 0) {
 8003b28:	e7e5      	b.n	8003af6 <mount_volume+0x2ee>
			cv = ld_dword(fs->win + bcl % (SS(fs) / 4) * 4);
 8003b2a:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
 8003b2e:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
			if (cv == 0xFFFFFFFF) break;				/* Last link? */
 8003b32:	1c5a      	adds	r2, r3, #1
 8003b34:	d004      	beq.n	8003b40 <mount_volume+0x338>
			if (cv != ++bcl) return FR_NO_FILESYSTEM;	/* Fragmented? */
 8003b36:	3501      	adds	r5, #1
 8003b38:	42ab      	cmp	r3, r5
 8003b3a:	f43f af77 	beq.w	8003a2c <mount_volume+0x224>
 8003b3e:	e6b5      	b.n	80038ac <mount_volume+0xa4>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8003b40:	e9c4 3305 	strd	r3, r3, [r4, #20]
		fmt = FS_EXFAT;			/* FAT sub-type */
 8003b44:	2504      	movs	r5, #4
 8003b46:	e754      	b.n	80039f2 <mount_volume+0x1ea>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003b48:	2804      	cmp	r0, #4
 8003b4a:	f47f aeaf 	bne.w	80038ac <mount_volume+0xa4>
 8003b4e:	e775      	b.n	8003a3c <mount_volume+0x234>
}
 8003b50:	b005      	add	sp, #20
 8003b52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003b54:	7ffffffd 	.word	0x7ffffffd

08003b58 <create_chain>:
{
 8003b58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	FATFS *fs = obj->fs;
 8003b5c:	6805      	ldr	r5, [r0, #0]
{
 8003b5e:	4606      	mov	r6, r0
	if (clst == 0) {	/* Create a new chain */
 8003b60:	4688      	mov	r8, r1
 8003b62:	b931      	cbnz	r1, 8003b72 <create_chain+0x1a>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 8003b64:	696f      	ldr	r7, [r5, #20]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8003b66:	b1a7      	cbz	r7, 8003b92 <create_chain+0x3a>
 8003b68:	69eb      	ldr	r3, [r5, #28]
 8003b6a:	42bb      	cmp	r3, r7
 8003b6c:	bf98      	it	ls
 8003b6e:	2701      	movls	r7, #1
 8003b70:	e010      	b.n	8003b94 <create_chain+0x3c>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8003b72:	f7ff fb85 	bl	8003280 <get_fat>
		if (cs < 2) return 1;				/* Test for insanity */
 8003b76:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8003b78:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Test for insanity */
 8003b7a:	d801      	bhi.n	8003b80 <create_chain+0x28>
 8003b7c:	2401      	movs	r4, #1
 8003b7e:	e0d7      	b.n	8003d30 <create_chain+0x1d8>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 8003b80:	1c42      	adds	r2, r0, #1
 8003b82:	f000 80bb 	beq.w	8003cfc <create_chain+0x1a4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8003b86:	69eb      	ldr	r3, [r5, #28]
 8003b88:	4283      	cmp	r3, r0
 8003b8a:	f200 80d1 	bhi.w	8003d30 <create_chain+0x1d8>
		scl = clst;							/* Cluster to start to find */
 8003b8e:	4647      	mov	r7, r8
 8003b90:	e000      	b.n	8003b94 <create_chain+0x3c>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8003b92:	2701      	movs	r7, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8003b94:	69ab      	ldr	r3, [r5, #24]
 8003b96:	b90b      	cbnz	r3, 8003b9c <create_chain+0x44>
 8003b98:	2400      	movs	r4, #0
 8003b9a:	e0c9      	b.n	8003d30 <create_chain+0x1d8>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003b9c:	782a      	ldrb	r2, [r5, #0]
	if (clst >= fs->n_fatent - 2) clst = 0;
 8003b9e:	69eb      	ldr	r3, [r5, #28]
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003ba0:	2a04      	cmp	r2, #4
 8003ba2:	d159      	bne.n	8003c58 <create_chain+0x100>
	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
 8003ba4:	f1a7 0a02 	sub.w	sl, r7, #2
	if (clst >= fs->n_fatent - 2) clst = 0;
 8003ba8:	3b02      	subs	r3, #2
 8003baa:	459a      	cmp	sl, r3
 8003bac:	bf28      	it	cs
 8003bae:	f04f 0a00 	movcs.w	sl, #0
	scl = val = clst; ctr = 0;
 8003bb2:	46d1      	mov	r9, sl
		if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
 8003bb4:	6b69      	ldr	r1, [r5, #52]	@ 0x34
 8003bb6:	4628      	mov	r0, r5
 8003bb8:	eb01 3119 	add.w	r1, r1, r9, lsr #12
 8003bbc:	f7ff fa06 	bl	8002fcc <move_window>
 8003bc0:	bb30      	cbnz	r0, 8003c10 <create_chain+0xb8>
		i = val / 8 % SS(fs); bm = 1 << (val % 8);
 8003bc2:	f009 0207 	and.w	r2, r9, #7
 8003bc6:	2301      	movs	r3, #1
 8003bc8:	4093      	lsls	r3, r2
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003bca:	69ea      	ldr	r2, [r5, #28]
		i = val / 8 % SS(fs); bm = 1 << (val % 8);
 8003bcc:	f3c9 01c8 	ubfx	r1, r9, #3, #9
 8003bd0:	b2db      	uxtb	r3, r3
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003bd2:	3a02      	subs	r2, #2
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003bd4:	1868      	adds	r0, r5, r1
			bm = 1;
 8003bd6:	464c      	mov	r4, r9
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003bd8:	f890 003c 	ldrb.w	r0, [r0, #60]	@ 0x3c
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003bdc:	f109 0901 	add.w	r9, r9, #1
 8003be0:	4591      	cmp	r9, r2
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003be2:	ea00 0003 	and.w	r0, r0, r3
				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
 8003be6:	d202      	bcs.n	8003bee <create_chain+0x96>
				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
 8003be8:	005b      	lsls	r3, r3, #1
 8003bea:	b2db      	uxtb	r3, r3
 8003bec:	e003      	b.n	8003bf6 <create_chain+0x9e>
					val = 0; bm = 0; i = SS(fs);
 8003bee:	2300      	movs	r3, #0
 8003bf0:	4699      	mov	r9, r3
 8003bf2:	f44f 7100 	mov.w	r1, #512	@ 0x200
				if (bv == 0) {	/* Is it a free cluster? */
 8003bf6:	b908      	cbnz	r0, 8003bfc <create_chain+0xa4>
					if (++ctr == ncl) return scl + 2;	/* Check if run length is sufficient for required */
 8003bf8:	3402      	adds	r4, #2
 8003bfa:	e00d      	b.n	8003c18 <create_chain+0xc0>
				if (val == clst) return 0;	/* All cluster scanned? */
 8003bfc:	45ca      	cmp	sl, r9
 8003bfe:	d00a      	beq.n	8003c16 <create_chain+0xbe>
			} while (bm != 0);
 8003c00:	2b00      	cmp	r3, #0
 8003c02:	d1e7      	bne.n	8003bd4 <create_chain+0x7c>
		} while (++i < SS(fs));
 8003c04:	3101      	adds	r1, #1
 8003c06:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
 8003c0a:	d2d3      	bcs.n	8003bb4 <create_chain+0x5c>
			bm = 1;
 8003c0c:	2301      	movs	r3, #1
 8003c0e:	e7e1      	b.n	8003bd4 <create_chain+0x7c>
		if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
 8003c10:	f04f 34ff 	mov.w	r4, #4294967295
 8003c14:	e000      	b.n	8003c18 <create_chain+0xc0>
				if (val == clst) return 0;	/* All cluster scanned? */
 8003c16:	2400      	movs	r4, #0
		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
 8003c18:	1e63      	subs	r3, r4, #1
 8003c1a:	3303      	adds	r3, #3
 8003c1c:	f200 8088 	bhi.w	8003d30 <create_chain+0x1d8>
		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
 8003c20:	2301      	movs	r3, #1
 8003c22:	461a      	mov	r2, r3
 8003c24:	4621      	mov	r1, r4
 8003c26:	4628      	mov	r0, r5
 8003c28:	f7ff fa46 	bl	80030b8 <change_bitmap>
		if (res == FR_INT_ERR) return 1;
 8003c2c:	2802      	cmp	r0, #2
 8003c2e:	d0a5      	beq.n	8003b7c <create_chain+0x24>
		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
 8003c30:	2801      	cmp	r0, #1
 8003c32:	d063      	beq.n	8003cfc <create_chain+0x1a4>
		if (clst == 0) {							/* Is it a new chain? */
 8003c34:	f1b8 0f00 	cmp.w	r8, #0
 8003c38:	d102      	bne.n	8003c40 <create_chain+0xe8>
			obj->stat = 2;							/* Set status 'contiguous' */
 8003c3a:	2302      	movs	r3, #2
 8003c3c:	71f3      	strb	r3, [r6, #7]
 8003c3e:	e04c      	b.n	8003cda <create_chain+0x182>
			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
 8003c40:	79f3      	ldrb	r3, [r6, #7]
 8003c42:	2b02      	cmp	r3, #2
 8003c44:	d15d      	bne.n	8003d02 <create_chain+0x1aa>
 8003c46:	1c7b      	adds	r3, r7, #1
 8003c48:	42a3      	cmp	r3, r4
 8003c4a:	d046      	beq.n	8003cda <create_chain+0x182>
				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
 8003c4c:	68b3      	ldr	r3, [r6, #8]
 8003c4e:	1afb      	subs	r3, r7, r3
 8003c50:	61b3      	str	r3, [r6, #24]
				obj->stat = 3;						/* Change status 'just fragmented' */
 8003c52:	2303      	movs	r3, #3
 8003c54:	71f3      	strb	r3, [r6, #7]
 8003c56:	e054      	b.n	8003d02 <create_chain+0x1aa>
		if (scl == clst) {						/* Stretching an existing chain? */
 8003c58:	4547      	cmp	r7, r8
 8003c5a:	d116      	bne.n	8003c8a <create_chain+0x132>
			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
 8003c5c:	1c7c      	adds	r4, r7, #1
			if (ncl >= fs->n_fatent) ncl = 2;
 8003c5e:	42a3      	cmp	r3, r4
 8003c60:	bf98      	it	ls
 8003c62:	2402      	movls	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 8003c64:	4621      	mov	r1, r4
 8003c66:	4630      	mov	r0, r6
 8003c68:	f7ff fb0a 	bl	8003280 <get_fat>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8003c6c:	2801      	cmp	r0, #1
 8003c6e:	d085      	beq.n	8003b7c <create_chain+0x24>
 8003c70:	1c43      	adds	r3, r0, #1
 8003c72:	d043      	beq.n	8003cfc <create_chain+0x1a4>
			if (cs != 0) {						/* Not free? */
 8003c74:	b140      	cbz	r0, 8003c88 <create_chain+0x130>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 8003c76:	f8d5 9014 	ldr.w	r9, [r5, #20]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 8003c7a:	f1b9 0f01 	cmp.w	r9, #1
 8003c7e:	d904      	bls.n	8003c8a <create_chain+0x132>
 8003c80:	69eb      	ldr	r3, [r5, #28]
 8003c82:	4599      	cmp	r9, r3
 8003c84:	d302      	bcc.n	8003c8c <create_chain+0x134>
 8003c86:	e000      	b.n	8003c8a <create_chain+0x132>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 8003c88:	b9bc      	cbnz	r4, 8003cba <create_chain+0x162>
			if (ncl >= fs->n_fatent) ncl = 2;
 8003c8a:	46b9      	mov	r9, r7
			ncl = scl;	/* Start cluster */
 8003c8c:	464c      	mov	r4, r9
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8003c8e:	69eb      	ldr	r3, [r5, #28]
				ncl++;							/* Next cluster */
 8003c90:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8003c92:	42a3      	cmp	r3, r4
 8003c94:	d804      	bhi.n	8003ca0 <create_chain+0x148>
					if (ncl > scl) return 0;	/* No free cluster found? */
 8003c96:	f1b9 0f01 	cmp.w	r9, #1
 8003c9a:	f43f af7d 	beq.w	8003b98 <create_chain+0x40>
					ncl = 2;
 8003c9e:	2402      	movs	r4, #2
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 8003ca0:	4621      	mov	r1, r4
 8003ca2:	4630      	mov	r0, r6
 8003ca4:	f7ff faec 	bl	8003280 <get_fat>
				if (cs == 0) break;				/* Found a free cluster? */
 8003ca8:	b138      	cbz	r0, 8003cba <create_chain+0x162>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 8003caa:	2801      	cmp	r0, #1
 8003cac:	f43f af66 	beq.w	8003b7c <create_chain+0x24>
 8003cb0:	3001      	adds	r0, #1
 8003cb2:	d023      	beq.n	8003cfc <create_chain+0x1a4>
				if (ncl == scl) return 0;		/* No free cluster found? */
 8003cb4:	454c      	cmp	r4, r9
 8003cb6:	d1ea      	bne.n	8003c8e <create_chain+0x136>
 8003cb8:	e76e      	b.n	8003b98 <create_chain+0x40>
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
 8003cba:	f04f 32ff 	mov.w	r2, #4294967295
 8003cbe:	4621      	mov	r1, r4
 8003cc0:	4628      	mov	r0, r5
 8003cc2:	f7ff fa35 	bl	8003130 <put_fat>
		if (res == FR_OK && clst != 0) {
 8003cc6:	b9b0      	cbnz	r0, 8003cf6 <create_chain+0x19e>
 8003cc8:	f1b8 0f00 	cmp.w	r8, #0
 8003ccc:	d005      	beq.n	8003cda <create_chain+0x182>
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
 8003cce:	4622      	mov	r2, r4
 8003cd0:	4641      	mov	r1, r8
 8003cd2:	4628      	mov	r0, r5
 8003cd4:	f7ff fa2c 	bl	8003130 <put_fat>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8003cd8:	b968      	cbnz	r0, 8003cf6 <create_chain+0x19e>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8003cda:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
 8003cde:	3a02      	subs	r2, #2
 8003ce0:	4293      	cmp	r3, r2
 8003ce2:	bf9c      	itt	ls
 8003ce4:	f103 33ff 	addls.w	r3, r3, #4294967295
 8003ce8:	61ab      	strls	r3, [r5, #24]
		fs->fsi_flag |= 1;
 8003cea:	792b      	ldrb	r3, [r5, #4]
		fs->last_clst = ncl;
 8003cec:	616c      	str	r4, [r5, #20]
		fs->fsi_flag |= 1;
 8003cee:	f043 0301 	orr.w	r3, r3, #1
 8003cf2:	712b      	strb	r3, [r5, #4]
 8003cf4:	e01c      	b.n	8003d30 <create_chain+0x1d8>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8003cf6:	2801      	cmp	r0, #1
 8003cf8:	f47f af40 	bne.w	8003b7c <create_chain+0x24>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 8003cfc:	f04f 34ff 	mov.w	r4, #4294967295
 8003d00:	e016      	b.n	8003d30 <create_chain+0x1d8>
			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
 8003d02:	f108 0201 	add.w	r2, r8, #1
 8003d06:	42a2      	cmp	r2, r4
				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
 8003d08:	69f3      	ldr	r3, [r6, #28]
			if (ncl == clst + 1) {	/* Is the cluster next to previous one? */
 8003d0a:	d104      	bne.n	8003d16 <create_chain+0x1be>
				obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;	/* Increment size of last framgent */
 8003d0c:	b10b      	cbz	r3, 8003d12 <create_chain+0x1ba>
 8003d0e:	3301      	adds	r3, #1
 8003d10:	e00c      	b.n	8003d2c <create_chain+0x1d4>
 8003d12:	2302      	movs	r3, #2
 8003d14:	e00a      	b.n	8003d2c <create_chain+0x1d4>
				if (obj->n_frag == 0) obj->n_frag = 1;
 8003d16:	b90b      	cbnz	r3, 8003d1c <create_chain+0x1c4>
 8003d18:	2301      	movs	r3, #1
 8003d1a:	61f3      	str	r3, [r6, #28]
				res = fill_last_frag(obj, clst, ncl);	/* Fill last fragment on the FAT and link it to new one */
 8003d1c:	4622      	mov	r2, r4
 8003d1e:	4641      	mov	r1, r8
 8003d20:	4630      	mov	r0, r6
 8003d22:	f7ff fa7d 	bl	8003220 <fill_last_frag>
				if (res == FR_OK) obj->n_frag = 1;
 8003d26:	2800      	cmp	r0, #0
 8003d28:	d1e5      	bne.n	8003cf6 <create_chain+0x19e>
 8003d2a:	2301      	movs	r3, #1
 8003d2c:	61f3      	str	r3, [r6, #28]
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8003d2e:	e7d4      	b.n	8003cda <create_chain+0x182>
}
 8003d30:	4620      	mov	r0, r4
 8003d32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08003d38 <dir_next>:
{
 8003d38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs = dp->obj.fs;
 8003d3c:	6806      	ldr	r6, [r0, #0]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8003d3e:	6b07      	ldr	r7, [r0, #48]	@ 0x30
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 8003d40:	7833      	ldrb	r3, [r6, #0]
 8003d42:	2b04      	cmp	r3, #4
 8003d44:	bf14      	ite	ne
 8003d46:	f44f 1300 	movne.w	r3, #2097152	@ 0x200000
 8003d4a:	f04f 5380 	moveq.w	r3, #268435456	@ 0x10000000
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8003d4e:	3720      	adds	r7, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 8003d50:	42bb      	cmp	r3, r7
 8003d52:	bf9c      	itt	ls
 8003d54:	2300      	movls	r3, #0
 8003d56:	6383      	strls	r3, [r0, #56]	@ 0x38
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003d58:	6b83      	ldr	r3, [r0, #56]	@ 0x38
{
 8003d5a:	4604      	mov	r4, r0
 8003d5c:	4689      	mov	r9, r1
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003d5e:	b173      	cbz	r3, 8003d7e <dir_next+0x46>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8003d60:	f3c7 0808 	ubfx	r8, r7, #0, #9
 8003d64:	f1b8 0f00 	cmp.w	r8, #0
 8003d68:	d13b      	bne.n	8003de2 <dir_next+0xaa>
		if (dp->clust == 0) {	/* Static table */
 8003d6a:	6b41      	ldr	r1, [r0, #52]	@ 0x34
		dp->sect++;				/* Next sector */
 8003d6c:	3301      	adds	r3, #1
 8003d6e:	6383      	str	r3, [r0, #56]	@ 0x38
		if (dp->clust == 0) {	/* Static table */
 8003d70:	b939      	cbnz	r1, 8003d82 <dir_next+0x4a>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8003d72:	8933      	ldrh	r3, [r6, #8]
 8003d74:	ebb3 1f57 	cmp.w	r3, r7, lsr #5
 8003d78:	d833      	bhi.n	8003de2 <dir_next+0xaa>
				dp->sect = 0; return FR_NO_FILE;
 8003d7a:	2300      	movs	r3, #0
 8003d7c:	63a3      	str	r3, [r4, #56]	@ 0x38
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 8003d7e:	2004      	movs	r0, #4
 8003d80:	e036      	b.n	8003df0 <dir_next+0xb8>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 8003d82:	8973      	ldrh	r3, [r6, #10]
 8003d84:	3b01      	subs	r3, #1
 8003d86:	ea13 2357 	ands.w	r3, r3, r7, lsr #9
 8003d8a:	d12a      	bne.n	8003de2 <dir_next+0xaa>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 8003d8c:	f7ff fa78 	bl	8003280 <get_fat>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8003d90:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 8003d92:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8003d94:	d801      	bhi.n	8003d9a <dir_next+0x62>
 8003d96:	2002      	movs	r0, #2
 8003d98:	e02a      	b.n	8003df0 <dir_next+0xb8>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003d9a:	1c42      	adds	r2, r0, #1
 8003d9c:	d101      	bne.n	8003da2 <dir_next+0x6a>
 8003d9e:	2001      	movs	r0, #1
 8003da0:	e026      	b.n	8003df0 <dir_next+0xb8>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 8003da2:	69f3      	ldr	r3, [r6, #28]
 8003da4:	4283      	cmp	r3, r0
 8003da6:	d816      	bhi.n	8003dd6 <dir_next+0x9e>
					if (!stretch) {								/* If no stretch, report EOT */
 8003da8:	f1b9 0f00 	cmp.w	r9, #0
 8003dac:	d0e5      	beq.n	8003d7a <dir_next+0x42>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8003dae:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8003db0:	4620      	mov	r0, r4
 8003db2:	f7ff fed1 	bl	8003b58 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8003db6:	4605      	mov	r5, r0
 8003db8:	b1c8      	cbz	r0, 8003dee <dir_next+0xb6>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8003dba:	2801      	cmp	r0, #1
 8003dbc:	d0eb      	beq.n	8003d96 <dir_next+0x5e>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003dbe:	1c43      	adds	r3, r0, #1
 8003dc0:	d0ed      	beq.n	8003d9e <dir_next+0x66>
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 8003dc2:	4601      	mov	r1, r0
 8003dc4:	4630      	mov	r0, r6
 8003dc6:	f7ff fbb7 	bl	8003538 <dir_clear>
 8003dca:	2800      	cmp	r0, #0
 8003dcc:	d1e7      	bne.n	8003d9e <dir_next+0x66>
					if (FF_FS_EXFAT) dp->obj.stat |= 4;			/* exFAT: The directory has been stretched */
 8003dce:	79e3      	ldrb	r3, [r4, #7]
 8003dd0:	f043 0304 	orr.w	r3, r3, #4
 8003dd4:	71e3      	strb	r3, [r4, #7]
				dp->clust = clst;		/* Initialize data for new cluster */
 8003dd6:	6365      	str	r5, [r4, #52]	@ 0x34
				dp->sect = clst2sect(fs, clst);
 8003dd8:	4629      	mov	r1, r5
 8003dda:	4630      	mov	r0, r6
 8003ddc:	f7ff f80a 	bl	8002df4 <clst2sect>
 8003de0:	63a0      	str	r0, [r4, #56]	@ 0x38
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8003de2:	363c      	adds	r6, #60	@ 0x3c
 8003de4:	4446      	add	r6, r8
	dp->dptr = ofs;						/* Current entry */
 8003de6:	6327      	str	r7, [r4, #48]	@ 0x30
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 8003de8:	63e6      	str	r6, [r4, #60]	@ 0x3c
	return FR_OK;
 8003dea:	2000      	movs	r0, #0
 8003dec:	e000      	b.n	8003df0 <dir_next+0xb8>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8003dee:	2007      	movs	r0, #7
}
 8003df0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08003df4 <load_xdir>:
{
 8003df4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003df8:	4605      	mov	r5, r0
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 8003dfa:	6800      	ldr	r0, [r0, #0]
	res = move_window(dp->obj.fs, dp->sect);
 8003dfc:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 8003dfe:	6906      	ldr	r6, [r0, #16]
	res = move_window(dp->obj.fs, dp->sect);
 8003e00:	f7ff f8e4 	bl	8002fcc <move_window>
	if (res != FR_OK) return res;
 8003e04:	b108      	cbz	r0, 8003e0a <load_xdir+0x16>
 8003e06:	2401      	movs	r4, #1
 8003e08:	e05c      	b.n	8003ec4 <load_xdir+0xd0>
	if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_INT_ERR;	/* Invalid order */
 8003e0a:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8003e0c:	780b      	ldrb	r3, [r1, #0]
 8003e0e:	2b85      	cmp	r3, #133	@ 0x85
 8003e10:	d001      	beq.n	8003e16 <load_xdir+0x22>
 8003e12:	2402      	movs	r4, #2
 8003e14:	e056      	b.n	8003ec4 <load_xdir+0xd0>
	memcpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
 8003e16:	2220      	movs	r2, #32
 8003e18:	4604      	mov	r4, r0
 8003e1a:	4630      	mov	r0, r6
 8003e1c:	f7fe ffcc 	bl	8002db8 <mem_cpy>
	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 8003e20:	7873      	ldrb	r3, [r6, #1]
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 8003e22:	f06f 025f 	mvn.w	r2, #95	@ 0x5f
	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 8003e26:	3301      	adds	r3, #1
 8003e28:	ea4f 1843 	mov.w	r8, r3, lsl #5
	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 8003e2c:	eb02 1343 	add.w	r3, r2, r3, lsl #5
 8003e30:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8003e34:	d8ed      	bhi.n	8003e12 <load_xdir+0x1e>
	res = dir_next(dp, 0);
 8003e36:	4621      	mov	r1, r4
 8003e38:	4628      	mov	r0, r5
 8003e3a:	f7ff ff7d 	bl	8003d38 <dir_next>
	if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003e3e:	2804      	cmp	r0, #4
	res = dir_next(dp, 0);
 8003e40:	4604      	mov	r4, r0
	if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003e42:	d0e6      	beq.n	8003e12 <load_xdir+0x1e>
	if (res != FR_OK) return res;
 8003e44:	2800      	cmp	r0, #0
 8003e46:	d13d      	bne.n	8003ec4 <load_xdir+0xd0>
	res = move_window(dp->obj.fs, dp->sect);
 8003e48:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
 8003e4a:	6828      	ldr	r0, [r5, #0]
 8003e4c:	f7ff f8be 	bl	8002fcc <move_window>
	if (res != FR_OK) return res;
 8003e50:	2800      	cmp	r0, #0
 8003e52:	d1d8      	bne.n	8003e06 <load_xdir+0x12>
	if (dp->dir[XDIR_Type] != ET_STREAM) return FR_INT_ERR;	/* Invalid order */
 8003e54:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8003e56:	780b      	ldrb	r3, [r1, #0]
 8003e58:	2bc0      	cmp	r3, #192	@ 0xc0
 8003e5a:	d1da      	bne.n	8003e12 <load_xdir+0x1e>
	memcpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
 8003e5c:	2220      	movs	r2, #32
 8003e5e:	18b0      	adds	r0, r6, r2
 8003e60:	f7fe ffaa 	bl	8002db8 <mem_cpy>
	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
 8003e64:	f896 3023 	ldrb.w	r3, [r6, #35]	@ 0x23
 8003e68:	220f      	movs	r2, #15
 8003e6a:	332c      	adds	r3, #44	@ 0x2c
 8003e6c:	fbb3 f3f2 	udiv	r3, r3, r2
 8003e70:	ebb8 1f43 	cmp.w	r8, r3, lsl #5
 8003e74:	d3cd      	bcc.n	8003e12 <load_xdir+0x1e>
	i = 2 * SZDIRE;	/* Name offset to load */
 8003e76:	2740      	movs	r7, #64	@ 0x40
		res = dir_next(dp, 0);
 8003e78:	2100      	movs	r1, #0
 8003e7a:	4628      	mov	r0, r5
 8003e7c:	f7ff ff5c 	bl	8003d38 <dir_next>
		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003e80:	2804      	cmp	r0, #4
		res = dir_next(dp, 0);
 8003e82:	4604      	mov	r4, r0
		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 8003e84:	d0c5      	beq.n	8003e12 <load_xdir+0x1e>
		if (res != FR_OK) return res;
 8003e86:	b9e8      	cbnz	r0, 8003ec4 <load_xdir+0xd0>
		res = move_window(dp->obj.fs, dp->sect);
 8003e88:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
 8003e8a:	6828      	ldr	r0, [r5, #0]
 8003e8c:	f7ff f89e 	bl	8002fcc <move_window>
		if (res != FR_OK) return res;
 8003e90:	4604      	mov	r4, r0
 8003e92:	2800      	cmp	r0, #0
 8003e94:	d1b7      	bne.n	8003e06 <load_xdir+0x12>
		if (dp->dir[XDIR_Type] != ET_FILENAME) return FR_INT_ERR;	/* Invalid order */
 8003e96:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
 8003e98:	780b      	ldrb	r3, [r1, #0]
 8003e9a:	2bc1      	cmp	r3, #193	@ 0xc1
 8003e9c:	d1b9      	bne.n	8003e12 <load_xdir+0x1e>
		if (i < MAXDIRB(FF_MAX_LFN)) memcpy(dirb + i, dp->dir, SZDIRE);
 8003e9e:	2f7f      	cmp	r7, #127	@ 0x7f
 8003ea0:	d803      	bhi.n	8003eaa <load_xdir+0xb6>
 8003ea2:	2220      	movs	r2, #32
 8003ea4:	19f0      	adds	r0, r6, r7
 8003ea6:	f7fe ff87 	bl	8002db8 <mem_cpy>
	} while ((i += SZDIRE) < sz_ent);
 8003eaa:	3720      	adds	r7, #32
 8003eac:	45b8      	cmp	r8, r7
 8003eae:	d8e3      	bhi.n	8003e78 <load_xdir+0x84>
	if (i <= MAXDIRB(FF_MAX_LFN)) {
 8003eb0:	2f80      	cmp	r7, #128	@ 0x80
 8003eb2:	d807      	bhi.n	8003ec4 <load_xdir+0xd0>
		if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
 8003eb4:	4630      	mov	r0, r6
 8003eb6:	f7fe ffb9 	bl	8002e2c <xdir_sum>
 8003eba:	8874      	ldrh	r4, [r6, #2]
 8003ebc:	1a24      	subs	r4, r4, r0
 8003ebe:	bf18      	it	ne
 8003ec0:	2401      	movne	r4, #1
 8003ec2:	0064      	lsls	r4, r4, #1
}
 8003ec4:	4620      	mov	r0, r4
 8003ec6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08003ecc <dir_alloc>:
{
 8003ecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ece:	460e      	mov	r6, r1
	res = dir_sdi(dp, 0);
 8003ed0:	2100      	movs	r1, #0
	FATFS *fs = dp->obj.fs;
 8003ed2:	6807      	ldr	r7, [r0, #0]
{
 8003ed4:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);
 8003ed6:	f7ff fa65 	bl	80033a4 <dir_sdi>
	if (res == FR_OK) {
 8003eda:	b9f0      	cbnz	r0, 8003f1a <dir_alloc+0x4e>
		n = 0;
 8003edc:	4605      	mov	r5, r0
			res = move_window(fs, dp->sect);
 8003ede:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003ee0:	4638      	mov	r0, r7
 8003ee2:	f7ff f873 	bl	8002fcc <move_window>
			if (res != FR_OK) break;
 8003ee6:	b9c0      	cbnz	r0, 8003f1a <dir_alloc+0x4e>
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {	/* Is the entry free? */
 8003ee8:	783a      	ldrb	r2, [r7, #0]
 8003eea:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8003eec:	2a04      	cmp	r2, #4
 8003eee:	781b      	ldrb	r3, [r3, #0]
 8003ef0:	d102      	bne.n	8003ef8 <dir_alloc+0x2c>
 8003ef2:	061b      	lsls	r3, r3, #24
 8003ef4:	d503      	bpl.n	8003efe <dir_alloc+0x32>
 8003ef6:	e006      	b.n	8003f06 <dir_alloc+0x3a>
 8003ef8:	2be5      	cmp	r3, #229	@ 0xe5
 8003efa:	d000      	beq.n	8003efe <dir_alloc+0x32>
 8003efc:	b91b      	cbnz	r3, 8003f06 <dir_alloc+0x3a>
				if (++n == n_ent) break;	/* Is a block of contiguous free entries found? */
 8003efe:	3501      	adds	r5, #1
 8003f00:	42b5      	cmp	r5, r6
 8003f02:	d101      	bne.n	8003f08 <dir_alloc+0x3c>
 8003f04:	e009      	b.n	8003f1a <dir_alloc+0x4e>
				n = 0;				/* Not a free entry, restart to search */
 8003f06:	4605      	mov	r5, r0
			res = dir_next(dp, 1);	/* Next entry with table stretch enabled */
 8003f08:	2101      	movs	r1, #1
 8003f0a:	4620      	mov	r0, r4
 8003f0c:	f7ff ff14 	bl	8003d38 <dir_next>
		} while (res == FR_OK);
 8003f10:	2800      	cmp	r0, #0
 8003f12:	d0e4      	beq.n	8003ede <dir_alloc+0x12>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8003f14:	2804      	cmp	r0, #4
 8003f16:	bf08      	it	eq
 8003f18:	2007      	moveq	r0, #7
}
 8003f1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003f1c <store_xdir>:
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
 8003f1c:	6803      	ldr	r3, [r0, #0]
{
 8003f1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE *dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
 8003f22:	691e      	ldr	r6, [r3, #16]
{
 8003f24:	4605      	mov	r5, r0
	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
 8003f26:	4630      	mov	r0, r6
 8003f28:	f7fe ff80 	bl	8002e2c <xdir_sum>
	res = dir_sdi(dp, dp->blk_ofs);
 8003f2c:	6ce9      	ldr	r1, [r5, #76]	@ 0x4c
	st_word(dirb + XDIR_SetSum, xdir_sum(dirb));
 8003f2e:	8070      	strh	r0, [r6, #2]
	res = dir_sdi(dp, dp->blk_ofs);
 8003f30:	4628      	mov	r0, r5
	nent = dirb[XDIR_NumSec] + 1;
 8003f32:	7877      	ldrb	r7, [r6, #1]
	res = dir_sdi(dp, dp->blk_ofs);
 8003f34:	f7ff fa36 	bl	80033a4 <dir_sdi>
		dp->obj.fs->wflag = 1;
 8003f38:	f04f 0801 	mov.w	r8, #1
	res = dir_sdi(dp, dp->blk_ofs);
 8003f3c:	4604      	mov	r4, r0
	while (res == FR_OK) {
 8003f3e:	b9b4      	cbnz	r4, 8003f6e <store_xdir+0x52>
		res = move_window(dp->obj.fs, dp->sect);
 8003f40:	6ba9      	ldr	r1, [r5, #56]	@ 0x38
 8003f42:	6828      	ldr	r0, [r5, #0]
 8003f44:	f7ff f842 	bl	8002fcc <move_window>
		if (res != FR_OK) break;
 8003f48:	4604      	mov	r4, r0
 8003f4a:	b980      	cbnz	r0, 8003f6e <store_xdir+0x52>
		memcpy(dp->dir, dirb, SZDIRE);
 8003f4c:	6be8      	ldr	r0, [r5, #60]	@ 0x3c
 8003f4e:	2220      	movs	r2, #32
 8003f50:	4631      	mov	r1, r6
 8003f52:	f7fe ff31 	bl	8002db8 <mem_cpy>
		dp->obj.fs->wflag = 1;
 8003f56:	682b      	ldr	r3, [r5, #0]
 8003f58:	f883 8003 	strb.w	r8, [r3, #3]
		if (--nent == 0) break;
 8003f5c:	b13f      	cbz	r7, 8003f6e <store_xdir+0x52>
		res = dir_next(dp, 0);
 8003f5e:	4621      	mov	r1, r4
 8003f60:	4628      	mov	r0, r5
 8003f62:	f7ff fee9 	bl	8003d38 <dir_next>
		dirb += SZDIRE;
 8003f66:	3620      	adds	r6, #32
		res = dir_next(dp, 0);
 8003f68:	4604      	mov	r4, r0
 8003f6a:	3f01      	subs	r7, #1
 8003f6c:	e7e7      	b.n	8003f3e <store_xdir+0x22>
	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
 8003f6e:	2c02      	cmp	r4, #2
 8003f70:	bf28      	it	cs
 8003f72:	2402      	movcs	r4, #2
}
 8003f74:	b2e0      	uxtb	r0, r4
 8003f76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08003f7c <dir_remove>:
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003f7c:	6cc1      	ldr	r1, [r0, #76]	@ 0x4c
{
 8003f7e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003f80:	1c4b      	adds	r3, r1, #1
	FATFS *fs = dp->obj.fs;
 8003f82:	6805      	ldr	r5, [r0, #0]
	DWORD last = dp->dptr;
 8003f84:	6b06      	ldr	r6, [r0, #48]	@ 0x30
{
 8003f86:	4604      	mov	r4, r0
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003f88:	d101      	bne.n	8003f8e <dir_remove+0x12>
			fs->wflag = 1;
 8003f8a:	2701      	movs	r7, #1
 8003f8c:	e003      	b.n	8003f96 <dir_remove+0x1a>
	res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
 8003f8e:	f7ff fa09 	bl	80033a4 <dir_sdi>
	if (res == FR_OK) {
 8003f92:	b9d8      	cbnz	r0, 8003fcc <dir_remove+0x50>
 8003f94:	e7f9      	b.n	8003f8a <dir_remove+0xe>
			res = move_window(fs, dp->sect);
 8003f96:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003f98:	4628      	mov	r0, r5
 8003f9a:	f7ff f817 	bl	8002fcc <move_window>
			if (res != FR_OK) break;
 8003f9e:	b9a8      	cbnz	r0, 8003fcc <dir_remove+0x50>
			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003fa0:	782b      	ldrb	r3, [r5, #0]
				dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
 8003fa2:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003fa4:	2b04      	cmp	r3, #4
				dp->dir[XDIR_Type] &= 0x7F;	/* Clear the entry InUse flag. */
 8003fa6:	bf0a      	itet	eq
 8003fa8:	7813      	ldrbeq	r3, [r2, #0]
 8003faa:	23e5      	movne	r3, #229	@ 0xe5
 8003fac:	f003 037f 	andeq.w	r3, r3, #127	@ 0x7f
 8003fb0:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 8003fb2:	70ef      	strb	r7, [r5, #3]
			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
 8003fb4:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8003fb6:	42b3      	cmp	r3, r6
 8003fb8:	d208      	bcs.n	8003fcc <dir_remove+0x50>
			res = dir_next(dp, 0);	/* Next entry */
 8003fba:	2100      	movs	r1, #0
 8003fbc:	4620      	mov	r0, r4
 8003fbe:	f7ff febb 	bl	8003d38 <dir_next>
		} while (res == FR_OK);
 8003fc2:	2800      	cmp	r0, #0
 8003fc4:	d0e7      	beq.n	8003f96 <dir_remove+0x1a>
		if (res == FR_NO_FILE) res = FR_INT_ERR;
 8003fc6:	2804      	cmp	r0, #4
 8003fc8:	bf08      	it	eq
 8003fca:	2002      	moveq	r0, #2
}
 8003fcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003fd0 <dir_read.constprop.0>:
static FRESULT dir_read (
 8003fd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	BYTE ord = 0xFF, sum = 0xFF;
 8003fd4:	27ff      	movs	r7, #255	@ 0xff
	FATFS *fs = dp->obj.fs;
 8003fd6:	6806      	ldr	r6, [r0, #0]
static FRESULT dir_read (
 8003fd8:	4604      	mov	r4, r0
	BYTE ord = 0xFF, sum = 0xFF;
 8003fda:	463d      	mov	r5, r7
	FRESULT res = FR_NO_FILE;
 8003fdc:	2004      	movs	r0, #4
	while (dp->sect) {
 8003fde:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8003fe0:	2900      	cmp	r1, #0
 8003fe2:	d074      	beq.n	80040ce <dir_read.constprop.0+0xfe>
		res = move_window(fs, dp->sect);
 8003fe4:	4630      	mov	r0, r6
 8003fe6:	f7fe fff1 	bl	8002fcc <move_window>
		if (res != FR_OK) break;
 8003fea:	2800      	cmp	r0, #0
 8003fec:	d172      	bne.n	80040d4 <dir_read.constprop.0+0x104>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
 8003fee:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8003ff0:	7803      	ldrb	r3, [r0, #0]
		if (b == 0) {
 8003ff2:	2b00      	cmp	r3, #0
 8003ff4:	d06d      	beq.n	80040d2 <dir_read.constprop.0+0x102>
		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 8003ff6:	7832      	ldrb	r2, [r6, #0]
 8003ff8:	2a04      	cmp	r2, #4
 8003ffa:	d10e      	bne.n	800401a <dir_read.constprop.0+0x4a>
				if (b == ET_FILEDIR) {		/* Start of the file entry block? */
 8003ffc:	2b85      	cmp	r3, #133	@ 0x85
 8003ffe:	d15f      	bne.n	80040c0 <dir_read.constprop.0+0xf0>
					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 8004000:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 8004002:	64e3      	str	r3, [r4, #76]	@ 0x4c
					res = load_xdir(dp);	/* Load the entry block */
 8004004:	4620      	mov	r0, r4
 8004006:	f7ff fef5 	bl	8003df4 <load_xdir>
					if (res == FR_OK) {
 800400a:	2800      	cmp	r0, #0
 800400c:	d162      	bne.n	80040d4 <dir_read.constprop.0+0x104>
						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
 800400e:	6933      	ldr	r3, [r6, #16]
 8004010:	791b      	ldrb	r3, [r3, #4]
 8004012:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8004016:	71a3      	strb	r3, [r4, #6]
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 8004018:	e04b      	b.n	80040b2 <dir_read.constprop.0+0xe2>
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800401a:	7ac2      	ldrb	r2, [r0, #11]
			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 800401c:	2be5      	cmp	r3, #229	@ 0xe5
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800401e:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
 8004022:	71a2      	strb	r2, [r4, #6]
			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 8004024:	d04b      	beq.n	80040be <dir_read.constprop.0+0xee>
 8004026:	2b2e      	cmp	r3, #46	@ 0x2e
 8004028:	d049      	beq.n	80040be <dir_read.constprop.0+0xee>
 800402a:	f022 0120 	bic.w	r1, r2, #32
 800402e:	2908      	cmp	r1, #8
 8004030:	d045      	beq.n	80040be <dir_read.constprop.0+0xee>
				if (attr == AM_LFN) {	/* An LFN entry is found */
 8004032:	2a0f      	cmp	r2, #15
 8004034:	d138      	bne.n	80040a8 <dir_read.constprop.0+0xd8>
					if (b & LLEF) {		/* Is it start of an LFN sequence? */
 8004036:	0659      	lsls	r1, r3, #25
 8004038:	d505      	bpl.n	8004046 <dir_read.constprop.0+0x76>
						b &= (BYTE)~LLEF; ord = b;
 800403a:	f003 05bf 	and.w	r5, r3, #191	@ 0xbf
						dp->blk_ofs = dp->dptr;
 800403e:	6b23      	ldr	r3, [r4, #48]	@ 0x30
						sum = dp->dir[LDIR_Chksum];
 8004040:	7b47      	ldrb	r7, [r0, #13]
						dp->blk_ofs = dp->dptr;
 8004042:	64e3      	str	r3, [r4, #76]	@ 0x4c
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8004044:	e001      	b.n	800404a <dir_read.constprop.0+0x7a>
 8004046:	42ab      	cmp	r3, r5
 8004048:	d139      	bne.n	80040be <dir_read.constprop.0+0xee>
 800404a:	7b43      	ldrb	r3, [r0, #13]
 800404c:	42bb      	cmp	r3, r7
 800404e:	d136      	bne.n	80040be <dir_read.constprop.0+0xee>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 8004050:	8b42      	ldrh	r2, [r0, #26]
 8004052:	bba2      	cbnz	r2, 80040be <dir_read.constprop.0+0xee>
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 8004054:	7803      	ldrb	r3, [r0, #0]
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8004056:	f8d6 e00c 	ldr.w	lr, [r6, #12]
	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 800405a:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 80040dc <dir_read.constprop.0+0x10c>
 800405e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8004062:	210d      	movs	r1, #13
 8004064:	3b01      	subs	r3, #1
 8004066:	434b      	muls	r3, r1
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004068:	f64f 79ff 	movw	r9, #65535	@ 0xffff
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800406c:	2101      	movs	r1, #1
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800406e:	f818 cb01 	ldrb.w	ip, [r8], #1
 8004072:	f830 c00c 	ldrh.w	ip, [r0, ip]
		if (wc != 0) {
 8004076:	b131      	cbz	r1, 8004086 <dir_read.constprop.0+0xb6>
			if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 8004078:	2b16      	cmp	r3, #22
 800407a:	d820      	bhi.n	80040be <dir_read.constprop.0+0xee>
			lfnbuf[i++] = wc = uc;			/* Store it */
 800407c:	f82e c013 	strh.w	ip, [lr, r3, lsl #1]
 8004080:	4661      	mov	r1, ip
 8004082:	3301      	adds	r3, #1
 8004084:	e001      	b.n	800408a <dir_read.constprop.0+0xba>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004086:	45cc      	cmp	ip, r9
 8004088:	d119      	bne.n	80040be <dir_read.constprop.0+0xee>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800408a:	3201      	adds	r2, #1
 800408c:	2a0d      	cmp	r2, #13
 800408e:	d1ee      	bne.n	800406e <dir_read.constprop.0+0x9e>
	if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put terminator if it is the last LFN part and not terminated */
 8004090:	7802      	ldrb	r2, [r0, #0]
 8004092:	0652      	lsls	r2, r2, #25
 8004094:	d505      	bpl.n	80040a2 <dir_read.constprop.0+0xd2>
 8004096:	b121      	cbz	r1, 80040a2 <dir_read.constprop.0+0xd2>
		if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 8004098:	2b16      	cmp	r3, #22
 800409a:	d810      	bhi.n	80040be <dir_read.constprop.0+0xee>
		lfnbuf[i] = 0;
 800409c:	2200      	movs	r2, #0
 800409e:	f82e 2013 	strh.w	r2, [lr, r3, lsl #1]
					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80040a2:	3d01      	subs	r5, #1
 80040a4:	b2ed      	uxtb	r5, r5
 80040a6:	e00b      	b.n	80040c0 <dir_read.constprop.0+0xf0>
					if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 80040a8:	b92d      	cbnz	r5, 80040b6 <dir_read.constprop.0+0xe6>
 80040aa:	f7fe feaf 	bl	8002e0c <sum_sfn>
 80040ae:	42b8      	cmp	r0, r7
 80040b0:	d101      	bne.n	80040b6 <dir_read.constprop.0+0xe6>
 80040b2:	2000      	movs	r0, #0
 80040b4:	e010      	b.n	80040d8 <dir_read.constprop.0+0x108>
						dp->blk_ofs = 0xFFFFFFFF;	/* It has no LFN. */
 80040b6:	f04f 33ff 	mov.w	r3, #4294967295
 80040ba:	64e3      	str	r3, [r4, #76]	@ 0x4c
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80040bc:	e7f9      	b.n	80040b2 <dir_read.constprop.0+0xe2>
				ord = 0xFF;
 80040be:	25ff      	movs	r5, #255	@ 0xff
		res = dir_next(dp, 0);		/* Next entry */
 80040c0:	2100      	movs	r1, #0
 80040c2:	4620      	mov	r0, r4
 80040c4:	f7ff fe38 	bl	8003d38 <dir_next>
		if (res != FR_OK) break;
 80040c8:	2800      	cmp	r0, #0
 80040ca:	d088      	beq.n	8003fde <dir_read.constprop.0+0xe>
 80040cc:	e002      	b.n	80040d4 <dir_read.constprop.0+0x104>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80040ce:	2800      	cmp	r0, #0
 80040d0:	d0ef      	beq.n	80040b2 <dir_read.constprop.0+0xe2>
 80040d2:	2004      	movs	r0, #4
 80040d4:	2300      	movs	r3, #0
 80040d6:	63a3      	str	r3, [r4, #56]	@ 0x38
}
 80040d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80040dc:	08014d2c 	.word	0x08014d2c

080040e0 <dir_find>:
{
 80040e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 80040e4:	2100      	movs	r1, #0
{
 80040e6:	b087      	sub	sp, #28
	FATFS *fs = dp->obj.fs;
 80040e8:	f8d0 8000 	ldr.w	r8, [r0]
{
 80040ec:	4604      	mov	r4, r0
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 80040ee:	f7ff f959 	bl	80033a4 <dir_sdi>
	if (res != FR_OK) return res;
 80040f2:	4607      	mov	r7, r0
 80040f4:	2800      	cmp	r0, #0
 80040f6:	f040 80dc 	bne.w	80042b2 <dir_find+0x1d2>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 80040fa:	f898 3000 	ldrb.w	r3, [r8]
 80040fe:	2b04      	cmp	r3, #4
 8004100:	d13b      	bne.n	800417a <dir_find+0x9a>
		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
 8004102:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8004106:	f7ff fb2b 	bl	8003760 <xname_sum>
 800410a:	4681      	mov	r9, r0
		while ((res = DIR_READ_FILE(dp)) == FR_OK) {	/* Read an item */
 800410c:	4620      	mov	r0, r4
 800410e:	f7ff ff5f 	bl	8003fd0 <dir_read.constprop.0>
 8004112:	4605      	mov	r5, r0
 8004114:	bb78      	cbnz	r0, 8004176 <dir_find+0x96>
			if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;		/* Skip comparison if inaccessible object name */
 8004116:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800411a:	f893 6023 	ldrb.w	r6, [r3, #35]	@ 0x23
 800411e:	2e16      	cmp	r6, #22
 8004120:	d8f4      	bhi.n	800410c <dir_find+0x2c>
			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip comparison if hash mismatched */
 8004122:	8c9b      	ldrh	r3, [r3, #36]	@ 0x24
 8004124:	454b      	cmp	r3, r9
 8004126:	d1f1      	bne.n	800410c <dir_find+0x2c>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 8004128:	f04f 0a40 	mov.w	sl, #64	@ 0x40
 800412c:	42b5      	cmp	r5, r6
 800412e:	d013      	beq.n	8004158 <dir_find+0x78>
				if ((di % SZDIRE) == 0) di += 2;
 8004130:	f01a 0f1f 	tst.w	sl, #31
 8004134:	bf08      	it	eq
 8004136:	f10a 0a02 	addeq.w	sl, sl, #2
				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
 800413a:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800413e:	f833 000a 	ldrh.w	r0, [r3, sl]
 8004142:	f001 f8d1 	bl	80052e8 <ff_wtoupper>
 8004146:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800414a:	4683      	mov	fp, r0
 800414c:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
 8004150:	f001 f8ca 	bl	80052e8 <ff_wtoupper>
 8004154:	4583      	cmp	fp, r0
 8004156:	d003      	beq.n	8004160 <dir_find+0x80>
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 8004158:	1b76      	subs	r6, r6, r5
 800415a:	b2f6      	uxtb	r6, r6
 800415c:	b126      	cbz	r6, 8004168 <dir_find+0x88>
 800415e:	e7d5      	b.n	800410c <dir_find+0x2c>
			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
 8004160:	f10a 0a02 	add.w	sl, sl, #2
 8004164:	3501      	adds	r5, #1
 8004166:	e7e1      	b.n	800412c <dir_find+0x4c>
			if (nc == 0 && !fs->lfnbuf[ni]) break;	/* Name matched? */
 8004168:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800416c:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
 8004170:	2b00      	cmp	r3, #0
 8004172:	d1cb      	bne.n	800410c <dir_find+0x2c>
 8004174:	e09d      	b.n	80042b2 <dir_find+0x1d2>
		return res;
 8004176:	4607      	mov	r7, r0
 8004178:	e09b      	b.n	80042b2 <dir_find+0x1d2>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800417a:	f04f 33ff 	mov.w	r3, #4294967295
 800417e:	64e3      	str	r3, [r4, #76]	@ 0x4c
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !memcmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8004180:	f104 0340 	add.w	r3, r4, #64	@ 0x40
 8004184:	e9cd 0303 	strd	r0, r3, [sp, #12]
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8004188:	f04f 0aff 	mov.w	sl, #255	@ 0xff
 800418c:	4655      	mov	r5, sl
		res = move_window(fs, dp->sect);
 800418e:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8004190:	4640      	mov	r0, r8
 8004192:	f7fe ff1b 	bl	8002fcc <move_window>
		if (res != FR_OK) break;
 8004196:	2800      	cmp	r0, #0
 8004198:	f040 8086 	bne.w	80042a8 <dir_find+0x1c8>
		c = dp->dir[DIR_Name];
 800419c:	6be6      	ldr	r6, [r4, #60]	@ 0x3c
 800419e:	7831      	ldrb	r1, [r6, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80041a0:	2900      	cmp	r1, #0
 80041a2:	f000 8083 	beq.w	80042ac <dir_find+0x1cc>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 80041a6:	7af2      	ldrb	r2, [r6, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 80041a8:	29e5      	cmp	r1, #229	@ 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 80041aa:	f002 033f 	and.w	r3, r2, #63	@ 0x3f
 80041ae:	71a3      	strb	r3, [r4, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 80041b0:	d06a      	beq.n	8004288 <dir_find+0x1a8>
 80041b2:	0712      	lsls	r2, r2, #28
 80041b4:	d558      	bpl.n	8004268 <dir_find+0x188>
 80041b6:	2b0f      	cmp	r3, #15
 80041b8:	d166      	bne.n	8004288 <dir_find+0x1a8>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 80041ba:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 80041be:	065f      	lsls	r7, r3, #25
 80041c0:	d46b      	bmi.n	800429a <dir_find+0x1ba>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 80041c2:	0648      	lsls	r0, r1, #25
 80041c4:	d506      	bpl.n	80041d4 <dir_find+0xf4>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 80041c6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
						sum = dp->dir[LDIR_Chksum];
 80041c8:	f896 a00d 	ldrb.w	sl, [r6, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 80041cc:	64e3      	str	r3, [r4, #76]	@ 0x4c
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 80041ce:	f001 01bf 	and.w	r1, r1, #191	@ 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80041d2:	e001      	b.n	80041d8 <dir_find+0xf8>
 80041d4:	428d      	cmp	r5, r1
 80041d6:	d15f      	bne.n	8004298 <dir_find+0x1b8>
 80041d8:	7b73      	ldrb	r3, [r6, #13]
 80041da:	4553      	cmp	r3, sl
 80041dc:	d15c      	bne.n	8004298 <dir_find+0x1b8>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 80041de:	8b73      	ldrh	r3, [r6, #26]
 80041e0:	2b00      	cmp	r3, #0
 80041e2:	d159      	bne.n	8004298 <dir_find+0x1b8>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80041e4:	7835      	ldrb	r5, [r6, #0]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80041e6:	f8d8 700c 	ldr.w	r7, [r8, #12]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80041ea:	f8df 90d4 	ldr.w	r9, [pc, #212]	@ 80042c0 <dir_find+0x1e0>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80041ee:	f8cd a004 	str.w	sl, [sp, #4]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80041f2:	f005 053f 	and.w	r5, r5, #63	@ 0x3f
 80041f6:	230d      	movs	r3, #13
 80041f8:	3d01      	subs	r5, #1
 80041fa:	435d      	muls	r5, r3
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80041fc:	eb09 0203 	add.w	r2, r9, r3
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004200:	46c3      	mov	fp, r8
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8004202:	2301      	movs	r3, #1
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8004204:	46b8      	mov	r8, r7
 8004206:	9105      	str	r1, [sp, #20]
 8004208:	4637      	mov	r7, r6
 800420a:	9402      	str	r4, [sp, #8]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 800420c:	f819 0b01 	ldrb.w	r0, [r9], #1
 8004210:	f837 a000 	ldrh.w	sl, [r7, r0]
		if (wc != 0) {
 8004214:	b18b      	cbz	r3, 800423a <dir_find+0x15a>
			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8004216:	2d16      	cmp	r5, #22
 8004218:	d83a      	bhi.n	8004290 <dir_find+0x1b0>
 800421a:	4650      	mov	r0, sl
 800421c:	f001 f864 	bl	80052e8 <ff_wtoupper>
 8004220:	4604      	mov	r4, r0
 8004222:	f838 0015 	ldrh.w	r0, [r8, r5, lsl #1]
 8004226:	f001 f85f 	bl	80052e8 <ff_wtoupper>
 800422a:	4284      	cmp	r4, r0
 800422c:	f105 0601 	add.w	r6, r5, #1
 8004230:	d12e      	bne.n	8004290 <dir_find+0x1b0>
 8004232:	4a22      	ldr	r2, [pc, #136]	@ (80042bc <dir_find+0x1dc>)
			wc = uc;
 8004234:	4653      	mov	r3, sl
			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8004236:	4635      	mov	r5, r6
 8004238:	e003      	b.n	8004242 <dir_find+0x162>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800423a:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 800423e:	458a      	cmp	sl, r1
 8004240:	d126      	bne.n	8004290 <dir_find+0x1b0>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8004242:	4591      	cmp	r9, r2
 8004244:	d1e2      	bne.n	800420c <dir_find+0x12c>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8004246:	463e      	mov	r6, r7
 8004248:	f8dd a004 	ldr.w	sl, [sp, #4]
 800424c:	7832      	ldrb	r2, [r6, #0]
 800424e:	9905      	ldr	r1, [sp, #20]
 8004250:	9c02      	ldr	r4, [sp, #8]
 8004252:	0652      	lsls	r2, r2, #25
 8004254:	4647      	mov	r7, r8
 8004256:	46d8      	mov	r8, fp
 8004258:	d503      	bpl.n	8004262 <dir_find+0x182>
 800425a:	b113      	cbz	r3, 8004262 <dir_find+0x182>
 800425c:	f837 3015 	ldrh.w	r3, [r7, r5, lsl #1]
 8004260:	b9d3      	cbnz	r3, 8004298 <dir_find+0x1b8>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8004262:	3901      	subs	r1, #1
 8004264:	b2cd      	uxtb	r5, r1
 8004266:	e018      	b.n	800429a <dir_find+0x1ba>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8004268:	b925      	cbnz	r5, 8004274 <dir_find+0x194>
 800426a:	4630      	mov	r0, r6
 800426c:	f7fe fdce 	bl	8002e0c <sum_sfn>
 8004270:	4550      	cmp	r0, sl
 8004272:	d01d      	beq.n	80042b0 <dir_find+0x1d0>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !memcmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8004274:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 8004278:	07db      	lsls	r3, r3, #31
 800427a:	d405      	bmi.n	8004288 <dir_find+0x1a8>
 800427c:	9904      	ldr	r1, [sp, #16]
 800427e:	220b      	movs	r2, #11
 8004280:	4630      	mov	r0, r6
 8004282:	f7fe fda9 	bl	8002dd8 <mem_cmp>
 8004286:	b198      	cbz	r0, 80042b0 <dir_find+0x1d0>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8004288:	f04f 33ff 	mov.w	r3, #4294967295
 800428c:	64e3      	str	r3, [r4, #76]	@ 0x4c
 800428e:	e003      	b.n	8004298 <dir_find+0x1b8>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8004290:	f8dd a004 	ldr.w	sl, [sp, #4]
 8004294:	9c02      	ldr	r4, [sp, #8]
 8004296:	46d8      	mov	r8, fp
 8004298:	25ff      	movs	r5, #255	@ 0xff
		res = dir_next(dp, 0);	/* Next entry */
 800429a:	2100      	movs	r1, #0
 800429c:	4620      	mov	r0, r4
 800429e:	f7ff fd4b 	bl	8003d38 <dir_next>
	} while (res == FR_OK);
 80042a2:	2800      	cmp	r0, #0
 80042a4:	f43f af73 	beq.w	800418e <dir_find+0xae>
		res = move_window(fs, dp->sect);
 80042a8:	4607      	mov	r7, r0
 80042aa:	e002      	b.n	80042b2 <dir_find+0x1d2>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80042ac:	2704      	movs	r7, #4
 80042ae:	e000      	b.n	80042b2 <dir_find+0x1d2>
 80042b0:	9f03      	ldr	r7, [sp, #12]
}
 80042b2:	4638      	mov	r0, r7
 80042b4:	b007      	add	sp, #28
 80042b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80042ba:	bf00      	nop
 80042bc:	08014d39 	.word	0x08014d39
 80042c0:	08014d2c 	.word	0x08014d2c

080042c4 <dir_register>:
{
 80042c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80042c8:	f890 804b 	ldrb.w	r8, [r0, #75]	@ 0x4b
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 80042cc:	f018 08a0 	ands.w	r8, r8, #160	@ 0xa0
{
 80042d0:	b099      	sub	sp, #100	@ 0x64
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 80042d2:	f040 818e 	bne.w	80045f2 <dir_register+0x32e>
	FATFS *fs = dp->obj.fs;
 80042d6:	6806      	ldr	r6, [r0, #0]
	for (len = 0; fs->lfnbuf[len]; len++) ;	/* Get lfn length */
 80042d8:	68f3      	ldr	r3, [r6, #12]
 80042da:	4604      	mov	r4, r0
 80042dc:	f833 2018 	ldrh.w	r2, [r3, r8, lsl #1]
 80042e0:	b112      	cbz	r2, 80042e8 <dir_register+0x24>
 80042e2:	f108 0801 	add.w	r8, r8, #1
 80042e6:	e7f9      	b.n	80042dc <dir_register+0x18>
	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 80042e8:	7833      	ldrb	r3, [r6, #0]
 80042ea:	2b04      	cmp	r3, #4
 80042ec:	f040 808f 	bne.w	800440e <dir_register+0x14a>
		n_ent = (len + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
 80042f0:	230f      	movs	r3, #15
 80042f2:	f108 080e 	add.w	r8, r8, #14
		res = dir_alloc(dp, n_ent);		/* Allocate directory entries */
 80042f6:	4620      	mov	r0, r4
		n_ent = (len + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
 80042f8:	fbb8 f8f3 	udiv	r8, r8, r3
		res = dir_alloc(dp, n_ent);		/* Allocate directory entries */
 80042fc:	f108 0102 	add.w	r1, r8, #2
 8004300:	f7ff fde4 	bl	8003ecc <dir_alloc>
		if (res != FR_OK) return res;
 8004304:	4605      	mov	r5, r0
 8004306:	2800      	cmp	r0, #0
 8004308:	f040 8174 	bne.w	80045f4 <dir_register+0x330>
		dp->blk_ofs = dp->dptr - SZDIRE * (n_ent - 1);	/* Set the allocated entry block offset */
 800430c:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 800430e:	f108 0801 	add.w	r8, r8, #1
 8004312:	eba3 1348 	sub.w	r3, r3, r8, lsl #5
 8004316:	64e3      	str	r3, [r4, #76]	@ 0x4c
		if (dp->obj.stat & 4) {			/* Has the directory been stretched by new allocation? */
 8004318:	79e3      	ldrb	r3, [r4, #7]
 800431a:	075f      	lsls	r7, r3, #29
 800431c:	d547      	bpl.n	80043ae <dir_register+0xea>
			dp->obj.stat &= ~4;
 800431e:	f023 0304 	bic.w	r3, r3, #4
 8004322:	71e3      	strb	r3, [r4, #7]
			res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
 8004324:	4620      	mov	r0, r4
 8004326:	f7fe ff93 	bl	8003250 <fill_first_frag>
			if (res != FR_OK) return res;
 800432a:	2800      	cmp	r0, #0
 800432c:	f040 8162 	bne.w	80045f4 <dir_register+0x330>
			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
 8004330:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8004332:	f04f 32ff 	mov.w	r2, #4294967295
 8004336:	4620      	mov	r0, r4
 8004338:	f7fe ff72 	bl	8003220 <fill_last_frag>
			if (res != FR_OK) return res;
 800433c:	2800      	cmp	r0, #0
 800433e:	f040 8159 	bne.w	80045f4 <dir_register+0x330>
			if (dp->obj.sclust != 0) {		/* Is it a sub-directory? */
 8004342:	68a3      	ldr	r3, [r4, #8]
 8004344:	2b00      	cmp	r3, #0
 8004346:	d032      	beq.n	80043ae <dir_register+0xea>
	dp->obj.fs = obj->fs;
 8004348:	6823      	ldr	r3, [r4, #0]
 800434a:	9302      	str	r3, [sp, #8]
	dp->obj.sclust = obj->c_scl;
 800434c:	6a23      	ldr	r3, [r4, #32]
 800434e:	9304      	str	r3, [sp, #16]
	dp->obj.stat = (BYTE)obj->c_size;
 8004350:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8004352:	f88d 300f 	strb.w	r3, [sp, #15]
	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 8004356:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800435a:	e9cd 3006 	strd	r3, r0, [sp, #24]
	dp->blk_ofs = obj->c_ofs;
 800435e:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
	dp->obj.n_frag = 0;
 8004360:	9009      	str	r0, [sp, #36]	@ 0x24
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 8004362:	a802      	add	r0, sp, #8
	dp->blk_ofs = obj->c_ofs;
 8004364:	9115      	str	r1, [sp, #84]	@ 0x54
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 8004366:	f7ff f81d 	bl	80033a4 <dir_sdi>
	if (res == FR_OK) {
 800436a:	2800      	cmp	r0, #0
 800436c:	f040 8142 	bne.w	80045f4 <dir_register+0x330>
		res = load_xdir(dp);		/* Load the object's entry block */
 8004370:	a802      	add	r0, sp, #8
 8004372:	f7ff fd3f 	bl	8003df4 <load_xdir>
				if (res != FR_OK) return res;
 8004376:	2800      	cmp	r0, #0
 8004378:	f040 813c 	bne.w	80045f4 <dir_register+0x330>
				dp->obj.objsize += (DWORD)fs->csize * SS(fs);		/* Increase the directory size by cluster size */
 800437c:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
 8004380:	8970      	ldrh	r0, [r6, #10]
 8004382:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004386:	fbe0 3102 	umlal	r3, r1, r0, r2
				st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);
 800438a:	6932      	ldr	r2, [r6, #16]
				dp->obj.objsize += (DWORD)fs->csize * SS(fs);		/* Increase the directory size by cluster size */
 800438c:	e9c4 3104 	strd	r3, r1, [r4, #16]
				st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);
 8004390:	e9c2 310e 	strd	r3, r1, [r2, #56]	@ 0x38
				st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
 8004394:	e9c2 310a 	strd	r3, r1, [r2, #40]	@ 0x28
				fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;		/* Update the allocation status */
 8004398:	79e3      	ldrb	r3, [r4, #7]
 800439a:	f043 0301 	orr.w	r3, r3, #1
 800439e:	f882 3021 	strb.w	r3, [r2, #33]	@ 0x21
				res = store_xdir(&dj);				/* Store the object status */
 80043a2:	a802      	add	r0, sp, #8
 80043a4:	f7ff fdba 	bl	8003f1c <store_xdir>
				if (res != FR_OK) return res;
 80043a8:	2800      	cmp	r0, #0
 80043aa:	f040 8123 	bne.w	80045f4 <dir_register+0x330>
		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
 80043ae:	e9d6 6403 	ldrd	r6, r4, [r6, #12]
	memset(dirb, 0, 2 * SZDIRE);
 80043b2:	2240      	movs	r2, #64	@ 0x40
 80043b4:	2100      	movs	r1, #0
	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
 80043b6:	2385      	movs	r3, #133	@ 0x85
	memset(dirb, 0, 2 * SZDIRE);
 80043b8:	4620      	mov	r0, r4
 80043ba:	f7fe fd07 	bl	8002dcc <mem_set>
	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
 80043be:	7023      	strb	r3, [r4, #0]
	dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;
 80043c0:	23c0      	movs	r3, #192	@ 0xc0
 80043c2:	f884 3020 	strb.w	r3, [r4, #32]
	nlen = nc1 = 0; wc = 1;
 80043c6:	2201      	movs	r2, #1
	i = SZDIRE * 2;	/* Top of file_name entries */
 80043c8:	2340      	movs	r3, #64	@ 0x40
		dirb[i++] = ET_FILENAME; dirb[i++] = 0;
 80043ca:	f04f 0cc1 	mov.w	ip, #193	@ 0xc1
 80043ce:	460f      	mov	r7, r1
 80043d0:	1c58      	adds	r0, r3, #1
 80043d2:	f804 c003 	strb.w	ip, [r4, r3]
 80043d6:	5427      	strb	r7, [r4, r0]
 80043d8:	3302      	adds	r3, #2
			if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
 80043da:	b122      	cbz	r2, 80043e6 <dir_register+0x122>
 80043dc:	f836 2015 	ldrh.w	r2, [r6, r5, lsl #1]
 80043e0:	b10a      	cbz	r2, 80043e6 <dir_register+0x122>
 80043e2:	3501      	adds	r5, #1
 80043e4:	b2ed      	uxtb	r5, r5
			st_word(dirb + i, wc); 	/* Store it */
 80043e6:	52e2      	strh	r2, [r4, r3]
			i += 2;
 80043e8:	3302      	adds	r3, #2
		} while (i % SZDIRE != 0);
 80043ea:	06d8      	lsls	r0, r3, #27
 80043ec:	d1f5      	bne.n	80043da <dir_register+0x116>
	} while (lfn[nlen]);	/* Fill next entry if any char follows */
 80043ee:	f836 0015 	ldrh.w	r0, [r6, r5, lsl #1]
 80043f2:	f101 0e01 	add.w	lr, r1, #1
 80043f6:	b108      	cbz	r0, 80043fc <dir_register+0x138>
 80043f8:	4671      	mov	r1, lr
 80043fa:	e7e9      	b.n	80043d0 <dir_register+0x10c>
	dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
 80043fc:	3102      	adds	r1, #2
	dirb[XDIR_NumName] = nlen;		/* Set name length */
 80043fe:	f884 5023 	strb.w	r5, [r4, #35]	@ 0x23
	dirb[XDIR_NumSec] = 1 + nc1;	/* Set secondary count (C0 + C1s) */
 8004402:	7061      	strb	r1, [r4, #1]
	st_word(dirb + XDIR_NameHash, xname_sum(lfn));	/* Set name hash */
 8004404:	4630      	mov	r0, r6
 8004406:	f7ff f9ab 	bl	8003760 <xname_sum>
 800440a:	84a0      	strh	r0, [r4, #36]	@ 0x24
}
 800440c:	e0ef      	b.n	80045ee <dir_register+0x32a>
	memcpy(sn, dp->fn, 12);
 800440e:	f104 0740 	add.w	r7, r4, #64	@ 0x40
 8004412:	220c      	movs	r2, #12
 8004414:	4639      	mov	r1, r7
 8004416:	a802      	add	r0, sp, #8
 8004418:	f7fe fcce 	bl	8002db8 <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 800441c:	f89d a013 	ldrb.w	sl, [sp, #19]
 8004420:	f01a 0f01 	tst.w	sl, #1
 8004424:	d06c      	beq.n	8004500 <dir_register+0x23c>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 8004426:	2340      	movs	r3, #64	@ 0x40
				if (sreg & 0x10000) sreg ^= 0x11021;
 8004428:	4d74      	ldr	r5, [pc, #464]	@ (80045fc <dir_register+0x338>)
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 800442a:	f884 304b 	strb.w	r3, [r4, #75]	@ 0x4b
		for (n = 1; n < 100; n++) {
 800442e:	f04f 0901 	mov.w	r9, #1
	memcpy(dst, src, 11);	/* Prepare the SFN to be modified */
 8004432:	220b      	movs	r2, #11
 8004434:	a902      	add	r1, sp, #8
 8004436:	4638      	mov	r0, r7
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 8004438:	f8d6 b00c 	ldr.w	fp, [r6, #12]
	memcpy(dst, src, 11);	/* Prepare the SFN to be modified */
 800443c:	f7fe fcbc 	bl	8002db8 <mem_cpy>
	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8004440:	f1b9 0f05 	cmp.w	r9, #5
 8004444:	d913      	bls.n	800446e <dir_register+0x1aa>
 8004446:	f1ab 0202 	sub.w	r2, fp, #2
		sreg = seq;
 800444a:	464b      	mov	r3, r9
		while (*lfn) {	/* Create a CRC as hash value */
 800444c:	f832 1f02 	ldrh.w	r1, [r2, #2]!
 8004450:	b171      	cbz	r1, 8004470 <dir_register+0x1ac>
 8004452:	2010      	movs	r0, #16
				sreg = (sreg << 1) + (wc & 1);
 8004454:	f001 0c01 	and.w	ip, r1, #1
 8004458:	eb0c 0343 	add.w	r3, ip, r3, lsl #1
				if (sreg & 0x10000) sreg ^= 0x11021;
 800445c:	f413 3f80 	tst.w	r3, #65536	@ 0x10000
 8004460:	bf18      	it	ne
 8004462:	406b      	eorne	r3, r5
			for (i = 0; i < 16; i++) {
 8004464:	3801      	subs	r0, #1
				wc >>= 1;
 8004466:	ea4f 0151 	mov.w	r1, r1, lsr #1
			for (i = 0; i < 16; i++) {
 800446a:	d1f3      	bne.n	8004454 <dir_register+0x190>
 800446c:	e7ee      	b.n	800444c <dir_register+0x188>
 800446e:	464b      	mov	r3, r9
 8004470:	a802      	add	r0, sp, #8
 8004472:	2207      	movs	r2, #7
		c = (BYTE)((seq % 16) + '0'); seq /= 16;
 8004474:	f003 0c0f 	and.w	ip, r3, #15
 8004478:	f10c 0130 	add.w	r1, ip, #48	@ 0x30
		if (c > '9') c += 7;
 800447c:	2939      	cmp	r1, #57	@ 0x39
 800447e:	bf88      	it	hi
 8004480:	f10c 0137 	addhi.w	r1, ip, #55	@ 0x37
	} while (i && seq);
 8004484:	3a01      	subs	r2, #1
 8004486:	469e      	mov	lr, r3
		ns[i--] = c;
 8004488:	f800 1d01 	strb.w	r1, [r0, #-1]!
		c = (BYTE)((seq % 16) + '0'); seq /= 16;
 800448c:	ea4f 1313 	mov.w	r3, r3, lsr #4
	} while (i && seq);
 8004490:	d002      	beq.n	8004498 <dir_register+0x1d4>
 8004492:	f1be 0f0f 	cmp.w	lr, #15
 8004496:	d8ed      	bhi.n	8004474 <dir_register+0x1b0>
	ns[i] = '~';
 8004498:	f102 0360 	add.w	r3, r2, #96	@ 0x60
 800449c:	446b      	add	r3, sp
 800449e:	217e      	movs	r1, #126	@ 0x7e
 80044a0:	f803 1c60 	strb.w	r1, [r3, #-96]
	for (j = 0; j < i && dst[j] != ' '; j++) {	/* Find the offset to append */
 80044a4:	f104 013f 	add.w	r1, r4, #63	@ 0x3f
 80044a8:	2300      	movs	r3, #0
 80044aa:	4293      	cmp	r3, r2
 80044ac:	d007      	beq.n	80044be <dir_register+0x1fa>
 80044ae:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 80044b2:	2820      	cmp	r0, #32
 80044b4:	f103 0c01 	add.w	ip, r3, #1
 80044b8:	d001      	beq.n	80044be <dir_register+0x1fa>
 80044ba:	4663      	mov	r3, ip
 80044bc:	e7f5      	b.n	80044aa <dir_register+0x1e6>
 80044be:	333f      	adds	r3, #63	@ 0x3f
 80044c0:	4423      	add	r3, r4
 80044c2:	f104 0047 	add.w	r0, r4, #71	@ 0x47
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 80044c6:	2a07      	cmp	r2, #7
 80044c8:	d806      	bhi.n	80044d8 <dir_register+0x214>
 80044ca:	f102 0160 	add.w	r1, r2, #96	@ 0x60
 80044ce:	4469      	add	r1, sp
 80044d0:	3201      	adds	r2, #1
 80044d2:	f811 1c60 	ldrb.w	r1, [r1, #-96]
 80044d6:	e000      	b.n	80044da <dir_register+0x216>
 80044d8:	2120      	movs	r1, #32
 80044da:	f803 1f01 	strb.w	r1, [r3, #1]!
	} while (j < 8);
 80044de:	4298      	cmp	r0, r3
 80044e0:	d1f1      	bne.n	80044c6 <dir_register+0x202>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 80044e2:	4620      	mov	r0, r4
 80044e4:	f7ff fdfc 	bl	80040e0 <dir_find>
			if (res != FR_OK) break;
 80044e8:	b930      	cbnz	r0, 80044f8 <dir_register+0x234>
		for (n = 1; n < 100; n++) {
 80044ea:	f109 0901 	add.w	r9, r9, #1
 80044ee:	f1b9 0f64 	cmp.w	r9, #100	@ 0x64
 80044f2:	d19e      	bne.n	8004432 <dir_register+0x16e>
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 80044f4:	2007      	movs	r0, #7
 80044f6:	e07d      	b.n	80045f4 <dir_register+0x330>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 80044f8:	2804      	cmp	r0, #4
 80044fa:	d17b      	bne.n	80045f4 <dir_register+0x330>
		dp->fn[NSFLAG] = sn[NSFLAG];
 80044fc:	f884 a04b 	strb.w	sl, [r4, #75]	@ 0x4b
	n_ent = (sn[NSFLAG] & NS_LFN) ? (len + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8004500:	f01a 0f02 	tst.w	sl, #2
 8004504:	d006      	beq.n	8004514 <dir_register+0x250>
 8004506:	f108 050c 	add.w	r5, r8, #12
 800450a:	230d      	movs	r3, #13
 800450c:	fbb5 f5f3 	udiv	r5, r5, r3
 8004510:	3501      	adds	r5, #1
 8004512:	e000      	b.n	8004516 <dir_register+0x252>
 8004514:	2501      	movs	r5, #1
	res = dir_alloc(dp, n_ent);		/* Allocate entries */
 8004516:	4629      	mov	r1, r5
 8004518:	4620      	mov	r0, r4
 800451a:	f7ff fcd7 	bl	8003ecc <dir_alloc>
	if (res == FR_OK && --n_ent) {	/* Set LFN entry if needed */
 800451e:	2800      	cmp	r0, #0
 8004520:	d168      	bne.n	80045f4 <dir_register+0x330>
 8004522:	3d01      	subs	r5, #1
 8004524:	d118      	bne.n	8004558 <dir_register+0x294>
		res = move_window(fs, dp->sect);
 8004526:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8004528:	4630      	mov	r0, r6
 800452a:	f7fe fd4f 	bl	8002fcc <move_window>
		if (res == FR_OK) {
 800452e:	2800      	cmp	r0, #0
 8004530:	d160      	bne.n	80045f4 <dir_register+0x330>
			memset(dp->dir, 0, SZDIRE);	/* Clean the entry */
 8004532:	4601      	mov	r1, r0
 8004534:	2220      	movs	r2, #32
 8004536:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8004538:	f7fe fc48 	bl	8002dcc <mem_set>
			memcpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 800453c:	220b      	movs	r2, #11
 800453e:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8004540:	4639      	mov	r1, r7
 8004542:	f7fe fc39 	bl	8002db8 <mem_cpy>
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8004546:	f894 304b 	ldrb.w	r3, [r4, #75]	@ 0x4b
 800454a:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 800454c:	f003 0318 	and.w	r3, r3, #24
 8004550:	7313      	strb	r3, [r2, #12]
			fs->wflag = 1;
 8004552:	2301      	movs	r3, #1
 8004554:	70f3      	strb	r3, [r6, #3]
 8004556:	e04a      	b.n	80045ee <dir_register+0x32a>
		res = dir_sdi(dp, dp->dptr - n_ent * SZDIRE);
 8004558:	6b21      	ldr	r1, [r4, #48]	@ 0x30
 800455a:	4620      	mov	r0, r4
 800455c:	eba1 1145 	sub.w	r1, r1, r5, lsl #5
 8004560:	f7fe ff20 	bl	80033a4 <dir_sdi>
		if (res == FR_OK) {
 8004564:	2800      	cmp	r0, #0
 8004566:	d145      	bne.n	80045f4 <dir_register+0x330>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 8004568:	4638      	mov	r0, r7
 800456a:	f7fe fc4f 	bl	8002e0c <sum_sfn>
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 800456e:	f64f 79ff 	movw	r9, #65535	@ 0xffff
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 8004572:	4680      	mov	r8, r0
				res = move_window(fs, dp->sect);
 8004574:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8004576:	4630      	mov	r0, r6
 8004578:	f7fe fd28 	bl	8002fcc <move_window>
 800457c:	4603      	mov	r3, r0
				if (res != FR_OK) break;
 800457e:	bbc8      	cbnz	r0, 80045f4 <dir_register+0x330>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)n_ent, sum);
 8004580:	6be2      	ldr	r2, [r4, #60]	@ 0x3c
 8004582:	f8d6 e00c 	ldr.w	lr, [r6, #12]
 8004586:	f8df a078 	ldr.w	sl, [pc, #120]	@ 8004600 <dir_register+0x33c>
	dir[LDIR_Type] = 0;
 800458a:	7310      	strb	r0, [r2, #12]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 800458c:	f04f 010f 	mov.w	r1, #15
 8004590:	fa5f fc85 	uxtb.w	ip, r5
 8004594:	72d1      	strb	r1, [r2, #11]
	st_word(dir + LDIR_FstClusLO, 0);
 8004596:	8350      	strh	r0, [r2, #26]
	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 8004598:	f10c 31ff 	add.w	r1, ip, #4294967295
 800459c:	200d      	movs	r0, #13
 800459e:	4341      	muls	r1, r0
	dir[LDIR_Chksum] = sum;			/* Set checksum */
 80045a0:	f882 800d 	strb.w	r8, [r2, #13]
	s = wc = 0;
 80045a4:	4618      	mov	r0, r3
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80045a6:	4548      	cmp	r0, r9
 80045a8:	bf18      	it	ne
 80045aa:	f83e 0011 	ldrhne.w	r0, [lr, r1, lsl #1]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 80045ae:	f81a bb01 	ldrb.w	fp, [sl], #1
	} while (++s < 13);
 80045b2:	f103 0301 	add.w	r3, r3, #1
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80045b6:	bf18      	it	ne
 80045b8:	3101      	addne	r1, #1
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 80045ba:	f822 000b 	strh.w	r0, [r2, fp]
		if (wc == 0) wc = 0xFFFF;			/* Padding characters for following items */
 80045be:	2800      	cmp	r0, #0
 80045c0:	bf08      	it	eq
 80045c2:	4648      	moveq	r0, r9
	} while (++s < 13);
 80045c4:	2b0d      	cmp	r3, #13
 80045c6:	d1ee      	bne.n	80045a6 <dir_register+0x2e2>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 80045c8:	4548      	cmp	r0, r9
 80045ca:	d002      	beq.n	80045d2 <dir_register+0x30e>
 80045cc:	f83e 3011 	ldrh.w	r3, [lr, r1, lsl #1]
 80045d0:	b90b      	cbnz	r3, 80045d6 <dir_register+0x312>
 80045d2:	f04c 0c40 	orr.w	ip, ip, #64	@ 0x40
				fs->wflag = 1;
 80045d6:	2301      	movs	r3, #1
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 80045d8:	f882 c000 	strb.w	ip, [r2]
				res = dir_next(dp, 0);	/* Next entry */
 80045dc:	2100      	movs	r1, #0
				fs->wflag = 1;
 80045de:	70f3      	strb	r3, [r6, #3]
				res = dir_next(dp, 0);	/* Next entry */
 80045e0:	4620      	mov	r0, r4
 80045e2:	f7ff fba9 	bl	8003d38 <dir_next>
			} while (res == FR_OK && --n_ent);
 80045e6:	b928      	cbnz	r0, 80045f4 <dir_register+0x330>
 80045e8:	3d01      	subs	r5, #1
 80045ea:	d1c3      	bne.n	8004574 <dir_register+0x2b0>
 80045ec:	e79b      	b.n	8004526 <dir_register+0x262>
		return FR_OK;
 80045ee:	2000      	movs	r0, #0
 80045f0:	e000      	b.n	80045f4 <dir_register+0x330>
	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 80045f2:	2006      	movs	r0, #6
}
 80045f4:	b019      	add	sp, #100	@ 0x64
 80045f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80045fa:	bf00      	nop
 80045fc:	00011021 	.word	0x00011021
 8004600:	08014d2c 	.word	0x08014d2c

08004604 <init_alloc_info.isra.0>:
	obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Start cluster */
 8004604:	6b43      	ldr	r3, [r0, #52]	@ 0x34
 8004606:	608b      	str	r3, [r1, #8]
	obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);	/* Size */
 8004608:	e9d0 230e 	ldrd	r2, r3, [r0, #56]	@ 0x38
 800460c:	e9c1 2304 	strd	r2, r3, [r1, #16]
	obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;				/* Allocation status */
 8004610:	f890 3021 	ldrb.w	r3, [r0, #33]	@ 0x21
 8004614:	f003 0302 	and.w	r3, r3, #2
 8004618:	71cb      	strb	r3, [r1, #7]
	obj->n_frag = 0;										/* No last fragment info */
 800461a:	2300      	movs	r3, #0
 800461c:	61cb      	str	r3, [r1, #28]
}
 800461e:	4770      	bx	lr

08004620 <ld_clust.isra.0>:
	if (fs->fs_type == FS_FAT32) {
 8004620:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 8004622:	8b4b      	ldrh	r3, [r1, #26]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8004624:	bf04      	itt	eq
 8004626:	8a8a      	ldrheq	r2, [r1, #20]
 8004628:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16
}
 800462c:	4618      	mov	r0, r3
 800462e:	4770      	bx	lr

08004630 <follow_path>:
{
 8004630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004634:	b085      	sub	sp, #20
	FATFS *fs = dp->obj.fs;
 8004636:	6803      	ldr	r3, [r0, #0]
 8004638:	9302      	str	r3, [sp, #8]
{
 800463a:	4605      	mov	r5, r0
 800463c:	468b      	mov	fp, r1
		while (IsSeparator(*path)) path++;	/* Strip separators */
 800463e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8004642:	2b2f      	cmp	r3, #47	@ 0x2f
 8004644:	d0fa      	beq.n	800463c <follow_path+0xc>
 8004646:	2b5c      	cmp	r3, #92	@ 0x5c
 8004648:	d0f8      	beq.n	800463c <follow_path+0xc>
		dp->obj.sclust = 0;					/* Start from the root directory */
 800464a:	2300      	movs	r3, #0
 800464c:	60ab      	str	r3, [r5, #8]
	dp->obj.n_frag = 0;	/* Invalidate last fragment counter of the object */
 800464e:	61eb      	str	r3, [r5, #28]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8004650:	f89b 3000 	ldrb.w	r3, [fp]
 8004654:	2b1f      	cmp	r3, #31
 8004656:	f200 80b3 	bhi.w	80047c0 <follow_path+0x190>
		dp->fn[NSFLAG] = NS_NONAME;
 800465a:	2380      	movs	r3, #128	@ 0x80
		res = dir_sdi(dp, 0);
 800465c:	2100      	movs	r1, #0
 800465e:	4628      	mov	r0, r5
		dp->fn[NSFLAG] = NS_NONAME;
 8004660:	f885 304b 	strb.w	r3, [r5, #75]	@ 0x4b
}
 8004664:	b005      	add	sp, #20
 8004666:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		res = dir_sdi(dp, 0);
 800466a:	f7fe be9b 	b.w	80033a4 <dir_sdi>
		wc = ff_oem2uni(wc, CODEPAGE);	/* ANSI/OEM ==> Unicode */
 800466e:	f240 3162 	movw	r1, #866	@ 0x362
 8004672:	f000 fe25 	bl	80052c0 <ff_oem2uni>
		if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
 8004676:	2800      	cmp	r0, #0
 8004678:	f000 813f 	beq.w	80048fa <follow_path+0x2ca>
		if (wc < ' ' || IsSeparator(wc)) break;	/* Break if end of the path or a separator is found */
 800467c:	281f      	cmp	r0, #31
 800467e:	d917      	bls.n	80046b0 <follow_path+0x80>
 8004680:	282f      	cmp	r0, #47	@ 0x2f
 8004682:	f000 8146 	beq.w	8004912 <follow_path+0x2e2>
 8004686:	285c      	cmp	r0, #92	@ 0x5c
 8004688:	f000 8143 	beq.w	8004912 <follow_path+0x2e2>
		if (wc < 0x80 && strchr("*:<>|\"\?\x7F", (int)wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 800468c:	287f      	cmp	r0, #127	@ 0x7f
 800468e:	d805      	bhi.n	800469c <follow_path+0x6c>
 8004690:	4ba9      	ldr	r3, [pc, #676]	@ (8004938 <follow_path+0x308>)
	while (*str && *str != chr) str++;
 8004692:	f813 2b01 	ldrb.w	r2, [r3], #1
 8004696:	2a00      	cmp	r2, #0
 8004698:	f040 8097 	bne.w	80047ca <follow_path+0x19a>
		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 800469c:	2e16      	cmp	r6, #22
 800469e:	f000 812c 	beq.w	80048fa <follow_path+0x2ca>
		lfn[di++] = wc;				/* Store the Unicode character */
 80046a2:	f829 0016 	strh.w	r0, [r9, r6, lsl #1]
		uc = tchar2uni(&p);			/* Get a character */
 80046a6:	3601      	adds	r6, #1
	wc = (BYTE)*p++;			/* Get a byte */
 80046a8:	f81b 0b01 	ldrb.w	r0, [fp], #1
	if (wc != 0) {
 80046ac:	2800      	cmp	r0, #0
 80046ae:	d1de      	bne.n	800466e <follow_path+0x3e>
		cf = NS_LAST;			/* Last segment */
 80046b0:	2404      	movs	r4, #4
	while (di) {					/* Snip off trailing spaces and dots if exist */
 80046b2:	eb09 0346 	add.w	r3, r9, r6, lsl #1
 80046b6:	b13e      	cbz	r6, 80046c8 <follow_path+0x98>
		wc = lfn[di - 1];
 80046b8:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
		if (wc != ' ' && wc != '.') break;
 80046bc:	2a20      	cmp	r2, #32
 80046be:	f000 8088 	beq.w	80047d2 <follow_path+0x1a2>
 80046c2:	2a2e      	cmp	r2, #46	@ 0x2e
 80046c4:	f000 8085 	beq.w	80047d2 <follow_path+0x1a2>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 80046c8:	f04f 0300 	mov.w	r3, #0
 80046cc:	f829 3016 	strh.w	r3, [r9, r6, lsl #1]
 80046d0:	eb09 0246 	add.w	r2, r9, r6, lsl #1
	if (di == 0) return FR_INVALID_NAME;	/* Reject null name */
 80046d4:	2e00      	cmp	r6, #0
 80046d6:	f000 8110 	beq.w	80048fa <follow_path+0x2ca>
	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 80046da:	2100      	movs	r1, #0
 80046dc:	f839 0011 	ldrh.w	r0, [r9, r1, lsl #1]
 80046e0:	2820      	cmp	r0, #32
 80046e2:	460b      	mov	r3, r1
 80046e4:	f101 0101 	add.w	r1, r1, #1
 80046e8:	d0f8      	beq.n	80046dc <follow_path+0xac>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 80046ea:	2b00      	cmp	r3, #0
 80046ec:	d173      	bne.n	80047d6 <follow_path+0x1a6>
 80046ee:	282e      	cmp	r0, #46	@ 0x2e
 80046f0:	d071      	beq.n	80047d6 <follow_path+0x1a6>
	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
 80046f2:	f832 1d02 	ldrh.w	r1, [r2, #-2]!
 80046f6:	292e      	cmp	r1, #46	@ 0x2e
 80046f8:	d001      	beq.n	80046fe <follow_path+0xce>
 80046fa:	3e01      	subs	r6, #1
 80046fc:	d1f9      	bne.n	80046f2 <follow_path+0xc2>
	memset(dp->fn, ' ', 11);
 80046fe:	220b      	movs	r2, #11
 8004700:	2120      	movs	r1, #32
 8004702:	f105 0040 	add.w	r0, r5, #64	@ 0x40
	i = b = 0; ni = 8;
 8004706:	2700      	movs	r7, #0
	memset(dp->fn, ' ', 11);
 8004708:	f7fe fb60 	bl	8002dcc <mem_set>
	i = b = 0; ni = 8;
 800470c:	f04f 0808 	mov.w	r8, #8
 8004710:	464a      	mov	r2, r9
 8004712:	f8cd b004 	str.w	fp, [sp, #4]
 8004716:	46ba      	mov	sl, r7
 8004718:	46b1      	mov	r9, r6
 800471a:	46ab      	mov	fp, r5
		wc = lfn[si++];					/* Get an LFN character */
 800471c:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
 8004720:	1c5e      	adds	r6, r3, #1
		if (wc == 0) break;				/* Break on end of the LFN */
 8004722:	2800      	cmp	r0, #0
 8004724:	f000 80c0 	beq.w	80048a8 <follow_path+0x278>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 8004728:	2820      	cmp	r0, #32
 800472a:	d05b      	beq.n	80047e4 <follow_path+0x1b4>
 800472c:	282e      	cmp	r0, #46	@ 0x2e
 800472e:	d056      	beq.n	80047de <follow_path+0x1ae>
		if (i >= ni || si == di) {		/* End of field? */
 8004730:	4547      	cmp	r7, r8
 8004732:	d35c      	bcc.n	80047ee <follow_path+0x1be>
			if (ni == 11) {				/* Name extension overflow? */
 8004734:	f1b8 0f0b 	cmp.w	r8, #11
 8004738:	d15c      	bne.n	80047f4 <follow_path+0x1c4>
 800473a:	465d      	mov	r5, fp
				cf |= NS_LOSS | NS_LFN;
 800473c:	f044 0403 	orr.w	r4, r4, #3
 8004740:	f8dd b004 	ldr.w	fp, [sp, #4]
 8004744:	b2e4      	uxtb	r4, r4
				break;
 8004746:	f04f 080b 	mov.w	r8, #11
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800474a:	f895 3040 	ldrb.w	r3, [r5, #64]	@ 0x40
 800474e:	2be5      	cmp	r3, #229	@ 0xe5
 8004750:	bf04      	itt	eq
 8004752:	2305      	moveq	r3, #5
 8004754:	f885 3040 	strbeq.w	r3, [r5, #64]	@ 0x40
	if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
 8004758:	f1b8 0f08 	cmp.w	r8, #8
 800475c:	bf04      	itt	eq
 800475e:	ea4f 018a 	moveq.w	r1, sl, lsl #2
 8004762:	fa5f fa81 	uxtbeq.w	sl, r1
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 8004766:	f00a 030c 	and.w	r3, sl, #12
 800476a:	2b0c      	cmp	r3, #12
 800476c:	f040 80a0 	bne.w	80048b0 <follow_path+0x280>
 8004770:	f044 0402 	orr.w	r4, r4, #2
 8004774:	b2e4      	uxtb	r4, r4
	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
 8004776:	f885 404b 	strb.w	r4, [r5, #75]	@ 0x4b
			res = dir_find(dp);				/* Find an object with the segment name */
 800477a:	4628      	mov	r0, r5
 800477c:	f7ff fcb0 	bl	80040e0 <dir_find>
			ns = dp->fn[NSFLAG];
 8004780:	f895 304b 	ldrb.w	r3, [r5, #75]	@ 0x4b
			if (res != FR_OK) {				/* Failed to find the object */
 8004784:	2800      	cmp	r0, #0
 8004786:	f040 80a6 	bne.w	80048d6 <follow_path+0x2a6>
			if (ns & NS_LAST) break;		/* Last segment matched. Function completed. */
 800478a:	075a      	lsls	r2, r3, #29
 800478c:	f100 80d0 	bmi.w	8004930 <follow_path+0x300>
			if (!(dp->obj.attr & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8004790:	79ab      	ldrb	r3, [r5, #6]
 8004792:	06db      	lsls	r3, r3, #27
 8004794:	f140 80b3 	bpl.w	80048fe <follow_path+0x2ce>
			if (fs->fs_type == FS_EXFAT) {	/* Save containing directory information for next dir */
 8004798:	9b02      	ldr	r3, [sp, #8]
 800479a:	7818      	ldrb	r0, [r3, #0]
 800479c:	2804      	cmp	r0, #4
 800479e:	f040 80a1 	bne.w	80048e4 <follow_path+0x2b4>
				dp->obj.c_scl = dp->obj.sclust;
 80047a2:	68ab      	ldr	r3, [r5, #8]
 80047a4:	622b      	str	r3, [r5, #32]
				dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 80047a6:	692b      	ldr	r3, [r5, #16]
 80047a8:	79ea      	ldrb	r2, [r5, #7]
 80047aa:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80047ae:	4313      	orrs	r3, r2
 80047b0:	626b      	str	r3, [r5, #36]	@ 0x24
				dp->obj.c_ofs = dp->blk_ofs;
 80047b2:	6ceb      	ldr	r3, [r5, #76]	@ 0x4c
 80047b4:	62ab      	str	r3, [r5, #40]	@ 0x28
				init_alloc_info(fs, &dp->obj);	/* Open next directory */
 80047b6:	9b02      	ldr	r3, [sp, #8]
 80047b8:	4629      	mov	r1, r5
 80047ba:	6918      	ldr	r0, [r3, #16]
 80047bc:	f7ff ff22 	bl	8004604 <init_alloc_info.isra.0>
	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 80047c0:	682b      	ldr	r3, [r5, #0]
 80047c2:	2600      	movs	r6, #0
 80047c4:	f8d3 900c 	ldr.w	r9, [r3, #12]
 80047c8:	e76e      	b.n	80046a8 <follow_path+0x78>
	while (*str && *str != chr) str++;
 80047ca:	4290      	cmp	r0, r2
 80047cc:	f47f af61 	bne.w	8004692 <follow_path+0x62>
 80047d0:	e093      	b.n	80048fa <follow_path+0x2ca>
		di--;
 80047d2:	3e01      	subs	r6, #1
 80047d4:	e76f      	b.n	80046b6 <follow_path+0x86>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 80047d6:	f044 0403 	orr.w	r4, r4, #3
 80047da:	b2e4      	uxtb	r4, r4
 80047dc:	e789      	b.n	80046f2 <follow_path+0xc2>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 80047de:	454e      	cmp	r6, r9
 80047e0:	f000 808f 	beq.w	8004902 <follow_path+0x2d2>
			cf |= NS_LOSS | NS_LFN;
 80047e4:	f044 0403 	orr.w	r4, r4, #3
 80047e8:	b2e4      	uxtb	r4, r4
		dp->fn[i++] = (BYTE)wc;
 80047ea:	4633      	mov	r3, r6
 80047ec:	e796      	b.n	800471c <follow_path+0xec>
		if (i >= ni || si == di) {		/* End of field? */
 80047ee:	454e      	cmp	r6, r9
 80047f0:	d10f      	bne.n	8004812 <follow_path+0x1e2>
 80047f2:	e089      	b.n	8004908 <follow_path+0x2d8>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
 80047f4:	454e      	cmp	r6, r9
 80047f6:	d003      	beq.n	8004800 <follow_path+0x1d0>
 80047f8:	f044 0403 	orr.w	r4, r4, #3
 80047fc:	b2e4      	uxtb	r4, r4
			if (si > di) break;						/* No name extension? */
 80047fe:	d853      	bhi.n	80048a8 <follow_path+0x278>
			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
 8004800:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8004804:	fa5f fa8a 	uxtb.w	sl, sl
 8004808:	464e      	mov	r6, r9
 800480a:	f04f 080b 	mov.w	r8, #11
 800480e:	2708      	movs	r7, #8
			continue;
 8004810:	e7eb      	b.n	80047ea <follow_path+0x1ba>
		if (wc >= 0x80) {	/* Is this an extended character? */
 8004812:	287f      	cmp	r0, #127	@ 0x7f
 8004814:	d924      	bls.n	8004860 <follow_path+0x230>
			wc = ff_uni2oem(wc, CODEPAGE);			/* Unicode ==> ANSI/OEM code */
 8004816:	f240 3162 	movw	r1, #866	@ 0x362
 800481a:	9203      	str	r2, [sp, #12]
 800481c:	f000 fd34 	bl	8005288 <ff_uni2oem>
			cf |= NS_LFN;	/* LFN entry needs to be created */
 8004820:	f044 0502 	orr.w	r5, r4, #2
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 8004824:	f010 0f80 	tst.w	r0, #128	@ 0x80
 8004828:	9a03      	ldr	r2, [sp, #12]
			cf |= NS_LFN;	/* LFN entry needs to be created */
 800482a:	b2ed      	uxtb	r5, r5
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 800482c:	d004      	beq.n	8004838 <follow_path+0x208>
 800482e:	4b43      	ldr	r3, [pc, #268]	@ (800493c <follow_path+0x30c>)
 8004830:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8004834:	5c18      	ldrb	r0, [r3, r0]
		if (wc >= 0x100) {				/* Is this a DBC? */
 8004836:	e011      	b.n	800485c <follow_path+0x22c>
 8004838:	28ff      	cmp	r0, #255	@ 0xff
 800483a:	d90f      	bls.n	800485c <follow_path+0x22c>
			if (i >= ni - 1) {			/* Field overflow? */
 800483c:	f108 33ff 	add.w	r3, r8, #4294967295
 8004840:	429f      	cmp	r7, r3
 8004842:	d304      	bcc.n	800484e <follow_path+0x21e>
				cf |= NS_LOSS | NS_LFN;
 8004844:	f044 0403 	orr.w	r4, r4, #3
 8004848:	b2e4      	uxtb	r4, r4
				i = ni; continue;		/* Next field */
 800484a:	4647      	mov	r7, r8
 800484c:	e7cd      	b.n	80047ea <follow_path+0x1ba>
			dp->fn[i++] = (BYTE)(wc >> 8);	/* Put 1st byte */
 800484e:	eb0b 0307 	add.w	r3, fp, r7
 8004852:	0a01      	lsrs	r1, r0, #8
 8004854:	f883 1040 	strb.w	r1, [r3, #64]	@ 0x40
 8004858:	3701      	adds	r7, #1
 800485a:	e01e      	b.n	800489a <follow_path+0x26a>
			if (wc == 0 || strchr("+,;=[]", (int)wc)) {	/* Replace illegal characters for SFN */
 800485c:	b138      	cbz	r0, 800486e <follow_path+0x23e>
 800485e:	e000      	b.n	8004862 <follow_path+0x232>
 8004860:	4625      	mov	r5, r4
 8004862:	4b37      	ldr	r3, [pc, #220]	@ (8004940 <follow_path+0x310>)
	while (*str && *str != chr) str++;
 8004864:	f813 1b01 	ldrb.w	r1, [r3], #1
 8004868:	b131      	cbz	r1, 8004878 <follow_path+0x248>
 800486a:	4288      	cmp	r0, r1
 800486c:	d1fa      	bne.n	8004864 <follow_path+0x234>
				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800486e:	f045 0503 	orr.w	r5, r5, #3
 8004872:	b2ed      	uxtb	r5, r5
 8004874:	205f      	movs	r0, #95	@ 0x5f
 8004876:	e010      	b.n	800489a <follow_path+0x26a>
				if (IsUpper(wc)) {		/* ASCII upper case? */
 8004878:	f1a0 0341 	sub.w	r3, r0, #65	@ 0x41
 800487c:	b29b      	uxth	r3, r3
 800487e:	2b19      	cmp	r3, #25
 8004880:	d802      	bhi.n	8004888 <follow_path+0x258>
					b |= 2;
 8004882:	f04a 0a02 	orr.w	sl, sl, #2
				if (IsLower(wc)) {		/* ASCII lower case? */
 8004886:	e008      	b.n	800489a <follow_path+0x26a>
 8004888:	f1a0 0361 	sub.w	r3, r0, #97	@ 0x61
 800488c:	b29b      	uxth	r3, r3
 800488e:	2b19      	cmp	r3, #25
 8004890:	d803      	bhi.n	800489a <follow_path+0x26a>
					b |= 1; wc -= 0x20;
 8004892:	3820      	subs	r0, #32
 8004894:	f04a 0a01 	orr.w	sl, sl, #1
 8004898:	b280      	uxth	r0, r0
		dp->fn[i++] = (BYTE)wc;
 800489a:	eb0b 0307 	add.w	r3, fp, r7
 800489e:	462c      	mov	r4, r5
 80048a0:	f883 0040 	strb.w	r0, [r3, #64]	@ 0x40
 80048a4:	3701      	adds	r7, #1
 80048a6:	e7a0      	b.n	80047ea <follow_path+0x1ba>
 80048a8:	465d      	mov	r5, fp
 80048aa:	f8dd b004 	ldr.w	fp, [sp, #4]
 80048ae:	e74c      	b.n	800474a <follow_path+0x11a>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 80048b0:	f00a 0303 	and.w	r3, sl, #3
 80048b4:	2b03      	cmp	r3, #3
 80048b6:	f43f af5b 	beq.w	8004770 <follow_path+0x140>
	if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
 80048ba:	07a1      	lsls	r1, r4, #30
 80048bc:	f53f af5b 	bmi.w	8004776 <follow_path+0x146>
		if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
 80048c0:	f00a 0301 	and.w	r3, sl, #1
 80048c4:	ea44 1303 	orr.w	r3, r4, r3, lsl #4
 80048c8:	b2dc      	uxtb	r4, r3
		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
 80048ca:	f01a 0f04 	tst.w	sl, #4
 80048ce:	bf18      	it	ne
 80048d0:	f044 0408 	orrne.w	r4, r4, #8
 80048d4:	e74f      	b.n	8004776 <follow_path+0x146>
				if (res == FR_NO_FILE) {	/* Object is not found */
 80048d6:	2804      	cmp	r0, #4
 80048d8:	d12a      	bne.n	8004930 <follow_path+0x300>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 80048da:	f013 0f04 	tst.w	r3, #4
 80048de:	bf08      	it	eq
 80048e0:	2005      	moveq	r0, #5
 80048e2:	e025      	b.n	8004930 <follow_path+0x300>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 80048e4:	9b02      	ldr	r3, [sp, #8]
 80048e6:	f103 013c 	add.w	r1, r3, #60	@ 0x3c
 80048ea:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
 80048ec:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80048f0:	4419      	add	r1, r3
 80048f2:	f7ff fe95 	bl	8004620 <ld_clust.isra.0>
 80048f6:	60a8      	str	r0, [r5, #8]
 80048f8:	e762      	b.n	80047c0 <follow_path+0x190>
			res = create_name(dp, &path);	/* Get a segment name of the path */
 80048fa:	2006      	movs	r0, #6
 80048fc:	e018      	b.n	8004930 <follow_path+0x300>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 80048fe:	2005      	movs	r0, #5
	return res;
 8004900:	e016      	b.n	8004930 <follow_path+0x300>
		if (i >= ni || si == di) {		/* End of field? */
 8004902:	4547      	cmp	r7, r8
 8004904:	f4bf af16 	bcs.w	8004734 <follow_path+0x104>
			if (ni == 11) {				/* Name extension overflow? */
 8004908:	f1b8 0f0b 	cmp.w	r8, #11
 800490c:	f47f af78 	bne.w	8004800 <follow_path+0x1d0>
 8004910:	e713      	b.n	800473a <follow_path+0x10a>
	if (wc < ' ') {				/* Stopped at end of the path? */
 8004912:	465b      	mov	r3, fp
		while (IsSeparator(*p)) p++;	/* Skip duplicated separators if exist */
 8004914:	781c      	ldrb	r4, [r3, #0]
 8004916:	2c2f      	cmp	r4, #47	@ 0x2f
 8004918:	469b      	mov	fp, r3
 800491a:	f103 0301 	add.w	r3, r3, #1
 800491e:	d0f9      	beq.n	8004914 <follow_path+0x2e4>
 8004920:	2c5c      	cmp	r4, #92	@ 0x5c
 8004922:	d0f7      	beq.n	8004914 <follow_path+0x2e4>
		if (IsTerminator(*p)) cf = NS_LAST;	/* Ignore terminating separator */
 8004924:	2c1f      	cmp	r4, #31
 8004926:	bf8c      	ite	hi
 8004928:	2400      	movhi	r4, #0
 800492a:	2401      	movls	r4, #1
 800492c:	00a4      	lsls	r4, r4, #2
 800492e:	e6c0      	b.n	80046b2 <follow_path+0x82>
}
 8004930:	b005      	add	sp, #20
 8004932:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004936:	bf00      	nop
 8004938:	08014841 	.word	0x08014841
 800493c:	08014cac 	.word	0x08014cac
 8004940:	0801484a 	.word	0x0801484a

08004944 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the filesystem object to be registered (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mount option: 0=Do not mount (delayed mount), 1=Mount immediately */
)
{
 8004944:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8004946:	e9cd 1000 	strd	r1, r0, [sp]
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 800494a:	a803      	add	r0, sp, #12
{
 800494c:	4614      	mov	r4, r2
	const TCHAR *rp = path;
 800494e:	9103      	str	r1, [sp, #12]
	vol = get_ldnumber(&rp);
 8004950:	f7fe faea 	bl	8002f28 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8004954:	3001      	adds	r0, #1
 8004956:	d011      	beq.n	800497c <f_mount+0x38>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8004958:	4a0a      	ldr	r2, [pc, #40]	@ (8004984 <f_mount+0x40>)
 800495a:	6813      	ldr	r3, [r2, #0]

	if (cfs) {
 800495c:	b10b      	cbz	r3, 8004962 <f_mount+0x1e>
		clear_lock(cfs);
#endif
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 800495e:	2100      	movs	r1, #0
 8004960:	7019      	strb	r1, [r3, #0]
	}

	if (fs) {
 8004962:	9b01      	ldr	r3, [sp, #4]
 8004964:	b10b      	cbz	r3, 800496a <f_mount+0x26>
		fs->fs_type = 0;				/* Clear new fs object */
 8004966:	2100      	movs	r1, #0
 8004968:	7019      	strb	r1, [r3, #0]
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 800496a:	6013      	str	r3, [r2, #0]

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */
 800496c:	b13c      	cbz	r4, 800497e <f_mount+0x3a>

	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume */
 800496e:	2200      	movs	r2, #0
 8004970:	a901      	add	r1, sp, #4
 8004972:	4668      	mov	r0, sp
 8004974:	f7fe ff48 	bl	8003808 <mount_volume>
 8004978:	4604      	mov	r4, r0
	LEAVE_FF(fs, res);
 800497a:	e000      	b.n	800497e <f_mount+0x3a>
	if (vol < 0) return FR_INVALID_DRIVE;
 800497c:	240b      	movs	r4, #11
}
 800497e:	4620      	mov	r0, r4
 8004980:	b004      	add	sp, #16
 8004982:	bd10      	pop	{r4, pc}
 8004984:	20000788 	.word	0x20000788

08004988 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and open mode flags */
)
{
 8004988:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800498c:	b09b      	sub	sp, #108	@ 0x6c
 800498e:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 8004990:	2800      	cmp	r0, #0
 8004992:	f000 8123 	beq.w	8004bdc <f_open+0x254>

	/* Get logical drive number */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
 8004996:	f002 093f 	and.w	r9, r2, #63	@ 0x3f
 800499a:	4617      	mov	r7, r2
 800499c:	4604      	mov	r4, r0
	res = mount_volume(&path, &fs, mode);
 800499e:	464a      	mov	r2, r9
 80049a0:	a903      	add	r1, sp, #12
 80049a2:	a801      	add	r0, sp, #4
 80049a4:	f7fe ff30 	bl	8003808 <mount_volume>
	if (res == FR_OK) {
 80049a8:	4680      	mov	r8, r0
 80049aa:	2800      	cmp	r0, #0
 80049ac:	f040 8112 	bne.w	8004bd4 <f_open+0x24c>
		dj.obj.fs = fs;
 80049b0:	9d03      	ldr	r5, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 80049b2:	f88d 0016 	strb.w	r0, [sp, #22]
 80049b6:	2300      	movs	r3, #0
 80049b8:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 80049ba:	9504      	str	r5, [sp, #16]
		res = follow_path(&dj, path);	/* Follow the file path */
 80049bc:	a804      	add	r0, sp, #16
 80049be:	9313      	str	r3, [sp, #76]	@ 0x4c
 80049c0:	f7ff fe36 	bl	8004630 <follow_path>
 80049c4:	f89d b016 	ldrb.w	fp, [sp, #22]
 80049c8:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
#if !FF_FS_READONLY	/* Read/Write configuration */
		if (res == FR_OK) {
 80049ca:	b920      	cbnz	r0, 80049d6 <f_open+0x4e>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 80049cc:	f99d 305b 	ldrsb.w	r3, [sp, #91]	@ 0x5b
				res = FR_INVALID_NAME;
 80049d0:	2b00      	cmp	r3, #0
 80049d2:	bfb8      	it	lt
 80049d4:	2006      	movlt	r0, #6
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);		/* Check if the file can be used */
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80049d6:	f017 0f1c 	tst.w	r7, #28
 80049da:	d077      	beq.n	8004acc <f_open+0x144>
			if (res != FR_OK) {					/* No file, create new */
 80049dc:	b170      	cbz	r0, 80049fc <f_open+0x74>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 80049de:	2804      	cmp	r0, #4
 80049e0:	f040 80f8 	bne.w	8004bd4 <f_open+0x24c>
#if FF_FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
 80049e4:	a804      	add	r0, sp, #16
 80049e6:	f7ff fc6d 	bl	80042c4 <dir_register>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 80049ea:	2800      	cmp	r0, #0
 80049ec:	f040 80f2 	bne.w	8004bd4 <f_open+0x24c>
					res = dir_register(&dj);
 80049f0:	f89d b016 	ldrb.w	fp, [sp, #22]
 80049f4:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80049f6:	f049 0908 	orr.w	r9, r9, #8
 80049fa:	e008      	b.n	8004a0e <f_open+0x86>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80049fc:	f01b 0f11 	tst.w	fp, #17
 8004a00:	f040 80e5 	bne.w	8004bce <f_open+0x246>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8004a04:	0778      	lsls	r0, r7, #29
 8004a06:	f100 80de 	bmi.w	8004bc6 <f_open+0x23e>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
 8004a0a:	0739      	lsls	r1, r7, #28
 8004a0c:	d56c      	bpl.n	8004ae8 <f_open+0x160>
#if FF_FS_EXFAT
				if (fs->fs_type == FS_EXFAT) {
 8004a0e:	782b      	ldrb	r3, [r5, #0]
 8004a10:	2b04      	cmp	r3, #4
 8004a12:	d12c      	bne.n	8004a6e <f_open+0xe6>
					/* Get current allocation info */
					fp->obj.fs = fs;
 8004a14:	6928      	ldr	r0, [r5, #16]
 8004a16:	6025      	str	r5, [r4, #0]
					init_alloc_info(fs, &fp->obj);
 8004a18:	4621      	mov	r1, r4
 8004a1a:	f7ff fdf3 	bl	8004604 <init_alloc_info.isra.0>
					/* Set directory entry block initial state */
					memset(fs->dirbuf + 2, 0, 30);	/* Clear 85 entry except for NumSec */
 8004a1e:	2100      	movs	r1, #0
 8004a20:	221e      	movs	r2, #30
 8004a22:	3002      	adds	r0, #2
 8004a24:	f7fe f9d2 	bl	8002dcc <mem_set>
					memset(fs->dirbuf + 38, 0, 26);	/* Clear C0 entry except for NumName and NameHash */
 8004a28:	6928      	ldr	r0, [r5, #16]
 8004a2a:	221a      	movs	r2, #26
 8004a2c:	3026      	adds	r0, #38	@ 0x26
 8004a2e:	f7fe f9cd 	bl	8002dcc <mem_set>
					fs->dirbuf[XDIR_Attr] = AM_ARC;
 8004a32:	692b      	ldr	r3, [r5, #16]
 8004a34:	2220      	movs	r2, #32
 8004a36:	711a      	strb	r2, [r3, #4]
					st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
 8004a38:	692f      	ldr	r7, [r5, #16]
 8004a3a:	f00c fd01 	bl	8011440 <get_fattime>
					fs->dirbuf[XDIR_GenFlags] = 1;
 8004a3e:	692b      	ldr	r3, [r5, #16]
					st_dword(fs->dirbuf + XDIR_CrtTime, GET_FATTIME());
 8004a40:	60b8      	str	r0, [r7, #8]
					fs->dirbuf[XDIR_GenFlags] = 1;
 8004a42:	2201      	movs	r2, #1
 8004a44:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
					res = store_xdir(&dj);
 8004a48:	a804      	add	r0, sp, #16
 8004a4a:	f88d b016 	strb.w	fp, [sp, #22]
 8004a4e:	9613      	str	r6, [sp, #76]	@ 0x4c
 8004a50:	f7ff fa64 	bl	8003f1c <store_xdir>
					if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
 8004a54:	2800      	cmp	r0, #0
 8004a56:	f040 80bd 	bne.w	8004bd4 <f_open+0x24c>
 8004a5a:	68a1      	ldr	r1, [r4, #8]
					res = store_xdir(&dj);
 8004a5c:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
					if (res == FR_OK && fp->obj.sclust != 0) {	/* Remove the cluster chain if exist */
 8004a5e:	2900      	cmp	r1, #0
 8004a60:	d040      	beq.n	8004ae4 <f_open+0x15c>
						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
 8004a62:	4602      	mov	r2, r0
 8004a64:	4620      	mov	r0, r4
 8004a66:	f7fe fce5 	bl	8003434 <remove_chain>
						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
 8004a6a:	68a7      	ldr	r7, [r4, #8]
 8004a6c:	e028      	b.n	8004ac0 <f_open+0x138>
					}
				} else
#endif
				{
					/* Set directory entry initial state */
					tm = GET_FATTIME();					/* Set created time */
 8004a6e:	f00c fce7 	bl	8011440 <get_fattime>
					st_dword(dj.dir + DIR_CrtTime, tm);
 8004a72:	f8c6 000e 	str.w	r0, [r6, #14]
					st_dword(dj.dir + DIR_ModTime, tm);
 8004a76:	f8c6 0016 	str.w	r0, [r6, #22]
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 8004a7a:	7828      	ldrb	r0, [r5, #0]
 8004a7c:	4631      	mov	r1, r6
 8004a7e:	f7ff fdcf 	bl	8004620 <ld_clust.isra.0>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8004a82:	2320      	movs	r3, #32
 8004a84:	72f3      	strb	r3, [r6, #11]
 8004a86:	782a      	ldrb	r2, [r5, #0]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 8004a88:	2300      	movs	r3, #0
	if (fs->fs_type == FS_FAT32) {
 8004a8a:	2a03      	cmp	r2, #3
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 8004a8c:	8373      	strh	r3, [r6, #26]
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 8004a8e:	bf08      	it	eq
 8004a90:	82b3      	strheq	r3, [r6, #20]
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
					st_dword(dj.dir + DIR_FileSize, 0);
 8004a92:	61f3      	str	r3, [r6, #28]
					fs->wflag = 1;
 8004a94:	2301      	movs	r3, #1
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
 8004a96:	4607      	mov	r7, r0
					fs->wflag = 1;
 8004a98:	70eb      	strb	r3, [r5, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
 8004a9a:	b318      	cbz	r0, 8004ae4 <f_open+0x15c>
						sc = fs->winsect;
						res = remove_chain(&dj.obj, cl, 0);
 8004a9c:	4601      	mov	r1, r0
 8004a9e:	2200      	movs	r2, #0
 8004aa0:	a804      	add	r0, sp, #16
						sc = fs->winsect;
 8004aa2:	f8d5 a038 	ldr.w	sl, [r5, #56]	@ 0x38
						res = remove_chain(&dj.obj, cl, 0);
 8004aa6:	f88d b016 	strb.w	fp, [sp, #22]
 8004aaa:	9613      	str	r6, [sp, #76]	@ 0x4c
 8004aac:	f7fe fcc2 	bl	8003434 <remove_chain>
						if (res == FR_OK) {
 8004ab0:	2800      	cmp	r0, #0
 8004ab2:	f040 808f 	bne.w	8004bd4 <f_open+0x24c>
							res = move_window(fs, sc);
 8004ab6:	4651      	mov	r1, sl
 8004ab8:	4628      	mov	r0, r5
						res = remove_chain(&dj.obj, cl, 0);
 8004aba:	9e13      	ldr	r6, [sp, #76]	@ 0x4c
							res = move_window(fs, sc);
 8004abc:	f7fe fa86 	bl	8002fcc <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8004ac0:	3f01      	subs	r7, #1
 8004ac2:	616f      	str	r7, [r5, #20]
						res = FR_DENIED;
					}
				}
			}
		}
		if (res == FR_OK) {
 8004ac4:	2800      	cmp	r0, #0
 8004ac6:	f040 8085 	bne.w	8004bd4 <f_open+0x24c>
 8004aca:	e00b      	b.n	8004ae4 <f_open+0x15c>
			if (res == FR_OK) {					/* Is the object exsiting? */
 8004acc:	2800      	cmp	r0, #0
 8004ace:	f040 8081 	bne.w	8004bd4 <f_open+0x24c>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 8004ad2:	f01b 0f10 	tst.w	fp, #16
 8004ad6:	d178      	bne.n	8004bca <f_open+0x242>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
 8004ad8:	07ba      	lsls	r2, r7, #30
 8004ada:	d505      	bpl.n	8004ae8 <f_open+0x160>
 8004adc:	f01b 0f01 	tst.w	fp, #1
 8004ae0:	d175      	bne.n	8004bce <f_open+0x246>
 8004ae2:	e001      	b.n	8004ae8 <f_open+0x160>
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
 8004ae4:	f049 0940 	orr.w	r9, r9, #64	@ 0x40
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8004ae8:	6bab      	ldr	r3, [r5, #56]	@ 0x38
			fp->dir_ptr = dj.dir;
 8004aea:	e9c4 3612 	strd	r3, r6, [r4, #72]	@ 0x48
		}
#endif

		if (res == FR_OK) {
#if FF_FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 8004aee:	7828      	ldrb	r0, [r5, #0]
 8004af0:	2804      	cmp	r0, #4
 8004af2:	d10f      	bne.n	8004b14 <f_open+0x18c>
				fp->obj.c_scl = dj.obj.sclust;							/* Get containing directory info */
 8004af4:	9b06      	ldr	r3, [sp, #24]
 8004af6:	6223      	str	r3, [r4, #32]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 8004af8:	9b08      	ldr	r3, [sp, #32]
 8004afa:	f89d 2017 	ldrb.w	r2, [sp, #23]
				fp->obj.c_ofs = dj.blk_ofs;
				init_alloc_info(fs, &fp->obj);
 8004afe:	6928      	ldr	r0, [r5, #16]
				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
 8004b00:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8004b04:	4313      	orrs	r3, r2
 8004b06:	6263      	str	r3, [r4, #36]	@ 0x24
				fp->obj.c_ofs = dj.blk_ofs;
 8004b08:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8004b0a:	62a3      	str	r3, [r4, #40]	@ 0x28
				init_alloc_info(fs, &fp->obj);
 8004b0c:	4621      	mov	r1, r4
 8004b0e:	f7ff fd79 	bl	8004604 <init_alloc_info.isra.0>
 8004b12:	e007      	b.n	8004b24 <f_open+0x19c>
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8004b14:	4631      	mov	r1, r6
 8004b16:	f7ff fd83 	bl	8004620 <ld_clust.isra.0>
 8004b1a:	60a0      	str	r0, [r4, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8004b1c:	69f3      	ldr	r3, [r6, #28]
 8004b1e:	6123      	str	r3, [r4, #16]
 8004b20:	2300      	movs	r3, #0
 8004b22:	6163      	str	r3, [r4, #20]
			}
#if FF_USE_FASTSEEK
			fp->cltbl = 0;		/* Disable fast seek mode */
#endif
			fp->obj.fs = fs;	/* Validate the file object */
			fp->obj.id = fs->id;
 8004b24:	88eb      	ldrh	r3, [r5, #6]
 8004b26:	80a3      	strh	r3, [r4, #4]
			fp->flag = mode;	/* Set file access mode */
			fp->err = 0;		/* Clear error flag */
 8004b28:	f04f 0a00 	mov.w	sl, #0
			fp->sect = 0;		/* Invalidate current data sector */
			fp->fptr = 0;		/* Set file pointer top of the file */
 8004b2c:	2200      	movs	r2, #0
 8004b2e:	2300      	movs	r3, #0
#if !FF_FS_READONLY
#if !FF_FS_TINY
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 8004b30:	f104 0750 	add.w	r7, r4, #80	@ 0x50
			fp->fptr = 0;		/* Set file pointer top of the file */
 8004b34:	e9c4 230e 	strd	r2, r3, [r4, #56]	@ 0x38
			fp->obj.fs = fs;	/* Validate the file object */
 8004b38:	6025      	str	r5, [r4, #0]
			fp->flag = mode;	/* Set file access mode */
 8004b3a:	f884 9030 	strb.w	r9, [r4, #48]	@ 0x30
			fp->err = 0;		/* Clear error flag */
 8004b3e:	f884 a031 	strb.w	sl, [r4, #49]	@ 0x31
			fp->sect = 0;		/* Invalidate current data sector */
 8004b42:	f8c4 a044 	str.w	sl, [r4, #68]	@ 0x44
			memset(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 8004b46:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004b4a:	4651      	mov	r1, sl
 8004b4c:	4638      	mov	r0, r7
 8004b4e:	f7fe f93d 	bl	8002dcc <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 8004b52:	f019 0f20 	tst.w	r9, #32
 8004b56:	d043      	beq.n	8004be0 <f_open+0x258>
 8004b58:	e9d4 6904 	ldrd	r6, r9, [r4, #16]
 8004b5c:	ea56 0309 	orrs.w	r3, r6, r9
 8004b60:	d03e      	beq.n	8004be0 <f_open+0x258>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8004b62:	f8b5 b00a 	ldrh.w	fp, [r5, #10]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8004b66:	68a1      	ldr	r1, [r4, #8]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8004b68:	e9c4 690e 	strd	r6, r9, [r4, #56]	@ 0x38
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8004b6c:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8004b70:	45b3      	cmp	fp, r6
 8004b72:	eb7a 0309 	sbcs.w	r3, sl, r9
 8004b76:	d20d      	bcs.n	8004b94 <f_open+0x20c>
					clst = get_fat(&fp->obj, clst);
 8004b78:	4620      	mov	r0, r4
 8004b7a:	f7fe fb81 	bl	8003280 <get_fat>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8004b7e:	ebb6 060b 	subs.w	r6, r6, fp
 8004b82:	f169 0900 	sbc.w	r9, r9, #0
					if (clst <= 1) res = FR_INT_ERR;
 8004b86:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 8004b88:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
 8004b8a:	d905      	bls.n	8004b98 <f_open+0x210>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8004b8c:	1c43      	adds	r3, r0, #1
 8004b8e:	d1ef      	bne.n	8004b70 <f_open+0x1e8>
 8004b90:	2001      	movs	r0, #1
 8004b92:	e002      	b.n	8004b9a <f_open+0x212>
 8004b94:	2000      	movs	r0, #0
 8004b96:	e000      	b.n	8004b9a <f_open+0x212>
					if (clst <= 1) res = FR_INT_ERR;
 8004b98:	2002      	movs	r0, #2
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
				}
				fp->clust = clst;
 8004b9a:	6421      	str	r1, [r4, #64]	@ 0x40
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8004b9c:	b9d0      	cbnz	r0, 8004bd4 <f_open+0x24c>
 8004b9e:	f3c6 0308 	ubfx	r3, r6, #0, #9
 8004ba2:	b1eb      	cbz	r3, 8004be0 <f_open+0x258>
					sc = clst2sect(fs, clst);
 8004ba4:	4628      	mov	r0, r5
 8004ba6:	f7fe f925 	bl	8002df4 <clst2sect>
					if (sc == 0) {
 8004baa:	b190      	cbz	r0, 8004bd2 <f_open+0x24a>
						res = FR_INT_ERR;
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 8004bac:	0a76      	lsrs	r6, r6, #9
 8004bae:	ea46 56c9 	orr.w	r6, r6, r9, lsl #23
 8004bb2:	1982      	adds	r2, r0, r6
 8004bb4:	6462      	str	r2, [r4, #68]	@ 0x44
#if !FF_FS_TINY
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8004bb6:	7868      	ldrb	r0, [r5, #1]
 8004bb8:	2301      	movs	r3, #1
 8004bba:	4639      	mov	r1, r7
 8004bbc:	f00c fcd2 	bl	8011564 <disk_read>
 8004bc0:	b170      	cbz	r0, 8004be0 <f_open+0x258>
 8004bc2:	2001      	movs	r0, #1
 8004bc4:	e006      	b.n	8004bd4 <f_open+0x24c>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8004bc6:	2008      	movs	r0, #8
 8004bc8:	e004      	b.n	8004bd4 <f_open+0x24c>
					res = FR_NO_FILE;
 8004bca:	2004      	movs	r0, #4
 8004bcc:	e002      	b.n	8004bd4 <f_open+0x24c>
					res = FR_DENIED;
 8004bce:	2007      	movs	r0, #7
 8004bd0:	e000      	b.n	8004bd4 <f_open+0x24c>
						res = FR_INT_ERR;
 8004bd2:	2002      	movs	r0, #2
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8004bd4:	2300      	movs	r3, #0
 8004bd6:	6023      	str	r3, [r4, #0]
 8004bd8:	4680      	mov	r8, r0
 8004bda:	e001      	b.n	8004be0 <f_open+0x258>
	if (!fp) return FR_INVALID_OBJECT;
 8004bdc:	f04f 0809 	mov.w	r8, #9

	LEAVE_FF(fs, res);
}
 8004be0:	4640      	mov	r0, r8
 8004be2:	b01b      	add	sp, #108	@ 0x6c
 8004be4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004be8 <f_read>:
	FIL* fp, 	/* Open file to be read */
	void* buff,	/* Data buffer to store the read data */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Number of bytes read */
)
{
 8004be8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004bec:	469a      	mov	sl, r3
 8004bee:	b087      	sub	sp, #28
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 8004bf0:	2300      	movs	r3, #0
{
 8004bf2:	4688      	mov	r8, r1
	*br = 0;	/* Clear read byte counter */
 8004bf4:	f8ca 3000 	str.w	r3, [sl]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004bf8:	a905      	add	r1, sp, #20
{
 8004bfa:	4604      	mov	r4, r0
 8004bfc:	4616      	mov	r6, r2
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004bfe:	f7fe f9a9 	bl	8002f54 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8004c02:	2800      	cmp	r0, #0
 8004c04:	f040 80bb 	bne.w	8004d7e <f_read+0x196>
 8004c08:	f894 9031 	ldrb.w	r9, [r4, #49]	@ 0x31
 8004c0c:	f1b9 0f00 	cmp.w	r9, #0
 8004c10:	f040 80ba 	bne.w	8004d88 <f_read+0x1a0>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8004c14:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004c18:	f013 0501 	ands.w	r5, r3, #1
 8004c1c:	f000 80b2 	beq.w	8004d84 <f_read+0x19c>
	remain = fp->obj.objsize - fp->fptr;
 8004c20:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8004c24:	e9d4 100e 	ldrd	r1, r0, [r4, #56]	@ 0x38
 8004c28:	1a5b      	subs	r3, r3, r1
 8004c2a:	eb62 0200 	sbc.w	r2, r2, r0
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8004c2e:	42b3      	cmp	r3, r6
 8004c30:	f172 0200 	sbcs.w	r2, r2, #0
 8004c34:	bf38      	it	cc
 8004c36:	461e      	movcc	r6, r3
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		memcpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8004c38:	f104 0350 	add.w	r3, r4, #80	@ 0x50
 8004c3c:	e9cd 3500 	strd	r3, r5, [sp]
 8004c40:	f8cd 9008 	str.w	r9, [sp, #8]
	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
 8004c44:	2e00      	cmp	r6, #0
 8004c46:	f000 8097 	beq.w	8004d78 <f_read+0x190>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8004c4a:	e9d4 300e 	ldrd	r3, r0, [r4, #56]	@ 0x38
 8004c4e:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004c52:	2a00      	cmp	r2, #0
 8004c54:	d173      	bne.n	8004d3e <f_read+0x156>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8004c56:	f8dd b014 	ldr.w	fp, [sp, #20]
 8004c5a:	f8bb 200a 	ldrh.w	r2, [fp, #10]
 8004c5e:	0a59      	lsrs	r1, r3, #9
 8004c60:	3a01      	subs	r2, #1
 8004c62:	ea41 51c0 	orr.w	r1, r1, r0, lsl #23
			if (csect == 0) {					/* On the cluster boundary? */
 8004c66:	ea12 0901 	ands.w	r9, r2, r1
 8004c6a:	d117      	bne.n	8004c9c <f_read+0xb4>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8004c6c:	4303      	orrs	r3, r0
 8004c6e:	d101      	bne.n	8004c74 <f_read+0x8c>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8004c70:	68a0      	ldr	r0, [r4, #8]
 8004c72:	e003      	b.n	8004c7c <f_read+0x94>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8004c74:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004c76:	4620      	mov	r0, r4
 8004c78:	f7fe fb02 	bl	8003280 <get_fat>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8004c7c:	2801      	cmp	r0, #1
 8004c7e:	d804      	bhi.n	8004c8a <f_read+0xa2>
 8004c80:	f04f 0902 	mov.w	r9, #2
 8004c84:	f884 9031 	strb.w	r9, [r4, #49]	@ 0x31
 8004c88:	e07e      	b.n	8004d88 <f_read+0x1a0>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004c8a:	1c43      	adds	r3, r0, #1
 8004c8c:	d105      	bne.n	8004c9a <f_read+0xb2>
 8004c8e:	9d01      	ldr	r5, [sp, #4]
 8004c90:	2301      	movs	r3, #1
 8004c92:	f884 3031 	strb.w	r3, [r4, #49]	@ 0x31
 8004c96:	46a9      	mov	r9, r5
 8004c98:	e076      	b.n	8004d88 <f_read+0x1a0>
				fp->clust = clst;				/* Update current cluster */
 8004c9a:	6420      	str	r0, [r4, #64]	@ 0x40
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 8004c9c:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004c9e:	4658      	mov	r0, fp
 8004ca0:	f7fe f8a8 	bl	8002df4 <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 8004ca4:	2800      	cmp	r0, #0
 8004ca6:	d0eb      	beq.n	8004c80 <f_read+0x98>
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8004ca8:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
			sect += csect;
 8004cac:	eb09 0700 	add.w	r7, r9, r0
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 8004cb0:	d324      	bcc.n	8004cfc <f_read+0x114>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004cb2:	f8bb 100a 	ldrh.w	r1, [fp, #10]
 8004cb6:	eb09 2056 	add.w	r0, r9, r6, lsr #9
 8004cba:	4288      	cmp	r0, r1
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8004cbc:	ea4f 2556 	mov.w	r5, r6, lsr #9
					cc = fs->csize - csect;
 8004cc0:	bf88      	it	hi
 8004cc2:	eba1 0509 	subhi.w	r5, r1, r9
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004cc6:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004cca:	462b      	mov	r3, r5
 8004ccc:	463a      	mov	r2, r7
 8004cce:	4641      	mov	r1, r8
 8004cd0:	f00c fc48 	bl	8011564 <disk_read>
 8004cd4:	2800      	cmp	r0, #0
 8004cd6:	d1da      	bne.n	8004c8e <f_read+0xa6>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8004cd8:	f994 2030 	ldrsb.w	r2, [r4, #48]	@ 0x30
 8004cdc:	2a00      	cmp	r2, #0
 8004cde:	da0b      	bge.n	8004cf8 <f_read+0x110>
 8004ce0:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8004ce2:	1bc0      	subs	r0, r0, r7
 8004ce4:	42a8      	cmp	r0, r5
 8004ce6:	d207      	bcs.n	8004cf8 <f_read+0x110>
					memcpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8004ce8:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004cec:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004cf0:	eb08 2040 	add.w	r0, r8, r0, lsl #9
 8004cf4:	f7fe f860 	bl	8002db8 <mem_cpy>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8004cf8:	026f      	lsls	r7, r5, #9
				continue;
 8004cfa:	e02e      	b.n	8004d5a <f_read+0x172>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8004cfc:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8004cfe:	42ba      	cmp	r2, r7
 8004d00:	d01c      	beq.n	8004d3c <f_read+0x154>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8004d02:	f994 3030 	ldrsb.w	r3, [r4, #48]	@ 0x30
 8004d06:	2b00      	cmp	r3, #0
 8004d08:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004d0c:	da0e      	bge.n	8004d2c <f_read+0x144>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004d0e:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004d12:	9103      	str	r1, [sp, #12]
 8004d14:	2301      	movs	r3, #1
 8004d16:	f00c fc67 	bl	80115e8 <disk_write>
 8004d1a:	2800      	cmp	r0, #0
 8004d1c:	d1b7      	bne.n	8004c8e <f_read+0xa6>
					fp->flag &= (BYTE)~FA_DIRTY;
 8004d1e:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004d22:	9903      	ldr	r1, [sp, #12]
 8004d24:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004d28:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8004d2c:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004d30:	2301      	movs	r3, #1
 8004d32:	463a      	mov	r2, r7
 8004d34:	f00c fc16 	bl	8011564 <disk_read>
 8004d38:	2800      	cmp	r0, #0
 8004d3a:	d1a8      	bne.n	8004c8e <f_read+0xa6>
			fp->sect = sect;
 8004d3c:	6467      	str	r7, [r4, #68]	@ 0x44
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004d3e:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8004d40:	9b00      	ldr	r3, [sp, #0]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004d42:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8004d46:	f5c1 7700 	rsb	r7, r1, #512	@ 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 8004d4a:	42b7      	cmp	r7, r6
 8004d4c:	bf28      	it	cs
 8004d4e:	4637      	movcs	r7, r6
		memcpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8004d50:	463a      	mov	r2, r7
 8004d52:	4419      	add	r1, r3
 8004d54:	4640      	mov	r0, r8
 8004d56:	f7fe f82f 	bl	8002db8 <mem_cpy>
	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {	/* Repeat until btr bytes read */
 8004d5a:	f8da 3000 	ldr.w	r3, [sl]
 8004d5e:	443b      	add	r3, r7
 8004d60:	f8ca 3000 	str.w	r3, [sl]
 8004d64:	e9d4 320e 	ldrd	r3, r2, [r4, #56]	@ 0x38
 8004d68:	19db      	adds	r3, r3, r7
 8004d6a:	f142 0200 	adc.w	r2, r2, #0
 8004d6e:	e9c4 320e 	strd	r3, r2, [r4, #56]	@ 0x38
 8004d72:	1bf6      	subs	r6, r6, r7
 8004d74:	44b8      	add	r8, r7
 8004d76:	e765      	b.n	8004c44 <f_read+0x5c>
 8004d78:	f8dd 9008 	ldr.w	r9, [sp, #8]
 8004d7c:	e004      	b.n	8004d88 <f_read+0x1a0>
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8004d7e:	f04f 0909 	mov.w	r9, #9
 8004d82:	e001      	b.n	8004d88 <f_read+0x1a0>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8004d84:	f04f 0907 	mov.w	r9, #7
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 8004d88:	4648      	mov	r0, r9
 8004d8a:	b007      	add	sp, #28
 8004d8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004d90 <f_write>:
	FIL* fp,			/* Open file to be written */
	const void* buff,	/* Data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Number of bytes written */
)
{
 8004d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004d94:	461f      	mov	r7, r3
 8004d96:	b085      	sub	sp, #20
	LBA_t sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 8004d98:	2300      	movs	r3, #0
{
 8004d9a:	460e      	mov	r6, r1
	*bw = 0;	/* Clear write byte counter */
 8004d9c:	603b      	str	r3, [r7, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8004d9e:	a903      	add	r1, sp, #12
{
 8004da0:	4604      	mov	r4, r0
 8004da2:	4615      	mov	r5, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8004da4:	f7fe f8d6 	bl	8002f54 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8004da8:	2800      	cmp	r0, #0
 8004daa:	f040 80db 	bne.w	8004f64 <f_write+0x1d4>
 8004dae:	f894 b031 	ldrb.w	fp, [r4, #49]	@ 0x31
 8004db2:	f1bb 0f00 	cmp.w	fp, #0
 8004db6:	f040 80da 	bne.w	8004f6e <f_write+0x1de>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8004dba:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004dbe:	079a      	lsls	r2, r3, #30
 8004dc0:	f140 80d3 	bpl.w	8004f6a <f_write+0x1da>

	/* Check fptr wrap-around (file size cannot reach 4 GiB at FAT volume) */
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8004dc4:	f8dd a00c 	ldr.w	sl, [sp, #12]
 8004dc8:	f89a 3000 	ldrb.w	r3, [sl]
 8004dcc:	2b04      	cmp	r3, #4
 8004dce:	d003      	beq.n	8004dd8 <f_write+0x48>
 8004dd0:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8004dd2:	42eb      	cmn	r3, r5
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8004dd4:	bf28      	it	cs
 8004dd6:	43dd      	mvncs	r5, r3
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		memcpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8004dd8:	f104 0350 	add.w	r3, r4, #80	@ 0x50
 8004ddc:	e9cd b300 	strd	fp, r3, [sp]
	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
 8004de0:	b1dd      	cbz	r5, 8004e1a <f_write+0x8a>
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8004de2:	e9d4 310e 	ldrd	r3, r1, [r4, #56]	@ 0x38
 8004de6:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8004dea:	2a00      	cmp	r2, #0
 8004dec:	f040 808d 	bne.w	8004f0a <f_write+0x17a>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8004df0:	f8ba 900a 	ldrh.w	r9, [sl, #10]
 8004df4:	0a5a      	lsrs	r2, r3, #9
 8004df6:	f109 39ff 	add.w	r9, r9, #4294967295
 8004dfa:	ea42 52c1 	orr.w	r2, r2, r1, lsl #23
			if (csect == 0) {				/* On the cluster boundary? */
 8004dfe:	ea19 0902 	ands.w	r9, r9, r2
 8004e02:	d123      	bne.n	8004e4c <f_write+0xbc>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8004e04:	430b      	orrs	r3, r1
 8004e06:	d102      	bne.n	8004e0e <f_write+0x7e>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8004e08:	68a1      	ldr	r1, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 8004e0a:	b979      	cbnz	r1, 8004e2c <f_write+0x9c>
 8004e0c:	e000      	b.n	8004e10 <f_write+0x80>
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8004e0e:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004e10:	4620      	mov	r0, r4
 8004e12:	f7fe fea1 	bl	8003b58 <create_chain>
 8004e16:	4601      	mov	r1, r0
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8004e18:	b940      	cbnz	r0, 8004e2c <f_write+0x9c>
		fp->flag |= FA_DIRTY;
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 8004e1a:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004e1e:	f8dd b000 	ldr.w	fp, [sp]
 8004e22:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8004e26:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30

	LEAVE_FF(fs, FR_OK);
 8004e2a:	e0a0      	b.n	8004f6e <f_write+0x1de>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8004e2c:	2901      	cmp	r1, #1
 8004e2e:	d102      	bne.n	8004e36 <f_write+0xa6>
 8004e30:	f04f 0b02 	mov.w	fp, #2
 8004e34:	e003      	b.n	8004e3e <f_write+0xae>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8004e36:	1c4b      	adds	r3, r1, #1
 8004e38:	d104      	bne.n	8004e44 <f_write+0xb4>
 8004e3a:	f04f 0b01 	mov.w	fp, #1
 8004e3e:	f884 b031 	strb.w	fp, [r4, #49]	@ 0x31
 8004e42:	e094      	b.n	8004f6e <f_write+0x1de>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8004e44:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 8004e46:	6421      	str	r1, [r4, #64]	@ 0x40
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8004e48:	b903      	cbnz	r3, 8004e4c <f_write+0xbc>
 8004e4a:	60a1      	str	r1, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8004e4c:	f994 3030 	ldrsb.w	r3, [r4, #48]	@ 0x30
 8004e50:	2b00      	cmp	r3, #0
 8004e52:	da0f      	bge.n	8004e74 <f_write+0xe4>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004e54:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8004e56:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8004e5a:	2301      	movs	r3, #1
 8004e5c:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004e60:	f00c fbc2 	bl	80115e8 <disk_write>
 8004e64:	2800      	cmp	r0, #0
 8004e66:	d1e8      	bne.n	8004e3a <f_write+0xaa>
				fp->flag &= (BYTE)~FA_DIRTY;
 8004e68:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004e6c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004e70:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
 8004e74:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004e76:	4650      	mov	r0, sl
 8004e78:	f7fd ffbc 	bl	8002df4 <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 8004e7c:	2800      	cmp	r0, #0
 8004e7e:	d0d7      	beq.n	8004e30 <f_write+0xa0>
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 8004e80:	f5b5 7f00 	cmp.w	r5, #512	@ 0x200
			sect += csect;
 8004e84:	eb09 0800 	add.w	r8, r9, r0
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
 8004e88:	d328      	bcc.n	8004edc <f_write+0x14c>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004e8a:	f8ba 200a 	ldrh.w	r2, [sl, #10]
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004e8e:	f89a 0001 	ldrb.w	r0, [sl, #1]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8004e92:	eb09 2155 	add.w	r1, r9, r5, lsr #9
 8004e96:	4291      	cmp	r1, r2
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 8004e98:	ea4f 2b55 	mov.w	fp, r5, lsr #9
					cc = fs->csize - csect;
 8004e9c:	bf88      	it	hi
 8004e9e:	eba2 0b09 	subhi.w	fp, r2, r9
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8004ea2:	465b      	mov	r3, fp
 8004ea4:	4642      	mov	r2, r8
 8004ea6:	4631      	mov	r1, r6
 8004ea8:	f00c fb9e 	bl	80115e8 <disk_write>
 8004eac:	2800      	cmp	r0, #0
 8004eae:	d1c4      	bne.n	8004e3a <f_write+0xaa>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8004eb0:	6c61      	ldr	r1, [r4, #68]	@ 0x44
 8004eb2:	eba1 0108 	sub.w	r1, r1, r8
 8004eb6:	4559      	cmp	r1, fp
 8004eb8:	d20d      	bcs.n	8004ed6 <f_write+0x146>
					memcpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 8004eba:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8004ebe:	eb06 2141 	add.w	r1, r6, r1, lsl #9
 8004ec2:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 8004ec6:	f7fd ff77 	bl	8002db8 <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 8004eca:	f894 2030 	ldrb.w	r2, [r4, #48]	@ 0x30
 8004ece:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 8004ed2:	f884 2030 	strb.w	r2, [r4, #48]	@ 0x30
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 8004ed6:	ea4f 284b 	mov.w	r8, fp, lsl #9
				continue;
 8004eda:	e02a      	b.n	8004f32 <f_write+0x1a2>
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8004edc:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8004ede:	4543      	cmp	r3, r8
 8004ee0:	d011      	beq.n	8004f06 <f_write+0x176>
 8004ee2:	e9d4 1304 	ldrd	r1, r3, [r4, #16]
 8004ee6:	e9d4 020e 	ldrd	r0, r2, [r4, #56]	@ 0x38
 8004eea:	4288      	cmp	r0, r1
 8004eec:	eb72 0303 	sbcs.w	r3, r2, r3
 8004ef0:	d209      	bcs.n	8004f06 <f_write+0x176>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
 8004ef2:	f89a 0001 	ldrb.w	r0, [sl, #1]
 8004ef6:	2301      	movs	r3, #1
 8004ef8:	4642      	mov	r2, r8
 8004efa:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004efe:	f00c fb31 	bl	8011564 <disk_read>
				fp->fptr < fp->obj.objsize &&
 8004f02:	2800      	cmp	r0, #0
 8004f04:	d199      	bne.n	8004e3a <f_write+0xaa>
			fp->sect = sect;
 8004f06:	f8c4 8044 	str.w	r8, [r4, #68]	@ 0x44
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004f0a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8004f0c:	9b01      	ldr	r3, [sp, #4]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
 8004f0e:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8004f12:	f5c0 7800 	rsb	r8, r0, #512	@ 0x200
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 8004f16:	45a8      	cmp	r8, r5
 8004f18:	bf28      	it	cs
 8004f1a:	46a8      	movcs	r8, r5
		memcpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8004f1c:	4418      	add	r0, r3
 8004f1e:	4642      	mov	r2, r8
 8004f20:	4631      	mov	r1, r6
 8004f22:	f7fd ff49 	bl	8002db8 <mem_cpy>
		fp->flag |= FA_DIRTY;
 8004f26:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004f2a:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8004f2e:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {	/* Repeat until all data written */
 8004f32:	683b      	ldr	r3, [r7, #0]
 8004f34:	4443      	add	r3, r8
 8004f36:	603b      	str	r3, [r7, #0]
 8004f38:	e9d4 320e 	ldrd	r3, r2, [r4, #56]	@ 0x38
 8004f3c:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 8004f40:	eb18 0303 	adds.w	r3, r8, r3
 8004f44:	f142 0200 	adc.w	r2, r2, #0
 8004f48:	4298      	cmp	r0, r3
 8004f4a:	eb71 0c02 	sbcs.w	ip, r1, r2
 8004f4e:	bf3c      	itt	cc
 8004f50:	4618      	movcc	r0, r3
 8004f52:	4611      	movcc	r1, r2
 8004f54:	e9c4 320e 	strd	r3, r2, [r4, #56]	@ 0x38
 8004f58:	e9c4 0104 	strd	r0, r1, [r4, #16]
 8004f5c:	eba5 0508 	sub.w	r5, r5, r8
 8004f60:	4446      	add	r6, r8
 8004f62:	e73d      	b.n	8004de0 <f_write+0x50>
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8004f64:	f04f 0b09 	mov.w	fp, #9
 8004f68:	e001      	b.n	8004f6e <f_write+0x1de>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8004f6a:	f04f 0b07 	mov.w	fp, #7
}
 8004f6e:	4658      	mov	r0, fp
 8004f70:	b005      	add	sp, #20
 8004f72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08004f78 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Open file to be synced */
)
{
 8004f78:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 8004f7c:	b098      	sub	sp, #96	@ 0x60
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8004f7e:	a901      	add	r1, sp, #4
{
 8004f80:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8004f82:	f7fd ffe7 	bl	8002f54 <validate>
	if (res == FR_OK) {
 8004f86:	2800      	cmp	r0, #0
 8004f88:	f040 8086 	bne.w	8005098 <f_sync+0x120>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8004f8c:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004f90:	f013 0040 	ands.w	r0, r3, #64	@ 0x40
 8004f94:	f000 8081 	beq.w	800509a <f_sync+0x122>
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8004f98:	061b      	lsls	r3, r3, #24
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8004f9a:	9d01      	ldr	r5, [sp, #4]
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8004f9c:	d50f      	bpl.n	8004fbe <f_sync+0x46>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8004f9e:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8004fa0:	7868      	ldrb	r0, [r5, #1]
 8004fa2:	2301      	movs	r3, #1
 8004fa4:	f104 0150 	add.w	r1, r4, #80	@ 0x50
 8004fa8:	f00c fb1e 	bl	80115e8 <disk_write>
 8004fac:	b108      	cbz	r0, 8004fb2 <f_sync+0x3a>
 8004fae:	2001      	movs	r0, #1
 8004fb0:	e073      	b.n	800509a <f_sync+0x122>
				fp->flag &= (BYTE)~FA_DIRTY;
 8004fb2:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 8004fb6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8004fba:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 8004fbe:	f00c fa3f 	bl	8011440 <get_fattime>
#if FF_FS_EXFAT
			if (fs->fs_type == FS_EXFAT) {
 8004fc2:	782b      	ldrb	r3, [r5, #0]
 8004fc4:	2b04      	cmp	r3, #4
			tm = GET_FATTIME();				/* Modified time */
 8004fc6:	4606      	mov	r6, r0
			if (fs->fs_type == FS_EXFAT) {
 8004fc8:	d141      	bne.n	800504e <f_sync+0xd6>
				res = fill_first_frag(&fp->obj);	/* Fill first fragment on the FAT if needed */
 8004fca:	4620      	mov	r0, r4
 8004fcc:	f7fe f940 	bl	8003250 <fill_first_frag>
				if (res == FR_OK) {
 8004fd0:	2800      	cmp	r0, #0
 8004fd2:	d162      	bne.n	800509a <f_sync+0x122>
					res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
 8004fd4:	6c21      	ldr	r1, [r4, #64]	@ 0x40
 8004fd6:	f04f 32ff 	mov.w	r2, #4294967295
 8004fda:	4620      	mov	r0, r4
 8004fdc:	f7fe f920 	bl	8003220 <fill_last_frag>
				}
				if (res == FR_OK) {
 8004fe0:	2800      	cmp	r0, #0
 8004fe2:	d15a      	bne.n	800509a <f_sync+0x122>
	dp->obj.fs = obj->fs;
 8004fe4:	6823      	ldr	r3, [r4, #0]
 8004fe6:	9302      	str	r3, [sp, #8]
	dp->obj.sclust = obj->c_scl;
 8004fe8:	6a23      	ldr	r3, [r4, #32]
 8004fea:	9304      	str	r3, [sp, #16]
	dp->obj.stat = (BYTE)obj->c_size;
 8004fec:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8004fee:	f88d 300f 	strb.w	r3, [sp, #15]
	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 8004ff2:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8004ff6:	e9cd 3006 	strd	r3, r0, [sp, #24]
	dp->blk_ofs = obj->c_ofs;
 8004ffa:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
	dp->obj.n_frag = 0;
 8004ffc:	9009      	str	r0, [sp, #36]	@ 0x24
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 8004ffe:	a802      	add	r0, sp, #8
	dp->blk_ofs = obj->c_ofs;
 8005000:	9115      	str	r1, [sp, #84]	@ 0x54
	res = dir_sdi(dp, dp->blk_ofs);	/* Goto object's entry block */
 8005002:	f7fe f9cf 	bl	80033a4 <dir_sdi>
	if (res == FR_OK) {
 8005006:	2800      	cmp	r0, #0
 8005008:	d147      	bne.n	800509a <f_sync+0x122>
		res = load_xdir(dp);		/* Load the object's entry block */
 800500a:	a802      	add	r0, sp, #8
 800500c:	f7fe fef2 	bl	8003df4 <load_xdir>
					DIR dj;
					DEF_NAMBUF

					INIT_NAMBUF(fs);
					res = load_obj_xdir(&dj, &fp->obj);	/* Load directory entry block */
					if (res == FR_OK) {
 8005010:	2800      	cmp	r0, #0
 8005012:	d142      	bne.n	800509a <f_sync+0x122>
						fs->dirbuf[XDIR_Attr] |= AM_ARC;				/* Set archive attribute to indicate that the file has been changed */
 8005014:	692a      	ldr	r2, [r5, #16]
 8005016:	7913      	ldrb	r3, [r2, #4]
 8005018:	f043 0320 	orr.w	r3, r3, #32
 800501c:	7113      	strb	r3, [r2, #4]
						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;	/* Update file allocation information */
 800501e:	79e3      	ldrb	r3, [r4, #7]
 8005020:	692a      	ldr	r2, [r5, #16]
 8005022:	f043 0301 	orr.w	r3, r3, #1
 8005026:	f882 3021 	strb.w	r3, [r2, #33]	@ 0x21
						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);		/* Update start cluster */
 800502a:	692b      	ldr	r3, [r5, #16]
 800502c:	68a2      	ldr	r2, [r4, #8]
 800502e:	635a      	str	r2, [r3, #52]	@ 0x34
						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		/* Update file size */
 8005030:	e9d4 8904 	ldrd	r8, r9, [r4, #16]
						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatFs does not support Valid File Size feature) */
						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
						fs->dirbuf[XDIR_ModTime10] = 0;
 8005034:	7558      	strb	r0, [r3, #21]
						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);		/* Update file size */
 8005036:	e9c3 890e 	strd	r8, r9, [r3, #56]	@ 0x38
						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);	/* (FatFs does not support Valid File Size feature) */
 800503a:	e9c3 890a 	strd	r8, r9, [r3, #40]	@ 0x28
						st_dword(fs->dirbuf + XDIR_ModTime, tm);		/* Update modified time */
 800503e:	60de      	str	r6, [r3, #12]
						st_dword(fs->dirbuf + XDIR_AccTime, 0);
 8005040:	692b      	ldr	r3, [r5, #16]
 8005042:	6118      	str	r0, [r3, #16]
						res = store_xdir(&dj);	/* Restore it to the directory */
 8005044:	a802      	add	r0, sp, #8
 8005046:	f7fe ff69 	bl	8003f1c <store_xdir>
						if (res == FR_OK) {
 800504a:	bb30      	cbnz	r0, 800509a <f_sync+0x122>
 800504c:	e01a      	b.n	8005084 <f_sync+0x10c>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 800504e:	6ca1      	ldr	r1, [r4, #72]	@ 0x48
 8005050:	4628      	mov	r0, r5
 8005052:	f7fd ffbb 	bl	8002fcc <move_window>
				if (res == FR_OK) {
 8005056:	2800      	cmp	r0, #0
 8005058:	d1a9      	bne.n	8004fae <f_sync+0x36>
					dir = fp->dir_ptr;
 800505a:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
 800505c:	7ada      	ldrb	r2, [r3, #11]
 800505e:	f042 0220 	orr.w	r2, r2, #32
 8005062:	72da      	strb	r2, [r3, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
 8005064:	6821      	ldr	r1, [r4, #0]
 8005066:	68a2      	ldr	r2, [r4, #8]
 8005068:	7809      	ldrb	r1, [r1, #0]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 800506a:	835a      	strh	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800506c:	2903      	cmp	r1, #3
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 800506e:	bf04      	itt	eq
 8005070:	0c12      	lsreq	r2, r2, #16
 8005072:	829a      	strheq	r2, [r3, #20]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 8005074:	6922      	ldr	r2, [r4, #16]
 8005076:	61da      	str	r2, [r3, #28]
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
					st_word(dir + DIR_LstAccDate, 0);
 8005078:	2200      	movs	r2, #0
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 800507a:	f8c3 6016 	str.w	r6, [r3, #22]
					st_word(dir + DIR_LstAccDate, 0);
 800507e:	825a      	strh	r2, [r3, #18]
					fs->wflag = 1;
 8005080:	2301      	movs	r3, #1
 8005082:	70eb      	strb	r3, [r5, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8005084:	4628      	mov	r0, r5
 8005086:	f7fe fb85 	bl	8003794 <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 800508a:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 800508e:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8005092:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
 8005096:	e000      	b.n	800509a <f_sync+0x122>
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 8005098:	2009      	movs	r0, #9
			}
		}
	}

	LEAVE_FF(fs, res);
}
 800509a:	b018      	add	sp, #96	@ 0x60
 800509c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

080050a0 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Open file to be closed */
)
{
 80050a0:	b513      	push	{r0, r1, r4, lr}
 80050a2:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 80050a4:	f7ff ff68 	bl	8004f78 <f_sync>
	if (res == FR_OK)
 80050a8:	b938      	cbnz	r0, 80050ba <f_close+0x1a>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 80050aa:	a901      	add	r1, sp, #4
 80050ac:	4620      	mov	r0, r4
 80050ae:	f7fd ff51 	bl	8002f54 <validate>
		if (res == FR_OK) {
 80050b2:	b908      	cbnz	r0, 80050b8 <f_close+0x18>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
 80050b4:	6020      	str	r0, [r4, #0]
 80050b6:	e000      	b.n	80050ba <f_close+0x1a>
		res = validate(&fp->obj, &fs);	/* Lock volume */
 80050b8:	2009      	movs	r0, #9
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 80050ba:	b002      	add	sp, #8
 80050bc:	bd10      	pop	{r4, pc}
	...

080050c0 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80050c0:	b530      	push	{r4, r5, lr}
 80050c2:	b085      	sub	sp, #20
 80050c4:	9101      	str	r1, [sp, #4]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 80050c6:	2800      	cmp	r0, #0
 80050c8:	d03b      	beq.n	8005142 <f_opendir+0x82>
 80050ca:	4604      	mov	r4, r0

	/* Get logical drive */
	res = mount_volume(&path, &fs, 0);
 80050cc:	2200      	movs	r2, #0
 80050ce:	a903      	add	r1, sp, #12
 80050d0:	a801      	add	r0, sp, #4
 80050d2:	f7fe fb99 	bl	8003808 <mount_volume>
	if (res == FR_OK) {
 80050d6:	2800      	cmp	r0, #0
 80050d8:	d130      	bne.n	800513c <f_opendir+0x7c>
		dp->obj.fs = fs;
 80050da:	9d03      	ldr	r5, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
 80050dc:	9901      	ldr	r1, [sp, #4]
		dp->obj.fs = fs;
 80050de:	6025      	str	r5, [r4, #0]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 80050e0:	4620      	mov	r0, r4
 80050e2:	f7ff faa5 	bl	8004630 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 80050e6:	bb20      	cbnz	r0, 8005132 <f_opendir+0x72>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 80050e8:	f994 304b 	ldrsb.w	r3, [r4, #75]	@ 0x4b
 80050ec:	2b00      	cmp	r3, #0
 80050ee:	db18      	blt.n	8005122 <f_opendir+0x62>
				if (dp->obj.attr & AM_DIR) {		/* This object is a sub-directory */
 80050f0:	79a3      	ldrb	r3, [r4, #6]
 80050f2:	06db      	lsls	r3, r3, #27
 80050f4:	d521      	bpl.n	800513a <f_opendir+0x7a>
#if FF_FS_EXFAT
					if (fs->fs_type == FS_EXFAT) {
 80050f6:	7828      	ldrb	r0, [r5, #0]
 80050f8:	2804      	cmp	r0, #4
 80050fa:	d10e      	bne.n	800511a <f_opendir+0x5a>
						dp->obj.c_scl = dp->obj.sclust;							/* Get containing directory inforamation */
 80050fc:	68a3      	ldr	r3, [r4, #8]
 80050fe:	6223      	str	r3, [r4, #32]
						dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 8005100:	6923      	ldr	r3, [r4, #16]
 8005102:	79e2      	ldrb	r2, [r4, #7]
						dp->obj.c_ofs = dp->blk_ofs;
						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
 8005104:	6928      	ldr	r0, [r5, #16]
						dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
 8005106:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800510a:	4313      	orrs	r3, r2
 800510c:	6263      	str	r3, [r4, #36]	@ 0x24
						dp->obj.c_ofs = dp->blk_ofs;
 800510e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8005110:	62a3      	str	r3, [r4, #40]	@ 0x28
						init_alloc_info(fs, &dp->obj);	/* Get object allocation info */
 8005112:	4621      	mov	r1, r4
 8005114:	f7ff fa76 	bl	8004604 <init_alloc_info.isra.0>
 8005118:	e003      	b.n	8005122 <f_opendir+0x62>
					} else
#endif
					{
						dp->obj.sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 800511a:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 800511c:	f7ff fa80 	bl	8004620 <ld_clust.isra.0>
 8005120:	60a0      	str	r0, [r4, #8]
				} else {						/* This object is a file */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				dp->obj.id = fs->id;
 8005122:	88eb      	ldrh	r3, [r5, #6]
 8005124:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8005126:	2100      	movs	r1, #0
 8005128:	4620      	mov	r0, r4
 800512a:	f7fe f93b 	bl	80033a4 <dir_sdi>
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 800512e:	b148      	cbz	r0, 8005144 <f_opendir+0x84>
 8005130:	e004      	b.n	800513c <f_opendir+0x7c>
					res = FR_NO_PATH;
 8005132:	2804      	cmp	r0, #4
 8005134:	bf08      	it	eq
 8005136:	2005      	moveq	r0, #5
 8005138:	e000      	b.n	800513c <f_opendir+0x7c>
 800513a:	2005      	movs	r0, #5
	if (res != FR_OK) dp->obj.fs = 0;		/* Invalidate the directory object if function faild */
 800513c:	2300      	movs	r3, #0
 800513e:	6023      	str	r3, [r4, #0]
 8005140:	e000      	b.n	8005144 <f_opendir+0x84>
	if (!dp) return FR_INVALID_OBJECT;
 8005142:	2009      	movs	r0, #9

	LEAVE_FF(fs, res);
}
 8005144:	b005      	add	sp, #20
 8005146:	bd30      	pop	{r4, r5, pc}

08005148 <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 8005148:	b513      	push	{r0, r1, r4, lr}
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
 800514a:	a901      	add	r1, sp, #4
{
 800514c:	4604      	mov	r4, r0
	res = validate(&dp->obj, &fs);	/* Check validity of the file object */
 800514e:	f7fd ff01 	bl	8002f54 <validate>
	if (res == FR_OK) {
 8005152:	b900      	cbnz	r0, 8005156 <f_closedir+0xe>
#if FF_FS_LOCK != 0
		if (dp->obj.lockid) res = dec_lock(dp->obj.lockid);	/* Decrement sub-directory open counter */
		if (res == FR_OK) dp->obj.fs = 0;	/* Invalidate directory object */
#else
		dp->obj.fs = 0;	/* Invalidate directory object */
 8005154:	6020      	str	r0, [r4, #0]
#if FF_FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 8005156:	b002      	add	sp, #8
 8005158:	bd10      	pop	{r4, pc}
	...

0800515c <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 800515c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800515e:	460d      	mov	r5, r1
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8005160:	a901      	add	r1, sp, #4
{
 8005162:	4604      	mov	r4, r0
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8005164:	f7fd fef6 	bl	8002f54 <validate>
	if (res == FR_OK) {
 8005168:	b9c8      	cbnz	r0, 800519e <f_readdir+0x42>
		if (!fno) {
 800516a:	b935      	cbnz	r5, 800517a <f_readdir+0x1e>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 800516c:	4629      	mov	r1, r5
 800516e:	4620      	mov	r0, r4
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 8005170:	b002      	add	sp, #8
 8005172:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8005176:	f7fe b915 	b.w	80033a4 <dir_sdi>
			res = DIR_READ_FILE(dp);		/* Read an item */
 800517a:	4620      	mov	r0, r4
 800517c:	f7fe ff28 	bl	8003fd0 <dir_read.constprop.0>
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 8005180:	f010 06fb 	ands.w	r6, r0, #251	@ 0xfb
 8005184:	d10c      	bne.n	80051a0 <f_readdir+0x44>
				get_fileinfo(dp, fno);		/* Get the object information */
 8005186:	4629      	mov	r1, r5
 8005188:	4620      	mov	r0, r4
 800518a:	f7fe fa1b 	bl	80035c4 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 800518e:	4631      	mov	r1, r6
 8005190:	4620      	mov	r0, r4
 8005192:	f7fe fdd1 	bl	8003d38 <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8005196:	2804      	cmp	r0, #4
 8005198:	bf08      	it	eq
 800519a:	2000      	moveq	r0, #0
 800519c:	e000      	b.n	80051a0 <f_readdir+0x44>
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 800519e:	2009      	movs	r0, #9
}
 80051a0:	b002      	add	sp, #8
 80051a2:	bd70      	pop	{r4, r5, r6, pc}

080051a4 <f_findnext>:

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
 80051a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80051a6:	4606      	mov	r6, r0
 80051a8:	460c      	mov	r4, r1


	for (;;) {
		res = f_readdir(dp, fno);		/* Get a directory item */
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
 80051aa:	f101 071a 	add.w	r7, r1, #26
		res = f_readdir(dp, fno);		/* Get a directory item */
 80051ae:	4621      	mov	r1, r4
 80051b0:	4630      	mov	r0, r6
 80051b2:	f7ff ffd3 	bl	800515c <f_readdir>
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 80051b6:	4605      	mov	r5, r0
 80051b8:	b950      	cbnz	r0, 80051d0 <f_findnext+0x2c>
 80051ba:	b14c      	cbz	r4, 80051d0 <f_findnext+0x2c>
 80051bc:	7ea3      	ldrb	r3, [r4, #26]
 80051be:	b13b      	cbz	r3, 80051d0 <f_findnext+0x2c>
		if (pattern_match(dp->pat, fno->fname, 0, FIND_RECURS)) break;		/* Test for the file name */
 80051c0:	4602      	mov	r2, r0
 80051c2:	2304      	movs	r3, #4
 80051c4:	6d30      	ldr	r0, [r6, #80]	@ 0x50
 80051c6:	4639      	mov	r1, r7
 80051c8:	f7fd fe5a 	bl	8002e80 <pattern_match>
 80051cc:	2800      	cmp	r0, #0
 80051ce:	d0ee      	beq.n	80051ae <f_findnext+0xa>
#if FF_USE_LFN && FF_USE_FIND == 2
		if (pattern_match(dp->pat, fno->altname, 0, FIND_RECURS)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
}
 80051d0:	4628      	mov	r0, r5
 80051d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080051d4 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 80051d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80051d6:	b0bd      	sub	sp, #244	@ 0xf4
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = mount_volume(&path, &fs, FA_WRITE);
 80051d8:	2202      	movs	r2, #2
{
 80051da:	9001      	str	r0, [sp, #4]
	res = mount_volume(&path, &fs, FA_WRITE);
 80051dc:	a903      	add	r1, sp, #12
 80051de:	a801      	add	r0, sp, #4
 80051e0:	f7fe fb12 	bl	8003808 <mount_volume>
	if (res == FR_OK) {
 80051e4:	2800      	cmp	r0, #0
 80051e6:	d14d      	bne.n	8005284 <f_unlink+0xb0>
		dj.obj.fs = fs;
 80051e8:	9c03      	ldr	r4, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
 80051ea:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
 80051ec:	9410      	str	r4, [sp, #64]	@ 0x40
		res = follow_path(&dj, path);		/* Follow the file path */
 80051ee:	a810      	add	r0, sp, #64	@ 0x40
 80051f0:	f7ff fa1e 	bl	8004630 <follow_path>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
		}
#if FF_FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
#endif
		if (res == FR_OK) {					/* The object is accessible */
 80051f4:	2800      	cmp	r0, #0
 80051f6:	d145      	bne.n	8005284 <f_unlink+0xb0>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 80051f8:	f99d 308b 	ldrsb.w	r3, [sp, #139]	@ 0x8b
 80051fc:	2b00      	cmp	r3, #0
 80051fe:	db40      	blt.n	8005282 <f_unlink+0xae>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
			} else {
				if (dj.obj.attr & AM_RDO) {
 8005200:	f89d 7046 	ldrb.w	r7, [sp, #70]	@ 0x46
 8005204:	07fa      	lsls	r2, r7, #31
 8005206:	d501      	bpl.n	800520c <f_unlink+0x38>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 8005208:	2007      	movs	r0, #7
 800520a:	e03b      	b.n	8005284 <f_unlink+0xb0>
				}
			}
			if (res == FR_OK) {
#if FF_FS_EXFAT
				obj.fs = fs;
				if (fs->fs_type == FS_EXFAT) {
 800520c:	7826      	ldrb	r6, [r4, #0]
				obj.fs = fs;
 800520e:	9404      	str	r4, [sp, #16]
				if (fs->fs_type == FS_EXFAT) {
 8005210:	2e04      	cmp	r6, #4
 8005212:	d105      	bne.n	8005220 <f_unlink+0x4c>
					init_alloc_info(fs, &obj);
 8005214:	6920      	ldr	r0, [r4, #16]
 8005216:	a904      	add	r1, sp, #16
 8005218:	f7ff f9f4 	bl	8004604 <init_alloc_info.isra.0>
					dclst = obj.sclust;
 800521c:	9d06      	ldr	r5, [sp, #24]
 800521e:	e004      	b.n	800522a <f_unlink+0x56>
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
 8005220:	991f      	ldr	r1, [sp, #124]	@ 0x7c
 8005222:	4630      	mov	r0, r6
 8005224:	f7ff f9fc 	bl	8004620 <ld_clust.isra.0>
 8005228:	4605      	mov	r5, r0
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 800522a:	06fb      	lsls	r3, r7, #27
 800522c:	d404      	bmi.n	8005238 <f_unlink+0x64>
						}
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);			/* Remove the directory entry */
 800522e:	a810      	add	r0, sp, #64	@ 0x40
 8005230:	f7fe fea4 	bl	8003f7c <dir_remove>
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 8005234:	b1c8      	cbz	r0, 800526a <f_unlink+0x96>
 8005236:	e025      	b.n	8005284 <f_unlink+0xb0>
						if (fs->fs_type == FS_EXFAT) {
 8005238:	2e04      	cmp	r6, #4
						sdj.obj.fs = fs;			/* Open the sub-directory */
 800523a:	9426      	str	r4, [sp, #152]	@ 0x98
						sdj.obj.sclust = dclst;
 800523c:	9528      	str	r5, [sp, #160]	@ 0xa0
						if (fs->fs_type == FS_EXFAT) {
 800523e:	d107      	bne.n	8005250 <f_unlink+0x7c>
							sdj.obj.objsize = obj.objsize;
 8005240:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8005244:	e9cd 232a 	strd	r2, r3, [sp, #168]	@ 0xa8
							sdj.obj.stat = obj.stat;
 8005248:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800524c:	f88d 309f 	strb.w	r3, [sp, #159]	@ 0x9f
						res = dir_sdi(&sdj, 0);
 8005250:	2100      	movs	r1, #0
 8005252:	a826      	add	r0, sp, #152	@ 0x98
 8005254:	f7fe f8a6 	bl	80033a4 <dir_sdi>
						if (res == FR_OK) {
 8005258:	b9a0      	cbnz	r0, 8005284 <f_unlink+0xb0>
							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
 800525a:	a826      	add	r0, sp, #152	@ 0x98
 800525c:	f7fe feb8 	bl	8003fd0 <dir_read.constprop.0>
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 8005260:	2800      	cmp	r0, #0
 8005262:	d0d1      	beq.n	8005208 <f_unlink+0x34>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 8005264:	2804      	cmp	r0, #4
 8005266:	d10d      	bne.n	8005284 <f_unlink+0xb0>
 8005268:	e7e1      	b.n	800522e <f_unlink+0x5a>
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
 800526a:	b91d      	cbnz	r5, 8005274 <f_unlink+0xa0>
					res = remove_chain(&obj, dclst, 0);
#else
					res = remove_chain(&dj.obj, dclst, 0);
#endif
				}
				if (res == FR_OK) res = sync_fs(fs);
 800526c:	4620      	mov	r0, r4
 800526e:	f7fe fa91 	bl	8003794 <sync_fs>
 8005272:	e007      	b.n	8005284 <f_unlink+0xb0>
					res = remove_chain(&obj, dclst, 0);
 8005274:	4602      	mov	r2, r0
 8005276:	4629      	mov	r1, r5
 8005278:	a804      	add	r0, sp, #16
 800527a:	f7fe f8db 	bl	8003434 <remove_chain>
				if (res == FR_OK) res = sync_fs(fs);
 800527e:	b908      	cbnz	r0, 8005284 <f_unlink+0xb0>
 8005280:	e7f4      	b.n	800526c <f_unlink+0x98>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 8005282:	2006      	movs	r0, #6
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 8005284:	b03d      	add	sp, #244	@ 0xf4
 8005286:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005288 <ff_uni2oem>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (uni < 0x80) {	/* ASCII? */
 8005288:	287f      	cmp	r0, #127	@ 0x7f
 800528a:	d801      	bhi.n	8005290 <ff_uni2oem+0x8>
		c = (WCHAR)uni;
 800528c:	b280      	uxth	r0, r0
 800528e:	4770      	bx	lr

	} else {			/* Non-ASCII */
		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 8005290:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 8005294:	d203      	bcs.n	800529e <ff_uni2oem+0x16>
 8005296:	f240 3362 	movw	r3, #866	@ 0x362
 800529a:	4299      	cmp	r1, r3
 800529c:	d001      	beq.n	80052a2 <ff_uni2oem+0x1a>
	WCHAR c = 0;
 800529e:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
 80052a0:	4770      	bx	lr
 80052a2:	4a06      	ldr	r2, [pc, #24]	@ (80052bc <ff_uni2oem+0x34>)
		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 80052a4:	2300      	movs	r3, #0
 80052a6:	e002      	b.n	80052ae <ff_uni2oem+0x26>
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 80052a8:	3301      	adds	r3, #1
 80052aa:	2b80      	cmp	r3, #128	@ 0x80
 80052ac:	d0f7      	beq.n	800529e <ff_uni2oem+0x16>
 80052ae:	f832 1b02 	ldrh.w	r1, [r2], #2
 80052b2:	4281      	cmp	r1, r0
 80052b4:	d1f8      	bne.n	80052a8 <ff_uni2oem+0x20>
			c = (c + 0x80) & 0xFF;
 80052b6:	3380      	adds	r3, #128	@ 0x80
 80052b8:	b298      	uxth	r0, r3
 80052ba:	4770      	bx	lr
 80052bc:	08014fec 	.word	0x08014fec

080052c0 <ff_oem2uni>:
{
	WCHAR c = 0;
	const WCHAR *p = CVTBL(uc, FF_CODE_PAGE);


	if (oem < 0x80) {	/* ASCII? */
 80052c0:	287f      	cmp	r0, #127	@ 0x7f
 80052c2:	d904      	bls.n	80052ce <ff_oem2uni+0xe>
		c = oem;

	} else {			/* Extended char */
		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
 80052c4:	f240 3362 	movw	r3, #866	@ 0x362
 80052c8:	4299      	cmp	r1, r3
 80052ca:	d001      	beq.n	80052d0 <ff_oem2uni+0x10>
	WCHAR c = 0;
 80052cc:	2000      	movs	r0, #0
			if (oem < 0x100) c = p[oem - 0x80];
		}
	}

	return c;
}
 80052ce:	4770      	bx	lr
			if (oem < 0x100) c = p[oem - 0x80];
 80052d0:	28ff      	cmp	r0, #255	@ 0xff
 80052d2:	d8fb      	bhi.n	80052cc <ff_oem2uni+0xc>
 80052d4:	f100 4000 	add.w	r0, r0, #2147483648	@ 0x80000000
 80052d8:	4b02      	ldr	r3, [pc, #8]	@ (80052e4 <ff_oem2uni+0x24>)
 80052da:	3880      	subs	r0, #128	@ 0x80
 80052dc:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 80052e0:	4770      	bx	lr
 80052e2:	bf00      	nop
 80052e4:	08014fec 	.word	0x08014fec

080052e8 <ff_wtoupper>:

		0x0000	/* EOT */
	};


	if (uni < 0x10000) {	/* Is it in BMP? */
 80052e8:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 80052ec:	d21d      	bcs.n	800532a <ff_wtoupper+0x42>
{
 80052ee:	b530      	push	{r4, r5, lr}
		uc = (WORD)uni;
 80052f0:	b284      	uxth	r4, r0
		p = uc < 0x1000 ? cvt1 : cvt2;
 80052f2:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
 80052f6:	bf34      	ite	cc
 80052f8:	4b22      	ldrcc	r3, [pc, #136]	@ (8005384 <ff_wtoupper+0x9c>)
 80052fa:	4b23      	ldrcs	r3, [pc, #140]	@ (8005388 <ff_wtoupper+0xa0>)
 80052fc:	3304      	adds	r3, #4
 80052fe:	e00d      	b.n	800531c <ff_wtoupper+0x34>
		for (;;) {
			bc = *p++;								/* Get the block base */
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 8005300:	428c      	cmp	r4, r1
 8005302:	d310      	bcc.n	8005326 <ff_wtoupper+0x3e>
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8005304:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 8005308:	fa5f fc82 	uxtb.w	ip, r2
			if (uc < bc + nc) {	/* In the block? */
 800530c:	eb0c 0e01 	add.w	lr, ip, r1
 8005310:	4570      	cmp	r0, lr
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8005312:	ea4f 2212 	mov.w	r2, r2, lsr #8
			if (uc < bc + nc) {	/* In the block? */
 8005316:	db09      	blt.n	800532c <ff_wtoupper+0x44>
				case 7: uc -= 80; break;			/* Shift -80 */
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
				}
				break;
			}
			if (cmd == 0) p += nc;	/* Skip table if needed */
 8005318:	3304      	adds	r3, #4
 800531a:	b182      	cbz	r2, 800533e <ff_wtoupper+0x56>
			bc = *p++;								/* Get the block base */
 800531c:	f833 1c04 	ldrh.w	r1, [r3, #-4]
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 8005320:	461d      	mov	r5, r3
 8005322:	2900      	cmp	r1, #0
 8005324:	d1ec      	bne.n	8005300 <ff_wtoupper+0x18>
		}
		uni = uc;
 8005326:	4620      	mov	r0, r4
	}

	return uni;
}
 8005328:	bd30      	pop	{r4, r5, pc}
 800532a:	4770      	bx	lr
				switch (cmd) {
 800532c:	2a08      	cmp	r2, #8
 800532e:	d8fa      	bhi.n	8005326 <ff_wtoupper+0x3e>
 8005330:	e8df f002 	tbb	[pc, r2]
 8005334:	181b1e24 	.word	0x181b1e24
 8005338:	0c0f1215 	.word	0x0c0f1215
 800533c:	08          	.byte	0x08
 800533d:	00          	.byte	0x00
			if (cmd == 0) p += nc;	/* Skip table if needed */
 800533e:	eb05 034c 	add.w	r3, r5, ip, lsl #1
 8005342:	e7db      	b.n	80052fc <ff_wtoupper+0x14>
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
 8005344:	f5a4 54e3 	sub.w	r4, r4, #7264	@ 0x1c60
 8005348:	b2a4      	uxth	r4, r4
 800534a:	e7ec      	b.n	8005326 <ff_wtoupper+0x3e>
				case 7: uc -= 80; break;			/* Shift -80 */
 800534c:	3c50      	subs	r4, #80	@ 0x50
 800534e:	b2a4      	uxth	r4, r4
 8005350:	e7e9      	b.n	8005326 <ff_wtoupper+0x3e>
				case 6:	uc += 8; break;				/* Shift +8 */
 8005352:	3408      	adds	r4, #8
 8005354:	b2a4      	uxth	r4, r4
 8005356:	e7e6      	b.n	8005326 <ff_wtoupper+0x3e>
				case 5:	uc -= 26; break;			/* Shift -26 */
 8005358:	3c1a      	subs	r4, #26
 800535a:	b2a4      	uxth	r4, r4
 800535c:	e7e3      	b.n	8005326 <ff_wtoupper+0x3e>
				case 4:	uc -= 48; break;			/* Shift -48 */
 800535e:	3c30      	subs	r4, #48	@ 0x30
 8005360:	b2a4      	uxth	r4, r4
 8005362:	e7e0      	b.n	8005326 <ff_wtoupper+0x3e>
				case 3:	uc -= 32; break;			/* Shift -32 */
 8005364:	3c20      	subs	r4, #32
 8005366:	b2a4      	uxth	r4, r4
 8005368:	e7dd      	b.n	8005326 <ff_wtoupper+0x3e>
				case 2: uc -= 16; break;			/* Shift -16 */
 800536a:	3c10      	subs	r4, #16
 800536c:	b2a4      	uxth	r4, r4
 800536e:	e7da      	b.n	8005326 <ff_wtoupper+0x3e>
				case 1:	uc -= (uc - bc) & 1; break;	/* Case pairs */
 8005370:	1a63      	subs	r3, r4, r1
 8005372:	f003 0301 	and.w	r3, r3, #1
 8005376:	1ae4      	subs	r4, r4, r3
 8005378:	b2a4      	uxth	r4, r4
 800537a:	e7d4      	b.n	8005326 <ff_wtoupper+0x3e>
				case 0:	uc = p[uc - bc]; break;		/* Table conversion */
 800537c:	1a40      	subs	r0, r0, r1
 800537e:	f833 4010 	ldrh.w	r4, [r3, r0, lsl #1]
 8005382:	e7d0      	b.n	8005326 <ff_wtoupper+0x3e>
 8005384:	08014df8 	.word	0x08014df8
 8005388:	08014d3c 	.word	0x08014d3c

0800538c <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 800538c:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800538e:	2320      	movs	r3, #32
 8005390:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;
  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
 8005394:	4803      	ldr	r0, [pc, #12]	@ (80053a4 <sof_handler+0x18>)
 8005396:	f7fc fa0f 	bl	80017b8 <sduSOFHookI>
 800539a:	2300      	movs	r3, #0
 800539c:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlockFromISR();
}
 80053a0:	bd08      	pop	{r3, pc}
 80053a2:	bf00      	nop
 80053a4:	200007b0 	.word	0x200007b0

080053a8 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80053a8:	b538      	push	{r3, r4, r5, lr}
 80053aa:	460c      	mov	r4, r1
 80053ac:	2320      	movs	r3, #32
 80053ae:	f383 8811 	msr	BASEPRI, r3
  switch (event) {
 80053b2:	2902      	cmp	r1, #2
 80053b4:	d00c      	beq.n	80053d0 <usb_event+0x28>
 80053b6:	2903      	cmp	r1, #3
 80053b8:	d003      	beq.n	80053c2 <usb_event+0x1a>
 80053ba:	2300      	movs	r3, #0
 80053bc:	f383 8811 	msr	BASEPRI, r3
}
 80053c0:	bd38      	pop	{r3, r4, r5, pc}
    sduDisconnectI(&SDU1);
 80053c2:	480c      	ldr	r0, [pc, #48]	@ (80053f4 <usb_event+0x4c>)
 80053c4:	f7fc f9c2 	bl	800174c <sduDisconnectI>
 80053c8:	2300      	movs	r3, #0
 80053ca:	f383 8811 	msr	BASEPRI, r3
}
 80053ce:	bd38      	pop	{r3, r4, r5, pc}
 80053d0:	4605      	mov	r5, r0
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 80053d2:	4a09      	ldr	r2, [pc, #36]	@ (80053f8 <usb_event+0x50>)
 80053d4:	2101      	movs	r1, #1
 80053d6:	f7fc fab5 	bl	8001944 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 80053da:	4a08      	ldr	r2, [pc, #32]	@ (80053fc <usb_event+0x54>)
 80053dc:	4621      	mov	r1, r4
 80053de:	4628      	mov	r0, r5
 80053e0:	f7fc fab0 	bl	8001944 <usbInitEndpointI>
    sduConfigureHookI(&SDU1);
 80053e4:	4803      	ldr	r0, [pc, #12]	@ (80053f4 <usb_event+0x4c>)
 80053e6:	f7fc f9bd 	bl	8001764 <sduConfigureHookI>
 80053ea:	2300      	movs	r3, #0
 80053ec:	f383 8811 	msr	BASEPRI, r3
}
 80053f0:	bd38      	pop	{r3, r4, r5, pc}
 80053f2:	bf00      	nop
 80053f4:	200007b0 	.word	0x200007b0
 80053f8:	08015998 	.word	0x08015998
 80053fc:	0801597c 	.word	0x0801597c

08005400 <getSerialStringDescriptor>:
  uint32_t id0 = *(uint32_t *)0x1FFFF7AC; // MCU id0 address
 8005400:	4a17      	ldr	r2, [pc, #92]	@ (8005460 <getSerialStringDescriptor+0x60>)
  id0+= id2;
 8005402:	f8d2 07b4 	ldr.w	r0, [r2, #1972]	@ 0x7b4
  uint32_t id0 = *(uint32_t *)0x1FFFF7AC; // MCU id0 address
 8005406:	f8d2 37ac 	ldr.w	r3, [r2, #1964]	@ 0x7ac
  uint64_t uid = id1;
 800540a:	f8d2 17b0 	ldr.w	r1, [r2, #1968]	@ 0x7b0
USBDescriptor *getSerialStringDescriptor(void) {
 800540e:	b510      	push	{r4, lr}
 8005410:	4c14      	ldr	r4, [pc, #80]	@ (8005464 <getSerialStringDescriptor+0x64>)
  id0+= id2;
 8005412:	4403      	add	r3, r0
  uid|= id0 | (uid<<32);                  // generate unique 64bit ID
 8005414:	430b      	orrs	r3, r1
  for(i = 1; i < USB_SERIAL_STRING_SIZE + 1; i++) {
 8005416:	4620      	mov	r0, r4
 8005418:	f104 0e18 	add.w	lr, r4, #24
    uint16_t c = uid & ((1<<UID_RADIX) - 1);
 800541c:	f003 021f 	and.w	r2, r3, #31
    buf[i] = c + (c < 0x0A ? '0' : 'A' - 0x0A);
 8005420:	2a0a      	cmp	r2, #10
 8005422:	bf34      	ite	cc
 8005424:	f04f 0c30 	movcc.w	ip, #48	@ 0x30
 8005428:	f04f 0c37 	movcs.w	ip, #55	@ 0x37
 800542c:	4462      	add	r2, ip
 800542e:	f820 2f02 	strh.w	r2, [r0, #2]!
    uid>>= UID_RADIX;
 8005432:	095b      	lsrs	r3, r3, #5
  for(i = 1; i < USB_SERIAL_STRING_SIZE + 1; i++) {
 8005434:	4586      	cmp	lr, r0
    uid>>= UID_RADIX;
 8005436:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 800543a:	ea4f 1151 	mov.w	r1, r1, lsr #5
  for(i = 1; i < USB_SERIAL_STRING_SIZE + 1; i++) {
 800543e:	d1ed      	bne.n	800541c <getSerialStringDescriptor+0x1c>
  buf[0] = size | (USB_DESCRIPTOR_STRING << 8);
 8005440:	4809      	ldr	r0, [pc, #36]	@ (8005468 <getSerialStringDescriptor+0x68>)
 8005442:	f240 311a 	movw	r1, #794	@ 0x31a
  d->ud_size   = size;
 8005446:	2300      	movs	r3, #0
 8005448:	221a      	movs	r2, #26
  buf[0] = size | (USB_DESCRIPTOR_STRING << 8);
 800544a:	f8a0 1fe0 	strh.w	r1, [r0, #4064]	@ 0xfe0
  d->ud_size   = size;
 800544e:	f8a0 2fd8 	strh.w	r2, [r0, #4056]	@ 0xfd8
 8005452:	f8a0 3fda 	strh.w	r3, [r0, #4058]	@ 0xfda
  d->ud_string = (uint8_t *)buf;
 8005456:	f8c0 4fdc 	str.w	r4, [r0, #4060]	@ 0xfdc
}
 800545a:	f600 70d8 	addw	r0, r0, #4056	@ 0xfd8
 800545e:	bd10      	pop	{r4, pc}
 8005460:	1ffff000 	.word	0x1ffff000
 8005464:	20009a1c 	.word	0x20009a1c
 8005468:	20008a3c 	.word	0x20008a3c

0800546c <get_descriptor>:
  switch (dtype) {
 800546c:	2902      	cmp	r1, #2
 800546e:	d00e      	beq.n	800548e <get_descriptor+0x22>
 8005470:	2903      	cmp	r1, #3
 8005472:	d003      	beq.n	800547c <get_descriptor+0x10>
 8005474:	2901      	cmp	r1, #1
 8005476:	d108      	bne.n	800548a <get_descriptor+0x1e>
    return &vcom_device_descriptor;
 8005478:	4809      	ldr	r0, [pc, #36]	@ (80054a0 <get_descriptor+0x34>)
 800547a:	4770      	bx	lr
    if (dindex == STR_SERIAL && VNA_MODE(VNA_MODE_USB_UID))
 800547c:	2a03      	cmp	r2, #3
 800547e:	d008      	beq.n	8005492 <get_descriptor+0x26>
    if (dindex < 4)
 8005480:	d803      	bhi.n	800548a <get_descriptor+0x1e>
      return &vcom_strings[dindex];
 8005482:	4808      	ldr	r0, [pc, #32]	@ (80054a4 <get_descriptor+0x38>)
 8005484:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 8005488:	4770      	bx	lr
  return NULL;
 800548a:	2000      	movs	r0, #0
}
 800548c:	4770      	bx	lr
  switch (dtype) {
 800548e:	4806      	ldr	r0, [pc, #24]	@ (80054a8 <get_descriptor+0x3c>)
 8005490:	4770      	bx	lr
    if (dindex == STR_SERIAL && VNA_MODE(VNA_MODE_USB_UID))
 8005492:	4b06      	ldr	r3, [pc, #24]	@ (80054ac <get_descriptor+0x40>)
 8005494:	8a9b      	ldrh	r3, [r3, #20]
 8005496:	059b      	lsls	r3, r3, #22
 8005498:	d5f3      	bpl.n	8005482 <get_descriptor+0x16>
      return getSerialStringDescriptor();
 800549a:	f7ff bfb1 	b.w	8005400 <getSerialStringDescriptor>
 800549e:	bf00      	nop
 80054a0:	08015a5c 	.word	0x08015a5c
 80054a4:	080159b4 	.word	0x080159b4
 80054a8:	08015a10 	.word	0x08015a10
 80054ac:	20000318 	.word	0x20000318

080054b0 <getSWRfromIndex>:
// SWR = (1 + ||) / (1 - ||),    = S11
// If || is invalid or >= 1, return a very large SWR.
// ---------------------------------------------------------------------------
static float getSWRfromIndex(uint16_t i)
{
  if (i >= sweep_points)
 80054b0:	4b14      	ldr	r3, [pc, #80]	@ (8005504 <getSWRfromIndex+0x54>)
 80054b2:	8b5b      	ldrh	r3, [r3, #26]
 80054b4:	4283      	cmp	r3, r0
 80054b6:	d921      	bls.n	80054fc <getSWRfromIndex+0x4c>
    return 9999.0f;

  float re = measured[0][i][0];
 80054b8:	4b13      	ldr	r3, [pc, #76]	@ (8005508 <getSWRfromIndex+0x58>)
 80054ba:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
  float im = measured[0][i][1];
 80054be:	edd3 7a01 	vldr	s15, [r3, #4]
  float re = measured[0][i][0];
 80054c2:	ed93 7a00 	vldr	s14, [r3]
  float mag2 = re * re + im * im;
 80054c6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80054ca:	eee7 7a07 	vfma.f32	s15, s14, s14

  if (mag2 <= 0.0f)
 80054ce:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80054d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80054d6:	d911      	bls.n	80054fc <getSWRfromIndex+0x4c>
// VNA math used library
#ifdef __USE_VNA_MATH__
// Some functions implemented in hardware FPU
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 80054d8:	eef1 7ae7 	vsqrt.f32	s15, s15
    return 9999.0f;

  float mag = vna_sqrtf(mag2); // ||

  if (mag >= 0.9999f)
 80054dc:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 800550c <getSWRfromIndex+0x5c>
 80054e0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80054e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80054e8:	da08      	bge.n	80054fc <getSWRfromIndex+0x4c>
    return 9999.0f;

  return (1.0f + mag) / (1.0f - mag);
 80054ea:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80054ee:	ee77 6a87 	vadd.f32	s13, s15, s14
 80054f2:	ee37 7a67 	vsub.f32	s14, s14, s15
 80054f6:	ee86 0a87 	vdiv.f32	s0, s13, s14
 80054fa:	4770      	bx	lr
    return 9999.0f;
 80054fc:	ed9f 0a04 	vldr	s0, [pc, #16]	@ 8005510 <getSWRfromIndex+0x60>
}
 8005500:	4770      	bx	lr
 8005502:	bf00      	nop
 8005504:	20000aa8 	.word	0x20000aa8
 8005508:	20004f54 	.word	0x20004f54
 800550c:	3f7ff972 	.word	0x3f7ff972
 8005510:	461c3c00 	.word	0x461c3c00

08005514 <shell_write>:
  formatted_bytes = chvprintf(shell_stream, fmt, ap);
  va_end(ap);
  return formatted_bytes;
}

static void shell_write(const void *buf, uint32_t size) { streamWrite(shell_stream, buf, size); }
 8005514:	4b05      	ldr	r3, [pc, #20]	@ (800552c <shell_write+0x18>)
 8005516:	681b      	ldr	r3, [r3, #0]
 8005518:	b410      	push	{r4}
 800551a:	681c      	ldr	r4, [r3, #0]
 800551c:	6824      	ldr	r4, [r4, #0]
 800551e:	460a      	mov	r2, r1
 8005520:	4601      	mov	r1, r0
 8005522:	4618      	mov	r0, r3
 8005524:	4623      	mov	r3, r4
 8005526:	f85d 4b04 	ldr.w	r4, [sp], #4
 800552a:	4718      	bx	r3
 800552c:	200068ec 	.word	0x200068ec

08005530 <eterm_calc_er>:
  cal_status |= CALSTAT_ES;
}

static void
eterm_calc_er(int sign)
{
 8005530:	b410      	push	{r4}
  int i;
  for (i = 0; i < sweep_points; i++)
 8005532:	4c27      	ldr	r4, [pc, #156]	@ (80055d0 <eterm_calc_er+0xa0>)
 8005534:	8b63      	ldrh	r3, [r4, #26]
 8005536:	2b00      	cmp	r3, #0
 8005538:	d041      	beq.n	80055be <eterm_calc_er+0x8e>
 800553a:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
 800553e:	4622      	mov	r2, r4
 8005540:	f604 5158 	addw	r1, r4, #3416	@ 0xd58
 8005544:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 8005548:	f504 53cf 	add.w	r3, r4, #6624	@ 0x19e0
  {
    // Er = sign*(1-sign*Es)S11ms'
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 800554c:	edd2 4a35 	vldr	s9, [r2, #212]	@ 0xd4
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8005550:	ed92 4a34 	vldr	s8, [r2, #208]	@ 0xd0
 8005554:	edd3 5a00 	vldr	s11, [r3]
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8005558:	edd3 7a01 	vldr	s15, [r3, #4]
    float esr = cal_data[ETERM_ES][i][0];
    float esi = cal_data[ETERM_ES][i][1];
 800555c:	ed91 6a01 	vldr	s12, [r1, #4]
    float esr = cal_data[ETERM_ES][i][0];
 8005560:	ed91 5a00 	vldr	s10, [r1]
    {
      esr = -esr;
      esi = -esi;
    }
    esr = 1 + esr;
    float err = esr * s11sr - esi * s11si;
 8005564:	ee74 6ae7 	vsub.f32	s13, s9, s15
    float eri = esr * s11si + esi * s11sr;
 8005568:	ee34 7a65 	vsub.f32	s14, s8, s11
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 800556c:	ee75 5ac4 	vsub.f32	s11, s11, s8
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8005570:	ee77 7ae4 	vsub.f32	s15, s15, s9
    float err = esr * s11sr - esi * s11si;
 8005574:	ee66 6a66 	vnmul.f32	s13, s12, s13
    esr = 1 + esr;
 8005578:	ee75 3a03 	vadd.f32	s7, s10, s6
    float eri = esr * s11si + esi * s11sr;
 800557c:	ee27 7a06 	vmul.f32	s14, s14, s12
 8005580:	ee33 5a45 	vsub.f32	s10, s6, s10
 8005584:	ee65 4a86 	vmul.f32	s9, s11, s12
    if (sign > 0)
 8005588:	2801      	cmp	r0, #1
    float eri = esr * s11si + esi * s11sr;
 800558a:	eee7 4aa3 	vfma.f32	s9, s15, s7
    float err = esr * s11sr - esi * s11si;
 800558e:	eee5 6a85 	vfma.f32	s13, s11, s10
    float eri = esr * s11si + esi * s11sr;
 8005592:	eea7 7a85 	vfma.f32	s14, s15, s10
    float err = esr * s11sr - esi * s11si;
 8005596:	ee27 6a86 	vmul.f32	s12, s15, s12
    if (sign > 0)
 800559a:	d005      	beq.n	80055a8 <eterm_calc_er+0x78>
    if (sign < 0)
    {
      err = -err;
 800559c:	eef0 6a46 	vmov.f32	s13, s12
 80055a0:	eee5 6ae3 	vfms.f32	s13, s11, s7
      eri = -eri;
 80055a4:	eeb1 7a64 	vneg.f32	s14, s9
  for (i = 0; i < sweep_points; i++)
 80055a8:	3208      	adds	r2, #8
 80055aa:	4562      	cmp	r2, ip
    }
    cal_data[ETERM_ER][i][0] = err;
 80055ac:	edc3 6a00 	vstr	s13, [r3]
    cal_data[ETERM_ER][i][1] = eri;
 80055b0:	ed83 7a01 	vstr	s14, [r3, #4]
  for (i = 0; i < sweep_points; i++)
 80055b4:	f101 0108 	add.w	r1, r1, #8
 80055b8:	f103 0308 	add.w	r3, r3, #8
 80055bc:	d1c6      	bne.n	800554c <eterm_calc_er+0x1c>
  }
  cal_status &= ~CALSTAT_SHORT;
 80055be:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
 80055c0:	f023 0304 	bic.w	r3, r3, #4
  cal_status |= CALSTAT_ER;
 80055c4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80055c8:	84a3      	strh	r3, [r4, #36]	@ 0x24
}
 80055ca:	f85d 4b04 	ldr.w	r4, [sp], #4
 80055ce:	4770      	bx	lr
 80055d0:	20000aa8 	.word	0x20000aa8

080055d4 <set_domain_mode>:

#ifdef ENABLE_TRANSFORM_COMMAND
static void
set_domain_mode(int mode) // accept DOMAIN_FREQ or DOMAIN_TIME
{
  if (mode != (props_mode & DOMAIN_MODE))
 80055d4:	4a09      	ldr	r2, [pc, #36]	@ (80055fc <set_domain_mode+0x28>)
{
 80055d6:	b508      	push	{r3, lr}
  if (mode != (props_mode & DOMAIN_MODE))
 80055d8:	8b13      	ldrh	r3, [r2, #24]
 80055da:	f003 0101 	and.w	r1, r3, #1
 80055de:	4281      	cmp	r1, r0
 80055e0:	d100      	bne.n	80055e4 <set_domain_mode+0x10>
  {
    props_mode = (props_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
    request_to_redraw(REDRAW_FREQUENCY | REDRAW_MARKER);
    lever_mode = LM_MARKER;
  }
}
 80055e2:	bd08      	pop	{r3, pc}
    props_mode = (props_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
 80055e4:	f023 0301 	bic.w	r3, r3, #1
 80055e8:	4303      	orrs	r3, r0
    request_to_redraw(REDRAW_FREQUENCY | REDRAW_MARKER);
 80055ea:	2028      	movs	r0, #40	@ 0x28
    props_mode = (props_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
 80055ec:	8313      	strh	r3, [r2, #24]
    request_to_redraw(REDRAW_FREQUENCY | REDRAW_MARKER);
 80055ee:	f007 f8bb 	bl	800c768 <request_to_redraw>
    lever_mode = LM_MARKER;
 80055f2:	4b03      	ldr	r3, [pc, #12]	@ (8005600 <set_domain_mode+0x2c>)
 80055f4:	2200      	movs	r2, #0
 80055f6:	771a      	strb	r2, [r3, #28]
}
 80055f8:	bd08      	pop	{r3, pc}
 80055fa:	bf00      	nop
 80055fc:	20000aa8 	.word	0x20000aa8
 8005600:	20000318 	.word	0x20000318

08005604 <cal_interpolate>:
{
 8005604:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005608:	ed2d 8b02 	vpush	{d8}
  if (idx >= 0)
 800560c:	1e06      	subs	r6, r0, #0
{
 800560e:	b083      	sub	sp, #12
 8005610:	4615      	mov	r5, r2
  if (idx >= 0)
 8005612:	da7e      	bge.n	8005712 <cal_interpolate+0x10e>
  if (f <= cal_frequency0)
 8005614:	4c59      	ldr	r4, [pc, #356]	@ (800577c <cal_interpolate+0x178>)
 8005616:	f8d4 a00c 	ldr.w	sl, [r4, #12]
 800561a:	458a      	cmp	sl, r1
 800561c:	460f      	mov	r7, r1
 800561e:	f080 808e 	bcs.w	800573e <cal_interpolate+0x13a>
  uint16_t src_points = cal_sweep_points - 1;
 8005622:	f8b4 9022 	ldrh.w	r9, [r4, #34]	@ 0x22
  if (f >= cal_frequency1)
 8005626:	6920      	ldr	r0, [r4, #16]
  uint16_t src_points = cal_sweep_points - 1;
 8005628:	f109 39ff 	add.w	r9, r9, #4294967295
  if (f >= cal_frequency1)
 800562c:	4288      	cmp	r0, r1
  uint16_t src_points = cal_sweep_points - 1;
 800562e:	fa1f f989 	uxth.w	r9, r9
  if (f >= cal_frequency1)
 8005632:	f240 8086 	bls.w	8005742 <cal_interpolate+0x13e>
  freq_t span = cal_frequency1 - cal_frequency0;
 8005636:	eba0 080a 	sub.w	r8, r0, sl
  idx = (uint64_t)(f - cal_frequency0) * (uint64_t)src_points / span;
 800563a:	eba1 000a 	sub.w	r0, r1, sl
 800563e:	4642      	mov	r2, r8
 8005640:	2300      	movs	r3, #0
 8005642:	fba0 0109 	umull	r0, r1, r0, r9
 8005646:	f7fb f961 	bl	800090c <__aeabi_uldivmod>
 800564a:	4606      	mov	r6, r0
  uint64_t v = (uint64_t)span * idx + src_points / 2;
 800564c:	fba6 cb08 	umull	ip, fp, r6, r8
 8005650:	17c0      	asrs	r0, r0, #31
 8005652:	ea4f 0159 	mov.w	r1, r9, lsr #1
 8005656:	eb1c 0101 	adds.w	r1, ip, r1
 800565a:	fb08 bb00 	mla	fp, r8, r0, fp
 800565e:	f14b 0b00 	adc.w	fp, fp, #0
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 8005662:	464a      	mov	r2, r9
 8005664:	2300      	movs	r3, #0
 8005666:	9101      	str	r1, [sp, #4]
 8005668:	4608      	mov	r0, r1
 800566a:	4659      	mov	r1, fp
 800566c:	f7fb f94e 	bl	800090c <__aeabi_uldivmod>
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 8005670:	9901      	ldr	r1, [sp, #4]
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 8005672:	4603      	mov	r3, r0
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 8005674:	eb18 0001 	adds.w	r0, r8, r1
 8005678:	f14b 0100 	adc.w	r1, fp, #0
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 800567c:	4698      	mov	r8, r3
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 800567e:	464a      	mov	r2, r9
 8005680:	2300      	movs	r3, #0
 8005682:	f7fb f943 	bl	800090c <__aeabi_uldivmod>
  freq_t src_f0 = cal_frequency0 + (v) / src_points;
 8005686:	eb0a 0b08 	add.w	fp, sl, r8
  if (f == src_f0)
 800568a:	455f      	cmp	r7, fp
  freq_t src_f1 = cal_frequency0 + (v + span) / src_points;
 800568c:	4482      	add	sl, r0
  freq_t delta = src_f1 - src_f0;
 800568e:	eba0 0008 	sub.w	r0, r0, r8
  if (f == src_f0)
 8005692:	d03f      	beq.n	8005714 <cal_interpolate+0x110>
  float k = (delta == 0) ? 0.0f : (float)(f - src_f0) / delta;
 8005694:	2800      	cmp	r0, #0
 8005696:	d056      	beq.n	8005746 <cal_interpolate+0x142>
 8005698:	eba7 030b 	sub.w	r3, r7, fp
 800569c:	ee07 0a90 	vmov	s15, r0
 80056a0:	ee07 3a10 	vmov	s14, r3
 80056a4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80056a8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 80056ac:	ee87 8a27 	vdiv.f32	s16, s14, s15
  uint32_t hf0 = si5351_get_harmonic_lvl(src_f0);
 80056b0:	4658      	mov	r0, fp
 80056b2:	f004 fc0b 	bl	8009ecc <si5351_get_harmonic_lvl>
 80056b6:	4680      	mov	r8, r0
  if (hf0 != si5351_get_harmonic_lvl(src_f1))
 80056b8:	4650      	mov	r0, sl
 80056ba:	f004 fc07 	bl	8009ecc <si5351_get_harmonic_lvl>
 80056be:	4540      	cmp	r0, r8
 80056c0:	d144      	bne.n	800574c <cal_interpolate+0x148>
      idx++;
 80056c2:	1c73      	adds	r3, r6, #1
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 80056c4:	1d2a      	adds	r2, r5, #4
 80056c6:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
 80056ca:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80056ce:	352c      	adds	r5, #44	@ 0x2c
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 80056d0:	edd6 7a34 	vldr	s15, [r6, #208]	@ 0xd0
 80056d4:	ed93 7a34 	vldr	s14, [r3, #208]	@ 0xd0
 80056d8:	ee37 7a67 	vsub.f32	s14, s14, s15
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 80056dc:	4611      	mov	r1, r2
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 80056de:	eee7 7a08 	vfma.f32	s15, s14, s16
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 80056e2:	3208      	adds	r2, #8
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 80056e4:	ed42 7a03 	vstr	s15, [r2, #-12]
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 80056e8:	edd6 7a35 	vldr	s15, [r6, #212]	@ 0xd4
 80056ec:	ed93 7a35 	vldr	s14, [r3, #212]	@ 0xd4
 80056f0:	ee37 7a67 	vsub.f32	s14, s14, s15
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 80056f4:	4295      	cmp	r5, r2
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 80056f6:	eee7 7a08 	vfma.f32	s15, s14, s16
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 80056fa:	f606 4688 	addw	r6, r6, #3208	@ 0xc88
 80056fe:	f603 4388 	addw	r3, r3, #3208	@ 0xc88
    data[eterm][1] = cal_data[eterm][idx][1] + k * (cal_data[eterm][idx + 1][1] - cal_data[eterm][idx][1]);
 8005702:	edc1 7a00 	vstr	s15, [r1]
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 8005706:	d1e3      	bne.n	80056d0 <cal_interpolate+0xcc>
}
 8005708:	b003      	add	sp, #12
 800570a:	ecbd 8b02 	vpop	{d8}
 800570e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005712:	4c1a      	ldr	r4, [pc, #104]	@ (800577c <cal_interpolate+0x178>)
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 8005714:	1d2b      	adds	r3, r5, #4
 8005716:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 800571a:	352c      	adds	r5, #44	@ 0x2c
    data[eterm][0] = cal_data[eterm][idx][0];
 800571c:	f8d4 20d0 	ldr.w	r2, [r4, #208]	@ 0xd0
 8005720:	f843 2c04 	str.w	r2, [r3, #-4]
    data[eterm][1] = cal_data[eterm][idx][1];
 8005724:	f8d4 20d4 	ldr.w	r2, [r4, #212]	@ 0xd4
 8005728:	f843 2b08 	str.w	r2, [r3], #8
  for (eterm = 0; eterm < CAL_TYPE_COUNT; eterm++)
 800572c:	429d      	cmp	r5, r3
 800572e:	f604 4488 	addw	r4, r4, #3208	@ 0xc88
 8005732:	d1f3      	bne.n	800571c <cal_interpolate+0x118>
}
 8005734:	b003      	add	sp, #12
 8005736:	ecbd 8b02 	vpop	{d8}
 800573a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    idx = 0;
 800573e:	2600      	movs	r6, #0
 8005740:	e7e8      	b.n	8005714 <cal_interpolate+0x110>
    idx = src_points;
 8005742:	464e      	mov	r6, r9
    goto copy_point;
 8005744:	e7e6      	b.n	8005714 <cal_interpolate+0x110>
  float k = (delta == 0) ? 0.0f : (float)(f - src_f0) / delta;
 8005746:	ed9f 8a0e 	vldr	s16, [pc, #56]	@ 8005780 <cal_interpolate+0x17c>
 800574a:	e7b1      	b.n	80056b0 <cal_interpolate+0xac>
    if (hf0 == si5351_get_harmonic_lvl(f))
 800574c:	4638      	mov	r0, r7
 800574e:	f004 fbbd 	bl	8009ecc <si5351_get_harmonic_lvl>
 8005752:	4540      	cmp	r0, r8
 8005754:	d008      	beq.n	8005768 <cal_interpolate+0x164>
      if (idx >= src_points)
 8005756:	45b1      	cmp	r9, r6
 8005758:	dddc      	ble.n	8005714 <cal_interpolate+0x110>
      k -= 1.0f;
 800575a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
    data[eterm][0] = cal_data[eterm][idx][0] + k * (cal_data[eterm][idx + 1][0] - cal_data[eterm][idx][0]);
 800575e:	1cb3      	adds	r3, r6, #2
      k -= 1.0f;
 8005760:	ee38 8a67 	vsub.f32	s16, s16, s15
      idx++;
 8005764:	3601      	adds	r6, #1
 8005766:	e7ad      	b.n	80056c4 <cal_interpolate+0xc0>
      if (idx < 1)
 8005768:	2e00      	cmp	r6, #0
 800576a:	ddd3      	ble.n	8005714 <cal_interpolate+0x110>
      k += 1.0f;
 800576c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8005770:	4633      	mov	r3, r6
 8005772:	ee38 8a27 	vadd.f32	s16, s16, s15
      idx--;
 8005776:	3e01      	subs	r6, #1
 8005778:	e7a4      	b.n	80056c4 <cal_interpolate+0xc0>
 800577a:	bf00      	nop
 800577c:	20000aa8 	.word	0x20000aa8
 8005780:	00000000 	.word	0x00000000

08005784 <cmd_refresh>:
}

VNA_SHELL_FUNCTION(cmd_refresh)
{
  static const char cmd_enable_list[] = "on|off";
  if (argc != 1)
 8005784:	2801      	cmp	r0, #1
 8005786:	d000      	beq.n	800578a <cmd_refresh+0x6>
 8005788:	4770      	bx	lr
{
 800578a:	b508      	push	{r3, lr}
 800578c:	460b      	mov	r3, r1
    return;
  int enable = get_str_index(argv[0], cmd_enable_list);
 800578e:	490e      	ldr	r1, [pc, #56]	@ (80057c8 <cmd_refresh+0x44>)
 8005790:	6818      	ldr	r0, [r3, #0]
 8005792:	f004 f98b 	bl	8009aac <get_str_index>
  if (enable == 0)
 8005796:	b160      	cbz	r0, 80057b2 <cmd_refresh+0x2e>
    sweep_mode |= SWEEP_REMOTE;
  else if (enable == 1)
 8005798:	2801      	cmp	r0, #1
 800579a:	d104      	bne.n	80057a6 <cmd_refresh+0x22>
    sweep_mode &= ~SWEEP_REMOTE;
 800579c:	4a0b      	ldr	r2, [pc, #44]	@ (80057cc <cmd_refresh+0x48>)
 800579e:	7813      	ldrb	r3, [r2, #0]
 80057a0:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80057a4:	7013      	strb	r3, [r2, #0]
  // redraw all on screen
  request_to_redraw(REDRAW_FREQUENCY | REDRAW_CAL_STATUS | REDRAW_AREA | REDRAW_BATTERY);
}
 80057a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_FREQUENCY | REDRAW_CAL_STATUS | REDRAW_AREA | REDRAW_BATTERY);
 80057aa:	f44f 708d 	mov.w	r0, #282	@ 0x11a
 80057ae:	f006 bfdb 	b.w	800c768 <request_to_redraw>
    sweep_mode |= SWEEP_REMOTE;
 80057b2:	4a06      	ldr	r2, [pc, #24]	@ (80057cc <cmd_refresh+0x48>)
 80057b4:	7813      	ldrb	r3, [r2, #0]
 80057b6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80057ba:	7013      	strb	r3, [r2, #0]
}
 80057bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_FREQUENCY | REDRAW_CAL_STATUS | REDRAW_AREA | REDRAW_BATTERY);
 80057c0:	f44f 708d 	mov.w	r0, #282	@ 0x11a
 80057c4:	f006 bfd0 	b.w	800c768 <request_to_redraw>
 80057c8:	08015c38 	.word	0x08015c38
 80057cc:	200003c4 	.word	0x200003c4

080057d0 <cmd_usart>:
  if (argc == 0 || argc > 2 || VNA_MODE(VNA_MODE_CONNECTION))
 80057d0:	2800      	cmp	r0, #0
 80057d2:	d02d      	beq.n	8005830 <cmd_usart+0x60>
 80057d4:	2802      	cmp	r0, #2
 80057d6:	dc2b      	bgt.n	8005830 <cmd_usart+0x60>
 80057d8:	4b1d      	ldr	r3, [pc, #116]	@ (8005850 <cmd_usart+0x80>)
 80057da:	8a9b      	ldrh	r3, [r3, #20]
 80057dc:	075b      	lsls	r3, r3, #29
 80057de:	d427      	bmi.n	8005830 <cmd_usart+0x60>
{
 80057e0:	b530      	push	{r4, r5, lr}
  if (argc == 2)
 80057e2:	2802      	cmp	r0, #2
{
 80057e4:	b093      	sub	sp, #76	@ 0x4c
  if (argc == 2)
 80057e6:	d024      	beq.n	8005832 <cmd_usart+0x62>
  uint32_t time = MS2ST(200); // 200ms wait answer by default
 80057e8:	f644 6420 	movw	r4, #20000	@ 0x4e20
  sdWriteTimeout(&SD1, (uint8_t *)argv[0], strlen(argv[0]), time);
 80057ec:	680d      	ldr	r5, [r1, #0]
 80057ee:	4628      	mov	r0, r5
 80057f0:	f7fb f8a6 	bl	8000940 <strlen>
 80057f4:	4629      	mov	r1, r5
 80057f6:	4602      	mov	r2, r0
 80057f8:	4623      	mov	r3, r4
 80057fa:	4816      	ldr	r0, [pc, #88]	@ (8005854 <cmd_usart+0x84>)
    streamWrite(&SDU1, buffer, size);
 80057fc:	4d16      	ldr	r5, [pc, #88]	@ (8005858 <cmd_usart+0x88>)
  sdWriteTimeout(&SD1, (uint8_t *)argv[0], strlen(argv[0]), time);
 80057fe:	f7fb fe51 	bl	80014a4 <oqWriteTimeout>
  sdWriteTimeout(&SD1, (uint8_t *)VNA_SHELL_NEWLINE_STR, sizeof(VNA_SHELL_NEWLINE_STR) - 1, time);
 8005802:	4916      	ldr	r1, [pc, #88]	@ (800585c <cmd_usart+0x8c>)
 8005804:	4813      	ldr	r0, [pc, #76]	@ (8005854 <cmd_usart+0x84>)
 8005806:	4623      	mov	r3, r4
 8005808:	2202      	movs	r2, #2
 800580a:	f7fb fe4b 	bl	80014a4 <oqWriteTimeout>
  while ((size = sdReadTimeout(&SD1, buffer, sizeof(buffer), time)))
 800580e:	e002      	b.n	8005816 <cmd_usart+0x46>
    streamWrite(&SDU1, buffer, size);
 8005810:	682b      	ldr	r3, [r5, #0]
 8005812:	681b      	ldr	r3, [r3, #0]
 8005814:	4798      	blx	r3
  while ((size = sdReadTimeout(&SD1, buffer, sizeof(buffer), time)))
 8005816:	2240      	movs	r2, #64	@ 0x40
 8005818:	a902      	add	r1, sp, #8
 800581a:	4811      	ldr	r0, [pc, #68]	@ (8005860 <cmd_usart+0x90>)
 800581c:	4623      	mov	r3, r4
 800581e:	f7fb fdb7 	bl	8001390 <iqReadTimeout>
 8005822:	4602      	mov	r2, r0
    streamWrite(&SDU1, buffer, size);
 8005824:	a902      	add	r1, sp, #8
 8005826:	480c      	ldr	r0, [pc, #48]	@ (8005858 <cmd_usart+0x88>)
  while ((size = sdReadTimeout(&SD1, buffer, sizeof(buffer), time)))
 8005828:	2a00      	cmp	r2, #0
 800582a:	d1f1      	bne.n	8005810 <cmd_usart+0x40>
}
 800582c:	b013      	add	sp, #76	@ 0x4c
 800582e:	bd30      	pop	{r4, r5, pc}
 8005830:	4770      	bx	lr
    time = MS2ST(my_atoui(argv[1]));
 8005832:	6848      	ldr	r0, [r1, #4]
 8005834:	9101      	str	r1, [sp, #4]
 8005836:	f004 f879 	bl	800992c <my_atoui>
 800583a:	4c0a      	ldr	r4, [pc, #40]	@ (8005864 <cmd_usart+0x94>)
 800583c:	4b0a      	ldr	r3, [pc, #40]	@ (8005868 <cmd_usart+0x98>)
 800583e:	9901      	ldr	r1, [sp, #4]
 8005840:	fb00 f404 	mul.w	r4, r0, r4
 8005844:	f204 34e7 	addw	r4, r4, #999	@ 0x3e7
 8005848:	fba3 3404 	umull	r3, r4, r3, r4
 800584c:	09a4      	lsrs	r4, r4, #6
 800584e:	e7cd      	b.n	80057ec <cmd_usart+0x1c>
 8005850:	20000318 	.word	0x20000318
 8005854:	2000059c 	.word	0x2000059c
 8005858:	200007b0 	.word	0x200007b0
 800585c:	08013860 	.word	0x08013860
 8005860:	2000057c 	.word	0x2000057c
 8005864:	000186a0 	.word	0x000186a0
 8005868:	10624dd3 	.word	0x10624dd3

0800586c <cmd_release>:
}

VNA_SHELL_FUNCTION(cmd_release)
{
  int16_t x = -1, y = -1;
  if (argc == 2)
 800586c:	2802      	cmp	r0, #2
{
 800586e:	b538      	push	{r3, r4, r5, lr}
  if (argc == 2)
 8005870:	d008      	beq.n	8005884 <cmd_release+0x18>
  int16_t x = -1, y = -1;
 8005872:	f04f 32ff 	mov.w	r2, #4294967295
 8005876:	4615      	mov	r5, r2
  {
    x = my_atoi(argv[0]);
    y = my_atoi(argv[1]);
  }
  remote_touch_set(REMOTE_RELEASE, x, y);
 8005878:	4629      	mov	r1, r5
 800587a:	2002      	movs	r0, #2
}
 800587c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  remote_touch_set(REMOTE_RELEASE, x, y);
 8005880:	f00b b85e 	b.w	8010940 <remote_touch_set>
    x = my_atoi(argv[0]);
 8005884:	6808      	ldr	r0, [r1, #0]
 8005886:	460c      	mov	r4, r1
 8005888:	f004 f836 	bl	80098f8 <my_atoi>
 800588c:	b205      	sxth	r5, r0
    y = my_atoi(argv[1]);
 800588e:	6860      	ldr	r0, [r4, #4]
 8005890:	f004 f832 	bl	80098f8 <my_atoi>
  remote_touch_set(REMOTE_RELEASE, x, y);
 8005894:	4629      	mov	r1, r5
    y = my_atoi(argv[1]);
 8005896:	b202      	sxth	r2, r0
}
 8005898:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  remote_touch_set(REMOTE_RELEASE, x, y);
 800589c:	2002      	movs	r0, #2
 800589e:	f00b b84f 	b.w	8010940 <remote_touch_set>
 80058a2:	bf00      	nop

080058a4 <cmd_touch>:
  if (argc != 2)
 80058a4:	2802      	cmp	r0, #2
 80058a6:	d000      	beq.n	80058aa <cmd_touch+0x6>
 80058a8:	4770      	bx	lr
{
 80058aa:	b538      	push	{r3, r4, r5, lr}
  remote_touch_set(REMOTE_PRESS, my_atoi(argv[0]), my_atoi(argv[1]));
 80058ac:	6808      	ldr	r0, [r1, #0]
 80058ae:	460c      	mov	r4, r1
 80058b0:	f004 f822 	bl	80098f8 <my_atoi>
 80058b4:	4605      	mov	r5, r0
 80058b6:	6860      	ldr	r0, [r4, #4]
 80058b8:	f004 f81e 	bl	80098f8 <my_atoi>
 80058bc:	b229      	sxth	r1, r5
 80058be:	b202      	sxth	r2, r0
}
 80058c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  remote_touch_set(REMOTE_PRESS, my_atoi(argv[0]), my_atoi(argv[1]));
 80058c4:	2001      	movs	r0, #1
 80058c6:	f00b b83b 	b.w	8010940 <remote_touch_set>
 80058ca:	bf00      	nop

080058cc <cmd_touchtest>:
  ui_touch_draw_test();
 80058cc:	f00a bc8a 	b.w	80101e4 <ui_touch_draw_test>

080058d0 <get_sweep_mask>:
{
 80058d0:	b508      	push	{r3, lr}
  ch_mask |= plot_get_measure_channels();
 80058d2:	f006 ff31 	bl	800c738 <plot_get_measure_channels>
  if (cal_status & CALSTAT_APPLY)
 80058d6:	4b14      	ldr	r3, [pc, #80]	@ (8005928 <get_sweep_mask+0x58>)
 80058d8:	8c9a      	ldrh	r2, [r3, #36]	@ 0x24
  if (electrical_delayS11)
 80058da:	edd3 7a27 	vldr	s15, [r3, #156]	@ 0x9c
  if (cal_status & CALSTAT_APPLY)
 80058de:	05d1      	lsls	r1, r2, #23
  ch_mask |= plot_get_measure_channels();
 80058e0:	bf54      	ite	pl
 80058e2:	f040 0003 	orrpl.w	r0, r0, #3
    ch_mask |= SWEEP_APPLY_CALIBRATION;
 80058e6:	f040 0023 	orrmi.w	r0, r0, #35	@ 0x23
  if (electrical_delayS11)
 80058ea:	eef5 7a40 	vcmp.f32	s15, #0.0
  if (electrical_delayS21)
 80058ee:	edd3 7a28 	vldr	s15, [r3, #160]	@ 0xa0
    ch_mask |= SWEEP_APPLY_CALIBRATION;
 80058f2:	b280      	uxth	r0, r0
  if (cal_status & CALSTAT_INTERPOLATED)
 80058f4:	0592      	lsls	r2, r2, #22
    ch_mask |= SWEEP_USE_INTERPOLATION;
 80058f6:	bf48      	it	mi
 80058f8:	f040 0040 	orrmi.w	r0, r0, #64	@ 0x40
  if (electrical_delayS11)
 80058fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (electrical_delayS21)
 8005900:	eef5 7a40 	vcmp.f32	s15, #0.0
  if (s21_offset)
 8005904:	edd3 7a2a 	vldr	s15, [r3, #168]	@ 0xa8
    ch_mask |= SWEEP_APPLY_EDELAY_S11;
 8005908:	bf18      	it	ne
 800590a:	f040 0004 	orrne.w	r0, r0, #4
  if (electrical_delayS21)
 800590e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (s21_offset)
 8005912:	eef5 7a40 	vcmp.f32	s15, #0.0
    ch_mask |= SWEEP_APPLY_EDELAY_S21;
 8005916:	bf18      	it	ne
 8005918:	f040 0008 	orrne.w	r0, r0, #8
  if (s21_offset)
 800591c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ch_mask |= SWEEP_APPLY_S21_OFFSET;
 8005920:	bf18      	it	ne
 8005922:	f040 0010 	orrne.w	r0, r0, #16
}
 8005926:	bd08      	pop	{r3, pc}
 8005928:	20000aa8 	.word	0x20000aa8

0800592c <eterm_set.constprop.0>:
  for (i = 0; i < sweep_points; i++)
 800592c:	4b0a      	ldr	r3, [pc, #40]	@ (8005958 <eterm_set.constprop.0+0x2c>)
 800592e:	8b5a      	ldrh	r2, [r3, #26]
 8005930:	b18a      	cbz	r2, 8005956 <eterm_set.constprop.0+0x2a>
 8005932:	f240 1191 	movw	r1, #401	@ 0x191
 8005936:	fb01 2100 	mla	r1, r1, r0, r2
 800593a:	f640 4c88 	movw	ip, #3208	@ 0xc88
 800593e:	fb0c 3000 	mla	r0, ip, r0, r3
    cal_data[term][i][1] = im;
 8005942:	2200      	movs	r2, #0
 8005944:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    cal_data[term][i][0] = re;
 8005948:	ed80 0a34 	vstr	s0, [r0, #208]	@ 0xd0
    cal_data[term][i][1] = im;
 800594c:	f8c0 20d4 	str.w	r2, [r0, #212]	@ 0xd4
  for (i = 0; i < sweep_points; i++)
 8005950:	3008      	adds	r0, #8
 8005952:	4298      	cmp	r0, r3
 8005954:	d1f8      	bne.n	8005948 <eterm_set.constprop.0+0x1c>
}
 8005956:	4770      	bx	lr
 8005958:	20000aa8 	.word	0x20000aa8

0800595c <serial_shell_printf>:
{
 800595c:	b40f      	push	{r0, r1, r2, r3}
 800595e:	b500      	push	{lr}
 8005960:	b083      	sub	sp, #12
 8005962:	aa04      	add	r2, sp, #16
  formatted_bytes = chvprintf((BaseSequentialStream *)&SD1, fmt, ap);
 8005964:	4805      	ldr	r0, [pc, #20]	@ (800597c <serial_shell_printf+0x20>)
{
 8005966:	f852 1b04 	ldr.w	r1, [r2], #4
  va_start(ap, fmt);
 800596a:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf((BaseSequentialStream *)&SD1, fmt, ap);
 800596c:	f7fc fe56 	bl	800261c <chvprintf>
}
 8005970:	b003      	add	sp, #12
 8005972:	f85d eb04 	ldr.w	lr, [sp], #4
 8005976:	b004      	add	sp, #16
 8005978:	4770      	bx	lr
 800597a:	bf00      	nop
 800597c:	20000574 	.word	0x20000574

08005980 <mla_calc_q_after_sweep>:
{
 8005980:	b530      	push	{r4, r5, lr}
  if (mla_res_freq == 0)
 8005982:	4b22      	ldr	r3, [pc, #136]	@ (8005a0c <mla_calc_q_after_sweep+0x8c>)
{
 8005984:	ed2d 8b02 	vpush	{d8}
  if (mla_res_freq == 0)
 8005988:	681c      	ldr	r4, [r3, #0]
{
 800598a:	b085      	sub	sp, #20
  if (mla_res_freq == 0)
 800598c:	2c00      	cmp	r4, #0
 800598e:	d038      	beq.n	8005a02 <mla_calc_q_after_sweep+0x82>
  if (mla_bw_swr2 == 0)
 8005990:	4b1f      	ldr	r3, [pc, #124]	@ (8005a10 <mla_calc_q_after_sweep+0x90>)
 8005992:	681d      	ldr	r5, [r3, #0]
 8005994:	b355      	cbz	r5, 80059ec <mla_calc_q_after_sweep+0x6c>
  const float f0 = (float)mla_res_freq;
 8005996:	ee07 4a90 	vmov	s15, r4
 800599a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  const float bw = (float)mla_bw_swr2;
 800599e:	ee07 5a90 	vmov	s15, r5
 80059a2:	eef8 7a67 	vcvt.f32.u32	s15, s15
  const float bw_over_f0 = (bw / f0) * 100.0f;
 80059a6:	eddf 6a1b 	vldr	s13, [pc, #108]	@ 8005a14 <mla_calc_q_after_sweep+0x94>
 80059aa:	ee87 6a87 	vdiv.f32	s12, s15, s14
  const float q = f0 / bw;
 80059ae:	ee87 8a27 	vdiv.f32	s16, s14, s15
  MLA_UART_LOG("[MLA] Q@SWR2: f0=" VNA_FREQ_FMT_STR " Hz, BW(SWR<=2)=" VNA_FREQ_FMT_STR
 80059b2:	ee66 7a26 	vmul.f32	s15, s12, s13
 80059b6:	ee17 0a90 	vmov	r0, s15
 80059ba:	f7fa fdf1 	bl	80005a0 <__aeabi_f2d>
 80059be:	4602      	mov	r2, r0
 80059c0:	460b      	mov	r3, r1
 80059c2:	ee18 0a10 	vmov	r0, s16
 80059c6:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80059ca:	f7fa fde9 	bl	80005a0 <__aeabi_f2d>
 80059ce:	460b      	mov	r3, r1
 80059d0:	4602      	mov	r2, r0
 80059d2:	e9cd 2300 	strd	r2, r3, [sp]
 80059d6:	4621      	mov	r1, r4
 80059d8:	462a      	mov	r2, r5
 80059da:	480f      	ldr	r0, [pc, #60]	@ (8005a18 <mla_calc_q_after_sweep+0x98>)
 80059dc:	f7ff ffbe 	bl	800595c <serial_shell_printf>
}
 80059e0:	eeb0 0a48 	vmov.f32	s0, s16
 80059e4:	b005      	add	sp, #20
 80059e6:	ecbd 8b02 	vpop	{d8}
 80059ea:	bd30      	pop	{r4, r5, pc}
    MLA_UART_LOG("[MLA] Q@SWR2: n/a (BW(SWR<=2)=0)\r\n");
 80059ec:	480b      	ldr	r0, [pc, #44]	@ (8005a1c <mla_calc_q_after_sweep+0x9c>)
 80059ee:	f7ff ffb5 	bl	800595c <serial_shell_printf>
    return 0.0f;
 80059f2:	ed9f 8a0b 	vldr	s16, [pc, #44]	@ 8005a20 <mla_calc_q_after_sweep+0xa0>
}
 80059f6:	eeb0 0a48 	vmov.f32	s0, s16
 80059fa:	b005      	add	sp, #20
 80059fc:	ecbd 8b02 	vpop	{d8}
 8005a00:	bd30      	pop	{r4, r5, pc}
    MLA_UART_LOG("[MLA] Q@SWR2: n/a (resonance freq not set)\r\n");
 8005a02:	4808      	ldr	r0, [pc, #32]	@ (8005a24 <mla_calc_q_after_sweep+0xa4>)
 8005a04:	f7ff ffaa 	bl	800595c <serial_shell_printf>
    return 0.0f;
 8005a08:	e7f3      	b.n	80059f2 <mla_calc_q_after_sweep+0x72>
 8005a0a:	bf00      	nop
 8005a0c:	20006884 	.word	0x20006884
 8005a10:	20006870 	.word	0x20006870
 8005a14:	42c80000 	.word	0x42c80000
 8005a18:	08012998 	.word	0x08012998
 8005a1c:	08012974 	.word	0x08012974
 8005a20:	00000000 	.word	0x00000000
 8005a24:	08012944 	.word	0x08012944

08005a28 <mla_is_resonance_centered>:
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005a28:	4b0f      	ldr	r3, [pc, #60]	@ (8005a68 <mla_is_resonance_centered+0x40>)
      (mla_res_idx > EDGE_POINTS) &&
 8005a2a:	4a10      	ldr	r2, [pc, #64]	@ (8005a6c <mla_is_resonance_centered+0x44>)
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005a2c:	8b5b      	ldrh	r3, [r3, #26]
 8005a2e:	4910      	ldr	r1, [pc, #64]	@ (8005a70 <mla_is_resonance_centered+0x48>)
      (mla_res_idx > EDGE_POINTS) &&
 8005a30:	f9b2 2000 	ldrsh.w	r2, [r2]
{
 8005a34:	b510      	push	{r4, lr}
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005a36:	fba1 0103 	umull	r0, r1, r1, r3
      (mla_res_idx > EDGE_POINTS) &&
 8005a3a:	ebb2 0f91 	cmp.w	r2, r1, lsr #2
{
 8005a3e:	b082      	sub	sp, #8
  const int EDGE_POINTS = sweep_points / 5; // aggressive, safe
 8005a40:	ea4f 0091 	mov.w	r0, r1, lsr #2
      (mla_res_idx > EDGE_POINTS) &&
 8005a44:	dd0c      	ble.n	8005a60 <mla_is_resonance_centered+0x38>
      (mla_res_idx < (sweep_points - EDGE_POINTS));
 8005a46:	1a1c      	subs	r4, r3, r0
      (mla_res_idx > EDGE_POINTS) &&
 8005a48:	42a2      	cmp	r2, r4
 8005a4a:	bfac      	ite	ge
 8005a4c:	2400      	movge	r4, #0
 8005a4e:	2401      	movlt	r4, #1
 8005a50:	4621      	mov	r1, r4
  MLA_UART_LOG(
 8005a52:	9000      	str	r0, [sp, #0]
 8005a54:	4807      	ldr	r0, [pc, #28]	@ (8005a74 <mla_is_resonance_centered+0x4c>)
 8005a56:	f7ff ff81 	bl	800595c <serial_shell_printf>
}
 8005a5a:	4620      	mov	r0, r4
 8005a5c:	b002      	add	sp, #8
 8005a5e:	bd10      	pop	{r4, pc}
 8005a60:	2400      	movs	r4, #0
      (mla_res_idx > EDGE_POINTS) &&
 8005a62:	4621      	mov	r1, r4
 8005a64:	e7f5      	b.n	8005a52 <mla_is_resonance_centered+0x2a>
 8005a66:	bf00      	nop
 8005a68:	20000aa8 	.word	0x20000aa8
 8005a6c:	200003d4 	.word	0x200003d4
 8005a70:	cccccccd 	.word	0xcccccccd
 8005a74:	080129dc 	.word	0x080129dc

08005a78 <set_smooth_factor>:
  if (factor > 8)
 8005a78:	2808      	cmp	r0, #8
  smooth_factor = factor;
 8005a7a:	4a04      	ldr	r2, [pc, #16]	@ (8005a8c <set_smooth_factor+0x14>)
  if (factor > 8)
 8005a7c:	4603      	mov	r3, r0
 8005a7e:	bf28      	it	cs
 8005a80:	2308      	movcs	r3, #8
  request_to_redraw(REDRAW_CAL_STATUS);
 8005a82:	2010      	movs	r0, #16
  smooth_factor = factor;
 8005a84:	7013      	strb	r3, [r2, #0]
  request_to_redraw(REDRAW_CAL_STATUS);
 8005a86:	f006 be6f 	b.w	800c768 <request_to_redraw>
 8005a8a:	bf00      	nop
 8005a8c:	20004f50 	.word	0x20004f50

08005a90 <get_smooth_factor>:
  return smooth_factor;
 8005a90:	4b01      	ldr	r3, [pc, #4]	@ (8005a98 <get_smooth_factor+0x8>)
}
 8005a92:	7818      	ldrb	r0, [r3, #0]
 8005a94:	4770      	bx	lr
 8005a96:	bf00      	nop
 8005a98:	20004f50 	.word	0x20004f50

08005a9c <drawBarGraph>:
  if (value > SWR_MAX)
 8005a9c:	eeb0 7a0c 	vmov.f32	s14, #12	@ 0x40600000  3.5
 8005aa0:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8005aa4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (value < SWR_MIN)
 8005aa8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
  if (value > SWR_MAX)
 8005aac:	bf88      	it	hi
 8005aae:	eeb0 0a47 	vmovhi.f32	s0, s14
  if (value < SWR_MIN)
 8005ab2:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8005ab6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005aba:	bfb8      	it	lt
 8005abc:	eeb0 0a67 	vmovlt.f32	s0, s15
  float norm = (value - SWR_MIN) / (SWR_MAX - SWR_MIN);
 8005ac0:	ee30 0a67 	vsub.f32	s0, s0, s15
  int active = (int)(norm * BAR_SEGMENTS + 0.5f);
 8005ac4:	eeb3 7a00 	vmov.f32	s14, #48	@ 0x41800000  16.0
 8005ac8:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8005acc:	eee0 7a07 	vfma.f32	s15, s0, s14
{
 8005ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int active = (int)(norm * BAR_SEGMENTS + 0.5f);
 8005ad2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  if (doOnceOnly_In_Mode2 == true)
 8005ad6:	4b45      	ldr	r3, [pc, #276]	@ (8005bec <drawBarGraph+0x150>)
    prevActive = -1;
 8005ad8:	4f45      	ldr	r7, [pc, #276]	@ (8005bf0 <drawBarGraph+0x154>)
  if (doOnceOnly_In_Mode2 == true)
 8005ada:	781b      	ldrb	r3, [r3, #0]
  int active = (int)(norm * BAR_SEGMENTS + 0.5f);
 8005adc:	ee17 5a90 	vmov	r5, s15
  if (active > BAR_SEGMENTS)
 8005ae0:	2d28      	cmp	r5, #40	@ 0x28
 8005ae2:	462e      	mov	r6, r5
 8005ae4:	bfa8      	it	ge
 8005ae6:	2628      	movge	r6, #40	@ 0x28
{
 8005ae8:	ed2d 8b02 	vpush	{d8}
  if (active < 0)
 8005aec:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
  if (doOnceOnly_In_Mode2 == true)
 8005af0:	2b00      	cmp	r3, #0
 8005af2:	d05c      	beq.n	8005bae <drawBarGraph+0x112>
    prevActive = -1;
 8005af4:	f04f 33ff 	mov.w	r3, #4294967295
 8005af8:	603b      	str	r3, [r7, #0]
    lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8005afa:	2100      	movs	r1, #0
 8005afc:	4608      	mov	r0, r1
 8005afe:	f00b fadb 	bl	80110b8 <lcd_set_colors>
    lcd_fill(x0, y0, barWidth, BAR_HEIGHT_PX);
 8005b02:	232d      	movs	r3, #45	@ 0x2d
 8005b04:	f44f 72dc 	mov.w	r2, #440	@ 0x1b8
 8005b08:	21f0      	movs	r1, #240	@ 0xf0
 8005b0a:	2014      	movs	r0, #20
 8005b0c:	f00b f9ce 	bl	8010eac <lcd_fill>
    lcd_set_colors(LCD_BG_COLOR, LCD_GRID_COLOR);
 8005b10:	2102      	movs	r1, #2
 8005b12:	2000      	movs	r0, #0
 8005b14:	f00b fad0 	bl	80110b8 <lcd_set_colors>
    lcd_fill(x0 - 1, y0 - 1, barWidth + 2, 1);
 8005b18:	2301      	movs	r3, #1
 8005b1a:	f44f 72dd 	mov.w	r2, #442	@ 0x1ba
 8005b1e:	21ef      	movs	r1, #239	@ 0xef
 8005b20:	2013      	movs	r0, #19
 8005b22:	f00b f9c3 	bl	8010eac <lcd_fill>
    lcd_fill(x0 - 1, y0 + BAR_HEIGHT_PX, barWidth + 2, 1);
 8005b26:	2301      	movs	r3, #1
 8005b28:	f44f 72dd 	mov.w	r2, #442	@ 0x1ba
 8005b2c:	f240 111d 	movw	r1, #285	@ 0x11d
 8005b30:	2013      	movs	r0, #19
 8005b32:	f00b f9bb 	bl	8010eac <lcd_fill>
    lcd_fill(x0 - 1, y0 - 1, 1, BAR_HEIGHT_PX + 2);
 8005b36:	232f      	movs	r3, #47	@ 0x2f
 8005b38:	2201      	movs	r2, #1
 8005b3a:	21ef      	movs	r1, #239	@ 0xef
 8005b3c:	2013      	movs	r0, #19
 8005b3e:	f00b f9b5 	bl	8010eac <lcd_fill>
    prevActive = 0;
 8005b42:	2400      	movs	r4, #0
    lcd_fill(x0 + barWidth, y0 - 1, 1, BAR_HEIGHT_PX + 2);
 8005b44:	232f      	movs	r3, #47	@ 0x2f
 8005b46:	2201      	movs	r2, #1
 8005b48:	21ef      	movs	r1, #239	@ 0xef
 8005b4a:	f44f 70e6 	mov.w	r0, #460	@ 0x1cc
 8005b4e:	f00b f9ad 	bl	8010eac <lcd_fill>
  if (active > prevActive)
 8005b52:	42a5      	cmp	r5, r4
    prevActive = 0;
 8005b54:	603c      	str	r4, [r7, #0]
  if (active > prevActive)
 8005b56:	dd26      	ble.n	8005ba6 <drawBarGraph+0x10a>
    for (int i = prevActive; i < active; i++)
 8005b58:	250b      	movs	r5, #11
 8005b5a:	2314      	movs	r3, #20
      else if (segValue <= 3.0f)
 8005b5c:	eddf 8a25 	vldr	s17, [pc, #148]	@ 8005bf4 <drawBarGraph+0x158>
 8005b60:	fb14 3505 	smlabb	r5, r4, r5, r3
      if (segValue <= 1.5f)
 8005b64:	eeb2 8a00 	vmov.f32	s16, #32	@ 0x41000000  8.0
          ((float)(i + 1) / BAR_SEGMENTS) * (SWR_MAX - SWR_MIN);
 8005b68:	3401      	adds	r4, #1
 8005b6a:	ee07 4a90 	vmov	s15, r4
 8005b6e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        color = LCD_TRACE_3_COLOR; // green
 8005b72:	2108      	movs	r1, #8
      if (segValue <= 1.5f)
 8005b74:	eef4 7ac8 	vcmpe.f32	s15, s16
 8005b78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        color = LCD_TRACE_5_COLOR; // red
 8005b7c:	eef4 7ae8 	vcmpe.f32	s15, s17
      if (segValue <= 1.5f)
 8005b80:	d904      	bls.n	8005b8c <drawBarGraph+0xf0>
        color = LCD_TRACE_5_COLOR; // red
 8005b82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005b86:	bf94      	ite	ls
 8005b88:	2106      	movls	r1, #6
 8005b8a:	210a      	movhi	r1, #10
      lcd_set_colors(LCD_BG_COLOR, color);
 8005b8c:	2000      	movs	r0, #0
 8005b8e:	f00b fa93 	bl	80110b8 <lcd_set_colors>
      lcd_fill(x, y0, segmentWidth, BAR_HEIGHT_PX);
 8005b92:	4628      	mov	r0, r5
 8005b94:	232d      	movs	r3, #45	@ 0x2d
 8005b96:	2209      	movs	r2, #9
 8005b98:	21f0      	movs	r1, #240	@ 0xf0
 8005b9a:	f00b f987 	bl	8010eac <lcd_fill>
    for (int i = prevActive; i < active; i++)
 8005b9e:	42b4      	cmp	r4, r6
 8005ba0:	f105 050b 	add.w	r5, r5, #11
 8005ba4:	dbe0      	blt.n	8005b68 <drawBarGraph+0xcc>
}
 8005ba6:	ecbd 8b02 	vpop	{d8}
  prevActive = active;
 8005baa:	603e      	str	r6, [r7, #0]
}
 8005bac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (prevActive < 0)
 8005bae:	683c      	ldr	r4, [r7, #0]
 8005bb0:	2c00      	cmp	r4, #0
 8005bb2:	dba2      	blt.n	8005afa <drawBarGraph+0x5e>
  if (active > prevActive)
 8005bb4:	42b4      	cmp	r4, r6
 8005bb6:	dbcf      	blt.n	8005b58 <drawBarGraph+0xbc>
  else if (active < prevActive)
 8005bb8:	ddf5      	ble.n	8005ba6 <drawBarGraph+0x10a>
 8005bba:	240b      	movs	r4, #11
 8005bbc:	2314      	movs	r3, #20
 8005bbe:	fb16 3404 	smlabb	r4, r6, r4, r3
    for (int i = active; i < prevActive; i++)
 8005bc2:	4635      	mov	r5, r6
      lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8005bc4:	2100      	movs	r1, #0
 8005bc6:	4608      	mov	r0, r1
 8005bc8:	f00b fa76 	bl	80110b8 <lcd_set_colors>
      lcd_fill(x, y0, segmentWidth, BAR_HEIGHT_PX);
 8005bcc:	232d      	movs	r3, #45	@ 0x2d
 8005bce:	4620      	mov	r0, r4
 8005bd0:	2209      	movs	r2, #9
 8005bd2:	21f0      	movs	r1, #240	@ 0xf0
 8005bd4:	f00b f96a 	bl	8010eac <lcd_fill>
    for (int i = active; i < prevActive; i++)
 8005bd8:	683b      	ldr	r3, [r7, #0]
 8005bda:	3501      	adds	r5, #1
 8005bdc:	42ab      	cmp	r3, r5
 8005bde:	f104 040b 	add.w	r4, r4, #11
 8005be2:	dcef      	bgt.n	8005bc4 <drawBarGraph+0x128>
}
 8005be4:	ecbd 8b02 	vpop	{d8}
  prevActive = active;
 8005be8:	603e      	str	r6, [r7, #0]
}
 8005bea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005bec:	200068f8 	.word	0x200068f8
 8005bf0:	20000310 	.word	0x20000310
 8005bf4:	42000000 	.word	0x42000000

08005bf8 <displaySWR>:
{
 8005bf8:	b570      	push	{r4, r5, r6, lr}
  if (doOnceOnly_In_Mode2)
 8005bfa:	4b71      	ldr	r3, [pc, #452]	@ (8005dc0 <displaySWR+0x1c8>)
{
 8005bfc:	ed2d 8b02 	vpush	{d8}
  if (doOnceOnly_In_Mode2)
 8005c00:	781b      	ldrb	r3, [r3, #0]
{
 8005c02:	b082      	sub	sp, #8
  if (doOnceOnly_In_Mode2)
 8005c04:	b113      	cbz	r3, 8005c0c <displaySWR+0x14>
    label_drawn = 0;
 8005c06:	4b6f      	ldr	r3, [pc, #444]	@ (8005dc4 <displaySWR+0x1cc>)
 8005c08:	2200      	movs	r2, #0
 8005c0a:	601a      	str	r2, [r3, #0]
  if (t0 == 0)
 8005c0c:	4a6e      	ldr	r2, [pc, #440]	@ (8005dc8 <displaySWR+0x1d0>)
  return (systime_t)STM32_ST_TIM->CNT;
 8005c0e:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8005c12:	6813      	ldr	r3, [r2, #0]
 8005c14:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8005c16:	2b00      	cmp	r3, #0
 8005c18:	d07e      	beq.n	8005d18 <displaySWR+0x120>
  acc += swr;
 8005c1a:	4d6c      	ldr	r5, [pc, #432]	@ (8005dcc <displaySWR+0x1d4>)
  if (n != 0xFFFF)
 8005c1c:	4c6c      	ldr	r4, [pc, #432]	@ (8005dd0 <displaySWR+0x1d8>)
  acc += swr;
 8005c1e:	edd5 7a00 	vldr	s15, [r5]
  if (n != 0xFFFF)
 8005c22:	8820      	ldrh	r0, [r4, #0]
  acc += swr;
 8005c24:	ee30 0a27 	vadd.f32	s0, s0, s15
  if (n != 0xFFFF)
 8005c28:	f64f 76ff 	movw	r6, #65535	@ 0xffff
 8005c2c:	42b0      	cmp	r0, r6
  if ((systime_t)(now - t0) < (systime_t)250)
 8005c2e:	eba1 0303 	sub.w	r3, r1, r3
  acc += swr;
 8005c32:	ed85 0a00 	vstr	s0, [r5]
  if (n != 0xFFFF)
 8005c36:	d001      	beq.n	8005c3c <displaySWR+0x44>
    n++;
 8005c38:	3001      	adds	r0, #1
 8005c3a:	8020      	strh	r0, [r4, #0]
  if ((systime_t)(now - t0) < (systime_t)250)
 8005c3c:	2bf9      	cmp	r3, #249	@ 0xf9
 8005c3e:	d967      	bls.n	8005d10 <displaySWR+0x118>
  float avg = (n ? (acc / (float)n) : swr);
 8005c40:	8823      	ldrh	r3, [r4, #0]
  if (!label_drawn)
 8005c42:	4e60      	ldr	r6, [pc, #384]	@ (8005dc4 <displaySWR+0x1cc>)
  t0 = now;
 8005c44:	6011      	str	r1, [r2, #0]
  float avg = (n ? (acc / (float)n) : swr);
 8005c46:	ee07 3a90 	vmov	s15, r3
  if (!label_drawn)
 8005c4a:	6830      	ldr	r0, [r6, #0]
  float avg = (n ? (acc / (float)n) : swr);
 8005c4c:	eef8 7a67 	vcvt.f32.u32	s15, s15
  acc = 0.0f;
 8005c50:	2300      	movs	r3, #0
  n = 0;
 8005c52:	2200      	movs	r2, #0
  float avg = (n ? (acc / (float)n) : swr);
 8005c54:	ee80 8a27 	vdiv.f32	s16, s0, s15
  n = 0;
 8005c58:	8022      	strh	r2, [r4, #0]
  acc = 0.0f;
 8005c5a:	602b      	str	r3, [r5, #0]
  if (!label_drawn)
 8005c5c:	2800      	cmp	r0, #0
 8005c5e:	f000 8090 	beq.w	8005d82 <displaySWR+0x18a>
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 8005c62:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8005c66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c6a:	d969      	bls.n	8005d40 <displaySWR+0x148>
 8005c6c:	eddf 7a59 	vldr	s15, [pc, #356]	@ 8005dd4 <displaySWR+0x1dc>
 8005c70:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8005c74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c78:	dc62      	bgt.n	8005d40 <displaySWR+0x148>
  else if (avg <= 1.5f)
 8005c7a:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 8005c7e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8005c82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c86:	f240 8094 	bls.w	8005db2 <displaySWR+0x1ba>
  else if (avg <= 3.0f)
 8005c8a:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
    color = LCD_TRACE_5_COLOR; // red
 8005c8e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8005c92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8005c96:	bf94      	ite	ls
 8005c98:	2506      	movls	r5, #6
 8005c9a:	250a      	movhi	r5, #10
  int swr_int = overflow ? -9999 : (int)(avg * 10.0f + 0.5f);
 8005c9c:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8005ca0:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8005ca4:	eee8 7a07 	vfma.f32	s15, s16, s14
    if ((swr_int == last_swr_int) && (color == last_color))
 8005ca8:	4b4b      	ldr	r3, [pc, #300]	@ (8005dd8 <displaySWR+0x1e0>)
 8005caa:	681a      	ldr	r2, [r3, #0]
  int swr_int = overflow ? -9999 : (int)(avg * 10.0f + 0.5f);
 8005cac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8005cb0:	ee17 4a90 	vmov	r4, s15
    if ((swr_int == last_swr_int) && (color == last_color))
 8005cb4:	42a2      	cmp	r2, r4
 8005cb6:	4a49      	ldr	r2, [pc, #292]	@ (8005ddc <displaySWR+0x1e4>)
 8005cb8:	d07d      	beq.n	8005db6 <displaySWR+0x1be>
  lcd_set_background(LCD_BG_COLOR);
 8005cba:	2000      	movs	r0, #0
  last_swr_int = swr_int;
 8005cbc:	601c      	str	r4, [r3, #0]
  last_color = color;
 8005cbe:	8015      	strh	r5, [r2, #0]
  lcd_set_background(LCD_BG_COLOR);
 8005cc0:	f00b f9ee 	bl	80110a0 <lcd_set_background>
  lcd_fill(250, (LCD_HEIGHT / 2) - 30, 140, 50);
 8005cc4:	2332      	movs	r3, #50	@ 0x32
 8005cc6:	228c      	movs	r2, #140	@ 0x8c
 8005cc8:	2182      	movs	r1, #130	@ 0x82
 8005cca:	20fa      	movs	r0, #250	@ 0xfa
 8005ccc:	f00b f8ee 	bl	8010eac <lcd_fill>
  lcd_set_foreground(color);
 8005cd0:	4628      	mov	r0, r5
 8005cd2:	f00b f9d9 	bl	8011088 <lcd_set_foreground>
  int swr_whole = swr_int / 10; /* 0..9 */
 8005cd6:	4a42      	ldr	r2, [pc, #264]	@ (8005de0 <displaySWR+0x1e8>)
 8005cd8:	fb82 3204 	smull	r3, r2, r2, r4
 8005cdc:	17e3      	asrs	r3, r4, #31
 8005cde:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
  int swr_frac = swr_int % 10;  /* 0..9 */
 8005ce2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
  buf[1] = '.';
 8005ce6:	212e      	movs	r1, #46	@ 0x2e
  int swr_frac = swr_int % 10;  /* 0..9 */
 8005ce8:	eba4 0442 	sub.w	r4, r4, r2, lsl #1
  buf[0] = '0' + swr_whole;
 8005cec:	f103 0230 	add.w	r2, r3, #48	@ 0x30
  buf[2] = '0' + swr_frac;
 8005cf0:	3430      	adds	r4, #48	@ 0x30
  buf[3] = 0;
 8005cf2:	2500      	movs	r5, #0
  buf[0] = '0' + swr_whole;
 8005cf4:	f88d 2004 	strb.w	r2, [sp, #4]
  buf[1] = '.';
 8005cf8:	f88d 1005 	strb.w	r1, [sp, #5]
  lcd_drawstring_size(buf, 240, (LCD_HEIGHT / 2) - 20, 3);
 8005cfc:	2303      	movs	r3, #3
 8005cfe:	228c      	movs	r2, #140	@ 0x8c
 8005d00:	21f0      	movs	r1, #240	@ 0xf0
 8005d02:	a801      	add	r0, sp, #4
  buf[2] = '0' + swr_frac;
 8005d04:	f88d 4006 	strb.w	r4, [sp, #6]
  buf[3] = 0;
 8005d08:	f88d 5007 	strb.w	r5, [sp, #7]
  lcd_drawstring_size(buf, 240, (LCD_HEIGHT / 2) - 20, 3);
 8005d0c:	f00b fb82 	bl	8011414 <lcd_drawstring_size>
}
 8005d10:	b002      	add	sp, #8
 8005d12:	ecbd 8b02 	vpop	{d8}
 8005d16:	bd70      	pop	{r4, r5, r6, pc}
  acc += swr;
 8005d18:	482c      	ldr	r0, [pc, #176]	@ (8005dcc <displaySWR+0x1d4>)
  if (n != 0xFFFF)
 8005d1a:	4c2d      	ldr	r4, [pc, #180]	@ (8005dd0 <displaySWR+0x1d8>)
  acc += swr;
 8005d1c:	edd0 7a00 	vldr	s15, [r0]
  if (n != 0xFFFF)
 8005d20:	8823      	ldrh	r3, [r4, #0]
    t0 = now;
 8005d22:	6011      	str	r1, [r2, #0]
  acc += swr;
 8005d24:	ee77 7a80 	vadd.f32	s15, s15, s0
  if (n != 0xFFFF)
 8005d28:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8005d2c:	4293      	cmp	r3, r2
  acc += swr;
 8005d2e:	edc0 7a00 	vstr	s15, [r0]
  if (n != 0xFFFF)
 8005d32:	d0ed      	beq.n	8005d10 <displaySWR+0x118>
    n++;
 8005d34:	3301      	adds	r3, #1
 8005d36:	8023      	strh	r3, [r4, #0]
}
 8005d38:	b002      	add	sp, #8
 8005d3a:	ecbd 8b02 	vpop	{d8}
 8005d3e:	bd70      	pop	{r4, r5, r6, pc}
    if ((last_swr_int == -9999) && (last_color == color))
 8005d40:	4b25      	ldr	r3, [pc, #148]	@ (8005dd8 <displaySWR+0x1e0>)
 8005d42:	4a28      	ldr	r2, [pc, #160]	@ (8005de4 <displaySWR+0x1ec>)
 8005d44:	6819      	ldr	r1, [r3, #0]
 8005d46:	4291      	cmp	r1, r2
 8005d48:	4a24      	ldr	r2, [pc, #144]	@ (8005ddc <displaySWR+0x1e4>)
 8005d4a:	d02e      	beq.n	8005daa <displaySWR+0x1b2>
  last_swr_int = swr_int;
 8005d4c:	4925      	ldr	r1, [pc, #148]	@ (8005de4 <displaySWR+0x1ec>)
 8005d4e:	6019      	str	r1, [r3, #0]
  last_color = color;
 8005d50:	240a      	movs	r4, #10
  lcd_set_background(LCD_BG_COLOR);
 8005d52:	2000      	movs	r0, #0
  last_color = color;
 8005d54:	8014      	strh	r4, [r2, #0]
  lcd_set_background(LCD_BG_COLOR);
 8005d56:	f00b f9a3 	bl	80110a0 <lcd_set_background>
  lcd_fill(250, (LCD_HEIGHT / 2) - 30, 140, 50);
 8005d5a:	2332      	movs	r3, #50	@ 0x32
 8005d5c:	228c      	movs	r2, #140	@ 0x8c
 8005d5e:	2182      	movs	r1, #130	@ 0x82
 8005d60:	20fa      	movs	r0, #250	@ 0xfa
 8005d62:	f00b f8a3 	bl	8010eac <lcd_fill>
  lcd_set_foreground(color);
 8005d66:	4620      	mov	r0, r4
 8005d68:	f00b f98e 	bl	8011088 <lcd_set_foreground>
    lcd_drawstring_size("!!!", 240, (LCD_HEIGHT / 2) - 20, 3);
 8005d6c:	481e      	ldr	r0, [pc, #120]	@ (8005de8 <displaySWR+0x1f0>)
 8005d6e:	2303      	movs	r3, #3
 8005d70:	228c      	movs	r2, #140	@ 0x8c
 8005d72:	21f0      	movs	r1, #240	@ 0xf0
}
 8005d74:	b002      	add	sp, #8
 8005d76:	ecbd 8b02 	vpop	{d8}
 8005d7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    lcd_drawstring_size("!!!", 240, (LCD_HEIGHT / 2) - 20, 3);
 8005d7e:	f00b bb49 	b.w	8011414 <lcd_drawstring_size>
    lcd_set_background(LCD_BG_COLOR);
 8005d82:	f00b f98d 	bl	80110a0 <lcd_set_background>
    lcd_set_foreground(LCD_FG_COLOR);
 8005d86:	2001      	movs	r0, #1
 8005d88:	f00b f97e 	bl	8011088 <lcd_set_foreground>
    lcd_drawstring_size("SWR", 140, (LCD_HEIGHT / 2) - 20, 3);
 8005d8c:	228c      	movs	r2, #140	@ 0x8c
 8005d8e:	2303      	movs	r3, #3
 8005d90:	4816      	ldr	r0, [pc, #88]	@ (8005dec <displaySWR+0x1f4>)
 8005d92:	4611      	mov	r1, r2
 8005d94:	f00b fb3e 	bl	8011414 <lcd_drawstring_size>
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 8005d98:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
    label_drawn = 1;
 8005d9c:	2301      	movs	r3, #1
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 8005d9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    label_drawn = 1;
 8005da2:	6033      	str	r3, [r6, #0]
  if (!(avg > 0.0f) || (avg != avg) || (avg > 9.9f)) /* <=0, NaN, or too large */
 8005da4:	f63f af62 	bhi.w	8005c6c <displaySWR+0x74>
 8005da8:	e7ca      	b.n	8005d40 <displaySWR+0x148>
    if ((last_swr_int == -9999) && (last_color == color))
 8005daa:	8811      	ldrh	r1, [r2, #0]
 8005dac:	290a      	cmp	r1, #10
 8005dae:	d1cd      	bne.n	8005d4c <displaySWR+0x154>
 8005db0:	e7ae      	b.n	8005d10 <displaySWR+0x118>
    color = LCD_TRACE_3_COLOR; // green
 8005db2:	2508      	movs	r5, #8
 8005db4:	e772      	b.n	8005c9c <displaySWR+0xa4>
    if ((swr_int == last_swr_int) && (color == last_color))
 8005db6:	8811      	ldrh	r1, [r2, #0]
 8005db8:	42a9      	cmp	r1, r5
 8005dba:	f47f af7e 	bne.w	8005cba <displaySWR+0xc2>
 8005dbe:	e7a7      	b.n	8005d10 <displaySWR+0x118>
 8005dc0:	200068f8 	.word	0x200068f8
 8005dc4:	20000904 	.word	0x20000904
 8005dc8:	20000900 	.word	0x20000900
 8005dcc:	200008fc 	.word	0x200008fc
 8005dd0:	200008f8 	.word	0x200008f8
 8005dd4:	411e6666 	.word	0x411e6666
 8005dd8:	2000030c 	.word	0x2000030c
 8005ddc:	20000308 	.word	0x20000308
 8005de0:	66666667 	.word	0x66666667
 8005de4:	ffffd8f1 	.word	0xffffd8f1
 8005de8:	08012a1c 	.word	0x08012a1c
 8005dec:	08012a18 	.word	0x08012a18

08005df0 <displayTargetFrequency>:
{
 8005df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (doOnceOnly_In_Mode2 == true)
 8005df4:	4b78      	ldr	r3, [pc, #480]	@ (8005fd8 <displayTargetFrequency+0x1e8>)
    label_drawn = 0;
 8005df6:	4d79      	ldr	r5, [pc, #484]	@ (8005fdc <displayTargetFrequency+0x1ec>)
  if (doOnceOnly_In_Mode2 == true)
 8005df8:	781b      	ldrb	r3, [r3, #0]
{
 8005dfa:	b085      	sub	sp, #20
 8005dfc:	4604      	mov	r4, r0
  if (doOnceOnly_In_Mode2 == true)
 8005dfe:	2b00      	cmp	r3, #0
 8005e00:	f000 80e5 	beq.w	8005fce <displayTargetFrequency+0x1de>
    label_drawn = 0;
 8005e04:	2300      	movs	r3, #0
 8005e06:	602b      	str	r3, [r5, #0]
    lcd_set_background(LCD_BG_COLOR);
 8005e08:	2000      	movs	r0, #0
 8005e0a:	f00b f949 	bl	80110a0 <lcd_set_background>
    lcd_set_foreground(LCD_FG_COLOR);
 8005e0e:	2001      	movs	r0, #1
 8005e10:	f00b f93a 	bl	8011088 <lcd_set_foreground>
    char label[16] = "Target  "; // 2 spaces after Target
 8005e14:	4b72      	ldr	r3, [pc, #456]	@ (8005fe0 <displayTargetFrequency+0x1f0>)
 8005e16:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8005e1a:	466b      	mov	r3, sp
 8005e1c:	c303      	stmia	r3!, {r0, r1}
 8005e1e:	2200      	movs	r2, #0
    label[8] = 0x18;             // put glyph AFTER the spaces
 8005e20:	2118      	movs	r1, #24
    char label[16] = "Target  "; // 2 spaces after Target
 8005e22:	f8cd 2009 	str.w	r2, [sp, #9]
    lcd_drawstring_size(label, 10, yp, 3);
 8005e26:	2303      	movs	r3, #3
    label[8] = 0x18;             // put glyph AFTER the spaces
 8005e28:	f88d 1008 	strb.w	r1, [sp, #8]
    char label[16] = "Target  "; // 2 spaces after Target
 8005e2c:	9203      	str	r2, [sp, #12]
    lcd_drawstring_size(label, 10, yp, 3);
 8005e2e:	210a      	movs	r1, #10
 8005e30:	2223      	movs	r2, #35	@ 0x23
 8005e32:	4668      	mov	r0, sp
 8005e34:	f00b faee 	bl	8011414 <lcd_drawstring_size>
    label_drawn = 1;
 8005e38:	2301      	movs	r3, #1
 8005e3a:	602b      	str	r3, [r5, #0]
  if (target_frequency == last_freq)
 8005e3c:	4969      	ldr	r1, [pc, #420]	@ (8005fe4 <displayTargetFrequency+0x1f4>)
 8005e3e:	680b      	ldr	r3, [r1, #0]
 8005e40:	42a3      	cmp	r3, r4
 8005e42:	f000 80c1 	beq.w	8005fc8 <displayTargetFrequency+0x1d8>
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 8005e46:	4b68      	ldr	r3, [pc, #416]	@ (8005fe8 <displayTargetFrequency+0x1f8>)
  uint32_t mhz = target_frequency / 1000000UL;
 8005e48:	4d68      	ldr	r5, [pc, #416]	@ (8005fec <displayTargetFrequency+0x1fc>)
  last_freq = target_frequency;
 8005e4a:	600c      	str	r4, [r1, #0]
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 8005e4c:	fba3 0204 	umull	r0, r2, r3, r4
 8005e50:	0992      	lsrs	r2, r2, #6
 8005e52:	fba3 0302 	umull	r0, r3, r3, r2
  uint32_t mhz = target_frequency / 1000000UL;
 8005e56:	fba5 0504 	umull	r0, r5, r5, r4
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 8005e5a:	099e      	lsrs	r6, r3, #6
  lcd_set_background(LCD_BG_COLOR);
 8005e5c:	2000      	movs	r0, #0
  uint32_t khz = (target_frequency / 1000UL) % 1000UL;
 8005e5e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8005e62:	fb03 2616 	mls	r6, r3, r6, r2
  uint32_t hz = target_frequency % 1000UL;
 8005e66:	fb03 4412 	mls	r4, r3, r2, r4
  lcd_set_background(LCD_BG_COLOR);
 8005e6a:	f00b f919 	bl	80110a0 <lcd_set_background>
  lcd_fill(200, 30 - 5, 260, yp);
 8005e6e:	2119      	movs	r1, #25
 8005e70:	f44f 7282 	mov.w	r2, #260	@ 0x104
 8005e74:	2323      	movs	r3, #35	@ 0x23
 8005e76:	20c8      	movs	r0, #200	@ 0xc8
 8005e78:	f00b f818 	bl	8010eac <lcd_fill>
  lcd_set_foreground(LCD_FG_COLOR);
 8005e7c:	2001      	movs	r0, #1
 8005e7e:	f00b f903 	bl	8011088 <lcd_set_foreground>
  buf[0] = '0' + (mhz / 10);
 8005e82:	4b5b      	ldr	r3, [pc, #364]	@ (8005ff0 <displayTargetFrequency+0x200>)
  buf[3] = '0' + (khz / 100);
 8005e84:	f8df e16c 	ldr.w	lr, [pc, #364]	@ 8005ff4 <displayTargetFrequency+0x204>
  uint32_t mhz = target_frequency / 1000000UL;
 8005e88:	0cad      	lsrs	r5, r5, #18
  buf[0] = '0' + (mhz / 10);
 8005e8a:	fba3 2005 	umull	r2, r0, r3, r5
  buf[4] = '0' + ((khz / 10) % 10);
 8005e8e:	fba3 1206 	umull	r1, r2, r3, r6
 8005e92:	08d2      	lsrs	r2, r2, #3
  buf[8] = '0' + ((hz / 10) % 10);
 8005e94:	fba3 1c04 	umull	r1, ip, r3, r4
  buf[4] = '0' + ((khz / 10) % 10);
 8005e98:	fba3 1702 	umull	r1, r7, r3, r2
  buf[8] = '0' + ((hz / 10) % 10);
 8005e9c:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
  buf[4] = '0' + ((khz / 10) % 10);
 8005ea0:	08ff      	lsrs	r7, r7, #3
  buf[8] = '0' + ((hz / 10) % 10);
 8005ea2:	fba3 130c 	umull	r1, r3, r3, ip
  buf[4] = '0' + ((khz / 10) % 10);
 8005ea6:	eb07 0787 	add.w	r7, r7, r7, lsl #2
  buf[8] = '0' + ((hz / 10) % 10);
 8005eaa:	08db      	lsrs	r3, r3, #3
  buf[4] = '0' + ((khz / 10) % 10);
 8005eac:	eba2 0747 	sub.w	r7, r2, r7, lsl #1
  buf[5] = '0' + (khz % 10);
 8005eb0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8005eb4:	eba6 0242 	sub.w	r2, r6, r2, lsl #1
  buf[8] = '0' + ((hz / 10) % 10);
 8005eb8:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  buf[3] = '0' + (khz / 100);
 8005ebc:	fbae 6306 	umull	r6, r3, lr, r6
  buf[5] = '0' + (khz % 10);
 8005ec0:	3230      	adds	r2, #48	@ 0x30
  buf[3] = '0' + (khz / 100);
 8005ec2:	095b      	lsrs	r3, r3, #5
  buf[8] = '0' + ((hz / 10) % 10);
 8005ec4:	ebac 0141 	sub.w	r1, ip, r1, lsl #1
  buf[0] = '0' + (mhz / 10);
 8005ec8:	08c0      	lsrs	r0, r0, #3
  buf[3] = '0' + (khz / 100);
 8005eca:	3330      	adds	r3, #48	@ 0x30
  buf[5] = '0' + (khz % 10);
 8005ecc:	f88d 2005 	strb.w	r2, [sp, #5]
  buf[12] = 'z';
 8005ed0:	227a      	movs	r2, #122	@ 0x7a
  buf[7] = '0' + (hz / 100);
 8005ed2:	fbae 6e04 	umull	r6, lr, lr, r4
  buf[9] = '0' + (hz % 10);
 8005ed6:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
  buf[3] = '0' + (khz / 100);
 8005eda:	f88d 3003 	strb.w	r3, [sp, #3]
  buf[12] = 'z';
 8005ede:	f8ad 200c 	strh.w	r2, [sp, #12]
  buf[8] = '0' + ((hz / 10) % 10);
 8005ee2:	f101 0330 	add.w	r3, r1, #48	@ 0x30
  buf[1] = '0' + (mhz % 10);
 8005ee6:	eb00 0280 	add.w	r2, r0, r0, lsl #2
  buf[9] = '0' + (hz % 10);
 8005eea:	eba4 044c 	sub.w	r4, r4, ip, lsl #1
  buf[8] = '0' + ((hz / 10) % 10);
 8005eee:	f88d 3008 	strb.w	r3, [sp, #8]
  buf[1] = '0' + (mhz % 10);
 8005ef2:	eba5 0542 	sub.w	r5, r5, r2, lsl #1
  buf[10] = ' ';
 8005ef6:	f644 0320 	movw	r3, #18464	@ 0x4820
  buf[2] = '.';
 8005efa:	222e      	movs	r2, #46	@ 0x2e
  buf[0] = '0' + (mhz / 10);
 8005efc:	3030      	adds	r0, #48	@ 0x30
  buf[7] = '0' + (hz / 100);
 8005efe:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8005f02:	f10e 0e30 	add.w	lr, lr, #48	@ 0x30
  buf[10] = ' ';
 8005f06:	f8ad 300a 	strh.w	r3, [sp, #10]
  buf[0] = '0' + (mhz / 10);
 8005f0a:	f88d 0000 	strb.w	r0, [sp]
  lcd_drawstring_size(buf, 200, yp, 3);
 8005f0e:	2303      	movs	r3, #3
  buf[2] = '.';
 8005f10:	f88d 2002 	strb.w	r2, [sp, #2]
  buf[6] = '.';
 8005f14:	f88d 2006 	strb.w	r2, [sp, #6]
  buf[4] = '0' + ((khz / 10) % 10);
 8005f18:	3730      	adds	r7, #48	@ 0x30
  buf[9] = '0' + (hz % 10);
 8005f1a:	3430      	adds	r4, #48	@ 0x30
  buf[1] = '0' + (mhz % 10);
 8005f1c:	3530      	adds	r5, #48	@ 0x30
  lcd_drawstring_size(buf, 200, yp, 3);
 8005f1e:	2223      	movs	r2, #35	@ 0x23
 8005f20:	21c8      	movs	r1, #200	@ 0xc8
 8005f22:	4668      	mov	r0, sp
  buf[4] = '0' + ((khz / 10) % 10);
 8005f24:	f88d 7004 	strb.w	r7, [sp, #4]
  buf[7] = '0' + (hz / 100);
 8005f28:	f88d e007 	strb.w	lr, [sp, #7]
  buf[9] = '0' + (hz % 10);
 8005f2c:	f88d 4009 	strb.w	r4, [sp, #9]
  buf[1] = '0' + (mhz % 10);
 8005f30:	f88d 5001 	strb.w	r5, [sp, #1]
  lcd_drawstring_size(buf, 200, yp, 3);
 8005f34:	f00b fa6e 	bl	8011414 <lcd_drawstring_size>
  while (*s && *s != ' ')
 8005f38:	f89d 3000 	ldrb.w	r3, [sp]
 8005f3c:	2b00      	cmp	r3, #0
 8005f3e:	d043      	beq.n	8005fc8 <displayTargetFrequency+0x1d8>
        int half = (triW * i) / (2 * triH); // grows from 0 to triW/2
 8005f40:	f8df 80b4 	ldr.w	r8, [pc, #180]	@ 8005ff8 <displayTargetFrequency+0x208>
  while (*s && *s != ' ')
 8005f44:	466d      	mov	r5, sp
  int x = xBase;
 8005f46:	26c8      	movs	r6, #200	@ 0xc8
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8005f48:	2702      	movs	r7, #2
 8005f4a:	e007      	b.n	8005f5c <displayTargetFrequency+0x16c>
    if (*s == '.')
 8005f4c:	782b      	ldrb	r3, [r5, #0]
 8005f4e:	2b2e      	cmp	r3, #46	@ 0x2e
  while (*s && *s != ' ')
 8005f50:	f815 3f01 	ldrb.w	r3, [r5, #1]!
      x += (cw / 2);
 8005f54:	bf0c      	ite	eq
 8005f56:	360a      	addeq	r6, #10
      x += cw;
 8005f58:	3615      	addne	r6, #21
  while (*s && *s != ' ')
 8005f5a:	b3ab      	cbz	r3, 8005fc8 <displayTargetFrequency+0x1d8>
 8005f5c:	2b20      	cmp	r3, #32
 8005f5e:	d033      	beq.n	8005fc8 <displayTargetFrequency+0x1d8>
    if (*s >= '0' && *s <= '9')
 8005f60:	3b30      	subs	r3, #48	@ 0x30
 8005f62:	2b09      	cmp	r3, #9
 8005f64:	d8f2      	bhi.n	8005f4c <displayTargetFrequency+0x15c>
      lcd_set_colors(LCD_MENU_ACTIVE_COLOR, LCD_MENU_ACTIVE_COLOR);
 8005f66:	2105      	movs	r1, #5
 8005f68:	4608      	mov	r0, r1
 8005f6a:	f00b f8a5 	bl	80110b8 <lcd_set_colors>
      int cx = x + (cw / 2);
 8005f6e:	f106 090a 	add.w	r9, r6, #10
 8005f72:	f04f 0b0d 	mov.w	fp, #13
 8005f76:	2400      	movs	r4, #0
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8005f78:	f04f 0a01 	mov.w	sl, #1
        int half = (triW * i) / (2 * triH); // grows from 0 to triW/2
 8005f7c:	fba8 3004 	umull	r3, r0, r8, r4
 8005f80:	08c0      	lsrs	r0, r0, #3
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8005f82:	fb10 a207 	smlabb	r2, r0, r7, sl
 8005f86:	4659      	mov	r1, fp
 8005f88:	2301      	movs	r3, #1
 8005f8a:	eba9 0000 	sub.w	r0, r9, r0
      for (int i = 0; i < triH; i++)
 8005f8e:	340a      	adds	r4, #10
        lcd_fill(cx - half, triUpY + i, 2 * half + 1, 1);
 8005f90:	f00a ff8c 	bl	8010eac <lcd_fill>
      for (int i = 0; i < triH; i++)
 8005f94:	2c3c      	cmp	r4, #60	@ 0x3c
 8005f96:	f10b 0b01 	add.w	fp, fp, #1
 8005f9a:	d1ef      	bne.n	8005f7c <displayTargetFrequency+0x18c>
 8005f9c:	f04f 0b5a 	mov.w	fp, #90	@ 0x5a
 8005fa0:	2400      	movs	r4, #0
        lcd_fill(cx - half, triDnY - i, 2 * half + 1, 1);
 8005fa2:	f04f 0a01 	mov.w	sl, #1
        int half = (triW * i) / (2 * triH);
 8005fa6:	fba8 3004 	umull	r3, r0, r8, r4
 8005faa:	08c0      	lsrs	r0, r0, #3
        lcd_fill(cx - half, triDnY - i, 2 * half + 1, 1);
 8005fac:	fb10 a207 	smlabb	r2, r0, r7, sl
 8005fb0:	4659      	mov	r1, fp
 8005fb2:	2301      	movs	r3, #1
 8005fb4:	eba9 0000 	sub.w	r0, r9, r0
      for (int i = 0; i < triH; i++)
 8005fb8:	340a      	adds	r4, #10
        lcd_fill(cx - half, triDnY - i, 2 * half + 1, 1);
 8005fba:	f00a ff77 	bl	8010eac <lcd_fill>
      for (int i = 0; i < triH; i++)
 8005fbe:	2c3c      	cmp	r4, #60	@ 0x3c
 8005fc0:	f10b 3bff 	add.w	fp, fp, #4294967295
 8005fc4:	d1ef      	bne.n	8005fa6 <displayTargetFrequency+0x1b6>
 8005fc6:	e7c1      	b.n	8005f4c <displayTargetFrequency+0x15c>
}
 8005fc8:	b005      	add	sp, #20
 8005fca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!label_drawn)
 8005fce:	682b      	ldr	r3, [r5, #0]
 8005fd0:	2b00      	cmp	r3, #0
 8005fd2:	f47f af33 	bne.w	8005e3c <displayTargetFrequency+0x4c>
 8005fd6:	e717      	b.n	8005e08 <displayTargetFrequency+0x18>
 8005fd8:	200068f8 	.word	0x200068f8
 8005fdc:	200008f4 	.word	0x200008f4
 8005fe0:	08012838 	.word	0x08012838
 8005fe4:	200008f0 	.word	0x200008f0
 8005fe8:	10624dd3 	.word	0x10624dd3
 8005fec:	431bde83 	.word	0x431bde83
 8005ff0:	cccccccd 	.word	0xcccccccd
 8005ff4:	51eb851f 	.word	0x51eb851f
 8005ff8:	aaaaaaab 	.word	0xaaaaaaab

08005ffc <pause_sweep>:
  sweep_mode &= ~SWEEP_ENABLE;
 8005ffc:	4a02      	ldr	r2, [pc, #8]	@ (8006008 <pause_sweep+0xc>)
 8005ffe:	7813      	ldrb	r3, [r2, #0]
 8006000:	f023 0301 	bic.w	r3, r3, #1
 8006004:	7013      	strb	r3, [r2, #0]
}
 8006006:	4770      	bx	lr
 8006008:	200003c4 	.word	0x200003c4

0800600c <cmd_pause>:
  pause_sweep();
 800600c:	f7ff bff6 	b.w	8005ffc <pause_sweep>

08006010 <toggle_sweep>:
  sweep_mode ^= SWEEP_ENABLE;
 8006010:	4a02      	ldr	r2, [pc, #8]	@ (800601c <toggle_sweep+0xc>)
 8006012:	7813      	ldrb	r3, [r2, #0]
 8006014:	f083 0301 	eor.w	r3, r3, #1
 8006018:	7013      	strb	r3, [r2, #0]
}
 800601a:	4770      	bx	lr
 800601c:	200003c4 	.word	0x200003c4

08006020 <shell_printf>:
{
 8006020:	b40f      	push	{r0, r1, r2, r3}
 8006022:	b500      	push	{lr}
  if (shell_stream == NULL)
 8006024:	4b06      	ldr	r3, [pc, #24]	@ (8006040 <shell_printf+0x20>)
 8006026:	6818      	ldr	r0, [r3, #0]
{
 8006028:	b083      	sub	sp, #12
  if (shell_stream == NULL)
 800602a:	b120      	cbz	r0, 8006036 <shell_printf+0x16>
  va_start(ap, fmt);
 800602c:	aa05      	add	r2, sp, #20
  formatted_bytes = chvprintf(shell_stream, fmt, ap);
 800602e:	9904      	ldr	r1, [sp, #16]
  va_start(ap, fmt);
 8006030:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(shell_stream, fmt, ap);
 8006032:	f7fc faf3 	bl	800261c <chvprintf>
}
 8006036:	b003      	add	sp, #12
 8006038:	f85d eb04 	ldr.w	lr, [sp], #4
 800603c:	b004      	add	sp, #16
 800603e:	4770      	bx	lr
 8006040:	200068ec 	.word	0x200068ec

08006044 <VNAShell_parceLine>:
  PREPARE_STREAM;
}
#endif

static const VNAShellCommand *VNAShell_parceLine(char *line)
{
 8006044:	b538      	push	{r3, r4, r5, lr}
  // Parse and execute line
  shell_nargs = parse_line(line, shell_args, ARRAY_COUNT(shell_args));
 8006046:	490e      	ldr	r1, [pc, #56]	@ (8006080 <VNAShell_parceLine+0x3c>)
 8006048:	2205      	movs	r2, #5
 800604a:	f003 fd4b 	bl	8009ae4 <parse_line>
 800604e:	4b0d      	ldr	r3, [pc, #52]	@ (8006084 <VNAShell_parceLine+0x40>)
 8006050:	b280      	uxth	r0, r0
  if (shell_nargs > ARRAY_COUNT(shell_args))
 8006052:	2805      	cmp	r0, #5
  shell_nargs = parse_line(line, shell_args, ARRAY_COUNT(shell_args));
 8006054:	8018      	strh	r0, [r3, #0]
  if (shell_nargs > ARRAY_COUNT(shell_args))
 8006056:	d80e      	bhi.n	8006076 <VNAShell_parceLine+0x32>
  {
    shell_printf("too many arguments, max " define_to_STR(VNA_SHELL_MAX_ARGUMENTS) "" VNA_SHELL_NEWLINE_STR);
    return NULL;
  }
  if (shell_nargs > 0)
 8006058:	b180      	cbz	r0, 800607c <VNAShell_parceLine+0x38>
  {
    const VNAShellCommand *scp;
    for (scp = commands; scp->sc_name != NULL; scp++)
 800605a:	4c0b      	ldr	r4, [pc, #44]	@ (8006088 <VNAShell_parceLine+0x44>)
 800605c:	480b      	ldr	r0, [pc, #44]	@ (800608c <VNAShell_parceLine+0x48>)
 800605e:	4d08      	ldr	r5, [pc, #32]	@ (8006080 <VNAShell_parceLine+0x3c>)
 8006060:	e002      	b.n	8006068 <VNAShell_parceLine+0x24>
 8006062:	f854 0f0a 	ldr.w	r0, [r4, #10]!
 8006066:	b148      	cbz	r0, 800607c <VNAShell_parceLine+0x38>
      if (get_str_index(scp->sc_name, shell_args[0]) == 0)
 8006068:	6829      	ldr	r1, [r5, #0]
 800606a:	f003 fd1f 	bl	8009aac <get_str_index>
 800606e:	2800      	cmp	r0, #0
 8006070:	d1f7      	bne.n	8006062 <VNAShell_parceLine+0x1e>
        return scp;
  }
  return NULL;
}
 8006072:	4620      	mov	r0, r4
 8006074:	bd38      	pop	{r3, r4, r5, pc}
    shell_printf("too many arguments, max " define_to_STR(VNA_SHELL_MAX_ARGUMENTS) "" VNA_SHELL_NEWLINE_STR);
 8006076:	4806      	ldr	r0, [pc, #24]	@ (8006090 <VNAShell_parceLine+0x4c>)
 8006078:	f7ff ffd2 	bl	8006020 <shell_printf>
    return NULL;
 800607c:	2400      	movs	r4, #0
 800607e:	e7f8      	b.n	8006072 <VNAShell_parceLine+0x2e>
 8006080:	20006890 	.word	0x20006890
 8006084:	2000688c 	.word	0x2000688c
 8006088:	08015cd8 	.word	0x08015cd8
 800608c:	08012a20 	.word	0x08012a20
 8006090:	08012a28 	.word	0x08012a28

08006094 <cmd_color>:
  if (argc != 2)
 8006094:	2802      	cmp	r0, #2
{
 8006096:	b570      	push	{r4, r5, r6, lr}
  if (argc != 2)
 8006098:	d01e      	beq.n	80060d8 <cmd_color+0x44>
    shell_printf("usage: color {id} {rgb24}" VNA_SHELL_NEWLINE_STR);
 800609a:	4826      	ldr	r0, [pc, #152]	@ (8006134 <cmd_color+0xa0>)
 800609c:	4d26      	ldr	r5, [pc, #152]	@ (8006138 <cmd_color+0xa4>)
 800609e:	f7ff ffbf 	bl	8006020 <shell_printf>
 80060a2:	2400      	movs	r4, #0
      color = GET_PALTETTE_COLOR(i);
 80060a4:	f835 3f02 	ldrh.w	r3, [r5, #2]!
      color = HEXRGB(color);
 80060a8:	08da      	lsrs	r2, r3, #3
 80060aa:	ea4f 1c53 	mov.w	ip, r3, lsr #5
 80060ae:	f00c 0cf8 	and.w	ip, ip, #248	@ 0xf8
 80060b2:	0418      	lsls	r0, r3, #16
 80060b4:	f402 52e0 	and.w	r2, r2, #7168	@ 0x1c00
 80060b8:	ea42 020c 	orr.w	r2, r2, ip
 80060bc:	f400 0078 	and.w	r0, r0, #16252928	@ 0xf80000
 80060c0:	035b      	lsls	r3, r3, #13
 80060c2:	4302      	orrs	r2, r0
 80060c4:	b29b      	uxth	r3, r3
      shell_printf(" %2d: 0x%06x" VNA_SHELL_NEWLINE_STR, i, color);
 80060c6:	4621      	mov	r1, r4
 80060c8:	481c      	ldr	r0, [pc, #112]	@ (800613c <cmd_color+0xa8>)
 80060ca:	431a      	orrs	r2, r3
    for (i = 0; i < MAX_PALETTE; i++)
 80060cc:	3401      	adds	r4, #1
      shell_printf(" %2d: 0x%06x" VNA_SHELL_NEWLINE_STR, i, color);
 80060ce:	f7ff ffa7 	bl	8006020 <shell_printf>
    for (i = 0; i < MAX_PALETTE; i++)
 80060d2:	2c20      	cmp	r4, #32
 80060d4:	d1e6      	bne.n	80060a4 <cmd_color+0x10>
}
 80060d6:	bd70      	pop	{r4, r5, r6, pc}
  i = my_atoui(argv[0]);
 80060d8:	6808      	ldr	r0, [r1, #0]
 80060da:	460c      	mov	r4, r1
 80060dc:	f003 fc26 	bl	800992c <my_atoui>
  if (i >= MAX_PALETTE)
 80060e0:	b283      	uxth	r3, r0
 80060e2:	2b1f      	cmp	r3, #31
  i = my_atoui(argv[0]);
 80060e4:	4606      	mov	r6, r0
  if (i >= MAX_PALETTE)
 80060e6:	d8f6      	bhi.n	80060d6 <cmd_color+0x42>
  color = RGBHEX(my_atoui(argv[1]));
 80060e8:	6860      	ldr	r0, [r4, #4]
 80060ea:	f003 fc1f 	bl	800992c <my_atoui>
 80060ee:	4605      	mov	r5, r0
 80060f0:	6860      	ldr	r0, [r4, #4]
 80060f2:	f003 fc1b 	bl	800992c <my_atoui>
 80060f6:	00ed      	lsls	r5, r5, #3
 80060f8:	0143      	lsls	r3, r0, #5
 80060fa:	f403 53f8 	and.w	r3, r3, #7936	@ 0x1f00
 80060fe:	6860      	ldr	r0, [r4, #4]
 8006100:	f405 4560 	and.w	r5, r5, #57344	@ 0xe000
 8006104:	431d      	orrs	r5, r3
 8006106:	f003 fc11 	bl	800992c <my_atoui>
 800610a:	0c03      	lsrs	r3, r0, #16
 800610c:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 8006110:	6860      	ldr	r0, [r4, #4]
 8006112:	431d      	orrs	r5, r3
 8006114:	f003 fc0a 	bl	800992c <my_atoui>
  config._lcd_palette[i] = color;
 8006118:	4a09      	ldr	r2, [pc, #36]	@ (8006140 <cmd_color+0xac>)
 800611a:	b2b6      	uxth	r6, r6
 800611c:	eb02 0246 	add.w	r2, r2, r6, lsl #1
  color = RGBHEX(my_atoui(argv[1]));
 8006120:	f3c0 3342 	ubfx	r3, r0, #13, #3
 8006124:	432b      	orrs	r3, r5
  request_to_redraw(REDRAW_ALL);
 8006126:	f240 301a 	movw	r0, #794	@ 0x31a
}
 800612a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  config._lcd_palette[i] = color;
 800612e:	83d3      	strh	r3, [r2, #30]
  request_to_redraw(REDRAW_ALL);
 8006130:	f006 bb1a 	b.w	800c768 <request_to_redraw>
 8006134:	08012a44 	.word	0x08012a44
 8006138:	20000334 	.word	0x20000334
 800613c:	08012a60 	.word	0x08012a60
 8006140:	20000318 	.word	0x20000318

08006144 <cmd_reson>:
  if (!mla_resonance_locked)
 8006144:	4b06      	ldr	r3, [pc, #24]	@ (8006160 <cmd_reson+0x1c>)
 8006146:	781b      	ldrb	r3, [r3, #0]
 8006148:	b13b      	cbz	r3, 800615a <cmd_reson+0x16>
  shell_printf("MLA resonance: f = %u Hz (idx=%u)" VNA_SHELL_NEWLINE_STR,
 800614a:	4a06      	ldr	r2, [pc, #24]	@ (8006164 <cmd_reson+0x20>)
 800614c:	4b06      	ldr	r3, [pc, #24]	@ (8006168 <cmd_reson+0x24>)
 800614e:	f9b2 2000 	ldrsh.w	r2, [r2]
 8006152:	6819      	ldr	r1, [r3, #0]
 8006154:	4805      	ldr	r0, [pc, #20]	@ (800616c <cmd_reson+0x28>)
 8006156:	f7ff bf63 	b.w	8006020 <shell_printf>
    shell_printf("Resonance not computed yet" VNA_SHELL_NEWLINE_STR);
 800615a:	4805      	ldr	r0, [pc, #20]	@ (8006170 <cmd_reson+0x2c>)
 800615c:	f7ff bf60 	b.w	8006020 <shell_printf>
 8006160:	2000687d 	.word	0x2000687d
 8006164:	200003d4 	.word	0x200003d4
 8006168:	20006884 	.word	0x20006884
 800616c:	08012a90 	.word	0x08012a90
 8006170:	08012a70 	.word	0x08012a70

08006174 <cmd_version>:
  shell_printf("%s" VNA_SHELL_NEWLINE_STR, NANOVNA_VERSION);
 8006174:	4901      	ldr	r1, [pc, #4]	@ (800617c <cmd_version+0x8>)
 8006176:	4802      	ldr	r0, [pc, #8]	@ (8006180 <cmd_version+0xc>)
 8006178:	f7ff bf52 	b.w	8006020 <shell_printf>
 800617c:	08015ec4 	.word	0x08015ec4
 8006180:	08013560 	.word	0x08013560

08006184 <cmd_info>:
{
 8006184:	b510      	push	{r4, lr}
  while (info_about[i])
 8006186:	4c05      	ldr	r4, [pc, #20]	@ (800619c <cmd_info+0x18>)
 8006188:	6821      	ldr	r1, [r4, #0]
 800618a:	b131      	cbz	r1, 800619a <cmd_info+0x16>
    shell_printf("%s" VNA_SHELL_NEWLINE_STR, info_about[i++]);
 800618c:	4804      	ldr	r0, [pc, #16]	@ (80061a0 <cmd_info+0x1c>)
 800618e:	f7ff ff47 	bl	8006020 <shell_printf>
  while (info_about[i])
 8006192:	f854 1f04 	ldr.w	r1, [r4, #4]!
 8006196:	2900      	cmp	r1, #0
 8006198:	d1f8      	bne.n	800618c <cmd_info+0x8>
}
 800619a:	bd10      	pop	{r4, pc}
 800619c:	2000038c 	.word	0x2000038c
 80061a0:	08013560 	.word	0x08013560

080061a4 <cmd_help>:
{
 80061a4:	b510      	push	{r4, lr}
  shell_printf("Commands:");
 80061a6:	4808      	ldr	r0, [pc, #32]	@ (80061c8 <cmd_help+0x24>)
  const VNAShellCommand *scp = commands;
 80061a8:	4c08      	ldr	r4, [pc, #32]	@ (80061cc <cmd_help+0x28>)
  shell_printf("Commands:");
 80061aa:	f7ff ff39 	bl	8006020 <shell_printf>
  while (scp->sc_name != NULL)
 80061ae:	4908      	ldr	r1, [pc, #32]	@ (80061d0 <cmd_help+0x2c>)
    shell_printf(" %s", scp->sc_name);
 80061b0:	4808      	ldr	r0, [pc, #32]	@ (80061d4 <cmd_help+0x30>)
 80061b2:	f7ff ff35 	bl	8006020 <shell_printf>
  while (scp->sc_name != NULL)
 80061b6:	f854 1f0a 	ldr.w	r1, [r4, #10]!
 80061ba:	2900      	cmp	r1, #0
 80061bc:	d1f8      	bne.n	80061b0 <cmd_help+0xc>
}
 80061be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  shell_printf(VNA_SHELL_NEWLINE_STR);
 80061c2:	4805      	ldr	r0, [pc, #20]	@ (80061d8 <cmd_help+0x34>)
 80061c4:	f7ff bf2c 	b.w	8006020 <shell_printf>
 80061c8:	08012ab4 	.word	0x08012ab4
 80061cc:	08015cd8 	.word	0x08015cd8
 80061d0:	08012a20 	.word	0x08012a20
 80061d4:	08012ac0 	.word	0x08012ac0
 80061d8:	08013860 	.word	0x08013860

080061dc <cmd_threshold>:
  if (argc != 1)
 80061dc:	2801      	cmp	r0, #1
{
 80061de:	b508      	push	{r3, lr}
  if (argc != 1)
 80061e0:	d007      	beq.n	80061f2 <cmd_threshold+0x16>
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 80061e2:	4b07      	ldr	r3, [pc, #28]	@ (8006200 <cmd_threshold+0x24>)
 80061e4:	4907      	ldr	r1, [pc, #28]	@ (8006204 <cmd_threshold+0x28>)
 80061e6:	685a      	ldr	r2, [r3, #4]
 80061e8:	4807      	ldr	r0, [pc, #28]	@ (8006208 <cmd_threshold+0x2c>)
}
 80061ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 80061ee:	f7ff bf17 	b.w	8006020 <shell_printf>
  value = my_atoui(argv[0]);
 80061f2:	6808      	ldr	r0, [r1, #0]
 80061f4:	f003 fb9a 	bl	800992c <my_atoui>
  config._harmonic_freq_threshold = value;
 80061f8:	4b01      	ldr	r3, [pc, #4]	@ (8006200 <cmd_threshold+0x24>)
 80061fa:	6058      	str	r0, [r3, #4]
}
 80061fc:	bd08      	pop	{r3, pc}
 80061fe:	bf00      	nop
 8006200:	20000318 	.word	0x20000318
 8006204:	08012ac4 	.word	0x08012ac4
 8006208:	08012aec 	.word	0x08012aec

0800620c <cmd_transform>:
{
 800620c:	b570      	push	{r4, r5, r6, lr}
  if (argc == 0)
 800620e:	1e06      	subs	r6, r0, #0
 8006210:	d00f      	beq.n	8006232 <cmd_transform+0x26>
  for (i = 0; i < argc; i++)
 8006212:	dd1e      	ble.n	8006252 <cmd_transform+0x46>
 8006214:	1f0c      	subs	r4, r1, #4
 8006216:	2500      	movs	r5, #0
    switch (get_str_index(argv[i], cmd_transform_list))
 8006218:	f854 0f04 	ldr.w	r0, [r4, #4]!
 800621c:	4923      	ldr	r1, [pc, #140]	@ (80062ac <cmd_transform+0xa0>)
 800621e:	f003 fc45 	bl	8009aac <get_str_index>
 8006222:	2807      	cmp	r0, #7
 8006224:	d805      	bhi.n	8006232 <cmd_transform+0x26>
 8006226:	e8df f000 	tbb	[pc, r0]
 800622a:	393d      	.short	0x393d
 800622c:	1b232931 	.word	0x1b232931
 8006230:	0a15      	.short	0x0a15
}
 8006232:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  shell_printf("usage: transform {%s} [...]" VNA_SHELL_NEWLINE_STR, cmd_transform_list);
 8006236:	491d      	ldr	r1, [pc, #116]	@ (80062ac <cmd_transform+0xa0>)
 8006238:	481d      	ldr	r0, [pc, #116]	@ (80062b0 <cmd_transform+0xa4>)
 800623a:	f7ff bef1 	b.w	8006020 <shell_printf>
  props_mode = (props_mode & ~TD_WINDOW) | func;
 800623e:	4a1d      	ldr	r2, [pc, #116]	@ (80062b4 <cmd_transform+0xa8>)
 8006240:	8b13      	ldrh	r3, [r2, #24]
 8006242:	f023 0318 	bic.w	r3, r3, #24
 8006246:	f043 0310 	orr.w	r3, r3, #16
 800624a:	8313      	strh	r3, [r2, #24]
  for (i = 0; i < argc; i++)
 800624c:	3501      	adds	r5, #1
 800624e:	42ae      	cmp	r6, r5
 8006250:	d1e2      	bne.n	8006218 <cmd_transform+0xc>
}
 8006252:	bd70      	pop	{r4, r5, r6, pc}
  props_mode = (props_mode & ~TD_WINDOW) | func;
 8006254:	4a17      	ldr	r2, [pc, #92]	@ (80062b4 <cmd_transform+0xa8>)
 8006256:	8b13      	ldrh	r3, [r2, #24]
 8006258:	f023 0318 	bic.w	r3, r3, #24
 800625c:	8313      	strh	r3, [r2, #24]
}
 800625e:	e7f5      	b.n	800624c <cmd_transform+0x40>
  props_mode = (props_mode & ~TD_WINDOW) | func;
 8006260:	4a14      	ldr	r2, [pc, #80]	@ (80062b4 <cmd_transform+0xa8>)
 8006262:	8b13      	ldrh	r3, [r2, #24]
 8006264:	f023 0318 	bic.w	r3, r3, #24
 8006268:	f043 0308 	orr.w	r3, r3, #8
 800626c:	8313      	strh	r3, [r2, #24]
}
 800626e:	e7ed      	b.n	800624c <cmd_transform+0x40>
  props_mode = (props_mode & ~TD_FUNC) | func;
 8006270:	4a10      	ldr	r2, [pc, #64]	@ (80062b4 <cmd_transform+0xa8>)
 8006272:	8b13      	ldrh	r3, [r2, #24]
 8006274:	f023 0306 	bic.w	r3, r3, #6
 8006278:	8313      	strh	r3, [r2, #24]
}
 800627a:	e7e7      	b.n	800624c <cmd_transform+0x40>
  props_mode = (props_mode & ~TD_FUNC) | func;
 800627c:	4a0d      	ldr	r2, [pc, #52]	@ (80062b4 <cmd_transform+0xa8>)
 800627e:	8b13      	ldrh	r3, [r2, #24]
 8006280:	f023 0306 	bic.w	r3, r3, #6
 8006284:	f043 0304 	orr.w	r3, r3, #4
 8006288:	8313      	strh	r3, [r2, #24]
}
 800628a:	e7df      	b.n	800624c <cmd_transform+0x40>
  props_mode = (props_mode & ~TD_FUNC) | func;
 800628c:	4a09      	ldr	r2, [pc, #36]	@ (80062b4 <cmd_transform+0xa8>)
 800628e:	8b13      	ldrh	r3, [r2, #24]
 8006290:	f023 0306 	bic.w	r3, r3, #6
 8006294:	f043 0302 	orr.w	r3, r3, #2
 8006298:	8313      	strh	r3, [r2, #24]
}
 800629a:	e7d7      	b.n	800624c <cmd_transform+0x40>
      set_domain_mode(DOMAIN_FREQ);
 800629c:	2000      	movs	r0, #0
 800629e:	f7ff f999 	bl	80055d4 <set_domain_mode>
      break;
 80062a2:	e7d3      	b.n	800624c <cmd_transform+0x40>
      set_domain_mode(DOMAIN_TIME);
 80062a4:	2001      	movs	r0, #1
 80062a6:	f7ff f995 	bl	80055d4 <set_domain_mode>
      break;
 80062aa:	e7cf      	b.n	800624c <cmd_transform+0x40>
 80062ac:	08015c78 	.word	0x08015c78
 80062b0:	08012b08 	.word	0x08012b08
 80062b4:	20000aa8 	.word	0x20000aa8

080062b8 <cmd_vbat_offset>:
  if (argc != 1)
 80062b8:	2801      	cmp	r0, #1
{
 80062ba:	b508      	push	{r3, lr}
  if (argc != 1)
 80062bc:	d006      	beq.n	80062cc <cmd_vbat_offset+0x14>
    shell_printf("%d" VNA_SHELL_NEWLINE_STR, config._vbat_offset);
 80062be:	4b06      	ldr	r3, [pc, #24]	@ (80062d8 <cmd_vbat_offset+0x20>)
 80062c0:	4806      	ldr	r0, [pc, #24]	@ (80062dc <cmd_vbat_offset+0x24>)
 80062c2:	8b19      	ldrh	r1, [r3, #24]
}
 80062c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("%d" VNA_SHELL_NEWLINE_STR, config._vbat_offset);
 80062c8:	f7ff beaa 	b.w	8006020 <shell_printf>
  config._vbat_offset = (int16_t)my_atoi(argv[0]);
 80062cc:	6808      	ldr	r0, [r1, #0]
 80062ce:	f003 fb13 	bl	80098f8 <my_atoi>
 80062d2:	4b01      	ldr	r3, [pc, #4]	@ (80062d8 <cmd_vbat_offset+0x20>)
 80062d4:	8318      	strh	r0, [r3, #24]
}
 80062d6:	bd08      	pop	{r3, pc}
 80062d8:	20000318 	.word	0x20000318
 80062dc:	08012e98 	.word	0x08012e98

080062e0 <cmd_config>:
  if (argc == 2 && (idx = get_str_index(argv[0], cmd_mode_list)) >= 0)
 80062e0:	2802      	cmp	r0, #2
 80062e2:	d003      	beq.n	80062ec <cmd_config+0xc>
    shell_printf("usage: config {%s} [0|1]" VNA_SHELL_NEWLINE_STR, cmd_mode_list);
 80062e4:	490d      	ldr	r1, [pc, #52]	@ (800631c <cmd_config+0x3c>)
 80062e6:	480e      	ldr	r0, [pc, #56]	@ (8006320 <cmd_config+0x40>)
 80062e8:	f7ff be9a 	b.w	8006020 <shell_printf>
{
 80062ec:	b538      	push	{r3, r4, r5, lr}
 80062ee:	460c      	mov	r4, r1
  if (argc == 2 && (idx = get_str_index(argv[0], cmd_mode_list)) >= 0)
 80062f0:	490a      	ldr	r1, [pc, #40]	@ (800631c <cmd_config+0x3c>)
 80062f2:	6820      	ldr	r0, [r4, #0]
 80062f4:	f003 fbda 	bl	8009aac <get_str_index>
 80062f8:	1e05      	subs	r5, r0, #0
 80062fa:	da05      	bge.n	8006308 <cmd_config+0x28>
}
 80062fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    shell_printf("usage: config {%s} [0|1]" VNA_SHELL_NEWLINE_STR, cmd_mode_list);
 8006300:	4906      	ldr	r1, [pc, #24]	@ (800631c <cmd_config+0x3c>)
 8006302:	4807      	ldr	r0, [pc, #28]	@ (8006320 <cmd_config+0x40>)
 8006304:	f7ff be8c 	b.w	8006020 <shell_printf>
    apply_VNA_mode(idx, my_atoui(argv[1]));
 8006308:	6860      	ldr	r0, [r4, #4]
 800630a:	f003 fb0f 	bl	800992c <my_atoui>
 800630e:	b2c1      	uxtb	r1, r0
 8006310:	b2a8      	uxth	r0, r5
}
 8006312:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    apply_VNA_mode(idx, my_atoui(argv[1]));
 8006316:	f00a b84b 	b.w	80103b0 <apply_VNA_mode>
 800631a:	bf00      	nop
 800631c:	08015c40 	.word	0x08015c40
 8006320:	08012b28 	.word	0x08012b28

08006324 <cmd_smooth>:
  if (argc != 1)
 8006324:	2801      	cmp	r0, #1
{
 8006326:	b508      	push	{r3, lr}
  if (argc != 1)
 8006328:	d007      	beq.n	800633a <cmd_smooth+0x16>
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 800632a:	4b08      	ldr	r3, [pc, #32]	@ (800634c <cmd_smooth+0x28>)
 800632c:	4908      	ldr	r1, [pc, #32]	@ (8006350 <cmd_smooth+0x2c>)
 800632e:	781a      	ldrb	r2, [r3, #0]
 8006330:	4808      	ldr	r0, [pc, #32]	@ (8006354 <cmd_smooth+0x30>)
}
 8006332:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 8006336:	f7ff be73 	b.w	8006020 <shell_printf>
  set_smooth_factor(my_atoui(argv[0]));
 800633a:	6808      	ldr	r0, [r1, #0]
 800633c:	f003 faf6 	bl	800992c <my_atoui>
}
 8006340:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_smooth_factor(my_atoui(argv[0]));
 8006344:	b2c0      	uxtb	r0, r0
 8006346:	f7ff bb97 	b.w	8005a78 <set_smooth_factor>
 800634a:	bf00      	nop
 800634c:	20004f50 	.word	0x20004f50
 8006350:	08012b44 	.word	0x08012b44
 8006354:	08012aec 	.word	0x08012aec

08006358 <cmd_reset>:
  if (argc == 1)
 8006358:	2801      	cmp	r0, #1
{
 800635a:	b508      	push	{r3, lr}
  if (argc == 1)
 800635c:	d10c      	bne.n	8006378 <cmd_reset+0x20>
    if (get_str_index(argv[0], "dfu") == 0)
 800635e:	460b      	mov	r3, r1
 8006360:	490d      	ldr	r1, [pc, #52]	@ (8006398 <cmd_reset+0x40>)
 8006362:	6818      	ldr	r0, [r3, #0]
 8006364:	f003 fba2 	bl	8009aac <get_str_index>
 8006368:	b930      	cbnz	r0, 8006378 <cmd_reset+0x20>
      shell_printf("Performing reset to DFU mode" VNA_SHELL_NEWLINE_STR);
 800636a:	480c      	ldr	r0, [pc, #48]	@ (800639c <cmd_reset+0x44>)
 800636c:	f7ff fe58 	bl	8006020 <shell_printf>
}
 8006370:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      ui_enter_dfu();
 8006374:	f00a b806 	b.w	8010384 <ui_enter_dfu>
  shell_printf("Performing reset" VNA_SHELL_NEWLINE_STR);
 8006378:	4809      	ldr	r0, [pc, #36]	@ (80063a0 <cmd_reset+0x48>)
 800637a:	f7ff fe51 	bl	8006020 <shell_printf>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800637e:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8006382:	4908      	ldr	r1, [pc, #32]	@ (80063a4 <cmd_reset+0x4c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8006384:	4b08      	ldr	r3, [pc, #32]	@ (80063a8 <cmd_reset+0x50>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8006386:	68ca      	ldr	r2, [r1, #12]
 8006388:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800638c:	4313      	orrs	r3, r2
 800638e:	60cb      	str	r3, [r1, #12]
 8006390:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 8006394:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */
  while(1) { __NOP(); }                                             /* wait until reset */
 8006396:	e7fd      	b.n	8006394 <cmd_reset+0x3c>
 8006398:	08012b54 	.word	0x08012b54
 800639c:	08012b58 	.word	0x08012b58
 80063a0:	08012b78 	.word	0x08012b78
 80063a4:	e000ed00 	.word	0xe000ed00
 80063a8:	05fa0004 	.word	0x05fa0004

080063ac <cmd_tcxo>:
  if (argc != 1)
 80063ac:	2801      	cmp	r0, #1
{
 80063ae:	b508      	push	{r3, lr}
  if (argc != 1)
 80063b0:	d007      	beq.n	80063c2 <cmd_tcxo+0x16>
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 80063b2:	4b07      	ldr	r3, [pc, #28]	@ (80063d0 <cmd_tcxo+0x24>)
 80063b4:	4907      	ldr	r1, [pc, #28]	@ (80063d4 <cmd_tcxo+0x28>)
 80063b6:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 80063b8:	4807      	ldr	r0, [pc, #28]	@ (80063d8 <cmd_tcxo+0x2c>)
}
 80063ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 80063be:	f7ff be2f 	b.w	8006020 <shell_printf>
  si5351_set_tcxo(my_atoui(argv[0]));
 80063c2:	6808      	ldr	r0, [r1, #0]
 80063c4:	f003 fab2 	bl	800992c <my_atoui>
}
 80063c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  si5351_set_tcxo(my_atoui(argv[0]));
 80063cc:	f003 bd56 	b.w	8009e7c <si5351_set_tcxo>
 80063d0:	20000318 	.word	0x20000318
 80063d4:	08012b8c 	.word	0x08012b8c
 80063d8:	08012aec 	.word	0x08012aec

080063dc <cmd_vbat>:
{
 80063dc:	b508      	push	{r3, lr}
  shell_printf("%d m" S_VOLT VNA_SHELL_NEWLINE_STR, adc_vbat_read());
 80063de:	f00b fb51 	bl	8011a84 <adc_vbat_read>
}
 80063e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shell_printf("%d m" S_VOLT VNA_SHELL_NEWLINE_STR, adc_vbat_read());
 80063e6:	4601      	mov	r1, r0
 80063e8:	4801      	ldr	r0, [pc, #4]	@ (80063f0 <cmd_vbat+0x14>)
 80063ea:	f7ff be19 	b.w	8006020 <shell_printf>
 80063ee:	bf00      	nop
 80063f0:	08012ba8 	.word	0x08012ba8

080063f4 <cmd_measure>:
  if (argc == 1 && (idx = get_str_index(argv[0], cmd_measure_list)) >= 0)
 80063f4:	2801      	cmp	r0, #1
 80063f6:	d003      	beq.n	8006400 <cmd_measure+0xc>
    shell_printf("usage: measure {%s}" VNA_SHELL_NEWLINE_STR, cmd_measure_list);
 80063f8:	490b      	ldr	r1, [pc, #44]	@ (8006428 <cmd_measure+0x34>)
 80063fa:	480c      	ldr	r0, [pc, #48]	@ (800642c <cmd_measure+0x38>)
 80063fc:	f7ff be10 	b.w	8006020 <shell_printf>
{
 8006400:	b508      	push	{r3, lr}
 8006402:	460b      	mov	r3, r1
  if (argc == 1 && (idx = get_str_index(argv[0], cmd_measure_list)) >= 0)
 8006404:	4908      	ldr	r1, [pc, #32]	@ (8006428 <cmd_measure+0x34>)
 8006406:	6818      	ldr	r0, [r3, #0]
 8006408:	f003 fb50 	bl	8009aac <get_str_index>
 800640c:	2800      	cmp	r0, #0
 800640e:	da05      	bge.n	800641c <cmd_measure+0x28>
}
 8006410:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("usage: measure {%s}" VNA_SHELL_NEWLINE_STR, cmd_measure_list);
 8006414:	4904      	ldr	r1, [pc, #16]	@ (8006428 <cmd_measure+0x34>)
 8006416:	4805      	ldr	r0, [pc, #20]	@ (800642c <cmd_measure+0x38>)
 8006418:	f7ff be02 	b.w	8006020 <shell_printf>
}
 800641c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    plot_set_measure_mode(idx);
 8006420:	b2c0      	uxtb	r0, r0
 8006422:	f006 b9b5 	b.w	800c790 <plot_set_measure_mode>
 8006426:	bf00      	nop
 8006428:	08015c00 	.word	0x08015c00
 800642c:	08012bb0 	.word	0x08012bb0

08006430 <cmd_save>:
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 8006430:	2801      	cmp	r0, #1
 8006432:	d004      	beq.n	800643e <cmd_save+0xe>
  shell_printf("usage: %s 0..%d" VNA_SHELL_NEWLINE_STR, SAVEAREA_MAX - 1, "save");
 8006434:	4a0c      	ldr	r2, [pc, #48]	@ (8006468 <cmd_save+0x38>)
 8006436:	480d      	ldr	r0, [pc, #52]	@ (800646c <cmd_save+0x3c>)
 8006438:	2106      	movs	r1, #6
 800643a:	f7ff bdf1 	b.w	8006020 <shell_printf>
{
 800643e:	b508      	push	{r3, lr}
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 8006440:	6808      	ldr	r0, [r1, #0]
 8006442:	f003 fa73 	bl	800992c <my_atoui>
 8006446:	2806      	cmp	r0, #6
 8006448:	d906      	bls.n	8006458 <cmd_save+0x28>
}
 800644a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shell_printf("usage: %s 0..%d" VNA_SHELL_NEWLINE_STR, SAVEAREA_MAX - 1, "save");
 800644e:	4a06      	ldr	r2, [pc, #24]	@ (8006468 <cmd_save+0x38>)
 8006450:	4806      	ldr	r0, [pc, #24]	@ (800646c <cmd_save+0x3c>)
 8006452:	2106      	movs	r1, #6
 8006454:	f7ff bde4 	b.w	8006020 <shell_printf>
    caldata_save(id);
 8006458:	f00b f9ba 	bl	80117d0 <caldata_save>
}
 800645c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    request_to_redraw(REDRAW_CAL_STATUS);
 8006460:	2010      	movs	r0, #16
 8006462:	f006 b981 	b.w	800c768 <request_to_redraw>
 8006466:	bf00      	nop
 8006468:	08012bc8 	.word	0x08012bc8
 800646c:	08012bd0 	.word	0x08012bd0

08006470 <cmd_msg>:
  if (argc == 0)
 8006470:	b1b0      	cbz	r0, 80064a0 <cmd_msg+0x30>
{
 8006472:	b538      	push	{r3, r4, r5, lr}
 8006474:	4604      	mov	r4, r0
  uint32_t delay = my_atoui(argv[0]);
 8006476:	6808      	ldr	r0, [r1, #0]
 8006478:	460d      	mov	r5, r1
 800647a:	f003 fa57 	bl	800992c <my_atoui>
  if (argc > 1)
 800647e:	2c01      	cmp	r4, #1
  uint32_t delay = my_atoui(argv[0]);
 8006480:	4602      	mov	r2, r0
  if (argc > 1)
 8006482:	dd07      	ble.n	8006494 <cmd_msg+0x24>
  if (argc > 2)
 8006484:	2c02      	cmp	r4, #2
    text = argv[1];
 8006486:	6869      	ldr	r1, [r5, #4]
  if (argc > 2)
 8006488:	d00d      	beq.n	80064a6 <cmd_msg+0x36>
    header = argv[2];
 800648a:	68a8      	ldr	r0, [r5, #8]
}
 800648c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ui_message_box(header, text, delay);
 8006490:	f009 ba4e 	b.w	800f930 <ui_message_box>
  char *header = 0, *text = 0;
 8006494:	2100      	movs	r1, #0
}
 8006496:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  char *header = 0, *text = 0;
 800649a:	4608      	mov	r0, r1
  ui_message_box(header, text, delay);
 800649c:	f009 ba48 	b.w	800f930 <ui_message_box>
    shell_printf("usage: msg delay [text] [header]" VNA_SHELL_NEWLINE_STR);
 80064a0:	4803      	ldr	r0, [pc, #12]	@ (80064b0 <cmd_msg+0x40>)
 80064a2:	f7ff bdbd 	b.w	8006020 <shell_printf>
}
 80064a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  char *header = 0, *text = 0;
 80064aa:	2000      	movs	r0, #0
  ui_message_box(header, text, delay);
 80064ac:	f009 ba40 	b.w	800f930 <ui_message_box>
 80064b0:	08012be4 	.word	0x08012be4

080064b4 <cmd_touchcal>:
{
 80064b4:	b510      	push	{r4, lr}
  shell_printf("first touch upper left, then lower right...");
 80064b6:	480d      	ldr	r0, [pc, #52]	@ (80064ec <cmd_touchcal+0x38>)
{
 80064b8:	b082      	sub	sp, #8
  shell_printf("first touch upper left, then lower right...");
 80064ba:	f7ff fdb1 	bl	8006020 <shell_printf>
  ui_touch_cal_exec();
 80064be:	f009 fe6b 	bl	8010198 <ui_touch_cal_exec>
               config._touch_cal[0], config._touch_cal[1], config._touch_cal[2], config._touch_cal[3]);
 80064c2:	490b      	ldr	r1, [pc, #44]	@ (80064f0 <cmd_touchcal+0x3c>)
  shell_printf("done" VNA_SHELL_NEWLINE_STR
 80064c4:	480b      	ldr	r0, [pc, #44]	@ (80064f4 <cmd_touchcal+0x40>)
 80064c6:	f9b1 4012 	ldrsh.w	r4, [r1, #18]
 80064ca:	f9b1 3010 	ldrsh.w	r3, [r1, #16]
 80064ce:	f9b1 200e 	ldrsh.w	r2, [r1, #14]
 80064d2:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
 80064d6:	9400      	str	r4, [sp, #0]
 80064d8:	f7ff fda2 	bl	8006020 <shell_printf>
  request_to_redraw(REDRAW_ALL);
 80064dc:	f240 301a 	movw	r0, #794	@ 0x31a
}
 80064e0:	b002      	add	sp, #8
 80064e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  request_to_redraw(REDRAW_ALL);
 80064e6:	f006 b93f 	b.w	800c768 <request_to_redraw>
 80064ea:	bf00      	nop
 80064ec:	08012c08 	.word	0x08012c08
 80064f0:	20000318 	.word	0x20000318
 80064f4:	08012c34 	.word	0x08012c34

080064f8 <cmd_dump>:
{
 80064f8:	b570      	push	{r4, r5, r6, lr}
  dump_len = ARRAY_COUNT(dump);
 80064fa:	4d23      	ldr	r5, [pc, #140]	@ (8006588 <cmd_dump+0x90>)
 80064fc:	23c0      	movs	r3, #192	@ 0xc0
{
 80064fe:	b0e0      	sub	sp, #384	@ 0x180
  dump_len = ARRAY_COUNT(dump);
 8006500:	802b      	strh	r3, [r5, #0]
  int len = dump_len;
 8006502:	882e      	ldrh	r6, [r5, #0]
  dump_buffer = dump;
 8006504:	4b21      	ldr	r3, [pc, #132]	@ (800658c <cmd_dump+0x94>)
  if (argc == 1)
 8006506:	2801      	cmp	r0, #1
  int len = dump_len;
 8006508:	b236      	sxth	r6, r6
  dump_buffer = dump;
 800650a:	466c      	mov	r4, sp
 800650c:	f8c3 d000 	str.w	sp, [r3]
  if (argc == 1)
 8006510:	d030      	beq.n	8006574 <cmd_dump+0x7c>
  tlv320aic3204_select(0);
 8006512:	2000      	movs	r0, #0
 8006514:	f003 fe7c 	bl	800a210 <tlv320aic3204_select>
 8006518:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
  DSP_START(DELAY_SWEEP_START);
 800651c:	4a1c      	ldr	r2, [pc, #112]	@ (8006590 <cmd_dump+0x98>)
 800651e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006520:	33c8      	adds	r3, #200	@ 0xc8
 8006522:	6013      	str	r3, [r2, #0]
 8006524:	4b1b      	ldr	r3, [pc, #108]	@ (8006594 <cmd_dump+0x9c>)
 8006526:	4a1c      	ldr	r2, [pc, #112]	@ (8006598 <cmd_dump+0xa0>)
 8006528:	8b5b      	ldrh	r3, [r3, #26]
 800652a:	3302      	adds	r3, #2
 800652c:	b29b      	uxth	r3, r3
 800652e:	8013      	strh	r3, [r2, #0]
  while (dump_len > 0)
 8006530:	882b      	ldrh	r3, [r5, #0]
 8006532:	b21b      	sxth	r3, r3
 8006534:	2b00      	cmp	r3, #0
 8006536:	dd04      	ble.n	8006542 <cmd_dump+0x4a>
  __ASM volatile ("wfi");
 8006538:	bf30      	wfi
 800653a:	882b      	ldrh	r3, [r5, #0]
 800653c:	b21b      	sxth	r3, r3
 800653e:	2b00      	cmp	r3, #0
 8006540:	dcfa      	bgt.n	8006538 <cmd_dump+0x40>
  for (i = 0, j = 0; i < len; i++)
 8006542:	2e00      	cmp	r6, #0
 8006544:	dd14      	ble.n	8006570 <cmd_dump+0x78>
 8006546:	eb04 0646 	add.w	r6, r4, r6, lsl #1
 800654a:	2500      	movs	r5, #0
 800654c:	e001      	b.n	8006552 <cmd_dump+0x5a>
 800654e:	42b4      	cmp	r4, r6
 8006550:	d00e      	beq.n	8006570 <cmd_dump+0x78>
    shell_printf("%6d ", dump[i]);
 8006552:	f934 1b02 	ldrsh.w	r1, [r4], #2
 8006556:	4811      	ldr	r0, [pc, #68]	@ (800659c <cmd_dump+0xa4>)
    if (++j == 12)
 8006558:	3501      	adds	r5, #1
    shell_printf("%6d ", dump[i]);
 800655a:	f7ff fd61 	bl	8006020 <shell_printf>
    if (++j == 12)
 800655e:	2d0c      	cmp	r5, #12
 8006560:	d1f5      	bne.n	800654e <cmd_dump+0x56>
      shell_printf(VNA_SHELL_NEWLINE_STR);
 8006562:	480f      	ldr	r0, [pc, #60]	@ (80065a0 <cmd_dump+0xa8>)
 8006564:	f7ff fd5c 	bl	8006020 <shell_printf>
  for (i = 0, j = 0; i < len; i++)
 8006568:	42b4      	cmp	r4, r6
      j = 0;
 800656a:	f04f 0500 	mov.w	r5, #0
  for (i = 0, j = 0; i < len; i++)
 800656e:	d1f0      	bne.n	8006552 <cmd_dump+0x5a>
}
 8006570:	b060      	add	sp, #384	@ 0x180
 8006572:	bd70      	pop	{r4, r5, r6, pc}
    dump_selection = my_atoi(argv[0]) == 1 ? 0 : 1;
 8006574:	6808      	ldr	r0, [r1, #0]
 8006576:	f003 f9bf 	bl	80098f8 <my_atoi>
 800657a:	4b0a      	ldr	r3, [pc, #40]	@ (80065a4 <cmd_dump+0xac>)
 800657c:	3801      	subs	r0, #1
 800657e:	bf18      	it	ne
 8006580:	2001      	movne	r0, #1
 8006582:	8018      	strh	r0, [r3, #0]
 8006584:	e7c5      	b.n	8006512 <cmd_dump+0x1a>
 8006586:	bf00      	nop
 8006588:	20000aa2 	.word	0x20000aa2
 800658c:	20000aa4 	.word	0x20000aa4
 8006590:	20000a9c 	.word	0x20000a9c
 8006594:	20000318 	.word	0x20000318
 8006598:	20000a98 	.word	0x20000a98
 800659c:	08012c5c 	.word	0x08012c5c
 80065a0:	08013860 	.word	0x08013860
 80065a4:	20000aa0 	.word	0x20000aa0

080065a8 <cmd_clearconfig>:
  if (argc != 1)
 80065a8:	2801      	cmp	r0, #1
 80065aa:	d002      	beq.n	80065b2 <cmd_clearconfig+0xa>
    shell_printf("usage: clearconfig {protection key}" VNA_SHELL_NEWLINE_STR);
 80065ac:	480a      	ldr	r0, [pc, #40]	@ (80065d8 <cmd_clearconfig+0x30>)
 80065ae:	f7ff bd37 	b.w	8006020 <shell_printf>
{
 80065b2:	b508      	push	{r3, lr}
 80065b4:	460b      	mov	r3, r1
  if (get_str_index(argv[0], "1234") != 0)
 80065b6:	4909      	ldr	r1, [pc, #36]	@ (80065dc <cmd_clearconfig+0x34>)
 80065b8:	6818      	ldr	r0, [r3, #0]
 80065ba:	f003 fa77 	bl	8009aac <get_str_index>
 80065be:	b930      	cbnz	r0, 80065ce <cmd_clearconfig+0x26>
  clear_all_config_prop_data();
 80065c0:	f00b f988 	bl	80118d4 <clear_all_config_prop_data>
}
 80065c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shell_printf("Config and all cal data cleared." VNA_SHELL_NEWLINE_STR
 80065c8:	4805      	ldr	r0, [pc, #20]	@ (80065e0 <cmd_clearconfig+0x38>)
 80065ca:	f7ff bd29 	b.w	8006020 <shell_printf>
}
 80065ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("Key unmatched." VNA_SHELL_NEWLINE_STR);
 80065d2:	4804      	ldr	r0, [pc, #16]	@ (80065e4 <cmd_clearconfig+0x3c>)
 80065d4:	f7ff bd24 	b.w	8006020 <shell_printf>
 80065d8:	08012c64 	.word	0x08012c64
 80065dc:	08012c8c 	.word	0x08012c8c
 80065e0:	08012ca8 	.word	0x08012ca8
 80065e4:	08012c94 	.word	0x08012c94

080065e8 <cmd_saveconfig>:
{
 80065e8:	b508      	push	{r3, lr}
  config_save();
 80065ea:	f00b f8b1 	bl	8011750 <config_save>
}
 80065ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shell_printf("Config saved" VNA_SHELL_NEWLINE_STR);
 80065f2:	4801      	ldr	r0, [pc, #4]	@ (80065f8 <cmd_saveconfig+0x10>)
 80065f4:	f7ff bd14 	b.w	8006020 <shell_printf>
 80065f8:	08012d0c 	.word	0x08012d0c

080065fc <cmd_sd_card_mount>:
{
 80065fc:	b510      	push	{r4, lr}
  const FRESULT res = f_mount(fs_volume, "", 1);
 80065fe:	4907      	ldr	r1, [pc, #28]	@ (800661c <cmd_sd_card_mount+0x20>)
 8006600:	4807      	ldr	r0, [pc, #28]	@ (8006620 <cmd_sd_card_mount+0x24>)
 8006602:	2201      	movs	r2, #1
 8006604:	f7fe f99e 	bl	8004944 <f_mount>
  if (res != FR_OK)
 8006608:	4604      	mov	r4, r0
 800660a:	b908      	cbnz	r0, 8006610 <cmd_sd_card_mount+0x14>
}
 800660c:	4620      	mov	r0, r4
 800660e:	bd10      	pop	{r4, pc}
    shell_printf("err: no card" VNA_SHELL_NEWLINE_STR);
 8006610:	4804      	ldr	r0, [pc, #16]	@ (8006624 <cmd_sd_card_mount+0x28>)
 8006612:	f7ff fd05 	bl	8006020 <shell_printf>
}
 8006616:	4620      	mov	r0, r4
 8006618:	bd10      	pop	{r4, pc}
 800661a:	bf00      	nop
 800661c:	080132e4 	.word	0x080132e4
 8006620:	20009800 	.word	0x20009800
 8006624:	08012d1c 	.word	0x08012d1c

08006628 <cmd_sd_delete>:
  if (argc != 1)
 8006628:	2801      	cmp	r0, #1
 800662a:	d002      	beq.n	8006632 <cmd_sd_delete+0xa>
    shell_printf("usage: sd_delete {filename}" VNA_SHELL_NEWLINE_STR);
 800662c:	480d      	ldr	r0, [pc, #52]	@ (8006664 <cmd_sd_delete+0x3c>)
 800662e:	f7ff bcf7 	b.w	8006020 <shell_printf>
{
 8006632:	b510      	push	{r4, lr}
 8006634:	460c      	mov	r4, r1
  if (cmd_sd_card_mount() != FR_OK)
 8006636:	f7ff ffe1 	bl	80065fc <cmd_sd_card_mount>
 800663a:	b100      	cbz	r0, 800663e <cmd_sd_delete+0x16>
}
 800663c:	bd10      	pop	{r4, pc}
  const char *filename = argv[0];
 800663e:	6824      	ldr	r4, [r4, #0]
  res = f_unlink(filename);
 8006640:	4620      	mov	r0, r4
 8006642:	f7fe fdc7 	bl	80051d4 <f_unlink>
  shell_printf("delete: %s %s" VNA_SHELL_NEWLINE_STR, filename, res == FR_OK ? "OK" : "err");
 8006646:	b130      	cbz	r0, 8006656 <cmd_sd_delete+0x2e>
 8006648:	4621      	mov	r1, r4
 800664a:	4a07      	ldr	r2, [pc, #28]	@ (8006668 <cmd_sd_delete+0x40>)
 800664c:	4807      	ldr	r0, [pc, #28]	@ (800666c <cmd_sd_delete+0x44>)
}
 800664e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  shell_printf("delete: %s %s" VNA_SHELL_NEWLINE_STR, filename, res == FR_OK ? "OK" : "err");
 8006652:	f7ff bce5 	b.w	8006020 <shell_printf>
 8006656:	4621      	mov	r1, r4
 8006658:	4a05      	ldr	r2, [pc, #20]	@ (8006670 <cmd_sd_delete+0x48>)
 800665a:	4804      	ldr	r0, [pc, #16]	@ (800666c <cmd_sd_delete+0x44>)
}
 800665c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  shell_printf("delete: %s %s" VNA_SHELL_NEWLINE_STR, filename, res == FR_OK ? "OK" : "err");
 8006660:	f7ff bcde 	b.w	8006020 <shell_printf>
 8006664:	08012d34 	.word	0x08012d34
 8006668:	08012d30 	.word	0x08012d30
 800666c:	08012d54 	.word	0x08012d54
 8006670:	08012d2c 	.word	0x08012d2c

08006674 <cmd_sd_read>:
  if (argc != 1)
 8006674:	2801      	cmp	r0, #1
 8006676:	d002      	beq.n	800667e <cmd_sd_read+0xa>
    shell_printf("usage: sd_read {filename}" VNA_SHELL_NEWLINE_STR);
 8006678:	481a      	ldr	r0, [pc, #104]	@ (80066e4 <cmd_sd_read+0x70>)
 800667a:	f7ff bcd1 	b.w	8006020 <shell_printf>
{
 800667e:	b530      	push	{r4, r5, lr}
 8006680:	b083      	sub	sp, #12
  const char *filename = argv[0];
 8006682:	680d      	ldr	r5, [r1, #0]
  if (cmd_sd_card_mount() != FR_OK)
 8006684:	4604      	mov	r4, r0
 8006686:	f7ff ffb9 	bl	80065fc <cmd_sd_card_mount>
 800668a:	b108      	cbz	r0, 8006690 <cmd_sd_read+0x1c>
}
 800668c:	b003      	add	sp, #12
 800668e:	bd30      	pop	{r4, r5, pc}
  if (f_open(fs_file, filename, FA_OPEN_EXISTING | FA_READ) != FR_OK)
 8006690:	4629      	mov	r1, r5
 8006692:	4815      	ldr	r0, [pc, #84]	@ (80066e8 <cmd_sd_read+0x74>)
 8006694:	4622      	mov	r2, r4
 8006696:	f7fe f977 	bl	8004988 <f_open>
 800669a:	4605      	mov	r5, r0
 800669c:	b9e0      	cbnz	r0, 80066d8 <cmd_sd_read+0x64>
  uint32_t filesize = f_size(fs_file);
 800669e:	4c13      	ldr	r4, [pc, #76]	@ (80066ec <cmd_sd_read+0x78>)
  shell_write(&filesize, 4);
 80066a0:	2104      	movs	r1, #4
  uint32_t filesize = f_size(fs_file);
 80066a2:	f8d4 3b84 	ldr.w	r3, [r4, #2948]	@ 0xb84
 80066a6:	9300      	str	r3, [sp, #0]
  shell_write(&filesize, 4);
 80066a8:	4668      	mov	r0, sp
 80066aa:	f7fe ff33 	bl	8005514 <shell_write>
  UINT size = 0;
 80066ae:	9501      	str	r5, [sp, #4]
  while (f_read(fs_file, buf, 512, &size) == FR_OK && size > 0)
 80066b0:	e004      	b.n	80066bc <cmd_sd_read+0x48>
 80066b2:	9901      	ldr	r1, [sp, #4]
    shell_write(buf, size);
 80066b4:	4620      	mov	r0, r4
  while (f_read(fs_file, buf, 512, &size) == FR_OK && size > 0)
 80066b6:	b151      	cbz	r1, 80066ce <cmd_sd_read+0x5a>
    shell_write(buf, size);
 80066b8:	f7fe ff2c 	bl	8005514 <shell_write>
  while (f_read(fs_file, buf, 512, &size) == FR_OK && size > 0)
 80066bc:	480a      	ldr	r0, [pc, #40]	@ (80066e8 <cmd_sd_read+0x74>)
 80066be:	ab01      	add	r3, sp, #4
 80066c0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80066c4:	4621      	mov	r1, r4
 80066c6:	f7fe fa8f 	bl	8004be8 <f_read>
 80066ca:	2800      	cmp	r0, #0
 80066cc:	d0f1      	beq.n	80066b2 <cmd_sd_read+0x3e>
  f_close(fs_file);
 80066ce:	4806      	ldr	r0, [pc, #24]	@ (80066e8 <cmd_sd_read+0x74>)
 80066d0:	f7fe fce6 	bl	80050a0 <f_close>
}
 80066d4:	b003      	add	sp, #12
 80066d6:	bd30      	pop	{r4, r5, pc}
    shell_printf("err: no file" VNA_SHELL_NEWLINE_STR);
 80066d8:	4805      	ldr	r0, [pc, #20]	@ (80066f0 <cmd_sd_read+0x7c>)
}
 80066da:	b003      	add	sp, #12
 80066dc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    shell_printf("err: no file" VNA_SHELL_NEWLINE_STR);
 80066e0:	f7ff bc9e 	b.w	8006020 <shell_printf>
 80066e4:	08012d64 	.word	0x08012d64
 80066e8:	200095b0 	.word	0x200095b0
 80066ec:	20008a3c 	.word	0x20008a3c
 80066f0:	08012d80 	.word	0x08012d80

080066f4 <cmd_sd_list>:
{
 80066f4:	b530      	push	{r4, r5, lr}
 80066f6:	b0a7      	sub	sp, #156	@ 0x9c
 80066f8:	4604      	mov	r4, r0
 80066fa:	460d      	mov	r5, r1
  if (cmd_sd_card_mount() != FR_OK)
 80066fc:	f7ff ff7e 	bl	80065fc <cmd_sd_card_mount>
 8006700:	b960      	cbnz	r0, 800671c <cmd_sd_list+0x28>
  switch (argc)
 8006702:	b1fc      	cbz	r4, 8006744 <cmd_sd_list+0x50>
 8006704:	2c01      	cmp	r4, #1
 8006706:	d11f      	bne.n	8006748 <cmd_sd_list+0x54>
    dj.pat = argv[0];
 8006708:	682b      	ldr	r3, [r5, #0]
  if (f_opendir(&dj, "") == FR_OK)
 800670a:	4912      	ldr	r1, [pc, #72]	@ (8006754 <cmd_sd_list+0x60>)
    dj.pat = "*.*";
 800670c:	9324      	str	r3, [sp, #144]	@ 0x90
  if (f_opendir(&dj, "") == FR_OK)
 800670e:	a810      	add	r0, sp, #64	@ 0x40
 8006710:	f7fe fcd6 	bl	80050c0 <f_opendir>
 8006714:	b178      	cbz	r0, 8006736 <cmd_sd_list+0x42>
  f_closedir(&dj);
 8006716:	a810      	add	r0, sp, #64	@ 0x40
 8006718:	f7fe fd16 	bl	8005148 <f_closedir>
}
 800671c:	b027      	add	sp, #156	@ 0x9c
 800671e:	bd30      	pop	{r4, r5, pc}
    while (f_findnext(&dj, &fno) == FR_OK && fno.fname[0])
 8006720:	f89d 301a 	ldrb.w	r3, [sp, #26]
      shell_printf("%s %u" VNA_SHELL_NEWLINE_STR, fno.fname, fno.fsize);
 8006724:	480c      	ldr	r0, [pc, #48]	@ (8006758 <cmd_sd_list+0x64>)
 8006726:	f10d 011a 	add.w	r1, sp, #26
    while (f_findnext(&dj, &fno) == FR_OK && fno.fname[0])
 800672a:	2b00      	cmp	r3, #0
 800672c:	d0f3      	beq.n	8006716 <cmd_sd_list+0x22>
      shell_printf("%s %u" VNA_SHELL_NEWLINE_STR, fno.fname, fno.fsize);
 800672e:	e9dd 2300 	ldrd	r2, r3, [sp]
 8006732:	f7ff fc75 	bl	8006020 <shell_printf>
    while (f_findnext(&dj, &fno) == FR_OK && fno.fname[0])
 8006736:	4669      	mov	r1, sp
 8006738:	a810      	add	r0, sp, #64	@ 0x40
 800673a:	f7fe fd33 	bl	80051a4 <f_findnext>
 800673e:	2800      	cmp	r0, #0
 8006740:	d0ee      	beq.n	8006720 <cmd_sd_list+0x2c>
 8006742:	e7e8      	b.n	8006716 <cmd_sd_list+0x22>
  switch (argc)
 8006744:	4b05      	ldr	r3, [pc, #20]	@ (800675c <cmd_sd_list+0x68>)
 8006746:	e7e0      	b.n	800670a <cmd_sd_list+0x16>
    shell_printf("usage: sd_list {pattern}" VNA_SHELL_NEWLINE_STR);
 8006748:	4805      	ldr	r0, [pc, #20]	@ (8006760 <cmd_sd_list+0x6c>)
}
 800674a:	b027      	add	sp, #156	@ 0x9c
 800674c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    shell_printf("usage: sd_list {pattern}" VNA_SHELL_NEWLINE_STR);
 8006750:	f7ff bc66 	b.w	8006020 <shell_printf>
 8006754:	080132e4 	.word	0x080132e4
 8006758:	08012db0 	.word	0x08012db0
 800675c:	08012d90 	.word	0x08012d90
 8006760:	08012d94 	.word	0x08012d94

08006764 <cmd_time>:
{
 8006764:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 8006768:	4b32      	ldr	r3, [pc, #200]	@ (8006834 <cmd_time+0xd0>)
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 800676a:	4d33      	ldr	r5, [pc, #204]	@ (8006838 <cmd_time+0xd4>)
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 800676c:	681e      	ldr	r6, [r3, #0]
{
 800676e:	b087      	sub	sp, #28
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 8006770:	f006 347f 	and.w	r4, r6, #2139062143	@ 0x7f7f7f7f
 8006774:	f024 44fe 	bic.w	r4, r4, #2130706432	@ 0x7f000000
 8006778:	9404      	str	r4, [sp, #16]
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 800677a:	f8d3 8004 	ldr.w	r8, [r3, #4]
  if (argc == 3 && get_str_index(argv[0], "b") == 0)
 800677e:	2803      	cmp	r0, #3
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 8006780:	ea08 0505 	and.w	r5, r8, r5
{
 8006784:	460f      	mov	r7, r1
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 8006786:	9505      	str	r5, [sp, #20]
  if (argc == 3 && get_str_index(argv[0], "b") == 0)
 8006788:	d03c      	beq.n	8006804 <cmd_time+0xa0>
  if (argc != 2)
 800678a:	2802      	cmp	r0, #2
 800678c:	d014      	beq.n	80067b8 <cmd_time+0x54>
  shell_printf("20%02x/%02x/%02x %02x:%02x:%02x" VNA_SHELL_NEWLINE_STR
 800678e:	4b2b      	ldr	r3, [pc, #172]	@ (800683c <cmd_time+0xd8>)
 8006790:	9303      	str	r3, [sp, #12]
 8006792:	f006 067f 	and.w	r6, r6, #127	@ 0x7f
 8006796:	f3c4 2306 	ubfx	r3, r4, #8, #7
 800679a:	0c24      	lsrs	r4, r4, #16
 800679c:	e9cd 3601 	strd	r3, r6, [sp, #4]
 80067a0:	9400      	str	r4, [sp, #0]
 80067a2:	f008 033f 	and.w	r3, r8, #63	@ 0x3f
 80067a6:	f3c5 2204 	ubfx	r2, r5, #8, #5
 80067aa:	0c29      	lsrs	r1, r5, #16
 80067ac:	4824      	ldr	r0, [pc, #144]	@ (8006840 <cmd_time+0xdc>)
 80067ae:	f7ff fc37 	bl	8006020 <shell_printf>
}
 80067b2:	b007      	add	sp, #28
 80067b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  int idx = get_str_index(argv[0], time_cmd);
 80067b8:	4920      	ldr	r1, [pc, #128]	@ (800683c <cmd_time+0xd8>)
 80067ba:	6838      	ldr	r0, [r7, #0]
 80067bc:	f003 f976 	bl	8009aac <get_str_index>
 80067c0:	4681      	mov	r9, r0
  if (idx == 6)
 80067c2:	f1b9 0f06 	cmp.w	r9, #6
    rtc_set_cal(my_atof(argv[1]));
 80067c6:	6878      	ldr	r0, [r7, #4]
  if (idx == 6)
 80067c8:	d02c      	beq.n	8006824 <cmd_time+0xc0>
  uint32_t val = my_atoui(argv[1]);
 80067ca:	f003 f8af 	bl	800992c <my_atoui>
  if (idx < 0 || val > 99)
 80067ce:	f1b9 0f00 	cmp.w	r9, #0
 80067d2:	dbdc      	blt.n	800678e <cmd_time+0x2a>
 80067d4:	2863      	cmp	r0, #99	@ 0x63
 80067d6:	d8da      	bhi.n	800678e <cmd_time+0x2a>
  time[idx_to_time[idx]] = ((val / 10) << 4) | (val % 10); // value in bcd format
 80067d8:	4b1a      	ldr	r3, [pc, #104]	@ (8006844 <cmd_time+0xe0>)
 80067da:	4a1b      	ldr	r2, [pc, #108]	@ (8006848 <cmd_time+0xe4>)
 80067dc:	fba3 1300 	umull	r1, r3, r3, r0
 80067e0:	08db      	lsrs	r3, r3, #3
 80067e2:	f812 2009 	ldrb.w	r2, [r2, r9]
 80067e6:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 80067ea:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 80067ee:	446a      	add	r2, sp
 80067f0:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 80067f4:	7410      	strb	r0, [r2, #16]
  rtc_set_time(dt_buf[1], dt_buf[0]);
 80067f6:	e9dd 1004 	ldrd	r1, r0, [sp, #16]
}
 80067fa:	b007      	add	sp, #28
 80067fc:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  rtc_set_time(dt_buf[1], dt_buf[0]);
 8006800:	f00b ba58 	b.w	8011cb4 <rtc_set_time>
  if (argc == 3 && get_str_index(argv[0], "b") == 0)
 8006804:	4911      	ldr	r1, [pc, #68]	@ (800684c <cmd_time+0xe8>)
 8006806:	6838      	ldr	r0, [r7, #0]
 8006808:	f003 f950 	bl	8009aac <get_str_index>
 800680c:	2800      	cmp	r0, #0
 800680e:	d1be      	bne.n	800678e <cmd_time+0x2a>
    rtc_set_time(my_atoui(argv[1]), my_atoui(argv[2]));
 8006810:	6878      	ldr	r0, [r7, #4]
 8006812:	f003 f88b 	bl	800992c <my_atoui>
 8006816:	4604      	mov	r4, r0
 8006818:	68b8      	ldr	r0, [r7, #8]
 800681a:	f003 f887 	bl	800992c <my_atoui>
 800681e:	4601      	mov	r1, r0
 8006820:	4620      	mov	r0, r4
 8006822:	e7ea      	b.n	80067fa <cmd_time+0x96>
    rtc_set_cal(my_atof(argv[1]));
 8006824:	f003 f8a8 	bl	8009978 <my_atof>
}
 8006828:	b007      	add	sp, #28
 800682a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    rtc_set_cal(my_atof(argv[1]));
 800682e:	f00b baaf 	b.w	8011d90 <rtc_set_cal>
 8006832:	bf00      	nop
 8006834:	40002800 	.word	0x40002800
 8006838:	00ff1f3f 	.word	0x00ff1f3f
 800683c:	08015ac4 	.word	0x08015ac4
 8006840:	08012dbc 	.word	0x08012dbc
 8006844:	cccccccd 	.word	0xcccccccd
 8006848:	08015abc 	.word	0x08015abc
 800684c:	08012db8 	.word	0x08012db8

08006850 <cmd_offset>:
  if (argc != 1)
 8006850:	2801      	cmp	r0, #1
{
 8006852:	b508      	push	{r3, lr}
  if (argc != 1)
 8006854:	d007      	beq.n	8006866 <cmd_offset+0x16>
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 8006856:	4b07      	ldr	r3, [pc, #28]	@ (8006874 <cmd_offset+0x24>)
 8006858:	4907      	ldr	r1, [pc, #28]	@ (8006878 <cmd_offset+0x28>)
 800685a:	689a      	ldr	r2, [r3, #8]
 800685c:	4807      	ldr	r0, [pc, #28]	@ (800687c <cmd_offset+0x2c>)
}
 800685e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("usage: %s" VNA_SHELL_NEWLINE_STR
 8006862:	f7ff bbdd 	b.w	8006020 <shell_printf>
  si5351_set_frequency_offset(my_atoi(argv[0]));
 8006866:	6808      	ldr	r0, [r1, #0]
 8006868:	f003 f846 	bl	80098f8 <my_atoi>
}
 800686c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  si5351_set_frequency_offset(my_atoi(argv[0]));
 8006870:	f003 b9ba 	b.w	8009be8 <si5351_set_frequency_offset>
 8006874:	20000318 	.word	0x20000318
 8006878:	08012e10 	.word	0x08012e10
 800687c:	08012aec 	.word	0x08012aec

08006880 <cmd_freq>:
  if (argc != 1)
 8006880:	2801      	cmp	r0, #1
 8006882:	d002      	beq.n	800688a <cmd_freq+0xa>
    shell_printf("usage: freq {frequency(Hz)}" VNA_SHELL_NEWLINE_STR);
 8006884:	4807      	ldr	r0, [pc, #28]	@ (80068a4 <cmd_freq+0x24>)
 8006886:	f7ff bbcb 	b.w	8006020 <shell_printf>
{
 800688a:	b508      	push	{r3, lr}
  uint32_t freq = my_atoui(argv[0]);
 800688c:	6808      	ldr	r0, [r1, #0]
 800688e:	f003 f84d 	bl	800992c <my_atoui>
  pause_sweep();
 8006892:	f7ff fbb3 	bl	8005ffc <pause_sweep>
  return si5351_set_frequency(freq, current_props._power);
 8006896:	4b04      	ldr	r3, [pc, #16]	@ (80068a8 <cmd_freq+0x28>)
 8006898:	7fd9      	ldrb	r1, [r3, #31]
}
 800689a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return si5351_set_frequency(freq, current_props._power);
 800689e:	f003 bb2d 	b.w	8009efc <si5351_set_frequency>
 80068a2:	bf00      	nop
 80068a4:	08012e30 	.word	0x08012e30
 80068a8:	20000aa8 	.word	0x20000aa8

080068ac <cmd_data>:
{
 80068ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (argc == 1)
 80068b0:	2801      	cmp	r0, #1
{
 80068b2:	b082      	sub	sp, #8
  if (argc == 1)
 80068b4:	d01f      	beq.n	80068f6 <cmd_data+0x4a>
 80068b6:	4c1f      	ldr	r4, [pc, #124]	@ (8006934 <cmd_data+0x88>)
 80068b8:	f8df 8084 	ldr.w	r8, [pc, #132]	@ 8006940 <cmd_data+0x94>
  for (i = 0; i < sweep_points; i++)
 80068bc:	f8b8 301a 	ldrh.w	r3, [r8, #26]
 80068c0:	b1b3      	cbz	r3, 80068f0 <cmd_data+0x44>
 80068c2:	2500      	movs	r5, #0
    shell_printf("%f %f" VNA_SHELL_NEWLINE_STR, array[i][0], array[i][1]);
 80068c4:	6820      	ldr	r0, [r4, #0]
 80068c6:	f7f9 fe6b 	bl	80005a0 <__aeabi_f2d>
 80068ca:	4606      	mov	r6, r0
 80068cc:	6860      	ldr	r0, [r4, #4]
 80068ce:	460f      	mov	r7, r1
 80068d0:	f7f9 fe66 	bl	80005a0 <__aeabi_f2d>
 80068d4:	463b      	mov	r3, r7
 80068d6:	e9cd 0100 	strd	r0, r1, [sp]
 80068da:	4632      	mov	r2, r6
 80068dc:	4816      	ldr	r0, [pc, #88]	@ (8006938 <cmd_data+0x8c>)
 80068de:	f7ff fb9f 	bl	8006020 <shell_printf>
  for (i = 0; i < sweep_points; i++)
 80068e2:	f8b8 301a 	ldrh.w	r3, [r8, #26]
 80068e6:	3501      	adds	r5, #1
 80068e8:	42ab      	cmp	r3, r5
 80068ea:	f104 0408 	add.w	r4, r4, #8
 80068ee:	dce9      	bgt.n	80068c4 <cmd_data+0x18>
}
 80068f0:	b002      	add	sp, #8
 80068f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    sel = my_atoi(argv[0]);
 80068f6:	6808      	ldr	r0, [r1, #0]
 80068f8:	f002 fffe 	bl	80098f8 <my_atoi>
  if (sel < 0 || sel >= 7)
 80068fc:	2806      	cmp	r0, #6
 80068fe:	d80b      	bhi.n	8006918 <cmd_data+0x6c>
  array = sel < 2 ? measured[sel] : cal_data[sel - 2];
 8006900:	2801      	cmp	r0, #1
 8006902:	dd0f      	ble.n	8006924 <cmd_data+0x78>
 8006904:	1e84      	subs	r4, r0, #2
 8006906:	f640 4388 	movw	r3, #3208	@ 0xc88
 800690a:	f8df 8034 	ldr.w	r8, [pc, #52]	@ 8006940 <cmd_data+0x94>
 800690e:	fb03 f404 	mul.w	r4, r3, r4
 8006912:	34d0      	adds	r4, #208	@ 0xd0
 8006914:	4444      	add	r4, r8
 8006916:	e7d1      	b.n	80068bc <cmd_data+0x10>
  shell_printf("usage: data [array]" VNA_SHELL_NEWLINE_STR);
 8006918:	4808      	ldr	r0, [pc, #32]	@ (800693c <cmd_data+0x90>)
}
 800691a:	b002      	add	sp, #8
 800691c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  shell_printf("usage: data [array]" VNA_SHELL_NEWLINE_STR);
 8006920:	f7ff bb7e 	b.w	8006020 <shell_printf>
  array = sel < 2 ? measured[sel] : cal_data[sel - 2];
 8006924:	4c03      	ldr	r4, [pc, #12]	@ (8006934 <cmd_data+0x88>)
 8006926:	f8df 8018 	ldr.w	r8, [pc, #24]	@ 8006940 <cmd_data+0x94>
 800692a:	f640 4288 	movw	r2, #3208	@ 0xc88
 800692e:	fb02 4400 	mla	r4, r2, r0, r4
 8006932:	e7c3      	b.n	80068bc <cmd_data+0x10>
 8006934:	20004f54 	.word	0x20004f54
 8006938:	08012e68 	.word	0x08012e68
 800693c:	08012e50 	.word	0x08012e50
 8006940:	20000aa8 	.word	0x20000aa8

08006944 <set_power>:
{
 8006944:	b510      	push	{r4, lr}
 8006946:	4604      	mov	r4, r0
  request_to_redraw(REDRAW_CAL_STATUS);
 8006948:	2010      	movs	r0, #16
 800694a:	f005 ff0d 	bl	800c768 <request_to_redraw>
  if (current_props._power == value)
 800694e:	4b09      	ldr	r3, [pc, #36]	@ (8006974 <set_power+0x30>)
    value = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 8006950:	2c04      	cmp	r4, #4
  if (current_props._power == value)
 8006952:	7fda      	ldrb	r2, [r3, #31]
    value = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 8006954:	bf28      	it	cs
 8006956:	24ff      	movcs	r4, #255	@ 0xff
  if (current_props._power == value)
 8006958:	42a2      	cmp	r2, r4
 800695a:	d004      	beq.n	8006966 <set_power+0x22>
  if (!(sweep_mode & SWEEP_ENABLE))
 800695c:	4a06      	ldr	r2, [pc, #24]	@ (8006978 <set_power+0x34>)
  current_props._power = value;
 800695e:	77dc      	strb	r4, [r3, #31]
  if (!(sweep_mode & SWEEP_ENABLE))
 8006960:	7813      	ldrb	r3, [r2, #0]
 8006962:	07db      	lsls	r3, r3, #31
 8006964:	d500      	bpl.n	8006968 <set_power+0x24>
}
 8006966:	bd10      	pop	{r4, pc}
    si5351_set_power(value);
 8006968:	4620      	mov	r0, r4
}
 800696a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    si5351_set_power(value);
 800696e:	f003 bc05 	b.w	800a17c <si5351_set_power>
 8006972:	bf00      	nop
 8006974:	20000aa8 	.word	0x20000aa8
 8006978:	200003c4 	.word	0x200003c4

0800697c <cmd_power>:
  if (argc != 1)
 800697c:	2801      	cmp	r0, #1
{
 800697e:	b508      	push	{r3, lr}
  if (argc != 1)
 8006980:	d006      	beq.n	8006990 <cmd_power+0x14>
                 current_props._power);
 8006982:	4b07      	ldr	r3, [pc, #28]	@ (80069a0 <cmd_power+0x24>)
    shell_printf("usage: power {0-3}|{255 - auto}" VNA_SHELL_NEWLINE_STR
 8006984:	4807      	ldr	r0, [pc, #28]	@ (80069a4 <cmd_power+0x28>)
 8006986:	7fd9      	ldrb	r1, [r3, #31]
}
 8006988:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("usage: power {0-3}|{255 - auto}" VNA_SHELL_NEWLINE_STR
 800698c:	f7ff bb48 	b.w	8006020 <shell_printf>
  set_power(my_atoi(argv[0]));
 8006990:	6808      	ldr	r0, [r1, #0]
 8006992:	f002 ffb1 	bl	80098f8 <my_atoi>
}
 8006996:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_power(my_atoi(argv[0]));
 800699a:	b2c0      	uxtb	r0, r0
 800699c:	f7ff bfd2 	b.w	8006944 <set_power>
 80069a0:	20000aa8 	.word	0x20000aa8
 80069a4:	08012e70 	.word	0x08012e70

080069a8 <capture_rle8>:
{
 80069a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80069ac:	b085      	sub	sp, #20
  uint16_t size = sizeof(config._lcd_palette);
 80069ae:	2340      	movs	r3, #64	@ 0x40
  shell_write(&screenshot_header, sizeof(screenshot_header)); // write header
 80069b0:	482b      	ldr	r0, [pc, #172]	@ (8006a60 <capture_rle8+0xb8>)
  uint16_t size = sizeof(config._lcd_palette);
 80069b2:	f8ad 300e 	strh.w	r3, [sp, #14]
  shell_write(&screenshot_header, sizeof(screenshot_header)); // write header
 80069b6:	2108      	movs	r1, #8
 80069b8:	f7fe fdac 	bl	8005514 <shell_write>
  shell_write(&size, sizeof(uint16_t));                       // write palette block size
 80069bc:	2102      	movs	r1, #2
 80069be:	f10d 000e 	add.w	r0, sp, #14
 80069c2:	f7fe fda7 	bl	8005514 <shell_write>
  shell_write(config._lcd_palette, size);                     // write palette block
 80069c6:	4827      	ldr	r0, [pc, #156]	@ (8006a64 <capture_rle8+0xbc>)
 80069c8:	f8bd 100e 	ldrh.w	r1, [sp, #14]
 80069cc:	f8df 80a4 	ldr.w	r8, [pc, #164]	@ 8006a74 <capture_rle8+0xcc>
 80069d0:	4e25      	ldr	r6, [pc, #148]	@ (8006a68 <capture_rle8+0xc0>)
 80069d2:	f7fe fd9f 	bl	8005514 <shell_write>
  for (int y = 0, idx = 0; y < LCD_HEIGHT; y++)
 80069d6:	2400      	movs	r4, #0
 80069d8:	4627      	mov	r7, r4
 80069da:	f208 35be 	addw	r5, r8, #958	@ 0x3be
 80069de:	f1a8 0940 	sub.w	r9, r8, #64	@ 0x40
    lcd_read_memory(0, y, LCD_WIDTH, 1, data); // read in 16bpp format
 80069e2:	2000      	movs	r0, #0
 80069e4:	f8cd 8000 	str.w	r8, [sp]
 80069e8:	2301      	movs	r3, #1
 80069ea:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 80069ee:	4639      	mov	r1, r7
 80069f0:	f00a f9f0 	bl	8010dd4 <lcd_read_memory>
    for (int x = 0; x < LCD_WIDTH; x++)
 80069f4:	481d      	ldr	r0, [pc, #116]	@ (8006a6c <capture_rle8+0xc4>)
 80069f6:	f100 0c01 	add.w	ip, r0, #1
 80069fa:	e004      	b.n	8006a06 <capture_rle8+0x5e>
      ((uint8_t *)data)[x] = idx; // put palette index
 80069fc:	b2e3      	uxtb	r3, r4
    for (int x = 0; x < LCD_WIDTH; x++)
 80069fe:	42a8      	cmp	r0, r5
      ((uint8_t *)data)[x] = idx; // put palette index
 8006a00:	f80c 3f01 	strb.w	r3, [ip, #1]!
    for (int x = 0; x < LCD_WIDTH; x++)
 8006a04:	d015      	beq.n	8006a32 <capture_rle8+0x8a>
      if (config._lcd_palette[idx] != data[x])
 8006a06:	eb06 0344 	add.w	r3, r6, r4, lsl #1
 8006a0a:	f830 1f02 	ldrh.w	r1, [r0, #2]!
 8006a0e:	8bdb      	ldrh	r3, [r3, #30]
 8006a10:	428b      	cmp	r3, r1
 8006a12:	d0f3      	beq.n	80069fc <capture_rle8+0x54>
 8006a14:	4b16      	ldr	r3, [pc, #88]	@ (8006a70 <capture_rle8+0xc8>)
        for (idx = 0; idx < MAX_PALETTE && config._lcd_palette[idx] != data[x]; idx++)
 8006a16:	2400      	movs	r4, #0
 8006a18:	f833 2f02 	ldrh.w	r2, [r3, #2]!
 8006a1c:	428a      	cmp	r2, r1
 8006a1e:	d0ed      	beq.n	80069fc <capture_rle8+0x54>
 8006a20:	3401      	adds	r4, #1
 8006a22:	2c20      	cmp	r4, #32
 8006a24:	d1f8      	bne.n	8006a18 <capture_rle8+0x70>
 8006a26:	2400      	movs	r4, #0
          idx = 0;
 8006a28:	4623      	mov	r3, r4
    for (int x = 0; x < LCD_WIDTH; x++)
 8006a2a:	42a8      	cmp	r0, r5
      ((uint8_t *)data)[x] = idx; // put palette index
 8006a2c:	f80c 3f01 	strb.w	r3, [ip, #1]!
    for (int x = 0; x < LCD_WIDTH; x++)
 8006a30:	d1e9      	bne.n	8006a06 <capture_rle8+0x5e>
    spi_buffer[0] = packbits((char *)data, (char *)&spi_buffer[1], LCD_WIDTH); // pack
 8006a32:	4810      	ldr	r0, [pc, #64]	@ (8006a74 <capture_rle8+0xcc>)
 8006a34:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8006a38:	f1a0 013e 	sub.w	r1, r0, #62	@ 0x3e
 8006a3c:	f003 f890 	bl	8009b60 <packbits>
    shell_write(spi_buffer, spi_buffer[0] + sizeof(uint16_t));
 8006a40:	b281      	uxth	r1, r0
    spi_buffer[0] = packbits((char *)data, (char *)&spi_buffer[1], LCD_WIDTH); // pack
 8006a42:	4603      	mov	r3, r0
    shell_write(spi_buffer, spi_buffer[0] + sizeof(uint16_t));
 8006a44:	3102      	adds	r1, #2
 8006a46:	4648      	mov	r0, r9
  for (int y = 0, idx = 0; y < LCD_HEIGHT; y++)
 8006a48:	3701      	adds	r7, #1
    spi_buffer[0] = packbits((char *)data, (char *)&spi_buffer[1], LCD_WIDTH); // pack
 8006a4a:	f8a9 3000 	strh.w	r3, [r9]
    shell_write(spi_buffer, spi_buffer[0] + sizeof(uint16_t));
 8006a4e:	f7fe fd61 	bl	8005514 <shell_write>
  for (int y = 0, idx = 0; y < LCD_HEIGHT; y++)
 8006a52:	f5b7 7fa0 	cmp.w	r7, #320	@ 0x140
 8006a56:	d1c4      	bne.n	80069e2 <capture_rle8+0x3a>
}
 8006a58:	b005      	add	sp, #20
 8006a5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006a5e:	bf00      	nop
 8006a60:	08015ccc 	.word	0x08015ccc
 8006a64:	20000336 	.word	0x20000336
 8006a68:	20000318 	.word	0x20000318
 8006a6c:	20008a7a 	.word	0x20008a7a
 8006a70:	20000334 	.word	0x20000334
 8006a74:	20008a7c 	.word	0x20008a7c

08006a78 <cmd_capture>:
  if (argc > 0)
 8006a78:	2800      	cmp	r0, #0
 8006a7a:	dc16      	bgt.n	8006aaa <cmd_capture+0x32>
{
 8006a7c:	b530      	push	{r4, r5, lr}
 8006a7e:	4d0c      	ldr	r5, [pc, #48]	@ (8006ab0 <cmd_capture+0x38>)
 8006a80:	b083      	sub	sp, #12
  for (int y = 0; y < LCD_HEIGHT; y += READ_ROWS)
 8006a82:	2400      	movs	r4, #0
    lcd_read_memory(0, y, LCD_WIDTH, READ_ROWS, (uint16_t *)spi_buffer);
 8006a84:	4621      	mov	r1, r4
 8006a86:	2302      	movs	r3, #2
 8006a88:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8006a8c:	2000      	movs	r0, #0
 8006a8e:	9500      	str	r5, [sp, #0]
 8006a90:	f00a f9a0 	bl	8010dd4 <lcd_read_memory>
  for (int y = 0; y < LCD_HEIGHT; y += READ_ROWS)
 8006a94:	3402      	adds	r4, #2
    shell_write(spi_buffer, READ_ROWS * LCD_WIDTH * sizeof(uint16_t));
 8006a96:	f44f 61f0 	mov.w	r1, #1920	@ 0x780
 8006a9a:	4628      	mov	r0, r5
 8006a9c:	f7fe fd3a 	bl	8005514 <shell_write>
  for (int y = 0; y < LCD_HEIGHT; y += READ_ROWS)
 8006aa0:	f5b4 7fa0 	cmp.w	r4, #320	@ 0x140
 8006aa4:	d1ee      	bne.n	8006a84 <cmd_capture+0xc>
}
 8006aa6:	b003      	add	sp, #12
 8006aa8:	bd30      	pop	{r4, r5, pc}
    capture_rle8();
 8006aaa:	f7ff bf7d 	b.w	80069a8 <capture_rle8>
 8006aae:	bf00      	nop
 8006ab0:	20008a3c 	.word	0x20008a3c

08006ab4 <i2s_lld_serve_rx_interrupt>:
{
 8006ab4:	b570      	push	{r4, r5, r6, lr}
  uint16_t wait = wait_count;
 8006ab6:	4d1f      	ldr	r5, [pc, #124]	@ (8006b34 <i2s_lld_serve_rx_interrupt+0x80>)
 8006ab8:	882b      	ldrh	r3, [r5, #0]
 8006aba:	b29b      	uxth	r3, r3
  if (wait == 0 || chVTGetSystemTimeX() < ready_time)
 8006abc:	2b00      	cmp	r3, #0
 8006abe:	d032      	beq.n	8006b26 <i2s_lld_serve_rx_interrupt+0x72>
 8006ac0:	491d      	ldr	r1, [pc, #116]	@ (8006b38 <i2s_lld_serve_rx_interrupt+0x84>)
 8006ac2:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8006ac6:	6809      	ldr	r1, [r1, #0]
 8006ac8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8006aca:	4291      	cmp	r1, r2
 8006acc:	d82b      	bhi.n	8006b26 <i2s_lld_serve_rx_interrupt+0x72>
  audio_sample_t *p = (flags & STM32_DMA_ISR_TCIF) ? rx_buffer + AUDIO_BUFFER_LEN : rx_buffer; // Full or Half transfer complete
 8006ace:	0782      	lsls	r2, r0, #30
  if (wait >= config._bandwidth + 2)                                                           // At this moment in buffer exist noise data, reset and wait next clean buffer
 8006ad0:	4a1a      	ldr	r2, [pc, #104]	@ (8006b3c <i2s_lld_serve_rx_interrupt+0x88>)
  audio_sample_t *p = (flags & STM32_DMA_ISR_TCIF) ? rx_buffer + AUDIO_BUFFER_LEN : rx_buffer; // Full or Half transfer complete
 8006ad2:	bf48      	it	mi
 8006ad4:	4e1a      	ldrmi	r6, [pc, #104]	@ (8006b40 <i2s_lld_serve_rx_interrupt+0x8c>)
  if (wait >= config._bandwidth + 2)                                                           // At this moment in buffer exist noise data, reset and wait next clean buffer
 8006ad6:	8b52      	ldrh	r2, [r2, #26]
  audio_sample_t *p = (flags & STM32_DMA_ISR_TCIF) ? rx_buffer + AUDIO_BUFFER_LEN : rx_buffer; // Full or Half transfer complete
 8006ad8:	bf58      	it	pl
 8006ada:	4e1a      	ldrpl	r6, [pc, #104]	@ (8006b44 <i2s_lld_serve_rx_interrupt+0x90>)
  if (wait >= config._bandwidth + 2)                                                           // At this moment in buffer exist noise data, reset and wait next clean buffer
 8006adc:	3201      	adds	r2, #1
 8006ade:	429a      	cmp	r2, r3
 8006ae0:	da22      	bge.n	8006b28 <i2s_lld_serve_rx_interrupt+0x74>
    reset_dsp_accumerator();
 8006ae2:	f003 fc8d 	bl	800a400 <reset_dsp_accumerator>
  p += dump_selection;
 8006ae6:	4b18      	ldr	r3, [pc, #96]	@ (8006b48 <i2s_lld_serve_rx_interrupt+0x94>)
 8006ae8:	4918      	ldr	r1, [pc, #96]	@ (8006b4c <i2s_lld_serve_rx_interrupt+0x98>)
 8006aea:	f9b3 3000 	ldrsh.w	r3, [r3]
    *dump_buffer++ = *p;
 8006aee:	4c18      	ldr	r4, [pc, #96]	@ (8006b50 <i2s_lld_serve_rx_interrupt+0x9c>)
  p += dump_selection;
 8006af0:	eb06 0e43 	add.w	lr, r6, r3, lsl #1
  while (n)
 8006af4:	f10e 0204 	add.w	r2, lr, #4
 8006af8:	f10e 0ec4 	add.w	lr, lr, #196	@ 0xc4
    if (dump_len == 0)
 8006afc:	880b      	ldrh	r3, [r1, #0]
 8006afe:	b21b      	sxth	r3, r3
 8006b00:	b16b      	cbz	r3, 8006b1e <i2s_lld_serve_rx_interrupt+0x6a>
    dump_len--;
 8006b02:	880b      	ldrh	r3, [r1, #0]
    *dump_buffer++ = *p;
 8006b04:	6820      	ldr	r0, [r4, #0]
 8006b06:	f932 cc04 	ldrsh.w	ip, [r2, #-4]
    dump_len--;
 8006b0a:	3b01      	subs	r3, #1
  while (n)
 8006b0c:	3204      	adds	r2, #4
    dump_len--;
 8006b0e:	b21b      	sxth	r3, r3
    *dump_buffer++ = *p;
 8006b10:	1c86      	adds	r6, r0, #2
  while (n)
 8006b12:	4596      	cmp	lr, r2
    dump_len--;
 8006b14:	800b      	strh	r3, [r1, #0]
    *dump_buffer++ = *p;
 8006b16:	6026      	str	r6, [r4, #0]
 8006b18:	f8a0 c000 	strh.w	ip, [r0]
  while (n)
 8006b1c:	d1ee      	bne.n	8006afc <i2s_lld_serve_rx_interrupt+0x48>
  --wait_count;
 8006b1e:	882b      	ldrh	r3, [r5, #0]
 8006b20:	3b01      	subs	r3, #1
 8006b22:	b29b      	uxth	r3, r3
 8006b24:	802b      	strh	r3, [r5, #0]
}
 8006b26:	bd70      	pop	{r4, r5, r6, pc}
    dsp_process(p, count);
 8006b28:	2160      	movs	r1, #96	@ 0x60
 8006b2a:	4630      	mov	r0, r6
 8006b2c:	f003 fbd2 	bl	800a2d4 <dsp_process>
 8006b30:	e7d9      	b.n	8006ae6 <i2s_lld_serve_rx_interrupt+0x32>
 8006b32:	bf00      	nop
 8006b34:	20000a98 	.word	0x20000a98
 8006b38:	20000a9c 	.word	0x20000a9c
 8006b3c:	20000318 	.word	0x20000318
 8006b40:	200009d8 	.word	0x200009d8
 8006b44:	20000918 	.word	0x20000918
 8006b48:	20000aa0 	.word	0x20000aa0
 8006b4c:	20000aa2 	.word	0x20000aa2
 8006b50:	20000aa4 	.word	0x20000aa4

08006b54 <set_bandwidth>:
  config._bandwidth = bw_count & 0x1FF;
 8006b54:	4a03      	ldr	r2, [pc, #12]	@ (8006b64 <set_bandwidth+0x10>)
 8006b56:	f3c0 0308 	ubfx	r3, r0, #0, #9
  request_to_redraw(REDRAW_BACKUP | REDRAW_FREQUENCY);
 8006b5a:	f44f 6081 	mov.w	r0, #1032	@ 0x408
  config._bandwidth = bw_count & 0x1FF;
 8006b5e:	8353      	strh	r3, [r2, #26]
  request_to_redraw(REDRAW_BACKUP | REDRAW_FREQUENCY);
 8006b60:	f005 be02 	b.w	800c768 <request_to_redraw>
 8006b64:	20000318 	.word	0x20000318

08006b68 <cmd_bandwidth>:
{
 8006b68:	b5d0      	push	{r4, r6, r7, lr}
  if (argc == 1)
 8006b6a:	2801      	cmp	r0, #1
{
 8006b6c:	b084      	sub	sp, #16
  if (argc == 1)
 8006b6e:	d030      	beq.n	8006bd2 <cmd_bandwidth+0x6a>
  else if (argc == 2)
 8006b70:	2802      	cmp	r0, #2
 8006b72:	d01e      	beq.n	8006bb2 <cmd_bandwidth+0x4a>
  uint32_t bw_hz = get_bandwidth_frequency(config._bandwidth);
 8006b74:	4b1d      	ldr	r3, [pc, #116]	@ (8006bec <cmd_bandwidth+0x84>)
  float bw_khz = (float)bw_hz / 1000.0f;
 8006b76:	eddf 7a1e 	vldr	s15, [pc, #120]	@ 8006bf0 <cmd_bandwidth+0x88>
  return (AUDIO_ADC_FREQ / AUDIO_SAMPLES_COUNT) / (bw_freq + 1);
 8006b7a:	8b5c      	ldrh	r4, [r3, #26]
 8006b7c:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 8006b80:	1c63      	adds	r3, r4, #1
 8006b82:	fbb2 f2f3 	udiv	r2, r2, r3
  float bw_khz = (float)bw_hz / 1000.0f;
 8006b86:	ee07 2a10 	vmov	s14, r2
 8006b8a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8006b8e:	9203      	str	r2, [sp, #12]
  shell_printf("bandwidth %d (%u Hz, %.2f kHz)" VNA_SHELL_NEWLINE_STR,
 8006b90:	ee67 7a27 	vmul.f32	s15, s14, s15
 8006b94:	ee17 0a90 	vmov	r0, s15
 8006b98:	f7f9 fd02 	bl	80005a0 <__aeabi_f2d>
 8006b9c:	4606      	mov	r6, r0
 8006b9e:	460f      	mov	r7, r1
 8006ba0:	e9cd 6700 	strd	r6, r7, [sp]
 8006ba4:	9a03      	ldr	r2, [sp, #12]
 8006ba6:	4813      	ldr	r0, [pc, #76]	@ (8006bf4 <cmd_bandwidth+0x8c>)
 8006ba8:	4621      	mov	r1, r4
 8006baa:	f7ff fa39 	bl	8006020 <shell_printf>
}
 8006bae:	b004      	add	sp, #16
 8006bb0:	bdd0      	pop	{r4, r6, r7, pc}
    uint16_t f = my_atoui(argv[0]);
 8006bb2:	6808      	ldr	r0, [r1, #0]
 8006bb4:	f002 feba 	bl	800992c <my_atoui>
 8006bb8:	b283      	uxth	r3, r0
    if (f > MAX_BANDWIDTH)
 8006bba:	f5b3 6f7a 	cmp.w	r3, #4000	@ 0xfa0
 8006bbe:	d80f      	bhi.n	8006be0 <cmd_bandwidth+0x78>
    else if (f < MIN_BANDWIDTH)
 8006bc0:	2b07      	cmp	r3, #7
 8006bc2:	d90f      	bls.n	8006be4 <cmd_bandwidth+0x7c>
      user_bw = ((AUDIO_ADC_FREQ + AUDIO_SAMPLES_COUNT / 2) / AUDIO_SAMPLES_COUNT) / f - 1;
 8006bc4:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 8006bc8:	fbb0 f0f3 	udiv	r0, r0, r3
 8006bcc:	3801      	subs	r0, #1
 8006bce:	b280      	uxth	r0, r0
 8006bd0:	e003      	b.n	8006bda <cmd_bandwidth+0x72>
    user_bw = my_atoui(argv[0]);
 8006bd2:	6808      	ldr	r0, [r1, #0]
 8006bd4:	f002 feaa 	bl	800992c <my_atoui>
 8006bd8:	b280      	uxth	r0, r0
  set_bandwidth(user_bw);
 8006bda:	f7ff ffbb 	bl	8006b54 <set_bandwidth>
 8006bde:	e7c9      	b.n	8006b74 <cmd_bandwidth+0xc>
      user_bw = 0;
 8006be0:	2000      	movs	r0, #0
 8006be2:	e7fa      	b.n	8006bda <cmd_bandwidth+0x72>
      user_bw = 511;
 8006be4:	f240 10ff 	movw	r0, #511	@ 0x1ff
 8006be8:	e7f7      	b.n	8006bda <cmd_bandwidth+0x72>
 8006bea:	bf00      	nop
 8006bec:	20000318 	.word	0x20000318
 8006bf0:	3a83126f 	.word	0x3a83126f
 8006bf4:	08012ea0 	.word	0x08012ea0

08006bf8 <get_bandwidth_frequency>:
  return (AUDIO_ADC_FREQ / AUDIO_SAMPLES_COUNT) / (bw_freq + 1);
 8006bf8:	f44f 637a 	mov.w	r3, #4000	@ 0xfa0
 8006bfc:	3001      	adds	r0, #1
}
 8006bfe:	fbb3 f0f0 	udiv	r0, r3, r0
 8006c02:	4770      	bx	lr

08006c04 <getFrequency>:
freq_t getFrequency(uint16_t idx) { return _f_start + _f_delta * idx + (_f_points / 2 + _f_error * idx) / _f_points; }
 8006c04:	4909      	ldr	r1, [pc, #36]	@ (8006c2c <getFrequency+0x28>)
 8006c06:	4a0a      	ldr	r2, [pc, #40]	@ (8006c30 <getFrequency+0x2c>)
 8006c08:	4b0a      	ldr	r3, [pc, #40]	@ (8006c34 <getFrequency+0x30>)
 8006c0a:	8809      	ldrh	r1, [r1, #0]
 8006c0c:	681b      	ldr	r3, [r3, #0]
 8006c0e:	6812      	ldr	r2, [r2, #0]
 8006c10:	b410      	push	{r4}
 8006c12:	4c09      	ldr	r4, [pc, #36]	@ (8006c38 <getFrequency+0x34>)
 8006c14:	6824      	ldr	r4, [r4, #0]
 8006c16:	fb02 3200 	mla	r2, r2, r0, r3
 8006c1a:	084b      	lsrs	r3, r1, #1
 8006c1c:	fb04 3300 	mla	r3, r4, r0, r3
 8006c20:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006c24:	fbb3 f3f1 	udiv	r3, r3, r1
 8006c28:	1898      	adds	r0, r3, r2
 8006c2a:	4770      	bx	lr
 8006c2c:	20000908 	.word	0x20000908
 8006c30:	20000910 	.word	0x20000910
 8006c34:	20000914 	.word	0x20000914
 8006c38:	2000090c 	.word	0x2000090c

08006c3c <sweep>:
{
 8006c3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (p_sweep >= sweep_points || break_on_operation == false)
 8006c40:	4d8f      	ldr	r5, [pc, #572]	@ (8006e80 <sweep+0x244>)
 8006c42:	4c90      	ldr	r4, [pc, #576]	@ (8006e84 <sweep+0x248>)
 8006c44:	8b6a      	ldrh	r2, [r5, #26]
 8006c46:	8823      	ldrh	r3, [r4, #0]
{
 8006c48:	ed2d 8b08 	vpush	{d8-d11}
 8006c4c:	b099      	sub	sp, #100	@ 0x64
  if (p_sweep >= sweep_points || break_on_operation == false)
 8006c4e:	429a      	cmp	r2, r3
{
 8006c50:	9002      	str	r0, [sp, #8]
 8006c52:	460f      	mov	r7, r1
  if (p_sweep >= sweep_points || break_on_operation == false)
 8006c54:	d966      	bls.n	8006d24 <sweep+0xe8>
 8006c56:	2800      	cmp	r0, #0
 8006c58:	d064      	beq.n	8006d24 <sweep+0xe8>
  palClearPad(GPIOC, GPIOC_LED);
 8006c5a:	4b8b      	ldr	r3, [pc, #556]	@ (8006e88 <sweep+0x24c>)
  float offset = vna_expf(s21_offset * (logf(10.0f) / 20.0f));
 8006c5c:	ed95 0a2a 	vldr	s0, [r5, #168]	@ 0xa8
 8006c60:	eddf 7a8a 	vldr	s15, [pc, #552]	@ 8006e8c <sweep+0x250>
  palClearPad(GPIOC, GPIOC_LED);
 8006c64:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 8006c68:	619a      	str	r2, [r3, #24]
  float offset = vna_expf(s21_offset * (logf(10.0f) / 20.0f));
 8006c6a:	ee20 0a27 	vmul.f32	s0, s0, s15
 8006c6e:	f00b fbf5 	bl	801245c <vna_expf>
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 8006c72:	2011      	movs	r0, #17
  float offset = vna_expf(s21_offset * (logf(10.0f) / 20.0f));
 8006c74:	eeb0 9a40 	vmov.f32	s18, s0
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 8006c78:	f00a fa12 	bl	80110a0 <lcd_set_background>
  for (; p_sweep < sweep_points; p_sweep++)
 8006c7c:	8b6b      	ldrh	r3, [r5, #26]
 8006c7e:	8820      	ldrh	r0, [r4, #0]
 8006c80:	4283      	cmp	r3, r0
 8006c82:	d942      	bls.n	8006d0a <sweep+0xce>
 8006c84:	f007 0303 	and.w	r3, r7, #3
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006c88:	f007 0240 	and.w	r2, r7, #64	@ 0x40
 8006c8c:	f8df a20c 	ldr.w	sl, [pc, #524]	@ 8006e9c <sweep+0x260>
 8006c90:	9203      	str	r2, [sp, #12]
  int bar_start = 0;
 8006c92:	f04f 0b00 	mov.w	fp, #0
  int st_delay = DELAY_SWEEP_START;
 8006c96:	f04f 09c8 	mov.w	r9, #200	@ 0xc8
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006c9a:	4698      	mov	r8, r3
    if (mask & (SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE))
 8006c9c:	f1b8 0f00 	cmp.w	r8, #0
 8006ca0:	d143      	bne.n	8006d2a <sweep+0xee>
    if (operation_requested && break_on_operation)
 8006ca2:	f89a 3000 	ldrb.w	r3, [sl]
 8006ca6:	b10b      	cbz	r3, 8006cac <sweep+0x70>
 8006ca8:	9b02      	ldr	r3, [sp, #8]
 8006caa:	bb03      	cbnz	r3, 8006cee <sweep+0xb2>
    if (config._bandwidth >= BANDWIDTH_100)
 8006cac:	4b78      	ldr	r3, [pc, #480]	@ (8006e90 <sweep+0x254>)
      int current_bar = (p_sweep * WIDTH) / (sweep_points - 1);
 8006cae:	8820      	ldrh	r0, [r4, #0]
    if (config._bandwidth >= BANDWIDTH_100)
 8006cb0:	8b5a      	ldrh	r2, [r3, #26]
      int current_bar = (p_sweep * WIDTH) / (sweep_points - 1);
 8006cb2:	8b6b      	ldrh	r3, [r5, #26]
    if (config._bandwidth >= BANDWIDTH_100)
 8006cb4:	2a26      	cmp	r2, #38	@ 0x26
 8006cb6:	d913      	bls.n	8006ce0 <sweep+0xa4>
      int current_bar = (p_sweep * WIDTH) / (sweep_points - 1);
 8006cb8:	ebc0 06c0 	rsb	r6, r0, r0, lsl #3
 8006cbc:	1e5a      	subs	r2, r3, #1
 8006cbe:	eb06 1686 	add.w	r6, r6, r6, lsl #6
 8006cc2:	fb96 f6f2 	sdiv	r6, r6, r2
      if (current_bar - bar_start > 0)
 8006cc6:	eba6 020b 	sub.w	r2, r6, fp
 8006cca:	2a00      	cmp	r2, #0
 8006ccc:	dd08      	ble.n	8006ce0 <sweep+0xa4>
        lcd_fill(OFFSETX + CELLOFFSETX + bar_start, OFFSETY, current_bar - bar_start, 1);
 8006cce:	f10b 0014 	add.w	r0, fp, #20
 8006cd2:	2301      	movs	r3, #1
 8006cd4:	2100      	movs	r1, #0
 8006cd6:	f00a f8e9 	bl	8010eac <lcd_fill>
  for (; p_sweep < sweep_points; p_sweep++)
 8006cda:	8820      	ldrh	r0, [r4, #0]
 8006cdc:	8b6b      	ldrh	r3, [r5, #26]
        bar_start = current_bar;
 8006cde:	46b3      	mov	fp, r6
  for (; p_sweep < sweep_points; p_sweep++)
 8006ce0:	3001      	adds	r0, #1
 8006ce2:	b280      	uxth	r0, r0
 8006ce4:	4298      	cmp	r0, r3
 8006ce6:	8020      	strh	r0, [r4, #0]
 8006ce8:	f04f 0900 	mov.w	r9, #0
 8006cec:	d3d6      	bcc.n	8006c9c <sweep+0x60>
  if (bar_start)
 8006cee:	f1bb 0f00 	cmp.w	fp, #0
 8006cf2:	d008      	beq.n	8006d06 <sweep+0xca>
    lcd_set_background(LCD_GRID_COLOR);
 8006cf4:	2002      	movs	r0, #2
 8006cf6:	f00a f9d3 	bl	80110a0 <lcd_set_background>
    lcd_fill(OFFSETX + CELLOFFSETX, OFFSETY, bar_start, 1);
 8006cfa:	2301      	movs	r3, #1
 8006cfc:	2100      	movs	r1, #0
 8006cfe:	465a      	mov	r2, fp
 8006d00:	2014      	movs	r0, #20
 8006d02:	f00a f8d3 	bl	8010eac <lcd_fill>
  return p_sweep == sweep_points;
 8006d06:	8b6b      	ldrh	r3, [r5, #26]
 8006d08:	8820      	ldrh	r0, [r4, #0]
  palSetPad(GPIOC, GPIOC_LED);
 8006d0a:	4a5f      	ldr	r2, [pc, #380]	@ (8006e88 <sweep+0x24c>)
}
 8006d0c:	1a18      	subs	r0, r3, r0
 8006d0e:	fab0 f080 	clz	r0, r0
  palSetPad(GPIOC, GPIOC_LED);
 8006d12:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
}
 8006d16:	0940      	lsrs	r0, r0, #5
  palSetPad(GPIOC, GPIOC_LED);
 8006d18:	6191      	str	r1, [r2, #24]
}
 8006d1a:	b019      	add	sp, #100	@ 0x64
 8006d1c:	ecbd 8b08 	vpop	{d8-d11}
 8006d20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    RESET_SWEEP;
 8006d24:	2300      	movs	r3, #0
 8006d26:	8023      	strh	r3, [r4, #0]
  if (break_on_operation && mask == 0)
 8006d28:	e797      	b.n	8006c5a <sweep+0x1e>
    freq_t frequency = getFrequency(p_sweep);
 8006d2a:	f7ff ff6b 	bl	8006c04 <getFrequency>
  return si5351_set_frequency(freq, current_props._power);
 8006d2e:	7fe9      	ldrb	r1, [r5, #31]
    freq_t frequency = getFrequency(p_sweep);
 8006d30:	9001      	str	r0, [sp, #4]
  return si5351_set_frequency(freq, current_props._power);
 8006d32:	f003 f8e3 	bl	8009efc <si5351_set_frequency>
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006d36:	9b03      	ldr	r3, [sp, #12]
  return si5351_set_frequency(freq, current_props._power);
 8006d38:	4606      	mov	r6, r0
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006d3a:	2b00      	cmp	r3, #0
 8006d3c:	d154      	bne.n	8006de8 <sweep+0x1ac>
    if (mask & SWEEP_CH0_MEASURE)
 8006d3e:	f017 0101 	ands.w	r1, r7, #1
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006d42:	8822      	ldrh	r2, [r4, #0]
    if (mask & SWEEP_CH0_MEASURE)
 8006d44:	9104      	str	r1, [sp, #16]
 8006d46:	f007 0302 	and.w	r3, r7, #2
 8006d4a:	d155      	bne.n	8006df8 <sweep+0x1bc>
    if (mask & SWEEP_CH1_MEASURE)
 8006d4c:	2b00      	cmp	r3, #0
 8006d4e:	d0a8      	beq.n	8006ca2 <sweep+0x66>
      tlv320aic3204_select(1);
 8006d50:	2001      	movs	r0, #1
 8006d52:	9205      	str	r2, [sp, #20]
 8006d54:	f003 fa5c 	bl	800a210 <tlv320aic3204_select>
 8006d58:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
      DSP_START(delay + st_delay);
 8006d5c:	4b4c      	ldr	r3, [pc, #304]	@ (8006e90 <sweep+0x254>)
 8006d5e:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8006d60:	8b5b      	ldrh	r3, [r3, #26]
 8006d62:	484c      	ldr	r0, [pc, #304]	@ (8006e94 <sweep+0x258>)
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8006d64:	9a05      	ldr	r2, [sp, #20]
      DSP_START(delay + st_delay);
 8006d66:	4449      	add	r1, r9
 8006d68:	4431      	add	r1, r6
 8006d6a:	3302      	adds	r3, #2
 8006d6c:	4e4a      	ldr	r6, [pc, #296]	@ (8006e98 <sweep+0x25c>)
 8006d6e:	6001      	str	r1, [r0, #0]
 8006d70:	b29b      	uxth	r3, r3
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8006d72:	f017 0f20 	tst.w	r7, #32
      DSP_START(delay + st_delay);
 8006d76:	8033      	strh	r3, [r6, #0]
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8006d78:	f040 8175 	bne.w	8007066 <sweep+0x42a>
      DSP_WAIT;
 8006d7c:	8833      	ldrh	r3, [r6, #0]
 8006d7e:	b29b      	uxth	r3, r3
 8006d80:	f04f 0900 	mov.w	r9, #0
 8006d84:	2b00      	cmp	r3, #0
 8006d86:	f000 81db 	beq.w	8007140 <sweep+0x504>
 8006d8a:	bf30      	wfi
 8006d8c:	8833      	ldrh	r3, [r6, #0]
 8006d8e:	b29b      	uxth	r3, r3
 8006d90:	2b00      	cmp	r3, #0
 8006d92:	d1fa      	bne.n	8006d8a <sweep+0x14e>
      (*sample_func)(&data[2]);           // Measure transmission coefficient
 8006d94:	a80c      	add	r0, sp, #48	@ 0x30
 8006d96:	f003 faeb 	bl	800a370 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8006d9a:	f1b9 0f00 	cmp.w	r9, #0
 8006d9e:	f040 8084 	bne.w	8006eaa <sweep+0x26e>
    if (p_sweep < SWEEP_POINTS_MAX)
 8006da2:	8823      	ldrh	r3, [r4, #0]
 8006da4:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 8006da8:	f63f af7b 	bhi.w	8006ca2 <sweep+0x66>
      if (mask & SWEEP_CH0_MEASURE)
 8006dac:	9a04      	ldr	r2, [sp, #16]
 8006dae:	2a00      	cmp	r2, #0
 8006db0:	f040 80d8 	bne.w	8006f64 <sweep+0x328>
  float real = data[0];
 8006db4:	eddd 8a0c 	vldr	s17, [sp, #48]	@ 0x30
  float imag = data[1];
 8006db8:	ed9d 8a0d 	vldr	s16, [sp, #52]	@ 0x34
        if (mask & SWEEP_APPLY_EDELAY_S21)
 8006dbc:	f8df 90e0 	ldr.w	r9, [pc, #224]	@ 8006ea0 <sweep+0x264>
 8006dc0:	073a      	lsls	r2, r7, #28
 8006dc2:	f100 80e8 	bmi.w	8006f96 <sweep+0x35a>
        if (mask & SWEEP_APPLY_S21_OFFSET)
 8006dc6:	06fb      	lsls	r3, r7, #27
 8006dc8:	f100 8108 	bmi.w	8006fdc <sweep+0x3a0>
        measured[1][p_sweep][0] = data[2];
 8006dcc:	8823      	ldrh	r3, [r4, #0]
 8006dce:	f203 1291 	addw	r2, r3, #401	@ 0x191
        measured[1][p_sweep][1] = data[3];
 8006dd2:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 8006dd6:	f603 438c 	addw	r3, r3, #3212	@ 0xc8c
        measured[1][p_sweep][0] = data[2];
 8006dda:	eb09 09c2 	add.w	r9, r9, r2, lsl #3
 8006dde:	edc9 8a00 	vstr	s17, [r9]
        measured[1][p_sweep][1] = data[3];
 8006de2:	ed83 8a00 	vstr	s16, [r3]
 8006de6:	e75c      	b.n	8006ca2 <sweep+0x66>
    if (mask & SWEEP_CH0_MEASURE)
 8006de8:	f017 0101 	ands.w	r1, r7, #1
      interpolation_idx = mask & SWEEP_USE_INTERPOLATION ? -1 : p_sweep;
 8006dec:	f04f 32ff 	mov.w	r2, #4294967295
    if (mask & SWEEP_CH0_MEASURE)
 8006df0:	f007 0302 	and.w	r3, r7, #2
 8006df4:	9104      	str	r1, [sp, #16]
 8006df6:	d0a9      	beq.n	8006d4c <sweep+0x110>
      tlv320aic3204_select(0);
 8006df8:	2000      	movs	r0, #0
 8006dfa:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8006dfe:	f003 fa07 	bl	800a210 <tlv320aic3204_select>
 8006e02:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
      DSP_START(delay + st_delay);
 8006e06:	4b22      	ldr	r3, [pc, #136]	@ (8006e90 <sweep+0x254>)
 8006e08:	6a48      	ldr	r0, [r1, #36]	@ 0x24
 8006e0a:	8b59      	ldrh	r1, [r3, #26]
 8006e0c:	4b21      	ldr	r3, [pc, #132]	@ (8006e94 <sweep+0x258>)
 8006e0e:	4448      	add	r0, r9
 8006e10:	4430      	add	r0, r6
 8006e12:	3102      	adds	r1, #2
 8006e14:	4e20      	ldr	r6, [pc, #128]	@ (8006e98 <sweep+0x25c>)
 8006e16:	6018      	str	r0, [r3, #0]
 8006e18:	b289      	uxth	r1, r1
      if (mask & SWEEP_APPLY_CALIBRATION)
 8006e1a:	f017 0320 	ands.w	r3, r7, #32
 8006e1e:	9307      	str	r3, [sp, #28]
      DSP_START(delay + st_delay);
 8006e20:	8031      	strh	r1, [r6, #0]
      if (mask & SWEEP_APPLY_CALIBRATION)
 8006e22:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
 8006e26:	f040 8133 	bne.w	8007090 <sweep+0x454>
      DSP_WAIT;
 8006e2a:	8832      	ldrh	r2, [r6, #0]
 8006e2c:	b292      	uxth	r2, r2
 8006e2e:	2a00      	cmp	r2, #0
 8006e30:	f000 818c 	beq.w	800714c <sweep+0x510>
 8006e34:	bf30      	wfi
 8006e36:	8832      	ldrh	r2, [r6, #0]
 8006e38:	b292      	uxth	r2, r2
 8006e3a:	2a00      	cmp	r2, #0
 8006e3c:	d1fa      	bne.n	8006e34 <sweep+0x1f8>
      (*sample_func)(&data[0]);           // calculate reflection coefficient
 8006e3e:	a80a      	add	r0, sp, #40	@ 0x28
 8006e40:	9305      	str	r3, [sp, #20]
 8006e42:	f003 fa95 	bl	800a370 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8006e46:	9a07      	ldr	r2, [sp, #28]
 8006e48:	9b05      	ldr	r3, [sp, #20]
 8006e4a:	2a00      	cmp	r2, #0
 8006e4c:	f040 8139 	bne.w	80070c2 <sweep+0x486>
    if (mask & SWEEP_CH1_MEASURE)
 8006e50:	2b00      	cmp	r3, #0
 8006e52:	f040 8181 	bne.w	8007158 <sweep+0x51c>
    if (p_sweep < SWEEP_POINTS_MAX)
 8006e56:	8823      	ldrh	r3, [r4, #0]
 8006e58:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 8006e5c:	f63f af21 	bhi.w	8006ca2 <sweep+0x66>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006e60:	077e      	lsls	r6, r7, #29
  float real = data[0];
 8006e62:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
  float imag = data[1];
 8006e66:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006e6a:	f100 816d 	bmi.w	8007148 <sweep+0x50c>
        measured[0][p_sweep][0] = data[0];
 8006e6e:	f8df 9030 	ldr.w	r9, [pc, #48]	@ 8006ea0 <sweep+0x264>
 8006e72:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 8006e76:	ed83 ba00 	vstr	s22, [r3]
        measured[0][p_sweep][1] = data[1];
 8006e7a:	edc3 aa01 	vstr	s21, [r3, #4]
      if (mask & SWEEP_CH1_MEASURE)
 8006e7e:	e710      	b.n	8006ca2 <sweep+0x66>
 8006e80:	20000aa8 	.word	0x20000aa8
 8006e84:	20006864 	.word	0x20006864
 8006e88:	48000800 	.word	0x48000800
 8006e8c:	3debc8e3 	.word	0x3debc8e3
 8006e90:	20000318 	.word	0x20000318
 8006e94:	20000a9c 	.word	0x20000a9c
 8006e98:	20000a98 	.word	0x20000a98
 8006e9c:	20008a23 	.word	0x20008a23
 8006ea0:	20004f54 	.word	0x20004f54
      (*sample_func)(&data[2]);           // Measure transmission coefficient
 8006ea4:	a80c      	add	r0, sp, #48	@ 0x30
 8006ea6:	f003 fa63 	bl	800a370 <calculate_gamma>
  float s21mr = data[2] - c_data[ETERM_EX][0];
 8006eaa:	ed9d 7a0c 	vldr	s14, [sp, #48]	@ 0x30
 8006eae:	eddd 6a16 	vldr	s13, [sp, #88]	@ 0x58
  float s21mi = data[3] - c_data[ETERM_EX][1];
 8006eb2:	eddd 7a0d 	vldr	s15, [sp, #52]	@ 0x34
 8006eb6:	eddd 5a17 	vldr	s11, [sp, #92]	@ 0x5c
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006eba:	ed9d 6a14 	vldr	s12, [sp, #80]	@ 0x50
  if (cal_status & CALSTAT_ENHANCED_RESPONSE)
 8006ebe:	8caa      	ldrh	r2, [r5, #36]	@ 0x24
    if (p_sweep < SWEEP_POINTS_MAX)
 8006ec0:	8823      	ldrh	r3, [r4, #0]
  float s21mr = data[2] - c_data[ETERM_EX][0];
 8006ec2:	ee37 7a66 	vsub.f32	s14, s14, s13
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006ec6:	eddd 6a15 	vldr	s13, [sp, #84]	@ 0x54
  float s21mi = data[3] - c_data[ETERM_EX][1];
 8006eca:	ee77 7ae5 	vsub.f32	s15, s15, s11
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 8006ece:	ee27 8a26 	vmul.f32	s16, s14, s13
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006ed2:	ee67 5a06 	vmul.f32	s11, s14, s12
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 8006ed6:	eea7 8a86 	vfma.f32	s16, s15, s12
  if (cal_status & CALSTAT_ENHANCED_RESPONSE)
 8006eda:	0551      	lsls	r1, r2, #21
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006edc:	ee67 6aa6 	vmul.f32	s13, s15, s13
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 8006ee0:	ed8d 8a0d 	vstr	s16, [sp, #52]	@ 0x34
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006ee4:	ee75 8ae6 	vsub.f32	s17, s11, s13
  data[3] = s21mi * c_data[ETERM_ET][0] + s21mr * c_data[ETERM_ET][1];
 8006ee8:	eef0 7a48 	vmov.f32	s15, s16
  data[2] = s21mr * c_data[ETERM_ET][0] - s21mi * c_data[ETERM_ET][1];
 8006eec:	edcd 8a0c 	vstr	s17, [sp, #48]	@ 0x30
 8006ef0:	eeb0 7a68 	vmov.f32	s14, s17
  if (cal_status & CALSTAT_ENHANCED_RESPONSE)
 8006ef4:	d57b      	bpl.n	8006fee <sweep+0x3b2>
    float esr = 1.0f - (c_data[ETERM_ES][0] * data[0] - c_data[ETERM_ES][1] * data[1]);
 8006ef6:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
 8006efa:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
 8006efe:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8006f02:	eeea 7aa9 	vfma.f32	s15, s21, s19
    if (p_sweep < SWEEP_POINTS_MAX)
 8006f06:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
    float esi = 0.0f - (c_data[ETERM_ES][1] * data[0] + c_data[ETERM_ES][0] * data[1]);
 8006f0a:	ee2a 7a8a 	vmul.f32	s14, s21, s20
    float esr = 1.0f - (c_data[ETERM_ES][0] * data[0] - c_data[ETERM_ES][1] * data[1]);
 8006f0e:	eeeb 7a4a 	vfms.f32	s15, s22, s20
    float esi = 0.0f - (c_data[ETERM_ES][1] * data[0] + c_data[ETERM_ES][0] * data[1]);
 8006f12:	eeab 7a29 	vfma.f32	s14, s22, s19
    data[3] = esi * re + esr * im;
 8006f16:	ee76 6ae5 	vsub.f32	s13, s13, s11
    data[2] = esr * re - esi * im;
 8006f1a:	ee28 6a07 	vmul.f32	s12, s16, s14
    data[3] = esi * re + esr * im;
 8006f1e:	ee68 5a27 	vmul.f32	s11, s16, s15
    data[2] = esr * re - esi * im;
 8006f22:	eea8 6aa7 	vfma.f32	s12, s17, s15
    data[3] = esi * re + esr * im;
 8006f26:	eee7 5a26 	vfma.f32	s11, s14, s13
    data[2] = esr * re - esi * im;
 8006f2a:	eef0 8a46 	vmov.f32	s17, s12
    data[3] = esi * re + esr * im;
 8006f2e:	eeb0 8a65 	vmov.f32	s16, s11
 8006f32:	edcd 5a0d 	vstr	s11, [sp, #52]	@ 0x34
    data[2] = esr * re - esi * im;
 8006f36:	ed8d 6a0c 	vstr	s12, [sp, #48]	@ 0x30
    if (p_sweep < SWEEP_POINTS_MAX)
 8006f3a:	f63f aeb2 	bhi.w	8006ca2 <sweep+0x66>
      if (mask & SWEEP_CH0_MEASURE)
 8006f3e:	9a04      	ldr	r2, [sp, #16]
 8006f40:	2a00      	cmp	r2, #0
 8006f42:	f43f af3b 	beq.w	8006dbc <sweep+0x180>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006f46:	0779      	lsls	r1, r7, #29
 8006f48:	d45f      	bmi.n	800700a <sweep+0x3ce>
        measured[0][p_sweep][0] = data[0];
 8006f4a:	f8df 922c 	ldr.w	r9, [pc, #556]	@ 8007178 <sweep+0x53c>
 8006f4e:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 8006f52:	eeb0 7a46 	vmov.f32	s14, s12
 8006f56:	eef0 7a65 	vmov.f32	s15, s11
 8006f5a:	ed83 ba00 	vstr	s22, [r3]
        measured[0][p_sweep][1] = data[1];
 8006f5e:	edc3 aa01 	vstr	s21, [r3, #4]
      if (mask & SWEEP_CH1_MEASURE)
 8006f62:	e011      	b.n	8006f88 <sweep+0x34c>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006f64:	077a      	lsls	r2, r7, #29
  float real = data[0];
 8006f66:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
  float imag = data[1];
 8006f6a:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006f6e:	d44c      	bmi.n	800700a <sweep+0x3ce>
        measured[0][p_sweep][0] = data[0];
 8006f70:	ed9d 7a0c 	vldr	s14, [sp, #48]	@ 0x30
 8006f74:	eddd 7a0d 	vldr	s15, [sp, #52]	@ 0x34
 8006f78:	f8df 91fc 	ldr.w	r9, [pc, #508]	@ 8007178 <sweep+0x53c>
 8006f7c:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
 8006f80:	ed83 ba00 	vstr	s22, [r3]
        measured[0][p_sweep][1] = data[1];
 8006f84:	edc3 aa01 	vstr	s21, [r3, #4]
        if (mask & SWEEP_APPLY_EDELAY_S21)
 8006f88:	073a      	lsls	r2, r7, #28
  float real = data[0];
 8006f8a:	eef0 8a47 	vmov.f32	s17, s14
  float imag = data[1];
 8006f8e:	eeb0 8a67 	vmov.f32	s16, s15
        if (mask & SWEEP_APPLY_EDELAY_S21)
 8006f92:	f57f af18 	bpl.w	8006dc6 <sweep+0x18a>
          applyEDelay(electrical_delayS21 * frequency, &data[2]); // Apply e-delay
 8006f96:	eddd 7a01 	vldr	s15, [sp, #4]
 8006f9a:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8006f9e:	edd5 7a28 	vldr	s15, [r5, #160]	@ 0xa0
  vna_sincosf(w, &s, &c);
 8006fa2:	a909      	add	r1, sp, #36	@ 0x24
 8006fa4:	ee20 0a27 	vmul.f32	s0, s0, s15
 8006fa8:	a808      	add	r0, sp, #32
 8006faa:	f00b f8ff 	bl	80121ac <vna_sincosf>
  data[0] = real * c - imag * s;
 8006fae:	ed9d 7a08 	vldr	s14, [sp, #32]
 8006fb2:	eddd 6a09 	vldr	s13, [sp, #36]	@ 0x24
 8006fb6:	ee68 7a47 	vnmul.f32	s15, s16, s14
  data[1] = imag * c + real * s;
 8006fba:	ee27 7a28 	vmul.f32	s14, s14, s17
  data[0] = real * c - imag * s;
 8006fbe:	eee6 7aa8 	vfma.f32	s15, s13, s17
        if (mask & SWEEP_APPLY_S21_OFFSET)
 8006fc2:	06fb      	lsls	r3, r7, #27
  data[1] = imag * c + real * s;
 8006fc4:	eea6 7a88 	vfma.f32	s14, s13, s16
}
 8006fc8:	eef0 8a67 	vmov.f32	s17, s15
  data[1] = imag * c + real * s;
 8006fcc:	eeb0 8a47 	vmov.f32	s16, s14
  data[0] = real * c - imag * s;
 8006fd0:	edcd 7a0c 	vstr	s15, [sp, #48]	@ 0x30
  data[1] = imag * c + real * s;
 8006fd4:	ed8d 7a0d 	vstr	s14, [sp, #52]	@ 0x34
        if (mask & SWEEP_APPLY_S21_OFFSET)
 8006fd8:	f57f aef8 	bpl.w	8006dcc <sweep+0x190>
  data[0] *= offset;
 8006fdc:	ee68 8a89 	vmul.f32	s17, s17, s18
  data[1] *= offset;
 8006fe0:	ee28 8a09 	vmul.f32	s16, s16, s18
  data[0] *= offset;
 8006fe4:	edcd 8a0c 	vstr	s17, [sp, #48]	@ 0x30
  data[1] *= offset;
 8006fe8:	ed8d 8a0d 	vstr	s16, [sp, #52]	@ 0x34
}
 8006fec:	e6ee      	b.n	8006dcc <sweep+0x190>
    if (p_sweep < SWEEP_POINTS_MAX)
 8006fee:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 8006ff2:	f63f ae56 	bhi.w	8006ca2 <sweep+0x66>
      if (mask & SWEEP_CH0_MEASURE)
 8006ff6:	9a04      	ldr	r2, [sp, #16]
 8006ff8:	2a00      	cmp	r2, #0
 8006ffa:	f43f aedf 	beq.w	8006dbc <sweep+0x180>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8006ffe:	0778      	lsls	r0, r7, #29
    float esr = 1.0f - (c_data[ETERM_ES][0] * data[0] - c_data[ETERM_ES][1] * data[1]);
 8007000:	ed9d ba0a 	vldr	s22, [sp, #40]	@ 0x28
 8007004:	eddd aa0b 	vldr	s21, [sp, #44]	@ 0x2c
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8007008:	d5b6      	bpl.n	8006f78 <sweep+0x33c>
 800700a:	2602      	movs	r6, #2
  vna_sincosf(w, &s, &c);
 800700c:	eddd 7a01 	vldr	s15, [sp, #4]
          applyEDelay(electrical_delayS11 * frequency, &data[0]); // Apply e-delay
 8007010:	ed95 0a27 	vldr	s0, [r5, #156]	@ 0x9c
  vna_sincosf(w, &s, &c);
 8007014:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007018:	a909      	add	r1, sp, #36	@ 0x24
 800701a:	ee27 0a80 	vmul.f32	s0, s15, s0
 800701e:	a808      	add	r0, sp, #32
 8007020:	f00b f8c4 	bl	80121ac <vna_sincosf>
  data[0] = real * c - imag * s;
 8007024:	eddd 7a08 	vldr	s15, [sp, #32]
 8007028:	eddd 6a09 	vldr	s13, [sp, #36]	@ 0x24
        measured[0][p_sweep][0] = data[0];
 800702c:	4a52      	ldr	r2, [pc, #328]	@ (8007178 <sweep+0x53c>)
 800702e:	8823      	ldrh	r3, [r4, #0]
  data[0] = real * c - imag * s;
 8007030:	ee27 7aea 	vnmul.f32	s14, s15, s21
  data[1] = imag * c + real * s;
 8007034:	ee6b 7a27 	vmul.f32	s15, s22, s15
  data[0] = real * c - imag * s;
 8007038:	eeab 7a26 	vfma.f32	s14, s22, s13
        measured[0][p_sweep][0] = data[0];
 800703c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8007040:	4691      	mov	r9, r2
  data[1] = imag * c + real * s;
 8007042:	eeea 7aa6 	vfma.f32	s15, s21, s13
  data[0] = real * c - imag * s;
 8007046:	ed8d 7a0a 	vstr	s14, [sp, #40]	@ 0x28
  data[1] = imag * c + real * s;
 800704a:	edcd 7a0b 	vstr	s15, [sp, #44]	@ 0x2c
        measured[0][p_sweep][0] = data[0];
 800704e:	ed83 7a00 	vstr	s14, [r3]
        measured[0][p_sweep][1] = data[1];
 8007052:	edc3 7a01 	vstr	s15, [r3, #4]
      if (mask & SWEEP_CH1_MEASURE)
 8007056:	2e00      	cmp	r6, #0
 8007058:	f43f ae23 	beq.w	8006ca2 <sweep+0x66>
 800705c:	ed9d 7a0c 	vldr	s14, [sp, #48]	@ 0x30
 8007060:	eddd 7a0d 	vldr	s15, [sp, #52]	@ 0x34
 8007064:	e790      	b.n	8006f88 <sweep+0x34c>
        cal_interpolate(interpolation_idx, frequency, c_data);
 8007066:	4610      	mov	r0, r2
 8007068:	9901      	ldr	r1, [sp, #4]
 800706a:	ed8d aa10 	vstr	s20, [sp, #64]	@ 0x40
 800706e:	aa0e      	add	r2, sp, #56	@ 0x38
 8007070:	edcd 9a11 	vstr	s19, [sp, #68]	@ 0x44
 8007074:	f7fe fac6 	bl	8005604 <cal_interpolate>
 8007078:	ed9d aa10 	vldr	s20, [sp, #64]	@ 0x40
 800707c:	eddd 9a11 	vldr	s19, [sp, #68]	@ 0x44
      DSP_WAIT;
 8007080:	8833      	ldrh	r3, [r6, #0]
 8007082:	b29b      	uxth	r3, r3
 8007084:	2b00      	cmp	r3, #0
 8007086:	f43f af0d 	beq.w	8006ea4 <sweep+0x268>
 800708a:	f04f 0920 	mov.w	r9, #32
 800708e:	e67c      	b.n	8006d8a <sweep+0x14e>
        cal_interpolate(interpolation_idx, frequency, c_data);
 8007090:	4610      	mov	r0, r2
 8007092:	9901      	ldr	r1, [sp, #4]
 8007094:	9305      	str	r3, [sp, #20]
 8007096:	aa0e      	add	r2, sp, #56	@ 0x38
 8007098:	ed8d aa10 	vstr	s20, [sp, #64]	@ 0x40
 800709c:	edcd 9a11 	vstr	s19, [sp, #68]	@ 0x44
 80070a0:	f7fe fab0 	bl	8005604 <cal_interpolate>
      DSP_WAIT;
 80070a4:	8832      	ldrh	r2, [r6, #0]
        cal_interpolate(interpolation_idx, frequency, c_data);
 80070a6:	ed9d aa10 	vldr	s20, [sp, #64]	@ 0x40
 80070aa:	eddd 9a11 	vldr	s19, [sp, #68]	@ 0x44
      DSP_WAIT;
 80070ae:	9b05      	ldr	r3, [sp, #20]
 80070b0:	b292      	uxth	r2, r2
 80070b2:	2a00      	cmp	r2, #0
 80070b4:	f47f aebe 	bne.w	8006e34 <sweep+0x1f8>
      (*sample_func)(&data[0]);           // calculate reflection coefficient
 80070b8:	a80a      	add	r0, sp, #40	@ 0x28
 80070ba:	9305      	str	r3, [sp, #20]
 80070bc:	f003 f958 	bl	800a370 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 80070c0:	9b05      	ldr	r3, [sp, #20]
  float s11mr = data[0] - c_data[ETERM_ED][0];
 80070c2:	ed9d 6a0a 	vldr	s12, [sp, #40]	@ 0x28
 80070c6:	ed9d 7a0e 	vldr	s14, [sp, #56]	@ 0x38
  float eri = c_data[ETERM_ER][1] + s11mr * c_data[ETERM_ES][1] + s11mi * c_data[ETERM_ES][0];
 80070ca:	eddd 7a13 	vldr	s15, [sp, #76]	@ 0x4c
  float s11mi = data[1] - c_data[ETERM_ED][1];
 80070ce:	eddd 6a0b 	vldr	s13, [sp, #44]	@ 0x2c
 80070d2:	eddd 5a0f 	vldr	s11, [sp, #60]	@ 0x3c
  float s11mr = data[0] - c_data[ETERM_ED][0];
 80070d6:	ee36 6a47 	vsub.f32	s12, s12, s14
  float err = c_data[ETERM_ER][0] + s11mr * c_data[ETERM_ES][0] - s11mi * c_data[ETERM_ES][1];
 80070da:	ed9d 7a12 	vldr	s14, [sp, #72]	@ 0x48
  float eri = c_data[ETERM_ER][1] + s11mr * c_data[ETERM_ES][1] + s11mi * c_data[ETERM_ES][0];
 80070de:	eee6 7a29 	vfma.f32	s15, s12, s19
  float s11mi = data[1] - c_data[ETERM_ED][1];
 80070e2:	ee76 6ae5 	vsub.f32	s13, s13, s11
  float err = c_data[ETERM_ER][0] + s11mr * c_data[ETERM_ES][0] - s11mi * c_data[ETERM_ES][1];
 80070e6:	eea6 7a0a 	vfma.f32	s14, s12, s20
  float eri = c_data[ETERM_ER][1] + s11mr * c_data[ETERM_ES][1] + s11mi * c_data[ETERM_ES][0];
 80070ea:	eee6 7a8a 	vfma.f32	s15, s13, s20
  float err = c_data[ETERM_ER][0] + s11mr * c_data[ETERM_ES][0] - s11mi * c_data[ETERM_ES][1];
 80070ee:	eea6 7ae9 	vfms.f32	s14, s13, s19
  data[0] = (s11mr * err + s11mi * eri) / sq;
 80070f2:	ee26 5aa7 	vmul.f32	s10, s13, s15
  float sq = err * err + eri * eri;
 80070f6:	ee67 5aa7 	vmul.f32	s11, s15, s15
  data[1] = (s11mi * err - s11mr * eri) / sq;
 80070fa:	ee67 7ac6 	vnmul.f32	s15, s15, s12
  float sq = err * err + eri * eri;
 80070fe:	eee7 5a07 	vfma.f32	s11, s14, s14
  data[0] = (s11mr * err + s11mi * eri) / sq;
 8007102:	eea6 5a07 	vfma.f32	s10, s12, s14
  data[1] = (s11mi * err - s11mr * eri) / sq;
 8007106:	eee6 7a87 	vfma.f32	s15, s13, s14
  data[0] = (s11mr * err + s11mi * eri) / sq;
 800710a:	eec5 6a25 	vdiv.f32	s13, s10, s11
  data[1] = (s11mi * err - s11mr * eri) / sq;
 800710e:	ee87 7aa5 	vdiv.f32	s14, s15, s11
  data[0] = (s11mr * err + s11mi * eri) / sq;
 8007112:	edcd 6a0a 	vstr	s13, [sp, #40]	@ 0x28
  data[1] = (s11mi * err - s11mr * eri) / sq;
 8007116:	ed8d 7a0b 	vstr	s14, [sp, #44]	@ 0x2c
    if (mask & SWEEP_CH1_MEASURE)
 800711a:	2b00      	cmp	r3, #0
 800711c:	f43f ae9b 	beq.w	8006e56 <sweep+0x21a>
      tlv320aic3204_select(1);
 8007120:	2001      	movs	r0, #1
 8007122:	f003 f875 	bl	800a210 <tlv320aic3204_select>
      DSP_START(delay + st_delay);
 8007126:	4b15      	ldr	r3, [pc, #84]	@ (800717c <sweep+0x540>)
 8007128:	8b5a      	ldrh	r2, [r3, #26]
 800712a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800712e:	3202      	adds	r2, #2
 8007130:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007132:	b292      	uxth	r2, r2
 8007134:	8032      	strh	r2, [r6, #0]
 8007136:	330a      	adds	r3, #10
 8007138:	4a11      	ldr	r2, [pc, #68]	@ (8007180 <sweep+0x544>)
 800713a:	444b      	add	r3, r9
 800713c:	6013      	str	r3, [r2, #0]
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 800713e:	e79f      	b.n	8007080 <sweep+0x444>
      (*sample_func)(&data[2]);           // Measure transmission coefficient
 8007140:	a80c      	add	r0, sp, #48	@ 0x30
 8007142:	f003 f915 	bl	800a370 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8007146:	e62c      	b.n	8006da2 <sweep+0x166>
        if (mask & SWEEP_APPLY_EDELAY_S11)
 8007148:	2600      	movs	r6, #0
 800714a:	e75f      	b.n	800700c <sweep+0x3d0>
      (*sample_func)(&data[0]);           // calculate reflection coefficient
 800714c:	a80a      	add	r0, sp, #40	@ 0x28
 800714e:	9305      	str	r3, [sp, #20]
 8007150:	f003 f90e 	bl	800a370 <calculate_gamma>
      if (mask & SWEEP_APPLY_CALIBRATION) // Apply calibration
 8007154:	9b05      	ldr	r3, [sp, #20]
 8007156:	e67b      	b.n	8006e50 <sweep+0x214>
      tlv320aic3204_select(1);
 8007158:	2001      	movs	r0, #1
 800715a:	f003 f859 	bl	800a210 <tlv320aic3204_select>
      DSP_START(delay + st_delay);
 800715e:	4b07      	ldr	r3, [pc, #28]	@ (800717c <sweep+0x540>)
 8007160:	8b5a      	ldrh	r2, [r3, #26]
 8007162:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8007166:	3202      	adds	r2, #2
 8007168:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800716a:	b292      	uxth	r2, r2
 800716c:	8032      	strh	r2, [r6, #0]
 800716e:	330a      	adds	r3, #10
 8007170:	4a03      	ldr	r2, [pc, #12]	@ (8007180 <sweep+0x544>)
 8007172:	444b      	add	r3, r9
 8007174:	6013      	str	r3, [r2, #0]
      if ((mask & SWEEP_APPLY_CALIBRATION) && !(mask & SWEEP_CH0_MEASURE))
 8007176:	e601      	b.n	8006d7c <sweep+0x140>
 8007178:	20004f54 	.word	0x20004f54
 800717c:	20000318 	.word	0x20000318
 8007180:	20000a9c 	.word	0x20000a9c

08007184 <cmd_frequencies>:
{
 8007184:	b538      	push	{r3, r4, r5, lr}
  for (i = 0; i < sweep_points; i++)
 8007186:	4d08      	ldr	r5, [pc, #32]	@ (80071a8 <cmd_frequencies+0x24>)
 8007188:	8b6b      	ldrh	r3, [r5, #26]
 800718a:	b15b      	cbz	r3, 80071a4 <cmd_frequencies+0x20>
 800718c:	2400      	movs	r4, #0
    shell_printf(VNA_FREQ_FMT_STR VNA_SHELL_NEWLINE_STR, getFrequency(i));
 800718e:	b2a0      	uxth	r0, r4
 8007190:	f7ff fd38 	bl	8006c04 <getFrequency>
 8007194:	4601      	mov	r1, r0
 8007196:	4805      	ldr	r0, [pc, #20]	@ (80071ac <cmd_frequencies+0x28>)
 8007198:	f7fe ff42 	bl	8006020 <shell_printf>
  for (i = 0; i < sweep_points; i++)
 800719c:	8b6b      	ldrh	r3, [r5, #26]
 800719e:	3401      	adds	r4, #1
 80071a0:	42a3      	cmp	r3, r4
 80071a2:	dcf4      	bgt.n	800718e <cmd_frequencies+0xa>
}
 80071a4:	bd38      	pop	{r3, r4, r5, pc}
 80071a6:	bf00      	nop
 80071a8:	20000aa8 	.word	0x20000aa8
 80071ac:	08012b00 	.word	0x08012b00

080071b0 <cmd_scan>:
{
 80071b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint16_t points = sweep_points;
 80071b4:	4faa      	ldr	r7, [pc, #680]	@ (8007460 <cmd_scan+0x2b0>)
{
 80071b6:	b084      	sub	sp, #16
  if (argc < 2 || argc > 4)
 80071b8:	1e83      	subs	r3, r0, #2
  uint16_t points = sweep_points;
 80071ba:	8b7a      	ldrh	r2, [r7, #26]
 80071bc:	f8ad 2008 	strh.w	r2, [sp, #8]
  if (argc < 2 || argc > 4)
 80071c0:	2b02      	cmp	r3, #2
 80071c2:	f200 80c5 	bhi.w	8007350 <cmd_scan+0x1a0>
  start = my_atoui(argv[0]);
 80071c6:	4606      	mov	r6, r0
 80071c8:	6808      	ldr	r0, [r1, #0]
 80071ca:	460c      	mov	r4, r1
 80071cc:	f002 fbae 	bl	800992c <my_atoui>
 80071d0:	4680      	mov	r8, r0
  stop = my_atoui(argv[1]);
 80071d2:	6860      	ldr	r0, [r4, #4]
 80071d4:	f002 fbaa 	bl	800992c <my_atoui>
 80071d8:	4605      	mov	r5, r0
  if (start == 0 || stop == 0 || start > stop)
 80071da:	f1b8 0f00 	cmp.w	r8, #0
 80071de:	f000 80b1 	beq.w	8007344 <cmd_scan+0x194>
 80071e2:	2800      	cmp	r0, #0
 80071e4:	f000 80ae 	beq.w	8007344 <cmd_scan+0x194>
 80071e8:	4580      	cmp	r8, r0
 80071ea:	f200 80ab 	bhi.w	8007344 <cmd_scan+0x194>
  if (argc >= 3)
 80071ee:	2e02      	cmp	r6, #2
 80071f0:	f040 80b4 	bne.w	800735c <cmd_scan+0x1ac>
  sweep_mode &= ~(SWEEP_BINARY);
 80071f4:	4c9b      	ldr	r4, [pc, #620]	@ (8007464 <cmd_scan+0x2b4>)
  sweep_points = points;
 80071f6:	f8bd 6008 	ldrh.w	r6, [sp, #8]
  sweep_mode &= ~(SWEEP_BINARY);
 80071fa:	7822      	ldrb	r2, [r4, #0]
  if (needInterpolate(start, stop, sweep_points))
 80071fc:	8b78      	ldrh	r0, [r7, #26]
  uint16_t mask = 0;
 80071fe:	2300      	movs	r3, #0
 8007200:	f8ad 300a 	strh.w	r3, [sp, #10]
  _f_points = (points - 1);
 8007204:	1e73      	subs	r3, r6, #1
 8007206:	b29b      	uxth	r3, r3
  uint16_t sweep_ch = SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE;
 8007208:	2103      	movs	r1, #3
  sweep_mode &= ~(SWEEP_BINARY);
 800720a:	f022 0208 	bic.w	r2, r2, #8
 800720e:	7022      	strb	r2, [r4, #0]
  if ((cal_status & CALSTAT_APPLY) && !(mask & SCAN_MASK_NO_CALIBRATION))
 8007210:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8007212:	05d2      	lsls	r2, r2, #23
 8007214:	d505      	bpl.n	8007222 <cmd_scan+0x72>
 8007216:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 800721a:	0714      	lsls	r4, r2, #28
    sweep_ch |= SWEEP_APPLY_CALIBRATION;
 800721c:	bf58      	it	pl
 800721e:	f041 0120 	orrpl.w	r1, r1, #32
  if (electrical_delayS11 && !(mask & SCAN_MASK_NO_EDELAY))
 8007222:	edd7 7a27 	vldr	s15, [r7, #156]	@ 0x9c
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 8007226:	ed97 7a28 	vldr	s14, [r7, #160]	@ 0xa0
  if (electrical_delayS11 && !(mask & SCAN_MASK_NO_EDELAY))
 800722a:	eef5 7a40 	vcmp.f32	s15, #0.0
 800722e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007232:	f000 80a9 	beq.w	8007388 <cmd_scan+0x1d8>
 8007236:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 800723a:	06d2      	lsls	r2, r2, #27
 800723c:	d408      	bmi.n	8007250 <cmd_scan+0xa0>
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 800723e:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8007242:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    sweep_ch |= SWEEP_APPLY_EDELAY_S11;
 8007246:	f041 0104 	orr.w	r1, r1, #4
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 800724a:	d001      	beq.n	8007250 <cmd_scan+0xa0>
    sweep_ch |= SWEEP_APPLY_EDELAY_S21;
 800724c:	f041 0108 	orr.w	r1, r1, #8
  if (s21_offset && !(mask & SCAN_MASK_NO_S21OFFS))
 8007250:	edd7 7a2a 	vldr	s15, [r7, #168]	@ 0xa8
 8007254:	eef5 7a40 	vcmp.f32	s15, #0.0
 8007258:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800725c:	d005      	beq.n	800726a <cmd_scan+0xba>
 800725e:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 8007262:	0692      	lsls	r2, r2, #26
    sweep_ch |= SWEEP_APPLY_S21_OFFSET;
 8007264:	bf58      	it	pl
 8007266:	f041 0110 	orrpl.w	r1, r1, #16
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 800726a:	68fa      	ldr	r2, [r7, #12]
 800726c:	4590      	cmp	r8, r2
 800726e:	f000 8097 	beq.w	80073a0 <cmd_scan+0x1f0>
    sweep_ch |= SWEEP_USE_INTERPOLATION;
 8007272:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
  _f_start = start;
 8007276:	4a7c      	ldr	r2, [pc, #496]	@ (8007468 <cmd_scan+0x2b8>)
  _f_delta = span / _f_points;
 8007278:	4c7c      	ldr	r4, [pc, #496]	@ (800746c <cmd_scan+0x2bc>)
  _f_start = start;
 800727a:	f8c2 8000 	str.w	r8, [r2]
  _f_points = (points - 1);
 800727e:	4a7c      	ldr	r2, [pc, #496]	@ (8007470 <cmd_scan+0x2c0>)
  _f_error = span % _f_points;
 8007280:	487c      	ldr	r0, [pc, #496]	@ (8007474 <cmd_scan+0x2c4>)
  _f_points = (points - 1);
 8007282:	8013      	strh	r3, [r2, #0]
  freq_t span = stop - start;
 8007284:	eba5 0508 	sub.w	r5, r5, r8
  _f_delta = span / _f_points;
 8007288:	fbb5 f2f3 	udiv	r2, r5, r3
  _f_error = span % _f_points;
 800728c:	fb03 5512 	mls	r5, r3, r2, r5
  if (sweep_ch & (SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE))
 8007290:	078b      	lsls	r3, r1, #30
  sweep_points = points;
 8007292:	837e      	strh	r6, [r7, #26]
  _f_delta = span / _f_points;
 8007294:	6022      	str	r2, [r4, #0]
  _f_error = span % _f_points;
 8007296:	6005      	str	r5, [r0, #0]
  if (sweep_ch & (SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE))
 8007298:	f040 808b 	bne.w	80073b2 <cmd_scan+0x202>
  pause_sweep();
 800729c:	f7fe feae 	bl	8005ffc <pause_sweep>
  if (mask)
 80072a0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80072a4:	2b00      	cmp	r3, #0
 80072a6:	d050      	beq.n	800734a <cmd_scan+0x19a>
    if (mask & SCAN_MASK_BINARY)
 80072a8:	f013 0480 	ands.w	r4, r3, #128	@ 0x80
 80072ac:	f040 8085 	bne.w	80073ba <cmd_scan+0x20a>
      for (int i = 0; i < points; i++)
 80072b0:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 80072b4:	2a00      	cmp	r2, #0
 80072b6:	d048      	beq.n	800734a <cmd_scan+0x19a>
 80072b8:	4d6f      	ldr	r5, [pc, #444]	@ (8007478 <cmd_scan+0x2c8>)
 80072ba:	e00f      	b.n	80072dc <cmd_scan+0x12c>
        if (mask & SCAN_MASK_OUT_DATA0)
 80072bc:	079a      	lsls	r2, r3, #30
 80072be:	d41a      	bmi.n	80072f6 <cmd_scan+0x146>
        if (mask & SCAN_MASK_OUT_DATA1)
 80072c0:	075b      	lsls	r3, r3, #29
 80072c2:	d42b      	bmi.n	800731c <cmd_scan+0x16c>
        shell_printf(VNA_SHELL_NEWLINE_STR);
 80072c4:	486d      	ldr	r0, [pc, #436]	@ (800747c <cmd_scan+0x2cc>)
 80072c6:	f7fe feab 	bl	8006020 <shell_printf>
      for (int i = 0; i < points; i++)
 80072ca:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 80072ce:	3401      	adds	r4, #1
 80072d0:	42a3      	cmp	r3, r4
 80072d2:	f105 0508 	add.w	r5, r5, #8
 80072d6:	dd38      	ble.n	800734a <cmd_scan+0x19a>
        if (mask & SCAN_MASK_OUT_FREQ)
 80072d8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80072dc:	07d9      	lsls	r1, r3, #31
 80072de:	d5ed      	bpl.n	80072bc <cmd_scan+0x10c>
          shell_printf(VNA_FREQ_FMT_STR " ", getFrequency(i));
 80072e0:	b2a0      	uxth	r0, r4
 80072e2:	f7ff fc8f 	bl	8006c04 <getFrequency>
 80072e6:	4601      	mov	r1, r0
 80072e8:	4865      	ldr	r0, [pc, #404]	@ (8007480 <cmd_scan+0x2d0>)
 80072ea:	f7fe fe99 	bl	8006020 <shell_printf>
        if (mask & SCAN_MASK_OUT_DATA0)
 80072ee:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80072f2:	079a      	lsls	r2, r3, #30
 80072f4:	d5e4      	bpl.n	80072c0 <cmd_scan+0x110>
          shell_printf("%f %f ", measured[0][i][0], measured[0][i][1]);
 80072f6:	6828      	ldr	r0, [r5, #0]
 80072f8:	f7f9 f952 	bl	80005a0 <__aeabi_f2d>
 80072fc:	4606      	mov	r6, r0
 80072fe:	6868      	ldr	r0, [r5, #4]
 8007300:	460f      	mov	r7, r1
 8007302:	f7f9 f94d 	bl	80005a0 <__aeabi_f2d>
 8007306:	463b      	mov	r3, r7
 8007308:	e9cd 0100 	strd	r0, r1, [sp]
 800730c:	4632      	mov	r2, r6
 800730e:	485d      	ldr	r0, [pc, #372]	@ (8007484 <cmd_scan+0x2d4>)
 8007310:	f7fe fe86 	bl	8006020 <shell_printf>
        if (mask & SCAN_MASK_OUT_DATA1)
 8007314:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8007318:	075b      	lsls	r3, r3, #29
 800731a:	d5d3      	bpl.n	80072c4 <cmd_scan+0x114>
          shell_printf("%f %f ", measured[1][i][0], measured[1][i][1]);
 800731c:	f605 4388 	addw	r3, r5, #3208	@ 0xc88
 8007320:	6818      	ldr	r0, [r3, #0]
 8007322:	f7f9 f93d 	bl	80005a0 <__aeabi_f2d>
 8007326:	f605 438c 	addw	r3, r5, #3212	@ 0xc8c
 800732a:	4606      	mov	r6, r0
 800732c:	6818      	ldr	r0, [r3, #0]
 800732e:	460f      	mov	r7, r1
 8007330:	f7f9 f936 	bl	80005a0 <__aeabi_f2d>
 8007334:	4632      	mov	r2, r6
 8007336:	e9cd 0100 	strd	r0, r1, [sp]
 800733a:	463b      	mov	r3, r7
 800733c:	4851      	ldr	r0, [pc, #324]	@ (8007484 <cmd_scan+0x2d4>)
 800733e:	f7fe fe6f 	bl	8006020 <shell_printf>
 8007342:	e7bf      	b.n	80072c4 <cmd_scan+0x114>
    shell_printf("frequency range is invalid" VNA_SHELL_NEWLINE_STR);
 8007344:	4850      	ldr	r0, [pc, #320]	@ (8007488 <cmd_scan+0x2d8>)
 8007346:	f7fe fe6b 	bl	8006020 <shell_printf>
}
 800734a:	b004      	add	sp, #16
 800734c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    shell_printf("usage: scan {start(Hz)} {stop(Hz)} [points] [outmask]" VNA_SHELL_NEWLINE_STR);
 8007350:	484e      	ldr	r0, [pc, #312]	@ (800748c <cmd_scan+0x2dc>)
 8007352:	f7fe fe65 	bl	8006020 <shell_printf>
}
 8007356:	b004      	add	sp, #16
 8007358:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    points = my_atoui(argv[2]);
 800735c:	68a0      	ldr	r0, [r4, #8]
 800735e:	f002 fae5 	bl	800992c <my_atoui>
 8007362:	b280      	uxth	r0, r0
    if (points == 0 || points > SWEEP_POINTS_MAX)
 8007364:	1e43      	subs	r3, r0, #1
 8007366:	b29b      	uxth	r3, r3
 8007368:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
    points = my_atoui(argv[2]);
 800736c:	f8ad 0008 	strh.w	r0, [sp, #8]
    if (points == 0 || points > SWEEP_POINTS_MAX)
 8007370:	d85a      	bhi.n	8007428 <cmd_scan+0x278>
  uint16_t mask = 0;
 8007372:	2200      	movs	r2, #0
  if (argc == 4)
 8007374:	2e04      	cmp	r6, #4
    sweep_points = points;
 8007376:	8378      	strh	r0, [r7, #26]
  uint16_t mask = 0;
 8007378:	f8ad 200a 	strh.w	r2, [sp, #10]
  if (argc == 4)
 800737c:	d058      	beq.n	8007430 <cmd_scan+0x280>
  sweep_mode &= ~(SWEEP_BINARY);
 800737e:	4c39      	ldr	r4, [pc, #228]	@ (8007464 <cmd_scan+0x2b4>)
 8007380:	4606      	mov	r6, r0
 8007382:	7822      	ldrb	r2, [r4, #0]
  uint16_t sweep_ch = SWEEP_CH0_MEASURE | SWEEP_CH1_MEASURE;
 8007384:	2103      	movs	r1, #3
 8007386:	e740      	b.n	800720a <cmd_scan+0x5a>
  if (electrical_delayS21 && !(mask & SCAN_MASK_NO_EDELAY))
 8007388:	eeb5 7a40 	vcmp.f32	s14, #0.0
 800738c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007390:	f43f af5e 	beq.w	8007250 <cmd_scan+0xa0>
 8007394:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 8007398:	06d4      	lsls	r4, r2, #27
 800739a:	f53f af59 	bmi.w	8007250 <cmd_scan+0xa0>
 800739e:	e755      	b.n	800724c <cmd_scan+0x9c>
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 80073a0:	693a      	ldr	r2, [r7, #16]
 80073a2:	4295      	cmp	r5, r2
 80073a4:	f47f af65 	bne.w	8007272 <cmd_scan+0xc2>
 80073a8:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 80073aa:	4282      	cmp	r2, r0
 80073ac:	f47f af61 	bne.w	8007272 <cmd_scan+0xc2>
 80073b0:	e761      	b.n	8007276 <cmd_scan+0xc6>
    sweep(false, sweep_ch);
 80073b2:	2000      	movs	r0, #0
 80073b4:	f7ff fc42 	bl	8006c3c <sweep>
 80073b8:	e770      	b.n	800729c <cmd_scan+0xec>
      shell_write(&mask, sizeof(uint16_t));
 80073ba:	2102      	movs	r1, #2
 80073bc:	f10d 000a 	add.w	r0, sp, #10
 80073c0:	f7fe f8a8 	bl	8005514 <shell_write>
      shell_write(&points, sizeof(uint16_t));
 80073c4:	2102      	movs	r1, #2
 80073c6:	a802      	add	r0, sp, #8
 80073c8:	f7fe f8a4 	bl	8005514 <shell_write>
      for (int i = 0; i < points; i++)
 80073cc:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 80073d0:	2b00      	cmp	r3, #0
 80073d2:	d0ba      	beq.n	800734a <cmd_scan+0x19a>
 80073d4:	4d28      	ldr	r5, [pc, #160]	@ (8007478 <cmd_scan+0x2c8>)
 80073d6:	2400      	movs	r4, #0
 80073d8:	e00a      	b.n	80073f0 <cmd_scan+0x240>
        if (mask & SCAN_MASK_OUT_DATA0)
 80073da:	079e      	lsls	r6, r3, #30
 80073dc:	d41d      	bmi.n	800741a <cmd_scan+0x26a>
        if (mask & SCAN_MASK_OUT_DATA1)
 80073de:	0758      	lsls	r0, r3, #29
 80073e0:	d415      	bmi.n	800740e <cmd_scan+0x25e>
      for (int i = 0; i < points; i++)
 80073e2:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 80073e6:	3401      	adds	r4, #1
 80073e8:	42a3      	cmp	r3, r4
 80073ea:	f105 0508 	add.w	r5, r5, #8
 80073ee:	ddac      	ble.n	800734a <cmd_scan+0x19a>
        if (mask & SCAN_MASK_OUT_FREQ)
 80073f0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80073f4:	07df      	lsls	r7, r3, #31
 80073f6:	d5f0      	bpl.n	80073da <cmd_scan+0x22a>
          freq_t f = getFrequency(i);
 80073f8:	b2a0      	uxth	r0, r4
 80073fa:	f7ff fc03 	bl	8006c04 <getFrequency>
          shell_write(&f, sizeof(freq_t));
 80073fe:	2104      	movs	r1, #4
          freq_t f = getFrequency(i);
 8007400:	9003      	str	r0, [sp, #12]
          shell_write(&f, sizeof(freq_t));
 8007402:	a803      	add	r0, sp, #12
 8007404:	f7fe f886 	bl	8005514 <shell_write>
        if (mask & SCAN_MASK_OUT_DATA0)
 8007408:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 800740c:	e7e5      	b.n	80073da <cmd_scan+0x22a>
          shell_write(&measured[1][i][0], sizeof(float) * 2); // 4+4 bytes .. S21 real/imag
 800740e:	2108      	movs	r1, #8
 8007410:	f605 4088 	addw	r0, r5, #3208	@ 0xc88
 8007414:	f7fe f87e 	bl	8005514 <shell_write>
 8007418:	e7e3      	b.n	80073e2 <cmd_scan+0x232>
          shell_write(&measured[0][i][0], sizeof(float) * 2); // 4+4 bytes .. S11 real/imag
 800741a:	2108      	movs	r1, #8
 800741c:	4628      	mov	r0, r5
 800741e:	f7fe f879 	bl	8005514 <shell_write>
        if (mask & SCAN_MASK_OUT_DATA1)
 8007422:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8007426:	e7da      	b.n	80073de <cmd_scan+0x22e>
      shell_printf("sweep points exceeds range " define_to_STR(SWEEP_POINTS_MAX) VNA_SHELL_NEWLINE_STR);
 8007428:	4819      	ldr	r0, [pc, #100]	@ (8007490 <cmd_scan+0x2e0>)
 800742a:	f7fe fdf9 	bl	8006020 <shell_printf>
      return;
 800742e:	e78c      	b.n	800734a <cmd_scan+0x19a>
    mask = my_atoui(argv[3]);
 8007430:	68e0      	ldr	r0, [r4, #12]
    if (sweep_mode & SWEEP_BINARY)
 8007432:	4c0c      	ldr	r4, [pc, #48]	@ (8007464 <cmd_scan+0x2b4>)
    mask = my_atoui(argv[3]);
 8007434:	f002 fa7a 	bl	800992c <my_atoui>
    if (sweep_mode & SWEEP_BINARY)
 8007438:	7822      	ldrb	r2, [r4, #0]
  sweep_points = points;
 800743a:	f8bd 6008 	ldrh.w	r6, [sp, #8]
    mask = my_atoui(argv[3]);
 800743e:	b281      	uxth	r1, r0
    if (sweep_mode & SWEEP_BINARY)
 8007440:	0710      	lsls	r0, r2, #28
    mask = my_atoui(argv[3]);
 8007442:	f8ad 100a 	strh.w	r1, [sp, #10]
  _f_points = (points - 1);
 8007446:	f106 33ff 	add.w	r3, r6, #4294967295
      mask |= SCAN_MASK_BINARY;
 800744a:	bf44      	itt	mi
 800744c:	f041 0180 	orrmi.w	r1, r1, #128	@ 0x80
 8007450:	f8ad 100a 	strhmi.w	r1, [sp, #10]
  if (needInterpolate(start, stop, sweep_points))
 8007454:	8b78      	ldrh	r0, [r7, #26]
    sweep_ch = (mask >> 1) & 3;
 8007456:	f3c1 0141 	ubfx	r1, r1, #1, #2
  _f_points = (points - 1);
 800745a:	b29b      	uxth	r3, r3
 800745c:	e6d5      	b.n	800720a <cmd_scan+0x5a>
 800745e:	bf00      	nop
 8007460:	20000aa8 	.word	0x20000aa8
 8007464:	200003c4 	.word	0x200003c4
 8007468:	20000914 	.word	0x20000914
 800746c:	20000910 	.word	0x20000910
 8007470:	20000908 	.word	0x20000908
 8007474:	2000090c 	.word	0x2000090c
 8007478:	20004f54 	.word	0x20004f54
 800747c:	08013860 	.word	0x08013860
 8007480:	08012f40 	.word	0x08012f40
 8007484:	08012f44 	.word	0x08012f44
 8007488:	08012efc 	.word	0x08012efc
 800748c:	08012ec4 	.word	0x08012ec4
 8007490:	08012f1c 	.word	0x08012f1c

08007494 <cmd_scan_bin>:
{
 8007494:	b510      	push	{r4, lr}
  sweep_mode |= SWEEP_BINARY;
 8007496:	4c06      	ldr	r4, [pc, #24]	@ (80074b0 <cmd_scan_bin+0x1c>)
 8007498:	7823      	ldrb	r3, [r4, #0]
 800749a:	f043 0308 	orr.w	r3, r3, #8
 800749e:	7023      	strb	r3, [r4, #0]
  cmd_scan(argc, argv);
 80074a0:	f7ff fe86 	bl	80071b0 <cmd_scan>
  sweep_mode &= ~(SWEEP_BINARY);
 80074a4:	7823      	ldrb	r3, [r4, #0]
 80074a6:	f023 0308 	bic.w	r3, r3, #8
 80074aa:	7023      	strb	r3, [r4, #0]
}
 80074ac:	bd10      	pop	{r4, pc}
 80074ae:	bf00      	nop
 80074b0:	200003c4 	.word	0x200003c4

080074b4 <mla_update_bandwidth_swr2>:
{
 80074b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (!mla_resonance_locked)
 80074b8:	4bb1      	ldr	r3, [pc, #708]	@ (8007780 <mla_update_bandwidth_swr2+0x2cc>)
  mla_bw_swr2 = 0;
 80074ba:	4cb2      	ldr	r4, [pc, #712]	@ (8007784 <mla_update_bandwidth_swr2+0x2d0>)
  if (!mla_resonance_locked)
 80074bc:	781b      	ldrb	r3, [r3, #0]
  mla_bw_swr2 = 0;
 80074be:	2200      	movs	r2, #0
{
 80074c0:	b089      	sub	sp, #36	@ 0x24
  mla_bw_swr2 = 0;
 80074c2:	6022      	str	r2, [r4, #0]
  if (!mla_resonance_locked)
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	f000 811b 	beq.w	8007700 <mla_update_bandwidth_swr2+0x24c>
  if (sweep_points < 3)
 80074ca:	4baf      	ldr	r3, [pc, #700]	@ (8007788 <mla_update_bandwidth_swr2+0x2d4>)
 80074cc:	8b5f      	ldrh	r7, [r3, #26]
 80074ce:	2f02      	cmp	r7, #2
 80074d0:	f240 8133 	bls.w	800773a <mla_update_bandwidth_swr2+0x286>
  uint16_t center = (uint16_t)mla_res_idx;
 80074d4:	4bad      	ldr	r3, [pc, #692]	@ (800778c <mla_update_bandwidth_swr2+0x2d8>)
 80074d6:	f9b3 5000 	ldrsh.w	r5, [r3]
 80074da:	b2a9      	uxth	r1, r5
  if (center >= sweep_points)
 80074dc:	428f      	cmp	r7, r1
 80074de:	f240 8136 	bls.w	800774e <mla_update_bandwidth_swr2+0x29a>
  float swr_center = getSWRfromIndex(center);
 80074e2:	4608      	mov	r0, r1
 80074e4:	f7fd ffe4 	bl	80054b0 <getSWRfromIndex>
  if (swr_center <= 0.0f || swr_center > 50.0f)
 80074e8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80074ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float swr_center = getSWRfromIndex(center);
 80074f0:	eeb0 6a40 	vmov.f32	s12, s0
  if (swr_center <= 0.0f || swr_center > 50.0f)
 80074f4:	f240 80f4 	bls.w	80076e0 <mla_update_bandwidth_swr2+0x22c>
 80074f8:	eddf 7aa5 	vldr	s15, [pc, #660]	@ 8007790 <mla_update_bandwidth_swr2+0x2dc>
 80074fc:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8007500:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007504:	f300 80ec 	bgt.w	80076e0 <mla_update_bandwidth_swr2+0x22c>
  while (left_idx >= 0)
 8007508:	2d00      	cmp	r5, #0
  while (right_idx < (int16_t)sweep_points)
 800750a:	b23f      	sxth	r7, r7
  while (left_idx >= 0)
 800750c:	f2c0 8101 	blt.w	8007712 <mla_update_bandwidth_swr2+0x25e>
  int16_t left_idx = (int16_t)center;
 8007510:	462e      	mov	r6, r5
  int16_t last_good_left = -1;
 8007512:	f04f 33ff 	mov.w	r3, #4294967295
    if (swr > 0.0f && swr <= swr_bw_limit)
 8007516:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 800751a:	e000      	b.n	800751e <mla_update_bandwidth_swr2+0x6a>
 800751c:	4616      	mov	r6, r2
 800751e:	eeb4 0ae5 	vcmpe.f32	s0, s11
 8007522:	1e70      	subs	r0, r6, #1
 8007524:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      left_idx--;
 8007528:	b202      	sxth	r2, r0
  while (left_idx >= 0)
 800752a:	b280      	uxth	r0, r0
    if (swr > 0.0f && swr <= swr_bw_limit)
 800752c:	f200 811b 	bhi.w	8007766 <mla_update_bandwidth_swr2+0x2b2>
  while (left_idx >= 0)
 8007530:	1c51      	adds	r1, r2, #1
 8007532:	f000 811a 	beq.w	800776a <mla_update_bandwidth_swr2+0x2b6>
    float swr = getSWRfromIndex((uint16_t)left_idx);
 8007536:	f7fd ffbb 	bl	80054b0 <getSWRfromIndex>
    if (swr > 0.0f && swr <= swr_bw_limit)
 800753a:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800753e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007542:	4633      	mov	r3, r6
 8007544:	dcea      	bgt.n	800751c <mla_update_bandwidth_swr2+0x68>
  while (right_idx < (int16_t)sweep_points)
 8007546:	42bd      	cmp	r5, r7
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (left=%d right=%d)\r\n",
 8007548:	bfa8      	it	ge
 800754a:	f04f 31ff 	movge.w	r1, #4294967295
  while (right_idx < (int16_t)sweep_points)
 800754e:	f280 80e9 	bge.w	8007724 <mla_update_bandwidth_swr2+0x270>
    if (swr > 0.0f && swr <= swr_bw_limit)
 8007552:	f04f 33ff 	mov.w	r3, #4294967295
 8007556:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 800755a:	e000      	b.n	800755e <mla_update_bandwidth_swr2+0xaa>
 800755c:	4615      	mov	r5, r2
 800755e:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8007562:	1c68      	adds	r0, r5, #1
 8007564:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      right_idx++;
 8007568:	b202      	sxth	r2, r0
  while (right_idx < (int16_t)sweep_points)
 800756a:	b280      	uxth	r0, r0
    if (swr > 0.0f && swr <= swr_bw_limit)
 800756c:	f200 80f9 	bhi.w	8007762 <mla_update_bandwidth_swr2+0x2ae>
  while (right_idx < (int16_t)sweep_points)
 8007570:	42ba      	cmp	r2, r7
 8007572:	da09      	bge.n	8007588 <mla_update_bandwidth_swr2+0xd4>
    float swr = getSWRfromIndex((uint16_t)right_idx);
 8007574:	f7fd ff9c 	bl	80054b0 <getSWRfromIndex>
    if (swr > 0.0f && swr <= swr_bw_limit)
 8007578:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800757c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float swr = getSWRfromIndex((uint16_t)right_idx);
 8007580:	eeb0 6a40 	vmov.f32	s12, s0
    if (swr > 0.0f && swr <= swr_bw_limit)
 8007584:	462b      	mov	r3, r5
 8007586:	dce9      	bgt.n	800755c <mla_update_bandwidth_swr2+0xa8>
  if (last_good_left < 0 || last_good_right < 0 || last_good_right <= last_good_left)
 8007588:	1c73      	adds	r3, r6, #1
  if (last_good_right < (int16_t)sweep_points - 1)
 800758a:	4629      	mov	r1, r5
  if (last_good_left < 0 || last_good_right < 0 || last_good_right <= last_good_left)
 800758c:	f000 80ca 	beq.w	8007724 <mla_update_bandwidth_swr2+0x270>
 8007590:	2d00      	cmp	r5, #0
 8007592:	f2c0 80c7 	blt.w	8007724 <mla_update_bandwidth_swr2+0x270>
 8007596:	42b5      	cmp	r5, r6
 8007598:	f340 80c4 	ble.w	8007724 <mla_update_bandwidth_swr2+0x270>
  float f_low_f = (float)getFrequency((uint16_t)last_good_left);
 800759c:	fa1f f886 	uxth.w	r8, r6
 80075a0:	4640      	mov	r0, r8
 80075a2:	f7ff fb2f 	bl	8006c04 <getFrequency>
 80075a6:	ee05 0a90 	vmov	s11, r0
 80075aa:	eef8 5a65 	vcvt.f32.u32	s11, s11
  if (last_good_left > 0)
 80075ae:	b376      	cbz	r6, 800760e <mla_update_bandwidth_swr2+0x15a>
    int16_t bad_i = last_good_left - 1;
 80075b0:	f108 32ff 	add.w	r2, r8, #4294967295
 80075b4:	b292      	uxth	r2, r2
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 80075b6:	4610      	mov	r0, r2
 80075b8:	f7fd ff7a 	bl	80054b0 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 80075bc:	eeb0 5a00 	vmov.f32	s10, #0	@ 0x40000000  2.0
 80075c0:	eeb4 0ac5 	vcmpe.f32	s0, s10
 80075c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 80075c8:	eeb0 6a40 	vmov.f32	s12, s0
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 80075cc:	dd1f      	ble.n	800760e <mla_update_bandwidth_swr2+0x15a>
    float swr_good = getSWRfromIndex((uint16_t)last_good_left);
 80075ce:	4640      	mov	r0, r8
 80075d0:	f7fd ff6e 	bl	80054b0 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 80075d4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80075d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80075dc:	dd17      	ble.n	800760e <mla_update_bandwidth_swr2+0x15a>
 80075de:	eeb4 0ac5 	vcmpe.f32	s0, s10
 80075e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80075e6:	d812      	bhi.n	800760e <mla_update_bandwidth_swr2+0x15a>
      float t = (swr_bw_limit - swr_bad) / (swr_good - swr_bad); // 0..1
 80075e8:	ee35 5a46 	vsub.f32	s10, s10, s12
 80075ec:	ee30 0a46 	vsub.f32	s0, s0, s12
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 80075f0:	4610      	mov	r0, r2
      float t = (swr_bw_limit - swr_bad) / (swr_good - swr_bad); // 0..1
 80075f2:	ee85 7a00 	vdiv.f32	s14, s10, s0
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 80075f6:	f7ff fb05 	bl	8006c04 <getFrequency>
 80075fa:	ee07 0a90 	vmov	s15, r0
 80075fe:	eef8 7a67 	vcvt.f32.u32	s15, s15
      f_low_f = f_bad + t * (f_good - f_bad);
 8007602:	ee75 6ae7 	vsub.f32	s13, s11, s15
 8007606:	eee6 7a87 	vfma.f32	s15, s13, s14
 800760a:	eef0 5a67 	vmov.f32	s11, s15
  float f_high_f = (float)getFrequency((uint16_t)last_good_right);
 800760e:	fa1f f885 	uxth.w	r8, r5
 8007612:	4640      	mov	r0, r8
 8007614:	f7ff faf6 	bl	8006c04 <getFrequency>
  if (last_good_right < (int16_t)sweep_points - 1)
 8007618:	3f01      	subs	r7, #1
  float f_high_f = (float)getFrequency((uint16_t)last_good_right);
 800761a:	ee06 0a10 	vmov	s12, r0
  if (last_good_right < (int16_t)sweep_points - 1)
 800761e:	b23f      	sxth	r7, r7
 8007620:	42bd      	cmp	r5, r7
  float f_high_f = (float)getFrequency((uint16_t)last_good_right);
 8007622:	eeb8 6a46 	vcvt.f32.u32	s12, s12
  if (last_good_right < (int16_t)sweep_points - 1)
 8007626:	da2c      	bge.n	8007682 <mla_update_bandwidth_swr2+0x1ce>
    int16_t bad_i = last_good_right + 1;
 8007628:	f108 0201 	add.w	r2, r8, #1
 800762c:	b292      	uxth	r2, r2
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 800762e:	4610      	mov	r0, r2
 8007630:	f7fd ff3e 	bl	80054b0 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8007634:	eef0 4a00 	vmov.f32	s9, #0	@ 0x40000000  2.0
 8007638:	eeb4 0ae4 	vcmpe.f32	s0, s9
 800763c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    float swr_bad = getSWRfromIndex((uint16_t)bad_i);
 8007640:	eeb0 5a40 	vmov.f32	s10, s0
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 8007644:	dd1d      	ble.n	8007682 <mla_update_bandwidth_swr2+0x1ce>
    float swr_good = getSWRfromIndex((uint16_t)last_good_right);
 8007646:	4640      	mov	r0, r8
 8007648:	f7fd ff32 	bl	80054b0 <getSWRfromIndex>
    if (swr_bad > swr_bw_limit && swr_good > 0.0f && swr_good <= swr_bw_limit && swr_bad != swr_good)
 800764c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8007650:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007654:	dd15      	ble.n	8007682 <mla_update_bandwidth_swr2+0x1ce>
 8007656:	eeb4 0ae4 	vcmpe.f32	s0, s9
 800765a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800765e:	d810      	bhi.n	8007682 <mla_update_bandwidth_swr2+0x1ce>
      float t = (swr_bw_limit - swr_good) / (swr_bad - swr_good); // 0..1
 8007660:	ee74 4ac0 	vsub.f32	s9, s9, s0
 8007664:	ee35 5a40 	vsub.f32	s10, s10, s0
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 8007668:	4610      	mov	r0, r2
      float t = (swr_bw_limit - swr_good) / (swr_bad - swr_good); // 0..1
 800766a:	ee84 7a85 	vdiv.f32	s14, s9, s10
      float f_bad = (float)getFrequency((uint16_t)bad_i);
 800766e:	f7ff fac9 	bl	8006c04 <getFrequency>
 8007672:	ee07 0a90 	vmov	s15, r0
 8007676:	eef8 7a67 	vcvt.f32.u32	s15, s15
      f_high_f = f_good + t * (f_bad - f_good);
 800767a:	ee77 7ac6 	vsub.f32	s15, s15, s12
 800767e:	eea7 6a87 	vfma.f32	s12, s15, s14
  mla_bw_low = (freq_t)(f_low_f + 0.5f);
 8007682:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8007686:	ee75 5aa7 	vadd.f32	s11, s11, s15
  mla_bw_high = (freq_t)(f_high_f + 0.5f);
 800768a:	ee36 6a27 	vadd.f32	s12, s12, s15
  mla_bw_low = (freq_t)(f_low_f + 0.5f);
 800768e:	eefc 7ae5 	vcvt.u32.f32	s15, s11
 8007692:	ee17 8a90 	vmov	r8, s15
  mla_bw_high = (freq_t)(f_high_f + 0.5f);
 8007696:	eefc 7ac6 	vcvt.u32.f32	s15, s12
 800769a:	ee17 7a90 	vmov	r7, s15
  if (mla_bw_high <= mla_bw_low)
 800769e:	45b8      	cmp	r8, r7
 80076a0:	d265      	bcs.n	800776e <mla_update_bandwidth_swr2+0x2ba>
  mla_bw_swr2 = mla_bw_high - mla_bw_low;
 80076a2:	eba7 0908 	sub.w	r9, r7, r8
  const float bw_khz = (float)mla_bw_swr2 / 1000.0f;
 80076a6:	ee07 9a10 	vmov	s14, r9
 80076aa:	eddf 7a3a 	vldr	s15, [pc, #232]	@ 8007794 <mla_update_bandwidth_swr2+0x2e0>
  mla_bw_swr2 = mla_bw_high - mla_bw_low;
 80076ae:	f8c4 9000 	str.w	r9, [r4]
  const float bw_khz = (float)mla_bw_swr2 / 1000.0f;
 80076b2:	eeb8 7a47 	vcvt.f32.u32	s14, s14
  MLA_UART_LOG("[MLA] BW(SWR<=%.1f): f_low=" VNA_FREQ_FMT_STR " Hz (idx=%d), "
 80076b6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80076ba:	ee17 0a90 	vmov	r0, s15
 80076be:	f7f8 ff6f 	bl	80005a0 <__aeabi_f2d>
 80076c2:	e9cd 7502 	strd	r7, r5, [sp, #8]
 80076c6:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80076ca:	e9cd 8600 	strd	r8, r6, [sp]
 80076ce:	f8cd 9010 	str.w	r9, [sp, #16]
 80076d2:	2200      	movs	r2, #0
 80076d4:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80076d8:	482f      	ldr	r0, [pc, #188]	@ (8007798 <mla_update_bandwidth_swr2+0x2e4>)
 80076da:	f7fe f93f 	bl	800595c <serial_shell_printf>
 80076de:	e00c      	b.n	80076fa <mla_update_bandwidth_swr2+0x246>
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (bad center SWR=%.2f idx=%u)\r\n",
 80076e0:	ee16 0a10 	vmov	r0, s12
 80076e4:	9102      	str	r1, [sp, #8]
 80076e6:	f7f8 ff5b 	bl	80005a0 <__aeabi_f2d>
 80076ea:	2200      	movs	r2, #0
 80076ec:	e9cd 0100 	strd	r0, r1, [sp]
 80076f0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80076f4:	4829      	ldr	r0, [pc, #164]	@ (800779c <mla_update_bandwidth_swr2+0x2e8>)
 80076f6:	f7fe f931 	bl	800595c <serial_shell_printf>
}
 80076fa:	b009      	add	sp, #36	@ 0x24
 80076fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (not locked)\r\n", swr_bw_limit);
 8007700:	4827      	ldr	r0, [pc, #156]	@ (80077a0 <mla_update_bandwidth_swr2+0x2ec>)
 8007702:	2200      	movs	r2, #0
 8007704:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
}
 8007708:	b009      	add	sp, #36	@ 0x24
 800770a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (not locked)\r\n", swr_bw_limit);
 800770e:	f7fe b925 	b.w	800595c <serial_shell_printf>
  while (right_idx < (int16_t)sweep_points)
 8007712:	42bd      	cmp	r5, r7
  int16_t last_good_left = -1;
 8007714:	bfb8      	it	lt
 8007716:	f04f 36ff 	movlt.w	r6, #4294967295
  while (right_idx < (int16_t)sweep_points)
 800771a:	f6ff af1a 	blt.w	8007552 <mla_update_bandwidth_swr2+0x9e>
 800771e:	f04f 31ff 	mov.w	r1, #4294967295
 8007722:	460e      	mov	r6, r1
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (left=%d right=%d)\r\n",
 8007724:	e9cd 6100 	strd	r6, r1, [sp]
 8007728:	2200      	movs	r2, #0
 800772a:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 800772e:	481d      	ldr	r0, [pc, #116]	@ (80077a4 <mla_update_bandwidth_swr2+0x2f0>)
 8007730:	f7fe f914 	bl	800595c <serial_shell_printf>
}
 8007734:	b009      	add	sp, #36	@ 0x24
 8007736:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (sweep_points=%u)\r\n",
 800773a:	2200      	movs	r2, #0
 800773c:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8007740:	9700      	str	r7, [sp, #0]
 8007742:	4819      	ldr	r0, [pc, #100]	@ (80077a8 <mla_update_bandwidth_swr2+0x2f4>)
 8007744:	f7fe f90a 	bl	800595c <serial_shell_printf>
}
 8007748:	b009      	add	sp, #36	@ 0x24
 800774a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (center idx out of range: %u)\r\n",
 800774e:	2200      	movs	r2, #0
 8007750:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8007754:	9100      	str	r1, [sp, #0]
 8007756:	4815      	ldr	r0, [pc, #84]	@ (80077ac <mla_update_bandwidth_swr2+0x2f8>)
 8007758:	f7fe f900 	bl	800595c <serial_shell_printf>
}
 800775c:	b009      	add	sp, #36	@ 0x24
 800775e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007762:	461d      	mov	r5, r3
 8007764:	e710      	b.n	8007588 <mla_update_bandwidth_swr2+0xd4>
 8007766:	461e      	mov	r6, r3
 8007768:	e6ed      	b.n	8007546 <mla_update_bandwidth_swr2+0x92>
 800776a:	2600      	movs	r6, #0
 800776c:	e6eb      	b.n	8007546 <mla_update_bandwidth_swr2+0x92>
    MLA_UART_LOG("[MLA] BW(SWR<=%.1f): n/a (f_high<=f_low)\r\n", swr_bw_limit);
 800776e:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8007772:	480f      	ldr	r0, [pc, #60]	@ (80077b0 <mla_update_bandwidth_swr2+0x2fc>)
 8007774:	2200      	movs	r2, #0
 8007776:	f7fe f8f1 	bl	800595c <serial_shell_printf>
    mla_bw_low = mla_bw_high = mla_bw_swr2 = 0;
 800777a:	2300      	movs	r3, #0
 800777c:	6023      	str	r3, [r4, #0]
    return;
 800777e:	e7bc      	b.n	80076fa <mla_update_bandwidth_swr2+0x246>
 8007780:	2000687d 	.word	0x2000687d
 8007784:	20006870 	.word	0x20006870
 8007788:	20000aa8 	.word	0x20000aa8
 800778c:	200003d4 	.word	0x200003d4
 8007790:	42480000 	.word	0x42480000
 8007794:	3a83126f 	.word	0x3a83126f
 8007798:	08013074 	.word	0x08013074
 800779c:	08012fe0 	.word	0x08012fe0
 80077a0:	08012f4c 	.word	0x08012f4c
 80077a4:	08013018 	.word	0x08013018
 80077a8:	08012f74 	.word	0x08012f74
 80077ac:	08012fa4 	.word	0x08012fa4
 80077b0:	08013048 	.word	0x08013048

080077b4 <getFrequencyStep>:
freq_t getFrequencyStep(void) { return _f_delta; }
 80077b4:	4b01      	ldr	r3, [pc, #4]	@ (80077bc <getFrequencyStep+0x8>)
 80077b6:	6818      	ldr	r0, [r3, #0]
 80077b8:	4770      	bx	lr
 80077ba:	bf00      	nop
 80077bc:	20000910 	.word	0x20000910

080077c0 <set_marker_index>:
  if (m == MARKER_INVALID || (uint32_t)idx >= sweep_points)
 80077c0:	1c42      	adds	r2, r0, #1
 80077c2:	d01b      	beq.n	80077fc <set_marker_index+0x3c>
{
 80077c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (m == MARKER_INVALID || (uint32_t)idx >= sweep_points)
 80077c6:	4e0e      	ldr	r6, [pc, #56]	@ (8007800 <set_marker_index+0x40>)
 80077c8:	8b73      	ldrh	r3, [r6, #26]
 80077ca:	428b      	cmp	r3, r1
 80077cc:	460d      	mov	r5, r1
 80077ce:	d914      	bls.n	80077fa <set_marker_index+0x3a>
  markers[m].frequency = getFrequency(idx);
 80077d0:	4604      	mov	r4, r0
 80077d2:	340b      	adds	r4, #11
 80077d4:	b28f      	uxth	r7, r1
 80077d6:	eb06 06c4 	add.w	r6, r6, r4, lsl #3
 80077da:	4638      	mov	r0, r7
 80077dc:	f7ff fa12 	bl	8006c04 <getFrequency>
  if (markers[m].index == idx)
 80077e0:	8873      	ldrh	r3, [r6, #2]
  markers[m].frequency = getFrequency(idx);
 80077e2:	6070      	str	r0, [r6, #4]
  if (markers[m].index == idx)
 80077e4:	42ab      	cmp	r3, r5
 80077e6:	d008      	beq.n	80077fa <set_marker_index+0x3a>
  request_to_draw_marker(markers[m].index); // Mark old marker position for erase
 80077e8:	4618      	mov	r0, r3
 80077ea:	f004 fcf5 	bl	800c1d8 <request_to_draw_marker>
  markers[m].index = idx;                   // Set new position
 80077ee:	8077      	strh	r7, [r6, #2]
  request_to_redraw(REDRAW_MARKER);
 80077f0:	2020      	movs	r0, #32
}
 80077f2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  request_to_redraw(REDRAW_MARKER);
 80077f6:	f004 bfb7 	b.w	800c768 <request_to_redraw>
}
 80077fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80077fc:	4770      	bx	lr
 80077fe:	bf00      	nop
 8007800:	20000aa8 	.word	0x20000aa8

08007804 <update_frequencies>:
{
 8007804:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

inline freq_t
get_sweep_frequency(uint16_t type)
{
  switch (type) {
    case ST_START:  return frequency0;
 8007808:	f8df 80e8 	ldr.w	r8, [pc, #232]	@ 80078f4 <update_frequencies+0xf0>
  _f_start = start;
 800780c:	4a34      	ldr	r2, [pc, #208]	@ (80078e0 <update_frequencies+0xdc>)
  set_frequencies(start, stop, sweep_points);
 800780e:	f8b8 701a 	ldrh.w	r7, [r8, #26]
  _f_delta = span / _f_points;
 8007812:	4934      	ldr	r1, [pc, #208]	@ (80078e4 <update_frequencies+0xe0>)
    case ST_STOP:   return frequency1;
 8007814:	e9d8 6901 	ldrd	r6, r9, [r8, #4]
  _f_points = (points - 1);
 8007818:	3f01      	subs	r7, #1
  freq_t span = stop - start;
 800781a:	eba9 0306 	sub.w	r3, r9, r6
{
 800781e:	ed2d 8b02 	vpush	{d8}
      float r = ((float)(f - fstart)) / (fstop - fstart);
 8007822:	ee07 3a90 	vmov	s15, r3
  _f_start = start;
 8007826:	6016      	str	r6, [r2, #0]
      idx = r * (points - 1);
 8007828:	ee07 7a10 	vmov	s14, r7
  _f_points = (points - 1);
 800782c:	4a2e      	ldr	r2, [pc, #184]	@ (80078e8 <update_frequencies+0xe4>)
 800782e:	b2b8      	uxth	r0, r7
 8007830:	8010      	strh	r0, [r2, #0]
      float r = ((float)(f - fstart)) / (fstop - fstart);
 8007832:	eef8 7a67 	vcvt.f32.u32	s15, s15
      idx = r * (points - 1);
 8007836:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  _f_error = span % _f_points;
 800783a:	4a2c      	ldr	r2, [pc, #176]	@ (80078ec <update_frequencies+0xe8>)
  _f_delta = span / _f_points;
 800783c:	fbb3 f4f0 	udiv	r4, r3, r0
  _f_error = span % _f_points;
 8007840:	fb00 3314 	mls	r3, r0, r4, r3
  _f_delta = span / _f_points;
 8007844:	600c      	str	r4, [r1, #0]
      idx = r * (points - 1);
 8007846:	ee87 8a27 	vdiv.f32	s16, s14, s15
  _f_error = span % _f_points;
 800784a:	6013      	str	r3, [r2, #0]
  for (m = 0; m < MARKERS_MAX; m++)
 800784c:	4645      	mov	r5, r8
 800784e:	2400      	movs	r4, #0
 8007850:	e009      	b.n	8007866 <update_frequencies+0x62>
      idx = markers[m].index; // Not need update index in no freq
 8007852:	f8b5 105a 	ldrh.w	r1, [r5, #90]	@ 0x5a
    set_marker_index(m, idx);
 8007856:	4620      	mov	r0, r4
  for (m = 0; m < MARKERS_MAX; m++)
 8007858:	3401      	adds	r4, #1
    set_marker_index(m, idx);
 800785a:	f7ff ffb1 	bl	80077c0 <set_marker_index>
  for (m = 0; m < MARKERS_MAX; m++)
 800785e:	2c08      	cmp	r4, #8
 8007860:	f105 0508 	add.w	r5, r5, #8
 8007864:	d015      	beq.n	8007892 <update_frequencies+0x8e>
    freq_t f = markers[m].frequency;
 8007866:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
    if (f == 0)
 8007868:	2b00      	cmp	r3, #0
 800786a:	d0f2      	beq.n	8007852 <update_frequencies+0x4e>
    else if (f <= fstart)
 800786c:	429e      	cmp	r6, r3
      idx = points - 1;
 800786e:	4639      	mov	r1, r7
    else if (f <= fstart)
 8007870:	d20d      	bcs.n	800788e <update_frequencies+0x8a>
      float r = ((float)(f - fstart)) / (fstop - fstart);
 8007872:	1b9a      	subs	r2, r3, r6
 8007874:	ee07 2a90 	vmov	s15, r2
 8007878:	eef8 7a67 	vcvt.f32.u32	s15, s15
    else if (f >= fstop)
 800787c:	4599      	cmp	r9, r3
      idx = r * (points - 1);
 800787e:	ee68 7a27 	vmul.f32	s15, s16, s15
    else if (f >= fstop)
 8007882:	d9e8      	bls.n	8007856 <update_frequencies+0x52>
      idx = r * (points - 1);
 8007884:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8007888:	ee17 1a90 	vmov	r1, s15
 800788c:	e7e3      	b.n	8007856 <update_frequencies+0x52>
      idx = 0;
 800788e:	2100      	movs	r1, #0
 8007890:	e7e1      	b.n	8007856 <update_frequencies+0x52>
  update_grid(start, stop);
 8007892:	4649      	mov	r1, r9
 8007894:	4630      	mov	r0, r6
 8007896:	f004 fc49 	bl	800c12c <update_grid>
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 800789a:	f8d8 200c 	ldr.w	r2, [r8, #12]
    cal_status &= ~CALSTAT_INTERPOLATED;
 800789e:	f8b8 3024 	ldrh.w	r3, [r8, #36]	@ 0x24
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 80078a2:	4296      	cmp	r6, r2
 80078a4:	d00e      	beq.n	80078c4 <update_frequencies+0xc0>
    cal_status |= CALSTAT_INTERPOLATED;
 80078a6:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
  request_to_redraw(REDRAW_BACKUP | REDRAW_PLOT | REDRAW_CAL_STATUS | REDRAW_FREQUENCY | REDRAW_AREA);
 80078aa:	f240 401b 	movw	r0, #1051	@ 0x41b
 80078ae:	f8a8 3024 	strh.w	r3, [r8, #36]	@ 0x24
 80078b2:	f004 ff59 	bl	800c768 <request_to_redraw>
}
 80078b6:	ecbd 8b02 	vpop	{d8}
  RESET_SWEEP;
 80078ba:	4b0d      	ldr	r3, [pc, #52]	@ (80078f0 <update_frequencies+0xec>)
 80078bc:	2200      	movs	r2, #0
 80078be:	801a      	strh	r2, [r3, #0]
}
 80078c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 80078c4:	f8d8 2010 	ldr.w	r2, [r8, #16]
 80078c8:	4591      	cmp	r9, r2
 80078ca:	d1ec      	bne.n	80078a6 <update_frequencies+0xa2>
 80078cc:	f8b8 101a 	ldrh.w	r1, [r8, #26]
 80078d0:	f8b8 2022 	ldrh.w	r2, [r8, #34]	@ 0x22
 80078d4:	4291      	cmp	r1, r2
 80078d6:	d1e6      	bne.n	80078a6 <update_frequencies+0xa2>
    cal_status &= ~CALSTAT_INTERPOLATED;
 80078d8:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 80078dc:	b29b      	uxth	r3, r3
 80078de:	e7e4      	b.n	80078aa <update_frequencies+0xa6>
 80078e0:	20000914 	.word	0x20000914
 80078e4:	20000910 	.word	0x20000910
 80078e8:	20000908 	.word	0x20000908
 80078ec:	2000090c 	.word	0x2000090c
 80078f0:	20006864 	.word	0x20006864
 80078f4:	20000aa8 	.word	0x20000aa8

080078f8 <load_properties>:
{
 80078f8:	b510      	push	{r4, lr}
  int r = caldata_recall(id);
 80078fa:	f009 ffd1 	bl	80118a0 <caldata_recall>
 80078fe:	4604      	mov	r4, r0
  update_frequencies();
 8007900:	f7ff ff80 	bl	8007804 <update_frequencies>
  plot_set_measure_mode(current_props._measure);
 8007904:	4b03      	ldr	r3, [pc, #12]	@ (8007914 <load_properties+0x1c>)
 8007906:	f893 0021 	ldrb.w	r0, [r3, #33]	@ 0x21
 800790a:	f004 ff41 	bl	800c790 <plot_set_measure_mode>
}
 800790e:	4620      	mov	r0, r4
 8007910:	bd10      	pop	{r4, pc}
 8007912:	bf00      	nop
 8007914:	20000aa8 	.word	0x20000aa8

08007918 <cmd_recall>:
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 8007918:	2801      	cmp	r0, #1
 800791a:	d004      	beq.n	8007926 <cmd_recall+0xe>
  shell_printf("usage: %s 0..%d" VNA_SHELL_NEWLINE_STR, SAVEAREA_MAX - 1, "recall");
 800791c:	4a0d      	ldr	r2, [pc, #52]	@ (8007954 <cmd_recall+0x3c>)
 800791e:	480e      	ldr	r0, [pc, #56]	@ (8007958 <cmd_recall+0x40>)
 8007920:	2106      	movs	r1, #6
 8007922:	f7fe bb7d 	b.w	8006020 <shell_printf>
{
 8007926:	b508      	push	{r3, lr}
  if (argc == 1 && (id = my_atoui(argv[0])) < SAVEAREA_MAX)
 8007928:	6808      	ldr	r0, [r1, #0]
 800792a:	f001 ffff 	bl	800992c <my_atoui>
 800792e:	2806      	cmp	r0, #6
 8007930:	d906      	bls.n	8007940 <cmd_recall+0x28>
}
 8007932:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shell_printf("usage: %s 0..%d" VNA_SHELL_NEWLINE_STR, SAVEAREA_MAX - 1, "recall");
 8007936:	4a07      	ldr	r2, [pc, #28]	@ (8007954 <cmd_recall+0x3c>)
 8007938:	4807      	ldr	r0, [pc, #28]	@ (8007958 <cmd_recall+0x40>)
 800793a:	2106      	movs	r1, #6
 800793c:	f7fe bb70 	b.w	8006020 <shell_printf>
    if (load_properties(id)) // Check for success
 8007940:	f7ff ffda 	bl	80078f8 <load_properties>
 8007944:	b900      	cbnz	r0, 8007948 <cmd_recall+0x30>
}
 8007946:	bd08      	pop	{r3, pc}
 8007948:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      shell_printf("Err, default load" VNA_SHELL_NEWLINE_STR);
 800794c:	4803      	ldr	r0, [pc, #12]	@ (800795c <cmd_recall+0x44>)
 800794e:	f7fe bb67 	b.w	8006020 <shell_printf>
 8007952:	bf00      	nop
 8007954:	080130e0 	.word	0x080130e0
 8007958:	08012bd0 	.word	0x08012bd0
 800795c:	080130cc 	.word	0x080130cc

08007960 <set_sweep_points>:
  if (points > SWEEP_POINTS_MAX)
 8007960:	2815      	cmp	r0, #21
  if (points == sweep_points)
 8007962:	4b07      	ldr	r3, [pc, #28]	@ (8007980 <set_sweep_points+0x20>)
  if (points > SWEEP_POINTS_MAX)
 8007964:	bf38      	it	cc
 8007966:	2015      	movcc	r0, #21
 8007968:	f240 1191 	movw	r1, #401	@ 0x191
 800796c:	4288      	cmp	r0, r1
  if (points == sweep_points)
 800796e:	8b5a      	ldrh	r2, [r3, #26]
  if (points > SWEEP_POINTS_MAX)
 8007970:	bf28      	it	cs
 8007972:	4608      	movcs	r0, r1
  if (points == sweep_points)
 8007974:	4282      	cmp	r2, r0
 8007976:	d002      	beq.n	800797e <set_sweep_points+0x1e>
  sweep_points = points;
 8007978:	8358      	strh	r0, [r3, #26]
  update_frequencies();
 800797a:	f7ff bf43 	b.w	8007804 <update_frequencies>
}
 800797e:	4770      	bx	lr
 8007980:	20000aa8 	.word	0x20000aa8

08007984 <cmd_resume>:
{
 8007984:	b508      	push	{r3, lr}
  update_frequencies();
 8007986:	f7ff ff3d 	bl	8007804 <update_frequencies>
  sweep_mode |= SWEEP_ENABLE;
 800798a:	4a03      	ldr	r2, [pc, #12]	@ (8007998 <cmd_resume+0x14>)
 800798c:	7813      	ldrb	r3, [r2, #0]
 800798e:	f043 0301 	orr.w	r3, r3, #1
 8007992:	7013      	strb	r3, [r2, #0]
}
 8007994:	bd08      	pop	{r3, pc}
 8007996:	bf00      	nop
 8007998:	200003c4 	.word	0x200003c4

0800799c <cmd_marker>:
{
 800799c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (argc == 0)
 80079a0:	4604      	mov	r4, r0
 80079a2:	b9b8      	cbnz	r0, 80079d4 <cmd_marker+0x38>
 80079a4:	4d42      	ldr	r5, [pc, #264]	@ (8007ab0 <cmd_marker+0x114>)
 80079a6:	e003      	b.n	80079b0 <cmd_marker+0x14>
    for (t = 0; t < MARKERS_MAX; t++)
 80079a8:	2c08      	cmp	r4, #8
 80079aa:	f105 0508 	add.w	r5, r5, #8
 80079ae:	d00f      	beq.n	80079d0 <cmd_marker+0x34>
      if (markers[t].enabled)
 80079b0:	f895 3058 	ldrb.w	r3, [r5, #88]	@ 0x58
        shell_printf("%d %d " VNA_FREQ_FMT_STR "" VNA_SHELL_NEWLINE_STR, t + 1, markers[t].index, markers[t].frequency);
 80079b4:	3401      	adds	r4, #1
      if (markers[t].enabled)
 80079b6:	2b00      	cmp	r3, #0
 80079b8:	d0f6      	beq.n	80079a8 <cmd_marker+0xc>
        shell_printf("%d %d " VNA_FREQ_FMT_STR "" VNA_SHELL_NEWLINE_STR, t + 1, markers[t].index, markers[t].frequency);
 80079ba:	6deb      	ldr	r3, [r5, #92]	@ 0x5c
 80079bc:	f8b5 205a 	ldrh.w	r2, [r5, #90]	@ 0x5a
 80079c0:	483c      	ldr	r0, [pc, #240]	@ (8007ab4 <cmd_marker+0x118>)
 80079c2:	4621      	mov	r1, r4
 80079c4:	f7fe fb2c 	bl	8006020 <shell_printf>
    for (t = 0; t < MARKERS_MAX; t++)
 80079c8:	2c08      	cmp	r4, #8
 80079ca:	f105 0508 	add.w	r5, r5, #8
 80079ce:	d1ef      	bne.n	80079b0 <cmd_marker+0x14>
}
 80079d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  request_to_redraw(REDRAW_MARKER | REDRAW_AREA);
 80079d4:	460d      	mov	r5, r1
 80079d6:	2022      	movs	r0, #34	@ 0x22
 80079d8:	f004 fec6 	bl	800c768 <request_to_redraw>
  int enable = get_str_index(argv[0], cmd_marker_list);
 80079dc:	4936      	ldr	r1, [pc, #216]	@ (8007ab8 <cmd_marker+0x11c>)
 80079de:	6828      	ldr	r0, [r5, #0]
 80079e0:	f002 f864 	bl	8009aac <get_str_index>
  if (enable >= 0)
 80079e4:	2800      	cmp	r0, #0
 80079e6:	db1c      	blt.n	8007a22 <cmd_marker+0x86>
    active_marker = enable == 1 ? MARKER_INVALID : 0;
 80079e8:	4a31      	ldr	r2, [pc, #196]	@ (8007ab0 <cmd_marker+0x114>)
      markers[t].enabled = enable == 0;
 80079ea:	fab0 f380 	clz	r3, r0
    active_marker = enable == 1 ? MARKER_INVALID : 0;
 80079ee:	2801      	cmp	r0, #1
      markers[t].enabled = enable == 0;
 80079f0:	ea4f 1353 	mov.w	r3, r3, lsr #5
    active_marker = enable == 1 ? MARKER_INVALID : 0;
 80079f4:	f04f 30ff 	mov.w	r0, #4294967295
 80079f8:	bf18      	it	ne
 80079fa:	2000      	movne	r0, #0
 80079fc:	7750      	strb	r0, [r2, #29]
      markers[t].enabled = enable == 0;
 80079fe:	f882 3058 	strb.w	r3, [r2, #88]	@ 0x58
 8007a02:	f882 3060 	strb.w	r3, [r2, #96]	@ 0x60
 8007a06:	f882 3068 	strb.w	r3, [r2, #104]	@ 0x68
 8007a0a:	f882 3070 	strb.w	r3, [r2, #112]	@ 0x70
 8007a0e:	f882 3078 	strb.w	r3, [r2, #120]	@ 0x78
 8007a12:	f882 3080 	strb.w	r3, [r2, #128]	@ 0x80
 8007a16:	f882 3088 	strb.w	r3, [r2, #136]	@ 0x88
 8007a1a:	f882 3090 	strb.w	r3, [r2, #144]	@ 0x90
}
 8007a1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  t = my_atoi(argv[0]) - 1;
 8007a22:	6828      	ldr	r0, [r5, #0]
 8007a24:	f001 ff68 	bl	80098f8 <my_atoi>
 8007a28:	1e47      	subs	r7, r0, #1
  if (t < 0 || t >= MARKERS_MAX)
 8007a2a:	2f07      	cmp	r7, #7
  t = my_atoi(argv[0]) - 1;
 8007a2c:	4606      	mov	r6, r0
  if (t < 0 || t >= MARKERS_MAX)
 8007a2e:	d829      	bhi.n	8007a84 <cmd_marker+0xe8>
  if (argc == 1)
 8007a30:	2c01      	cmp	r4, #1
 8007a32:	d02d      	beq.n	8007a90 <cmd_marker+0xf4>
  switch (get_str_index(argv[1], cmd_marker_list))
 8007a34:	4920      	ldr	r1, [pc, #128]	@ (8007ab8 <cmd_marker+0x11c>)
 8007a36:	6868      	ldr	r0, [r5, #4]
 8007a38:	f002 f838 	bl	8009aac <get_str_index>
 8007a3c:	b1d8      	cbz	r0, 8007a76 <cmd_marker+0xda>
 8007a3e:	2801      	cmp	r0, #1
 8007a40:	d10b      	bne.n	8007a5a <cmd_marker+0xbe>
    markers[t].enabled = FALSE;
 8007a42:	4b1b      	ldr	r3, [pc, #108]	@ (8007ab0 <cmd_marker+0x114>)
    if (active_marker == t)
 8007a44:	f993 201d 	ldrsb.w	r2, [r3, #29]
    markers[t].enabled = FALSE;
 8007a48:	360a      	adds	r6, #10
 8007a4a:	2100      	movs	r1, #0
    if (active_marker == t)
 8007a4c:	42ba      	cmp	r2, r7
    markers[t].enabled = FALSE;
 8007a4e:	f803 1036 	strb.w	r1, [r3, r6, lsl #3]
    if (active_marker == t)
 8007a52:	d1bd      	bne.n	80079d0 <cmd_marker+0x34>
      active_marker = MARKER_INVALID;
 8007a54:	22ff      	movs	r2, #255	@ 0xff
 8007a56:	775a      	strb	r2, [r3, #29]
 8007a58:	e7ba      	b.n	80079d0 <cmd_marker+0x34>
    markers[t].enabled = TRUE;
 8007a5a:	4c15      	ldr	r4, [pc, #84]	@ (8007ab0 <cmd_marker+0x114>)
 8007a5c:	360a      	adds	r6, #10
 8007a5e:	2301      	movs	r3, #1
 8007a60:	f804 3036 	strb.w	r3, [r4, r6, lsl #3]
    int index = my_atoi(argv[1]);
 8007a64:	6868      	ldr	r0, [r5, #4]
 8007a66:	f001 ff47 	bl	80098f8 <my_atoi>
 8007a6a:	4601      	mov	r1, r0
    set_marker_index(t, index);
 8007a6c:	4638      	mov	r0, r7
 8007a6e:	f7ff fea7 	bl	80077c0 <set_marker_index>
    active_marker = t;
 8007a72:	7767      	strb	r7, [r4, #29]
    return;
 8007a74:	e7ac      	b.n	80079d0 <cmd_marker+0x34>
    markers[t].enabled = TRUE;
 8007a76:	4b0e      	ldr	r3, [pc, #56]	@ (8007ab0 <cmd_marker+0x114>)
 8007a78:	360a      	adds	r6, #10
 8007a7a:	2201      	movs	r2, #1
 8007a7c:	f803 2036 	strb.w	r2, [r3, r6, lsl #3]
    active_marker = t;
 8007a80:	775f      	strb	r7, [r3, #29]
    return;
 8007a82:	e7a5      	b.n	80079d0 <cmd_marker+0x34>
}
 8007a84:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  shell_printf("marker [n] [%s|{index}]" VNA_SHELL_NEWLINE_STR, cmd_marker_list);
 8007a88:	490b      	ldr	r1, [pc, #44]	@ (8007ab8 <cmd_marker+0x11c>)
 8007a8a:	480c      	ldr	r0, [pc, #48]	@ (8007abc <cmd_marker+0x120>)
 8007a8c:	f7fe bac8 	b.w	8006020 <shell_printf>
    shell_printf("%d %d " VNA_FREQ_FMT_STR "" VNA_SHELL_NEWLINE_STR, t + 1, markers[t].index, markers[t].frequency);
 8007a90:	4d07      	ldr	r5, [pc, #28]	@ (8007ab0 <cmd_marker+0x114>)
 8007a92:	f100 080a 	add.w	r8, r0, #10
 8007a96:	eb05 02c8 	add.w	r2, r5, r8, lsl #3
 8007a9a:	4601      	mov	r1, r0
 8007a9c:	6853      	ldr	r3, [r2, #4]
 8007a9e:	4805      	ldr	r0, [pc, #20]	@ (8007ab4 <cmd_marker+0x118>)
 8007aa0:	8852      	ldrh	r2, [r2, #2]
 8007aa2:	f7fe fabd 	bl	8006020 <shell_printf>
    markers[t].enabled = TRUE;
 8007aa6:	f805 4038 	strb.w	r4, [r5, r8, lsl #3]
    active_marker = t;
 8007aaa:	776f      	strb	r7, [r5, #29]
    return;
 8007aac:	e790      	b.n	80079d0 <cmd_marker+0x34>
 8007aae:	bf00      	nop
 8007ab0:	20000aa8 	.word	0x20000aa8
 8007ab4:	080130e8 	.word	0x080130e8
 8007ab8:	08015bf0 	.word	0x08015bf0
 8007abc:	080130f4 	.word	0x080130f4

08007ac0 <get_marker_frequency>:
  if ((uint32_t)marker >= MARKERS_MAX)
 8007ac0:	2807      	cmp	r0, #7
  return markers[marker].frequency;
 8007ac2:	bf9d      	ittte	ls
 8007ac4:	4b02      	ldrls	r3, [pc, #8]	@ (8007ad0 <get_marker_frequency+0x10>)
 8007ac6:	eb03 03c0 	addls.w	r3, r3, r0, lsl #3
 8007aca:	6dd8      	ldrls	r0, [r3, #92]	@ 0x5c
    return 0;
 8007acc:	2000      	movhi	r0, #0
}
 8007ace:	4770      	bx	lr
 8007ad0:	20000aa8 	.word	0x20000aa8

08007ad4 <set_sweep_frequency>:
  if (type < ST_SPAN && freq < FREQUENCY_MIN)
 8007ad4:	2803      	cmp	r0, #3
{
 8007ad6:	b430      	push	{r4, r5}
  if (type < ST_SPAN && freq < FREQUENCY_MIN)
 8007ad8:	d81d      	bhi.n	8007b16 <set_sweep_frequency+0x42>
 8007ada:	f5b1 7f16 	cmp.w	r1, #600	@ 0x258
 8007ade:	bf38      	it	cc
 8007ae0:	f44f 7116 	movcc.w	r1, #600	@ 0x258
  if (freq > FREQUENCY_MAX)
 8007ae4:	4b41      	ldr	r3, [pc, #260]	@ (8007bec <set_sweep_frequency+0x118>)
 8007ae6:	4299      	cmp	r1, r3
 8007ae8:	bf28      	it	cs
 8007aea:	4619      	movcs	r1, r3
  switch (type)
 8007aec:	2806      	cmp	r0, #6
 8007aee:	d80f      	bhi.n	8007b10 <set_sweep_frequency+0x3c>
 8007af0:	e8df f000 	tbb	[pc, r0]
 8007af4:	674a7504 	.word	0x674a7504
 8007af8:	0e79      	.short	0x0e79
 8007afa:	6e          	.byte	0x6e
 8007afb:	00          	.byte	0x00
    FREQ_STARTSTOP();
 8007afc:	4b3c      	ldr	r3, [pc, #240]	@ (8007bf0 <set_sweep_frequency+0x11c>)
 8007afe:	8b1a      	ldrh	r2, [r3, #24]
    if (frequency1 < freq)
 8007b00:	6898      	ldr	r0, [r3, #8]
    frequency0 = freq;
 8007b02:	6059      	str	r1, [r3, #4]
    FREQ_STARTSTOP();
 8007b04:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
    if (frequency1 < freq)
 8007b08:	4288      	cmp	r0, r1
    FREQ_STARTSTOP();
 8007b0a:	831a      	strh	r2, [r3, #24]
    if (frequency1 < freq)
 8007b0c:	d200      	bcs.n	8007b10 <set_sweep_frequency+0x3c>
    frequency0 = freq;
 8007b0e:	6099      	str	r1, [r3, #8]
}
 8007b10:	bc30      	pop	{r4, r5}
  update_frequencies();
 8007b12:	f7ff be77 	b.w	8007804 <update_frequencies>
  if (type == ST_STEP)
 8007b16:	2805      	cmp	r0, #5
 8007b18:	d1e4      	bne.n	8007ae4 <set_sweep_frequency+0x10>
    freq *= (sweep_points - 1);
 8007b1a:	4b35      	ldr	r3, [pc, #212]	@ (8007bf0 <set_sweep_frequency+0x11c>)
 8007b1c:	8b5a      	ldrh	r2, [r3, #26]
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 8007b1e:	8b18      	ldrh	r0, [r3, #24]
    freq *= (sweep_points - 1);
 8007b20:	3a01      	subs	r2, #1
 8007b22:	fb01 f202 	mul.w	r2, r1, r2
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 8007b26:	0641      	lsls	r1, r0, #25
 8007b28:	d40d      	bmi.n	8007b46 <set_sweep_frequency+0x72>
      freq += frequency0;
 8007b2a:	685c      	ldr	r4, [r3, #4]
  if (freq > FREQUENCY_MAX)
 8007b2c:	4d2f      	ldr	r5, [pc, #188]	@ (8007bec <set_sweep_frequency+0x118>)
      freq += frequency0;
 8007b2e:	1911      	adds	r1, r2, r4
  if (freq > FREQUENCY_MAX)
 8007b30:	42a9      	cmp	r1, r5
 8007b32:	bf28      	it	cs
 8007b34:	4629      	movcs	r1, r5
    FREQ_STARTSTOP()
 8007b36:	f020 0040 	bic.w	r0, r0, #64	@ 0x40
    if (frequency0 > freq)
 8007b3a:	42a1      	cmp	r1, r4
    FREQ_STARTSTOP()
 8007b3c:	8318      	strh	r0, [r3, #24]
    frequency1 = freq;
 8007b3e:	6099      	str	r1, [r3, #8]
    if (frequency0 > freq)
 8007b40:	d2e6      	bcs.n	8007b10 <set_sweep_frequency+0x3c>
      frequency0 = freq;
 8007b42:	6059      	str	r1, [r3, #4]
 8007b44:	e7e4      	b.n	8007b10 <set_sweep_frequency+0x3c>
  if (freq > FREQUENCY_MAX)
 8007b46:	4929      	ldr	r1, [pc, #164]	@ (8007bec <set_sweep_frequency+0x118>)
 8007b48:	4291      	cmp	r1, r2
 8007b4a:	bf28      	it	cs
 8007b4c:	4611      	movcs	r1, r2
    case ST_CENTER: return (frequency0>>1) + (frequency1>>1) + (frequency0&1);
 8007b4e:	e9d3 4501 	ldrd	r4, r5, [r3, #4]
 8007b52:	0862      	lsrs	r2, r4, #1
    span = freq >> 1;
 8007b54:	0849      	lsrs	r1, r1, #1
    FREQ_CENTERSPAN();
 8007b56:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 8007b5a:	eb02 0255 	add.w	r2, r2, r5, lsr #1
 8007b5e:	f004 0401 	and.w	r4, r4, #1
 8007b62:	4422      	add	r2, r4
 8007b64:	8318      	strh	r0, [r3, #24]
    if (center < FREQUENCY_MIN + span)
 8007b66:	f501 7416 	add.w	r4, r1, #600	@ 0x258
    if (center > FREQUENCY_MAX - span)
 8007b6a:	4820      	ldr	r0, [pc, #128]	@ (8007bec <set_sweep_frequency+0x118>)
    if (center < FREQUENCY_MIN + span)
 8007b6c:	42a2      	cmp	r2, r4
 8007b6e:	bf38      	it	cc
 8007b70:	4622      	movcc	r2, r4
    if (center > FREQUENCY_MAX - span)
 8007b72:	1a40      	subs	r0, r0, r1
 8007b74:	4282      	cmp	r2, r0
 8007b76:	bf28      	it	cs
 8007b78:	4602      	movcs	r2, r0
    frequency0 = center - span;
 8007b7a:	1a50      	subs	r0, r2, r1
}
 8007b7c:	bc30      	pop	{r4, r5}
    frequency1 = center + span;
 8007b7e:	440a      	add	r2, r1
 8007b80:	e9c3 0201 	strd	r0, r2, [r3, #4]
  update_frequencies();
 8007b84:	f7ff be3e 	b.w	8007804 <update_frequencies>
    FREQ_CENTERSPAN();
 8007b88:	4a19      	ldr	r2, [pc, #100]	@ (8007bf0 <set_sweep_frequency+0x11c>)
    if (span > FREQUENCY_MAX - center)
 8007b8a:	4d18      	ldr	r5, [pc, #96]	@ (8007bec <set_sweep_frequency+0x118>)
    span = (frequency1 - frequency0 + 1) >> 1;
 8007b8c:	e9d2 0301 	ldrd	r0, r3, [r2, #4]
    if (span > center - FREQUENCY_MIN)
 8007b90:	f5a1 7416 	sub.w	r4, r1, #600	@ 0x258
    if (span > FREQUENCY_MAX - center)
 8007b94:	1a6d      	subs	r5, r5, r1
    span = (frequency1 - frequency0 + 1) >> 1;
 8007b96:	3301      	adds	r3, #1
    if (span > FREQUENCY_MAX - center)
 8007b98:	42ac      	cmp	r4, r5
    span = (frequency1 - frequency0 + 1) >> 1;
 8007b9a:	eba3 0300 	sub.w	r3, r3, r0
 8007b9e:	ea4f 0353 	mov.w	r3, r3, lsr #1
    if (span > FREQUENCY_MAX - center)
 8007ba2:	bf28      	it	cs
 8007ba4:	462c      	movcs	r4, r5
    FREQ_CENTERSPAN();
 8007ba6:	8b10      	ldrh	r0, [r2, #24]
    if (span > FREQUENCY_MAX - center)
 8007ba8:	42a3      	cmp	r3, r4
 8007baa:	bf28      	it	cs
 8007bac:	4623      	movcs	r3, r4
    FREQ_CENTERSPAN();
 8007bae:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 8007bb2:	8310      	strh	r0, [r2, #24]
}
 8007bb4:	bc30      	pop	{r4, r5}
    frequency0 = center - span;
 8007bb6:	1ac8      	subs	r0, r1, r3
    frequency1 = center + span;
 8007bb8:	440b      	add	r3, r1
 8007bba:	e9c2 0301 	strd	r0, r3, [r2, #4]
  update_frequencies();
 8007bbe:	f7ff be21 	b.w	8007804 <update_frequencies>
    FREQ_CENTERSPAN();
 8007bc2:	4b0b      	ldr	r3, [pc, #44]	@ (8007bf0 <set_sweep_frequency+0x11c>)
 8007bc4:	8b1a      	ldrh	r2, [r3, #24]
    frequency0 = freq;
 8007bc6:	6059      	str	r1, [r3, #4]
    FREQ_CENTERSPAN();
 8007bc8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8007bcc:	831a      	strh	r2, [r3, #24]
 8007bce:	e79e      	b.n	8007b0e <set_sweep_frequency+0x3a>
    var_freq = freq;
 8007bd0:	4b07      	ldr	r3, [pc, #28]	@ (8007bf0 <set_sweep_frequency+0x11c>)
}
 8007bd2:	bc30      	pop	{r4, r5}
    request_to_redraw(REDRAW_BACKUP);
 8007bd4:	f44f 6080 	mov.w	r0, #1024	@ 0x400
    var_freq = freq;
 8007bd8:	6159      	str	r1, [r3, #20]
    request_to_redraw(REDRAW_BACKUP);
 8007bda:	f004 bdc5 	b.w	800c768 <request_to_redraw>
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 8007bde:	4b04      	ldr	r3, [pc, #16]	@ (8007bf0 <set_sweep_frequency+0x11c>)
 8007be0:	8b18      	ldrh	r0, [r3, #24]
      freq += frequency0;
 8007be2:	685c      	ldr	r4, [r3, #4]
 8007be4:	e7a7      	b.n	8007b36 <set_sweep_frequency+0x62>
    type = FREQ_IS_CENTERSPAN() ? ST_SPAN : ST_STOP;
 8007be6:	4b02      	ldr	r3, [pc, #8]	@ (8007bf0 <set_sweep_frequency+0x11c>)
 8007be8:	8b18      	ldrh	r0, [r3, #24]
 8007bea:	e7b0      	b.n	8007b4e <set_sweep_frequency+0x7a>
 8007bec:	a0eebb00 	.word	0xa0eebb00
 8007bf0:	20000aa8 	.word	0x20000aa8

08007bf4 <cmd_sweep>:
  if (argc == 0)
 8007bf4:	b318      	cbz	r0, 8007c3e <cmd_sweep+0x4a>
  else if (argc > 3)
 8007bf6:	2803      	cmp	r0, #3
{
 8007bf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007bfc:	4604      	mov	r4, r0
  else if (argc > 3)
 8007bfe:	dc18      	bgt.n	8007c32 <cmd_sweep+0x3e>
  if (argc >= 1)
 8007c00:	2800      	cmp	r0, #0
 8007c02:	dc01      	bgt.n	8007c08 <cmd_sweep+0x14>
}
 8007c04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    value0 = my_atoui(argv[0]);
 8007c08:	6808      	ldr	r0, [r1, #0]
 8007c0a:	460d      	mov	r5, r1
 8007c0c:	f001 fe8e 	bl	800992c <my_atoui>
  if (argc >= 2)
 8007c10:	2c01      	cmp	r4, #1
    value0 = my_atoui(argv[0]);
 8007c12:	4606      	mov	r6, r0
  if (argc >= 2)
 8007c14:	d11a      	bne.n	8007c4c <cmd_sweep+0x58>
  if (value0)
 8007c16:	2800      	cmp	r0, #0
 8007c18:	d0f4      	beq.n	8007c04 <cmd_sweep+0x10>
    set_sweep_frequency(ST_START, value0);
 8007c1a:	4601      	mov	r1, r0
}
 8007c1c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    set_sweep_frequency(ST_START, value0);
 8007c20:	2000      	movs	r0, #0
 8007c22:	f7ff bf57 	b.w	8007ad4 <set_sweep_frequency>
    int type = get_str_index(argv[0], sweep_cmd);
 8007c26:	4921      	ldr	r1, [pc, #132]	@ (8007cac <cmd_sweep+0xb8>)
 8007c28:	6828      	ldr	r0, [r5, #0]
 8007c2a:	f001 ff3f 	bl	8009aac <get_str_index>
    if (type == -1)
 8007c2e:	1c43      	adds	r3, r0, #1
 8007c30:	d136      	bne.n	8007ca0 <cmd_sweep+0xac>
}
 8007c32:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  shell_printf("usage: sweep {start(Hz)} [stop(Hz)] [points]" VNA_SHELL_NEWLINE_STR
 8007c36:	491d      	ldr	r1, [pc, #116]	@ (8007cac <cmd_sweep+0xb8>)
 8007c38:	481d      	ldr	r0, [pc, #116]	@ (8007cb0 <cmd_sweep+0xbc>)
 8007c3a:	f7fe b9f1 	b.w	8006020 <shell_printf>
    shell_printf(VNA_FREQ_FMT_STR " " VNA_FREQ_FMT_STR " %d" VNA_SHELL_NEWLINE_STR, get_sweep_frequency(ST_START), get_sweep_frequency(ST_STOP), sweep_points);
 8007c3e:	491d      	ldr	r1, [pc, #116]	@ (8007cb4 <cmd_sweep+0xc0>)
 8007c40:	481d      	ldr	r0, [pc, #116]	@ (8007cb8 <cmd_sweep+0xc4>)
 8007c42:	8b4b      	ldrh	r3, [r1, #26]
 8007c44:	e9d1 1201 	ldrd	r1, r2, [r1, #4]
 8007c48:	f7fe b9ea 	b.w	8006020 <shell_printf>
    value1 = my_atoui(argv[1]);
 8007c4c:	6868      	ldr	r0, [r5, #4]
 8007c4e:	f001 fe6d 	bl	800992c <my_atoui>
  if (argc >= 3)
 8007c52:	2c03      	cmp	r4, #3
    value1 = my_atoui(argv[1]);
 8007c54:	4607      	mov	r7, r0
  if (argc >= 3)
 8007c56:	d115      	bne.n	8007c84 <cmd_sweep+0x90>
    value2 = my_atoui(argv[2]);
 8007c58:	68a8      	ldr	r0, [r5, #8]
 8007c5a:	f001 fe67 	bl	800992c <my_atoui>
 8007c5e:	4604      	mov	r4, r0
  if (value0)
 8007c60:	b95e      	cbnz	r6, 8007c7a <cmd_sweep+0x86>
  if (value1)
 8007c62:	b11f      	cbz	r7, 8007c6c <cmd_sweep+0x78>
    set_sweep_frequency(ST_STOP, value1);
 8007c64:	4639      	mov	r1, r7
 8007c66:	2001      	movs	r0, #1
 8007c68:	f7ff ff34 	bl	8007ad4 <set_sweep_frequency>
  if (value2)
 8007c6c:	2c00      	cmp	r4, #0
 8007c6e:	d0c9      	beq.n	8007c04 <cmd_sweep+0x10>
    set_sweep_points(value2);
 8007c70:	b2a0      	uxth	r0, r4
}
 8007c72:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    set_sweep_points(value2);
 8007c76:	f7ff be73 	b.w	8007960 <set_sweep_points>
    set_sweep_frequency(ST_START, value0);
 8007c7a:	4631      	mov	r1, r6
 8007c7c:	2000      	movs	r0, #0
 8007c7e:	f7ff ff29 	bl	8007ad4 <set_sweep_frequency>
 8007c82:	e7ee      	b.n	8007c62 <cmd_sweep+0x6e>
  if (argc == 2 && value0 == 0)
 8007c84:	2e00      	cmp	r6, #0
 8007c86:	d0ce      	beq.n	8007c26 <cmd_sweep+0x32>
    set_sweep_frequency(ST_START, value0);
 8007c88:	4631      	mov	r1, r6
 8007c8a:	2000      	movs	r0, #0
 8007c8c:	f7ff ff22 	bl	8007ad4 <set_sweep_frequency>
  if (value1)
 8007c90:	2f00      	cmp	r7, #0
 8007c92:	d0b7      	beq.n	8007c04 <cmd_sweep+0x10>
    set_sweep_frequency(ST_STOP, value1);
 8007c94:	4639      	mov	r1, r7
 8007c96:	2001      	movs	r0, #1
}
 8007c98:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    set_sweep_frequency(ST_STOP, value1);
 8007c9c:	f7ff bf1a 	b.w	8007ad4 <set_sweep_frequency>
    set_sweep_frequency(type, value1);
 8007ca0:	4639      	mov	r1, r7
 8007ca2:	b280      	uxth	r0, r0
}
 8007ca4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    set_sweep_frequency(type, value1);
 8007ca8:	f7ff bf14 	b.w	8007ad4 <set_sweep_frequency>
 8007cac:	08015a98 	.word	0x08015a98
 8007cb0:	0801311c 	.word	0x0801311c
 8007cb4:	20000aa8 	.word	0x20000aa8
 8007cb8:	08013110 	.word	0x08013110

08007cbc <cal_collect>:
  if (type >= ARRAY_COUNT(calibration_set))
 8007cbc:	2804      	cmp	r0, #4
 8007cbe:	d843      	bhi.n	8007d48 <cal_collect+0x8c>
{
 8007cc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (needInterpolate(frequency0, frequency1, sweep_points))
 8007cc4:	4c21      	ldr	r4, [pc, #132]	@ (8007d4c <cal_collect+0x90>)
 8007cc6:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8007cca:	68e5      	ldr	r5, [r4, #12]
  if (needInterpolate(frequency0, frequency1, sweep_points))
 8007ccc:	8b61      	ldrh	r1, [r4, #26]
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8007cce:	429d      	cmp	r5, r3
 8007cd0:	d032      	beq.n	8007d38 <cal_collect+0x7c>
    cal_frequency0 = frequency0;
 8007cd2:	e9c4 3203 	strd	r3, r2, [r4, #12]
    cal_sweep_points = sweep_points;
 8007cd6:	8461      	strh	r1, [r4, #34]	@ 0x22
 8007cd8:	2300      	movs	r3, #0
  cal_status &= calibration_set[type].clr_flag;
 8007cda:	491d      	ldr	r1, [pc, #116]	@ (8007d50 <cal_collect+0x94>)
  uint8_t bw = config._bandwidth; // store current setting
 8007cdc:	4d1d      	ldr	r5, [pc, #116]	@ (8007d54 <cal_collect+0x98>)
  cal_status &= calibration_set[type].clr_flag;
 8007cde:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8007ce2:	eb01 0240 	add.w	r2, r1, r0, lsl #1
  cal_status |= calibration_set[type].set_flag;
 8007ce6:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
  cal_power = current_props._power;
 8007cea:	7fe0      	ldrb	r0, [r4, #31]
 8007cec:	f884 0020 	strb.w	r0, [r4, #32]
  cal_status &= calibration_set[type].clr_flag;
 8007cf0:	8850      	ldrh	r0, [r2, #2]
  if (bw < BANDWIDTH_100)
 8007cf2:	7eae      	ldrb	r6, [r5, #26]
  src = calibration_set[type].src;
 8007cf4:	7957      	ldrb	r7, [r2, #5]
  dst = calibration_set[type].dst;
 8007cf6:	f892 8004 	ldrb.w	r8, [r2, #4]
  cal_status &= calibration_set[type].clr_flag;
 8007cfa:	4003      	ands	r3, r0
  cal_status |= calibration_set[type].set_flag;
 8007cfc:	430b      	orrs	r3, r1
  if (bw < BANDWIDTH_100)
 8007cfe:	2e26      	cmp	r6, #38	@ 0x26
  cal_status |= calibration_set[type].set_flag;
 8007d00:	84a3      	strh	r3, [r4, #36]	@ 0x24
    config._bandwidth = BANDWIDTH_100;
 8007d02:	bf9c      	itt	ls
 8007d04:	2327      	movls	r3, #39	@ 0x27
 8007d06:	836b      	strhls	r3, [r5, #26]
  uint16_t mask = (src == 0) ? SWEEP_CH0_MEASURE : SWEEP_CH1_MEASURE;
 8007d08:	2f00      	cmp	r7, #0
  sweep(false, mask);
 8007d0a:	bf14      	ite	ne
 8007d0c:	2102      	movne	r1, #2
 8007d0e:	2101      	moveq	r1, #1
 8007d10:	2000      	movs	r0, #0
 8007d12:	f7fe ff93 	bl	8006c3c <sweep>
  memcpy(cal_data[dst], measured[src], sizeof measured[0]);
 8007d16:	f640 4388 	movw	r3, #3208	@ 0xc88
 8007d1a:	490f      	ldr	r1, [pc, #60]	@ (8007d58 <cal_collect+0x9c>)
 8007d1c:	fb03 4008 	mla	r0, r3, r8, r4
 8007d20:	fb03 1107 	mla	r1, r3, r7, r1
 8007d24:	30d0      	adds	r0, #208	@ 0xd0
 8007d26:	461a      	mov	r2, r3
 8007d28:	f00a fd78 	bl	801281c <memcpy>
  config._bandwidth = bw; // restore
 8007d2c:	836e      	strh	r6, [r5, #26]
  request_to_redraw(REDRAW_CAL_STATUS);
 8007d2e:	2010      	movs	r0, #16
}
 8007d30:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  request_to_redraw(REDRAW_CAL_STATUS);
 8007d34:	f004 bd18 	b.w	800c768 <request_to_redraw>
  return start != cal_frequency0 || stop != cal_frequency1 || points != cal_sweep_points;
 8007d38:	6925      	ldr	r5, [r4, #16]
 8007d3a:	4295      	cmp	r5, r2
 8007d3c:	d1c9      	bne.n	8007cd2 <cal_collect+0x16>
 8007d3e:	8c65      	ldrh	r5, [r4, #34]	@ 0x22
 8007d40:	428d      	cmp	r5, r1
 8007d42:	d1c6      	bne.n	8007cd2 <cal_collect+0x16>
  cal_status &= calibration_set[type].clr_flag;
 8007d44:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
 8007d46:	e7c8      	b.n	8007cda <cal_collect+0x1e>
 8007d48:	4770      	bx	lr
 8007d4a:	bf00      	nop
 8007d4c:	20000aa8 	.word	0x20000aa8
 8007d50:	08015cac 	.word	0x08015cac
 8007d54:	20000318 	.word	0x20000318
 8007d58:	20004f54 	.word	0x20004f54

08007d5c <cal_done>:
{
 8007d5c:	b538      	push	{r3, r4, r5, lr}
  if (!(cal_status & CALSTAT_LOAD))
 8007d5e:	4d6c      	ldr	r5, [pc, #432]	@ (8007f10 <cal_done+0x1b4>)
 8007d60:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 8007d62:	f014 0001 	ands.w	r0, r4, #1
 8007d66:	f000 8083 	beq.w	8007e70 <cal_done+0x114>
  if (!(cal_status & CALSTAT_ISOLN))
 8007d6a:	06e1      	lsls	r1, r4, #27
 8007d6c:	d57a      	bpl.n	8007e64 <cal_done+0x108>
  if ((cal_status & CALSTAT_SHORT) && (cal_status & CALSTAT_OPEN))
 8007d6e:	0762      	lsls	r2, r4, #29
 8007d70:	f004 0302 	and.w	r3, r4, #2
 8007d74:	d520      	bpl.n	8007db8 <cal_done+0x5c>
 8007d76:	2b00      	cmp	r3, #0
 8007d78:	d17f      	bne.n	8007e7a <cal_done+0x11e>
    eterm_set(ETERM_ES, 0.0, 0.0);
 8007d7a:	2001      	movs	r0, #1
 8007d7c:	ed9f 0a65 	vldr	s0, [pc, #404]	@ 8007f14 <cal_done+0x1b8>
 8007d80:	f7fd fdd4 	bl	800592c <eterm_set.constprop.0>
    eterm_calc_er(-1);
 8007d84:	f04f 30ff 	mov.w	r0, #4294967295
 8007d88:	f7fd fbd2 	bl	8005530 <eterm_calc_er>
  if (cal_status & CALSTAT_THRU)
 8007d8c:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 8007d8e:	0720      	lsls	r0, r4, #28
 8007d90:	d428      	bmi.n	8007de4 <cal_done+0x88>
  if (!(cal_status & CALSTAT_ET))
 8007d92:	0621      	lsls	r1, r4, #24
 8007d94:	d560      	bpl.n	8007e58 <cal_done+0xfc>
  if (!(cal_status & CALSTAT_ER))
 8007d96:	0662      	lsls	r2, r4, #25
 8007d98:	d551      	bpl.n	8007e3e <cal_done+0xe2>
  if (!(cal_status & CALSTAT_ES))
 8007d9a:	06a3      	lsls	r3, r4, #26
 8007d9c:	d556      	bpl.n	8007e4c <cal_done+0xf0>
  lastsaveid = NO_SAVE_SLOT;
 8007d9e:	4b5e      	ldr	r3, [pc, #376]	@ (8007f18 <cal_done+0x1bc>)
  cal_status |= CALSTAT_APPLY;
 8007da0:	f444 7480 	orr.w	r4, r4, #256	@ 0x100
  lastsaveid = NO_SAVE_SLOT;
 8007da4:	f64f 72ff 	movw	r2, #65535	@ 0xffff
  cal_status |= CALSTAT_APPLY;
 8007da8:	84ac      	strh	r4, [r5, #36]	@ 0x24
  lastsaveid = NO_SAVE_SLOT;
 8007daa:	801a      	strh	r2, [r3, #0]
  request_to_redraw(REDRAW_BACKUP | REDRAW_CAL_STATUS);
 8007dac:	f44f 6082 	mov.w	r0, #1040	@ 0x410
}
 8007db0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  request_to_redraw(REDRAW_BACKUP | REDRAW_CAL_STATUS);
 8007db4:	f004 bcd8 	b.w	800c768 <request_to_redraw>
  else if (cal_status & CALSTAT_OPEN)
 8007db8:	2b00      	cmp	r3, #0
 8007dba:	d0e8      	beq.n	8007d8e <cal_done+0x32>
  memcpy(cal_data[dst], cal_data[src], sizeof cal_data[dst]);
 8007dbc:	4957      	ldr	r1, [pc, #348]	@ (8007f1c <cal_done+0x1c0>)
 8007dbe:	f640 4288 	movw	r2, #3208	@ 0xc88
 8007dc2:	1888      	adds	r0, r1, r2
 8007dc4:	f00a fd2a 	bl	801281c <memcpy>
    cal_status &= ~CALSTAT_OPEN;
 8007dc8:	f024 0402 	bic.w	r4, r4, #2
    eterm_set(ETERM_ES, 0.0, 0.0);
 8007dcc:	2001      	movs	r0, #1
 8007dce:	ed9f 0a51 	vldr	s0, [pc, #324]	@ 8007f14 <cal_done+0x1b8>
    cal_status &= ~CALSTAT_OPEN;
 8007dd2:	84ac      	strh	r4, [r5, #36]	@ 0x24
    eterm_set(ETERM_ES, 0.0, 0.0);
 8007dd4:	f7fd fdaa 	bl	800592c <eterm_set.constprop.0>
    eterm_calc_er(1);
 8007dd8:	2001      	movs	r0, #1
 8007dda:	f7fd fba9 	bl	8005530 <eterm_calc_er>
  if (cal_status & CALSTAT_THRU)
 8007dde:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 8007de0:	0720      	lsls	r0, r4, #28
 8007de2:	d5d6      	bpl.n	8007d92 <cal_done+0x36>
  for (i = 0; i < sweep_points; i++)
 8007de4:	8b69      	ldrh	r1, [r5, #26]
 8007de6:	b319      	cbz	r1, 8007e30 <cal_done+0xd4>
 8007de8:	4b4d      	ldr	r3, [pc, #308]	@ (8007f20 <cal_done+0x1c4>)
 8007dea:	f603 4288 	addw	r2, r3, #3208	@ 0xc88
 8007dee:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8007df2:	ed93 6a01 	vldr	s12, [r3, #4]
 8007df6:	edd2 6a01 	vldr	s13, [r2, #4]
    float etr = cal_data[CAL_THRU][i][0] - cal_data[CAL_ISOLN][i][0];
 8007dfa:	ed93 7a00 	vldr	s14, [r3]
 8007dfe:	edd2 5a00 	vldr	s11, [r2]
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8007e02:	ee76 7a66 	vsub.f32	s15, s12, s13
    float etr = cal_data[CAL_THRU][i][0] - cal_data[CAL_ISOLN][i][0];
 8007e06:	ee37 7a65 	vsub.f32	s14, s14, s11
    float sq = etr * etr + eti * eti;
 8007e0a:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float invi = -eti / sq;
 8007e0e:	ee76 6ac6 	vsub.f32	s13, s13, s12
    float sq = etr * etr + eti * eti;
 8007e12:	eee7 7a07 	vfma.f32	s15, s14, s14
  for (i = 0; i < sweep_points; i++)
 8007e16:	3308      	adds	r3, #8
 8007e18:	4299      	cmp	r1, r3
 8007e1a:	f102 0208 	add.w	r2, r2, #8
    float invr = etr / sq;
 8007e1e:	ee87 6a27 	vdiv.f32	s12, s14, s15
    float invi = -eti / sq;
 8007e22:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    cal_data[ETERM_ET][i][0] = invr;
 8007e26:	ed03 6a02 	vstr	s12, [r3, #-8]
    cal_data[ETERM_ET][i][1] = invi;
 8007e2a:	ed03 7a01 	vstr	s14, [r3, #-4]
  for (i = 0; i < sweep_points; i++)
 8007e2e:	d1e0      	bne.n	8007df2 <cal_done+0x96>
  cal_status &= ~CALSTAT_THRU;
 8007e30:	f024 0408 	bic.w	r4, r4, #8
  cal_status |= CALSTAT_ET;
 8007e34:	f044 0480 	orr.w	r4, r4, #128	@ 0x80
  if (!(cal_status & CALSTAT_ER))
 8007e38:	0662      	lsls	r2, r4, #25
  cal_status |= CALSTAT_ET;
 8007e3a:	84ac      	strh	r4, [r5, #36]	@ 0x24
  if (!(cal_status & CALSTAT_ER))
 8007e3c:	d4ad      	bmi.n	8007d9a <cal_done+0x3e>
    eterm_set(ETERM_ER, 1.0, 0.0);
 8007e3e:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 8007e42:	2002      	movs	r0, #2
 8007e44:	f7fd fd72 	bl	800592c <eterm_set.constprop.0>
  if (!(cal_status & CALSTAT_ES))
 8007e48:	06a3      	lsls	r3, r4, #26
 8007e4a:	d4a8      	bmi.n	8007d9e <cal_done+0x42>
    eterm_set(ETERM_ES, 0.0, 0.0);
 8007e4c:	ed9f 0a31 	vldr	s0, [pc, #196]	@ 8007f14 <cal_done+0x1b8>
 8007e50:	2001      	movs	r0, #1
 8007e52:	f7fd fd6b 	bl	800592c <eterm_set.constprop.0>
 8007e56:	e7a2      	b.n	8007d9e <cal_done+0x42>
    eterm_set(ETERM_ET, 1.0, 0.0);
 8007e58:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 8007e5c:	2003      	movs	r0, #3
 8007e5e:	f7fd fd65 	bl	800592c <eterm_set.constprop.0>
 8007e62:	e798      	b.n	8007d96 <cal_done+0x3a>
    eterm_set(ETERM_EX, 0.0, 0.0);
 8007e64:	ed9f 0a2b 	vldr	s0, [pc, #172]	@ 8007f14 <cal_done+0x1b8>
 8007e68:	2004      	movs	r0, #4
 8007e6a:	f7fd fd5f 	bl	800592c <eterm_set.constprop.0>
 8007e6e:	e77e      	b.n	8007d6e <cal_done+0x12>
    eterm_set(ETERM_ED, 0.0, 0.0);
 8007e70:	ed9f 0a28 	vldr	s0, [pc, #160]	@ 8007f14 <cal_done+0x1b8>
 8007e74:	f7fd fd5a 	bl	800592c <eterm_set.constprop.0>
 8007e78:	e777      	b.n	8007d6a <cal_done+0xe>
  for (i = 0; i < sweep_points; i++)
 8007e7a:	8b68      	ldrh	r0, [r5, #26]
 8007e7c:	b3e0      	cbz	r0, 8007ef8 <cal_done+0x19c>
 8007e7e:	4a24      	ldr	r2, [pc, #144]	@ (8007f10 <cal_done+0x1b4>)
 8007e80:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 8007e84:	f602 5358 	addw	r3, r2, #3416	@ 0xd58
 8007e88:	f502 51cf 	add.w	r1, r2, #6624	@ 0x19e0
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8007e8c:	edd1 5a00 	vldr	s11, [r1]
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8007e90:	ed91 4a01 	vldr	s8, [r1, #4]
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 8007e94:	ed93 7a00 	vldr	s14, [r3]
    float s11oi = cal_data[CAL_OPEN][i][1] - cal_data[ETERM_ED][i][1];
 8007e98:	edd3 7a01 	vldr	s15, [r3, #4]
 8007e9c:	ed92 5a35 	vldr	s10, [r2, #212]	@ 0xd4
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 8007ea0:	edd2 4a34 	vldr	s9, [r2, #208]	@ 0xd0
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 8007ea4:	ee37 6a25 	vadd.f32	s12, s14, s11
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 8007ea8:	ee77 6a84 	vadd.f32	s13, s15, s8
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 8007eac:	ee36 6a64 	vsub.f32	s12, s12, s9
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 8007eb0:	ee76 6ac5 	vsub.f32	s13, s13, s10
    float denomi = s11oi - s11si;
 8007eb4:	ee77 7ac4 	vsub.f32	s15, s15, s8
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 8007eb8:	ee76 6ac5 	vsub.f32	s13, s13, s10
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 8007ebc:	ee36 6a64 	vsub.f32	s12, s12, s9
    float denomr = s11or - s11sr;
 8007ec0:	ee37 7a65 	vsub.f32	s14, s14, s11
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 8007ec4:	ee26 5aa7 	vmul.f32	s10, s13, s15
    float d = denomr * denomr + denomi * denomi;
 8007ec8:	ee67 5aa7 	vmul.f32	s11, s15, s15
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 8007ecc:	ee67 7ac6 	vnmul.f32	s15, s15, s12
    float d = denomr * denomr + denomi * denomi;
 8007ed0:	eee7 5a07 	vfma.f32	s11, s14, s14
  for (i = 0; i < sweep_points; i++)
 8007ed4:	3208      	adds	r2, #8
 8007ed6:	3308      	adds	r3, #8
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 8007ed8:	eea6 5a07 	vfma.f32	s10, s12, s14
  for (i = 0; i < sweep_points; i++)
 8007edc:	4290      	cmp	r0, r2
 8007ede:	f101 0108 	add.w	r1, r1, #8
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 8007ee2:	eee6 7a87 	vfma.f32	s15, s13, s14
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 8007ee6:	eec5 6a25 	vdiv.f32	s13, s10, s11
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 8007eea:	ee87 7aa5 	vdiv.f32	s14, s15, s11
    cal_data[ETERM_ES][i][0] = (numr * denomr + numi * denomi) / d;
 8007eee:	ed43 6a02 	vstr	s13, [r3, #-8]
    cal_data[ETERM_ES][i][1] = (numi * denomr - numr * denomi) / d;
 8007ef2:	ed03 7a01 	vstr	s14, [r3, #-4]
  for (i = 0; i < sweep_points; i++)
 8007ef6:	d1c9      	bne.n	8007e8c <cal_done+0x130>
  cal_status &= ~CALSTAT_OPEN;
 8007ef8:	f024 0402 	bic.w	r4, r4, #2
  cal_status |= CALSTAT_ES;
 8007efc:	f044 0420 	orr.w	r4, r4, #32
    eterm_calc_er(-1);
 8007f00:	f04f 30ff 	mov.w	r0, #4294967295
  cal_status |= CALSTAT_ES;
 8007f04:	84ac      	strh	r4, [r5, #36]	@ 0x24
    eterm_calc_er(-1);
 8007f06:	f7fd fb13 	bl	8005530 <eterm_calc_er>
  if (cal_status & CALSTAT_THRU)
 8007f0a:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
    eterm_calc_er(-1);
 8007f0c:	e73f      	b.n	8007d8e <cal_done+0x32>
 8007f0e:	bf00      	nop
 8007f10:	20000aa8 	.word	0x20000aa8
 8007f14:	00000000 	.word	0x00000000
 8007f18:	20009a3e 	.word	0x20009a3e
 8007f1c:	20001800 	.word	0x20001800
 8007f20:	20003110 	.word	0x20003110

08007f24 <cmd_cal>:
{
 8007f24:	b570      	push	{r4, r5, r6, lr}
  if (argc == 0)
 8007f26:	b9b8      	cbnz	r0, 8007f58 <cmd_cal+0x34>
 8007f28:	4d2d      	ldr	r5, [pc, #180]	@ (8007fe0 <cmd_cal+0xbc>)
        shell_printf("%s ", items[i]);
 8007f2a:	4e2e      	ldr	r6, [pc, #184]	@ (8007fe4 <cmd_cal+0xc0>)
 8007f2c:	4604      	mov	r4, r0
 8007f2e:	e002      	b.n	8007f36 <cmd_cal+0x12>
    for (i = 0; i < 9; i++)
 8007f30:	3401      	adds	r4, #1
 8007f32:	2c09      	cmp	r4, #9
 8007f34:	d00b      	beq.n	8007f4e <cmd_cal+0x2a>
      if (cal_status & (1 << i))
 8007f36:	8cab      	ldrh	r3, [r5, #36]	@ 0x24
 8007f38:	4123      	asrs	r3, r4
 8007f3a:	07db      	lsls	r3, r3, #31
 8007f3c:	d5f8      	bpl.n	8007f30 <cmd_cal+0xc>
        shell_printf("%s ", items[i]);
 8007f3e:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
 8007f42:	4829      	ldr	r0, [pc, #164]	@ (8007fe8 <cmd_cal+0xc4>)
    for (i = 0; i < 9; i++)
 8007f44:	3401      	adds	r4, #1
        shell_printf("%s ", items[i]);
 8007f46:	f7fe f86b 	bl	8006020 <shell_printf>
    for (i = 0; i < 9; i++)
 8007f4a:	2c09      	cmp	r4, #9
 8007f4c:	d1f3      	bne.n	8007f36 <cmd_cal+0x12>
}
 8007f4e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    shell_printf(VNA_SHELL_NEWLINE_STR);
 8007f52:	4826      	ldr	r0, [pc, #152]	@ (8007fec <cmd_cal+0xc8>)
 8007f54:	f7fe b864 	b.w	8006020 <shell_printf>
  request_to_redraw(REDRAW_CAL_STATUS);
 8007f58:	460d      	mov	r5, r1
 8007f5a:	2010      	movs	r0, #16
 8007f5c:	f004 fc04 	bl	800c768 <request_to_redraw>
  switch (get_str_index(argv[0], cmd_cal_list))
 8007f60:	4923      	ldr	r1, [pc, #140]	@ (8007ff0 <cmd_cal+0xcc>)
 8007f62:	6828      	ldr	r0, [r5, #0]
 8007f64:	f001 fda2 	bl	8009aac <get_str_index>
 8007f68:	2808      	cmp	r0, #8
 8007f6a:	d833      	bhi.n	8007fd4 <cmd_cal+0xb0>
 8007f6c:	e8df f000 	tbb	[pc, r0]
 8007f70:	28232d09 	.word	0x28232d09
 8007f74:	1d17130e 	.word	0x1d17130e
 8007f78:	05          	.byte	0x05
 8007f79:	00          	.byte	0x00
    cal_status = 0;
 8007f7a:	4b19      	ldr	r3, [pc, #100]	@ (8007fe0 <cmd_cal+0xbc>)
 8007f7c:	2200      	movs	r2, #0
 8007f7e:	849a      	strh	r2, [r3, #36]	@ 0x24
}
 8007f80:	bd70      	pop	{r4, r5, r6, pc}
 8007f82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cal_collect(CAL_LOAD);
 8007f86:	2000      	movs	r0, #0
 8007f88:	f7ff be98 	b.w	8007cbc <cal_collect>
}
 8007f8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cal_collect(CAL_ISOLN);
 8007f90:	2004      	movs	r0, #4
 8007f92:	f7ff be93 	b.w	8007cbc <cal_collect>
}
 8007f96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cal_done();
 8007f9a:	f7ff bedf 	b.w	8007d5c <cal_done>
    cal_status |= CALSTAT_APPLY;
 8007f9e:	4a10      	ldr	r2, [pc, #64]	@ (8007fe0 <cmd_cal+0xbc>)
 8007fa0:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 8007fa2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8007fa6:	8493      	strh	r3, [r2, #36]	@ 0x24
}
 8007fa8:	bd70      	pop	{r4, r5, r6, pc}
    cal_status &= ~CALSTAT_APPLY;
 8007faa:	4a0d      	ldr	r2, [pc, #52]	@ (8007fe0 <cmd_cal+0xbc>)
 8007fac:	8c93      	ldrh	r3, [r2, #36]	@ 0x24
 8007fae:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8007fb2:	8493      	strh	r3, [r2, #36]	@ 0x24
}
 8007fb4:	bd70      	pop	{r4, r5, r6, pc}
 8007fb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cal_collect(CAL_SHORT);
 8007fba:	2002      	movs	r0, #2
 8007fbc:	f7ff be7e 	b.w	8007cbc <cal_collect>
}
 8007fc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cal_collect(CAL_THRU);
 8007fc4:	2003      	movs	r0, #3
 8007fc6:	f7ff be79 	b.w	8007cbc <cal_collect>
}
 8007fca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    cal_collect(CAL_OPEN);
 8007fce:	2001      	movs	r0, #1
 8007fd0:	f7ff be74 	b.w	8007cbc <cal_collect>
}
 8007fd4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  shell_printf("usage: cal [%s]" VNA_SHELL_NEWLINE_STR, cmd_cal_list);
 8007fd8:	4905      	ldr	r1, [pc, #20]	@ (8007ff0 <cmd_cal+0xcc>)
 8007fda:	4806      	ldr	r0, [pc, #24]	@ (8007ff4 <cmd_cal+0xd0>)
 8007fdc:	f7fe b820 	b.w	8006020 <shell_printf>
 8007fe0:	20000aa8 	.word	0x20000aa8
 8007fe4:	08015b08 	.word	0x08015b08
 8007fe8:	08013164 	.word	0x08013164
 8007fec:	08013860 	.word	0x08013860
 8007ff0:	08015ad8 	.word	0x08015ad8
 8007ff4:	08013168 	.word	0x08013168

08007ff8 <get_trace_chname>:
  return trc_channel_name[trace[t].channel & 1];
 8007ff8:	4b06      	ldr	r3, [pc, #24]	@ (8008014 <get_trace_chname+0x1c>)
 8007ffa:	4a07      	ldr	r2, [pc, #28]	@ (8008018 <get_trace_chname+0x20>)
 8007ffc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8008000:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8008004:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 8008008:	f003 0301 	and.w	r3, r3, #1
}
 800800c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8008010:	4770      	bx	lr
 8008012:	bf00      	nop
 8008014:	20000aa8 	.word	0x20000aa8
 8008018:	08015ed4 	.word	0x08015ed4

0800801c <set_trace_channel>:
  if (trace[t].channel != channel)
 800801c:	4b08      	ldr	r3, [pc, #32]	@ (8008040 <set_trace_channel+0x24>)
 800801e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8008022:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  channel &= 1;
 8008026:	f001 0101 	and.w	r1, r1, #1
  if (trace[t].channel != channel)
 800802a:	f893 202a 	ldrb.w	r2, [r3, #42]	@ 0x2a
 800802e:	428a      	cmp	r2, r1
 8008030:	d100      	bne.n	8008034 <set_trace_channel+0x18>
}
 8008032:	4770      	bx	lr
    request_to_redraw(REDRAW_MARKER | REDRAW_PLOT);
 8008034:	2021      	movs	r0, #33	@ 0x21
    trace[t].channel = channel;
 8008036:	f883 102a 	strb.w	r1, [r3, #42]	@ 0x2a
    request_to_redraw(REDRAW_MARKER | REDRAW_PLOT);
 800803a:	f004 bb95 	b.w	800c768 <request_to_redraw>
 800803e:	bf00      	nop
 8008040:	20000aa8 	.word	0x20000aa8

08008044 <set_active_trace>:
  if (current_trace == t)
 8008044:	4a05      	ldr	r2, [pc, #20]	@ (800805c <set_active_trace+0x18>)
 8008046:	f992 101c 	ldrsb.w	r1, [r2, #28]
 800804a:	4281      	cmp	r1, r0
{
 800804c:	4603      	mov	r3, r0
  if (current_trace == t)
 800804e:	d003      	beq.n	8008058 <set_active_trace+0x14>
  request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE);
 8008050:	20a0      	movs	r0, #160	@ 0xa0
  current_trace = t;
 8008052:	7713      	strb	r3, [r2, #28]
  request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE);
 8008054:	f004 bb88 	b.w	800c768 <request_to_redraw>
}
 8008058:	4770      	bx	lr
 800805a:	bf00      	nop
 800805c:	20000aa8 	.word	0x20000aa8

08008060 <set_trace_scale>:
  if (trace[t].scale != scale)
 8008060:	4b08      	ldr	r3, [pc, #32]	@ (8008084 <set_trace_scale+0x24>)
 8008062:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8008066:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800806a:	edd3 7a0b 	vldr	s15, [r3, #44]	@ 0x2c
 800806e:	eef4 7a40 	vcmp.f32	s15, s0
 8008072:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008076:	d100      	bne.n	800807a <set_trace_scale+0x1a>
}
 8008078:	4770      	bx	lr
    request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_PLOT);
 800807a:	20a1      	movs	r0, #161	@ 0xa1
    trace[t].scale = scale;
 800807c:	ed83 0a0b 	vstr	s0, [r3, #44]	@ 0x2c
    request_to_redraw(REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_PLOT);
 8008080:	f004 bb72 	b.w	800c768 <request_to_redraw>
 8008084:	20000aa8 	.word	0x20000aa8

08008088 <set_trace_refpos>:
  if (trace[t].refpos != refpos)
 8008088:	4b08      	ldr	r3, [pc, #32]	@ (80080ac <set_trace_refpos+0x24>)
 800808a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800808e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8008092:	edd3 7a0c 	vldr	s15, [r3, #48]	@ 0x30
 8008096:	eef4 7a40 	vcmp.f32	s15, s0
 800809a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800809e:	d100      	bne.n	80080a2 <set_trace_refpos+0x1a>
}
 80080a0:	4770      	bx	lr
    request_to_redraw(REDRAW_REFERENCE | REDRAW_GRID_VALUE | REDRAW_PLOT);
 80080a2:	20c1      	movs	r0, #193	@ 0xc1
    trace[t].refpos = refpos;
 80080a4:	ed83 0a0c 	vstr	s0, [r3, #48]	@ 0x30
    request_to_redraw(REDRAW_REFERENCE | REDRAW_GRID_VALUE | REDRAW_PLOT);
 80080a8:	f004 bb5e 	b.w	800c768 <request_to_redraw>
 80080ac:	20000aa8 	.word	0x20000aa8

080080b0 <set_trace_type>:
{
 80080b0:	b570      	push	{r4, r5, r6, lr}
  bool update = trace[t].type != type || trace[t].channel != channel;
 80080b2:	4d15      	ldr	r5, [pc, #84]	@ (8008108 <set_trace_type+0x58>)
  channel &= 1;
 80080b4:	f002 0601 	and.w	r6, r2, #1
  bool update = trace[t].type != type || trace[t].channel != channel;
 80080b8:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80080bc:	eb05 0c82 	add.w	ip, r5, r2, lsl #2
{
 80080c0:	4604      	mov	r4, r0
  bool update = trace[t].type != type || trace[t].channel != channel;
 80080c2:	f89c 2029 	ldrb.w	r2, [ip, #41]	@ 0x29
 80080c6:	428a      	cmp	r2, r1
 80080c8:	d019      	beq.n	80080fe <set_trace_type+0x4e>
    set_trace_refpos(t, trace_info_list[type].refpos);
 80080ca:	4d10      	ldr	r5, [pc, #64]	@ (800810c <set_trace_type+0x5c>)
    trace[t].type = type;
 80080cc:	f88c 1029 	strb.w	r1, [ip, #41]	@ 0x29
    set_trace_refpos(t, trace_info_list[type].refpos);
 80080d0:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 80080d4:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 80080d8:	ed95 0a04 	vldr	s0, [r5, #16]
 80080dc:	f7ff ffd4 	bl	8008088 <set_trace_refpos>
    set_trace_scale(t, trace_info_list[type].scale_unit);
 80080e0:	4620      	mov	r0, r4
 80080e2:	ed95 0a05 	vldr	s0, [r5, #20]
 80080e6:	f7ff ffbb 	bl	8008060 <set_trace_scale>
    request_to_redraw(REDRAW_AREA | REDRAW_PLOT | REDRAW_BACKUP); // need for update grid
 80080ea:	f240 4003 	movw	r0, #1027	@ 0x403
 80080ee:	f004 fb3b 	bl	800c768 <request_to_redraw>
  set_trace_channel(t, channel);
 80080f2:	4631      	mov	r1, r6
 80080f4:	4620      	mov	r0, r4
}
 80080f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  set_trace_channel(t, channel);
 80080fa:	f7ff bf8f 	b.w	800801c <set_trace_channel>
  bool update = trace[t].type != type || trace[t].channel != channel;
 80080fe:	f89c 302a 	ldrb.w	r3, [ip, #42]	@ 0x2a
 8008102:	429e      	cmp	r6, r3
 8008104:	d1f5      	bne.n	80080f2 <set_trace_type+0x42>
}
 8008106:	bd70      	pop	{r4, r5, r6, pc}
 8008108:	20000aa8 	.word	0x20000aa8
 800810c:	0801650c 	.word	0x0801650c

08008110 <Thread1>:
{
 8008110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008114:	ed2d 8b0a 	vpush	{d8-d12}
 8008118:	b095      	sub	sp, #84	@ 0x54
  ui_init();
 800811a:	f008 fc23 	bl	8010964 <ui_init>
  lcd_show_logo();
 800811e:	f009 fad3 	bl	80116c8 <lcd_show_logo>
  redraw_request |= REDRAW_ALL;
 8008122:	4aa0      	ldr	r2, [pc, #640]	@ (80083a4 <Thread1+0x294>)
    markers[m].enabled = FALSE;
 8008124:	f8df 92ec 	ldr.w	r9, [pc, #748]	@ 8008414 <Thread1+0x304>
  redraw_request |= REDRAW_ALL;
 8008128:	7813      	ldrb	r3, [r2, #0]
            float refpos = y_max - (max_p / scale);
 800812a:	eddf 9a9f 	vldr	s19, [pc, #636]	@ 80083a8 <Thread1+0x298>
            if (vna_fabsf(refpos - trace[t].refpos) > 0.02f)
 800812e:	ed9f 9a9f 	vldr	s18, [pc, #636]	@ 80083ac <Thread1+0x29c>
                vna_fabsf(scale - trace[t].scale) > trace[t].scale * 0.03f)
 8008132:	ed9f aa9f 	vldr	s20, [pc, #636]	@ 80083b0 <Thread1+0x2a0>
            float min_p = 0.0f, max_p = 0.0f;
 8008136:	eddf aa9f 	vldr	s21, [pc, #636]	@ 80083b4 <Thread1+0x2a4>
    if (swr > 0.0f && swr < 9999.0f && swr > max_swr)
 800813a:	eddf 8a9f 	vldr	s17, [pc, #636]	@ 80083b8 <Thread1+0x2a8>
 800813e:	f8df a2d8 	ldr.w	sl, [pc, #728]	@ 8008418 <Thread1+0x308>
 8008142:	f8df b2d8 	ldr.w	fp, [pc, #728]	@ 800841c <Thread1+0x30c>
  redraw_request |= REDRAW_ALL;
 8008146:	f043 031a 	orr.w	r3, r3, #26
    markers[m].enabled = FALSE;
 800814a:	2400      	movs	r4, #0
  redraw_request |= REDRAW_ALL;
 800814c:	7013      	strb	r3, [r2, #0]
  plot_init();
 800814e:	f005 fff7 	bl	800e140 <plot_init>
  active_marker = MARKER_INVALID;
 8008152:	23ff      	movs	r3, #255	@ 0xff
  request_to_redraw(REDRAW_MARKER | REDRAW_AREA);
 8008154:	2022      	movs	r0, #34	@ 0x22
    markers[m].enabled = FALSE;
 8008156:	f889 4058 	strb.w	r4, [r9, #88]	@ 0x58
 800815a:	f889 4060 	strb.w	r4, [r9, #96]	@ 0x60
 800815e:	f889 4068 	strb.w	r4, [r9, #104]	@ 0x68
 8008162:	f889 4070 	strb.w	r4, [r9, #112]	@ 0x70
 8008166:	f889 4078 	strb.w	r4, [r9, #120]	@ 0x78
 800816a:	f889 4080 	strb.w	r4, [r9, #128]	@ 0x80
 800816e:	f889 4088 	strb.w	r4, [r9, #136]	@ 0x88
 8008172:	f889 4090 	strb.w	r4, [r9, #144]	@ 0x90
  active_marker = MARKER_INVALID;
 8008176:	f889 301d 	strb.w	r3, [r9, #29]
  request_to_redraw(REDRAW_MARKER | REDRAW_AREA);
 800817a:	f004 faf5 	bl	800c768 <request_to_redraw>
  HB9II_mode = 1;
 800817e:	4a8f      	ldr	r2, [pc, #572]	@ (80083bc <Thread1+0x2ac>)
 8008180:	2301      	movs	r3, #1
 8008182:	6013      	str	r3, [r2, #0]
  targetting_mode = false; // to ignore screen touch on mode 2 , double usage, could be replaced by HB9II_mode
 8008184:	4a8e      	ldr	r2, [pc, #568]	@ (80083c0 <Thread1+0x2b0>)
 8008186:	7014      	strb	r4, [r2, #0]
  doOnceOnly_In_Mode2 = true;
 8008188:	4a8e      	ldr	r2, [pc, #568]	@ (80083c4 <Thread1+0x2b4>)
 800818a:	4c8f      	ldr	r4, [pc, #572]	@ (80083c8 <Thread1+0x2b8>)
 800818c:	7013      	strb	r3, [r2, #0]
 800818e:	e080      	b.n	8008292 <Thread1+0x182>
      if (doOnceOnly_In_Mode2 == true)
 8008190:	4b8c      	ldr	r3, [pc, #560]	@ (80083c4 <Thread1+0x2b4>)
 8008192:	781b      	ldrb	r3, [r3, #0]
 8008194:	2b00      	cmp	r3, #0
 8008196:	f040 80d7 	bne.w	8008348 <Thread1+0x238>
      uint16_t mask = get_sweep_mask();
 800819a:	f7fd fb99 	bl	80058d0 <get_sweep_mask>
 800819e:	4601      	mov	r1, r0
      completed = sweep(true, mask);
 80081a0:	2001      	movs	r0, #1
 80081a2:	f7fe fd4b 	bl	8006c3c <sweep>
      displayTargetFrequency(target_frequency);
 80081a6:	4b89      	ldr	r3, [pc, #548]	@ (80083cc <Thread1+0x2bc>)
      completed = sweep(true, mask);
 80081a8:	4605      	mov	r5, r0
      displayTargetFrequency(target_frequency);
 80081aa:	6818      	ldr	r0, [r3, #0]
 80081ac:	f7fd fe20 	bl	8005df0 <displayTargetFrequency>
      if (completed)
 80081b0:	b32d      	cbz	r5, 80081fe <Thread1+0xee>
        float im = measured[0][0][1];
 80081b2:	4b87      	ldr	r3, [pc, #540]	@ (80083d0 <Thread1+0x2c0>)
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 80081b4:	eddf 6a87 	vldr	s13, [pc, #540]	@ 80083d4 <Thread1+0x2c4>
        float im = measured[0][0][1];
 80081b8:	edd3 7a01 	vldr	s15, [r3, #4]
        float re = measured[0][0][0];
 80081bc:	ed93 7a00 	vldr	s14, [r3]
        float mag = sqrtf(re * re + im * im);
 80081c0:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80081c4:	eee7 7a07 	vfma.f32	s15, s14, s14
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 80081c8:	eef4 7ae6 	vcmpe.f32	s15, s13
 80081cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80081d0:	f140 8225 	bpl.w	800861e <Thread1+0x50e>
        float mag = sqrtf(re * re + im * im);
 80081d4:	eeb1 7ae7 	vsqrt.f32	s14, s15
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 80081d8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80081dc:	ee77 6a27 	vadd.f32	s13, s14, s15
 80081e0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80081e4:	ee86 8aa7 	vdiv.f32	s16, s13, s15
        drawBarGraph(swr);
 80081e8:	eeb0 0a48 	vmov.f32	s0, s16
 80081ec:	f7fd fc56 	bl	8005a9c <drawBarGraph>
        displaySWR(swr);
 80081f0:	eeb0 0a48 	vmov.f32	s0, s16
 80081f4:	f7fd fd00 	bl	8005bf8 <displaySWR>
        doOnceOnly_In_Mode2 = false;
 80081f8:	4a72      	ldr	r2, [pc, #456]	@ (80083c4 <Thread1+0x2b4>)
 80081fa:	2300      	movs	r3, #0
 80081fc:	7013      	strb	r3, [r2, #0]
      int evt = touch_checkHB9IIU();
 80081fe:	f007 fb3f 	bl	800f880 <touch_checkHB9IIU>
      if (evt == 2) // PRESSED
 8008202:	2802      	cmp	r0, #2
 8008204:	d13f      	bne.n	8008286 <Thread1+0x176>
        int px = g_touch_px;
 8008206:	4b74      	ldr	r3, [pc, #464]	@ (80083d8 <Thread1+0x2c8>)
 8008208:	6819      	ldr	r1, [r3, #0]
        int py = g_touch_py;
 800820a:	4b74      	ldr	r3, [pc, #464]	@ (80083dc <Thread1+0x2cc>)
        if (px >= SWR_TOUCH_X0 && px < (SWR_TOUCH_X0 + SWR_TOUCH_W) &&
 800820c:	f5b1 7ff0 	cmp.w	r1, #480	@ 0x1e0
        int py = g_touch_py;
 8008210:	681a      	ldr	r2, [r3, #0]
        if (px >= SWR_TOUCH_X0 && px < (SWR_TOUCH_X0 + SWR_TOUCH_W) &&
 8008212:	d275      	bcs.n	8008300 <Thread1+0x1f0>
 8008214:	2a81      	cmp	r2, #129	@ 0x81
 8008216:	dd73      	ble.n	8008300 <Thread1+0x1f0>
            py >= SWR_TOUCH_Y0 && py < (SWR_TOUCH_Y0 + SWR_TOUCH_H))
 8008218:	2ab3      	cmp	r2, #179	@ 0xb3
 800821a:	dc34      	bgt.n	8008286 <Thread1+0x176>
          MLA_UART_LOG("SWR AREA PRESSED  x=%d y=%d\r\n", px, py);
 800821c:	4870      	ldr	r0, [pc, #448]	@ (80083e0 <Thread1+0x2d0>)
          redraw_request = REDRAW_ALL; // <-- critical: don't OR with old redraw bits
 800821e:	4f61      	ldr	r7, [pc, #388]	@ (80083a4 <Thread1+0x294>)
          MLA_UART_LOG("SWR AREA PRESSED  x=%d y=%d\r\n", px, py);
 8008220:	f7fd fb9c 	bl	800595c <serial_shell_printf>
          targetting_mode = false;
 8008224:	4b66      	ldr	r3, [pc, #408]	@ (80083c0 <Thread1+0x2b0>)
 8008226:	2500      	movs	r5, #0
 8008228:	701d      	strb	r5, [r3, #0]
          drawTheSWRLines = false;
 800822a:	4b6e      	ldr	r3, [pc, #440]	@ (80083e4 <Thread1+0x2d4>)
          sweep_mode = 0; // <-- critical: purge stale sweep flags
 800822c:	f88a 5000 	strb.w	r5, [sl]
          drawTheSWRLines = false;
 8008230:	701d      	strb	r5, [r3, #0]
          mla_resonance_locked = false;
 8008232:	4b6d      	ldr	r3, [pc, #436]	@ (80083e8 <Thread1+0x2d8>)
 8008234:	701d      	strb	r5, [r3, #0]
          mla_res_ref_freq = 0;
 8008236:	4b6d      	ldr	r3, [pc, #436]	@ (80083ec <Thread1+0x2dc>)
 8008238:	601d      	str	r5, [r3, #0]
          mla_res_stable_count = 0;
 800823a:	4b6d      	ldr	r3, [pc, #436]	@ (80083f0 <Thread1+0x2e0>)
 800823c:	701d      	strb	r5, [r3, #0]
          mla_no_dip_count = 0;
 800823e:	4b6d      	ldr	r3, [pc, #436]	@ (80083f4 <Thread1+0x2e4>)
 8008240:	701d      	strb	r5, [r3, #0]
          mla_autozone_stage = 0;
 8008242:	4b6d      	ldr	r3, [pc, #436]	@ (80083f8 <Thread1+0x2e8>)
 8008244:	701d      	strb	r5, [r3, #0]
          HB9II_mode = 1;
 8008246:	4b5d      	ldr	r3, [pc, #372]	@ (80083bc <Thread1+0x2ac>)
 8008248:	2601      	movs	r6, #1
          sweep_points = 401;
 800824a:	f240 1091 	movw	r0, #401	@ 0x191
          HB9II_mode = 1;
 800824e:	601e      	str	r6, [r3, #0]
          redraw_request = REDRAW_ALL; // <-- critical: don't OR with old redraw bits
 8008250:	231a      	movs	r3, #26
 8008252:	703b      	strb	r3, [r7, #0]
          sweep_points = 401;
 8008254:	f8a9 001a 	strh.w	r0, [r9, #26]
          set_sweep_points(401);
 8008258:	f7ff fb82 	bl	8007960 <set_sweep_points>
          set_sweep_frequency(ST_START, 3000000); // 3 MHz
 800825c:	4967      	ldr	r1, [pc, #412]	@ (80083fc <Thread1+0x2ec>)
 800825e:	4628      	mov	r0, r5
 8008260:	f7ff fc38 	bl	8007ad4 <set_sweep_frequency>
          set_sweep_frequency(ST_STOP, 30000000); // 30 MHz
 8008264:	4966      	ldr	r1, [pc, #408]	@ (8008400 <Thread1+0x2f0>)
 8008266:	4630      	mov	r0, r6
 8008268:	f7ff fc34 	bl	8007ad4 <set_sweep_frequency>
          lcd_clear_screen();
 800826c:	f008 febe 	bl	8010fec <lcd_clear_screen>
          ui_close_all();
 8008270:	f008 fba2 	bl	80109b8 <ui_close_all>
          plot_init();
 8008274:	f005 ff64 	bl	800e140 <plot_init>
          sweep_mode = (SWEEP_ENABLE | SWEEP_ONCE);
 8008278:	2303      	movs	r3, #3
 800827a:	f88a 3000 	strb.w	r3, [sl]
          redraw_request |= REDRAW_ALL;
 800827e:	783b      	ldrb	r3, [r7, #0]
 8008280:	f043 031a 	orr.w	r3, r3, #26
 8008284:	703b      	strb	r3, [r7, #0]
      chThdSleepMilliseconds(40);
 8008286:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 800828a:	f7f8 fe01 	bl	8000e90 <chThdSleep>
    if (HB9II_mode == 1)
 800828e:	4b4b      	ldr	r3, [pc, #300]	@ (80083bc <Thread1+0x2ac>)
 8008290:	681b      	ldr	r3, [r3, #0]
 8008292:	2b01      	cmp	r3, #1
 8008294:	d004      	beq.n	80082a0 <Thread1+0x190>
    if (HB9II_mode == 2)
 8008296:	2b02      	cmp	r3, #2
 8008298:	f43f af7a 	beq.w	8008190 <Thread1+0x80>
    if (HB9II_mode == 1)
 800829c:	2b01      	cmp	r3, #1
 800829e:	d1fd      	bne.n	800829c <Thread1+0x18c>
      doOnceOnly_In_Mode2 = true;
 80082a0:	4b48      	ldr	r3, [pc, #288]	@ (80083c4 <Thread1+0x2b4>)
 80082a2:	2601      	movs	r6, #1
 80082a4:	701e      	strb	r6, [r3, #0]
      uint16_t mask = get_sweep_mask();
 80082a6:	f7fd fb13 	bl	80058d0 <get_sweep_mask>
      if (sweep_mode & (SWEEP_ENABLE | SWEEP_ONCE))
 80082aa:	f89a 5000 	ldrb.w	r5, [sl]
 80082ae:	f015 0503 	ands.w	r5, r5, #3
 80082b2:	f040 81a8 	bne.w	8008606 <Thread1+0x4f6>
 80082b6:	bf30      	wfi
      while (shell_function)
 80082b8:	6823      	ldr	r3, [r4, #0]
 80082ba:	b173      	cbz	r3, 80082da <Thread1+0x1ca>
        shell_function = 0;
 80082bc:	2600      	movs	r6, #0
        shell_function(shell_nargs - 1, &shell_args[1]);
 80082be:	f8bb 0000 	ldrh.w	r0, [fp]
 80082c2:	6823      	ldr	r3, [r4, #0]
 80082c4:	494f      	ldr	r1, [pc, #316]	@ (8008404 <Thread1+0x2f4>)
 80082c6:	3801      	subs	r0, #1
 80082c8:	4798      	blx	r3
  chThdDequeueNextI(tqp, msg);
 80082ca:	484f      	ldr	r0, [pc, #316]	@ (8008408 <Thread1+0x2f8>)
        shell_function = 0;
 80082cc:	6026      	str	r6, [r4, #0]
 80082ce:	2100      	movs	r1, #0
 80082d0:	f7f8 fdfe 	bl	8000ed0 <chThdDequeueNextI>
      while (shell_function)
 80082d4:	6823      	ldr	r3, [r4, #0]
 80082d6:	2b00      	cmp	r3, #0
 80082d8:	d1f1      	bne.n	80082be <Thread1+0x1ae>
      sweep_mode |= SWEEP_UI_MODE;
 80082da:	f89a 3000 	ldrb.w	r3, [sl]
 80082de:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 80082e2:	f88a 3000 	strb.w	r3, [sl]
      ui_process();
 80082e6:	f008 fae5 	bl	80108b4 <ui_process>
      sweep_mode &= ~SWEEP_UI_MODE;
 80082ea:	f89a 3000 	ldrb.w	r3, [sl]
 80082ee:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80082f2:	f88a 3000 	strb.w	r3, [sl]
      if (completed)
 80082f6:	2d00      	cmp	r5, #0
 80082f8:	d145      	bne.n	8008386 <Thread1+0x276>
    if (HB9II_mode == 2)
 80082fa:	4b30      	ldr	r3, [pc, #192]	@ (80083bc <Thread1+0x2ac>)
 80082fc:	681b      	ldr	r3, [r3, #0]
 80082fe:	e7ca      	b.n	8008296 <Thread1+0x186>
  if (py >= topY && py < topY + boxH)
 8008300:	2a0a      	cmp	r2, #10
 8008302:	ddc0      	ble.n	8008286 <Thread1+0x176>
 8008304:	2a20      	cmp	r2, #32
 8008306:	f300 822e 	bgt.w	8008766 <Thread1+0x656>
    dir = +1; // upper = increment
 800830a:	2601      	movs	r6, #1
  int x = xBase;
 800830c:	22c8      	movs	r2, #200	@ 0xc8
  int digitIdx = -1;
 800830e:	f04f 35ff 	mov.w	r5, #4294967295
  for (int sym = 0; sym < 10; sym++)
 8008312:	2300      	movs	r3, #0
    const int isDot = (sym == 2) || (sym == 6);
 8008314:	f023 0004 	bic.w	r0, r3, #4
 8008318:	2802      	cmp	r0, #2
 800831a:	d012      	beq.n	8008342 <Thread1+0x232>
      if (px >= bx0 && px < bx1)
 800831c:	4291      	cmp	r1, r2
      int bx1 = bx0 + boxW;
 800831e:	f102 0014 	add.w	r0, r2, #20
  for (int sym = 0; sym < 10; sym++)
 8008322:	f103 0301 	add.w	r3, r3, #1
      digitIdx++;
 8008326:	f105 0501 	add.w	r5, r5, #1
      x += cw;
 800832a:	f102 0215 	add.w	r2, r2, #21
      if (px >= bx0 && px < bx1)
 800832e:	dd02      	ble.n	8008336 <Thread1+0x226>
 8008330:	4281      	cmp	r1, r0
 8008332:	f2c0 845b 	blt.w	8008bec <Thread1+0xadc>
  for (int sym = 0; sym < 10; sym++)
 8008336:	2b0a      	cmp	r3, #10
 8008338:	d0a5      	beq.n	8008286 <Thread1+0x176>
    const int isDot = (sym == 2) || (sym == 6);
 800833a:	f023 0004 	bic.w	r0, r3, #4
 800833e:	2802      	cmp	r0, #2
 8008340:	d1ec      	bne.n	800831c <Thread1+0x20c>
      x += (cw / 2); // '.' is narrower (same as your working hitbox code)
 8008342:	320a      	adds	r2, #10
  for (int sym = 0; sym < 10; sym++)
 8008344:	3301      	adds	r3, #1
 8008346:	e7e5      	b.n	8008314 <Thread1+0x204>
        targetting_mode = true;
 8008348:	4b1d      	ldr	r3, [pc, #116]	@ (80083c0 <Thread1+0x2b0>)
        MLA_UART_LOG("[MLA] We are in Mode 2\r\n");
 800834a:	4830      	ldr	r0, [pc, #192]	@ (800840c <Thread1+0x2fc>)
        targetting_mode = true;
 800834c:	2501      	movs	r5, #1
 800834e:	701d      	strb	r5, [r3, #0]
        MLA_UART_LOG("[MLA] We are in Mode 2\r\n");
 8008350:	f7fd fb04 	bl	800595c <serial_shell_printf>
        set_sweep_frequency(ST_START, target_frequency);
 8008354:	4b1d      	ldr	r3, [pc, #116]	@ (80083cc <Thread1+0x2bc>)
 8008356:	461e      	mov	r6, r3
 8008358:	6819      	ldr	r1, [r3, #0]
 800835a:	2000      	movs	r0, #0
 800835c:	f7ff fbba 	bl	8007ad4 <set_sweep_frequency>
        set_sweep_frequency(ST_STOP, target_frequency);
 8008360:	6831      	ldr	r1, [r6, #0]
 8008362:	4628      	mov	r0, r5
 8008364:	f7ff fbb6 	bl	8007ad4 <set_sweep_frequency>
        lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8008368:	2100      	movs	r1, #0
 800836a:	4608      	mov	r0, r1
        sweep_points = 1;
 800836c:	f8a9 501a 	strh.w	r5, [r9, #26]
        lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 8008370:	f008 fea2 	bl	80110b8 <lcd_set_colors>
        lcd_fill(0, 0, LCD_WIDTH, LCD_HEIGHT);
 8008374:	2100      	movs	r1, #0
 8008376:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 800837a:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800837e:	4608      	mov	r0, r1
 8008380:	f008 fd94 	bl	8010eac <lcd_fill>
 8008384:	e709      	b.n	800819a <Thread1+0x8a>
  for (int i = 0; i < sweep_points; i++)
 8008386:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800838a:	2b00      	cmp	r3, #0
 800838c:	f000 832a 	beq.w	80089e4 <Thread1+0x8d4>
 8008390:	4f0f      	ldr	r7, [pc, #60]	@ (80083d0 <Thread1+0x2c0>)
 8008392:	950f      	str	r5, [sp, #60]	@ 0x3c
  float best_mag2 = 0.0f;
 8008394:	eddf 6a1e 	vldr	s13, [pc, #120]	@ 8008410 <Thread1+0x300>
  for (int i = 0; i < sweep_points; i++)
 8008398:	463d      	mov	r5, r7
  int best = -1;
 800839a:	f04f 38ff 	mov.w	r8, #4294967295
  for (int i = 0; i < sweep_points; i++)
 800839e:	2600      	movs	r6, #0
 80083a0:	461f      	mov	r7, r3
 80083a2:	e04b      	b.n	800843c <Thread1+0x32c>
 80083a4:	20004f51 	.word	0x20004f51
 80083a8:	40e66666 	.word	0x40e66666
 80083ac:	3ca3d70a 	.word	0x3ca3d70a
 80083b0:	3cf5c28f 	.word	0x3cf5c28f
 80083b4:	3d969697 	.word	0x3d969697
 80083b8:	461c3c00 	.word	0x461c3c00
 80083bc:	200068f4 	.word	0x200068f4
 80083c0:	200003d6 	.word	0x200003d6
 80083c4:	200068f8 	.word	0x200068f8
 80083c8:	20006888 	.word	0x20006888
 80083cc:	200068f0 	.word	0x200068f0
 80083d0:	20004f54 	.word	0x20004f54
 80083d4:	3f7f7cfe 	.word	0x3f7f7cfe
 80083d8:	20008a00 	.word	0x20008a00
 80083dc:	200089fc 	.word	0x200089fc
 80083e0:	080137a0 	.word	0x080137a0
 80083e4:	20006874 	.word	0x20006874
 80083e8:	2000687d 	.word	0x2000687d
 80083ec:	20006878 	.word	0x20006878
 80083f0:	2000687c 	.word	0x2000687c
 80083f4:	20006876 	.word	0x20006876
 80083f8:	20006875 	.word	0x20006875
 80083fc:	002dc6c0 	.word	0x002dc6c0
 8008400:	01c9c380 	.word	0x01c9c380
 8008404:	20006894 	.word	0x20006894
 8008408:	200068e4 	.word	0x200068e4
 800840c:	08013784 	.word	0x08013784
 8008410:	00000000 	.word	0x00000000
 8008414:	20000aa8 	.word	0x20000aa8
 8008418:	200003c4 	.word	0x200003c4
 800841c:	2000688c 	.word	0x2000688c
      best = i;
 8008420:	eef4 7ae6 	vcmpe.f32	s15, s13
 8008424:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008428:	bf48      	it	mi
 800842a:	46b0      	movmi	r8, r6
 800842c:	bf48      	it	mi
 800842e:	eef0 6a67 	vmovmi.f32	s13, s15
  for (int i = 0; i < sweep_points; i++)
 8008432:	3601      	adds	r6, #1
 8008434:	42be      	cmp	r6, r7
 8008436:	f105 0508 	add.w	r5, r5, #8
 800843a:	d017      	beq.n	800846c <Thread1+0x35c>
    const freq_t f = getFrequency((uint16_t)i);
 800843c:	b2b0      	uxth	r0, r6
 800843e:	f7fe fbe1 	bl	8006c04 <getFrequency>
    if (f == 0)
 8008442:	2800      	cmp	r0, #0
 8008444:	d0f5      	beq.n	8008432 <Thread1+0x322>
    const float im = measured[0][i][1];
 8008446:	edd5 7a01 	vldr	s15, [r5, #4]
    const float re = measured[0][i][0];
 800844a:	ed95 7a00 	vldr	s14, [r5]
    const float mag2 = (re * re) + (im * im);
 800844e:	ee67 7aa7 	vmul.f32	s15, s15, s15
    if (best < 0 || mag2 < best_mag2)
 8008452:	f1b8 3fff 	cmp.w	r8, #4294967295
    const float mag2 = (re * re) + (im * im);
 8008456:	eee7 7a07 	vfma.f32	s15, s14, s14
    if (best < 0 || mag2 < best_mag2)
 800845a:	d1e1      	bne.n	8008420 <Thread1+0x310>
      best = i;
 800845c:	46b0      	mov	r8, r6
  for (int i = 0; i < sweep_points; i++)
 800845e:	3601      	adds	r6, #1
 8008460:	42be      	cmp	r6, r7
      best_mag2 = mag2;
 8008462:	eef0 6a67 	vmov.f32	s13, s15
  for (int i = 0; i < sweep_points; i++)
 8008466:	f105 0508 	add.w	r5, r5, #8
 800846a:	d1e7      	bne.n	800843c <Thread1+0x32c>
  if (best >= 0)
 800846c:	f1b8 3fff 	cmp.w	r8, #4294967295
 8008470:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
 8008472:	f000 82b7 	beq.w	80089e4 <Thread1+0x8d4>
    mla_res_idx = (int16_t)best;
 8008476:	4bc9      	ldr	r3, [pc, #804]	@ (800879c <Thread1+0x68c>)
 8008478:	fa0f f688 	sxth.w	r6, r8
    mla_res_freq = getFrequency((uint16_t)best);
 800847c:	fa1f f088 	uxth.w	r0, r8
    mla_res_idx = (int16_t)best;
 8008480:	801e      	strh	r6, [r3, #0]
    mla_res_freq = getFrequency((uint16_t)best);
 8008482:	f7fe fbbf 	bl	8006c04 <getFrequency>
 8008486:	4bc6      	ldr	r3, [pc, #792]	@ (80087a0 <Thread1+0x690>)
 8008488:	4601      	mov	r1, r0
 800848a:	6018      	str	r0, [r3, #0]
    MLA_UART_LOG("[MLA] Resonance Freq: " VNA_FREQ_FMT_STR " Hz (idx=%d)\r\n",
 800848c:	4632      	mov	r2, r6
 800848e:	48c5      	ldr	r0, [pc, #788]	@ (80087a4 <Thread1+0x694>)
 8008490:	f7fd fa64 	bl	800595c <serial_shell_printf>
  if (mla_res_idx < 0 || mla_res_idx >= (int16_t)sweep_points)
 8008494:	4bc1      	ldr	r3, [pc, #772]	@ (800879c <Thread1+0x68c>)
        target_frequency = mla_res_freq;
 8008496:	4ac4      	ldr	r2, [pc, #784]	@ (80087a8 <Thread1+0x698>)
  if (mla_res_idx < 0 || mla_res_idx >= (int16_t)sweep_points)
 8008498:	f9b3 6000 	ldrsh.w	r6, [r3]
        target_frequency = mla_res_freq;
 800849c:	4bc0      	ldr	r3, [pc, #768]	@ (80087a0 <Thread1+0x690>)
  if (mla_res_idx < 0 || mla_res_idx >= (int16_t)sweep_points)
 800849e:	2e00      	cmp	r6, #0
        target_frequency = mla_res_freq;
 80084a0:	681b      	ldr	r3, [r3, #0]
 80084a2:	6013      	str	r3, [r2, #0]
  if (mla_res_idx < 0 || mla_res_idx >= (int16_t)sweep_points)
 80084a4:	f2c0 8295 	blt.w	80089d2 <Thread1+0x8c2>
 80084a8:	f9b9 301a 	ldrsh.w	r3, [r9, #26]
 80084ac:	42b3      	cmp	r3, r6
 80084ae:	f340 8290 	ble.w	80089d2 <Thread1+0x8c2>
  float swr = getSWRfromIndex((uint16_t)mla_res_idx);
 80084b2:	b2b0      	uxth	r0, r6
 80084b4:	f7fc fffc 	bl	80054b0 <getSWRfromIndex>
  MLA_UART_LOG("[MLA] Resonance SWR: %.2f (idx=%d)\r\n", swr, (int)mla_res_idx);
 80084b8:	ee10 0a10 	vmov	r0, s0
  float swr = getSWRfromIndex((uint16_t)mla_res_idx);
 80084bc:	eeb0 8a40 	vmov.f32	s16, s0
  MLA_UART_LOG("[MLA] Resonance SWR: %.2f (idx=%d)\r\n", swr, (int)mla_res_idx);
 80084c0:	f7f8 f86e 	bl	80005a0 <__aeabi_f2d>
  if (swr <= 0.0f || swr > 50.0f)
 80084c4:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 80084c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  MLA_UART_LOG("[MLA] Resonance SWR: %.2f (idx=%d)\r\n", swr, (int)mla_res_idx);
 80084cc:	4602      	mov	r2, r0
 80084ce:	460b      	mov	r3, r1
    MLA_UART_LOG("[MLA] Resonance SWR: invalid (%.2f) at idx=%d\r\n",
 80084d0:	9600      	str	r6, [sp, #0]
  if (swr <= 0.0f || swr > 50.0f)
 80084d2:	f240 8292 	bls.w	80089fa <Thread1+0x8ea>
 80084d6:	eddf 7ab5 	vldr	s15, [pc, #724]	@ 80087ac <Thread1+0x69c>
 80084da:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80084de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80084e2:	f300 828a 	bgt.w	80089fa <Thread1+0x8ea>
  MLA_UART_LOG("[MLA] Resonance SWR: %.2f (idx=%d)\r\n", swr, (int)mla_res_idx);
 80084e6:	48b2      	ldr	r0, [pc, #712]	@ (80087b0 <Thread1+0x6a0>)
 80084e8:	f7fd fa38 	bl	800595c <serial_shell_printf>
        mla_res_swr = mla_calc_swr_at_resonance_after_sweep();
 80084ec:	4bb1      	ldr	r3, [pc, #708]	@ (80087b4 <Thread1+0x6a4>)
 80084ee:	ed83 8a00 	vstr	s16, [r3]
        mla_update_bandwidth_swr2();
 80084f2:	f7fe ffdf 	bl	80074b4 <mla_update_bandwidth_swr2>
        mla_calc_q_after_sweep();
 80084f6:	f7fd fa43 	bl	8005980 <mla_calc_q_after_sweep>
  const float q = mla_calc_q_after_sweep(); // compute once, reuse
 80084fa:	f7fd fa41 	bl	8005980 <mla_calc_q_after_sweep>
  if (q <= 0.0f)
 80084fe:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8008502:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008506:	f240 832f 	bls.w	8008b68 <Thread1+0xa58>
  if (q >= 500.0f)
 800850a:	eddf 7aab 	vldr	s15, [pc, #684]	@ 80087b8 <Thread1+0x6a8>
 800850e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008516:	f280 8263 	bge.w	80089e0 <Thread1+0x8d0>
  else if (q >= 350.0f)
 800851a:	eddf 7aa8 	vldr	s15, [pc, #672]	@ 80087bc <Thread1+0x6ac>
 800851e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008522:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008526:	f280 8274 	bge.w	8008a12 <Thread1+0x902>
  else if (q >= 200.0f)
 800852a:	eddf 7aa5 	vldr	s15, [pc, #660]	@ 80087c0 <Thread1+0x6b0>
 800852e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008532:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008536:	f280 8398 	bge.w	8008c6a <Thread1+0xb5a>
  else if (q >= 100.0f)
 800853a:	eddf 7aa2 	vldr	s15, [pc, #648]	@ 80087c4 <Thread1+0x6b4>
 800853e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8008542:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008546:	f2c0 83af 	blt.w	8008ca8 <Thread1+0xb98>
    rating = "FAIR";
 800854a:	4e9f      	ldr	r6, [pc, #636]	@ (80087c8 <Thread1+0x6b8>)
  MLA_UART_LOG("[MLA] Q rating: %s (Q@SWR2=%.1f)\r\n", rating, q);
 800854c:	ee10 0a10 	vmov	r0, s0
 8008550:	f7f8 f826 	bl	80005a0 <__aeabi_f2d>
 8008554:	4602      	mov	r2, r0
 8008556:	460b      	mov	r3, r1
 8008558:	489c      	ldr	r0, [pc, #624]	@ (80087cc <Thread1+0x6bc>)
 800855a:	4631      	mov	r1, r6
 800855c:	f7fd f9fe 	bl	800595c <serial_shell_printf>
        if (!mla_resonance_locked)
 8008560:	4b9b      	ldr	r3, [pc, #620]	@ (80087d0 <Thread1+0x6c0>)
 8008562:	781e      	ldrb	r6, [r3, #0]
 8008564:	2e00      	cmp	r6, #0
 8008566:	d05d      	beq.n	8008624 <Thread1+0x514>
        if (mla_resonance_locked && mla_autozone_stage < 3)
 8008568:	4b9a      	ldr	r3, [pc, #616]	@ (80087d4 <Thread1+0x6c4>)
 800856a:	781f      	ldrb	r7, [r3, #0]
 800856c:	2f02      	cmp	r7, #2
 800856e:	f240 8276 	bls.w	8008a5e <Thread1+0x94e>
          int type = trace[t].type;
 8008572:	f899 3029 	ldrb.w	r3, [r9, #41]	@ 0x29
          get_value_cb_t cb = trace_info_list[type].get_value_cb;
 8008576:	4a98      	ldr	r2, [pc, #608]	@ (80087d8 <Thread1+0x6c8>)
 8008578:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800857c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008580:	699a      	ldr	r2, [r3, #24]
          if (cb)
 8008582:	2a00      	cmp	r2, #0
 8008584:	f040 8171 	bne.w	800886a <Thread1+0x75a>
          int type = trace[t].type;
 8008588:	f899 304d 	ldrb.w	r3, [r9, #77]	@ 0x4d
          get_value_cb_t cb = trace_info_list[type].get_value_cb;
 800858c:	4a92      	ldr	r2, [pc, #584]	@ (80087d8 <Thread1+0x6c8>)
 800858e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8008592:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008596:	f8d3 8018 	ldr.w	r8, [r3, #24]
          if (cb)
 800859a:	f1b8 0f00 	cmp.w	r8, #0
 800859e:	f040 80e9 	bne.w	8008774 <Thread1+0x664>
          drawTheSWRLines = false;
 80085a2:	4a8e      	ldr	r2, [pc, #568]	@ (80087dc <Thread1+0x6cc>)
 80085a4:	2300      	movs	r3, #0
        request_to_redraw(REDRAW_BACKUP | REDRAW_AREA);
 80085a6:	f240 4002 	movw	r0, #1026	@ 0x402
          drawTheSWRLines = false;
 80085aa:	7013      	strb	r3, [r2, #0]
        request_to_redraw(REDRAW_BACKUP | REDRAW_AREA);
 80085ac:	f004 f8dc 	bl	800c768 <request_to_redraw>
             (mla_res_stable_count > 0) &&
 80085b0:	4b87      	ldr	r3, [pc, #540]	@ (80087d0 <Thread1+0x6c0>)
 80085b2:	781b      	ldrb	r3, [r3, #0]
 80085b4:	b92b      	cbnz	r3, 80085c2 <Thread1+0x4b2>
            (!mla_resonance_locked &&
 80085b6:	4b8a      	ldr	r3, [pc, #552]	@ (80087e0 <Thread1+0x6d0>)
 80085b8:	781b      	ldrb	r3, [r3, #0]
 80085ba:	3b01      	subs	r3, #1
 80085bc:	2b01      	cmp	r3, #1
 80085be:	f67f ae9c 	bls.w	80082fa <Thread1+0x1ea>
        if (!in_mla_stability_phase && (mla_no_dip_count == 0))
 80085c2:	4b88      	ldr	r3, [pc, #544]	@ (80087e4 <Thread1+0x6d4>)
 80085c4:	781b      	ldrb	r3, [r3, #0]
 80085c6:	2b00      	cmp	r3, #0
 80085c8:	f47f ae97 	bne.w	80082fa <Thread1+0x1ea>
          request_to_redraw(REDRAW_PLOT);
 80085cc:	2001      	movs	r0, #1
 80085ce:	f004 f8cb 	bl	800c768 <request_to_redraw>
          draw_all();
 80085d2:	f004 f8f1 	bl	800c7b8 <draw_all>
          bool centered = mla_is_resonance_centered();
 80085d6:	f7fd fa27 	bl	8005a28 <mla_is_resonance_centered>
          if (!centered)
 80085da:	2800      	cmp	r0, #0
 80085dc:	f47f ae8d 	bne.w	80082fa <Thread1+0x1ea>
            start = mla_res_freq - (SPAN_HZ / 2);
 80085e0:	4b6f      	ldr	r3, [pc, #444]	@ (80087a0 <Thread1+0x690>)
 80085e2:	681d      	ldr	r5, [r3, #0]
            set_sweep_frequency(ST_START, start);
 80085e4:	f5a5 21f4 	sub.w	r1, r5, #499712	@ 0x7a000
 80085e8:	f5a1 7190 	sub.w	r1, r1, #288	@ 0x120
 80085ec:	f7ff fa72 	bl	8007ad4 <set_sweep_frequency>
            set_sweep_frequency(ST_STOP, stop);
 80085f0:	f505 21f4 	add.w	r1, r5, #499712	@ 0x7a000
 80085f4:	f501 7190 	add.w	r1, r1, #288	@ 0x120
 80085f8:	2001      	movs	r0, #1
 80085fa:	f7ff fa6b 	bl	8007ad4 <set_sweep_frequency>
            mla_autozone_stage = 1;
 80085fe:	4a75      	ldr	r2, [pc, #468]	@ (80087d4 <Thread1+0x6c4>)
 8008600:	2301      	movs	r3, #1
 8008602:	7013      	strb	r3, [r2, #0]
 8008604:	e679      	b.n	80082fa <Thread1+0x1ea>
        completed = sweep(true, mask);
 8008606:	4601      	mov	r1, r0
 8008608:	4630      	mov	r0, r6
 800860a:	f7fe fb17 	bl	8006c3c <sweep>
        sweep_mode &= ~SWEEP_ONCE;
 800860e:	f89a 3000 	ldrb.w	r3, [sl]
 8008612:	f023 0302 	bic.w	r3, r3, #2
        completed = sweep(true, mask);
 8008616:	4605      	mov	r5, r0
        sweep_mode &= ~SWEEP_ONCE;
 8008618:	f88a 3000 	strb.w	r3, [sl]
 800861c:	e64c      	b.n	80082b8 <Thread1+0x1a8>
        float swr = (mag < 0.999f) ? (1.0f + mag) / (1.0f - mag) : 9999.0f;
 800861e:	eeb0 8a68 	vmov.f32	s16, s17
 8008622:	e5e1      	b.n	80081e8 <Thread1+0xd8>
          if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8008624:	4b6f      	ldr	r3, [pc, #444]	@ (80087e4 <Thread1+0x6d4>)
 8008626:	781b      	ldrb	r3, [r3, #0]
 8008628:	2b01      	cmp	r3, #1
 800862a:	f240 8310 	bls.w	8008c4e <Thread1+0xb3e>
  if (sweep_points < 3)
 800862e:	f8b9 701a 	ldrh.w	r7, [r9, #26]
 8008632:	2f02      	cmp	r7, #2
 8008634:	f240 8312 	bls.w	8008c5c <Thread1+0xb4c>
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8008638:	2201      	movs	r2, #1
 800863a:	f1a7 0c02 	sub.w	ip, r7, #2
  float best_mag2 = 1e30f;
 800863e:	eddf 6a6a 	vldr	s13, [pc, #424]	@ 80087e8 <Thread1+0x6d8>
 8008642:	4b6a      	ldr	r3, [pc, #424]	@ (80087ec <Thread1+0x6dc>)
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8008644:	fa1f fc8c 	uxth.w	ip, ip
  uint16_t best_idx = i_start;
 8008648:	4610      	mov	r0, r2
 800864a:	4611      	mov	r1, r2
 800864c:	e00d      	b.n	800866a <Thread1+0x55a>
      best_mag2 = mag2;
 800864e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008652:	bfc4      	itt	gt
 8008654:	462e      	movgt	r6, r5
 8008656:	4608      	movgt	r0, r1
 8008658:	bfc8      	it	gt
 800865a:	eef0 6a67 	vmovgt.f32	s13, s15
  for (uint16_t i = i_start; i <= i_end; i++)
 800865e:	3201      	adds	r2, #1
 8008660:	b291      	uxth	r1, r2
 8008662:	458c      	cmp	ip, r1
 8008664:	f103 0308 	add.w	r3, r3, #8
 8008668:	d31a      	bcc.n	80086a0 <Thread1+0x590>
    float im = measured[0][i][1];
 800866a:	edd3 7a03 	vldr	s15, [r3, #12]
    float re = measured[0][i][0];
 800866e:	ed93 7a02 	vldr	s14, [r3, #8]
    float mag2 = re * re + im * im;
 8008672:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8008676:	eee7 7a07 	vfma.f32	s15, s14, s14
    if (mag2 == 0.0f)
 800867a:	eef5 7a40 	vcmp.f32	s15, #0.0
 800867e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008682:	d0ec      	beq.n	800865e <Thread1+0x54e>
      best_mag2 = mag2;
 8008684:	eef4 6ae7 	vcmpe.f32	s13, s15
    if (!found || mag2 < best_mag2)
 8008688:	2e00      	cmp	r6, #0
 800868a:	d1e0      	bne.n	800864e <Thread1+0x53e>
  for (uint16_t i = i_start; i <= i_end; i++)
 800868c:	3201      	adds	r2, #1
      best_idx = i;
 800868e:	4608      	mov	r0, r1
  for (uint16_t i = i_start; i <= i_end; i++)
 8008690:	b291      	uxth	r1, r2
 8008692:	458c      	cmp	ip, r1
      best_mag2 = mag2;
 8008694:	eef0 6a67 	vmov.f32	s13, s15
      found = true;
 8008698:	462e      	mov	r6, r5
  for (uint16_t i = i_start; i <= i_end; i++)
 800869a:	f103 0308 	add.w	r3, r3, #8
 800869e:	d2e4      	bcs.n	800866a <Thread1+0x55a>
  if (!found)
 80086a0:	2e00      	cmp	r6, #0
 80086a2:	f000 82db 	beq.w	8008c5c <Thread1+0xb4c>
  float swr_min = getSWRfromIndex(idx);
 80086a6:	f7fc ff03 	bl	80054b0 <getSWRfromIndex>
  if (swr_min <= 0.0f || swr_min > 50.0f)
 80086aa:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80086ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float swr_min = getSWRfromIndex(idx);
 80086b2:	eef0 5a40 	vmov.f32	s11, s0
  if (swr_min <= 0.0f || swr_min > 50.0f)
 80086b6:	f240 81b6 	bls.w	8008a26 <Thread1+0x916>
 80086ba:	eddf 7a3c 	vldr	s15, [pc, #240]	@ 80087ac <Thread1+0x69c>
 80086be:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80086c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086c6:	f300 81ae 	bgt.w	8008a26 <Thread1+0x916>
  float max_swr = 0.0f;
 80086ca:	ed9f 6a49 	vldr	s12, [pc, #292]	@ 80087f0 <Thread1+0x6e0>
  if (swr_min <= 0.0f || swr_min > 50.0f)
 80086ce:	2200      	movs	r2, #0
    float swr = getSWRfromIndex(i);
 80086d0:	b290      	uxth	r0, r2
 80086d2:	f7fc feed 	bl	80054b0 <getSWRfromIndex>
    if (swr > 0.0f && swr < 9999.0f && swr > max_swr)
 80086d6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80086da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  for (uint16_t i = 0; i < sweep_points; i++)
 80086de:	f102 0201 	add.w	r2, r2, #1
    if (swr > 0.0f && swr < 9999.0f && swr > max_swr)
 80086e2:	dd0b      	ble.n	80086fc <Thread1+0x5ec>
 80086e4:	eeb4 0ae8 	vcmpe.f32	s0, s17
 80086e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086ec:	d506      	bpl.n	80086fc <Thread1+0x5ec>
 80086ee:	eeb4 6ac0 	vcmpe.f32	s12, s0
 80086f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086f6:	bfb8      	it	lt
 80086f8:	eeb0 6a40 	vmovlt.f32	s12, s0
  for (uint16_t i = 0; i < sweep_points; i++)
 80086fc:	42ba      	cmp	r2, r7
 80086fe:	d1e7      	bne.n	80086d0 <Thread1+0x5c0>
  if (max_swr <= 0.0f)
 8008700:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
 8008704:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008708:	f240 82dd 	bls.w	8008cc6 <Thread1+0xbb6>
  float ratio = max_swr / swr_min;
 800870c:	ee86 7a25 	vdiv.f32	s14, s12, s11
  if (ratio < 1.5f || swr_min > 10.0f)
 8008710:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 8008714:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8008718:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800871c:	d407      	bmi.n	800872e <Thread1+0x61e>
 800871e:	eef2 7a04 	vmov.f32	s15, #36	@ 0x41200000  10.0
 8008722:	eef4 5ae7 	vcmpe.f32	s11, s15
 8008726:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800872a:	f340 82c5 	ble.w	8008cb8 <Thread1+0xba8>
    mla_has_good_resonance = false;
 800872e:	4a31      	ldr	r2, [pc, #196]	@ (80087f4 <Thread1+0x6e4>)
    MLA_UART_LOG("[MLA][good_dip] NO CLEAR RESONANCE\r\n");
 8008730:	4831      	ldr	r0, [pc, #196]	@ (80087f8 <Thread1+0x6e8>)
    mla_has_good_resonance = false;
 8008732:	2300      	movs	r3, #0
 8008734:	7013      	strb	r3, [r2, #0]
    MLA_UART_LOG("[MLA][good_dip] NO CLEAR RESONANCE\r\n");
 8008736:	f7fd f911 	bl	800595c <serial_shell_printf>
          if (mla_has_good_resonance)
 800873a:	4b2e      	ldr	r3, [pc, #184]	@ (80087f4 <Thread1+0x6e4>)
 800873c:	781b      	ldrb	r3, [r3, #0]
 800873e:	2b00      	cmp	r3, #0
 8008740:	f040 817c 	bne.w	8008a3c <Thread1+0x92c>
            mla_res_stable_count = 0;
 8008744:	4a26      	ldr	r2, [pc, #152]	@ (80087e0 <Thread1+0x6d0>)
 8008746:	7013      	strb	r3, [r2, #0]
            if (mla_no_dip_count < MLA_NO_DIP_LIMIT)
 8008748:	4b26      	ldr	r3, [pc, #152]	@ (80087e4 <Thread1+0x6d4>)
 800874a:	781b      	ldrb	r3, [r3, #0]
 800874c:	2b01      	cmp	r3, #1
 800874e:	f240 8162 	bls.w	8008a16 <Thread1+0x906>
              ui_hide_check_amtenna_hint();
 8008752:	f007 fe8f 	bl	8010474 <ui_hide_check_amtenna_hint>
              ui_show_no_resonance_hint();
 8008756:	f007 fe61 	bl	801041c <ui_show_no_resonance_hint>
        if (mla_resonance_locked && mla_autozone_stage < 3)
 800875a:	4b1d      	ldr	r3, [pc, #116]	@ (80087d0 <Thread1+0x6c0>)
 800875c:	781b      	ldrb	r3, [r3, #0]
 800875e:	2b00      	cmp	r3, #0
 8008760:	f43f af07 	beq.w	8008572 <Thread1+0x462>
 8008764:	e700      	b.n	8008568 <Thread1+0x458>
  else if (py >= botY && py < botY + boxH)
 8008766:	3a46      	subs	r2, #70	@ 0x46
 8008768:	2a15      	cmp	r2, #21
 800876a:	f63f ad8c 	bhi.w	8008286 <Thread1+0x176>
    dir = -1; // lower = decrement
 800876e:	f04f 36ff 	mov.w	r6, #4294967295
 8008772:	e5cb      	b.n	800830c <Thread1+0x1fc>
            float (*array)[2] = measured[ch];
 8008774:	f899 304e 	ldrb.w	r3, [r9, #78]	@ 0x4e
 8008778:	481c      	ldr	r0, [pc, #112]	@ (80087ec <Thread1+0x6dc>)
            for (int i = 0; i < sweep_points; i++)
 800877a:	f8b9 201a 	ldrh.w	r2, [r9, #26]
            float min_p = 0.0f, max_p = 0.0f;
 800877e:	eddf ba1c 	vldr	s23, [pc, #112]	@ 80087f0 <Thread1+0x6e0>
            float (*array)[2] = measured[ch];
 8008782:	f640 4188 	movw	r1, #3208	@ 0xc88
 8008786:	fb01 0703 	mla	r7, r1, r3, r0
            for (int i = 0; i < sweep_points; i++)
 800878a:	2a00      	cmp	r2, #0
 800878c:	f000 813e 	beq.w	8008a0c <Thread1+0x8fc>
            float min_p = 0.0f, max_p = 0.0f;
 8008790:	eeb0 ca6b 	vmov.f32	s24, s23
              if (swr < 1.0f)
 8008794:	eeb7 ba00 	vmov.f32	s22, #112	@ 0x3f800000  1.0
            for (int i = 0; i < sweep_points; i++)
 8008798:	2600      	movs	r6, #0
 800879a:	e047      	b.n	800882c <Thread1+0x71c>
 800879c:	200003d4 	.word	0x200003d4
 80087a0:	20006884 	.word	0x20006884
 80087a4:	08013214 	.word	0x08013214
 80087a8:	200068f0 	.word	0x200068f0
 80087ac:	42480000 	.word	0x42480000
 80087b0:	080132c0 	.word	0x080132c0
 80087b4:	20006880 	.word	0x20006880
 80087b8:	43fa0000 	.word	0x43fa0000
 80087bc:	43af0000 	.word	0x43af0000
 80087c0:	43480000 	.word	0x43480000
 80087c4:	42c80000 	.word	0x42c80000
 80087c8:	0801319c 	.word	0x0801319c
 80087cc:	08013300 	.word	0x08013300
 80087d0:	2000687d 	.word	0x2000687d
 80087d4:	20006875 	.word	0x20006875
 80087d8:	0801650c 	.word	0x0801650c
 80087dc:	20006874 	.word	0x20006874
 80087e0:	2000687c 	.word	0x2000687c
 80087e4:	20006876 	.word	0x20006876
 80087e8:	7149f2ca 	.word	0x7149f2ca
 80087ec:	20004f54 	.word	0x20004f54
 80087f0:	00000000 	.word	0x00000000
 80087f4:	2000687e 	.word	0x2000687e
 80087f8:	080133e4 	.word	0x080133e4
                if (p < min_p)
 80087fc:	eeb4 cac8 	vcmpe.f32	s24, s16
 8008800:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (p > max_p)
 8008804:	eef4 bac8 	vcmpe.f32	s23, s16
                if (p < min_p)
 8008808:	bf88      	it	hi
 800880a:	eeb0 ca48 	vmovhi.f32	s24, s16
                if (p > max_p)
 800880e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008812:	bfb8      	it	lt
 8008814:	eef0 ba48 	vmovlt.f32	s23, s16
            for (int i = 0; i < sweep_points; i++)
 8008818:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800881c:	3601      	adds	r6, #1
 800881e:	42b3      	cmp	r3, r6
 8008820:	f04f 0500 	mov.w	r5, #0
 8008824:	f107 0708 	add.w	r7, r7, #8
 8008828:	f340 809b 	ble.w	8008962 <Thread1+0x852>
              float swr = cb(i, array[i]);
 800882c:	4639      	mov	r1, r7
 800882e:	4630      	mov	r0, r6
 8008830:	47c0      	blx	r8
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 8008832:	eef0 cac0 	vabs.f32	s25, s0
 8008836:	eeb0 8a40 	vmov.f32	s16, s0
              if (vna_fabsf(swr) == infinityf())
 800883a:	f009 fe37 	bl	80124ac <infinityf>
 800883e:	eeb4 0a6c 	vcmp.f32	s0, s25
 8008842:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
              if (swr < 1.0f)
 8008846:	eeb4 8acb 	vcmpe.f32	s16, s22
              if (vna_fabsf(swr) == infinityf())
 800884a:	f000 808a 	beq.w	8008962 <Thread1+0x852>
              if (swr < 1.0f)
 800884e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008852:	bfb8      	it	lt
 8008854:	eeb0 8a4b 	vmovlt.f32	s16, s22
              float p = swr - 1.0f;
 8008858:	ee38 8a4b 	vsub.f32	s16, s16, s22
              if (first)
 800885c:	2d00      	cmp	r5, #0
 800885e:	d0cd      	beq.n	80087fc <Thread1+0x6ec>
                min_p = max_p = p;
 8008860:	eef0 ba48 	vmov.f32	s23, s16
 8008864:	eeb0 ca48 	vmov.f32	s24, s16
 8008868:	e7d6      	b.n	8008818 <Thread1+0x708>
            float (*array)[2] = measured[ch];
 800886a:	f899 302a 	ldrb.w	r3, [r9, #42]	@ 0x2a
 800886e:	4ec0      	ldr	r6, [pc, #768]	@ (8008b70 <Thread1+0xa60>)
            for (int i = 0; i < sweep_points; i++)
 8008870:	f8b9 101a 	ldrh.w	r1, [r9, #26]
            float (*array)[2] = measured[ch];
 8008874:	f640 4088 	movw	r0, #3208	@ 0xc88
 8008878:	fb00 6703 	mla	r7, r0, r3, r6
            for (int i = 0; i < sweep_points; i++)
 800887c:	2900      	cmp	r1, #0
 800887e:	f000 80c0 	beq.w	8008a02 <Thread1+0x8f2>
            float min_v = 0.0f, max_v = 0.0f;
 8008882:	ed9f babc 	vldr	s22, [pc, #752]	@ 8008b74 <Thread1+0xa64>
            for (int i = 0; i < sweep_points; i++)
 8008886:	950f      	str	r5, [sp, #60]	@ 0x3c
            bool first = true;
 8008888:	46a8      	mov	r8, r5
            float min_v = 0.0f, max_v = 0.0f;
 800888a:	eef0 ba4b 	vmov.f32	s23, s22
            for (int i = 0; i < sweep_points; i++)
 800888e:	2600      	movs	r6, #0
 8008890:	4615      	mov	r5, r2
 8008892:	e014      	b.n	80088be <Thread1+0x7ae>
                if (v < min_v)
 8008894:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (v > max_v)
 8008898:	eef4 bac8 	vcmpe.f32	s23, s16
                if (v < min_v)
 800889c:	bf88      	it	hi
 800889e:	eeb0 ba48 	vmovhi.f32	s22, s16
                if (v > max_v)
 80088a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80088a6:	bfb8      	it	lt
 80088a8:	eef0 ba48 	vmovlt.f32	s23, s16
            for (int i = 0; i < sweep_points; i++)
 80088ac:	f8b9 201a 	ldrh.w	r2, [r9, #26]
 80088b0:	3601      	adds	r6, #1
 80088b2:	42b2      	cmp	r2, r6
 80088b4:	f04f 0800 	mov.w	r8, #0
 80088b8:	f107 0708 	add.w	r7, r7, #8
 80088bc:	dd17      	ble.n	80088ee <Thread1+0x7de>
              float v = cb(i, array[i]);
 80088be:	4639      	mov	r1, r7
 80088c0:	4630      	mov	r0, r6
 80088c2:	47a8      	blx	r5
 80088c4:	eeb0 cac0 	vabs.f32	s24, s0
 80088c8:	eeb0 8a40 	vmov.f32	s16, s0
              if (vna_fabsf(v) == infinityf())
 80088cc:	f009 fdee 	bl	80124ac <infinityf>
 80088d0:	eeb4 0a4c 	vcmp.f32	s0, s24
 80088d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (v < min_v)
 80088d8:	eeb4 bac8 	vcmpe.f32	s22, s16
              if (vna_fabsf(v) == infinityf())
 80088dc:	d007      	beq.n	80088ee <Thread1+0x7de>
              if (first)
 80088de:	f1b8 0f00 	cmp.w	r8, #0
 80088e2:	d0d7      	beq.n	8008894 <Thread1+0x784>
                min_v = max_v = v;
 80088e4:	eef0 ba48 	vmov.f32	s23, s16
 80088e8:	eeb0 ba48 	vmov.f32	s22, s16
 80088ec:	e7de      	b.n	80088ac <Thread1+0x79c>
            float span = max_v - min_v;
 80088ee:	ee3b 0acb 	vsub.f32	s0, s23, s22
            if (span < 1e-6f)
 80088f2:	eddf 7aa1 	vldr	s15, [pc, #644]	@ 8008b78 <Thread1+0xa68>
            float span = max_v - min_v;
 80088f6:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
            if (span < 1e-6f)
 80088f8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80088fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008900:	f100 8081 	bmi.w	8008a06 <Thread1+0x8f6>
            float scale = span / dy;
 8008904:	eddf 7a9d 	vldr	s15, [pc, #628]	@ 8008b7c <Thread1+0xa6c>
 8008908:	ee20 0a27 	vmul.f32	s0, s0, s15
            float refpos = y_max - (max_v / scale);
 800890c:	ee8b 8a80 	vdiv.f32	s16, s23, s0
            if (trace[t].scale <= 0.0f ||
 8008910:	edd9 7a0b 	vldr	s15, [r9, #44]	@ 0x2c
 8008914:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8008918:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            float refpos = y_max - (max_v / scale);
 800891c:	ee39 8ac8 	vsub.f32	s16, s19, s16
            if (trace[t].scale <= 0.0f ||
 8008920:	d90a      	bls.n	8008938 <Thread1+0x828>
                vna_fabsf(scale - trace[t].scale) > trace[t].scale * 0.03f)
 8008922:	ee27 7a8a 	vmul.f32	s14, s15, s20
 8008926:	ee70 7a67 	vsub.f32	s15, s0, s15
 800892a:	eef0 7ae7 	vabs.f32	s15, s15
            if (trace[t].scale <= 0.0f ||
 800892e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8008932:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008936:	d502      	bpl.n	800893e <Thread1+0x82e>
              set_trace_scale(t, scale);
 8008938:	2000      	movs	r0, #0
 800893a:	f7ff fb91 	bl	8008060 <set_trace_scale>
            if (vna_fabsf(refpos - trace[t].refpos) > 0.02f)
 800893e:	edd9 7a0c 	vldr	s15, [r9, #48]	@ 0x30
 8008942:	ee78 7a67 	vsub.f32	s15, s16, s15
 8008946:	eef0 7ae7 	vabs.f32	s15, s15
 800894a:	eef4 7ac9 	vcmpe.f32	s15, s18
 800894e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008952:	f77f ae19 	ble.w	8008588 <Thread1+0x478>
              set_trace_refpos(t, refpos);
 8008956:	eeb0 0a48 	vmov.f32	s0, s16
 800895a:	2000      	movs	r0, #0
 800895c:	f7ff fb94 	bl	8008088 <set_trace_refpos>
 8008960:	e612      	b.n	8008588 <Thread1+0x478>
            float span = max_p - min_p;
 8008962:	ee3b 0acc 	vsub.f32	s0, s23, s24
            if (span < 1e-6f)
 8008966:	eddf 7a84 	vldr	s15, [pc, #528]	@ 8008b78 <Thread1+0xa68>
 800896a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800896e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008972:	d44b      	bmi.n	8008a0c <Thread1+0x8fc>
            float scale = span / dy;
 8008974:	eddf 7a82 	vldr	s15, [pc, #520]	@ 8008b80 <Thread1+0xa70>
 8008978:	ee20 0a27 	vmul.f32	s0, s0, s15
            float refpos = y_max - (max_p / scale);
 800897c:	ee8b 8a80 	vdiv.f32	s16, s23, s0
            if (trace[t].scale <= 0.0f ||
 8008980:	edd9 7a14 	vldr	s15, [r9, #80]	@ 0x50
 8008984:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8008988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            float refpos = y_max - (max_p / scale);
 800898c:	ee39 8ac8 	vsub.f32	s16, s19, s16
            if (trace[t].scale <= 0.0f ||
 8008990:	d90a      	bls.n	80089a8 <Thread1+0x898>
                vna_fabsf(scale - trace[t].scale) > trace[t].scale * 0.03f)
 8008992:	ee27 7a8a 	vmul.f32	s14, s15, s20
 8008996:	ee70 7a67 	vsub.f32	s15, s0, s15
 800899a:	eef0 7ae7 	vabs.f32	s15, s15
            if (trace[t].scale <= 0.0f ||
 800899e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80089a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80089a6:	d502      	bpl.n	80089ae <Thread1+0x89e>
              set_trace_scale(t, scale);
 80089a8:	2003      	movs	r0, #3
 80089aa:	f7ff fb59 	bl	8008060 <set_trace_scale>
            if (vna_fabsf(refpos - trace[t].refpos) > 0.02f)
 80089ae:	edd9 7a15 	vldr	s15, [r9, #84]	@ 0x54
 80089b2:	ee78 7a67 	vsub.f32	s15, s16, s15
 80089b6:	eef0 7ae7 	vabs.f32	s15, s15
 80089ba:	eef4 7ac9 	vcmpe.f32	s15, s18
 80089be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80089c2:	f77f adee 	ble.w	80085a2 <Thread1+0x492>
              set_trace_refpos(t, refpos);
 80089c6:	eeb0 0a48 	vmov.f32	s0, s16
 80089ca:	2003      	movs	r0, #3
 80089cc:	f7ff fb5c 	bl	8008088 <set_trace_refpos>
 80089d0:	e5e7      	b.n	80085a2 <Thread1+0x492>
    MLA_UART_LOG("[MLA] Resonance SWR: invalid resonance index (%d)\r\n", (int)mla_res_idx);
 80089d2:	486c      	ldr	r0, [pc, #432]	@ (8008b84 <Thread1+0xa74>)
 80089d4:	4631      	mov	r1, r6
 80089d6:	f7fc ffc1 	bl	800595c <serial_shell_printf>
    return 0.0f;
 80089da:	ed9f 8a66 	vldr	s16, [pc, #408]	@ 8008b74 <Thread1+0xa64>
 80089de:	e585      	b.n	80084ec <Thread1+0x3dc>
    rating = "EXCELLENT";
 80089e0:	4e69      	ldr	r6, [pc, #420]	@ (8008b88 <Thread1+0xa78>)
 80089e2:	e5b3      	b.n	800854c <Thread1+0x43c>
    mla_res_idx = -1;
 80089e4:	4a69      	ldr	r2, [pc, #420]	@ (8008b8c <Thread1+0xa7c>)
    MLA_UART_LOG("[MLA] Resonance Freq: none\r\n");
 80089e6:	486a      	ldr	r0, [pc, #424]	@ (8008b90 <Thread1+0xa80>)
    mla_res_idx = -1;
 80089e8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80089ec:	8013      	strh	r3, [r2, #0]
    mla_res_freq = 0;
 80089ee:	4a69      	ldr	r2, [pc, #420]	@ (8008b94 <Thread1+0xa84>)
 80089f0:	2300      	movs	r3, #0
 80089f2:	6013      	str	r3, [r2, #0]
    MLA_UART_LOG("[MLA] Resonance Freq: none\r\n");
 80089f4:	f7fc ffb2 	bl	800595c <serial_shell_printf>
 80089f8:	e54c      	b.n	8008494 <Thread1+0x384>
    MLA_UART_LOG("[MLA] Resonance SWR: invalid (%.2f) at idx=%d\r\n",
 80089fa:	4867      	ldr	r0, [pc, #412]	@ (8008b98 <Thread1+0xa88>)
 80089fc:	f7fc ffae 	bl	800595c <serial_shell_printf>
    return 0.0f;
 8008a00:	e7eb      	b.n	80089da <Thread1+0x8ca>
            float min_v = 0.0f, max_v = 0.0f;
 8008a02:	eddf ba5c 	vldr	s23, [pc, #368]	@ 8008b74 <Thread1+0xa64>
 8008a06:	ed9f 0a65 	vldr	s0, [pc, #404]	@ 8008b9c <Thread1+0xa8c>
 8008a0a:	e77f      	b.n	800890c <Thread1+0x7fc>
            float min_p = 0.0f, max_p = 0.0f;
 8008a0c:	eeb0 0a6a 	vmov.f32	s0, s21
 8008a10:	e7b4      	b.n	800897c <Thread1+0x86c>
    rating = "VERY GOOD";
 8008a12:	4e63      	ldr	r6, [pc, #396]	@ (8008ba0 <Thread1+0xa90>)
 8008a14:	e59a      	b.n	800854c <Thread1+0x43c>
              mla_no_dip_count++;
 8008a16:	3301      	adds	r3, #1
 8008a18:	b2db      	uxtb	r3, r3
 8008a1a:	4a62      	ldr	r2, [pc, #392]	@ (8008ba4 <Thread1+0xa94>)
            if (mla_no_dip_count >= MLA_NO_DIP_LIMIT)
 8008a1c:	2b02      	cmp	r3, #2
              mla_no_dip_count++;
 8008a1e:	7013      	strb	r3, [r2, #0]
            if (mla_no_dip_count >= MLA_NO_DIP_LIMIT)
 8008a20:	f47f ae9b 	bne.w	800875a <Thread1+0x64a>
 8008a24:	e695      	b.n	8008752 <Thread1+0x642>
    mla_has_good_resonance = false;
 8008a26:	4a60      	ldr	r2, [pc, #384]	@ (8008ba8 <Thread1+0xa98>)
    MLA_UART_LOG("[MLA][good_dip] invalid SWR at resonance -> NO CLEAR RESONANCE\r\n");
 8008a28:	4860      	ldr	r0, [pc, #384]	@ (8008bac <Thread1+0xa9c>)
    mla_has_good_resonance = false;
 8008a2a:	2300      	movs	r3, #0
 8008a2c:	7013      	strb	r3, [r2, #0]
    MLA_UART_LOG("[MLA][good_dip] invalid SWR at resonance -> NO CLEAR RESONANCE\r\n");
 8008a2e:	f7fc ff95 	bl	800595c <serial_shell_printf>
          if (mla_has_good_resonance)
 8008a32:	4b5d      	ldr	r3, [pc, #372]	@ (8008ba8 <Thread1+0xa98>)
 8008a34:	781b      	ldrb	r3, [r3, #0]
 8008a36:	2b00      	cmp	r3, #0
 8008a38:	f43f ae84 	beq.w	8008744 <Thread1+0x634>
            mla_no_dip_count = 0;
 8008a3c:	4a59      	ldr	r2, [pc, #356]	@ (8008ba4 <Thread1+0xa94>)
 8008a3e:	2300      	movs	r3, #0
 8008a40:	7013      	strb	r3, [r2, #0]
            uint32_t f = mla_res_freq;
 8008a42:	4b54      	ldr	r3, [pc, #336]	@ (8008b94 <Thread1+0xa84>)
 8008a44:	681e      	ldr	r6, [r3, #0]
            ui_hide_no_resonance_hint();
 8008a46:	f007 fd57 	bl	80104f8 <ui_hide_no_resonance_hint>
            if (mla_res_stable_count == 0)
 8008a4a:	4a59      	ldr	r2, [pc, #356]	@ (8008bb0 <Thread1+0xaa0>)
 8008a4c:	7813      	ldrb	r3, [r2, #0]
 8008a4e:	2b00      	cmp	r3, #0
 8008a50:	f040 810d 	bne.w	8008c6e <Thread1+0xb5e>
              mla_res_ref_freq = f;
 8008a54:	4b57      	ldr	r3, [pc, #348]	@ (8008bb4 <Thread1+0xaa4>)
 8008a56:	601e      	str	r6, [r3, #0]
              mla_res_stable_count = 1;
 8008a58:	2301      	movs	r3, #1
 8008a5a:	7013      	strb	r3, [r2, #0]
 8008a5c:	e67d      	b.n	800875a <Thread1+0x64a>
  if (mla_autozone_stage == 2)
 8008a5e:	f000 81f5 	beq.w	8008e4c <Thread1+0xd3c>
  if (sweep_points < 3)
 8008a62:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 8008a66:	2b02      	cmp	r3, #2
 8008a68:	f67f ad83 	bls.w	8008572 <Thread1+0x462>
  uint16_t i_end = sweep_points - 2; // skip last index (edge)
 8008a6c:	3b02      	subs	r3, #2
 8008a6e:	2201      	movs	r2, #1
 8008a70:	fa1f fc83 	uxth.w	ip, r3
  float best_mag2 = 1e30f;
 8008a74:	ed9f 8a50 	vldr	s16, [pc, #320]	@ 8008bb8 <Thread1+0xaa8>
 8008a78:	4b3d      	ldr	r3, [pc, #244]	@ (8008b70 <Thread1+0xa60>)
  uint16_t best_idx = i_start;
 8008a7a:	4616      	mov	r6, r2
  bool found = false;
 8008a7c:	2000      	movs	r0, #0
 8008a7e:	4611      	mov	r1, r2
 8008a80:	e00d      	b.n	8008a9e <Thread1+0x98e>
      best_mag2 = mag2;
 8008a82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008a86:	bf44      	itt	mi
 8008a88:	4628      	movmi	r0, r5
 8008a8a:	460e      	movmi	r6, r1
 8008a8c:	bf48      	it	mi
 8008a8e:	eeb0 8a67 	vmovmi.f32	s16, s15
  for (uint16_t i = i_start; i <= i_end; i++)
 8008a92:	3201      	adds	r2, #1
 8008a94:	b291      	uxth	r1, r2
 8008a96:	4561      	cmp	r1, ip
 8008a98:	f103 0308 	add.w	r3, r3, #8
 8008a9c:	d81a      	bhi.n	8008ad4 <Thread1+0x9c4>
    float im = measured[0][i][1];
 8008a9e:	edd3 7a03 	vldr	s15, [r3, #12]
    float re = measured[0][i][0];
 8008aa2:	ed93 7a02 	vldr	s14, [r3, #8]
    float mag2 = re * re + im * im;
 8008aa6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8008aaa:	eee7 7a07 	vfma.f32	s15, s14, s14
    if (mag2 == 0.0f)
 8008aae:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008ab2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008ab6:	d0ec      	beq.n	8008a92 <Thread1+0x982>
      best_mag2 = mag2;
 8008ab8:	eef4 7ac8 	vcmpe.f32	s15, s16
    if (!found || mag2 < best_mag2)
 8008abc:	2800      	cmp	r0, #0
 8008abe:	d1e0      	bne.n	8008a82 <Thread1+0x972>
  for (uint16_t i = i_start; i <= i_end; i++)
 8008ac0:	3201      	adds	r2, #1
      best_idx = i;
 8008ac2:	460e      	mov	r6, r1
  for (uint16_t i = i_start; i <= i_end; i++)
 8008ac4:	b291      	uxth	r1, r2
 8008ac6:	4561      	cmp	r1, ip
      best_mag2 = mag2;
 8008ac8:	eeb0 8a67 	vmov.f32	s16, s15
      found = true;
 8008acc:	4628      	mov	r0, r5
  for (uint16_t i = i_start; i <= i_end; i++)
 8008ace:	f103 0308 	add.w	r3, r3, #8
 8008ad2:	d9e4      	bls.n	8008a9e <Thread1+0x98e>
  if (!found)
 8008ad4:	2800      	cmp	r0, #0
 8008ad6:	f43f ad4c 	beq.w	8008572 <Thread1+0x462>
    *out_freq = getFrequency(best_idx);
 8008ada:	4630      	mov	r0, r6
 8008adc:	f7fe f892 	bl	8006c04 <getFrequency>
  mla_res_freq = f_res;
 8008ae0:	4b2c      	ldr	r3, [pc, #176]	@ (8008b94 <Thread1+0xa84>)
 8008ae2:	900f      	str	r0, [sp, #60]	@ 0x3c
 8008ae4:	6018      	str	r0, [r3, #0]
  mla_res_idx = idx;
 8008ae6:	4b29      	ldr	r3, [pc, #164]	@ (8008b8c <Thread1+0xa7c>)
  mla_resonance_locked = true;
 8008ae8:	4834      	ldr	r0, [pc, #208]	@ (8008bbc <Thread1+0xaac>)
  mla_res_idx = idx;
 8008aea:	801e      	strh	r6, [r3, #0]
  MLA_UART_LOG("[MLA] resonance result (stage %u):\r\n", mla_autozone_stage);
 8008aec:	4639      	mov	r1, r7
  mla_resonance_locked = true;
 8008aee:	2301      	movs	r3, #1
    case ST_STOP:   return frequency1;
 8008af0:	e9d9 8701 	ldrd	r8, r7, [r9, #4]
 8008af4:	7003      	strb	r3, [r0, #0]
  MLA_UART_LOG("[MLA] resonance result (stage %u):\r\n", mla_autozone_stage);
 8008af6:	4832      	ldr	r0, [pc, #200]	@ (8008bc0 <Thread1+0xab0>)
 8008af8:	f7fc ff30 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("  sweep_points = %u\r\n", sweep_points);
 8008afc:	f8b9 101a 	ldrh.w	r1, [r9, #26]
 8008b00:	4830      	ldr	r0, [pc, #192]	@ (8008bc4 <Thread1+0xab4>)
 8008b02:	f7fc ff2b 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("  f_start      = " VNA_FREQ_FMT_STR " Hz\r\n", cur_start);
 8008b06:	4641      	mov	r1, r8
 8008b08:	482f      	ldr	r0, [pc, #188]	@ (8008bc8 <Thread1+0xab8>)
 8008b0a:	f7fc ff27 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("  f_stop       = " VNA_FREQ_FMT_STR " Hz\r\n", cur_stop);
 8008b0e:	4639      	mov	r1, r7
 8008b10:	482e      	ldr	r0, [pc, #184]	@ (8008bcc <Thread1+0xabc>)
 8008b12:	f7fc ff23 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("  best_idx     = %u\r\n", idx);
 8008b16:	4631      	mov	r1, r6
 8008b18:	482d      	ldr	r0, [pc, #180]	@ (8008bd0 <Thread1+0xac0>)
 8008b1a:	f7fc ff1f 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("  f_res        = " VNA_FREQ_FMT_STR " Hz\r\n", f_res);
 8008b1e:	9f0f      	ldr	r7, [sp, #60]	@ 0x3c
 8008b20:	482c      	ldr	r0, [pc, #176]	@ (8008bd4 <Thread1+0xac4>)
 8008b22:	4639      	mov	r1, r7
 8008b24:	f7fc ff1a 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("  |S11|^2      = %f\r\n", mag2);
 8008b28:	ee18 0a10 	vmov	r0, s16
 8008b2c:	f7f7 fd38 	bl	80005a0 <__aeabi_f2d>
 8008b30:	4602      	mov	r2, r0
 8008b32:	460b      	mov	r3, r1
 8008b34:	4828      	ldr	r0, [pc, #160]	@ (8008bd8 <Thread1+0xac8>)
 8008b36:	f7fc ff11 	bl	800595c <serial_shell_printf>
  if (mla_autozone_stage == 0)
 8008b3a:	4b28      	ldr	r3, [pc, #160]	@ (8008bdc <Thread1+0xacc>)
 8008b3c:	781b      	ldrb	r3, [r3, #0]
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	f040 80c8 	bne.w	8008cd4 <Thread1+0xbc4>
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 8008b44:	4b26      	ldr	r3, [pc, #152]	@ (8008be0 <Thread1+0xad0>)
 8008b46:	429f      	cmp	r7, r3
 8008b48:	f240 8210 	bls.w	8008f6c <Thread1+0xe5c>
    if (stop > FREQUENCY_MAX)
 8008b4c:	4b25      	ldr	r3, [pc, #148]	@ (8008be4 <Thread1+0xad4>)
    freq_t stop = start + span;
 8008b4e:	f507 3674 	add.w	r6, r7, #249856	@ 0x3d000
 8008b52:	3690      	adds	r6, #144	@ 0x90
    if (stop > FREQUENCY_MAX)
 8008b54:	429e      	cmp	r6, r3
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 8008b56:	f5a7 3774 	sub.w	r7, r7, #249856	@ 0x3d000
    if (stop > FREQUENCY_MAX)
 8008b5a:	bf28      	it	cs
 8008b5c:	461e      	movcs	r6, r3
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 8008b5e:	3f90      	subs	r7, #144	@ 0x90
    if (start >= stop)
 8008b60:	42b7      	cmp	r7, r6
 8008b62:	f4bf ad06 	bcs.w	8008572 <Thread1+0x462>
 8008b66:	e204      	b.n	8008f72 <Thread1+0xe62>
    MLA_UART_LOG("[MLA] Q rating: N/A\r\n");
 8008b68:	481f      	ldr	r0, [pc, #124]	@ (8008be8 <Thread1+0xad8>)
 8008b6a:	f7fc fef7 	bl	800595c <serial_shell_printf>
    return "N/A";
 8008b6e:	e4f7      	b.n	8008560 <Thread1+0x450>
 8008b70:	20004f54 	.word	0x20004f54
 8008b74:	00000000 	.word	0x00000000
 8008b78:	358637bd 	.word	0x358637bd
 8008b7c:	3e11745d 	.word	0x3e11745d
 8008b80:	3e169697 	.word	0x3e169697
 8008b84:	0801325c 	.word	0x0801325c
 8008b88:	0801317c 	.word	0x0801317c
 8008b8c:	200003d4 	.word	0x200003d4
 8008b90:	0801323c 	.word	0x0801323c
 8008b94:	20006884 	.word	0x20006884
 8008b98:	08013290 	.word	0x08013290
 8008b9c:	3e91745d 	.word	0x3e91745d
 8008ba0:	08013188 	.word	0x08013188
 8008ba4:	20006876 	.word	0x20006876
 8008ba8:	2000687e 	.word	0x2000687e
 8008bac:	08013368 	.word	0x08013368
 8008bb0:	2000687c 	.word	0x2000687c
 8008bb4:	20006878 	.word	0x20006878
 8008bb8:	7149f2ca 	.word	0x7149f2ca
 8008bbc:	2000687d 	.word	0x2000687d
 8008bc0:	08013568 	.word	0x08013568
 8008bc4:	08013590 	.word	0x08013590
 8008bc8:	080135a8 	.word	0x080135a8
 8008bcc:	080135c4 	.word	0x080135c4
 8008bd0:	080135e0 	.word	0x080135e0
 8008bd4:	080135f8 	.word	0x080135f8
 8008bd8:	08013614 	.word	0x08013614
 8008bdc:	20006875 	.word	0x20006875
 8008be0:	0003d090 	.word	0x0003d090
 8008be4:	a0eebb00 	.word	0xa0eebb00
 8008be8:	080132e8 	.word	0x080132e8
        if (digitIdx >= 0 && digitIdx < 8)
 8008bec:	2d07      	cmp	r5, #7
 8008bee:	f73f ab4a 	bgt.w	8008286 <Thread1+0x176>
          return dir * stepHz[digitIdx];
 8008bf2:	4b84      	ldr	r3, [pc, #528]	@ (8008e04 <Thread1+0xcf4>)
 8008bf4:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
 8008bf8:	fb06 f505 	mul.w	r5, r6, r5
          if (dHz != 0)
 8008bfc:	2d00      	cmp	r5, #0
 8008bfe:	f43f ab42 	beq.w	8008286 <Thread1+0x176>
            int64_t nf = (int64_t)target_frequency + dHz;
 8008c02:	4b81      	ldr	r3, [pc, #516]	@ (8008e08 <Thread1+0xcf8>)
            if (nf > 160000000)
 8008c04:	4881      	ldr	r0, [pc, #516]	@ (8008e0c <Thread1+0xcfc>)
            int64_t nf = (int64_t)target_frequency + dHz;
 8008c06:	6819      	ldr	r1, [r3, #0]
 8008c08:	17eb      	asrs	r3, r5, #31
 8008c0a:	1949      	adds	r1, r1, r5
 8008c0c:	f143 0300 	adc.w	r3, r3, #0
 8008c10:	2200      	movs	r2, #0
            if (nf > 160000000)
 8008c12:	4288      	cmp	r0, r1
 8008c14:	eb72 0603 	sbcs.w	r6, r2, r3
 8008c18:	bfbc      	itt	lt
 8008c1a:	4601      	movlt	r1, r0
 8008c1c:	4613      	movlt	r3, r2
            if (nf < 8000)
 8008c1e:	f5b1 5ffa 	cmp.w	r1, #8000	@ 0x1f40
 8008c22:	f173 0300 	sbcs.w	r3, r3, #0
            target_frequency = (uint32_t)nf;
 8008c26:	4b78      	ldr	r3, [pc, #480]	@ (8008e08 <Thread1+0xcf8>)
 8008c28:	461e      	mov	r6, r3
            if (nf < 8000)
 8008c2a:	bfb8      	it	lt
 8008c2c:	f44f 51fa 	movlt.w	r1, #8000	@ 0x1f40
            set_sweep_frequency(ST_START, target_frequency);
 8008c30:	2000      	movs	r0, #0
            target_frequency = (uint32_t)nf;
 8008c32:	6019      	str	r1, [r3, #0]
            set_sweep_frequency(ST_START, target_frequency);
 8008c34:	f7fe ff4e 	bl	8007ad4 <set_sweep_frequency>
            set_sweep_frequency(ST_STOP, target_frequency);
 8008c38:	6831      	ldr	r1, [r6, #0]
 8008c3a:	2001      	movs	r0, #1
 8008c3c:	f7fe ff4a 	bl	8007ad4 <set_sweep_frequency>
            MLA_UART_LOG("NEW FREQ = %lu (dHz=%ld)\r\n",
 8008c40:	6831      	ldr	r1, [r6, #0]
 8008c42:	4873      	ldr	r0, [pc, #460]	@ (8008e10 <Thread1+0xd00>)
 8008c44:	462a      	mov	r2, r5
 8008c46:	f7fc fe89 	bl	800595c <serial_shell_printf>
 8008c4a:	f7ff bb1c 	b.w	8008286 <Thread1+0x176>
            ui_show_check_amtenna_hint();
 8008c4e:	f007 fc29 	bl	80104a4 <ui_show_check_amtenna_hint>
  if (sweep_points < 3)
 8008c52:	f8b9 701a 	ldrh.w	r7, [r9, #26]
 8008c56:	2f02      	cmp	r7, #2
 8008c58:	f63f acee 	bhi.w	8008638 <Thread1+0x528>
    mla_has_good_resonance = false;
 8008c5c:	4a6d      	ldr	r2, [pc, #436]	@ (8008e14 <Thread1+0xd04>)
    MLA_UART_LOG("[MLA][good_dip] no resonance found (getResonanceHB9IIU failed)\r\n");
 8008c5e:	486e      	ldr	r0, [pc, #440]	@ (8008e18 <Thread1+0xd08>)
    mla_has_good_resonance = false;
 8008c60:	2300      	movs	r3, #0
 8008c62:	7013      	strb	r3, [r2, #0]
    MLA_UART_LOG("[MLA][good_dip] no resonance found (getResonanceHB9IIU failed)\r\n");
 8008c64:	f7fc fe7a 	bl	800595c <serial_shell_printf>
    return;
 8008c68:	e567      	b.n	800873a <Thread1+0x62a>
    rating = "GOOD";
 8008c6a:	4e6c      	ldr	r6, [pc, #432]	@ (8008e1c <Thread1+0xd0c>)
 8008c6c:	e46e      	b.n	800854c <Thread1+0x43c>
                  (f > mla_res_ref_freq) ? (f - mla_res_ref_freq) : (mla_res_ref_freq - f);
 8008c6e:	4a6c      	ldr	r2, [pc, #432]	@ (8008e20 <Thread1+0xd10>)
 8008c70:	6812      	ldr	r2, [r2, #0]
 8008c72:	42b2      	cmp	r2, r6
 8008c74:	bf34      	ite	cc
 8008c76:	1ab0      	subcc	r0, r6, r2
 8008c78:	1b90      	subcs	r0, r2, r6
              if (delta <= MLA_RESONANCE_STABILITY_HZ)
 8008c7a:	f644 6120 	movw	r1, #20000	@ 0x4e20
 8008c7e:	4288      	cmp	r0, r1
 8008c80:	d814      	bhi.n	8008cac <Thread1+0xb9c>
                if (mla_res_stable_count < MLA_STABLE_SWEEPS_REQUIRED)
 8008c82:	2b02      	cmp	r3, #2
 8008c84:	d806      	bhi.n	8008c94 <Thread1+0xb84>
                  mla_res_stable_count++;
 8008c86:	3301      	adds	r3, #1
 8008c88:	b2db      	uxtb	r3, r3
 8008c8a:	4966      	ldr	r1, [pc, #408]	@ (8008e24 <Thread1+0xd14>)
            if (mla_res_stable_count >= MLA_STABLE_SWEEPS_REQUIRED)
 8008c8c:	2b03      	cmp	r3, #3
                  mla_res_stable_count++;
 8008c8e:	700b      	strb	r3, [r1, #0]
            if (mla_res_stable_count >= MLA_STABLE_SWEEPS_REQUIRED)
 8008c90:	f47f ad63 	bne.w	800875a <Thread1+0x64a>
              mla_res_freq = mla_res_ref_freq;
 8008c94:	4b64      	ldr	r3, [pc, #400]	@ (8008e28 <Thread1+0xd18>)
 8008c96:	601a      	str	r2, [r3, #0]
              mla_resonance_locked = true;
 8008c98:	4a64      	ldr	r2, [pc, #400]	@ (8008e2c <Thread1+0xd1c>)
 8008c9a:	2301      	movs	r3, #1
 8008c9c:	7013      	strb	r3, [r2, #0]
              ui_hide_check_amtenna_hint();
 8008c9e:	f007 fbe9 	bl	8010474 <ui_hide_check_amtenna_hint>
              ui_hide_no_resonance_hint();
 8008ca2:	f007 fc29 	bl	80104f8 <ui_hide_no_resonance_hint>
 8008ca6:	e558      	b.n	800875a <Thread1+0x64a>
    rating = "POOR";
 8008ca8:	4e61      	ldr	r6, [pc, #388]	@ (8008e30 <Thread1+0xd20>)
 8008caa:	e44f      	b.n	800854c <Thread1+0x43c>
                mla_res_ref_freq = f;
 8008cac:	4b5c      	ldr	r3, [pc, #368]	@ (8008e20 <Thread1+0xd10>)
                mla_res_stable_count = 1;
 8008cae:	4a5d      	ldr	r2, [pc, #372]	@ (8008e24 <Thread1+0xd14>)
                mla_res_ref_freq = f;
 8008cb0:	601e      	str	r6, [r3, #0]
                mla_res_stable_count = 1;
 8008cb2:	2301      	movs	r3, #1
 8008cb4:	7013      	strb	r3, [r2, #0]
 8008cb6:	e550      	b.n	800875a <Thread1+0x64a>
    mla_has_good_resonance = true;
 8008cb8:	4a56      	ldr	r2, [pc, #344]	@ (8008e14 <Thread1+0xd04>)
    MLA_UART_LOG("[MLA][good_dip] GOOD DIP DETECTED\r\n");
 8008cba:	485e      	ldr	r0, [pc, #376]	@ (8008e34 <Thread1+0xd24>)
    mla_has_good_resonance = true;
 8008cbc:	2301      	movs	r3, #1
 8008cbe:	7013      	strb	r3, [r2, #0]
    MLA_UART_LOG("[MLA][good_dip] GOOD DIP DETECTED\r\n");
 8008cc0:	f7fc fe4c 	bl	800595c <serial_shell_printf>
 8008cc4:	e539      	b.n	800873a <Thread1+0x62a>
    mla_has_good_resonance = false;
 8008cc6:	4a53      	ldr	r2, [pc, #332]	@ (8008e14 <Thread1+0xd04>)
    MLA_UART_LOG("[MLA][good_dip] flat SWR curve -> NO CLEAR RESONANCE\r\n");
 8008cc8:	485b      	ldr	r0, [pc, #364]	@ (8008e38 <Thread1+0xd28>)
    mla_has_good_resonance = false;
 8008cca:	2300      	movs	r3, #0
 8008ccc:	7013      	strb	r3, [r2, #0]
    MLA_UART_LOG("[MLA][good_dip] flat SWR curve -> NO CLEAR RESONANCE\r\n");
 8008cce:	f7fc fe45 	bl	800595c <serial_shell_printf>
    return;
 8008cd2:	e532      	b.n	800873a <Thread1+0x62a>
  if (mla_autozone_stage == 1)
 8008cd4:	2b01      	cmp	r3, #1
 8008cd6:	f47f ac4c 	bne.w	8008572 <Thread1+0x462>
      if (swr > swr_limit)
 8008cda:	eeb0 6a08 	vmov.f32	s12, #8	@ 0x40400000  3.0
    uint16_t left = idx;
 8008cde:	4632      	mov	r2, r6
 8008ce0:	e007      	b.n	8008cf2 <Thread1+0xbe2>
      float swr = getSWRfromIndex(left - 1);
 8008ce2:	f7fc fbe5 	bl	80054b0 <getSWRfromIndex>
      if (swr > swr_limit)
 8008ce6:	eeb4 0ac6 	vcmpe.f32	s0, s12
 8008cea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008cee:	dc05      	bgt.n	8008cfc <Thread1+0xbec>
      left--;
 8008cf0:	460a      	mov	r2, r1
      float swr = getSWRfromIndex(left - 1);
 8008cf2:	1e51      	subs	r1, r2, #1
 8008cf4:	b289      	uxth	r1, r1
 8008cf6:	4608      	mov	r0, r1
    while (left > 0)
 8008cf8:	2a00      	cmp	r2, #0
 8008cfa:	d1f2      	bne.n	8008ce2 <Thread1+0xbd2>
    while (right + 1 < sweep_points)
 8008cfc:	f8b9 101a 	ldrh.w	r1, [r9, #26]
    *out_idx = best_idx;
 8008d00:	9210      	str	r2, [sp, #64]	@ 0x40
      if (swr > swr_limit)
 8008d02:	eeb0 6a08 	vmov.f32	s12, #8	@ 0x40400000  3.0
    *out_idx = best_idx;
 8008d06:	4637      	mov	r7, r6
 8008d08:	e008      	b.n	8008d1c <Thread1+0xc0c>
      float swr = getSWRfromIndex(right + 1);
 8008d0a:	f7fc fbd1 	bl	80054b0 <getSWRfromIndex>
      if (swr > swr_limit)
 8008d0e:	eeb4 0ac6 	vcmpe.f32	s0, s12
 8008d12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008d16:	f300 8141 	bgt.w	8008f9c <Thread1+0xe8c>
      right++;
 8008d1a:	4617      	mov	r7, r2
    while (right + 1 < sweep_points)
 8008d1c:	f107 0801 	add.w	r8, r7, #1
      float swr = getSWRfromIndex(right + 1);
 8008d20:	fa1f f288 	uxth.w	r2, r8
    while (right + 1 < sweep_points)
 8008d24:	4588      	cmp	r8, r1
      float swr = getSWRfromIndex(right + 1);
 8008d26:	4610      	mov	r0, r2
    while (right + 1 < sweep_points)
 8008d28:	dbef      	blt.n	8008d0a <Thread1+0xbfa>
    if (left > 0)
 8008d2a:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8008d2c:	4643      	mov	r3, r8
 8008d2e:	2a00      	cmp	r2, #0
 8008d30:	f040 8137 	bne.w	8008fa2 <Thread1+0xe92>
    int left_span = (int)idx - (int)left;
 8008d34:	1ab3      	subs	r3, r6, r2
    int right_span = (int)right - (int)idx;
 8008d36:	1bbf      	subs	r7, r7, r6
    int half_span = (left_span > right_span) ? left_span : right_span;
 8008d38:	42bb      	cmp	r3, r7
 8008d3a:	bfb8      	it	lt
 8008d3c:	463b      	movlt	r3, r7
    int sym_right = (int)idx + half_span;
 8008d3e:	eb06 0803 	add.w	r8, r6, r3
    if (sym_right >= (int)sweep_points)
 8008d42:	4541      	cmp	r1, r8
    int sym_left = (int)idx - half_span;
 8008d44:	eba6 0203 	sub.w	r2, r6, r3
    if (sym_left < 0)
 8008d48:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
      sym_right = (int)sweep_points - 1;
 8008d4c:	bfd8      	it	le
 8008d4e:	f101 38ff 	addle.w	r8, r1, #4294967295
    if (sym_left >= sym_right)
 8008d52:	4542      	cmp	r2, r8
 8008d54:	f6bf ac0d 	bge.w	8008572 <Thread1+0x462>
    freq_t start = getFrequency((uint16_t)sym_left);
 8008d58:	b293      	uxth	r3, r2
 8008d5a:	4618      	mov	r0, r3
 8008d5c:	9213      	str	r2, [sp, #76]	@ 0x4c
 8008d5e:	9311      	str	r3, [sp, #68]	@ 0x44
 8008d60:	f7fd ff50 	bl	8006c04 <getFrequency>
    freq_t stop = getFrequency((uint16_t)sym_right);
 8008d64:	fa1f f388 	uxth.w	r3, r8
    freq_t start = getFrequency((uint16_t)sym_left);
 8008d68:	4607      	mov	r7, r0
    freq_t stop = getFrequency((uint16_t)sym_right);
 8008d6a:	4618      	mov	r0, r3
 8008d6c:	9312      	str	r3, [sp, #72]	@ 0x48
 8008d6e:	f7fd ff49 	bl	8006c04 <getFrequency>
    if (stop > FREQUENCY_MAX)
 8008d72:	4932      	ldr	r1, [pc, #200]	@ (8008e3c <Thread1+0xd2c>)
    if (start < FREQUENCY_MIN)
 8008d74:	f5b7 7f16 	cmp.w	r7, #600	@ 0x258
 8008d78:	bf38      	it	cc
 8008d7a:	f44f 7716 	movcc.w	r7, #600	@ 0x258
    if (stop > FREQUENCY_MAX)
 8008d7e:	4288      	cmp	r0, r1
 8008d80:	bf28      	it	cs
 8008d82:	4608      	movcs	r0, r1
    if (start >= stop)
 8008d84:	4287      	cmp	r7, r0
    if (stop > FREQUENCY_MAX)
 8008d86:	9010      	str	r0, [sp, #64]	@ 0x40
    if (start >= stop)
 8008d88:	f4bf abf3 	bcs.w	8008572 <Thread1+0x462>
    float swr_center = getSWRfromIndex(idx);
 8008d8c:	4630      	mov	r0, r6
 8008d8e:	f7fc fb8f 	bl	80054b0 <getSWRfromIndex>
    float swr_left = getSWRfromIndex((uint16_t)sym_left);
 8008d92:	9811      	ldr	r0, [sp, #68]	@ 0x44
    float swr_center = getSWRfromIndex(idx);
 8008d94:	ed8d 0a11 	vstr	s0, [sp, #68]	@ 0x44
    float swr_left = getSWRfromIndex((uint16_t)sym_left);
 8008d98:	f7fc fb8a 	bl	80054b0 <getSWRfromIndex>
    float swr_right = getSWRfromIndex((uint16_t)sym_right);
 8008d9c:	9812      	ldr	r0, [sp, #72]	@ 0x48
    float swr_left = getSWRfromIndex((uint16_t)sym_left);
 8008d9e:	ed8d 0a12 	vstr	s0, [sp, #72]	@ 0x48
    float swr_right = getSWRfromIndex((uint16_t)sym_right);
 8008da2:	f7fc fb85 	bl	80054b0 <getSWRfromIndex>
    MLA_UART_LOG(
 8008da6:	9b10      	ldr	r3, [sp, #64]	@ 0x40
    float swr_right = getSWRfromIndex((uint16_t)sym_right);
 8008da8:	ee10 0a10 	vmov	r0, s0
    MLA_UART_LOG(
 8008dac:	e9cd 730c 	strd	r7, r3, [sp, #48]	@ 0x30
 8008db0:	f7f7 fbf6 	bl	80005a0 <__aeabi_f2d>
 8008db4:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 8008db6:	9309      	str	r3, [sp, #36]	@ 0x24
 8008db8:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 8008dbc:	9811      	ldr	r0, [sp, #68]	@ 0x44
 8008dbe:	f8cd 8020 	str.w	r8, [sp, #32]
 8008dc2:	f7f7 fbed 	bl	80005a0 <__aeabi_f2d>
 8008dc6:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 8008dc8:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8008dcc:	9812      	ldr	r0, [sp, #72]	@ 0x48
 8008dce:	e9cd 6204 	strd	r6, r2, [sp, #16]
 8008dd2:	f7f7 fbe5 	bl	80005a0 <__aeabi_f2d>
 8008dd6:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8008dd8:	4b19      	ldr	r3, [pc, #100]	@ (8008e40 <Thread1+0xd30>)
 8008dda:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8008dde:	e9cd 2700 	strd	r2, r7, [sp]
 8008de2:	4818      	ldr	r0, [pc, #96]	@ (8008e44 <Thread1+0xd34>)
 8008de4:	2200      	movs	r2, #0
 8008de6:	f7fc fdb9 	bl	800595c <serial_shell_printf>
    set_sweep_frequency(ST_START, start);
 8008dea:	4639      	mov	r1, r7
 8008dec:	2000      	movs	r0, #0
 8008dee:	f7fe fe71 	bl	8007ad4 <set_sweep_frequency>
    set_sweep_frequency(ST_STOP, stop);
 8008df2:	9910      	ldr	r1, [sp, #64]	@ 0x40
 8008df4:	2001      	movs	r0, #1
 8008df6:	f7fe fe6d 	bl	8007ad4 <set_sweep_frequency>
    mla_autozone_stage = 2;
 8008dfa:	4a13      	ldr	r2, [pc, #76]	@ (8008e48 <Thread1+0xd38>)
 8008dfc:	2302      	movs	r3, #2
 8008dfe:	7013      	strb	r3, [r2, #0]
    return;
 8008e00:	f7ff bbb7 	b.w	8008572 <Thread1+0x462>
 8008e04:	08015a78 	.word	0x08015a78
 8008e08:	200068f0 	.word	0x200068f0
 8008e0c:	09896800 	.word	0x09896800
 8008e10:	080137c0 	.word	0x080137c0
 8008e14:	2000687e 	.word	0x2000687e
 8008e18:	08013324 	.word	0x08013324
 8008e1c:	08013194 	.word	0x08013194
 8008e20:	20006878 	.word	0x20006878
 8008e24:	2000687c 	.word	0x2000687c
 8008e28:	20006884 	.word	0x20006884
 8008e2c:	2000687d 	.word	0x2000687d
 8008e30:	080131a4 	.word	0x080131a4
 8008e34:	0801340c 	.word	0x0801340c
 8008e38:	080133ac 	.word	0x080133ac
 8008e3c:	a0eebb00 	.word	0xa0eebb00
 8008e40:	40080000 	.word	0x40080000
 8008e44:	080136a8 	.word	0x080136a8
 8008e48:	20006875 	.word	0x20006875
    MLA_UART_LOG("[MLA] stage 2: applying AUTO SCALE on final sweep\r\n");
 8008e4c:	4899      	ldr	r0, [pc, #612]	@ (80090b4 <Thread1+0xfa4>)
 8008e4e:	f7fc fd85 	bl	800595c <serial_shell_printf>
    mla_update_bandwidth_swr2();
 8008e52:	f7fe fb2f 	bl	80074b4 <mla_update_bandwidth_swr2>
  mla_Q_factor = 0.0f;
 8008e56:	4a98      	ldr	r2, [pc, #608]	@ (80090b8 <Thread1+0xfa8>)
  strncpy(mla_band_name, "n/a", sizeof(mla_band_name));
 8008e58:	4998      	ldr	r1, [pc, #608]	@ (80090bc <Thread1+0xfac>)
 8008e5a:	4899      	ldr	r0, [pc, #612]	@ (80090c0 <Thread1+0xfb0>)
  mla_Q_factor = 0.0f;
 8008e5c:	2300      	movs	r3, #0
 8008e5e:	6013      	str	r3, [r2, #0]
  mla_bw_rel = 0.0f;
 8008e60:	4a98      	ldr	r2, [pc, #608]	@ (80090c4 <Thread1+0xfb4>)
 8008e62:	6013      	str	r3, [r2, #0]
  strncpy(mla_band_name, "n/a", sizeof(mla_band_name));
 8008e64:	220c      	movs	r2, #12
 8008e66:	f009 fcc5 	bl	80127f4 <strncpy>
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 8008e6a:	4a95      	ldr	r2, [pc, #596]	@ (80090c0 <Thread1+0xfb0>)
 8008e6c:	2300      	movs	r3, #0
 8008e6e:	72d3      	strb	r3, [r2, #11]
  if (!mla_resonance_locked || mla_res_freq == 0 || mla_bw_swr2 == 0)
 8008e70:	4b95      	ldr	r3, [pc, #596]	@ (80090c8 <Thread1+0xfb8>)
 8008e72:	781b      	ldrb	r3, [r3, #0]
 8008e74:	2b00      	cmp	r3, #0
 8008e76:	d06d      	beq.n	8008f54 <Thread1+0xe44>
 8008e78:	4b94      	ldr	r3, [pc, #592]	@ (80090cc <Thread1+0xfbc>)
 8008e7a:	681e      	ldr	r6, [r3, #0]
 8008e7c:	2e00      	cmp	r6, #0
 8008e7e:	d069      	beq.n	8008f54 <Thread1+0xe44>
 8008e80:	4b93      	ldr	r3, [pc, #588]	@ (80090d0 <Thread1+0xfc0>)
 8008e82:	f8d3 8000 	ldr.w	r8, [r3]
 8008e86:	f1b8 0f00 	cmp.w	r8, #0
 8008e8a:	d063      	beq.n	8008f54 <Thread1+0xe44>
  float bw = (float)bw_hz;
 8008e8c:	ee07 8a90 	vmov	s15, r8
 8008e90:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  mla_Q_factor = f0 / bw;
 8008e94:	ee07 6a90 	vmov	s15, r6
 8008e98:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008e9c:	4b86      	ldr	r3, [pc, #536]	@ (80090b8 <Thread1+0xfa8>)
  if (f0_hz >= 1800000 && f0_hz <= 2000000)
 8008e9e:	4a8d      	ldr	r2, [pc, #564]	@ (80090d4 <Thread1+0xfc4>)
  mla_Q_factor = f0 / bw;
 8008ea0:	ee87 6a87 	vdiv.f32	s12, s15, s14
  mla_bw_rel = bw / f0; // dimensionless (~ 1/Q)
 8008ea4:	eec7 6a27 	vdiv.f32	s13, s14, s15
  mla_Q_factor = f0 / bw;
 8008ea8:	ed83 6a00 	vstr	s12, [r3]
  mla_bw_rel = bw / f0; // dimensionless (~ 1/Q)
 8008eac:	4b85      	ldr	r3, [pc, #532]	@ (80090c4 <Thread1+0xfb4>)
 8008eae:	edc3 6a00 	vstr	s13, [r3]
  if (f0_hz >= 1800000 && f0_hz <= 2000000)
 8008eb2:	f5a6 13db 	sub.w	r3, r6, #1794048	@ 0x1b6000
 8008eb6:	f5a3 53ba 	sub.w	r3, r3, #5952	@ 0x1740
 8008eba:	4293      	cmp	r3, r2
 8008ebc:	f240 80cd 	bls.w	800905a <Thread1+0xf4a>
  else if (f0_hz >= 3500000 && f0_hz <= 4000000)
 8008ec0:	4b85      	ldr	r3, [pc, #532]	@ (80090d8 <Thread1+0xfc8>)
 8008ec2:	4986      	ldr	r1, [pc, #536]	@ (80090dc <Thread1+0xfcc>)
 8008ec4:	4433      	add	r3, r6
 8008ec6:	428b      	cmp	r3, r1
 8008ec8:	d972      	bls.n	8008fb0 <Thread1+0xea0>
  else if (f0_hz >= 5300000 && f0_hz <= 5500000)
 8008eca:	4b85      	ldr	r3, [pc, #532]	@ (80090e0 <Thread1+0xfd0>)
 8008ecc:	4433      	add	r3, r6
 8008ece:	4293      	cmp	r3, r2
 8008ed0:	f240 80ca 	bls.w	8009068 <Thread1+0xf58>
  else if (f0_hz >= 7000000 && f0_hz <= 7300000)
 8008ed4:	4b83      	ldr	r3, [pc, #524]	@ (80090e4 <Thread1+0xfd4>)
 8008ed6:	4a84      	ldr	r2, [pc, #528]	@ (80090e8 <Thread1+0xfd8>)
 8008ed8:	4433      	add	r3, r6
 8008eda:	4293      	cmp	r3, r2
 8008edc:	f240 80e7 	bls.w	80090ae <Thread1+0xf9e>
  else if (f0_hz >= 10100000 && f0_hz <= 10150000)
 8008ee0:	f5a6 031a 	sub.w	r3, r6, #10092544	@ 0x9a0000
 8008ee4:	f5a3 53e9 	sub.w	r3, r3, #7456	@ 0x1d20
 8008ee8:	f24c 3250 	movw	r2, #50000	@ 0xc350
 8008eec:	4293      	cmp	r3, r2
 8008eee:	f240 80dc 	bls.w	80090aa <Thread1+0xf9a>
  else if (f0_hz >= 13900000 && f0_hz <= 14350000)
 8008ef2:	497e      	ldr	r1, [pc, #504]	@ (80090ec <Thread1+0xfdc>)
 8008ef4:	f5a6 0354 	sub.w	r3, r6, #13893632	@ 0xd40000
 8008ef8:	f5a3 53c7 	sub.w	r3, r3, #6368	@ 0x18e0
 8008efc:	428b      	cmp	r3, r1
 8008efe:	f240 80d2 	bls.w	80090a6 <Thread1+0xf96>
  else if (f0_hz >= 18068000 && f0_hz <= 18168000)
 8008f02:	4b7b      	ldr	r3, [pc, #492]	@ (80090f0 <Thread1+0xfe0>)
 8008f04:	4a7b      	ldr	r2, [pc, #492]	@ (80090f4 <Thread1+0xfe4>)
 8008f06:	4433      	add	r3, r6
 8008f08:	4293      	cmp	r3, r2
 8008f0a:	f240 80ca 	bls.w	80090a2 <Thread1+0xf92>
  else if (f0_hz >= 21000000 && f0_hz <= 21450000)
 8008f0e:	4b7a      	ldr	r3, [pc, #488]	@ (80090f8 <Thread1+0xfe8>)
 8008f10:	4433      	add	r3, r6
 8008f12:	428b      	cmp	r3, r1
 8008f14:	f240 80c3 	bls.w	800909e <Thread1+0xf8e>
  else if (f0_hz >= 24890000 && f0_hz <= 24990000)
 8008f18:	4b78      	ldr	r3, [pc, #480]	@ (80090fc <Thread1+0xfec>)
 8008f1a:	4433      	add	r3, r6
 8008f1c:	4293      	cmp	r3, r2
 8008f1e:	f240 80bc 	bls.w	800909a <Thread1+0xf8a>
  else if (f0_hz >= 28000000 && f0_hz <= 29700000)
 8008f22:	4b77      	ldr	r3, [pc, #476]	@ (8009100 <Thread1+0xff0>)
 8008f24:	4a77      	ldr	r2, [pc, #476]	@ (8009104 <Thread1+0xff4>)
 8008f26:	4433      	add	r3, r6
 8008f28:	4293      	cmp	r3, r2
 8008f2a:	f240 80b4 	bls.w	8009096 <Thread1+0xf86>
  else if (f0_hz >= 50000000 && f0_hz <= 54000000)
 8008f2e:	4b76      	ldr	r3, [pc, #472]	@ (8009108 <Thread1+0xff8>)
 8008f30:	4a76      	ldr	r2, [pc, #472]	@ (800910c <Thread1+0xffc>)
 8008f32:	4433      	add	r3, r6
 8008f34:	4293      	cmp	r3, r2
 8008f36:	f240 80ac 	bls.w	8009092 <Thread1+0xf82>
  else if (f0_hz >= 144000000 && f0_hz <= 148000000)
 8008f3a:	4b75      	ldr	r3, [pc, #468]	@ (8009110 <Thread1+0x1000>)
 8008f3c:	4433      	add	r3, r6
 8008f3e:	4293      	cmp	r3, r2
 8008f40:	f240 80a5 	bls.w	800908e <Thread1+0xf7e>
  else if (f0_hz >= 430000000 && f0_hz <= 440000000)
 8008f44:	4b73      	ldr	r3, [pc, #460]	@ (8009114 <Thread1+0x1004>)
 8008f46:	4a74      	ldr	r2, [pc, #464]	@ (8009118 <Thread1+0x1008>)
 8008f48:	4433      	add	r3, r6
 8008f4a:	4293      	cmp	r3, r2
 8008f4c:	f200 8092 	bhi.w	8009074 <Thread1+0xf64>
    name = "70cm";
 8008f50:	4972      	ldr	r1, [pc, #456]	@ (800911c <Thread1+0x100c>)
 8008f52:	e02e      	b.n	8008fb2 <Thread1+0xea2>
    MLA_UART_LOG("[MLA][Q] no valid resonance/BW, skip Q & band calc\r\n");
 8008f54:	4872      	ldr	r0, [pc, #456]	@ (8009120 <Thread1+0x1010>)
 8008f56:	f7fc fd01 	bl	800595c <serial_shell_printf>
    request_to_redraw(REDRAW_BACKUP | REDRAW_AREA); // ensure full screen refresh
 8008f5a:	f240 4002 	movw	r0, #1026	@ 0x402
 8008f5e:	f003 fc03 	bl	800c768 <request_to_redraw>
    mla_autozone_stage = 3; // fully done
 8008f62:	4a70      	ldr	r2, [pc, #448]	@ (8009124 <Thread1+0x1014>)
 8008f64:	2303      	movs	r3, #3
 8008f66:	7013      	strb	r3, [r2, #0]
    return;
 8008f68:	f7ff bb03 	b.w	8008572 <Thread1+0x462>
    freq_t stop = start + span;
 8008f6c:	4e6e      	ldr	r6, [pc, #440]	@ (8009128 <Thread1+0x1018>)
    freq_t start = (f_res > half) ? (f_res - half) : FREQUENCY_MIN;
 8008f6e:	f44f 7716 	mov.w	r7, #600	@ 0x258
    MLA_UART_LOG(
 8008f72:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8008f74:	4959      	ldr	r1, [pc, #356]	@ (80090dc <Thread1+0xfcc>)
 8008f76:	9300      	str	r3, [sp, #0]
 8008f78:	463a      	mov	r2, r7
 8008f7a:	4633      	mov	r3, r6
 8008f7c:	486b      	ldr	r0, [pc, #428]	@ (800912c <Thread1+0x101c>)
 8008f7e:	f7fc fced 	bl	800595c <serial_shell_printf>
    set_sweep_frequency(ST_START, start);
 8008f82:	4639      	mov	r1, r7
 8008f84:	2000      	movs	r0, #0
 8008f86:	f7fe fda5 	bl	8007ad4 <set_sweep_frequency>
    set_sweep_frequency(ST_STOP, stop);
 8008f8a:	4631      	mov	r1, r6
 8008f8c:	2001      	movs	r0, #1
 8008f8e:	f7fe fda1 	bl	8007ad4 <set_sweep_frequency>
    mla_autozone_stage = 1;
 8008f92:	4a64      	ldr	r2, [pc, #400]	@ (8009124 <Thread1+0x1014>)
 8008f94:	2301      	movs	r3, #1
 8008f96:	7013      	strb	r3, [r2, #0]
    return;
 8008f98:	f7ff baeb 	b.w	8008572 <Thread1+0x462>
    if (left > 0)
 8008f9c:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8008f9e:	4643      	mov	r3, r8
 8008fa0:	b122      	cbz	r2, 8008fac <Thread1+0xe9c>
      left--;
 8008fa2:	3a01      	subs	r2, #1
    if (right + 1 < sweep_points)
 8008fa4:	428b      	cmp	r3, r1
      left--;
 8008fa6:	b292      	uxth	r2, r2
    if (right + 1 < sweep_points)
 8008fa8:	f6bf aec4 	bge.w	8008d34 <Thread1+0xc24>
      right++;
 8008fac:	b29f      	uxth	r7, r3
 8008fae:	e6c1      	b.n	8008d34 <Thread1+0xc24>
    name = "80m";
 8008fb0:	495f      	ldr	r1, [pc, #380]	@ (8009130 <Thread1+0x1020>)
    strncpy(mla_band_name, name, sizeof(mla_band_name));
 8008fb2:	4843      	ldr	r0, [pc, #268]	@ (80090c0 <Thread1+0xfb0>)
 8008fb4:	220c      	movs	r2, #12
 8008fb6:	f009 fc1d 	bl	80127f4 <strncpy>
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 8008fba:	4a41      	ldr	r2, [pc, #260]	@ (80090c0 <Thread1+0xfb0>)
    MLA_UART_LOG("[MLA][Q] f0      = " VNA_FREQ_FMT_STR " Hz (%s band)\r\n", f0_hz, mla_band_name);
 8008fbc:	485d      	ldr	r0, [pc, #372]	@ (8009134 <Thread1+0x1024>)
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 8008fbe:	2300      	movs	r3, #0
    MLA_UART_LOG("[MLA][Q] f0      = " VNA_FREQ_FMT_STR " Hz (%s band)\r\n", f0_hz, mla_band_name);
 8008fc0:	4631      	mov	r1, r6
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 8008fc2:	72d3      	strb	r3, [r2, #11]
    MLA_UART_LOG("[MLA][Q] f0      = " VNA_FREQ_FMT_STR " Hz (%s band)\r\n", f0_hz, mla_band_name);
 8008fc4:	f7fc fcca 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("[MLA][Q] BW(SWR<=2) = " VNA_FREQ_FMT_STR " Hz\r\n", bw_hz);
 8008fc8:	4641      	mov	r1, r8
 8008fca:	485b      	ldr	r0, [pc, #364]	@ (8009138 <Thread1+0x1028>)
 8008fcc:	f7fc fcc6 	bl	800595c <serial_shell_printf>
  MLA_UART_LOG("[MLA][Q] Q  %.1f,  BW/f0  %.6f  (%.3f %%)\r\n",
 8008fd0:	4b3c      	ldr	r3, [pc, #240]	@ (80090c4 <Thread1+0xfb4>)
 8008fd2:	ed93 8a00 	vldr	s16, [r3]
 8008fd6:	4b38      	ldr	r3, [pc, #224]	@ (80090b8 <Thread1+0xfa8>)
 8008fd8:	6818      	ldr	r0, [r3, #0]
 8008fda:	f7f7 fae1 	bl	80005a0 <__aeabi_f2d>
 8008fde:	eddf 7a57 	vldr	s15, [pc, #348]	@ 800913c <Thread1+0x102c>
 8008fe2:	ee68 7a27 	vmul.f32	s15, s16, s15
 8008fe6:	4606      	mov	r6, r0
 8008fe8:	ee17 0a90 	vmov	r0, s15
 8008fec:	460f      	mov	r7, r1
 8008fee:	f7f7 fad7 	bl	80005a0 <__aeabi_f2d>
 8008ff2:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8008ff6:	ee18 0a10 	vmov	r0, s16
 8008ffa:	f7f7 fad1 	bl	80005a0 <__aeabi_f2d>
 8008ffe:	463b      	mov	r3, r7
 8009000:	e9cd 0100 	strd	r0, r1, [sp]
 8009004:	4632      	mov	r2, r6
 8009006:	484e      	ldr	r0, [pc, #312]	@ (8009140 <Thread1+0x1030>)
 8009008:	f7fc fca8 	bl	800595c <serial_shell_printf>
  if (bw_hz < MLA_BW_TOO_NARROW_HZ || mla_Q_factor > MLA_Q_TOO_HIGH)
 800900c:	f640 33b7 	movw	r3, #2999	@ 0xbb7
 8009010:	4598      	cmp	r8, r3
 8009012:	d924      	bls.n	800905e <Thread1+0xf4e>
 8009014:	4b28      	ldr	r3, [pc, #160]	@ (80090b8 <Thread1+0xfa8>)
 8009016:	ed9f 7a4b 	vldr	s14, [pc, #300]	@ 8009144 <Thread1+0x1034>
 800901a:	edd3 7a00 	vldr	s15, [r3]
 800901e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009026:	dc1a      	bgt.n	800905e <Thread1+0xf4e>
  else if (mla_Q_factor >= MLA_Q_HIGH)
 8009028:	ed9f 7a47 	vldr	s14, [pc, #284]	@ 8009148 <Thread1+0x1038>
 800902c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009030:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009034:	da1c      	bge.n	8009070 <Thread1+0xf60>
  else if (mla_Q_factor >= MLA_Q_GOOD)
 8009036:	ed9f 7a45 	vldr	s14, [pc, #276]	@ 800914c <Thread1+0x103c>
 800903a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800903e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009042:	da13      	bge.n	800906c <Thread1+0xf5c>
  else if (mla_Q_factor >= MLA_Q_LOW)
 8009044:	ed9f 7a42 	vldr	s14, [pc, #264]	@ 8009150 <Thread1+0x1040>
    q_class = "VERY-LOW-Q";
 8009048:	4b42      	ldr	r3, [pc, #264]	@ (8009154 <Thread1+0x1044>)
 800904a:	4943      	ldr	r1, [pc, #268]	@ (8009158 <Thread1+0x1048>)
 800904c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009050:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009054:	bfb8      	it	lt
 8009056:	4619      	movlt	r1, r3
 8009058:	e002      	b.n	8009060 <Thread1+0xf50>
    name = "160m";
 800905a:	4940      	ldr	r1, [pc, #256]	@ (800915c <Thread1+0x104c>)
 800905c:	e7a9      	b.n	8008fb2 <Thread1+0xea2>
    q_class = "ULTRA-NARROW";
 800905e:	4940      	ldr	r1, [pc, #256]	@ (8009160 <Thread1+0x1050>)
  MLA_UART_LOG("[MLA][Q] class: %s\r\n", q_class);
 8009060:	4840      	ldr	r0, [pc, #256]	@ (8009164 <Thread1+0x1054>)
 8009062:	f7fc fc7b 	bl	800595c <serial_shell_printf>
 8009066:	e778      	b.n	8008f5a <Thread1+0xe4a>
    name = "60m";
 8009068:	493f      	ldr	r1, [pc, #252]	@ (8009168 <Thread1+0x1058>)
 800906a:	e7a2      	b.n	8008fb2 <Thread1+0xea2>
    q_class = "GOOD";
 800906c:	493f      	ldr	r1, [pc, #252]	@ (800916c <Thread1+0x105c>)
 800906e:	e7f7      	b.n	8009060 <Thread1+0xf50>
    q_class = "HIGH-Q";
 8009070:	493f      	ldr	r1, [pc, #252]	@ (8009170 <Thread1+0x1060>)
 8009072:	e7f5      	b.n	8009060 <Thread1+0xf50>
    strncpy(mla_band_name, "outside", sizeof(mla_band_name));
 8009074:	493f      	ldr	r1, [pc, #252]	@ (8009174 <Thread1+0x1064>)
 8009076:	4812      	ldr	r0, [pc, #72]	@ (80090c0 <Thread1+0xfb0>)
 8009078:	220c      	movs	r2, #12
 800907a:	f009 fbbb 	bl	80127f4 <strncpy>
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 800907e:	4a10      	ldr	r2, [pc, #64]	@ (80090c0 <Thread1+0xfb0>)
    MLA_UART_LOG("[MLA][Q] f0      = " VNA_FREQ_FMT_STR " Hz (outside band)\r\n", f0_hz);
 8009080:	483d      	ldr	r0, [pc, #244]	@ (8009178 <Thread1+0x1068>)
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 8009082:	2300      	movs	r3, #0
    MLA_UART_LOG("[MLA][Q] f0      = " VNA_FREQ_FMT_STR " Hz (outside band)\r\n", f0_hz);
 8009084:	4631      	mov	r1, r6
  mla_band_name[sizeof(mla_band_name) - 1] = '\0';
 8009086:	72d3      	strb	r3, [r2, #11]
    MLA_UART_LOG("[MLA][Q] f0      = " VNA_FREQ_FMT_STR " Hz (outside band)\r\n", f0_hz);
 8009088:	f7fc fc68 	bl	800595c <serial_shell_printf>
 800908c:	e79c      	b.n	8008fc8 <Thread1+0xeb8>
    name = "2m";
 800908e:	493b      	ldr	r1, [pc, #236]	@ (800917c <Thread1+0x106c>)
 8009090:	e78f      	b.n	8008fb2 <Thread1+0xea2>
    name = "6m";
 8009092:	493b      	ldr	r1, [pc, #236]	@ (8009180 <Thread1+0x1070>)
 8009094:	e78d      	b.n	8008fb2 <Thread1+0xea2>
    name = "10m";
 8009096:	493b      	ldr	r1, [pc, #236]	@ (8009184 <Thread1+0x1074>)
 8009098:	e78b      	b.n	8008fb2 <Thread1+0xea2>
    name = "12m";
 800909a:	493b      	ldr	r1, [pc, #236]	@ (8009188 <Thread1+0x1078>)
 800909c:	e789      	b.n	8008fb2 <Thread1+0xea2>
    name = "15m";
 800909e:	493b      	ldr	r1, [pc, #236]	@ (800918c <Thread1+0x107c>)
 80090a0:	e787      	b.n	8008fb2 <Thread1+0xea2>
    name = "17m";
 80090a2:	493b      	ldr	r1, [pc, #236]	@ (8009190 <Thread1+0x1080>)
 80090a4:	e785      	b.n	8008fb2 <Thread1+0xea2>
    name = "20m"; // extended range
 80090a6:	493b      	ldr	r1, [pc, #236]	@ (8009194 <Thread1+0x1084>)
 80090a8:	e783      	b.n	8008fb2 <Thread1+0xea2>
    name = "30m";
 80090aa:	493b      	ldr	r1, [pc, #236]	@ (8009198 <Thread1+0x1088>)
 80090ac:	e781      	b.n	8008fb2 <Thread1+0xea2>
    name = "40m";
 80090ae:	493b      	ldr	r1, [pc, #236]	@ (800919c <Thread1+0x108c>)
 80090b0:	e77f      	b.n	8008fb2 <Thread1+0xea2>
 80090b2:	bf00      	nop
 80090b4:	08013430 	.word	0x08013430
 80090b8:	2000686c 	.word	0x2000686c
 80090bc:	08013464 	.word	0x08013464
 80090c0:	200003c8 	.word	0x200003c8
 80090c4:	20006868 	.word	0x20006868
 80090c8:	2000687d 	.word	0x2000687d
 80090cc:	20006884 	.word	0x20006884
 80090d0:	20006870 	.word	0x20006870
 80090d4:	00030d40 	.word	0x00030d40
 80090d8:	ffca9820 	.word	0xffca9820
 80090dc:	0007a120 	.word	0x0007a120
 80090e0:	ffaf20e0 	.word	0xffaf20e0
 80090e4:	ff953040 	.word	0xff953040
 80090e8:	000493e0 	.word	0x000493e0
 80090ec:	0006ddd0 	.word	0x0006ddd0
 80090f0:	feec4de0 	.word	0xfeec4de0
 80090f4:	000186a0 	.word	0x000186a0
 80090f8:	febf90c0 	.word	0xfebf90c0
 80090fc:	fe843570 	.word	0xfe843570
 8009100:	fe54c100 	.word	0xfe54c100
 8009104:	0019f0a0 	.word	0x0019f0a0
 8009108:	fd050f80 	.word	0xfd050f80
 800910c:	003d0900 	.word	0x003d0900
 8009110:	f76abc00 	.word	0xf76abc00
 8009114:	e65eb880 	.word	0xe65eb880
 8009118:	00989680 	.word	0x00989680
 800911c:	080131e0 	.word	0x080131e0
 8009120:	08013468 	.word	0x08013468
 8009124:	20006875 	.word	0x20006875
 8009128:	0007a378 	.word	0x0007a378
 800912c:	0801362c 	.word	0x0801362c
 8009130:	080131b4 	.word	0x080131b4
 8009134:	080134d4 	.word	0x080134d4
 8009138:	080134fc 	.word	0x080134fc
 800913c:	42c80000 	.word	0x42c80000
 8009140:	0801351c 	.word	0x0801351c
 8009144:	44960000 	.word	0x44960000
 8009148:	43c80000 	.word	0x43c80000
 800914c:	43160000 	.word	0x43160000
 8009150:	42480000 	.word	0x42480000
 8009154:	080131f8 	.word	0x080131f8
 8009158:	0801320c 	.word	0x0801320c
 800915c:	080131ac 	.word	0x080131ac
 8009160:	080131e8 	.word	0x080131e8
 8009164:	08013550 	.word	0x08013550
 8009168:	080131b8 	.word	0x080131b8
 800916c:	08013194 	.word	0x08013194
 8009170:	08013204 	.word	0x08013204
 8009174:	080134a0 	.word	0x080134a0
 8009178:	080134a8 	.word	0x080134a8
 800917c:	080131dc 	.word	0x080131dc
 8009180:	080131d8 	.word	0x080131d8
 8009184:	080131d4 	.word	0x080131d4
 8009188:	080131d0 	.word	0x080131d0
 800918c:	080131cc 	.word	0x080131cc
 8009190:	080131c8 	.word	0x080131c8
 8009194:	080131c4 	.word	0x080131c4
 8009198:	080131c0 	.word	0x080131c0
 800919c:	080131bc 	.word	0x080131bc

080091a0 <set_trace_enable>:
{
 80091a0:	b508      	push	{r3, lr}
  trace[t].enabled = enable;
 80091a2:	4b10      	ldr	r3, [pc, #64]	@ (80091e4 <set_trace_enable+0x44>)
 80091a4:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80091a8:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80091ac:	f882 1028 	strb.w	r1, [r2, #40]	@ 0x28
  current_trace = enable ? t : TRACE_INVALID;
 80091b0:	b129      	cbz	r1, 80091be <set_trace_enable+0x1e>
 80091b2:	7718      	strb	r0, [r3, #28]
}
 80091b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_AREA);
 80091b8:	2002      	movs	r0, #2
 80091ba:	f003 bad5 	b.w	800c768 <request_to_redraw>
  current_trace = enable ? t : TRACE_INVALID;
 80091be:	22ff      	movs	r2, #255	@ 0xff
 80091c0:	771a      	strb	r2, [r3, #28]
      if (trace[i].enabled)
 80091c2:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
    for (int i = 0; i < TRACES_MAX; i++) // set first enabled as current trace
 80091c6:	330c      	adds	r3, #12
      if (trace[i].enabled)
 80091c8:	b93a      	cbnz	r2, 80091da <set_trace_enable+0x3a>
    for (int i = 0; i < TRACES_MAX; i++) // set first enabled as current trace
 80091ca:	3101      	adds	r1, #1
 80091cc:	2904      	cmp	r1, #4
 80091ce:	d1f8      	bne.n	80091c2 <set_trace_enable+0x22>
}
 80091d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_AREA);
 80091d4:	2002      	movs	r0, #2
 80091d6:	f003 bac7 	b.w	800c768 <request_to_redraw>
        set_active_trace(i);
 80091da:	4608      	mov	r0, r1
 80091dc:	f7fe ff32 	bl	8008044 <set_active_trace>
        break;
 80091e0:	e7e8      	b.n	80091b4 <set_trace_enable+0x14>
 80091e2:	bf00      	nop
 80091e4:	20000aa8 	.word	0x20000aa8

080091e8 <cmd_trace>:
{
 80091e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (argc == 0)
 80091ea:	4604      	mov	r4, r0
{
 80091ec:	b085      	sub	sp, #20
  if (argc == 0)
 80091ee:	bb28      	cbnz	r0, 800923c <cmd_trace+0x54>
 80091f0:	4f5d      	ldr	r7, [pc, #372]	@ (8009368 <cmd_trace+0x180>)
      if (trace[t].enabled)
 80091f2:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80091f6:	b933      	cbnz	r3, 8009206 <cmd_trace+0x1e>
    for (t = 0; t < TRACES_MAX; t++)
 80091f8:	3401      	adds	r4, #1
 80091fa:	2c04      	cmp	r4, #4
 80091fc:	f107 070c 	add.w	r7, r7, #12
 8009200:	d1f7      	bne.n	80091f2 <cmd_trace+0xa>
}
 8009202:	b005      	add	sp, #20
 8009204:	bdf0      	pop	{r4, r5, r6, r7, pc}
        const char *type = get_trace_typename(trace[t].type, 0);
 8009206:	f897 0029 	ldrb.w	r0, [r7, #41]	@ 0x29
 800920a:	2100      	movs	r1, #0
 800920c:	f002 ffd0 	bl	800c1b0 <get_trace_typename>
 8009210:	4605      	mov	r5, r0
        const char *channel = get_trace_chname(t);
 8009212:	4620      	mov	r0, r4
 8009214:	f7fe fef0 	bl	8007ff8 <get_trace_chname>
 8009218:	4606      	mov	r6, r0
        shell_printf("%d %s %s %f %f" VNA_SHELL_NEWLINE_STR, t, type, channel, scale, refpos);
 800921a:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800921c:	f7f7 f9c0 	bl	80005a0 <__aeabi_f2d>
 8009220:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8009224:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8009226:	f7f7 f9bb 	bl	80005a0 <__aeabi_f2d>
 800922a:	4633      	mov	r3, r6
 800922c:	e9cd 0100 	strd	r0, r1, [sp]
 8009230:	462a      	mov	r2, r5
 8009232:	4621      	mov	r1, r4
 8009234:	484d      	ldr	r0, [pc, #308]	@ (800936c <cmd_trace+0x184>)
 8009236:	f7fc fef3 	bl	8006020 <shell_printf>
 800923a:	e7dd      	b.n	80091f8 <cmd_trace+0x10>
  if (get_str_index(argv[0], "all") == 0 &&
 800923c:	460e      	mov	r6, r1
 800923e:	494c      	ldr	r1, [pc, #304]	@ (8009370 <cmd_trace+0x188>)
 8009240:	6830      	ldr	r0, [r6, #0]
 8009242:	f000 fc33 	bl	8009aac <get_str_index>
 8009246:	b908      	cbnz	r0, 800924c <cmd_trace+0x64>
 8009248:	2c01      	cmp	r4, #1
 800924a:	dc23      	bgt.n	8009294 <cmd_trace+0xac>
  t = (uint32_t)my_atoi(argv[0]);
 800924c:	6830      	ldr	r0, [r6, #0]
 800924e:	f000 fb53 	bl	80098f8 <my_atoi>
  if (t >= TRACES_MAX)
 8009252:	2803      	cmp	r0, #3
  t = (uint32_t)my_atoi(argv[0]);
 8009254:	4605      	mov	r5, r0
  if (t >= TRACES_MAX)
 8009256:	d814      	bhi.n	8009282 <cmd_trace+0x9a>
  if (argc == 1)
 8009258:	2c01      	cmp	r4, #1
 800925a:	d02e      	beq.n	80092ba <cmd_trace+0xd2>
  if (get_str_index(argv[1], "off") == 0)
 800925c:	4945      	ldr	r1, [pc, #276]	@ (8009374 <cmd_trace+0x18c>)
 800925e:	6870      	ldr	r0, [r6, #4]
 8009260:	f000 fc24 	bl	8009aac <get_str_index>
 8009264:	b310      	cbz	r0, 80092ac <cmd_trace+0xc4>
  int type = get_str_index(argv[1], cmd_type_list);
 8009266:	4944      	ldr	r1, [pc, #272]	@ (8009378 <cmd_trace+0x190>)
 8009268:	6870      	ldr	r0, [r6, #4]
 800926a:	f000 fc1f 	bl	8009aac <get_str_index>
  if (type >= 0)
 800926e:	1e07      	subs	r7, r0, #0
 8009270:	db50      	blt.n	8009314 <cmd_trace+0x12c>
    if (argc > 2)
 8009272:	2c02      	cmp	r4, #2
 8009274:	dd38      	ble.n	80092e8 <cmd_trace+0x100>
      src = my_atoi(argv[2]);
 8009276:	68b0      	ldr	r0, [r6, #8]
 8009278:	f000 fb3e 	bl	80098f8 <my_atoi>
      if ((uint32_t)src > 1)
 800927c:	2801      	cmp	r0, #1
      src = my_atoi(argv[2]);
 800927e:	4602      	mov	r2, r0
      if ((uint32_t)src > 1)
 8009280:	d939      	bls.n	80092f6 <cmd_trace+0x10e>
  shell_printf("trace {0|1|2|3|all} [%s] [src]" VNA_SHELL_NEWLINE_STR
 8009282:	4b3e      	ldr	r3, [pc, #248]	@ (800937c <cmd_trace+0x194>)
 8009284:	4a3e      	ldr	r2, [pc, #248]	@ (8009380 <cmd_trace+0x198>)
 8009286:	493c      	ldr	r1, [pc, #240]	@ (8009378 <cmd_trace+0x190>)
 8009288:	483e      	ldr	r0, [pc, #248]	@ (8009384 <cmd_trace+0x19c>)
}
 800928a:	b005      	add	sp, #20
 800928c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  shell_printf("trace {0|1|2|3|all} [%s] [src]" VNA_SHELL_NEWLINE_STR
 8009290:	f7fc bec6 	b.w	8006020 <shell_printf>
      argc > 1 && get_str_index(argv[1], "off") == 0)
 8009294:	4937      	ldr	r1, [pc, #220]	@ (8009374 <cmd_trace+0x18c>)
 8009296:	6870      	ldr	r0, [r6, #4]
 8009298:	f000 fc08 	bl	8009aac <get_str_index>
 800929c:	b388      	cbz	r0, 8009302 <cmd_trace+0x11a>
  t = (uint32_t)my_atoi(argv[0]);
 800929e:	6830      	ldr	r0, [r6, #0]
 80092a0:	f000 fb2a 	bl	80098f8 <my_atoi>
  if (t >= TRACES_MAX)
 80092a4:	2803      	cmp	r0, #3
  t = (uint32_t)my_atoi(argv[0]);
 80092a6:	4605      	mov	r5, r0
  if (t >= TRACES_MAX)
 80092a8:	d9d8      	bls.n	800925c <cmd_trace+0x74>
 80092aa:	e7ea      	b.n	8009282 <cmd_trace+0x9a>
    set_trace_enable(t, false);
 80092ac:	4601      	mov	r1, r0
    set_trace_enable(t, true);
 80092ae:	4628      	mov	r0, r5
}
 80092b0:	b005      	add	sp, #20
 80092b2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    set_trace_enable(t, true);
 80092b6:	f7ff bf73 	b.w	80091a0 <set_trace_enable>
    const char *type = get_trace_typename(trace[t].type, 0);
 80092ba:	4b2b      	ldr	r3, [pc, #172]	@ (8009368 <cmd_trace+0x180>)
 80092bc:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80092c0:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80092c4:	2100      	movs	r1, #0
 80092c6:	f893 0029 	ldrb.w	r0, [r3, #41]	@ 0x29
 80092ca:	f002 ff71 	bl	800c1b0 <get_trace_typename>
 80092ce:	4601      	mov	r1, r0
    const char *channel = get_trace_chname(t);
 80092d0:	4628      	mov	r0, r5
 80092d2:	f7fe fe91 	bl	8007ff8 <get_trace_chname>
 80092d6:	4603      	mov	r3, r0
    shell_printf("%d %s %s" VNA_SHELL_NEWLINE_STR, t, type, channel);
 80092d8:	482b      	ldr	r0, [pc, #172]	@ (8009388 <cmd_trace+0x1a0>)
 80092da:	460a      	mov	r2, r1
 80092dc:	4629      	mov	r1, r5
}
 80092de:	b005      	add	sp, #20
 80092e0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  shell_printf("trace {0|1|2|3|all} [%s] [src]" VNA_SHELL_NEWLINE_STR
 80092e4:	f7fc be9c 	b.w	8006020 <shell_printf>
    int src = trace[t].channel;
 80092e8:	4b1f      	ldr	r3, [pc, #124]	@ (8009368 <cmd_trace+0x180>)
 80092ea:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 80092ee:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80092f2:	f893 202a 	ldrb.w	r2, [r3, #42]	@ 0x2a
    set_trace_type(t, type, src);
 80092f6:	4639      	mov	r1, r7
 80092f8:	4628      	mov	r0, r5
 80092fa:	f7fe fed9 	bl	80080b0 <set_trace_type>
    set_trace_enable(t, true);
 80092fe:	2101      	movs	r1, #1
 8009300:	e7d5      	b.n	80092ae <cmd_trace+0xc6>
    for (t = 0; t < TRACES_MAX; t++)
 8009302:	4604      	mov	r4, r0
      set_trace_enable(t, false);
 8009304:	4620      	mov	r0, r4
 8009306:	2100      	movs	r1, #0
    for (t = 0; t < TRACES_MAX; t++)
 8009308:	3401      	adds	r4, #1
      set_trace_enable(t, false);
 800930a:	f7ff ff49 	bl	80091a0 <set_trace_enable>
    for (t = 0; t < TRACES_MAX; t++)
 800930e:	2c04      	cmp	r4, #4
 8009310:	d1f8      	bne.n	8009304 <cmd_trace+0x11c>
 8009312:	e776      	b.n	8009202 <cmd_trace+0x1a>
  int format = get_str_index(argv[1], cmd_marker_smith);
 8009314:	491a      	ldr	r1, [pc, #104]	@ (8009380 <cmd_trace+0x198>)
 8009316:	6870      	ldr	r0, [r6, #4]
 8009318:	f000 fbc8 	bl	8009aac <get_str_index>
  if (format >= 0)
 800931c:	2800      	cmp	r0, #0
 800931e:	da12      	bge.n	8009346 <cmd_trace+0x15e>
  if (argc >= 3)
 8009320:	2c02      	cmp	r4, #2
 8009322:	f77f af6e 	ble.w	8009202 <cmd_trace+0x1a>
    switch (get_str_index(argv[1], cmd_scale_ref_list))
 8009326:	4915      	ldr	r1, [pc, #84]	@ (800937c <cmd_trace+0x194>)
 8009328:	6870      	ldr	r0, [r6, #4]
 800932a:	f000 fbbf 	bl	8009aac <get_str_index>
 800932e:	b190      	cbz	r0, 8009356 <cmd_trace+0x16e>
 8009330:	2801      	cmp	r0, #1
 8009332:	d1a6      	bne.n	8009282 <cmd_trace+0x9a>
      set_trace_refpos(t, my_atof(argv[2]));
 8009334:	68b0      	ldr	r0, [r6, #8]
 8009336:	f000 fb1f 	bl	8009978 <my_atof>
 800933a:	4628      	mov	r0, r5
}
 800933c:	b005      	add	sp, #20
 800933e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      set_trace_refpos(t, my_atof(argv[2]));
 8009342:	f7fe bea1 	b.w	8008088 <set_trace_refpos>
    trace[t].smith_format = format;
 8009346:	4b08      	ldr	r3, [pc, #32]	@ (8009368 <cmd_trace+0x180>)
 8009348:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800934c:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8009350:	f883 002b 	strb.w	r0, [r3, #43]	@ 0x2b
    return;
 8009354:	e755      	b.n	8009202 <cmd_trace+0x1a>
      set_trace_scale(t, my_atof(argv[2]));
 8009356:	68b0      	ldr	r0, [r6, #8]
 8009358:	f000 fb0e 	bl	8009978 <my_atof>
 800935c:	4628      	mov	r0, r5
}
 800935e:	b005      	add	sp, #20
 8009360:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      set_trace_scale(t, my_atof(argv[2]));
 8009364:	f7fe be7c 	b.w	8008060 <set_trace_scale>
 8009368:	20000aa8 	.word	0x20000aa8
 800936c:	080137dc 	.word	0x080137dc
 8009370:	080137f0 	.word	0x080137f0
 8009374:	080137f4 	.word	0x080137f4
 8009378:	08015b78 	.word	0x08015b78
 800937c:	08015b2c 	.word	0x08015b2c
 8009380:	08015b3c 	.word	0x08015b3c
 8009384:	08013804 	.word	0x08013804
 8009388:	080137f8 	.word	0x080137f8

0800938c <set_electrical_delay>:
  if (current_props._electrical_delay[ch] == seconds)
 800938c:	4b08      	ldr	r3, [pc, #32]	@ (80093b0 <set_electrical_delay+0x24>)
 800938e:	3026      	adds	r0, #38	@ 0x26
 8009390:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8009394:	edd3 7a01 	vldr	s15, [r3, #4]
 8009398:	eef4 7a40 	vcmp.f32	s15, s0
 800939c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80093a0:	d100      	bne.n	80093a4 <set_electrical_delay+0x18>
}
 80093a2:	4770      	bx	lr
  request_to_redraw(REDRAW_MARKER);
 80093a4:	2020      	movs	r0, #32
  current_props._electrical_delay[ch] = seconds;
 80093a6:	ed83 0a01 	vstr	s0, [r3, #4]
  request_to_redraw(REDRAW_MARKER);
 80093aa:	f003 b9dd 	b.w	800c768 <request_to_redraw>
 80093ae:	bf00      	nop
 80093b0:	20000aa8 	.word	0x20000aa8

080093b4 <cmd_edelay>:
{
 80093b4:	b570      	push	{r4, r5, r6, lr}
  if (argc >= 1)
 80093b6:	1e04      	subs	r4, r0, #0
 80093b8:	dd1d      	ble.n	80093f6 <cmd_edelay+0x42>
    int idx = get_str_index(argv[0], cmd_edelay_list);
 80093ba:	460e      	mov	r6, r1
 80093bc:	4917      	ldr	r1, [pc, #92]	@ (800941c <cmd_edelay+0x68>)
 80093be:	6830      	ldr	r0, [r6, #0]
 80093c0:	f000 fb74 	bl	8009aac <get_str_index>
    if (idx == -1)
 80093c4:	1c43      	adds	r3, r0, #1
    int idx = get_str_index(argv[0], cmd_edelay_list);
 80093c6:	4605      	mov	r5, r0
    if (idx == -1)
 80093c8:	d023      	beq.n	8009412 <cmd_edelay+0x5e>
      if (argc != 2)
 80093ca:	2c02      	cmp	r4, #2
 80093cc:	d015      	beq.n	80093fa <cmd_edelay+0x46>
  shell_printf("%f" VNA_SHELL_NEWLINE_STR, current_props._electrical_delay[ch] * (1.0f / 1e-12f)); // return in picoseconds
 80093ce:	4b14      	ldr	r3, [pc, #80]	@ (8009420 <cmd_edelay+0x6c>)
 80093d0:	eddf 7a14 	vldr	s15, [pc, #80]	@ 8009424 <cmd_edelay+0x70>
 80093d4:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 80093d8:	ed93 7a27 	vldr	s14, [r3, #156]	@ 0x9c
 80093dc:	ee67 7a27 	vmul.f32	s15, s14, s15
 80093e0:	ee17 0a90 	vmov	r0, s15
 80093e4:	f7f7 f8dc 	bl	80005a0 <__aeabi_f2d>
}
 80093e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  shell_printf("%f" VNA_SHELL_NEWLINE_STR, current_props._electrical_delay[ch] * (1.0f / 1e-12f)); // return in picoseconds
 80093ec:	4602      	mov	r2, r0
 80093ee:	460b      	mov	r3, r1
 80093f0:	480d      	ldr	r0, [pc, #52]	@ (8009428 <cmd_edelay+0x74>)
 80093f2:	f7fc be15 	b.w	8006020 <shell_printf>
  int ch = 0;
 80093f6:	2500      	movs	r5, #0
 80093f8:	e7e9      	b.n	80093ce <cmd_edelay+0x1a>
      value = my_atof(argv[0]);
 80093fa:	6830      	ldr	r0, [r6, #0]
 80093fc:	f000 fabc 	bl	8009978 <my_atof>
    set_electrical_delay(ch, value * 1e-12); // input value in seconds
 8009400:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 800942c <cmd_edelay+0x78>
 8009404:	4628      	mov	r0, r5
 8009406:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 800940a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    set_electrical_delay(ch, value * 1e-12); // input value in seconds
 800940e:	f7ff bfbd 	b.w	800938c <set_electrical_delay>
      value = my_atof(argv[0]);
 8009412:	6830      	ldr	r0, [r6, #0]
 8009414:	f000 fab0 	bl	8009978 <my_atof>
  int ch = 0;
 8009418:	2500      	movs	r5, #0
 800941a:	e7f1      	b.n	8009400 <cmd_edelay+0x4c>
 800941c:	08015bf8 	.word	0x08015bf8
 8009420:	20000aa8 	.word	0x20000aa8
 8009424:	5368d4a5 	.word	0x5368d4a5
 8009428:	080137e8 	.word	0x080137e8
 800942c:	2b8cbccc 	.word	0x2b8cbccc

08009430 <get_electrical_delay>:
  if (current_trace == TRACE_INVALID)
 8009430:	4a09      	ldr	r2, [pc, #36]	@ (8009458 <get_electrical_delay+0x28>)
 8009432:	f992 301c 	ldrsb.w	r3, [r2, #28]
 8009436:	1c59      	adds	r1, r3, #1
 8009438:	d00a      	beq.n	8009450 <get_electrical_delay+0x20>
  int ch = trace[current_trace].channel;
 800943a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800943e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8009442:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
  return current_props._electrical_delay[ch];
 8009446:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800944a:	ed92 0a27 	vldr	s0, [r2, #156]	@ 0x9c
 800944e:	4770      	bx	lr
    return 0.0f;
 8009450:	ed9f 0a02 	vldr	s0, [pc, #8]	@ 800945c <get_electrical_delay+0x2c>
}
 8009454:	4770      	bx	lr
 8009456:	bf00      	nop
 8009458:	20000aa8 	.word	0x20000aa8
 800945c:	00000000 	.word	0x00000000

08009460 <set_s21_offset>:
  if (s21_offset != offset)
 8009460:	4b06      	ldr	r3, [pc, #24]	@ (800947c <set_s21_offset+0x1c>)
 8009462:	edd3 7a2a 	vldr	s15, [r3, #168]	@ 0xa8
 8009466:	eef4 7a40 	vcmp.f32	s15, s0
 800946a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800946e:	d100      	bne.n	8009472 <set_s21_offset+0x12>
}
 8009470:	4770      	bx	lr
    request_to_redraw(REDRAW_MARKER);
 8009472:	2020      	movs	r0, #32
    s21_offset = offset;
 8009474:	ed83 0a2a 	vstr	s0, [r3, #168]	@ 0xa8
    request_to_redraw(REDRAW_MARKER);
 8009478:	f003 b976 	b.w	800c768 <request_to_redraw>
 800947c:	20000aa8 	.word	0x20000aa8

08009480 <cmd_s21offset>:
  if (argc != 1)
 8009480:	2801      	cmp	r0, #1
{
 8009482:	b510      	push	{r4, lr}
  if (argc != 1)
 8009484:	d00b      	beq.n	800949e <cmd_s21offset+0x1e>
    shell_printf("%f" VNA_SHELL_NEWLINE_STR, s21_offset); // return in dB
 8009486:	4b09      	ldr	r3, [pc, #36]	@ (80094ac <cmd_s21offset+0x2c>)
 8009488:	f8d3 00a8 	ldr.w	r0, [r3, #168]	@ 0xa8
 800948c:	f7f7 f888 	bl	80005a0 <__aeabi_f2d>
}
 8009490:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    shell_printf("%f" VNA_SHELL_NEWLINE_STR, s21_offset); // return in dB
 8009494:	4602      	mov	r2, r0
 8009496:	460b      	mov	r3, r1
 8009498:	4805      	ldr	r0, [pc, #20]	@ (80094b0 <cmd_s21offset+0x30>)
 800949a:	f7fc bdc1 	b.w	8006020 <shell_printf>
  set_s21_offset(my_atof(argv[0])); // input value in dB
 800949e:	6808      	ldr	r0, [r1, #0]
 80094a0:	f000 fa6a 	bl	8009978 <my_atof>
}
 80094a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_s21_offset(my_atof(argv[0])); // input value in dB
 80094a8:	f7ff bfda 	b.w	8009460 <set_s21_offset>
 80094ac:	20000aa8 	.word	0x20000aa8
 80094b0:	080137e8 	.word	0x080137e8

080094b4 <send_region>:
{
 80094b4:	b538      	push	{r3, r4, r5, lr}
  if (SDU1.config->usbp->state == USB_ACTIVE)
 80094b6:	4b0e      	ldr	r3, [pc, #56]	@ (80094f0 <send_region+0x3c>)
 80094b8:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
 80094bc:	681b      	ldr	r3, [r3, #0]
 80094be:	781b      	ldrb	r3, [r3, #0]
 80094c0:	2b04      	cmp	r3, #4
 80094c2:	d005      	beq.n	80094d0 <send_region+0x1c>
    sweep_mode &= ~SWEEP_REMOTE;
 80094c4:	4a0b      	ldr	r2, [pc, #44]	@ (80094f4 <send_region+0x40>)
 80094c6:	7813      	ldrb	r3, [r2, #0]
 80094c8:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80094cc:	7013      	strb	r3, [r2, #0]
}
 80094ce:	bd38      	pop	{r3, r4, r5, pc}
 80094d0:	4615      	mov	r5, r2
    shell_write(rd, sizeof(remote_region_t));
 80094d2:	460c      	mov	r4, r1
 80094d4:	210e      	movs	r1, #14
 80094d6:	f7fc f81d 	bl	8005514 <shell_write>
    shell_write(buf, size);
 80094da:	4629      	mov	r1, r5
 80094dc:	4620      	mov	r0, r4
 80094de:	f7fc f819 	bl	8005514 <shell_write>
}
 80094e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    shell_write(VNA_SHELL_PROMPT_STR VNA_SHELL_NEWLINE_STR, 6);
 80094e6:	4804      	ldr	r0, [pc, #16]	@ (80094f8 <send_region+0x44>)
 80094e8:	2106      	movs	r1, #6
 80094ea:	f7fc b813 	b.w	8005514 <shell_write>
 80094ee:	bf00      	nop
 80094f0:	200007b0 	.word	0x200007b0
 80094f4:	200003c4 	.word	0x200003c4
 80094f8:	0801385c 	.word	0x0801385c

080094fc <shell_update_speed>:
  config._serial_speed = speed;
 80094fc:	4b02      	ldr	r3, [pc, #8]	@ (8009508 <shell_update_speed+0xc>)
{
 80094fe:	4601      	mov	r1, r0
  sdSetBaudrate(&SD1, speed);
 8009500:	4802      	ldr	r0, [pc, #8]	@ (800950c <shell_update_speed+0x10>)
  config._serial_speed = speed;
 8009502:	6619      	str	r1, [r3, #96]	@ 0x60
  sdSetBaudrate(&SD1, speed);
 8009504:	f7f8 bd20 	b.w	8001f48 <sd_lld_setbaudrate>
 8009508:	20000318 	.word	0x20000318
 800950c:	20000574 	.word	0x20000574

08009510 <cmd_usart_cfg>:
  if (argc != 1)
 8009510:	2801      	cmp	r0, #1
{
 8009512:	b508      	push	{r3, lr}
  if (argc != 1)
 8009514:	d006      	beq.n	8009524 <cmd_usart_cfg+0x14>
    shell_printf("Serial: %u baud" VNA_SHELL_NEWLINE_STR, config._serial_speed);
 8009516:	4b09      	ldr	r3, [pc, #36]	@ (800953c <cmd_usart_cfg+0x2c>)
 8009518:	4809      	ldr	r0, [pc, #36]	@ (8009540 <cmd_usart_cfg+0x30>)
 800951a:	6e19      	ldr	r1, [r3, #96]	@ 0x60
}
 800951c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    shell_printf("Serial: %u baud" VNA_SHELL_NEWLINE_STR, config._serial_speed);
 8009520:	f7fc bd7e 	b.w	8006020 <shell_printf>
  uint32_t speed = my_atoui(argv[0]);
 8009524:	6808      	ldr	r0, [r1, #0]
 8009526:	f000 fa01 	bl	800992c <my_atoui>
  shell_update_speed(speed);
 800952a:	f5b0 7f96 	cmp.w	r0, #300	@ 0x12c
}
 800952e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  shell_update_speed(speed);
 8009532:	bf38      	it	cc
 8009534:	f44f 7096 	movcc.w	r0, #300	@ 0x12c
 8009538:	f7ff bfe0 	b.w	80094fc <shell_update_speed>
 800953c:	20000318 	.word	0x20000318
 8009540:	08013864 	.word	0x08013864

08009544 <shell_reset_console>:
{
 8009544:	b508      	push	{r3, lr}
  return usbGetDriverStateI(&USBD1) == USB_ACTIVE;
 8009546:	4b0c      	ldr	r3, [pc, #48]	@ (8009578 <shell_reset_console+0x34>)
  if (usb_IsActive())
 8009548:	781b      	ldrb	r3, [r3, #0]
 800954a:	2b04      	cmp	r3, #4
 800954c:	d106      	bne.n	800955c <shell_reset_console+0x18>
    if (VNA_MODE(VNA_MODE_CONNECTION))
 800954e:	4b0b      	ldr	r3, [pc, #44]	@ (800957c <shell_reset_console+0x38>)
      sduDisconnectI(&SDU1);
 8009550:	480b      	ldr	r0, [pc, #44]	@ (8009580 <shell_reset_console+0x3c>)
    if (VNA_MODE(VNA_MODE_CONNECTION))
 8009552:	8a9b      	ldrh	r3, [r3, #20]
 8009554:	075b      	lsls	r3, r3, #29
 8009556:	d50b      	bpl.n	8009570 <shell_reset_console+0x2c>
      sduDisconnectI(&SDU1);
 8009558:	f7f8 f8f8 	bl	800174c <sduDisconnectI>
  qResetI(&SD1.oqueue);
 800955c:	4809      	ldr	r0, [pc, #36]	@ (8009584 <shell_reset_console+0x40>)
 800955e:	f7f7 fee1 	bl	8001324 <qResetI>
  qResetI(&SD1.iqueue);
 8009562:	4809      	ldr	r0, [pc, #36]	@ (8009588 <shell_reset_console+0x44>)
 8009564:	f7f7 fede 	bl	8001324 <qResetI>
  PREPARE_STREAM;
 8009568:	4b08      	ldr	r3, [pc, #32]	@ (800958c <shell_reset_console+0x48>)
 800956a:	4a09      	ldr	r2, [pc, #36]	@ (8009590 <shell_reset_console+0x4c>)
 800956c:	601a      	str	r2, [r3, #0]
}
 800956e:	bd08      	pop	{r3, pc}
      sduConfigureHookI(&SDU1);
 8009570:	f7f8 f8f8 	bl	8001764 <sduConfigureHookI>
 8009574:	e7f2      	b.n	800955c <shell_reset_console+0x18>
 8009576:	bf00      	nop
 8009578:	20000650 	.word	0x20000650
 800957c:	20000318 	.word	0x20000318
 8009580:	200007b0 	.word	0x200007b0
 8009584:	2000059c 	.word	0x2000059c
 8009588:	2000057c 	.word	0x2000057c
 800958c:	200068ec 	.word	0x200068ec
 8009590:	20000574 	.word	0x20000574

08009594 <VNAShell_executeCMDLine>:
  else if (**shell_args) // unknown command (not empty), ignore <CR>
    shell_printf("%s?" VNA_SHELL_NEWLINE_STR, shell_args[0]);
}

void VNAShell_executeCMDLine(char *line)
{
 8009594:	b510      	push	{r4, lr}
  // Disable shell output (not allow shell_printf write, but not block other output!!)
  shell_stream = NULL;
 8009596:	4c09      	ldr	r4, [pc, #36]	@ (80095bc <VNAShell_executeCMDLine+0x28>)
 8009598:	2300      	movs	r3, #0
 800959a:	6023      	str	r3, [r4, #0]
  const VNAShellCommand *scp = VNAShell_parceLine(line);
 800959c:	f7fc fd52 	bl	8006044 <VNAShell_parceLine>
  if (scp && (scp->flags & CMD_RUN_IN_LOAD))
 80095a0:	b140      	cbz	r0, 80095b4 <VNAShell_executeCMDLine+0x20>
 80095a2:	8903      	ldrh	r3, [r0, #8]
 80095a4:	071b      	lsls	r3, r3, #28
 80095a6:	d505      	bpl.n	80095b4 <VNAShell_executeCMDLine+0x20>
    scp->sc_function(shell_nargs - 1, &shell_args[1]);
 80095a8:	4a05      	ldr	r2, [pc, #20]	@ (80095c0 <VNAShell_executeCMDLine+0x2c>)
 80095aa:	6843      	ldr	r3, [r0, #4]
 80095ac:	8810      	ldrh	r0, [r2, #0]
 80095ae:	4905      	ldr	r1, [pc, #20]	@ (80095c4 <VNAShell_executeCMDLine+0x30>)
 80095b0:	3801      	subs	r0, #1
 80095b2:	4798      	blx	r3
  PREPARE_STREAM;
 80095b4:	4b04      	ldr	r3, [pc, #16]	@ (80095c8 <VNAShell_executeCMDLine+0x34>)
 80095b6:	6023      	str	r3, [r4, #0]
}
 80095b8:	bd10      	pop	{r4, pc}
 80095ba:	bf00      	nop
 80095bc:	200068ec 	.word	0x200068ec
 80095c0:	2000688c 	.word	0x2000688c
 80095c4:	20006894 	.word	0x20006894
 80095c8:	20000574 	.word	0x20000574

080095cc <main>:
// Main thread stack size defined in makefile USE_PROCESS_STACKSIZE = 0x200
// Profile stack usage (enable threads command by def ENABLE_THREADS_COMMAND) show:
// Stack maximum usage = 472 bytes (need test more and run all commands), free stack = 40 bytes
//
int main(void)
{
 80095cc:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80095d0:	b087      	sub	sp, #28
  /*
   * Initialize ChibiOS systems
   */
  halInit();
 80095d2:	f7f7 fcdf 	bl	8000f94 <halInit>
  chSysInit();
 80095d6:	f7f7 f9ef 	bl	80009b8 <chSysInit>
   * Init used hardware
   */
  /*
   *  Init DMA channels (used for direct send data, used for i2s and spi)
   */
  rccEnableDMA1(false);
 80095da:	4aa3      	ldr	r2, [pc, #652]	@ (8009868 <main+0x29c>)
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 80095dc:	4ea3      	ldr	r6, [pc, #652]	@ (800986c <main+0x2a0>)
  rccEnableDMA1(false);
 80095de:	6953      	ldr	r3, [r2, #20]
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 80095e0:	4ca3      	ldr	r4, [pc, #652]	@ (8009870 <main+0x2a4>)
  current_props._frequency1 = 900000000; // end   = 900MHz
 80095e2:	f8df 82fc 	ldr.w	r8, [pc, #764]	@ 80098e0 <main+0x314>
  rccEnableDMA1(false);
 80095e6:	f043 0301 	orr.w	r3, r3, #1
 80095ea:	6153      	str	r3, [r2, #20]

/*
 * Init GPIO (pin control)
 */
#if HAL_USE_PAL == FALSE
  initPal();
 80095ec:	f008 fc94 	bl	8011f18 <initPal>

/*
 * Initialize RTC library (not used ChibiOS RTC module)
 */
#ifdef __USE_RTC__
  rtc_init();
 80095f0:	f008 fb96 	bl	8011d20 <rtc_init>

/*
 * Starting DAC1 driver, setting up the output pin as analog as suggested by the Reference Manual.
 */
#if defined(__VNA_ENABLE_DAC__) || defined(__LCD_BRIGHTNESS__)
  dac_init();
 80095f4:	f008 fc04 	bl	8011e00 <dac_init>
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 80095f8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80095fa:	f104 0528 	add.w	r5, r4, #40	@ 0x28
 80095fe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8009600:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8009602:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8009604:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 8009608:	f8df e2d8 	ldr.w	lr, [pc, #728]	@ 80098e4 <main+0x318>
  current_props._portz = 50.0f;
 800960c:	eddf 7a99 	vldr	s15, [pc, #612]	@ 8009874 <main+0x2a8>
 8009610:	4e99      	ldr	r6, [pc, #612]	@ (8009878 <main+0x2ac>)
  memcpy(current_props._trace, def_trace, sizeof(def_trace));
 8009612:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 8009616:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800961a:	f104 0c58 	add.w	ip, r4, #88	@ 0x58
 800961e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8009622:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8009626:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
  current_props.magic = PROPERTIES_MAGIC;
 800962a:	4b94      	ldr	r3, [pc, #592]	@ (800987c <main+0x2b0>)
 800962c:	6023      	str	r3, [r4, #0]
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 800962e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8009632:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8009636:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
  current_props._electrical_delay[0] = 0.0f;
 800963a:	f04f 0b00 	mov.w	fp, #0
  memcpy(current_props._markers, def_markers, sizeof(def_markers));
 800963e:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  current_props._frequency0 = 50000;     // start =  50kHz
 8009642:	f24c 3950 	movw	r9, #50000	@ 0xc350
  current_props._mode = 0;
 8009646:	4b8e      	ldr	r3, [pc, #568]	@ (8009880 <main+0x2b4>)
  current_props._portz = 50.0f;
 8009648:	edc4 7a2b 	vstr	s15, [r4, #172]	@ 0xac
  current_props._reserved = 0;
 800964c:	f44f 4a8c 	mov.w	sl, #17920	@ 0x4600
  current_props._cal_load_r = 50.0f;
 8009650:	edc4 7a2c 	vstr	s15, [r4, #176]	@ 0xb0
  current_props._reserved = 0;
 8009654:	f8a4 a098 	strh.w	sl, [r4, #152]	@ 0x98
  current_props._electrical_delay[0] = 0.0f;
 8009658:	f8c4 b09c 	str.w	fp, [r4, #156]	@ 0x9c
  current_props._electrical_delay[1] = 0.0f;
 800965c:	f8c4 b0a0 	str.w	fp, [r4, #160]	@ 0xa0
  current_props._var_delay = 0.0f;
 8009660:	f8c4 b0a4 	str.w	fp, [r4, #164]	@ 0xa4
  current_props._s21_offset = 0.0f;
 8009664:	f8c4 b0a8 	str.w	fp, [r4, #168]	@ 0xa8
  current_props._frequency0 = 50000;     // start =  50kHz
 8009668:	f8c4 9004 	str.w	r9, [r4, #4]
  current_props._mode = 0;
 800966c:	61a3      	str	r3, [r4, #24]
  current_props._power = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 800966e:	4b85      	ldr	r3, [pc, #532]	@ (8009884 <main+0x2b8>)
  current_props._cal_frequency0 = 50000;     // calibration start =  50kHz
 8009670:	f8c4 900c 	str.w	r9, [r4, #12]
  current_props._var_freq = 0;
 8009674:	2700      	movs	r7, #0
  current_props._power = SI5351_CLK_DRIVE_STRENGTH_AUTO;
 8009676:	f06f 00ff 	mvn.w	r0, #255	@ 0xff
 800967a:	e9c4 0307 	strd	r0, r3, [r4, #28]
  current_props._var_freq = 0;
 800967e:	e9c4 8704 	strd	r8, r7, [r4, #16]
  current_props._frequency1 = 900000000; // end   = 900MHz
 8009682:	f8c4 8008 	str.w	r8, [r4, #8]
  current_props._cal_sweep_points = 401;     // Set calibration default points count
 8009686:	84a7      	strh	r7, [r4, #36]	@ 0x24
  config_recall();
 8009688:	f008 f87e 	bl	8011788 <config_recall>
  load_properties(0);
 800968c:	4638      	mov	r0, r7
 800968e:	f7fe f933 	bl	80078f8 <load_properties>
  load_settings();

  /*
   * MLA Toolbox: force startup sweep range to 330 MHz
   */
  set_sweep_frequency(ST_START, 3000000); // 3 MHz
 8009692:	4638      	mov	r0, r7
 8009694:	497c      	ldr	r1, [pc, #496]	@ (8009888 <main+0x2bc>)

/*
 * Set frequency offset
 */
#ifdef USE_VARIABLE_OFFSET
  si5351_set_frequency_offset(IF_OFFSET);
 8009696:	4c7d      	ldr	r4, [pc, #500]	@ (800988c <main+0x2c0>)
 8009698:	4d7d      	ldr	r5, [pc, #500]	@ (8009890 <main+0x2c4>)
 800969a:	f8df 924c 	ldr.w	r9, [pc, #588]	@ 80098e8 <main+0x31c>
 800969e:	f8df b24c 	ldr.w	fp, [pc, #588]	@ 80098ec <main+0x320>
 80096a2:	f8df 824c 	ldr.w	r8, [pc, #588]	@ 80098f0 <main+0x324>
 80096a6:	f8df a24c 	ldr.w	sl, [pc, #588]	@ 80098f4 <main+0x328>
  set_sweep_frequency(ST_START, 3000000); // 3 MHz
 80096aa:	f7fe fa13 	bl	8007ad4 <set_sweep_frequency>
  set_sweep_frequency(ST_STOP, 30000000); // 30 MHz
 80096ae:	4979      	ldr	r1, [pc, #484]	@ (8009894 <main+0x2c8>)
 80096b0:	2001      	movs	r0, #1
 80096b2:	f7fe fa0f 	bl	8007ad4 <set_sweep_frequency>
  set_sweep_points(401);
 80096b6:	f240 1091 	movw	r0, #401	@ 0x191
 80096ba:	f7fe f951 	bl	8007960 <set_sweep_points>
  set_trace_enable(1, false); // disable S21 logmag
 80096be:	4639      	mov	r1, r7
 80096c0:	2001      	movs	r0, #1
 80096c2:	f7ff fd6d 	bl	80091a0 <set_trace_enable>
  set_trace_enable(2, false); // disable S11 smith
 80096c6:	4639      	mov	r1, r7
 80096c8:	2002      	movs	r0, #2
 80096ca:	f7ff fd69 	bl	80091a0 <set_trace_enable>
  set_active_trace(0);        // make sure S11 logmag is the active trace
 80096ce:	4638      	mov	r0, r7
 80096d0:	f7fe fcb8 	bl	8008044 <set_active_trace>
  set_trace_type(3, TRC_SWR, 0); // TRC_SWR on channel 0 (S11)
 80096d4:	463a      	mov	r2, r7
 80096d6:	2106      	movs	r1, #6
 80096d8:	2003      	movs	r0, #3
 80096da:	f7fe fce9 	bl	80080b0 <set_trace_type>
  i2c_start();
 80096de:	f008 fa67 	bl	8011bb0 <i2c_start>
  si5351_init();
 80096e2:	f000 fd59 	bl	800a198 <si5351_init>
  si5351_set_frequency_offset(IF_OFFSET);
 80096e6:	68a0      	ldr	r0, [r4, #8]
 80096e8:	f000 fa7e 	bl	8009be8 <si5351_set_frequency_offset>
 80096ec:	4b6a      	ldr	r3, [pc, #424]	@ (8009898 <main+0x2cc>)
  sduObjectInit(&SDU1);
 80096ee:	486b      	ldr	r0, [pc, #428]	@ (800989c <main+0x2d0>)
  tqp->prev = (thread_t *)tqp;
 80096f0:	e9c3 3300 	strd	r3, r3, [r3]
 80096f4:	f7f7 ffec 	bl	80016d0 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 80096f8:	4969      	ldr	r1, [pc, #420]	@ (80098a0 <main+0x2d4>)
 80096fa:	4868      	ldr	r0, [pc, #416]	@ (800989c <main+0x2d0>)
 80096fc:	f7f8 f80c 	bl	8001718 <sduStart>
  SerialConfig s_config = {config._serial_speed, 0, USART_CR2_STOP1_BITS, 0};
 8009700:	6e23      	ldr	r3, [r4, #96]	@ 0x60
  sdStart(&SD1, &s_config);
 8009702:	4868      	ldr	r0, [pc, #416]	@ (80098a4 <main+0x2d8>)
  SerialConfig s_config = {config._serial_speed, 0, USART_CR2_STOP1_BITS, 0};
 8009704:	9302      	str	r3, [sp, #8]
  sdStart(&SD1, &s_config);
 8009706:	a902      	add	r1, sp, #8
  SerialConfig s_config = {config._serial_speed, 0, USART_CR2_STOP1_BITS, 0};
 8009708:	e9cd 7703 	strd	r7, r7, [sp, #12]
 800970c:	9705      	str	r7, [sp, #20]
  sdStart(&SD1, &s_config);
 800970e:	f7f7 ff59 	bl	80015c4 <sdStart>
  shell_update_speed(config._serial_speed);
 8009712:	6e20      	ldr	r0, [r4, #96]	@ 0x60
 8009714:	f7ff fef2 	bl	80094fc <shell_update_speed>
  usbDisconnectBus(&USBD1);
 8009718:	210c      	movs	r1, #12
 800971a:	2201      	movs	r2, #1
 800971c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8009720:	f008 fc54 	bl	8011fcc <palSetPadMode>
 8009724:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
 8009728:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 800972c:	6193      	str	r3, [r2, #24]
  chThdSleepMilliseconds(100);
 800972e:	f242 7010 	movw	r0, #10000	@ 0x2710
 8009732:	f7f7 fbad 	bl	8000e90 <chThdSleep>
  usbStart(&USBD1, &usbcfg);
 8009736:	495c      	ldr	r1, [pc, #368]	@ (80098a8 <main+0x2dc>)
 8009738:	485c      	ldr	r0, [pc, #368]	@ (80098ac <main+0x2e0>)
 800973a:	f7f8 f8ef 	bl	800191c <usbStart>
  usbConnectBus(&USBD1);
 800973e:	f240 7202 	movw	r2, #1794	@ 0x702
 8009742:	210c      	movs	r1, #12
 8009744:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8009748:	f008 fc40 	bl	8011fcc <palSetPadMode>
  shell_reset_console();
 800974c:	f7ff fefa 	bl	8009544 <shell_reset_console>
   * Init Shell console connection data
   */
  shell_init_connection();

#ifdef __USE_SERIAL_CONSOLE__
  serial_shell_printf("\r\n[MLA ToolBox] NanoVNA H4 Booting...\r\n");
 8009750:	4857      	ldr	r0, [pc, #348]	@ (80098b0 <main+0x2e4>)
 8009752:	f7fc f903 	bl	800595c <serial_shell_printf>
#endif

  /*
   * SPI bus and LCD Initialize
   */
  lcd_init();
 8009756:	f007 fc51 	bl	8010ffc <lcd_init>



   * tlv320aic Initialize (audio codec)
   */
  tlv320aic3204_init();
 800975a:	f000 fd49 	bl	800a1f0 <tlv320aic3204_init>
  chThdSleepMilliseconds(200); // Wait for aic codec start
 800975e:	f644 6020 	movw	r0, #20000	@ 0x4e20
 8009762:	f7f7 fb95 	bl	8000e90 <chThdSleep>
                               /*
                                * I2S Initialize
                                */
  initI2S(rx_buffer, ARRAY_COUNT(rx_buffer) * sizeof(audio_sample_t) / sizeof(int16_t));
 8009766:	21c0      	movs	r1, #192	@ 0xc0
 8009768:	4852      	ldr	r0, [pc, #328]	@ (80098b4 <main+0x2e8>)
 800976a:	f008 fb5f 	bl	8011e2c <initI2S>
/*
 * SD Card init (if inserted) allow fix issues
 * Some card after insert work in SDIO mode and can corrupt SPI exchange (need switch it to SPI)
 */
#ifdef __USE_SD_CARD__
  disk_initialize(0);
 800976e:	4638      	mov	r0, r7
 8009770:	f007 fe68 	bl	8011444 <disk_initialize>
#endif

  /*
   * I2C bus run on work speed
   */
  i2c_set_timings(STM32_I2C_TIMINGR);
 8009774:	4850      	ldr	r0, [pc, #320]	@ (80098b8 <main+0x2ec>)
 8009776:	f008 fa0d 	bl	8011b94 <i2c_set_timings>

  /*
   * Startup sweep thread
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO - 1, Thread1, NULL);
 800977a:	4b50      	ldr	r3, [pc, #320]	@ (80098bc <main+0x2f0>)
 800977c:	9700      	str	r7, [sp, #0]
 800977e:	227f      	movs	r2, #127	@ 0x7f
 8009780:	f44f 61a5 	mov.w	r1, #1320	@ 0x528
 8009784:	484e      	ldr	r0, [pc, #312]	@ (80098c0 <main+0x2f4>)
 8009786:	4f4f      	ldr	r7, [pc, #316]	@ (80098c4 <main+0x2f8>)
 8009788:	f7f7 fb46 	bl	8000e18 <chThdCreateStatic>

  while (1)
  {
    if (shell_check_connect())
    {
      shell_printf(VNA_SHELL_NEWLINE_STR "NanoVNA Shell" VNA_SHELL_NEWLINE_STR);
 800978c:	484e      	ldr	r0, [pc, #312]	@ (80098c8 <main+0x2fc>)
 800978e:	f7fc fc47 	bl	8006020 <shell_printf>
                                            myshellThread, NULL);
      chThdWait(shelltp);
#else
      do
      {
        shell_printf(VNA_SHELL_PROMPT_STR);
 8009792:	484e      	ldr	r0, [pc, #312]	@ (80098cc <main+0x300>)
 8009794:	f7fc fc44 	bl	8006020 <shell_printf>
  uint16_t j = 0;
 8009798:	2400      	movs	r4, #0
static int shell_read(void *buf, uint32_t size) { return streamRead(shell_stream, buf, size); }
 800979a:	6828      	ldr	r0, [r5, #0]
 800979c:	6803      	ldr	r3, [r0, #0]
 800979e:	2201      	movs	r2, #1
 80097a0:	685b      	ldr	r3, [r3, #4]
 80097a2:	a902      	add	r1, sp, #8
 80097a4:	4798      	blx	r3
  while (shell_read(&c, 1))
 80097a6:	2800      	cmp	r0, #0
 80097a8:	d046      	beq.n	8009838 <main+0x26c>
    if (c == 0x08 || c == 0x7f)
 80097aa:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80097ae:	2b08      	cmp	r3, #8
 80097b0:	d012      	beq.n	80097d8 <main+0x20c>
 80097b2:	2b7f      	cmp	r3, #127	@ 0x7f
 80097b4:	d010      	beq.n	80097d8 <main+0x20c>
    if (c == '\r')
 80097b6:	2b0d      	cmp	r3, #13
 80097b8:	d017      	beq.n	80097ea <main+0x21e>
    if (c < ' ' || j >= max_size - 1)
 80097ba:	2b1f      	cmp	r3, #31
 80097bc:	d9ed      	bls.n	800979a <main+0x1ce>
 80097be:	2c3e      	cmp	r4, #62	@ 0x3e
    shell_write(&c, 1); // Echo
 80097c0:	f04f 0101 	mov.w	r1, #1
 80097c4:	a802      	add	r0, sp, #8
    if (c < ' ' || j >= max_size - 1)
 80097c6:	d8e8      	bhi.n	800979a <main+0x1ce>
    shell_write(&c, 1); // Echo
 80097c8:	f7fb fea4 	bl	8005514 <shell_write>
    line[j++] = (char)c;
 80097cc:	f89d 2008 	ldrb.w	r2, [sp, #8]
 80097d0:	5532      	strb	r2, [r6, r4]
 80097d2:	1c63      	adds	r3, r4, #1
 80097d4:	b29c      	uxth	r4, r3
 80097d6:	e7e0      	b.n	800979a <main+0x1ce>
      if (j > 0)
 80097d8:	2c00      	cmp	r4, #0
 80097da:	d0de      	beq.n	800979a <main+0x1ce>
        shell_write(backspace, sizeof(backspace));
 80097dc:	483c      	ldr	r0, [pc, #240]	@ (80098d0 <main+0x304>)
 80097de:	2104      	movs	r1, #4
        j--;
 80097e0:	3c01      	subs	r4, #1
        shell_write(backspace, sizeof(backspace));
 80097e2:	f7fb fe97 	bl	8005514 <shell_write>
        j--;
 80097e6:	b2a4      	uxth	r4, r4
 80097e8:	e7d7      	b.n	800979a <main+0x1ce>
      shell_printf(VNA_SHELL_NEWLINE_STR);
 80097ea:	483a      	ldr	r0, [pc, #232]	@ (80098d4 <main+0x308>)
 80097ec:	f7fc fc18 	bl	8006020 <shell_printf>
      line[j] = 0;
 80097f0:	2300      	movs	r3, #0
 80097f2:	5533      	strb	r3, [r6, r4]
  const VNAShellCommand *scp = VNAShell_parceLine(line);
 80097f4:	4820      	ldr	r0, [pc, #128]	@ (8009878 <main+0x2ac>)
 80097f6:	f7fc fc25 	bl	8006044 <VNAShell_parceLine>
  if (scp)
 80097fa:	b310      	cbz	r0, 8009842 <main+0x276>
    uint16_t cmd_flag = scp->flags;
 80097fc:	8903      	ldrh	r3, [r0, #8]
    if ((cmd_flag & CMD_RUN_IN_UI) && (sweep_mode & SWEEP_UI_MODE))
 80097fe:	0759      	lsls	r1, r3, #29
 8009800:	f003 0202 	and.w	r2, r3, #2
 8009804:	d503      	bpl.n	800980e <main+0x242>
 8009806:	f999 1000 	ldrsb.w	r1, [r9]
 800980a:	2900      	cmp	r1, #0
 800980c:	db0d      	blt.n	800982a <main+0x25e>
    if (scp->flags & CMD_BREAK_SWEEP)
 800980e:	b11a      	cbz	r2, 8009818 <main+0x24c>
      operation_requested |= OP_CONSOLE;
 8009810:	783a      	ldrb	r2, [r7, #0]
 8009812:	f042 0204 	orr.w	r2, r2, #4
 8009816:	703a      	strb	r2, [r7, #0]
    if (cmd_flag & CMD_WAIT_MUTEX)
 8009818:	07db      	lsls	r3, r3, #31
 800981a:	d41b      	bmi.n	8009854 <main+0x288>
      scp->sc_function(shell_nargs - 1, &shell_args[1]);
 800981c:	f8b8 2000 	ldrh.w	r2, [r8]
 8009820:	6843      	ldr	r3, [r0, #4]
 8009822:	492d      	ldr	r1, [pc, #180]	@ (80098d8 <main+0x30c>)
 8009824:	1e50      	subs	r0, r2, #1
 8009826:	4798      	blx	r3
 8009828:	e7b3      	b.n	8009792 <main+0x1c6>
    if (scp->flags & CMD_BREAK_SWEEP)
 800982a:	2a00      	cmp	r2, #0
 800982c:	d0f6      	beq.n	800981c <main+0x250>
      operation_requested |= OP_CONSOLE;
 800982e:	783b      	ldrb	r3, [r7, #0]
 8009830:	f043 0304 	orr.w	r3, r3, #4
 8009834:	703b      	strb	r3, [r7, #0]
    if (cmd_flag & CMD_WAIT_MUTEX)
 8009836:	e7f1      	b.n	800981c <main+0x250>
        if (VNAShell_readLine(shell_line, VNA_SHELL_MAX_LENGTH))
          VNAShell_executeLine(shell_line);
        else
          chThdSleepMilliseconds(200);
 8009838:	f644 6020 	movw	r0, #20000	@ 0x4e20
 800983c:	f7f7 fb28 	bl	8000e90 <chThdSleep>
 8009840:	e7a7      	b.n	8009792 <main+0x1c6>
  else if (**shell_args) // unknown command (not empty), ignore <CR>
 8009842:	f8da 1000 	ldr.w	r1, [sl]
 8009846:	780b      	ldrb	r3, [r1, #0]
 8009848:	2b00      	cmp	r3, #0
 800984a:	d0a2      	beq.n	8009792 <main+0x1c6>
    shell_printf("%s?" VNA_SHELL_NEWLINE_STR, shell_args[0]);
 800984c:	4823      	ldr	r0, [pc, #140]	@ (80098dc <main+0x310>)
 800984e:	f7fc fbe7 	bl	8006020 <shell_printf>
 8009852:	e79e      	b.n	8009792 <main+0x1c6>
      shell_function = scp->sc_function;
 8009854:	6843      	ldr	r3, [r0, #4]
  return chThdEnqueueTimeoutS(tqp, time);
 8009856:	4810      	ldr	r0, [pc, #64]	@ (8009898 <main+0x2cc>)
 8009858:	f8cb 3000 	str.w	r3, [fp]
 800985c:	f04f 31ff 	mov.w	r1, #4294967295
 8009860:	f7f7 fb22 	bl	8000ea8 <chThdEnqueueTimeoutS>
 8009864:	e795      	b.n	8009792 <main+0x1c6>
 8009866:	bf00      	nop
 8009868:	40021000 	.word	0x40021000
 800986c:	08015f1c 	.word	0x08015f1c
 8009870:	20000aa8 	.word	0x20000aa8
 8009874:	42480000 	.word	0x42480000
 8009878:	200068a4 	.word	0x200068a4
 800987c:	434f4e54 	.word	0x434f4e54
 8009880:	01910000 	.word	0x01910000
 8009884:	019100ff 	.word	0x019100ff
 8009888:	002dc6c0 	.word	0x002dc6c0
 800988c:	20000318 	.word	0x20000318
 8009890:	200068ec 	.word	0x200068ec
 8009894:	01c9c380 	.word	0x01c9c380
 8009898:	200068e4 	.word	0x200068e4
 800989c:	200007b0 	.word	0x200007b0
 80098a0:	08015964 	.word	0x08015964
 80098a4:	20000574 	.word	0x20000574
 80098a8:	0801596c 	.word	0x0801596c
 80098ac:	20000650 	.word	0x20000650
 80098b0:	08013878 	.word	0x08013878
 80098b4:	20000918 	.word	0x20000918
 80098b8:	00aa2841 	.word	0x00aa2841
 80098bc:	08008111 	.word	0x08008111
 80098c0:	20004a28 	.word	0x20004a28
 80098c4:	20008a23 	.word	0x20008a23
 80098c8:	080138a0 	.word	0x080138a0
 80098cc:	080138b4 	.word	0x080138b4
 80098d0:	08015cd4 	.word	0x08015cd4
 80098d4:	08013860 	.word	0x08013860
 80098d8:	20006894 	.word	0x20006894
 80098dc:	080138bc 	.word	0x080138bc
 80098e0:	35a4e900 	.word	0x35a4e900
 80098e4:	08015edc 	.word	0x08015edc
 80098e8:	200003c4 	.word	0x200003c4
 80098ec:	20006888 	.word	0x20006888
 80098f0:	2000688c 	.word	0x2000688c
 80098f4:	20006890 	.word	0x20006890

080098f8 <my_atoi>:
// Use macro, std isdigit more big
#define _isdigit(c) (c >= '0' && c <= '9')
// Rewrite universal standart str to value functions to more compact
//
// Convert string to int32
int32_t my_atoi(const char *p) {
 80098f8:	b510      	push	{r4, lr}
  int32_t value = 0;
  uint32_t c;
  bool neg = false;

  if (*p == '-') {neg = true; p++;}
 80098fa:	7802      	ldrb	r2, [r0, #0]
int32_t my_atoi(const char *p) {
 80098fc:	4603      	mov	r3, r0
  if (*p == '-') {neg = true; p++;}
 80098fe:	2a2d      	cmp	r2, #45	@ 0x2d
 8009900:	bf04      	itt	eq
 8009902:	3301      	addeq	r3, #1
 8009904:	2101      	moveq	r1, #1
  if (*p == '+') p++;
 8009906:	781a      	ldrb	r2, [r3, #0]
  bool neg = false;
 8009908:	bf18      	it	ne
 800990a:	2100      	movne	r1, #0
  if (*p == '+') p++;
 800990c:	2a2b      	cmp	r2, #43	@ 0x2b
 800990e:	bf08      	it	eq
 8009910:	3301      	addeq	r3, #1
  if (*p == '-') {neg = true; p++;}
 8009912:	2000      	movs	r0, #0
  while ((c = *p++ - '0') < 10)
    value = value * 10 + c;
 8009914:	240a      	movs	r4, #10
  while ((c = *p++ - '0') < 10)
 8009916:	f813 2b01 	ldrb.w	r2, [r3], #1
 800991a:	3a30      	subs	r2, #48	@ 0x30
 800991c:	2a09      	cmp	r2, #9
 800991e:	d802      	bhi.n	8009926 <my_atoi+0x2e>
    value = value * 10 + c;
 8009920:	fb04 2000 	mla	r0, r4, r0, r2
 8009924:	e7f7      	b.n	8009916 <my_atoi+0x1e>
  return neg ? -value : value;
 8009926:	b101      	cbz	r1, 800992a <my_atoi+0x32>
 8009928:	4240      	negs	r0, r0
}
 800992a:	bd10      	pop	{r4, pc}

0800992c <my_atoui>:
//  0o - for oct radix
//  0b - for bin radix
//  default dec radix
uint32_t my_atoui(const char *p) {
  uint32_t value = 0, radix = 10, c;
  if (*p == '+') p++;
 800992c:	7802      	ldrb	r2, [r0, #0]
uint32_t my_atoui(const char *p) {
 800992e:	4603      	mov	r3, r0
  if (*p == '+') p++;
 8009930:	2a2b      	cmp	r2, #43	@ 0x2b
 8009932:	bf08      	it	eq
 8009934:	3301      	addeq	r3, #1
  if (*p == '0') {
 8009936:	781a      	ldrb	r2, [r3, #0]
 8009938:	2a30      	cmp	r2, #48	@ 0x30
 800993a:	d10d      	bne.n	8009958 <my_atoui+0x2c>
    switch (p[1]) {
 800993c:	785a      	ldrb	r2, [r3, #1]
 800993e:	2a6f      	cmp	r2, #111	@ 0x6f
 8009940:	d005      	beq.n	800994e <my_atoui+0x22>
 8009942:	2a78      	cmp	r2, #120	@ 0x78
 8009944:	d005      	beq.n	8009952 <my_atoui+0x26>
 8009946:	2a62      	cmp	r2, #98	@ 0x62
 8009948:	d106      	bne.n	8009958 <my_atoui+0x2c>
      case 'x': radix = 16; break;
      case 'o': radix =  8; break;
      case 'b': radix =  2; break;
 800994a:	2102      	movs	r1, #2
 800994c:	e002      	b.n	8009954 <my_atoui+0x28>
    switch (p[1]) {
 800994e:	2108      	movs	r1, #8
 8009950:	e000      	b.n	8009954 <my_atoui+0x28>
      case 'x': radix = 16; break;
 8009952:	2110      	movs	r1, #16
      default:  goto calculate;
    }
    p+=2;
 8009954:	3302      	adds	r3, #2
 8009956:	e000      	b.n	800995a <my_atoui+0x2e>
    switch (p[1]) {
 8009958:	210a      	movs	r1, #10
  }
calculate:
 800995a:	2000      	movs	r0, #0
  while (1) {
    c = *p++ - '0';
 800995c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8009960:	3a30      	subs	r2, #48	@ 0x30
    // c = to_upper(*p) - 'A' + 10
    if (c >= 'A' - '0') c = (c&(~0x20)) - ('A' - '0') + 10;
 8009962:	2a10      	cmp	r2, #16
 8009964:	bf84      	itt	hi
 8009966:	f022 0220 	bichi.w	r2, r2, #32
 800996a:	3a07      	subhi	r2, #7
    if (c >= radix) return value;
 800996c:	428a      	cmp	r2, r1
 800996e:	d202      	bcs.n	8009976 <my_atoui+0x4a>
    value = value * radix + c;
 8009970:	fb01 2000 	mla	r0, r1, r0, r2
    c = *p++ - '0';
 8009974:	e7f2      	b.n	800995c <my_atoui+0x30>
  }
}
 8009976:	4770      	bx	lr

08009978 <my_atof>:

float my_atof(const char *p) {
 8009978:	b538      	push	{r3, r4, r5, lr}
  int neg = false;
  if (*p == '-')
 800997a:	7803      	ldrb	r3, [r0, #0]
 800997c:	2b2d      	cmp	r3, #45	@ 0x2d
float my_atof(const char *p) {
 800997e:	4604      	mov	r4, r0
  if (*p == '-')
 8009980:	d004      	beq.n	800998c <my_atof+0x14>
    neg = true;
  if (*p == '-' || *p == '+')
 8009982:	2b2b      	cmp	r3, #43	@ 0x2b
  int neg = false;
 8009984:	f04f 0500 	mov.w	r5, #0
  if (*p == '-' || *p == '+')
 8009988:	d102      	bne.n	8009990 <my_atof+0x18>
 800998a:	e000      	b.n	800998e <my_atof+0x16>
    neg = true;
 800998c:	2501      	movs	r5, #1
    p++;
 800998e:	3401      	adds	r4, #1
  float x = my_atoi(p);
 8009990:	4620      	mov	r0, r4
 8009992:	f7ff ffb1 	bl	80098f8 <my_atoi>
 8009996:	ee00 0a10 	vmov	s0, r0
 800999a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
  while (_isdigit((int)*p))
 800999e:	4620      	mov	r0, r4
 80099a0:	f814 3b01 	ldrb.w	r3, [r4], #1
 80099a4:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80099a8:	2a09      	cmp	r2, #9
 80099aa:	d9f8      	bls.n	800999e <my_atof+0x26>
    p++;
  if (*p == '.' || *p == ',') {
 80099ac:	f003 02fd 	and.w	r2, r3, #253	@ 0xfd
 80099b0:	2a2c      	cmp	r2, #44	@ 0x2c
 80099b2:	d115      	bne.n	80099e0 <my_atof+0x68>
    float d = 1.0f;
    p++;
    while (_isdigit((int)*p)) {
      d *= 1e-1f;
 80099b4:	eddf 6a2c 	vldr	s13, [pc, #176]	@ 8009a68 <my_atof+0xf0>
    p++;
 80099b8:	4621      	mov	r1, r4
    float d = 1.0f;
 80099ba:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80099be:	4608      	mov	r0, r1
    while (_isdigit((int)*p)) {
 80099c0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80099c4:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 80099c8:	b2d4      	uxtb	r4, r2
 80099ca:	2c09      	cmp	r4, #9
 80099cc:	d808      	bhi.n	80099e0 <my_atof+0x68>
      x += d * (*p - '0');
 80099ce:	ee07 2a90 	vmov	s15, r2
      d *= 1e-1f;
 80099d2:	ee27 7a26 	vmul.f32	s14, s14, s13
      x += d * (*p - '0');
 80099d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80099da:	eea7 0a87 	vfma.f32	s0, s15, s14
      p++;
 80099de:	e7ee      	b.n	80099be <my_atof+0x46>
    }
  }
  if (*p) {
 80099e0:	1e5a      	subs	r2, r3, #1
 80099e2:	2a74      	cmp	r2, #116	@ 0x74
 80099e4:	d83b      	bhi.n	8009a5e <my_atof+0xe6>
    int exp = 0;
    if (*p == 'e' || *p == 'E') exp = my_atoi(&p[1]);
 80099e6:	2b64      	cmp	r3, #100	@ 0x64
 80099e8:	d806      	bhi.n	80099f8 <my_atof+0x80>
 80099ea:	2b47      	cmp	r3, #71	@ 0x47
 80099ec:	d01b      	beq.n	8009a26 <my_atof+0xae>
 80099ee:	2b4d      	cmp	r3, #77	@ 0x4d
 80099f0:	d01b      	beq.n	8009a2a <my_atof+0xb2>
 80099f2:	2b45      	cmp	r3, #69	@ 0x45
 80099f4:	d011      	beq.n	8009a1a <my_atof+0xa2>
 80099f6:	e032      	b.n	8009a5e <my_atof+0xe6>
 80099f8:	3b65      	subs	r3, #101	@ 0x65
 80099fa:	2b10      	cmp	r3, #16
 80099fc:	d82f      	bhi.n	8009a5e <my_atof+0xe6>
 80099fe:	e8df f003 	tbb	[pc, r3]
 8009a02:	2e0c      	.short	0x2e0c
 8009a04:	2e2e2e2e 	.word	0x2e2e2e2e
 8009a08:	09212e16 	.word	0x09212e16
 8009a0c:	2e2e1e2e 	.word	0x2e2e1e2e
 8009a10:	2e2e      	.short	0x2e2e
 8009a12:	26          	.byte	0x26
 8009a13:	00          	.byte	0x00
  if (*p) {
 8009a14:	f06f 0008 	mvn.w	r0, #8
 8009a18:	e01b      	b.n	8009a52 <my_atof+0xda>
    if (*p == 'e' || *p == 'E') exp = my_atoi(&p[1]);
 8009a1a:	3001      	adds	r0, #1
 8009a1c:	f7ff ff6c 	bl	80098f8 <my_atoi>
    else if (*p == 'k') exp =  3; // kilo
    else if (*p == 'm') exp = -3; // milli
    else if (*p == 'u') exp = -6; // micro
    else if (*p == 'n') exp = -9; // nano
    else if (*p == 'p') exp =-12; // pico
    if (exp > 0) do {x*= 1e+1f;} while (--exp);
 8009a20:	2800      	cmp	r0, #0
 8009a22:	dd12      	ble.n	8009a4a <my_atof+0xd2>
 8009a24:	e004      	b.n	8009a30 <my_atof+0xb8>
  if (*p) {
 8009a26:	2009      	movs	r0, #9
 8009a28:	e002      	b.n	8009a30 <my_atof+0xb8>
 8009a2a:	2006      	movs	r0, #6
 8009a2c:	e000      	b.n	8009a30 <my_atof+0xb8>
 8009a2e:	2003      	movs	r0, #3
    if (exp > 0) do {x*= 1e+1f;} while (--exp);
 8009a30:	eef2 7a04 	vmov.f32	s15, #36	@ 0x41200000  10.0
 8009a34:	3801      	subs	r0, #1
 8009a36:	ee20 0a27 	vmul.f32	s0, s0, s15
 8009a3a:	d1fb      	bne.n	8009a34 <my_atof+0xbc>
 8009a3c:	e00f      	b.n	8009a5e <my_atof+0xe6>
    else if (*p == 'p') exp =-12; // pico
 8009a3e:	f06f 000b 	mvn.w	r0, #11
 8009a42:	e006      	b.n	8009a52 <my_atof+0xda>
  if (*p) {
 8009a44:	f06f 0002 	mvn.w	r0, #2
 8009a48:	e003      	b.n	8009a52 <my_atof+0xda>
    if (exp < 0) do {x*= 1e-1f;} while (++exp);
 8009a4a:	d008      	beq.n	8009a5e <my_atof+0xe6>
 8009a4c:	e001      	b.n	8009a52 <my_atof+0xda>
  if (*p) {
 8009a4e:	f06f 0005 	mvn.w	r0, #5
    if (exp < 0) do {x*= 1e-1f;} while (++exp);
 8009a52:	eddf 7a05 	vldr	s15, [pc, #20]	@ 8009a68 <my_atof+0xf0>
 8009a56:	3001      	adds	r0, #1
 8009a58:	ee20 0a27 	vmul.f32	s0, s0, s15
 8009a5c:	d1fb      	bne.n	8009a56 <my_atof+0xde>
  }
  return neg ? -x : x;
 8009a5e:	b10d      	cbz	r5, 8009a64 <my_atof+0xec>
 8009a60:	eeb1 0a40 	vneg.f32	s0, s0
}
 8009a64:	bd38      	pop	{r3, r4, r5, pc}
 8009a66:	bf00      	nop
 8009a68:	3dcccccd 	.word	0x3dcccccd

08009a6c <strcmpi>:

static char to_lower(char c) {return (c >='A' && c <= 'Z') ? c - 'A' + 'a' : c;}
bool strcmpi(const char *t1, const char *t2) {
 8009a6c:	b510      	push	{r4, lr}
 8009a6e:	3801      	subs	r0, #1
 8009a70:	3901      	subs	r1, #1
  int i = 0;
  while (1) {
    char ch1 = to_lower(t1[i]), ch2 = to_lower(t2[i]);
 8009a72:	f810 3f01 	ldrb.w	r3, [r0, #1]!
static char to_lower(char c) {return (c >='A' && c <= 'Z') ? c - 'A' + 'a' : c;}
 8009a76:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
 8009a7a:	2a19      	cmp	r2, #25
    char ch1 = to_lower(t1[i]), ch2 = to_lower(t2[i]);
 8009a7c:	f811 2f01 	ldrb.w	r2, [r1, #1]!
static char to_lower(char c) {return (c >='A' && c <= 'Z') ? c - 'A' + 'a' : c;}
 8009a80:	bf98      	it	ls
 8009a82:	3320      	addls	r3, #32
 8009a84:	f1a2 0441 	sub.w	r4, r2, #65	@ 0x41
 8009a88:	bf98      	it	ls
 8009a8a:	b2db      	uxtbls	r3, r3
 8009a8c:	2c19      	cmp	r4, #25
 8009a8e:	d804      	bhi.n	8009a9a <strcmpi+0x2e>
 8009a90:	3220      	adds	r2, #32
    if (ch1 != ch2) return false;
 8009a92:	b2d2      	uxtb	r2, r2
 8009a94:	429a      	cmp	r2, r3
 8009a96:	d0ec      	beq.n	8009a72 <strcmpi+0x6>
 8009a98:	e005      	b.n	8009aa6 <strcmpi+0x3a>
 8009a9a:	429a      	cmp	r2, r3
 8009a9c:	d103      	bne.n	8009aa6 <strcmpi+0x3a>
    if (ch1 ==   0) return true;
 8009a9e:	2b00      	cmp	r3, #0
 8009aa0:	d1e7      	bne.n	8009a72 <strcmpi+0x6>
 8009aa2:	2001      	movs	r0, #1
 8009aa4:	e000      	b.n	8009aa8 <strcmpi+0x3c>
    if (ch1 != ch2) return false;
 8009aa6:	2000      	movs	r0, #0
    i++;
  }
}
 8009aa8:	bd10      	pop	{r4, pc}
	...

08009aac <get_str_index>:
//
// Function used for search substring v in list
// Example need search parameter "center" in "start|stop|center|span|cw" getStringIndex return 2
// If not found return -1
// Used for easy parse command arguments
int get_str_index(const char *v, const char *list) {
 8009aac:	b570      	push	{r4, r5, r6, lr}
 8009aae:	4604      	mov	r4, r0
  int i = 0;
 8009ab0:	2000      	movs	r0, #0
  while (1) {
    const char *p = v;
 8009ab2:	460b      	mov	r3, r1
 8009ab4:	1e65      	subs	r5, r4, #1
    while (1) {
      char c = *list;
 8009ab6:	781a      	ldrb	r2, [r3, #0]
      if (c == '|') c = 0;
      if (c == *p++) {
 8009ab8:	f815 6f01 	ldrb.w	r6, [r5, #1]!
      if (c == '|') c = 0;
 8009abc:	2a7c      	cmp	r2, #124	@ 0x7c
 8009abe:	bf08      	it	eq
 8009ac0:	2200      	moveq	r2, #0
      if (c == *p++) {
 8009ac2:	4296      	cmp	r6, r2
 8009ac4:	4619      	mov	r1, r3
 8009ac6:	f103 0301 	add.w	r3, r3, #1
 8009aca:	d101      	bne.n	8009ad0 <get_str_index+0x24>
        // Found, return index
        if (c == 0) return i;
 8009acc:	b14e      	cbz	r6, 8009ae2 <get_str_index+0x36>
 8009ace:	e7f2      	b.n	8009ab6 <get_str_index+0xa>
      break;  // Not equal, break
    }
    // Set new substring ptr
    while (1) {
      // End of string, not found
      if (*list == 0) return -1;
 8009ad0:	f811 3b01 	ldrb.w	r3, [r1], #1
 8009ad4:	b11b      	cbz	r3, 8009ade <get_str_index+0x32>
      if (*list++ == '|') break;
 8009ad6:	2b7c      	cmp	r3, #124	@ 0x7c
 8009ad8:	d1fa      	bne.n	8009ad0 <get_str_index+0x24>
    }
    i++;
 8009ada:	3001      	adds	r0, #1
  while (1) {
 8009adc:	e7e9      	b.n	8009ab2 <get_str_index+0x6>
      if (*list == 0) return -1;
 8009ade:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return -1;
}
 8009ae2:	bd70      	pop	{r4, r5, r6, pc}

08009ae4 <parse_line>:
}

/*
 * Split line by arguments, return arguments count
 */
int parse_line(char *line, char* args[], int max_cnt) {
 8009ae4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009ae8:	4603      	mov	r3, r0
  const char *brk;
  uint16_t nargs = 0;
  while ((c = *lp) != 0) {                   // While not end
    if (c != ' ' && c != '\t') {             // Skipping white space and tabs.
      if (c == '"') {lp++; brk = "\""; }     // string end is next quote or end
      else          {      brk = " \t";}     // string end is tab or space or end
 8009aea:	4e15      	ldr	r6, [pc, #84]	@ (8009b40 <parse_line+0x5c>)
      if (c == '"') {lp++; brk = "\""; }     // string end is next quote or end
 8009aec:	4d15      	ldr	r5, [pc, #84]	@ (8009b44 <parse_line+0x60>)
  uint16_t nargs = 0;
 8009aee:	2000      	movs	r0, #0
      if (nargs < max_cnt) args[nargs] = lp; // Put pointer in args buffer (if possible)
      nargs++;                               // Substring count
      lp = _strpbrk(lp, brk);                // search end
      if (*lp == 0) break;                   // Stop, end of input string
      *lp = 0;                               // Set zero at the end of substring
 8009af0:	4686      	mov	lr, r0
  while ((c = *lp) != 0) {                   // While not end
 8009af2:	781c      	ldrb	r4, [r3, #0]
 8009af4:	b314      	cbz	r4, 8009b3c <parse_line+0x58>
    if (c != ' ' && c != '\t') {             // Skipping white space and tabs.
 8009af6:	2c20      	cmp	r4, #32
 8009af8:	d01e      	beq.n	8009b38 <parse_line+0x54>
 8009afa:	2c09      	cmp	r4, #9
 8009afc:	d01c      	beq.n	8009b38 <parse_line+0x54>
      if (c == '"') {lp++; brk = "\""; }     // string end is next quote or end
 8009afe:	2c22      	cmp	r4, #34	@ 0x22
 8009b00:	bf06      	itte	eq
 8009b02:	3301      	addeq	r3, #1
 8009b04:	462c      	moveq	r4, r5
      else          {      brk = " \t";}     // string end is tab or space or end
 8009b06:	4634      	movne	r4, r6
      if (nargs < max_cnt) args[nargs] = lp; // Put pointer in args buffer (if possible)
 8009b08:	4290      	cmp	r0, r2
 8009b0a:	bfb8      	it	lt
 8009b0c:	f841 3020 	strlt.w	r3, [r1, r0, lsl #2]
      nargs++;                               // Substring count
 8009b10:	3001      	adds	r0, #1
 8009b12:	b280      	uxth	r0, r0
    while(*s) if (*s++ == *s1) return s1;
 8009b14:	1e67      	subs	r7, r4, #1
 8009b16:	f817 cf01 	ldrb.w	ip, [r7, #1]!
 8009b1a:	f1bc 0f00 	cmp.w	ip, #0
 8009b1e:	d006      	beq.n	8009b2e <parse_line+0x4a>
 8009b20:	f893 8000 	ldrb.w	r8, [r3]
 8009b24:	45e0      	cmp	r8, ip
 8009b26:	d1f6      	bne.n	8009b16 <parse_line+0x32>
      *lp = 0;                               // Set zero at the end of substring
 8009b28:	f883 e000 	strb.w	lr, [r3]
 8009b2c:	e004      	b.n	8009b38 <parse_line+0x54>
  } while(*++s1);
 8009b2e:	f813 7f01 	ldrb.w	r7, [r3, #1]!
 8009b32:	2f00      	cmp	r7, #0
 8009b34:	d1ee      	bne.n	8009b14 <parse_line+0x30>
 8009b36:	e001      	b.n	8009b3c <parse_line+0x58>
    }
    lp++;
 8009b38:	3301      	adds	r3, #1
 8009b3a:	e7da      	b.n	8009af2 <parse_line+0xe>
  }
  return nargs;
}
 8009b3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009b40:	08014853 	.word	0x08014853
 8009b44:	08014851 	.word	0x08014851

08009b48 <swap_bytes>:

/*
 * Swap byte order in uint16_t buffer
 */
void swap_bytes(uint16_t *buf, int size) {
  for (int i = 0; i < size; i++)
 8009b48:	3802      	subs	r0, #2
 8009b4a:	2300      	movs	r3, #0
 8009b4c:	428b      	cmp	r3, r1
 8009b4e:	da05      	bge.n	8009b5c <swap_bytes+0x14>
    \return               Reversed value
 */
__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
{
#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
  return (short)__builtin_bswap16(value);
 8009b50:	f830 2f02 	ldrh.w	r2, [r0, #2]!
 8009b54:	ba52      	rev16	r2, r2
    buf[i] = __REVSH(buf[i]); // swap byte order (example 0x10FF to 0xFF10)
 8009b56:	8002      	strh	r2, [r0, #0]
  for (int i = 0; i < size; i++)
 8009b58:	3301      	adds	r3, #1
 8009b5a:	e7f7      	b.n	8009b4c <swap_bytes+0x4>
}
 8009b5c:	4770      	bx	lr
	...

08009b60 <packbits>:

/*
 * RLE packbits compression algorithm
 */
int packbits(char *source, char *dest, int size) {
 8009b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  int i = 0, rle, l, pk = 0, sz = 0;
 8009b64:	2400      	movs	r4, #0
int packbits(char *source, char *dest, int size) {
 8009b66:	4605      	mov	r5, r0
  int i = 0, rle, l, pk = 0, sz = 0;
 8009b68:	4623      	mov	r3, r4
 8009b6a:	4620      	mov	r0, r4
  while ((l = size - i) > 0) {
 8009b6c:	eba2 0e03 	sub.w	lr, r2, r3
 8009b70:	f1be 0f00 	cmp.w	lr, #0
 8009b74:	dd33      	ble.n	8009bde <packbits+0x7e>
    if (l > 128) l = 128;                              // Limit search RLE block size to 128
 8009b76:	f1be 0f80 	cmp.w	lr, #128	@ 0x80
    char c = source[i++];                              // Get next byte and write to block
 8009b7a:	5cef      	ldrb	r7, [r5, r3]
 8009b7c:	f103 0601 	add.w	r6, r3, #1
    for (rle = 0; c == source[i + rle] && --l; rle++); // Calculate this byte RLE sequence size = rle + 1
 8009b80:	eb05 0c03 	add.w	ip, r5, r3
    if (l > 128) l = 128;                              // Limit search RLE block size to 128
 8009b84:	bfa8      	it	ge
 8009b86:	f04f 0e80 	movge.w	lr, #128	@ 0x80
    for (rle = 0; c == source[i + rle] && --l; rle++); // Calculate this byte RLE sequence size = rle + 1
 8009b8a:	2300      	movs	r3, #0
 8009b8c:	f81c 8f01 	ldrb.w	r8, [ip, #1]!
 8009b90:	45b8      	cmp	r8, r7
 8009b92:	d105      	bne.n	8009ba0 <packbits+0x40>
 8009b94:	f103 0801 	add.w	r8, r3, #1
 8009b98:	45c6      	cmp	lr, r8
 8009b9a:	d001      	beq.n	8009ba0 <packbits+0x40>
 8009b9c:	4643      	mov	r3, r8
 8009b9e:	e7f5      	b.n	8009b8c <packbits+0x2c>
    if (sz && rle < 2) rle = 0;                        // Ignore (rle + 1) < 3 sequence on run non RLE input
 8009ba0:	b10c      	cbz	r4, 8009ba6 <packbits+0x46>
 8009ba2:	2b01      	cmp	r3, #1
 8009ba4:	dd02      	ble.n	8009bac <packbits+0x4c>
    else if (sz == 0 || rle > 0) sz = pk++;            // Reset state or RLE sequence found -> start new block
 8009ba6:	4604      	mov	r4, r0
 8009ba8:	3001      	adds	r0, #1
 8009baa:	e000      	b.n	8009bae <packbits+0x4e>
    if (sz && rle < 2) rle = 0;                        // Ignore (rle + 1) < 3 sequence on run non RLE input
 8009bac:	2300      	movs	r3, #0
    dest[pk++] = c;                                    // Write char to block
 8009bae:	f100 0c01 	add.w	ip, r0, #1
    if (rle > 0) {i+= rle; dest[sz] = -rle;}           // Write RLE sequence size and go to new block
 8009bb2:	eb01 0e04 	add.w	lr, r1, r4
    dest[pk++] = c;                                    // Write char to block
 8009bb6:	4408      	add	r0, r1
    if (rle > 0) {i+= rle; dest[sz] = -rle;}           // Write RLE sequence size and go to new block
 8009bb8:	b123      	cbz	r3, 8009bc4 <packbits+0x64>
 8009bba:	441e      	add	r6, r3
 8009bbc:	425b      	negs	r3, r3
 8009bbe:	b2db      	uxtb	r3, r3
    else if ((dest[sz] = pk - sz - 2) < 127)           // Continue write non RLE data while 1 + (non_rle + 1) < 127
      continue;
    sz = 0;                                            // Block complete
 8009bc0:	2400      	movs	r4, #0
 8009bc2:	e006      	b.n	8009bd2 <packbits+0x72>
    else if ((dest[sz] = pk - sz - 2) < 127)           // Continue write non RLE data while 1 + (non_rle + 1) < 127
 8009bc4:	ebac 0304 	sub.w	r3, ip, r4
 8009bc8:	3b02      	subs	r3, #2
 8009bca:	b2db      	uxtb	r3, r3
    sz = 0;                                            // Block complete
 8009bcc:	2b7f      	cmp	r3, #127	@ 0x7f
 8009bce:	bf28      	it	cs
 8009bd0:	2400      	movcs	r4, #0
    dest[pk++] = c;                                    // Write char to block
 8009bd2:	7007      	strb	r7, [r0, #0]
    else if ((dest[sz] = pk - sz - 2) < 127)           // Continue write non RLE data while 1 + (non_rle + 1) < 127
 8009bd4:	f88e 3000 	strb.w	r3, [lr]
 8009bd8:	4660      	mov	r0, ip
 8009bda:	4633      	mov	r3, r6
 8009bdc:	e7c6      	b.n	8009b6c <packbits+0xc>
  }
  return pk;
}
 8009bde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08009be4 <_delay_8t>:
    " bne  1b    \n"  // 2 if taken, 1 otherwise
   : [cyc] "+l" (cycles)
   : // no inputs
   : // No memory
  );
}
 8009be4:	4770      	bx	lr
	...

08009be8 <si5351_set_frequency_offset>:
  return current_freq;
}

#ifdef USE_VARIABLE_OFFSET
void si5351_set_frequency_offset(int32_t offset)
{
 8009be8:	b510      	push	{r4, lr}
  current_band = 0;
 8009bea:	4905      	ldr	r1, [pc, #20]	@ (8009c00 <si5351_set_frequency_offset+0x18>)
  current_freq = 0;
 8009bec:	4a05      	ldr	r2, [pc, #20]	@ (8009c04 <si5351_set_frequency_offset+0x1c>)
  current_band = 0;
 8009bee:	2300      	movs	r3, #0
{
 8009bf0:	4604      	mov	r4, r0
  current_band = 0;
 8009bf2:	700b      	strb	r3, [r1, #0]
  current_freq = 0;
 8009bf4:	6013      	str	r3, [r2, #0]
  si5351_reset_cache();
  generate_DSP_Table(offset);
 8009bf6:	f000 fb2f 	bl	800a258 <generate_DSP_Table>
  IF_OFFSET = offset;
 8009bfa:	4b03      	ldr	r3, [pc, #12]	@ (8009c08 <si5351_set_frequency_offset+0x20>)
 8009bfc:	609c      	str	r4, [r3, #8]
}
 8009bfe:	bd10      	pop	{r4, pc}
 8009c00:	20006909 	.word	0x20006909
 8009c04:	20006904 	.word	0x20006904
 8009c08:	20000318 	.word	0x20000318

08009c0c <si5351_bulk_write>:
  if (drive_strength == current_power) return;
  si5351_set_frequency(current_freq, drive_strength);
}

void si5351_bulk_write(const uint8_t *buf, int len)
{
 8009c0c:	460a      	mov	r2, r1
  i2c_transfer(SI5351_I2C_ADDR, buf, len);
 8009c0e:	4601      	mov	r1, r0
 8009c10:	2060      	movs	r0, #96	@ 0x60
 8009c12:	f007 bfd9 	b.w	8011bc8 <i2c_transfer>
 8009c16:	bf00      	nop

08009c18 <si5351_setupPLL>:
// Set PLL freq = XTALFREQ * (mult + num/denom)
static void si5351_setupPLL(uint8_t   pllSource,  /* SI5351_REG_PLL_A or SI5351_REG_PLL_B */
                            uint32_t  mult,
                            uint32_t  num,
                            uint32_t  denom)
{
 8009c18:	b510      	push	{r4, lr}
   *    P2[19:0] = (128 * num) % denom
   * P3 register is a 20-bit value using the following formula:
   *    P3[19:0] = denom
   */
  /* Set the main PLL config registers */
  mult <<= 7;
 8009c1a:	01c9      	lsls	r1, r1, #7
  num <<= 7;
  uint32_t P1 = mult - 512;  // Integer mode
  uint32_t P2 = 0;
  uint32_t P3 = 1;
  if (num) {                 // Fractional mode
 8009c1c:	01d2      	lsls	r2, r2, #7
{
 8009c1e:	b084      	sub	sp, #16
  uint32_t P1 = mult - 512;  // Integer mode
 8009c20:	f5a1 7100 	sub.w	r1, r1, #512	@ 0x200
  if (num) {                 // Fractional mode
 8009c24:	d031      	beq.n	8009c8a <si5351_setupPLL+0x72>
    P1+= num / denom;
 8009c26:	fbb2 f4f3 	udiv	r4, r2, r3
  reg[1] = (P3 & 0x0FF00) >> 8;                             // MSN_P3[15: 8]
  reg[2] = (P3 & 0x000FF);                                  // MSN_P3[ 7: 0]
  reg[3] = (P1 & 0x30000) >> 16;                            // MSN_P1[17:16]
  reg[4] = (P1 & 0x0FF00) >> 8;                             // MSN_P1[15: 8]
  reg[5] = (P1 & 0x000FF);                                  // MSN_P1[ 7: 0]
  reg[6] = ((P3 & 0xF0000) >> 12) | ((P2 & 0xF0000) >> 16); // MSN_P3[19:16] | MSN_P2[19:16]
 8009c2a:	ea4f 3c13 	mov.w	ip, r3, lsr #12
    P2 = num % denom;
 8009c2e:	fb03 2214 	mls	r2, r3, r4, r2
  reg[6] = ((P3 & 0xF0000) >> 12) | ((P2 & 0xF0000) >> 16); // MSN_P3[19:16] | MSN_P2[19:16]
 8009c32:	f3c2 4e03 	ubfx	lr, r2, #16, #4
 8009c36:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
    P1+= num / denom;
 8009c3a:	4421      	add	r1, r4
  reg[6] = ((P3 & 0xF0000) >> 12) | ((P2 & 0xF0000) >> 16); // MSN_P3[19:16] | MSN_P2[19:16]
 8009c3c:	ea4c 0c0e 	orr.w	ip, ip, lr
  reg[1] = (P3 & 0x0FF00) >> 8;                             // MSN_P3[15: 8]
 8009c40:	f3c3 2407 	ubfx	r4, r3, #8, #8
  reg[7] = (P2 & 0x0FF00) >> 8;                             // MSN_P2[15: 8]
 8009c44:	f3c2 2e07 	ubfx	lr, r2, #8, #8
  reg[2] = (P3 & 0x000FF);                                  // MSN_P3[ 7: 0]
 8009c48:	b2db      	uxtb	r3, r3
  reg[8] = (P2 & 0x000FF);                                  // MSN_P2[ 7: 0]
 8009c4a:	b2d2      	uxtb	r2, r2
 8009c4c:	f88d 200c 	strb.w	r2, [sp, #12]
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8009c50:	2200      	movs	r2, #0
 8009c52:	f360 0207 	bfi	r2, r0, #0, #8
 8009c56:	f364 220f 	bfi	r2, r4, #8, #8
 8009c5a:	f363 4217 	bfi	r2, r3, #16, #8
  reg[3] = (P1 & 0x30000) >> 16;                            // MSN_P1[17:16]
 8009c5e:	f3c1 4301 	ubfx	r3, r1, #16, #2
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8009c62:	f363 621f 	bfi	r2, r3, #24, #8
 8009c66:	9201      	str	r2, [sp, #4]
 8009c68:	2300      	movs	r3, #0
  reg[4] = (P1 & 0x0FF00) >> 8;                             // MSN_P1[15: 8]
 8009c6a:	0a0a      	lsrs	r2, r1, #8
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8009c6c:	f362 0307 	bfi	r3, r2, #0, #8
 8009c70:	f361 230f 	bfi	r3, r1, #8, #8
 8009c74:	f36c 4317 	bfi	r3, ip, #16, #8
 8009c78:	f36e 631f 	bfi	r3, lr, #24, #8
  si5351_bulk_write(reg, 9);
 8009c7c:	2109      	movs	r1, #9
 8009c7e:	a801      	add	r0, sp, #4
  reg[0] = pllSource;                                       // SI5351_REG_PLL_A or SI5351_REG_PLL_B
 8009c80:	9302      	str	r3, [sp, #8]
  si5351_bulk_write(reg, 9);
 8009c82:	f7ff ffc3 	bl	8009c0c <si5351_bulk_write>
}
 8009c86:	b004      	add	sp, #16
 8009c88:	bd10      	pop	{r4, pc}
 8009c8a:	4696      	mov	lr, r2
 8009c8c:	4694      	mov	ip, r2
 8009c8e:	2301      	movs	r3, #1
 8009c90:	4614      	mov	r4, r2
 8009c92:	e7db      	b.n	8009c4c <si5351_setupPLL+0x34>

08009c94 <si5351_setupPLL_freq>:

// Setup PLL freq if Multisynth divider fixed = div (need get output =  freq/mul)
static void
si5351_setupPLL_freq(uint32_t pllSource, uint64_t pllfreq, uint32_t div)
{
  uint32_t xtal  = config._xtal_freq * div;
 8009c94:	491d      	ldr	r1, [pc, #116]	@ (8009d0c <si5351_setupPLL_freq+0x78>)
{
 8009c96:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t xtal  = config._xtal_freq * div;
 8009c9a:	6e49      	ldr	r1, [r1, #100]	@ 0x64
{
 8009c9c:	9c06      	ldr	r4, [sp, #24]
 8009c9e:	4616      	mov	r6, r2
  uint32_t xtal  = config._xtal_freq * div;
 8009ca0:	fb01 f404 	mul.w	r4, r1, r4
{
 8009ca4:	4605      	mov	r5, r0
 8009ca6:	4619      	mov	r1, r3
 8009ca8:	4622      	mov	r2, r4
 8009caa:	4630      	mov	r0, r6
 8009cac:	2300      	movs	r3, #0
 8009cae:	f7f6 fe2d 	bl	800090c <__aeabi_uldivmod>
  if (denom > MAX_DENOMINATOR) {
 8009cb2:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
 8009cb6:	4601      	mov	r1, r0
 8009cb8:	d31a      	bcc.n	8009cf0 <si5351_setupPLL_freq+0x5c>
    uint32_t p0 = 0, q0 = 1, p1 = 1, q1 = 0;
 8009cba:	2700      	movs	r7, #0
 8009cbc:	f04f 0c01 	mov.w	ip, #1
 8009cc0:	46e0      	mov	r8, ip
 8009cc2:	46be      	mov	lr, r7
 8009cc4:	e001      	b.n	8009cca <si5351_setupPLL_freq+0x36>
 8009cc6:	469c      	mov	ip, r3
 8009cc8:	46b6      	mov	lr, r6
      uint32_t a = num / denom;
 8009cca:	fbb2 f3f4 	udiv	r3, r2, r4
      uint32_t q2 = q0 + a*q1;
 8009cce:	fb03 860e 	mla	r6, r3, lr, r8
      if (q2 > MAX_DENOMINATOR)
 8009cd2:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
 8009cd6:	4620      	mov	r0, r4
      uint32_t b = num % denom;
 8009cd8:	fb04 2413 	mls	r4, r4, r3, r2
      if (q2 > MAX_DENOMINATOR)
 8009cdc:	d20e      	bcs.n	8009cfc <si5351_setupPLL_freq+0x68>
      uint32_t p2 = p0 + a*p1;
 8009cde:	fb03 730c 	mla	r3, r3, ip, r7
    while (denom != 0) {
 8009ce2:	46f0      	mov	r8, lr
 8009ce4:	4667      	mov	r7, ip
 8009ce6:	4602      	mov	r2, r0
 8009ce8:	2c00      	cmp	r4, #0
 8009cea:	d1ec      	bne.n	8009cc6 <si5351_setupPLL_freq+0x32>
    *d = q1;
 8009cec:	4634      	mov	r4, r6
    *n = p1;
 8009cee:	461a      	mov	r2, r3
  uint32_t multi = pllfreq / xtal;
  uint32_t num   = pllfreq % xtal;
  uint32_t denom = xtal;
  approximate_fraction(&num, &denom);
  si5351_setupPLL(pllSource, multi, num, denom);
 8009cf0:	4623      	mov	r3, r4
 8009cf2:	b2e8      	uxtb	r0, r5
}
 8009cf4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  si5351_setupPLL(pllSource, multi, num, denom);
 8009cf8:	f7ff bf8e 	b.w	8009c18 <si5351_setupPLL>
    *d = q1;
 8009cfc:	4674      	mov	r4, lr
  si5351_setupPLL(pllSource, multi, num, denom);
 8009cfe:	4623      	mov	r3, r4
 8009d00:	b2e8      	uxtb	r0, r5
    *n = p1;
 8009d02:	4662      	mov	r2, ip
}
 8009d04:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  si5351_setupPLL(pllSource, multi, num, denom);
 8009d08:	f7ff bf86 	b.w	8009c18 <si5351_setupPLL>
 8009d0c:	20000318 	.word	0x20000318

08009d10 <si5351_setupMultisynth>:
{
 8009d10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009d14:	b085      	sub	sp, #20
  if (div == 4)
 8009d16:	2904      	cmp	r1, #4
{
 8009d18:	9f0c      	ldr	r7, [sp, #48]	@ 0x30
 8009d1a:	f89d 6034 	ldrb.w	r6, [sp, #52]	@ 0x34
 8009d1e:	4605      	mov	r5, r0
 8009d20:	4614      	mov	r4, r2
  if (div == 4)
 8009d22:	d05c      	beq.n	8009dde <si5351_setupMultisynth+0xce>
    div<<=7;
 8009d24:	01c9      	lsls	r1, r1, #7
    if (num) {       // Fractional mode
 8009d26:	01d4      	lsls	r4, r2, #7
    P1 = div - 512; // Integer mode
 8009d28:	f5a1 7100 	sub.w	r1, r1, #512	@ 0x200
    if (num) {       // Fractional mode
 8009d2c:	d13b      	bne.n	8009da6 <si5351_setupMultisynth+0x96>
  reg[3] = ((P1 & 0x30000)>>16)| rdiv;                // Rx_DIV[2:0] | MSx_DIVBY4[1:0] | MSx_P1[17:16]
 8009d2e:	f3c1 4001 	ubfx	r0, r1, #16, #2
  reg[4] = (P1 & 0x0FF00)>> 8;                        // MSx_P1[15: 8]
 8009d32:	f3c1 2e07 	ubfx	lr, r1, #8, #8
  reg[5] = (P1 & 0x000FF);                            // MSx_P1[ 7: 0]
 8009d36:	4622      	mov	r2, r4
 8009d38:	b2c9      	uxtb	r1, r1
 8009d3a:	46a0      	mov	r8, r4
 8009d3c:	46a4      	mov	ip, r4
 8009d3e:	2301      	movs	r3, #1
 8009d40:	46a1      	mov	r9, r4
  reg[8] = (P2 & 0x000FF);                            // MSx_P2[ 7: 0]
 8009d42:	f88d 200c 	strb.w	r2, [sp, #12]
  reg[0] = msreg_base[channel];                       // SI5351_REG_42_MULTISYNTH0, SI5351_REG_50_MULTISYNTH1, SI5351_REG_58_MULTISYNTH2
 8009d46:	4a2b      	ldr	r2, [pc, #172]	@ (8009df4 <si5351_setupMultisynth+0xe4>)
  reg[3] = ((P1 & 0x30000)>>16)| rdiv;                // Rx_DIV[2:0] | MSx_DIVBY4[1:0] | MSx_P1[17:16]
 8009d48:	4338      	orrs	r0, r7
  reg[0] = msreg_base[channel];                       // SI5351_REG_42_MULTISYNTH0, SI5351_REG_50_MULTISYNTH1, SI5351_REG_58_MULTISYNTH2
 8009d4a:	5d57      	ldrb	r7, [r2, r5]
 8009d4c:	2200      	movs	r2, #0
 8009d4e:	f367 0207 	bfi	r2, r7, #0, #8
 8009d52:	f369 220f 	bfi	r2, r9, #8, #8
 8009d56:	f363 4217 	bfi	r2, r3, #16, #8
 8009d5a:	2300      	movs	r3, #0
 8009d5c:	f36e 0307 	bfi	r3, lr, #0, #8
 8009d60:	f361 230f 	bfi	r3, r1, #8, #8
 8009d64:	f36c 4317 	bfi	r3, ip, #16, #8
 8009d68:	f360 621f 	bfi	r2, r0, #24, #8
 8009d6c:	f368 631f 	bfi	r3, r8, #24, #8
  si5351_bulk_write(reg, 9);
 8009d70:	2109      	movs	r1, #9
 8009d72:	a801      	add	r0, sp, #4
  reg[0] = msreg_base[channel];                       // SI5351_REG_42_MULTISYNTH0, SI5351_REG_50_MULTISYNTH1, SI5351_REG_58_MULTISYNTH2
 8009d74:	9201      	str	r2, [sp, #4]
 8009d76:	9302      	str	r3, [sp, #8]
  si5351_bulk_write(reg, 9);
 8009d78:	f7ff ff48 	bl	8009c0c <si5351_bulk_write>
  if (num == 0)
 8009d7c:	b364      	cbz	r4, 8009dd8 <si5351_setupMultisynth+0xc8>
  chctrl|= SI5351_CLK_INPUT_MULTISYNTH_N;
 8009d7e:	f046 060c 	orr.w	r6, r6, #12
  if (clk_cache[channel] != chctrl) {
 8009d82:	4c1d      	ldr	r4, [pc, #116]	@ (8009df8 <si5351_setupMultisynth+0xe8>)
 8009d84:	5d63      	ldrb	r3, [r4, r5]
 8009d86:	42b3      	cmp	r3, r6
 8009d88:	d00a      	beq.n	8009da0 <si5351_setupMultisynth+0x90>
    si5351_write(SI5351_REG_16_CLK0_CONTROL + channel, chctrl);
 8009d8a:	f105 0310 	add.w	r3, r5, #16
  si5351_bulk_write(buf, 2);
 8009d8e:	2102      	movs	r1, #2
 8009d90:	4668      	mov	r0, sp
  uint8_t buf[] = { reg, dat };
 8009d92:	f88d 3000 	strb.w	r3, [sp]
 8009d96:	f88d 6001 	strb.w	r6, [sp, #1]
  si5351_bulk_write(buf, 2);
 8009d9a:	f7ff ff37 	bl	8009c0c <si5351_bulk_write>
    clk_cache[channel] = chctrl;
 8009d9e:	5566      	strb	r6, [r4, r5]
}
 8009da0:	b005      	add	sp, #20
 8009da2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      P1+= num / denom;
 8009da6:	fbb4 f2f3 	udiv	r2, r4, r3
  reg[6] = ((P3 & 0xF0000)>>12)|((P2 & 0xF0000)>>16); // MSx_P3[19:16] | MSx_P2[19:16]
 8009daa:	ea4f 3c13 	mov.w	ip, r3, lsr #12
      P1+= num / denom;
 8009dae:	4411      	add	r1, r2
      P2 = num % denom;
 8009db0:	fb03 4212 	mls	r2, r3, r2, r4
  reg[6] = ((P3 & 0xF0000)>>12)|((P2 & 0xF0000)>>16); // MSx_P3[19:16] | MSx_P2[19:16]
 8009db4:	f3c2 4003 	ubfx	r0, r2, #16, #4
 8009db8:	f00c 0cf0 	and.w	ip, ip, #240	@ 0xf0
 8009dbc:	ea4c 0c00 	orr.w	ip, ip, r0
  reg[1] = (P3 & 0x0FF00)>>8;                         // MSx_P3[15: 8]
 8009dc0:	f3c3 2907 	ubfx	r9, r3, #8, #8
  reg[3] = ((P1 & 0x30000)>>16)| rdiv;                // Rx_DIV[2:0] | MSx_DIVBY4[1:0] | MSx_P1[17:16]
 8009dc4:	f3c1 4001 	ubfx	r0, r1, #16, #2
  reg[4] = (P1 & 0x0FF00)>> 8;                        // MSx_P1[15: 8]
 8009dc8:	f3c1 2e07 	ubfx	lr, r1, #8, #8
  reg[7] = (P2 & 0x0FF00)>>8;                         // MSx_P2[15: 8]
 8009dcc:	f3c2 2807 	ubfx	r8, r2, #8, #8
  reg[2] = (P3 & 0x000FF);                            // MSx_P3[ 7: 0]
 8009dd0:	b2db      	uxtb	r3, r3
  reg[5] = (P1 & 0x000FF);                            // MSx_P1[ 7: 0]
 8009dd2:	b2c9      	uxtb	r1, r1
  reg[8] = (P2 & 0x000FF);                            // MSx_P2[ 7: 0]
 8009dd4:	b2d2      	uxtb	r2, r2
 8009dd6:	e7b4      	b.n	8009d42 <si5351_setupMultisynth+0x32>
    chctrl|= SI5351_CLK_INTEGER_MODE;
 8009dd8:	f046 064c 	orr.w	r6, r6, #76	@ 0x4c
 8009ddc:	e7d1      	b.n	8009d82 <si5351_setupMultisynth+0x72>
    rdiv|= SI5351_DIVBY4;
 8009dde:	2200      	movs	r2, #0
 8009de0:	f047 070c 	orr.w	r7, r7, #12
 8009de4:	4690      	mov	r8, r2
 8009de6:	4694      	mov	ip, r2
 8009de8:	4611      	mov	r1, r2
 8009dea:	4696      	mov	lr, r2
 8009dec:	4610      	mov	r0, r2
 8009dee:	2301      	movs	r3, #1
 8009df0:	4691      	mov	r9, r2
 8009df2:	e7a6      	b.n	8009d42 <si5351_setupMultisynth+0x32>
 8009df4:	08016114 	.word	0x08016114
 8009df8:	20006900 	.word	0x20006900

08009dfc <si5351_set_frequency_fixedpll>:
{
 8009dfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009e00:	9c08      	ldr	r4, [sp, #32]
 8009e02:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 8009e04:	f89d 7028 	ldrb.w	r7, [sp, #40]	@ 0x28
 8009e08:	4619      	mov	r1, r3
 8009e0a:	4605      	mov	r5, r0
 8009e0c:	2300      	movs	r3, #0
 8009e0e:	4610      	mov	r0, r2
 8009e10:	4622      	mov	r2, r4
 8009e12:	f7f6 fd7b 	bl	800090c <__aeabi_uldivmod>
  if (denom > MAX_DENOMINATOR) {
 8009e16:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
 8009e1a:	4601      	mov	r1, r0
 8009e1c:	d31b      	bcc.n	8009e56 <si5351_set_frequency_fixedpll+0x5a>
    uint32_t p0 = 0, q0 = 1, p1 = 1, q1 = 0;
 8009e1e:	f04f 0900 	mov.w	r9, #0
 8009e22:	f04f 0c01 	mov.w	ip, #1
 8009e26:	4660      	mov	r0, ip
 8009e28:	46ce      	mov	lr, r9
 8009e2a:	e001      	b.n	8009e30 <si5351_set_frequency_fixedpll+0x34>
 8009e2c:	469c      	mov	ip, r3
 8009e2e:	46c6      	mov	lr, r8
      uint32_t a = num / denom;
 8009e30:	fbb2 f3f4 	udiv	r3, r2, r4
      uint32_t q2 = q0 + a*q1;
 8009e34:	fb03 080e 	mla	r8, r3, lr, r0
      if (q2 > MAX_DENOMINATOR)
 8009e38:	f5b8 1f80 	cmp.w	r8, #1048576	@ 0x100000
 8009e3c:	46a2      	mov	sl, r4
      uint32_t b = num % denom;
 8009e3e:	fb04 2413 	mls	r4, r4, r3, r2
      if (q2 > MAX_DENOMINATOR)
 8009e42:	d210      	bcs.n	8009e66 <si5351_set_frequency_fixedpll+0x6a>
      uint32_t p2 = p0 + a*p1;
 8009e44:	fb03 930c 	mla	r3, r3, ip, r9
    while (denom != 0) {
 8009e48:	4670      	mov	r0, lr
 8009e4a:	46e1      	mov	r9, ip
 8009e4c:	4652      	mov	r2, sl
 8009e4e:	2c00      	cmp	r4, #0
 8009e50:	d1ec      	bne.n	8009e2c <si5351_set_frequency_fixedpll+0x30>
    *d = q1;
 8009e52:	4644      	mov	r4, r8
    *n = p1;
 8009e54:	461a      	mov	r2, r3
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8009e56:	e9cd 6708 	strd	r6, r7, [sp, #32]
 8009e5a:	4623      	mov	r3, r4
 8009e5c:	4628      	mov	r0, r5
}
 8009e5e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8009e62:	f7ff bf55 	b.w	8009d10 <si5351_setupMultisynth>
    *d = q1;
 8009e66:	4674      	mov	r4, lr
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8009e68:	e9cd 6708 	strd	r6, r7, [sp, #32]
 8009e6c:	4623      	mov	r3, r4
 8009e6e:	4628      	mov	r0, r5
    *n = p1;
 8009e70:	4662      	mov	r2, ip
}
 8009e72:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  si5351_setupMultisynth(channel, div, num, denom, rdiv, chctrl);
 8009e76:	f7ff bf4b 	b.w	8009d10 <si5351_setupMultisynth>
 8009e7a:	bf00      	nop

08009e7c <si5351_set_tcxo>:
  if (xtal < XTALFREQ - 2000000 ||
 8009e7c:	4a09      	ldr	r2, [pc, #36]	@ (8009ea4 <si5351_set_tcxo+0x28>)
  current_band = 0;
 8009e7e:	490a      	ldr	r1, [pc, #40]	@ (8009ea8 <si5351_set_tcxo+0x2c>)
  if (xtal < XTALFREQ - 2000000 ||
 8009e80:	f1a0 73b7 	sub.w	r3, r0, #23986176	@ 0x16e0000
 8009e84:	f5a3 5358 	sub.w	r3, r3, #13824	@ 0x3600
void si5351_set_tcxo(uint32_t xtal){
 8009e88:	b410      	push	{r4}
  if (xtal < XTALFREQ - 2000000 ||
 8009e8a:	4293      	cmp	r3, r2
  config._xtal_freq = xtal;
 8009e8c:	4c07      	ldr	r4, [pc, #28]	@ (8009eac <si5351_set_tcxo+0x30>)
  current_freq = 0;
 8009e8e:	4a08      	ldr	r2, [pc, #32]	@ (8009eb0 <si5351_set_tcxo+0x34>)
      xtal > XTALFREQ + 2000000) xtal = XTALFREQ;
 8009e90:	bf88      	it	hi
 8009e92:	4808      	ldrhi	r0, [pc, #32]	@ (8009eb4 <si5351_set_tcxo+0x38>)
  config._xtal_freq = xtal;
 8009e94:	6660      	str	r0, [r4, #100]	@ 0x64
  current_band = 0;
 8009e96:	2300      	movs	r3, #0
 8009e98:	700b      	strb	r3, [r1, #0]
}
 8009e9a:	f85d 4b04 	ldr.w	r4, [sp], #4
  current_freq = 0;
 8009e9e:	6013      	str	r3, [r2, #0]
}
 8009ea0:	4770      	bx	lr
 8009ea2:	bf00      	nop
 8009ea4:	003d0900 	.word	0x003d0900
 8009ea8:	20006909 	.word	0x20006909
 8009eac:	20000318 	.word	0x20000318
 8009eb0:	20006904 	.word	0x20006904
 8009eb4:	018cba80 	.word	0x018cba80

08009eb8 <si5351_set_band_mode>:
    band_strategy_H4_SI5351,  band_strategy_36H_MS5351, band_strategy_SWC5351
#else
    band_strategy_33H_SI5351, band_strategy_36H_MS5351, band_strategy_SWC5351
#endif
  };
  band_s = bs[t];
 8009eb8:	4a02      	ldr	r2, [pc, #8]	@ (8009ec4 <si5351_set_band_mode+0xc>)
 8009eba:	4b03      	ldr	r3, [pc, #12]	@ (8009ec8 <si5351_set_band_mode+0x10>)
 8009ebc:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 8009ec0:	601a      	str	r2, [r3, #0]
}
 8009ec2:	4770      	bx	lr
 8009ec4:	08015f4c 	.word	0x08015f4c
 8009ec8:	200068fc 	.word	0x200068fc

08009ecc <si5351_get_harmonic_lvl>:

uint32_t
si5351_get_harmonic_lvl(uint32_t freq){
  uint16_t i;
  for (i = 0; ; i++){
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8009ecc:	4b09      	ldr	r3, [pc, #36]	@ (8009ef4 <si5351_get_harmonic_lvl+0x28>)
 8009ece:	4a0a      	ldr	r2, [pc, #40]	@ (8009ef8 <si5351_get_harmonic_lvl+0x2c>)
si5351_get_harmonic_lvl(uint32_t freq){
 8009ed0:	b430      	push	{r4, r5}
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8009ed2:	685d      	ldr	r5, [r3, #4]
 8009ed4:	6814      	ldr	r4, [r2, #0]
si5351_get_harmonic_lvl(uint32_t freq){
 8009ed6:	4601      	mov	r1, r0
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8009ed8:	2200      	movs	r2, #0
 8009eda:	b290      	uxth	r0, r2
 8009edc:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    if (freq <= f)
 8009ee0:	3201      	adds	r2, #1
    uint32_t f = band_s[i].freq; if (f < 20) f*=config._harmonic_freq_threshold;
 8009ee2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8009ee6:	2b13      	cmp	r3, #19
 8009ee8:	bf98      	it	ls
 8009eea:	436b      	mulls	r3, r5
    if (freq <= f)
 8009eec:	428b      	cmp	r3, r1
 8009eee:	d3f4      	bcc.n	8009eda <si5351_get_harmonic_lvl+0xe>
      return i;
  }
  return i;
}
 8009ef0:	bc30      	pop	{r4, r5}
 8009ef2:	4770      	bx	lr
 8009ef4:	20000318 	.word	0x20000318
 8009ef8:	200068fc 	.word	0x200068fc

08009efc <si5351_set_frequency>:
#define FREQ_CHANNEL         1
#define AUDIO_CODEC_CHANNEL  2

int
si5351_set_frequency(uint32_t freq, uint8_t drive_strength)
{
 8009efc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t band;
  int delay = 0;
  if (freq == 0) return 0;
 8009f00:	4604      	mov	r4, r0
{
 8009f02:	b08d      	sub	sp, #52	@ 0x34
  if (freq == 0) return 0;
 8009f04:	2800      	cmp	r0, #0
 8009f06:	d06f      	beq.n	8009fe8 <si5351_set_frequency+0xec>
  uint32_t rdiv = SI5351_R_DIV_1;
  uint32_t fdiv, pll_n;
  uint32_t ofreq = freq + IF_OFFSET;
 8009f08:	f8df 9264 	ldr.w	r9, [pc, #612]	@ 800a170 <si5351_set_frequency+0x274>

  // Select optimal band for prepared freq
  if (freq < band_s[1].freq) {
 8009f0c:	f8df 8264 	ldr.w	r8, [pc, #612]	@ 800a174 <si5351_set_frequency+0x278>
  uint32_t ofreq = freq + IF_OFFSET;
 8009f10:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8009f14:	eb00 0a03 	add.w	sl, r0, r3
  if (freq < band_s[1].freq) {
 8009f18:	f8d8 3000 	ldr.w	r3, [r8]
 8009f1c:	68da      	ldr	r2, [r3, #12]
 8009f1e:	4282      	cmp	r2, r0
 8009f20:	d810      	bhi.n	8009f44 <si5351_set_frequency+0x48>
     rdiv = SI5351_R_DIV(7);
     drive_strength = SI5351_CLK_DRIVE_STRENGTH_2MA; // Always use 2ma
     freq<<= 7;
    ofreq<<= 7;
    band = 1;
  } else if (freq <= 1000000U) {
 8009f22:	4a8f      	ldr	r2, [pc, #572]	@ (800a160 <si5351_set_frequency+0x264>)
 8009f24:	4290      	cmp	r0, r2
 8009f26:	460d      	mov	r5, r1
 8009f28:	f200 8101 	bhi.w	800a12e <si5351_set_frequency+0x232>
    freq*=align;
    ofreq = freq + current_offset;
  }
#endif
  // Check current power settings
  if (current_power != drive_strength){
 8009f2c:	4a8d      	ldr	r2, [pc, #564]	@ (800a164 <si5351_set_frequency+0x268>)
 8009f2e:	7811      	ldrb	r1, [r2, #0]
 8009f30:	42a9      	cmp	r1, r5
     freq<<= 4;
 8009f32:	ea4f 1400 	mov.w	r4, r0, lsl #4
    ofreq<<= 4;
 8009f36:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
  if (current_power != drive_strength){
 8009f3a:	d165      	bne.n	800a008 <si5351_set_frequency+0x10c>
    rdiv = SI5351_R_DIV(4);
 8009f3c:	2240      	movs	r2, #64	@ 0x40
 8009f3e:	9206      	str	r2, [sp, #24]
    band = 2;
 8009f40:	2602      	movs	r6, #2
 8009f42:	e009      	b.n	8009f58 <si5351_set_frequency+0x5c>
  if (current_power != drive_strength){
 8009f44:	4a87      	ldr	r2, [pc, #540]	@ (800a164 <si5351_set_frequency+0x268>)
 8009f46:	7815      	ldrb	r5, [r2, #0]
     freq<<= 7;
 8009f48:	01c4      	lsls	r4, r0, #7
    ofreq<<= 7;
 8009f4a:	ea4f 1aca 	mov.w	sl, sl, lsl #7
  if (current_power != drive_strength){
 8009f4e:	2d00      	cmp	r5, #0
 8009f50:	d14d      	bne.n	8009fee <si5351_set_frequency+0xf2>
 8009f52:	2270      	movs	r2, #112	@ 0x70
 8009f54:	9206      	str	r2, [sp, #24]
 8009f56:	2601      	movs	r6, #1
    si5351_reset_cache();
    current_power = drive_strength;
  }

  if (freq == current_freq)
 8009f58:	f8df b21c 	ldr.w	fp, [pc, #540]	@ 800a178 <si5351_set_frequency+0x27c>
 8009f5c:	f8db 2000 	ldr.w	r2, [fp]
 8009f60:	42a2      	cmp	r2, r4
 8009f62:	f000 80f7 	beq.w	800a154 <si5351_set_frequency+0x258>
 8009f66:	4f80      	ldr	r7, [pc, #512]	@ (800a168 <si5351_set_frequency+0x26c>)
    return DELAY_CHANNEL_CHANGE;

  if (current_band != band) {
 8009f68:	7839      	ldrb	r1, [r7, #0]
//   si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, SI5351_CLK0_EN|SI5351_CLK1_EN|SI5351_CLK2_EN);
    if (DELAY_RESET_PLL_BEFORE)
      si5351_reset_pll(SI5351_PLL_RESET_A | SI5351_PLL_RESET_B);
    // Set new gain values
    if (band_s[current_band].l_gain != band_s[band].l_gain || band_s[current_band].r_gain != band_s[band].r_gain)
 8009f6a:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 8009f6e:	0090      	lsls	r0, r2, #2
  if (current_band != band) {
 8009f70:	42b1      	cmp	r1, r6
    if (band_s[current_band].l_gain != band_s[band].l_gain || band_s[current_band].r_gain != band_s[band].r_gain)
 8009f72:	9008      	str	r0, [sp, #32]
 8009f74:	eb03 0282 	add.w	r2, r3, r2, lsl #2
  if (current_band != band) {
 8009f78:	d00f      	beq.n	8009f9a <si5351_set_frequency+0x9e>
    if (band_s[current_band].l_gain != band_s[band].l_gain || band_s[current_band].r_gain != band_s[band].r_gain)
 8009f7a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8009f7e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8009f82:	8919      	ldrh	r1, [r3, #8]
 8009f84:	8913      	ldrh	r3, [r2, #8]
 8009f86:	4299      	cmp	r1, r3
 8009f88:	d007      	beq.n	8009f9a <si5351_set_frequency+0x9e>
      tlv320aic3204_set_gain(band_s[band].l_gain, band_s[band].r_gain);
 8009f8a:	7a10      	ldrb	r0, [r2, #8]
 8009f8c:	7a51      	ldrb	r1, [r2, #9]
 8009f8e:	f000 f94f 	bl	800a230 <tlv320aic3204_set_gain>
    // Add delay
    if (DELAY_RESET_PLL_BEFORE)
      chThdSleepMicroseconds(DELAY_RESET_PLL_BEFORE);
  }
  uint32_t mul  = band_s[band].mul;
 8009f92:	f8d8 2000 	ldr.w	r2, [r8]
 8009f96:	9808      	ldr	r0, [sp, #32]
 8009f98:	4402      	add	r2, r0
 8009f9a:	7993      	ldrb	r3, [r2, #6]
  uint32_t omul = band_s[band].omul;
  uint8_t  ds   = drive_strength;
  uint8_t ods   = drive_strength;
  if (drive_strength > SI5351_CLK_DRIVE_STRENGTH_8MA) {ds = band_s[band].pow; ods = band_s[band].opow;}
 8009f9c:	2d03      	cmp	r5, #3
  uint32_t mul  = band_s[band].mul;
 8009f9e:	f003 010f 	and.w	r1, r3, #15
  uint32_t omul = band_s[band].omul;
 8009fa2:	ea4f 1313 	mov.w	r3, r3, lsr #4
  uint32_t mul  = band_s[band].mul;
 8009fa6:	9105      	str	r1, [sp, #20]
  uint32_t omul = band_s[band].omul;
 8009fa8:	9307      	str	r3, [sp, #28]
  if (drive_strength > SI5351_CLK_DRIVE_STRENGTH_8MA) {ds = band_s[band].pow; ods = band_s[band].opow;}
 8009faa:	d939      	bls.n	800a020 <si5351_set_frequency+0x124>
 8009fac:	79d3      	ldrb	r3, [r2, #7]
 8009fae:	f003 050f 	and.w	r5, r3, #15
 8009fb2:	091b      	lsrs	r3, r3, #4
 8009fb4:	9309      	str	r3, [sp, #36]	@ 0x24
  switch (band_s[band].mode) {
 8009fb6:	7913      	ldrb	r3, [r2, #4]
 8009fb8:	2b01      	cmp	r3, #1
 8009fba:	d035      	beq.n	800a028 <si5351_set_frequency+0x12c>
 8009fbc:	2b02      	cmp	r3, #2
 8009fbe:	d070      	beq.n	800a0a2 <si5351_set_frequency+0x1a6>
 8009fc0:	2000      	movs	r0, #0
      // Calculate CH2 freq = CLK2_FREQUENCY, depend from calculated before CH1 PLLB = (freq/mul)*fdiv
      si5351_set_frequency_fixedpll(AUDIO_CODEC_CHANNEL, (uint64_t)freq * fdiv, CLK2_FREQUENCY * mul, SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA | SI5351_CLK_PLL_SELECT_B);
      delay= DELAY_BAND_3_4;
      break;
  }
  if (current_band != band) {
 8009fc2:	783b      	ldrb	r3, [r7, #0]
 8009fc4:	42b3      	cmp	r3, r6
 8009fc6:	d00d      	beq.n	8009fe4 <si5351_set_frequency+0xe8>
//    si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, ~(SI5351_CLK0_EN|SI5351_CLK1_EN|SI5351_CLK2_EN));
    // Possibly not need add delay now
    if (DELAY_RESET_PLL_AFTER){
      chThdSleepMicroseconds(DELAY_RESET_PLL_AFTER);
 8009fc8:	f44f 70c8 	mov.w	r0, #400	@ 0x190
 8009fcc:	f7f6 ff60 	bl	8000e90 <chThdSleep>
  uint8_t buf[] = { reg, dat };
 8009fd0:	f64a 43b1 	movw	r3, #44209	@ 0xacb1
  si5351_bulk_write(buf, 2);
 8009fd4:	a80b      	add	r0, sp, #44	@ 0x2c
 8009fd6:	2102      	movs	r1, #2
  uint8_t buf[] = { reg, dat };
 8009fd8:	f8ad 302c 	strh.w	r3, [sp, #44]	@ 0x2c
  si5351_bulk_write(buf, 2);
 8009fdc:	f7ff fe16 	bl	8009c0c <si5351_bulk_write>
      si5351_reset_pll(SI5351_PLL_RESET_A|SI5351_PLL_RESET_B);
    }
    current_band = band;
    delay = DELAY_BANDCHANGE;
 8009fe0:	20c8      	movs	r0, #200	@ 0xc8
    current_band = band;
 8009fe2:	703e      	strb	r6, [r7, #0]
  }
  current_freq = freq;
 8009fe4:	f8cb 4000 	str.w	r4, [fp]
  return delay;
}
 8009fe8:	b00d      	add	sp, #52	@ 0x34
 8009fea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  current_band = 0;
 8009fee:	2500      	movs	r5, #0
 8009ff0:	4f5d      	ldr	r7, [pc, #372]	@ (800a168 <si5351_set_frequency+0x26c>)
  current_freq = 0;
 8009ff2:	f8df b184 	ldr.w	fp, [pc, #388]	@ 800a178 <si5351_set_frequency+0x27c>
    current_power = drive_strength;
 8009ff6:	7015      	strb	r5, [r2, #0]
 8009ff8:	2270      	movs	r2, #112	@ 0x70
 8009ffa:	9206      	str	r2, [sp, #24]
  current_band = 0;
 8009ffc:	703d      	strb	r5, [r7, #0]
  current_freq = 0;
 8009ffe:	f8cb 5000 	str.w	r5, [fp]
    current_power = drive_strength;
 800a002:	2601      	movs	r6, #1
 800a004:	462a      	mov	r2, r5
 800a006:	e7ab      	b.n	8009f60 <si5351_set_frequency+0x64>
  current_band = 0;
 800a008:	4f57      	ldr	r7, [pc, #348]	@ (800a168 <si5351_set_frequency+0x26c>)
  current_freq = 0;
 800a00a:	f8df b16c 	ldr.w	fp, [pc, #364]	@ 800a178 <si5351_set_frequency+0x27c>
    current_power = drive_strength;
 800a00e:	7015      	strb	r5, [r2, #0]
  current_band = 0;
 800a010:	2200      	movs	r2, #0
 800a012:	703a      	strb	r2, [r7, #0]
  current_freq = 0;
 800a014:	f8cb 2000 	str.w	r2, [fp]
    rdiv = SI5351_R_DIV(4);
 800a018:	2240      	movs	r2, #64	@ 0x40
 800a01a:	9206      	str	r2, [sp, #24]
    band = 2;
 800a01c:	2602      	movs	r6, #2
 800a01e:	e7a3      	b.n	8009f68 <si5351_set_frequency+0x6c>
  switch (band_s[band].mode) {
 800a020:	7913      	ldrb	r3, [r2, #4]
  uint8_t ods   = drive_strength;
 800a022:	9509      	str	r5, [sp, #36]	@ 0x24
  switch (band_s[band].mode) {
 800a024:	2b01      	cmp	r3, #1
 800a026:	d1c9      	bne.n	8009fbc <si5351_set_frequency+0xc0>
      pll_n = band_s[band].pll_n;
 800a028:	f892 8005 	ldrb.w	r8, [r2, #5]
      if (current_band != band) {
 800a02c:	783a      	ldrb	r2, [r7, #0]
 800a02e:	42b2      	cmp	r2, r6
 800a030:	d017      	beq.n	800a062 <si5351_set_frequency+0x166>
        si5351_setupPLL(SI5351_REG_PLL_A,   pll_n, 0, 1);
 800a032:	2200      	movs	r2, #0
 800a034:	4641      	mov	r1, r8
 800a036:	201a      	movs	r0, #26
 800a038:	9308      	str	r3, [sp, #32]
 800a03a:	f7ff fded 	bl	8009c18 <si5351_setupPLL>
        si5351_setupPLL(SI5351_REG_PLL_B, PLL_N_2, 0, 1);
 800a03e:	9b08      	ldr	r3, [sp, #32]
 800a040:	2200      	movs	r2, #0
 800a042:	2120      	movs	r1, #32
 800a044:	2022      	movs	r0, #34	@ 0x22
 800a046:	f7ff fde7 	bl	8009c18 <si5351_setupPLL>
        si5351_set_frequency_fixedpll(AUDIO_CODEC_CHANNEL, config._xtal_freq * PLL_N_2, CLK2_FREQUENCY, SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA | SI5351_CLK_PLL_SELECT_B);
 800a04a:	2300      	movs	r3, #0
 800a04c:	9301      	str	r3, [sp, #4]
 800a04e:	f8d9 2064 	ldr.w	r2, [r9, #100]	@ 0x64
 800a052:	4946      	ldr	r1, [pc, #280]	@ (800a16c <si5351_set_frequency+0x270>)
 800a054:	9100      	str	r1, [sp, #0]
 800a056:	2120      	movs	r1, #32
 800a058:	0152      	lsls	r2, r2, #5
 800a05a:	9102      	str	r1, [sp, #8]
 800a05c:	2002      	movs	r0, #2
 800a05e:	f7ff fecd 	bl	8009dfc <si5351_set_frequency_fixedpll>
      si5351_set_frequency_fixedpll(OFREQ_CHANNEL, (uint64_t)omul * config._xtal_freq * pll_n, ofreq, rdiv, ods | SI5351_CLK_PLL_SELECT_A);
 800a062:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800a064:	9302      	str	r3, [sp, #8]
 800a066:	9b07      	ldr	r3, [sp, #28]
 800a068:	f8cd a000 	str.w	sl, [sp]
 800a06c:	fba3 2308 	umull	r2, r3, r3, r8
 800a070:	9b06      	ldr	r3, [sp, #24]
 800a072:	9301      	str	r3, [sp, #4]
 800a074:	f8d9 3064 	ldr.w	r3, [r9, #100]	@ 0x64
 800a078:	2000      	movs	r0, #0
 800a07a:	fba3 2302 	umull	r2, r3, r3, r2
 800a07e:	f7ff febd 	bl	8009dfc <si5351_set_frequency_fixedpll>
      si5351_set_frequency_fixedpll( FREQ_CHANNEL, (uint64_t) mul * config._xtal_freq * pll_n,  freq, rdiv,  ds | SI5351_CLK_PLL_SELECT_A);
 800a082:	9a05      	ldr	r2, [sp, #20]
 800a084:	9502      	str	r5, [sp, #8]
 800a086:	fba8 8302 	umull	r8, r3, r8, r2
 800a08a:	9b06      	ldr	r3, [sp, #24]
 800a08c:	9301      	str	r3, [sp, #4]
 800a08e:	f8d9 2064 	ldr.w	r2, [r9, #100]	@ 0x64
 800a092:	9400      	str	r4, [sp, #0]
 800a094:	2001      	movs	r0, #1
 800a096:	fba2 2308 	umull	r2, r3, r2, r8
 800a09a:	f7ff feaf 	bl	8009dfc <si5351_set_frequency_fixedpll>
      delay = DELAY_BAND_1_2;
 800a09e:	200a      	movs	r0, #10
      break;
 800a0a0:	e78f      	b.n	8009fc2 <si5351_set_frequency+0xc6>
      fdiv = band_s[band].div;
 800a0a2:	f892 9005 	ldrb.w	r9, [r2, #5]
  uint32_t omul = band_s[band].omul;
 800a0a6:	9b07      	ldr	r3, [sp, #28]
 800a0a8:	9300      	str	r3, [sp, #0]
      si5351_setupPLL_freq(SI5351_REG_PLL_A, (uint64_t)ofreq * fdiv, omul);  // set PLLA freq = (ofreq/omul)*fdiv
 800a0aa:	201a      	movs	r0, #26
 800a0ac:	fbaa 2309 	umull	r2, r3, sl, r9
 800a0b0:	f7ff fdf0 	bl	8009c94 <si5351_setupPLL_freq>
      si5351_setupPLL_freq(SI5351_REG_PLL_B, (uint64_t) freq * fdiv,  mul);  // set PLLB freq = ( freq/ mul)*fdiv
 800a0b4:	9b05      	ldr	r3, [sp, #20]
 800a0b6:	9300      	str	r3, [sp, #0]
 800a0b8:	fba9 3a04 	umull	r3, sl, r9, r4
 800a0bc:	461a      	mov	r2, r3
 800a0be:	9306      	str	r3, [sp, #24]
 800a0c0:	2022      	movs	r0, #34	@ 0x22
 800a0c2:	4653      	mov	r3, sl
 800a0c4:	f7ff fde6 	bl	8009c94 <si5351_setupPLL_freq>
      if (band_s[current_band].div != band_s[band].div) {
 800a0c8:	f8d8 2000 	ldr.w	r2, [r8]
 800a0cc:	9b08      	ldr	r3, [sp, #32]
 800a0ce:	4413      	add	r3, r2
 800a0d0:	7959      	ldrb	r1, [r3, #5]
 800a0d2:	783b      	ldrb	r3, [r7, #0]
 800a0d4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800a0d8:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800a0dc:	7953      	ldrb	r3, [r2, #5]
 800a0de:	428b      	cmp	r3, r1
 800a0e0:	d015      	beq.n	800a10e <si5351_set_frequency+0x212>
        si5351_setupMultisynth(OFREQ_CHANNEL, fdiv, 0, 1, SI5351_R_DIV_1, ods | SI5351_CLK_PLL_SELECT_A);
 800a0e2:	f04f 0800 	mov.w	r8, #0
 800a0e6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800a0e8:	9301      	str	r3, [sp, #4]
 800a0ea:	4642      	mov	r2, r8
 800a0ec:	2301      	movs	r3, #1
 800a0ee:	4649      	mov	r1, r9
 800a0f0:	4640      	mov	r0, r8
 800a0f2:	f8cd 8000 	str.w	r8, [sp]
 800a0f6:	f7ff fe0b 	bl	8009d10 <si5351_setupMultisynth>
        si5351_setupMultisynth( FREQ_CHANNEL, fdiv, 0, 1, SI5351_R_DIV_1,  ds | SI5351_CLK_PLL_SELECT_B);
 800a0fa:	f045 0520 	orr.w	r5, r5, #32
 800a0fe:	2301      	movs	r3, #1
 800a100:	e9cd 8500 	strd	r8, r5, [sp]
 800a104:	4642      	mov	r2, r8
 800a106:	4649      	mov	r1, r9
 800a108:	4618      	mov	r0, r3
 800a10a:	f7ff fe01 	bl	8009d10 <si5351_setupMultisynth>
      si5351_set_frequency_fixedpll(AUDIO_CODEC_CHANNEL, (uint64_t)freq * fdiv, CLK2_FREQUENCY * mul, SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA | SI5351_CLK_PLL_SELECT_B);
 800a10e:	4917      	ldr	r1, [pc, #92]	@ (800a16c <si5351_set_frequency+0x270>)
 800a110:	9805      	ldr	r0, [sp, #20]
 800a112:	9a06      	ldr	r2, [sp, #24]
 800a114:	fb01 f000 	mul.w	r0, r1, r0
 800a118:	9000      	str	r0, [sp, #0]
 800a11a:	2100      	movs	r1, #0
 800a11c:	2020      	movs	r0, #32
 800a11e:	e9cd 1001 	strd	r1, r0, [sp, #4]
 800a122:	4653      	mov	r3, sl
 800a124:	2002      	movs	r0, #2
 800a126:	f7ff fe69 	bl	8009dfc <si5351_set_frequency_fixedpll>
      delay= DELAY_BAND_3_4;
 800a12a:	200c      	movs	r0, #12
      break;
 800a12c:	e749      	b.n	8009fc2 <si5351_set_frequency+0xc6>
    band = si5351_get_harmonic_lvl(freq);
 800a12e:	9305      	str	r3, [sp, #20]
 800a130:	f7ff fecc 	bl	8009ecc <si5351_get_harmonic_lvl>
  if (current_power != drive_strength){
 800a134:	4a0b      	ldr	r2, [pc, #44]	@ (800a164 <si5351_set_frequency+0x268>)
 800a136:	9b05      	ldr	r3, [sp, #20]
 800a138:	7811      	ldrb	r1, [r2, #0]
 800a13a:	42a9      	cmp	r1, r5
    band = si5351_get_harmonic_lvl(freq);
 800a13c:	b2c6      	uxtb	r6, r0
  if (current_power != drive_strength){
 800a13e:	d00b      	beq.n	800a158 <si5351_set_frequency+0x25c>
  current_band = 0;
 800a140:	4f09      	ldr	r7, [pc, #36]	@ (800a168 <si5351_set_frequency+0x26c>)
  current_freq = 0;
 800a142:	f8df b034 	ldr.w	fp, [pc, #52]	@ 800a178 <si5351_set_frequency+0x27c>
    current_power = drive_strength;
 800a146:	7015      	strb	r5, [r2, #0]
  current_band = 0;
 800a148:	2200      	movs	r2, #0
 800a14a:	703a      	strb	r2, [r7, #0]
  current_freq = 0;
 800a14c:	f8cb 2000 	str.w	r2, [fp]
  uint32_t rdiv = SI5351_R_DIV_1;
 800a150:	9206      	str	r2, [sp, #24]
 800a152:	e709      	b.n	8009f68 <si5351_set_frequency+0x6c>
    return DELAY_CHANNEL_CHANGE;
 800a154:	200a      	movs	r0, #10
 800a156:	e747      	b.n	8009fe8 <si5351_set_frequency+0xec>
  uint32_t rdiv = SI5351_R_DIV_1;
 800a158:	2200      	movs	r2, #0
 800a15a:	9206      	str	r2, [sp, #24]
 800a15c:	e6fc      	b.n	8009f58 <si5351_set_frequency+0x5c>
 800a15e:	bf00      	nop
 800a160:	000f4240 	.word	0x000f4240
 800a164:	20006908 	.word	0x20006908
 800a168:	20006909 	.word	0x20006909
 800a16c:	007a1200 	.word	0x007a1200
 800a170:	20000318 	.word	0x20000318
 800a174:	200068fc 	.word	0x200068fc
 800a178:	20006904 	.word	0x20006904

0800a17c <si5351_set_power>:
  if (drive_strength == current_power) return;
 800a17c:	4b04      	ldr	r3, [pc, #16]	@ (800a190 <si5351_set_power+0x14>)
 800a17e:	781b      	ldrb	r3, [r3, #0]
 800a180:	4283      	cmp	r3, r0
void si5351_set_power(uint8_t drive_strength){
 800a182:	4601      	mov	r1, r0
  if (drive_strength == current_power) return;
 800a184:	d003      	beq.n	800a18e <si5351_set_power+0x12>
  si5351_set_frequency(current_freq, drive_strength);
 800a186:	4b03      	ldr	r3, [pc, #12]	@ (800a194 <si5351_set_power+0x18>)
 800a188:	6818      	ldr	r0, [r3, #0]
 800a18a:	f7ff beb7 	b.w	8009efc <si5351_set_frequency>
}
 800a18e:	4770      	bx	lr
 800a190:	20006908 	.word	0x20006908
 800a194:	20006904 	.word	0x20006904

0800a198 <si5351_init>:
{
 800a198:	b538      	push	{r3, r4, r5, lr}
  const uint8_t *p = si5351_configs;
 800a19a:	4b0b      	ldr	r3, [pc, #44]	@ (800a1c8 <si5351_init+0x30>)
  while (*p) {
 800a19c:	2402      	movs	r4, #2
    uint8_t len = *p++;
 800a19e:	1c5d      	adds	r5, r3, #1
    si5351_bulk_write(p, len);
 800a1a0:	4621      	mov	r1, r4
 800a1a2:	4628      	mov	r0, r5
 800a1a4:	f7ff fd32 	bl	8009c0c <si5351_bulk_write>
    p += len;
 800a1a8:	192b      	adds	r3, r5, r4
  while (*p) {
 800a1aa:	5d2c      	ldrb	r4, [r5, r4]
 800a1ac:	2c00      	cmp	r4, #0
 800a1ae:	d1f6      	bne.n	800a19e <si5351_init+0x6>
  si5351_set_band_mode(config._band_mode);
 800a1b0:	4b06      	ldr	r3, [pc, #24]	@ (800a1cc <si5351_init+0x34>)
 800a1b2:	f893 006c 	ldrb.w	r0, [r3, #108]	@ 0x6c
 800a1b6:	f7ff fe7f 	bl	8009eb8 <si5351_set_band_mode>
  si5351_set_frequency(XTALFREQ, 0);
 800a1ba:	4621      	mov	r1, r4
 800a1bc:	4804      	ldr	r0, [pc, #16]	@ (800a1d0 <si5351_init+0x38>)
}
 800a1be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  si5351_set_frequency(XTALFREQ, 0);
 800a1c2:	f7ff be9b 	b.w	8009efc <si5351_set_frequency>
 800a1c6:	bf00      	nop
 800a1c8:	08016118 	.word	0x08016118
 800a1cc:	20000318 	.word	0x20000318
 800a1d0:	018cba80 	.word	0x018cba80

0800a1d4 <tlv320aic3204_config>:
}
#endif

static void
tlv320aic3204_config(const uint8_t *data, int len)
{
 800a1d4:	b538      	push	{r3, r4, r5, lr}
 800a1d6:	4604      	mov	r4, r0
  for (; len--; data += 2)
 800a1d8:	eb00 0541 	add.w	r5, r0, r1, lsl #1
  i2c_transfer(AIC3204_ADDR, buf, len);
 800a1dc:	4621      	mov	r1, r4
 800a1de:	2202      	movs	r2, #2
 800a1e0:	2018      	movs	r0, #24
  for (; len--; data += 2)
 800a1e2:	3402      	adds	r4, #2
  i2c_transfer(AIC3204_ADDR, buf, len);
 800a1e4:	f007 fcf0 	bl	8011bc8 <i2c_transfer>
  for (; len--; data += 2)
 800a1e8:	42a5      	cmp	r5, r4
 800a1ea:	d1f7      	bne.n	800a1dc <tlv320aic3204_config+0x8>
    tlv320aic3204_bulk_write(data, 2);
}
 800a1ec:	bd38      	pop	{r3, r4, r5, pc}
 800a1ee:	bf00      	nop

0800a1f0 <tlv320aic3204_init>:

void tlv320aic3204_init(void)
{
 800a1f0:	b508      	push	{r3, lr}
  tlv320aic3204_config(conf_data, sizeof(conf_data)/2);
 800a1f2:	4805      	ldr	r0, [pc, #20]	@ (800a208 <tlv320aic3204_init+0x18>)
 800a1f4:	211b      	movs	r1, #27
 800a1f6:	f7ff ffed 	bl	800a1d4 <tlv320aic3204_config>
//  wait_ms(40);
  tlv320aic3204_config(conf_data_unmute, sizeof(conf_data_unmute)/2);
}
 800a1fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  tlv320aic3204_config(conf_data_unmute, sizeof(conf_data_unmute)/2);
 800a1fe:	4803      	ldr	r0, [pc, #12]	@ (800a20c <tlv320aic3204_init+0x1c>)
 800a200:	2104      	movs	r1, #4
 800a202:	f7ff bfe7 	b.w	800a1d4 <tlv320aic3204_config>
 800a206:	bf00      	nop
 800a208:	08016140 	.word	0x08016140
 800a20c:	08016138 	.word	0x08016138

0800a210 <tlv320aic3204_select>:
  static uint8_t current_channel = -1;
  if (current_channel == channel)
    return;
  current_channel = channel;
#endif
  tlv320aic3204_bulk_write(channel ? conf_data_ch1_select : conf_data_ch3_select, sizeof(conf_data_ch1_select));
 800a210:	b120      	cbz	r0, 800a21c <tlv320aic3204_select+0xc>
 800a212:	4905      	ldr	r1, [pc, #20]	@ (800a228 <tlv320aic3204_select+0x18>)
  i2c_transfer(AIC3204_ADDR, buf, len);
 800a214:	2205      	movs	r2, #5
 800a216:	2018      	movs	r0, #24
 800a218:	f007 bcd6 	b.w	8011bc8 <i2c_transfer>
  tlv320aic3204_bulk_write(channel ? conf_data_ch1_select : conf_data_ch3_select, sizeof(conf_data_ch1_select));
 800a21c:	4903      	ldr	r1, [pc, #12]	@ (800a22c <tlv320aic3204_select+0x1c>)
  i2c_transfer(AIC3204_ADDR, buf, len);
 800a21e:	2205      	movs	r2, #5
 800a220:	2018      	movs	r0, #24
 800a222:	f007 bcd1 	b.w	8011bc8 <i2c_transfer>
 800a226:	bf00      	nop
 800a228:	08016128 	.word	0x08016128
 800a22c:	08016130 	.word	0x08016130

0800a230 <tlv320aic3204_set_gain>:
//  tlv320aic3204_config(channel ? conf_data_ch1_select : conf_data_ch3_select, sizeof(conf_data_ch3_select)/2);
}

void tlv320aic3204_set_gain(uint8_t lgain, uint8_t rgain)
{
 800a230:	b500      	push	{lr}
 800a232:	b083      	sub	sp, #12
 800a234:	460b      	mov	r3, r1
  uint8_t data[] = {
 800a236:	f04f 0c3b 	mov.w	ip, #59	@ 0x3b
 800a23a:	f88d 0005 	strb.w	r0, [sp, #5]
  i2c_transfer(AIC3204_ADDR, buf, len);
 800a23e:	2203      	movs	r2, #3
 800a240:	a901      	add	r1, sp, #4
 800a242:	2018      	movs	r0, #24
  uint8_t data[] = {
 800a244:	f88d c004 	strb.w	ip, [sp, #4]
 800a248:	f88d 3006 	strb.w	r3, [sp, #6]
  i2c_transfer(AIC3204_ADDR, buf, len);
 800a24c:	f007 fcbc 	bl	8011bc8 <i2c_transfer>
    0x3b,   lgain, // Unmute Left MICPGA, set gain
  /*0x3c,*/ rgain  // Unmute Right MICPGA, set gain
  };
//  tlv320aic3204_config(data, sizeof(data)/2);
  tlv320aic3204_bulk_write(data, sizeof(data));
}
 800a250:	b003      	add	sp, #12
 800a252:	f85d fb04 	ldr.w	pc, [sp], #4
 800a256:	bf00      	nop

0800a258 <generate_DSP_Table>:

#include "nanovna.h"

#ifdef USE_VARIABLE_OFFSET
static int16_t sincos_tbl[AUDIO_SAMPLES_COUNT][2];
void generate_DSP_Table(int offset){
 800a258:	b530      	push	{r4, r5, lr}
 800a25a:	ed2d 8b04 	vpush	{d8-d9}
 800a25e:	ee09 0a10 	vmov	s18, r0
  float audio_freq  = AUDIO_ADC_FREQ;
  // N = offset * AUDIO_SAMPLES_COUNT / audio_freq; should be integer
  // AUDIO_SAMPLES_COUNT = N * audio_freq / offset; N - minimum integer value for get integer AUDIO_SAMPLES_COUNT
  // Bandwidth on one step = audio_freq / AUDIO_SAMPLES_COUNT
  float step = offset / audio_freq;
 800a262:	eddf 7a19 	vldr	s15, [pc, #100]	@ 800a2c8 <generate_DSP_Table+0x70>
 800a266:	4c19      	ldr	r4, [pc, #100]	@ (800a2cc <generate_DSP_Table+0x74>)
  float w = step/2;
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
    float s, c;
    vna_sincosf(w, &s, &c);
    sincos_tbl[i][0] = s*32700.0f;
 800a268:	eddf 8a19 	vldr	s17, [pc, #100]	@ 800a2d0 <generate_DSP_Table+0x78>
  float step = offset / audio_freq;
 800a26c:	eeb8 9ac9 	vcvt.f32.s32	s18, s18
  float w = step/2;
 800a270:	eeb6 8a00 	vmov.f32	s16, #96	@ 0x3f000000  0.5
  float step = offset / audio_freq;
 800a274:	ee29 9a27 	vmul.f32	s18, s18, s15
void generate_DSP_Table(int offset){
 800a278:	b083      	sub	sp, #12
  float w = step/2;
 800a27a:	ee29 8a08 	vmul.f32	s16, s18, s16
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 800a27e:	f104 05c0 	add.w	r5, r4, #192	@ 0xc0
    vna_sincosf(w, &s, &c);
 800a282:	eeb0 0a48 	vmov.f32	s0, s16
 800a286:	a901      	add	r1, sp, #4
 800a288:	4668      	mov	r0, sp
 800a28a:	f007 ff8f 	bl	80121ac <vna_sincosf>
    sincos_tbl[i][0] = s*32700.0f;
 800a28e:	ed9d 7a00 	vldr	s14, [sp]
    sincos_tbl[i][1] = c*32700.0f;
 800a292:	eddd 7a01 	vldr	s15, [sp, #4]
    sincos_tbl[i][0] = s*32700.0f;
 800a296:	ee27 7a28 	vmul.f32	s14, s14, s17
    sincos_tbl[i][1] = c*32700.0f;
 800a29a:	ee67 7aa8 	vmul.f32	s15, s15, s17
    sincos_tbl[i][0] = s*32700.0f;
 800a29e:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    sincos_tbl[i][1] = c*32700.0f;
 800a2a2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    sincos_tbl[i][0] = s*32700.0f;
 800a2a6:	ee17 3a10 	vmov	r3, s14
 800a2aa:	8023      	strh	r3, [r4, #0]
    sincos_tbl[i][1] = c*32700.0f;
 800a2ac:	ee17 3a90 	vmov	r3, s15
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 800a2b0:	3404      	adds	r4, #4
    sincos_tbl[i][1] = c*32700.0f;
 800a2b2:	f824 3c02 	strh.w	r3, [r4, #-2]
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 800a2b6:	42ac      	cmp	r4, r5
    w+=step;
 800a2b8:	ee38 8a09 	vadd.f32	s16, s16, s18
  for (int i=0; i<AUDIO_SAMPLES_COUNT; i++){
 800a2bc:	d1e1      	bne.n	800a282 <generate_DSP_Table+0x2a>
  }
}
 800a2be:	b003      	add	sp, #12
 800a2c0:	ecbd 8b04 	vpop	{d8-d9}
 800a2c4:	bd30      	pop	{r4, r5, pc}
 800a2c6:	bf00      	nop
 800a2c8:	36aec33e 	.word	0x36aec33e
 800a2cc:	20006930 	.word	0x20006930
 800a2d0:	46ff7800 	.word	0x46ff7800

0800a2d4 <dsp_process>:
static acc_t acc_ref_c;
// Cortex M4 DSP instruction use
#include "dsp.h"
void
dsp_process(audio_sample_t *capture, size_t length)
{
 800a2d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a2d8:	b087      	sub	sp, #28
 800a2da:	4b20      	ldr	r3, [pc, #128]	@ (800a35c <dsp_process+0x88>)
 800a2dc:	9303      	str	r3, [sp, #12]
    acc_samp_s= __smlaltb(acc_samp_s, sr, sc ); // samp_s+= smp * sin
    acc_samp_c= __smlaltt(acc_samp_c, sr, sc ); // samp_c+= smp * cos
    acc_ref_s = __smlalbb( acc_ref_s, sr, sc ); //  ref_s+= ref * sin
    acc_ref_c = __smlalbt( acc_ref_c, sr, sc ); //  ref_s+= ref * cos
    i++;
  } while (i < length/2);
 800a2de:	084b      	lsrs	r3, r1, #1
 800a2e0:	9305      	str	r3, [sp, #20]
 800a2e2:	1f03      	subs	r3, r0, #4
 800a2e4:	9302      	str	r3, [sp, #8]
 800a2e6:	f8df b078 	ldr.w	fp, [pc, #120]	@ 800a360 <dsp_process+0x8c>
 800a2ea:	f8df a078 	ldr.w	sl, [pc, #120]	@ 800a364 <dsp_process+0x90>
 800a2ee:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 800a368 <dsp_process+0x94>
 800a2f2:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 800a36c <dsp_process+0x98>
  uint32_t i = 0;
 800a2f6:	2300      	movs	r3, #0
 800a2f8:	9301      	str	r3, [sp, #4]
    i++;
 800a2fa:	9a01      	ldr	r2, [sp, #4]
    int32_t sc = ((int32_t *)sincos_tbl)[i];
 800a2fc:	9803      	ldr	r0, [sp, #12]
    acc_ref_s = __smlalbb( acc_ref_s, sr, sc ); //  ref_s+= ref * sin
 800a2fe:	f8d9 5000 	ldr.w	r5, [r9]
 800a302:	f8d9 4004 	ldr.w	r4, [r9, #4]
    acc_samp_s= __smlaltb(acc_samp_s, sr, sc ); // samp_s+= smp * sin
 800a306:	e9db 1300 	ldrd	r1, r3, [fp]
    i++;
 800a30a:	3201      	adds	r2, #1
 800a30c:	9201      	str	r2, [sp, #4]
    int32_t sc = ((int32_t *)sincos_tbl)[i];
 800a30e:	f850 2b04 	ldr.w	r2, [r0], #4
 800a312:	9003      	str	r0, [sp, #12]
  register union {
    struct { uint32_t lo; uint32_t hi; } s_rep;
    int64_t i_rep;
  } r;
  r.i_rep = acc;
  __asm__ ("smlaltb %[r_lo], %[r_hi], %[x], %[y]"
 800a314:	468e      	mov	lr, r1
    acc_ref_c = __smlalbt( acc_ref_c, sr, sc ); //  ref_s+= ref * cos
 800a316:	e9d8 0100 	ldrd	r0, r1, [r8]
  __asm__ ("smlalbt %[r_lo], %[r_hi], %[x], %[y]"
 800a31a:	9104      	str	r1, [sp, #16]
    int32_t sr = ((int32_t *)capture)[i];
 800a31c:	9902      	ldr	r1, [sp, #8]
  __asm__ ("smlaltb %[r_lo], %[r_hi], %[x], %[y]"
 800a31e:	469c      	mov	ip, r3
 800a320:	f851 3f04 	ldr.w	r3, [r1, #4]!
 800a324:	9102      	str	r1, [sp, #8]
 800a326:	fbc3 eca2 	smlaltb	lr, ip, r3, r2
  __asm__ ("smlalbb %[r_lo], %[r_hi], %[x], %[y]"
 800a32a:	fbc3 5482 	smlalbb	r5, r4, r3, r2
    acc_samp_c= __smlaltt(acc_samp_c, sr, sc ); // samp_c+= smp * cos
 800a32e:	e9da 7600 	ldrd	r7, r6, [sl]
  register union {
    struct { uint32_t lo; uint32_t hi; } s_rep;
    int64_t i_rep;
  } r;
  r.i_rep = acc;
  __asm__ ("smlaltt %[r_lo], %[r_hi], %[x], %[y]"
 800a332:	fbc3 76b2 	smlaltt	r7, r6, r3, r2
  __asm__ ("smlalbt %[r_lo], %[r_hi], %[x], %[y]"
 800a336:	9904      	ldr	r1, [sp, #16]
 800a338:	fbc3 0192 	smlalbt	r0, r1, r3, r2
  } while (i < length/2);
 800a33c:	9b05      	ldr	r3, [sp, #20]
 800a33e:	9a01      	ldr	r2, [sp, #4]
 800a340:	4293      	cmp	r3, r2
    acc_samp_s= __smlaltb(acc_samp_s, sr, sc ); // samp_s+= smp * sin
 800a342:	e9cb ec00 	strd	lr, ip, [fp]
    acc_samp_c= __smlaltt(acc_samp_c, sr, sc ); // samp_c+= smp * cos
 800a346:	e9ca 7600 	strd	r7, r6, [sl]
    acc_ref_s = __smlalbb( acc_ref_s, sr, sc ); //  ref_s+= ref * sin
 800a34a:	e9c9 5400 	strd	r5, r4, [r9]
    acc_ref_c = __smlalbt( acc_ref_c, sr, sc ); //  ref_s+= ref * cos
 800a34e:	e9c8 0100 	strd	r0, r1, [r8]
  } while (i < length/2);
 800a352:	d8d2      	bhi.n	800a2fa <dsp_process+0x26>
// Accumulate result, for faster calc and prevent overflow reduce size to int32_t
//  acc_samp_s+= (int32_t)(samp_s>>4);
//  acc_samp_c+= (int32_t)(samp_c>>4);
//  acc_ref_s += (int32_t)( ref_s>>4);
//  acc_ref_c += (int32_t)( ref_c>>4);
}
 800a354:	b007      	add	sp, #28
 800a356:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a35a:	bf00      	nop
 800a35c:	20006930 	.word	0x20006930
 800a360:	20006928 	.word	0x20006928
 800a364:	20006920 	.word	0x20006920
 800a368:	20006918 	.word	0x20006918
 800a36c:	20006910 	.word	0x20006910

0800a370 <calculate_gamma>:
#endif

void
calculate_gamma(float *gamma)
{
 800a370:	b510      	push	{r4, lr}
  measure_t ss = acc_samp_s;
  measure_t sc = acc_samp_c;
  gamma[0] =  (sc * rc + ss * rs) / rr;
  gamma[1] =  (ss * rc - sc * rs) / rr;
#else
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 800a372:	4b1f      	ldr	r3, [pc, #124]	@ (800a3f0 <calculate_gamma+0x80>)
{
 800a374:	ed2d 8b04 	vpush	{d8-d9}
 800a378:	4604      	mov	r4, r0
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 800a37a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a37e:	f7f6 fa87 	bl	8000890 <__aeabi_l2f>
 800a382:	ee07 0a90 	vmov	s15, r0
 800a386:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 800a38a:	eec8 9aa7 	vdiv.f32	s19, s17, s15
 800a38e:	4b19      	ldr	r3, [pc, #100]	@ (800a3f4 <calculate_gamma+0x84>)
 800a390:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a394:	f7f6 fa7c 	bl	8000890 <__aeabi_l2f>
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 800a398:	4b17      	ldr	r3, [pc, #92]	@ (800a3f8 <calculate_gamma+0x88>)
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 800a39a:	ee08 0a10 	vmov	s16, r0
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 800a39e:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a3a2:	f7f6 fa75 	bl	8000890 <__aeabi_l2f>
  measure_t ss_rc = (measure_t)acc_samp_s / acc_ref_c;
 800a3a6:	4b15      	ldr	r3, [pc, #84]	@ (800a3fc <calculate_gamma+0x8c>)
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 800a3a8:	ee09 0a10 	vmov	s18, r0
  measure_t ss_rc = (measure_t)acc_samp_s / acc_ref_c;
 800a3ac:	e9d3 0100 	ldrd	r0, r1, [r3]
 800a3b0:	f7f6 fa6e 	bl	8000890 <__aeabi_l2f>
 800a3b4:	ee07 0a90 	vmov	s15, r0
  measure_t sc_rc = (measure_t)acc_samp_c / acc_ref_c;
 800a3b8:	ee29 9a29 	vmul.f32	s18, s18, s19
  measure_t rs_rc = (measure_t) acc_ref_s / acc_ref_c;
 800a3bc:	ee28 8a29 	vmul.f32	s16, s16, s19
  measure_t ss_rc = (measure_t)acc_samp_s / acc_ref_c;
 800a3c0:	ee67 7aa9 	vmul.f32	s15, s15, s19
  measure_t rr = rs_rc * rs_rc + 1.0f;
 800a3c4:	eeb0 7a68 	vmov.f32	s14, s17
  gamma[0] = (sc_rc + ss_rc * rs_rc) / rr;
 800a3c8:	eef0 6a49 	vmov.f32	s13, s18
 800a3cc:	eee8 6a27 	vfma.f32	s13, s16, s15
  measure_t rr = rs_rc * rs_rc + 1.0f;
 800a3d0:	eea8 7a08 	vfma.f32	s14, s16, s16
  gamma[1] = (ss_rc - sc_rc * rs_rc) / rr;
 800a3d4:	eee8 7a49 	vfms.f32	s15, s16, s18
#endif
}
 800a3d8:	ecbd 8b04 	vpop	{d8-d9}
  gamma[0] = (sc_rc + ss_rc * rs_rc) / rr;
 800a3dc:	ee86 6a87 	vdiv.f32	s12, s13, s14
  gamma[1] = (ss_rc - sc_rc * rs_rc) / rr;
 800a3e0:	eec7 6a87 	vdiv.f32	s13, s15, s14
  gamma[0] = (sc_rc + ss_rc * rs_rc) / rr;
 800a3e4:	ed84 6a00 	vstr	s12, [r4]
  gamma[1] = (ss_rc - sc_rc * rs_rc) / rr;
 800a3e8:	edc4 6a01 	vstr	s13, [r4, #4]
}
 800a3ec:	bd10      	pop	{r4, pc}
 800a3ee:	bf00      	nop
 800a3f0:	20006910 	.word	0x20006910
 800a3f4:	20006918 	.word	0x20006918
 800a3f8:	20006920 	.word	0x20006920
 800a3fc:	20006928 	.word	0x20006928

0800a400 <reset_dsp_accumerator>:
  gamma[1] =  acc_ref_c * 1e-9;
}

void
reset_dsp_accumerator(void)
{
 800a400:	b430      	push	{r4, r5}
  acc_ref_s = 0;
  acc_ref_c = 0;
  acc_samp_s = 0;
 800a402:	4808      	ldr	r0, [pc, #32]	@ (800a424 <reset_dsp_accumerator+0x24>)
  acc_ref_s = 0;
 800a404:	4d08      	ldr	r5, [pc, #32]	@ (800a428 <reset_dsp_accumerator+0x28>)
  acc_ref_c = 0;
 800a406:	4c09      	ldr	r4, [pc, #36]	@ (800a42c <reset_dsp_accumerator+0x2c>)
  acc_samp_c = 0;
 800a408:	4909      	ldr	r1, [pc, #36]	@ (800a430 <reset_dsp_accumerator+0x30>)
  acc_ref_s = 0;
 800a40a:	2200      	movs	r2, #0
 800a40c:	2300      	movs	r3, #0
 800a40e:	e9c5 2300 	strd	r2, r3, [r5]
  acc_ref_c = 0;
 800a412:	e9c4 2300 	strd	r2, r3, [r4]
  acc_samp_s = 0;
 800a416:	e9c0 2300 	strd	r2, r3, [r0]
}
 800a41a:	bc30      	pop	{r4, r5}
  acc_samp_c = 0;
 800a41c:	e9c1 2300 	strd	r2, r3, [r1]
}
 800a420:	4770      	bx	lr
 800a422:	bf00      	nop
 800a424:	20006928 	.word	0x20006928
 800a428:	20006918 	.word	0x20006918
 800a42c:	20006910 	.word	0x20006910
 800a430:	20006920 	.word	0x20006920

0800a434 <smith_grid>:
}
#else
static int smith_grid(int x, int y)
{
  uint16_t r = P_RADIUS;
  uint32_t _r = x * x + y * y;
 800a434:	fb01 f301 	mul.w	r3, r1, r1
 800a438:	fb00 3300 	mla	r3, r0, r0, r3
  int32_t d = _r;
  if (d > r * r + r)
 800a43c:	f645 22d8 	movw	r2, #23256	@ 0x5ad8
 800a440:	4293      	cmp	r3, r2
 800a442:	dc52      	bgt.n	800a4ea <smith_grid+0xb6>
    return 0; // outer area
  if (d > r * r - r)
 800a444:	f645 12a8 	movw	r2, #22952	@ 0x59a8
 800a448:	4293      	cmp	r3, r2
 800a44a:	dc4c      	bgt.n	800a4e6 <smith_grid+0xb2>
    return 1; // 1 - outer circle
  if (y == 0)
 800a44c:	2900      	cmp	r1, #0
 800a44e:	d04a      	beq.n	800a4e6 <smith_grid+0xb2>
    return 1; // 2 - horizontal axis
  if (y < 0)
 800a450:	2900      	cmp	r1, #0
 800a452:	bfb8      	it	lt
 800a454:	4249      	neglt	r1, r1
    y = -y; //  mirror by y axis
  uint32_t r_y = r * y;
 800a456:	f04f 0c98 	mov.w	ip, #152	@ 0x98
  if (x >= 0)
  { //   valid only if x >= 0
    if (x >= r / 2)
    { //    valid only if x >= P_RADIUS/2
      d = _r - 2 * r * x - r_y + r * r + r / 2;
 800a45a:	f44f 7298 	mov.w	r2, #304	@ 0x130
  if (x >= 0)
 800a45e:	2800      	cmp	r0, #0
  uint32_t r_y = r * y;
 800a460:	fb0c f101 	mul.w	r1, ip, r1
      d = _r - 2 * r * x - r_y + r * r + r / 2;
 800a464:	fb02 3210 	mls	r2, r2, r0, r3
  if (x >= 0)
 800a468:	db2a      	blt.n	800a4c0 <smith_grid+0x8c>
    if (x >= r / 2)
 800a46a:	284b      	cmp	r0, #75	@ 0x4b
 800a46c:	dd15      	ble.n	800a49a <smith_grid+0x66>
      d = _r - 2 * r * x - r_y + r * r + r / 2;
 800a46e:	f5c1 4cb5 	rsb	ip, r1, #23168	@ 0x5a80
 800a472:	f10c 0c0c 	add.w	ip, ip, #12
 800a476:	4494      	add	ip, r2
      if ((uint32_t)d <= r)
 800a478:	f1bc 0f98 	cmp.w	ip, #152	@ 0x98
 800a47c:	d933      	bls.n	800a4e6 <smith_grid+0xb2>
        return 1; // 3 - Constant Reactance Circle: 2j : R/2 = P_RADIUS/2 (mirror by y)
      d = _r - (3 * r / 2) * x + r * r / 2 + r / 4;
 800a47e:	f04f 0ce4 	mov.w	ip, #228	@ 0xe4
 800a482:	fb0c 3c10 	mls	ip, ip, r0, r3
 800a486:	f50c 5c35 	add.w	ip, ip, #11584	@ 0x2d40
 800a48a:	f10c 0c06 	add.w	ip, ip, #6
      if (d < 0)
 800a48e:	f1bc 0f00 	cmp.w	ip, #0
 800a492:	db2a      	blt.n	800a4ea <smith_grid+0xb6>
        return 0;
      if (d <= r / 2)
 800a494:	f1bc 0f4c 	cmp.w	ip, #76	@ 0x4c
 800a498:	dd25      	ble.n	800a4e6 <smith_grid+0xb2>
        return 1; // 4 - Constant Resistance Circle: 3 : R/4 = P_RADIUS/4
    }
    d = _r - 2 * r * x - 2 * r_y + r * r + r;
 800a49a:	eba2 0c41 	sub.w	ip, r2, r1, lsl #1
 800a49e:	f50c 4cb5 	add.w	ip, ip, #23168	@ 0x5a80
 800a4a2:	f10c 0c58 	add.w	ip, ip, #88	@ 0x58
    if ((uint32_t)d <= 2 * r)
 800a4a6:	f5bc 7f98 	cmp.w	ip, #304	@ 0x130
 800a4aa:	d91c      	bls.n	800a4e6 <smith_grid+0xb2>
      return 1; // 5 - Constant Reactance Circle: 1j : R = P_RADIUS  (mirror by y)
    d = _r - r * x + r / 2;
 800a4ac:	f04f 0c98 	mov.w	ip, #152	@ 0x98
 800a4b0:	fb0c 3c10 	mls	ip, ip, r0, r3
    if (d < 0)
 800a4b4:	f11c 0c4c 	adds.w	ip, ip, #76	@ 0x4c
 800a4b8:	d417      	bmi.n	800a4ea <smith_grid+0xb6>
      return 0;
    if (d <= r)
 800a4ba:	f1bc 0f98 	cmp.w	ip, #152	@ 0x98
 800a4be:	dd12      	ble.n	800a4e6 <smith_grid+0xb2>
      return 1; // 6 - Constant Resistance Circle: 1 : R/2
  }
  d = _r - 2 * r * x - 4 * r_y + r * r + r * 2;
 800a4c0:	eba2 0281 	sub.w	r2, r2, r1, lsl #2
 800a4c4:	f502 42b6 	add.w	r2, r2, #23296	@ 0x5b00
 800a4c8:	3270      	adds	r2, #112	@ 0x70
  if ((uint32_t)d <= r * 4)
 800a4ca:	f5b2 7f18 	cmp.w	r2, #608	@ 0x260
 800a4ce:	d90a      	bls.n	800a4e6 <smith_grid+0xb2>
    return 1; // 7 - Constant Reactance Circle: 1/2j : R*2  (mirror by y)
  d = _r - x * (r / 2) - r * r / 2 + r * 3 / 4;
 800a4d0:	224c      	movs	r2, #76	@ 0x4c
 800a4d2:	fb02 3010 	mls	r0, r2, r0, r3
 800a4d6:	f5a0 5032 	sub.w	r0, r0, #11392	@ 0x2c80
 800a4da:	382e      	subs	r0, #46	@ 0x2e
  if ((uint32_t)d <= r * 3 / 2)
 800a4dc:	28e4      	cmp	r0, #228	@ 0xe4
 800a4de:	bf8c      	ite	hi
 800a4e0:	2000      	movhi	r0, #0
 800a4e2:	2001      	movls	r0, #1
 800a4e4:	4770      	bx	lr
    return 1; // 1 - outer circle
 800a4e6:	2001      	movs	r0, #1
    return 1; // 8 - Constant Resistance Circle: 1/3 : R*3/4
  return 0;
}
 800a4e8:	4770      	bx	lr
    return 0; // outer area
 800a4ea:	2000      	movs	r0, #0
 800a4ec:	4770      	bx	lr
 800a4ee:	bf00      	nop

0800a4f0 <cell_blit_bitmap>:
  }
}

// Slower, but allow any width bitmaps
static void cell_blit_bitmap(int16_t x, int16_t y, uint16_t w, uint16_t h, const uint8_t *bmp)
{
 800a4f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a4f4:	4606      	mov	r6, r0
 800a4f6:	4610      	mov	r0, r2
  int16_t x1, y1;
  if ((x1 = x + w) < 0 || (y1 = y + h) < 0)
 800a4f8:	1984      	adds	r4, r0, r6
 800a4fa:	0424      	lsls	r4, r4, #16
{
 800a4fc:	9a06      	ldr	r2, [sp, #24]
  if ((x1 = x + w) < 0 || (y1 = y + h) < 0)
 800a4fe:	d439      	bmi.n	800a574 <cell_blit_bitmap+0x84>
 800a500:	440b      	add	r3, r1
 800a502:	b21b      	sxth	r3, r3
 800a504:	2b00      	cmp	r3, #0
 800a506:	db35      	blt.n	800a574 <cell_blit_bitmap+0x84>
    return;
  if (y1 >= CELLHEIGHT)
 800a508:	2b20      	cmp	r3, #32
 800a50a:	bfa8      	it	ge
 800a50c:	2320      	movge	r3, #32
    y1 = CELLHEIGHT; // clip bottom
  if (y < 0)
 800a50e:	2900      	cmp	r1, #0
 800a510:	db32      	blt.n	800a578 <cell_blit_bitmap+0x88>
  {
    bmp -= y * ((w + 7) >> 3);
    y = 0;
  } // clip top
  for (uint8_t bits = 0; y < y1; y++)
 800a512:	4299      	cmp	r1, r3
 800a514:	da2e      	bge.n	800a574 <cell_blit_bitmap+0x84>
 800a516:	1a5b      	subs	r3, r3, r1
 800a518:	fa11 f783 	uxtah	r7, r1, r3
        bits = *bmp++;
      if ((0x80 & bits) == 0)
        continue; // no pixel
      if ((uint32_t)(x + r) >= CELLWIDTH)
        continue; // x+r < 0 || x+r >= CELLWIDTH
      cell_buffer[y * CELLWIDTH + x + r] = foreground_color;
 800a51c:	4b1a      	ldr	r3, [pc, #104]	@ (800a588 <cell_blit_bitmap+0x98>)
 800a51e:	f8df 806c 	ldr.w	r8, [pc, #108]	@ 800a58c <cell_blit_bitmap+0x9c>
 800a522:	681c      	ldr	r4, [r3, #0]
 800a524:	eb06 1541 	add.w	r5, r6, r1, lsl #5
 800a528:	eb06 1747 	add.w	r7, r6, r7, lsl #5
 800a52c:	eb04 0445 	add.w	r4, r4, r5, lsl #1
    bmp -= y * ((w + 7) >> 3);
 800a530:	2100      	movs	r1, #0
    y = 0;
 800a532:	46b4      	mov	ip, r6
    for (int r = 0; r < w; r++, bits <<= 1)
 800a534:	2300      	movs	r3, #0
        bits = *bmp++;
 800a536:	4696      	mov	lr, r2
      if ((r & 7) == 0)
 800a538:	f013 0f07 	tst.w	r3, #7
        bits = *bmp++;
 800a53c:	bf04      	itt	eq
 800a53e:	f81e 1b01 	ldrbeq.w	r1, [lr], #1
 800a542:	4672      	moveq	r2, lr
    for (int r = 0; r < w; r++, bits <<= 1)
 800a544:	ea4f 0e41 	mov.w	lr, r1, lsl #1
      if ((0x80 & bits) == 0)
 800a548:	f011 0f80 	tst.w	r1, #128	@ 0x80
    for (int r = 0; r < w; r++, bits <<= 1)
 800a54c:	fa5f f18e 	uxtb.w	r1, lr
      if ((0x80 & bits) == 0)
 800a550:	d006      	beq.n	800a560 <cell_blit_bitmap+0x70>
      if ((uint32_t)(x + r) >= CELLWIDTH)
 800a552:	f1bc 0f1f 	cmp.w	ip, #31
      cell_buffer[y * CELLWIDTH + x + r] = foreground_color;
 800a556:	bf9c      	itt	ls
 800a558:	f8b8 e000 	ldrhls.w	lr, [r8]
 800a55c:	f824 e013 	strhls.w	lr, [r4, r3, lsl #1]
    for (int r = 0; r < w; r++, bits <<= 1)
 800a560:	3301      	adds	r3, #1
 800a562:	4283      	cmp	r3, r0
 800a564:	f10c 0c01 	add.w	ip, ip, #1
 800a568:	d1e5      	bne.n	800a536 <cell_blit_bitmap+0x46>
  for (uint8_t bits = 0; y < y1; y++)
 800a56a:	3520      	adds	r5, #32
 800a56c:	42bd      	cmp	r5, r7
 800a56e:	f104 0440 	add.w	r4, r4, #64	@ 0x40
 800a572:	d1de      	bne.n	800a532 <cell_blit_bitmap+0x42>
    }
  }
}
 800a574:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bmp -= y * ((w + 7) >> 3);
 800a578:	1dc4      	adds	r4, r0, #7
 800a57a:	10e4      	asrs	r4, r4, #3
 800a57c:	fb04 2211 	mls	r2, r4, r1, r2
    y = 0;
 800a580:	2100      	movs	r1, #0
  for (uint8_t bits = 0; y < y1; y++)
 800a582:	4299      	cmp	r1, r3
 800a584:	dbc7      	blt.n	800a516 <cell_blit_bitmap+0x26>
 800a586:	e7f5      	b.n	800a574 <cell_blit_bitmap+0x84>
 800a588:	200089ec 	.word	0x200089ec
 800a58c:	20008a3a 	.word	0x20008a3a

0800a590 <mark_line>:
//**************************************************************************************
// Cell mark map functions
//**************************************************************************************
static void mark_line(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2)
{
  x1 /= CELLWIDTH;
 800a590:	0940      	lsrs	r0, r0, #5
  x2 /= CELLWIDTH;
 800a592:	0952      	lsrs	r2, r2, #5
  y1 /= CELLHEIGHT;
  y2 /= CELLHEIGHT;
  if (x1 == x2 && y1 == y2)
 800a594:	4290      	cmp	r0, r2
  y1 /= CELLHEIGHT;
 800a596:	ea4f 1151 	mov.w	r1, r1, lsr #5
  y2 /= CELLHEIGHT;
 800a59a:	ea4f 1353 	mov.w	r3, r3, lsr #5
  if (x1 == x2 && y1 == y2)
 800a59e:	d020      	beq.n	800a5e2 <mark_line+0x52>
  {
    markmap[y1] |= 1 << x1;
    return;
  }
  if (x1 > x2)
 800a5a0:	d92b      	bls.n	800a5fa <mark_line+0x6a>
    SWAP(uint16_t, x1, x2);
  uint32_t mask = ((1 << (x2 - x1 + 1)) - 1) << x1;
 800a5a2:	1a80      	subs	r0, r0, r2
 800a5a4:	f100 0c01 	add.w	ip, r0, #1
 800a5a8:	2001      	movs	r0, #1
 800a5aa:	fa00 f00c 	lsl.w	r0, r0, ip
 800a5ae:	3801      	subs	r0, #1
  if (y1 > y2)
 800a5b0:	4299      	cmp	r1, r3
  uint32_t mask = ((1 << (x2 - x1 + 1)) - 1) << x1;
 800a5b2:	fa00 f002 	lsl.w	r0, r0, r2
  if (y1 > y2)
 800a5b6:	d910      	bls.n	800a5da <mark_line+0x4a>
    SWAP(uint16_t, y1, y2);
  for (; y1 <= y2; y1++)
 800a5b8:	4a12      	ldr	r2, [pc, #72]	@ (800a604 <mark_line+0x74>)
 800a5ba:	1ac9      	subs	r1, r1, r3
 800a5bc:	fa13 fc81 	uxtah	ip, r3, r1
    markmap[y1] |= mask;
 800a5c0:	b281      	uxth	r1, r0
 800a5c2:	1c90      	adds	r0, r2, #2
 800a5c4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800a5c8:	eb00 004c 	add.w	r0, r0, ip, lsl #1
 800a5cc:	881a      	ldrh	r2, [r3, #0]
 800a5ce:	430a      	orrs	r2, r1
 800a5d0:	f823 2b02 	strh.w	r2, [r3], #2
  for (; y1 <= y2; y1++)
 800a5d4:	4298      	cmp	r0, r3
 800a5d6:	d1f9      	bne.n	800a5cc <mark_line+0x3c>
 800a5d8:	4770      	bx	lr
  if (y1 > y2)
 800a5da:	461a      	mov	r2, r3
  y1 /= CELLHEIGHT;
 800a5dc:	460b      	mov	r3, r1
  y2 /= CELLHEIGHT;
 800a5de:	4611      	mov	r1, r2
 800a5e0:	e7ea      	b.n	800a5b8 <mark_line+0x28>
  if (x1 == x2 && y1 == y2)
 800a5e2:	4299      	cmp	r1, r3
 800a5e4:	d1dd      	bne.n	800a5a2 <mark_line+0x12>
    markmap[y1] |= 1 << x1;
 800a5e6:	4a07      	ldr	r2, [pc, #28]	@ (800a604 <mark_line+0x74>)
 800a5e8:	2301      	movs	r3, #1
 800a5ea:	f832 c011 	ldrh.w	ip, [r2, r1, lsl #1]
 800a5ee:	4083      	lsls	r3, r0
 800a5f0:	ea43 030c 	orr.w	r3, r3, ip
 800a5f4:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    return;
 800a5f8:	4770      	bx	lr
  if (x1 > x2)
 800a5fa:	4694      	mov	ip, r2
  x1 /= CELLWIDTH;
 800a5fc:	4602      	mov	r2, r0
  x2 /= CELLWIDTH;
 800a5fe:	4660      	mov	r0, ip
 800a600:	e7cf      	b.n	800a5a2 <mark_line+0x12>
 800a602:	bf00      	nop
 800a604:	200089d8 	.word	0x200089d8

0800a608 <mark_set_index>:
}

static void mark_set_index(index_t *index, uint16_t i, uint16_t x, uint16_t y)
{
 800a608:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  static uint16_t diff;
  static index_t last_erase;
  diff = (diff << 1);
 800a60c:	f8df e088 	ldr.w	lr, [pc, #136]	@ 800a698 <mark_set_index+0x90>
 800a610:	f8be c000 	ldrh.w	ip, [lr]
{
 800a614:	4616      	mov	r6, r2
  if (index[i].x != x || index[i].y != y)
 800a616:	f830 2021 	ldrh.w	r2, [r0, r1, lsl #2]
  diff = (diff << 1);
 800a61a:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800a61e:	fa1f fc8c 	uxth.w	ip, ip
  if (index[i].x != x || index[i].y != y)
 800a622:	42b2      	cmp	r2, r6
{
 800a624:	460c      	mov	r4, r1
 800a626:	4605      	mov	r5, r0
 800a628:	461f      	mov	r7, r3
  diff = (diff << 1);
 800a62a:	f8ae c000 	strh.w	ip, [lr]
  if (index[i].x != x || index[i].y != y)
 800a62e:	ea4f 0981 	mov.w	r9, r1, lsl #2
 800a632:	eb00 0881 	add.w	r8, r0, r1, lsl #2
 800a636:	d010      	beq.n	800a65a <mark_set_index+0x52>
    diff |= 1;
 800a638:	f04c 0c01 	orr.w	ip, ip, #1
 800a63c:	f8ae c000 	strh.w	ip, [lr]
  if ((diff & 3) && i > 0)
  {                                                                // one of points for trace line change (only for > 0 index)
    mark_line(last_erase.x, last_erase.y, index[i].x, index[i].y); // mark old line for erase
 800a640:	f8df a058 	ldr.w	sl, [pc, #88]	@ 800a69c <mark_set_index+0x94>
  if ((diff & 3) && i > 0)
 800a644:	b99c      	cbnz	r4, 800a66e <mark_set_index+0x66>
    mark_line(index[i - 1].x, index[i - 1].y, x, y);               // mark new line for draw
  }
  last_erase = index[i];
 800a646:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800a64a:	f8ca 3000 	str.w	r3, [sl]
  index[i].x = x;
 800a64e:	f825 6024 	strh.w	r6, [r5, r4, lsl #2]
  index[i].y = y;
 800a652:	f8a8 7002 	strh.w	r7, [r8, #2]
}
 800a656:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (index[i].x != x || index[i].y != y)
 800a65a:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 800a65e:	42bb      	cmp	r3, r7
 800a660:	d1ea      	bne.n	800a638 <mark_set_index+0x30>
  if ((diff & 3) && i > 0)
 800a662:	f01c 0f02 	tst.w	ip, #2
 800a666:	d1eb      	bne.n	800a640 <mark_set_index+0x38>
 800a668:	f8df a030 	ldr.w	sl, [pc, #48]	@ 800a69c <mark_set_index+0x94>
 800a66c:	e7eb      	b.n	800a646 <mark_set_index+0x3e>
    mark_line(last_erase.x, last_erase.y, index[i].x, index[i].y); // mark old line for erase
 800a66e:	f8b8 3002 	ldrh.w	r3, [r8, #2]
 800a672:	f8ba 1002 	ldrh.w	r1, [sl, #2]
 800a676:	f8ba 0000 	ldrh.w	r0, [sl]
    mark_line(index[i - 1].x, index[i - 1].y, x, y);               // mark new line for draw
 800a67a:	f1a9 0904 	sub.w	r9, r9, #4
    mark_line(last_erase.x, last_erase.y, index[i].x, index[i].y); // mark old line for erase
 800a67e:	f7ff ff87 	bl	800a590 <mark_line>
    mark_line(index[i - 1].x, index[i - 1].y, x, y);               // mark new line for draw
 800a682:	eb05 0309 	add.w	r3, r5, r9
 800a686:	f835 0009 	ldrh.w	r0, [r5, r9]
 800a68a:	8859      	ldrh	r1, [r3, #2]
 800a68c:	4632      	mov	r2, r6
 800a68e:	463b      	mov	r3, r7
 800a690:	f7ff ff7e 	bl	800a590 <mark_line>
 800a694:	e7d7      	b.n	800a646 <mark_set_index+0x3e>
 800a696:	bf00      	nop
 800a698:	200069f4 	.word	0x200069f4
 800a69c:	200069f0 	.word	0x200069f0

0800a6a0 <invalidate_rect_func>:
/*
 * Force region of screen update
 */
static void invalidate_rect_func(int x0, int y0, int x1, int y1)
{
  uint32_t mask = ((1 << (x1 - x0 + 1)) - 1) << x0;
 800a6a0:	1a12      	subs	r2, r2, r0
 800a6a2:	3201      	adds	r2, #1
 800a6a4:	f04f 0c01 	mov.w	ip, #1
 800a6a8:	fa0c fc02 	lsl.w	ip, ip, r2
 800a6ac:	f10c 3cff 	add.w	ip, ip, #4294967295
  for (; y0 <= y1; y0++)
 800a6b0:	4299      	cmp	r1, r3
  uint32_t mask = ((1 << (x1 - x0 + 1)) - 1) << x0;
 800a6b2:	fa0c fc00 	lsl.w	ip, ip, r0
  for (; y0 <= y1; y0++)
 800a6b6:	dc0f      	bgt.n	800a6d8 <invalidate_rect_func+0x38>
 800a6b8:	4a08      	ldr	r2, [pc, #32]	@ (800a6dc <invalidate_rect_func+0x3c>)
 800a6ba:	3301      	adds	r3, #1
 800a6bc:	eb02 0241 	add.w	r2, r2, r1, lsl #1
    if ((uint32_t)y0 < MAX_MARKMAP_Y)
 800a6c0:	2909      	cmp	r1, #9
  for (; y0 <= y1; y0++)
 800a6c2:	f101 0101 	add.w	r1, r1, #1
    if ((uint32_t)y0 < MAX_MARKMAP_Y)
 800a6c6:	dc03      	bgt.n	800a6d0 <invalidate_rect_func+0x30>
      markmap[y0] |= mask;
 800a6c8:	8810      	ldrh	r0, [r2, #0]
 800a6ca:	ea4c 0000 	orr.w	r0, ip, r0
 800a6ce:	8010      	strh	r0, [r2, #0]
  for (; y0 <= y1; y0++)
 800a6d0:	4299      	cmp	r1, r3
 800a6d2:	f102 0202 	add.w	r2, r2, #2
 800a6d6:	d1f3      	bne.n	800a6c0 <invalidate_rect_func+0x20>
}
 800a6d8:	4770      	bx	lr
 800a6da:	bf00      	nop
 800a6dc:	200089d8 	.word	0x200089d8

0800a6e0 <real>:
//**************************************************************************************
static float real(int i, const float *v)
{
  (void)i;
  return v[0];
}
 800a6e0:	ed91 0a00 	vldr	s0, [r1]
 800a6e4:	4770      	bx	lr
 800a6e6:	bf00      	nop

0800a6e8 <imag>:
//**************************************************************************************
static float imag(int i, const float *v)
{
  (void)i;
  return v[1];
}
 800a6e8:	ed91 0a01 	vldr	s0, [r1, #4]
 800a6ec:	4770      	bx	lr
 800a6ee:	bf00      	nop

0800a6f0 <resistance>:
// Z phase = atan(X, R)
//**************************************************************************************
static float resistance(int i, const float *v)
{
  (void)i;
  return get_s11_r(1.0f - v[0], -v[1], PORT_Z);
 800a6f0:	edd1 6a00 	vldr	s13, [r1]
 800a6f4:	ed91 7a01 	vldr	s14, [r1, #4]
 800a6f8:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800a6fc:	ee77 7ae6 	vsub.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800a700:	ee27 7a07 	vmul.f32	s14, s14, s14
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800a704:	eddf 6a07 	vldr	s13, [pc, #28]	@ 800a724 <resistance+0x34>
static float get_l(float re, float im) { return (re * re + im * im); }
 800a708:	eea7 7aa7 	vfma.f32	s14, s15, s15
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800a70c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800a710:	eddf 6a05 	vldr	s13, [pc, #20]	@ 800a728 <resistance+0x38>
 800a714:	ee87 0a87 	vdiv.f32	s0, s15, s14
 800a718:	ee30 0a66 	vsub.f32	s0, s0, s13
 800a71c:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800a720:	4770      	bx	lr
 800a722:	bf00      	nop
 800a724:	42c80000 	.word	0x42c80000
 800a728:	42480000 	.word	0x42480000

0800a72c <time_of_index>:
}

static float time_of_index(int idx)
{
  freq_t span = get_sweep_frequency(ST_SPAN);
  return (idx * (sweep_points - 1)) / ((float)FFT_SIZE * span);
 800a72c:	4909      	ldr	r1, [pc, #36]	@ (800a754 <time_of_index+0x28>)
 800a72e:	8b4b      	ldrh	r3, [r1, #26]
    case ST_SPAN:   return frequency1 - frequency0;
 800a730:	e9d1 1201 	ldrd	r1, r2, [r1, #4]
 800a734:	3b01      	subs	r3, #1
 800a736:	fb00 f303 	mul.w	r3, r0, r3
 800a73a:	1a52      	subs	r2, r2, r1
 800a73c:	ee00 2a10 	vmov	s0, r2
 800a740:	ee07 3a90 	vmov	s15, r3
 800a744:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 800a748:	eefa 7aeb 	vcvt.f32.s32	s15, s15, #9
}
 800a74c:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800a750:	4770      	bx	lr
 800a752:	bf00      	nop
 800a754:	20000aa8 	.word	0x20000aa8

0800a758 <distance_of_index>:

static float distance_of_index(int idx)
{
 800a758:	b508      	push	{r3, lr}
  return velocity_factor * (SPEED_OF_LIGHT / 200.0f) * time_of_index(idx);
 800a75a:	f7ff ffe7 	bl	800a72c <time_of_index>
 800a75e:	4b07      	ldr	r3, [pc, #28]	@ (800a77c <distance_of_index+0x24>)
 800a760:	ed9f 7a07 	vldr	s14, [pc, #28]	@ 800a780 <distance_of_index+0x28>
 800a764:	f893 3099 	ldrb.w	r3, [r3, #153]	@ 0x99
 800a768:	ee07 3a90 	vmov	s15, r3
 800a76c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800a770:	ee67 7a87 	vmul.f32	s15, s15, s14
}
 800a774:	ee27 0a80 	vmul.f32	s0, s15, s0
 800a778:	bd08      	pop	{r3, pc}
 800a77a:	bf00      	nop
 800a77c:	20000aa8 	.word	0x20000aa8
 800a780:	49b6fa92 	.word	0x49b6fa92

0800a784 <_greater>:
}

//**************************************************************************************
//            Marker search functions
//**************************************************************************************
static bool _greater(int x, int y) { return x > y; }
 800a784:	4288      	cmp	r0, r1
 800a786:	bfd4      	ite	le
 800a788:	2000      	movle	r0, #0
 800a78a:	2001      	movgt	r0, #1
 800a78c:	4770      	bx	lr
 800a78e:	bf00      	nop

0800a790 <_lesser>:
static bool _lesser(int x, int y) { return x < y; }
 800a790:	4288      	cmp	r0, r1
 800a792:	bfac      	ite	ge
 800a794:	2000      	movge	r0, #0
 800a796:	2001      	movlt	r0, #1
 800a798:	4770      	bx	lr
 800a79a:	bf00      	nop

0800a79c <match_quadratic_equation>:
static char measure_memory[128];

// Measure math functions
// quadratic function solver
static void match_quadratic_equation(float a, float b, float c, float *x) {
  const float a_x_2 = 2.0f * a;
 800a79c:	ee30 0a00 	vadd.f32	s0, s0, s0
  const float d = (b * b) - (2.0f * a_x_2 * c);
 800a7a0:	ee31 1a01 	vadd.f32	s2, s2, s2
  if (d < 0){
 800a7a4:	2300      	movs	r3, #0
  const float d = (b * b) - (2.0f * a_x_2 * c);
 800a7a6:	ee20 1a41 	vnmul.f32	s2, s0, s2
 800a7aa:	eea0 1aa0 	vfma.f32	s2, s1, s1
  if (d < 0){
 800a7ae:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 800a7b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a7b6:	d502      	bpl.n	800a7be <match_quadratic_equation+0x22>
    x[0] = x[1] = 0.0f;
 800a7b8:	6043      	str	r3, [r0, #4]
 800a7ba:	6003      	str	r3, [r0, #0]
    return;
 800a7bc:	4770      	bx	lr
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800a7be:	eeb1 1ac1 	vsqrt.f32	s2, s2
  }
  const float sd = vna_sqrtf(d);
  x[0] = (-b + sd) / a_x_2;
 800a7c2:	ee31 7a60 	vsub.f32	s14, s2, s1
  x[1] = (-b - sd) / a_x_2;
 800a7c6:	ee70 0a81 	vadd.f32	s1, s1, s2
  x[0] = (-b + sd) / a_x_2;
 800a7ca:	eec7 7a00 	vdiv.f32	s15, s14, s0
  x[1] = (-b - sd) / a_x_2;
 800a7ce:	eef1 0a60 	vneg.f32	s1, s1
  x[0] = (-b + sd) / a_x_2;
 800a7d2:	edc0 7a00 	vstr	s15, [r0]
  x[1] = (-b - sd) / a_x_2;
 800a7d6:	eec0 7a80 	vdiv.f32	s15, s1, s0
 800a7da:	edc0 7a01 	vstr	s15, [r0, #4]
}
 800a7de:	4770      	bx	lr

0800a7e0 <_greaterf>:
}

// Peak search, use bilinear interpolation for peak detect
#define MEASURE_SEARCH_MIN 0
#define MEASURE_SEARCH_MAX 1
static bool _greaterf(float x, float y) { return x > y; }
 800a7e0:	eeb4 0ae0 	vcmpe.f32	s0, s1
 800a7e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a7e8:	bfcc      	ite	gt
 800a7ea:	2001      	movgt	r0, #1
 800a7ec:	2000      	movle	r0, #0
 800a7ee:	4770      	bx	lr

0800a7f0 <_lesserf>:
static bool _lesserf(float x, float y) { return x < y; }
 800a7f0:	eeb4 0ae0 	vcmpe.f32	s0, s1
 800a7f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a7f8:	bf4c      	ite	mi
 800a7fa:	2001      	movmi	r0, #1
 800a7fc:	2000      	movpl	r0, #0
 800a7fe:	4770      	bx	lr

0800a800 <s21pow2>:
//  float tan45;
} s21_analysis_t;
static s21_analysis_t *s21_measure = (s21_analysis_t *)measure_memory;

static float s21pow2(uint16_t i) {
  const float re = measured[1][i][0]; // S21 real
 800a800:	4b08      	ldr	r3, [pc, #32]	@ (800a824 <s21pow2+0x24>)
 800a802:	f200 1291 	addw	r2, r0, #401	@ 0x191
 800a806:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
  const float im = measured[1][i][1]; // S21 imaginary
 800a80a:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800a80e:	f603 438c 	addw	r3, r3, #3212	@ 0xc8c
 800a812:	ed93 0a00 	vldr	s0, [r3]
  const float re = measured[1][i][0]; // S21 real
 800a816:	edd2 7a00 	vldr	s15, [r2]
  return re*re+im*im; // S21^2
 800a81a:	ee20 0a00 	vmul.f32	s0, s0, s0
}
 800a81e:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800a822:	4770      	bx	lr
 800a824:	20004f54 	.word	0x20004f54

0800a828 <s21tan>:

static float s21tan(uint16_t i) {
  const float re = measured[1][i][0]; // S21 real
  const float im = measured[1][i][1]; // S21 imaginary
 800a828:	4b07      	ldr	r3, [pc, #28]	@ (800a848 <s21tan+0x20>)
 800a82a:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
  const float re = measured[1][i][0]; // S21 real
 800a82e:	f200 1091 	addw	r0, r0, #401	@ 0x191
  const float im = measured[1][i][1]; // S21 imaginary
 800a832:	f602 428c 	addw	r2, r2, #3212	@ 0xc8c
  const float re = measured[1][i][0]; // S21 real
 800a836:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
  return im/re; // tan(S21)
 800a83a:	ed92 0a00 	vldr	s0, [r2]
 800a83e:	edd3 7a00 	vldr	s15, [r3]
}
 800a842:	ee80 0a27 	vdiv.f32	s0, s0, s15
 800a846:	4770      	bx	lr
 800a848:	20004f54 	.word	0x20004f54

0800a84c <s11imag>:
} s11_cable_measure_t;
static s11_cable_measure_t *s11_cable = (s11_cable_measure_t *)measure_memory;
float real_cable_len = 0.0f;

static float s11imag(uint16_t i) {
  return measured[0][i][1];
 800a84c:	4b02      	ldr	r3, [pc, #8]	@ (800a858 <s11imag+0xc>)
 800a84e:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
}
 800a852:	ed93 0a01 	vldr	s0, [r3, #4]
 800a856:	4770      	bx	lr
 800a858:	20004f54 	.word	0x20004f54

0800a85c <cell_string_width>:
}

static int cell_string_width(const char *str)
{
  int w = 0;
  while (*str)
 800a85c:	7803      	ldrb	r3, [r0, #0]
 800a85e:	b1ab      	cbz	r3, 800a88c <cell_string_width+0x30>
{
 800a860:	b410      	push	{r4}
 800a862:	4c0b      	ldr	r4, [pc, #44]	@ (800a890 <cell_string_width+0x34>)
 800a864:	4601      	mov	r1, r0
  int w = 0;
 800a866:	2000      	movs	r0, #0
    w += FONT_GET_WIDTH((uint8_t)*str++);
 800a868:	3b16      	subs	r3, #22
 800a86a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800a86e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
  while (*str)
 800a872:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    w += FONT_GET_WIDTH((uint8_t)*str++);
 800a876:	5ca2      	ldrb	r2, [r4, r2]
 800a878:	f002 0207 	and.w	r2, r2, #7
 800a87c:	f1c2 0208 	rsb	r2, r2, #8
 800a880:	4410      	add	r0, r2
  while (*str)
 800a882:	2b00      	cmp	r3, #0
 800a884:	d1f0      	bne.n	800a868 <cell_string_width+0xc>
  return w;
}
 800a886:	f85d 4b04 	ldr.w	r4, [sp], #4
 800a88a:	4770      	bx	lr
  int w = 0;
 800a88c:	4618      	mov	r0, r3
}
 800a88e:	4770      	bx	lr
 800a890:	080154e0 	.word	0x080154e0

0800a894 <cell_drawstring_big>:
    }
  }
}

static void cell_drawstring_big(const char *str, int x, int y)
{
 800a894:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a898:	4603      	mov	r3, r0
 800a89a:	b08d      	sub	sp, #52	@ 0x34
  while (*str)
 800a89c:	7800      	ldrb	r0, [r0, #0]
{
 800a89e:	920b      	str	r2, [sp, #44]	@ 0x2c
  while (*str)
 800a8a0:	2800      	cmp	r0, #0
 800a8a2:	f000 8095 	beq.w	800a9d0 <cell_drawstring_big+0x13c>
 800a8a6:	461f      	mov	r7, r3
        cell_buffer[py * CELLWIDTH + px] = foreground_color;
 800a8a8:	4b56      	ldr	r3, [pc, #344]	@ (800aa04 <cell_drawstring_big+0x170>)
 800a8aa:	f8df a160 	ldr.w	sl, [pc, #352]	@ 800aa0c <cell_drawstring_big+0x178>
 800a8ae:	681c      	ldr	r4, [r3, #0]
 800a8b0:	9401      	str	r4, [sp, #4]
 800a8b2:	4613      	mov	r3, r2
 800a8b4:	3301      	adds	r3, #1
 800a8b6:	9309      	str	r3, [sp, #36]	@ 0x24
 800a8b8:	015b      	lsls	r3, r3, #5
 800a8ba:	f1a3 0220 	sub.w	r2, r3, #32
 800a8be:	f503 7930 	add.w	r9, r3, #704	@ 0x2c0
 800a8c2:	9308      	str	r3, [sp, #32]
 800a8c4:	f1c4 0340 	rsb	r3, r4, #64	@ 0x40
 800a8c8:	9303      	str	r3, [sp, #12]
 800a8ca:	920a      	str	r2, [sp, #40]	@ 0x28
      const uint8_t mask = (uint8_t)(0x80u >> (xx & 7u));
 800a8cc:	f04f 0b80 	mov.w	fp, #128	@ 0x80
 800a8d0:	4603      	mov	r3, r0
 800a8d2:	f8cd 9010 	str.w	r9, [sp, #16]
  const uint16_t w = FONT_GET_WIDTH(ch);
 800a8d6:	3b16      	subs	r3, #22
 800a8d8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800a8dc:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800a8e0:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 800a8e2:	9801      	ldr	r0, [sp, #4]
  const uint8_t *bmp = FONT_GET_DATA(ch);
 800a8e4:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 800a8e6:	440a      	add	r2, r1
 800a8e8:	eb00 0842 	add.w	r8, r0, r2, lsl #1
 800a8ec:	4846      	ldr	r0, [pc, #280]	@ (800aa08 <cell_drawstring_big+0x174>)
 800a8ee:	5cc2      	ldrb	r2, [r0, r3]
 800a8f0:	e9dd c608 	ldrd	ip, r6, [sp, #32]
 800a8f4:	f002 0207 	and.w	r2, r2, #7
 800a8f8:	e9cd 7105 	strd	r7, r1, [sp, #20]
  const uint16_t w = FONT_GET_WIDTH(ch);
 800a8fc:	f1c2 0208 	rsb	r2, r2, #8
 800a900:	f101 0e01 	add.w	lr, r1, #1
  const uint8_t *bmp = FONT_GET_DATA(ch);
 800a904:	4418      	add	r0, r3
  const uint16_t w = FONT_GET_WIDTH(ch);
 800a906:	b294      	uxth	r4, r2
  for (uint16_t yy = 0; yy < h; yy++)
 800a908:	46e1      	mov	r9, ip
 800a90a:	f8cd e008 	str.w	lr, [sp, #8]
 800a90e:	9207      	str	r2, [sp, #28]
    for (uint16_t xx = 0; xx < w; xx++)
 800a910:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  const uint8_t *bmp = FONT_GET_DATA(ch);
 800a914:	9600      	str	r6, [sp, #0]
 800a916:	eb03 0108 	add.w	r1, r3, r8
 800a91a:	2300      	movs	r3, #0
 800a91c:	e018      	b.n	800a950 <cell_drawstring_big+0xbc>
      if ((unsigned)px < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 800a91e:	2d1f      	cmp	r5, #31
 800a920:	d959      	bls.n	800a9d6 <cell_drawstring_big+0x142>
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 800a922:	2a20      	cmp	r2, #32
 800a924:	d02f      	beq.n	800a986 <cell_drawstring_big+0xf2>
      if ((unsigned)px < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 800a926:	9e00      	ldr	r6, [sp, #0]
 800a928:	2e1f      	cmp	r6, #31
 800a92a:	d80a      	bhi.n	800a942 <cell_drawstring_big+0xae>
        cell_buffer[(py + 1) * CELLWIDTH + px] = foreground_color;
 800a92c:	9e01      	ldr	r6, [sp, #4]
 800a92e:	f8ba 7000 	ldrh.w	r7, [sl]
 800a932:	5277      	strh	r7, [r6, r1]
 800a934:	4657      	mov	r7, sl
        cell_buffer[(py + 1) * CELLWIDTH + (px + 1)] = foreground_color;
 800a936:	eb09 0c02 	add.w	ip, r9, r2
 800a93a:	9e01      	ldr	r6, [sp, #4]
 800a93c:	883f      	ldrh	r7, [r7, #0]
 800a93e:	f826 701c 	strh.w	r7, [r6, ip, lsl #1]
    for (uint16_t xx = 0; xx < w; xx++)
 800a942:	3301      	adds	r3, #1
 800a944:	42a3      	cmp	r3, r4
 800a946:	f102 0202 	add.w	r2, r2, #2
 800a94a:	f101 0104 	add.w	r1, r1, #4
 800a94e:	d028      	beq.n	800a9a2 <cell_drawstring_big+0x10e>
      if ((row[xx >> 3] & mask) == 0)
 800a950:	7807      	ldrb	r7, [r0, #0]
      const uint8_t mask = (uint8_t)(0x80u >> (xx & 7u));
 800a952:	fa2b fc03 	lsr.w	ip, fp, r3
      if ((row[xx >> 3] & mask) == 0)
 800a956:	ea1c 0f07 	tst.w	ip, r7
 800a95a:	d0f2      	beq.n	800a942 <cell_drawstring_big+0xae>
      if ((unsigned)px < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 800a95c:	1e57      	subs	r7, r2, #1
 800a95e:	2f1f      	cmp	r7, #31
 800a960:	d9dd      	bls.n	800a91e <cell_drawstring_big+0x8a>
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 800a962:	2a1f      	cmp	r2, #31
 800a964:	d8ed      	bhi.n	800a942 <cell_drawstring_big+0xae>
 800a966:	2d1f      	cmp	r5, #31
 800a968:	d807      	bhi.n	800a97a <cell_drawstring_big+0xe6>
        cell_buffer[py * CELLWIDTH + (px + 1)] = foreground_color;
 800a96a:	4e26      	ldr	r6, [pc, #152]	@ (800aa04 <cell_drawstring_big+0x170>)
 800a96c:	f8ba e000 	ldrh.w	lr, [sl]
 800a970:	6837      	ldr	r7, [r6, #0]
 800a972:	ea4f 1c85 	mov.w	ip, r5, lsl #6
 800a976:	f827 e00c 	strh.w	lr, [r7, ip]
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 800a97a:	9e00      	ldr	r6, [sp, #0]
 800a97c:	2e1f      	cmp	r6, #31
 800a97e:	d8e0      	bhi.n	800a942 <cell_drawstring_big+0xae>
 800a980:	46cc      	mov	ip, r9
 800a982:	4657      	mov	r7, sl
 800a984:	e7d9      	b.n	800a93a <cell_drawstring_big+0xa6>
      if ((unsigned)px < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 800a986:	9e00      	ldr	r6, [sp, #0]
 800a988:	2e1f      	cmp	r6, #31
 800a98a:	d8da      	bhi.n	800a942 <cell_drawstring_big+0xae>
        cell_buffer[(py + 1) * CELLWIDTH + px] = foreground_color;
 800a98c:	9e01      	ldr	r6, [sp, #4]
 800a98e:	f8ba 7000 	ldrh.w	r7, [sl]
 800a992:	5277      	strh	r7, [r6, r1]
    for (uint16_t xx = 0; xx < w; xx++)
 800a994:	3301      	adds	r3, #1
 800a996:	42a3      	cmp	r3, r4
 800a998:	f102 0202 	add.w	r2, r2, #2
 800a99c:	f101 0104 	add.w	r1, r1, #4
 800a9a0:	d1d6      	bne.n	800a950 <cell_drawstring_big+0xbc>
  for (uint16_t yy = 0; yy < h; yy++)
 800a9a2:	9b04      	ldr	r3, [sp, #16]
 800a9a4:	9e00      	ldr	r6, [sp, #0]
 800a9a6:	f109 0940 	add.w	r9, r9, #64	@ 0x40
 800a9aa:	4599      	cmp	r9, r3
 800a9ac:	f106 0602 	add.w	r6, r6, #2
 800a9b0:	f105 0502 	add.w	r5, r5, #2
 800a9b4:	f108 0880 	add.w	r8, r8, #128	@ 0x80
 800a9b8:	f100 0001 	add.w	r0, r0, #1
 800a9bc:	d1a8      	bne.n	800a910 <cell_drawstring_big+0x7c>
  {
    const uint8_t ch = (uint8_t)*str++;
    cell_drawchar_big(ch, x, y);
    x += (int)(FONT_GET_WIDTH(ch) * 2u);
 800a9be:	e9dd 7105 	ldrd	r7, r1, [sp, #20]
 800a9c2:	9a07      	ldr	r2, [sp, #28]
  while (*str)
 800a9c4:	f817 3f01 	ldrb.w	r3, [r7, #1]!
    x += (int)(FONT_GET_WIDTH(ch) * 2u);
 800a9c8:	eb01 0142 	add.w	r1, r1, r2, lsl #1
  while (*str)
 800a9cc:	2b00      	cmp	r3, #0
 800a9ce:	d182      	bne.n	800a8d6 <cell_drawstring_big+0x42>
  }
}
 800a9d0:	b00d      	add	sp, #52	@ 0x34
 800a9d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cell_buffer[py * CELLWIDTH + px] = foreground_color;
 800a9d6:	f8ba c000 	ldrh.w	ip, [sl]
 800a9da:	f828 c023 	strh.w	ip, [r8, r3, lsl #2]
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 800a9de:	2a20      	cmp	r2, #32
        cell_buffer[py * CELLWIDTH + px] = foreground_color;
 800a9e0:	4657      	mov	r7, sl
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)py < CELLHEIGHT)
 800a9e2:	d0d0      	beq.n	800a986 <cell_drawstring_big+0xf2>
        cell_buffer[py * CELLWIDTH + (px + 1)] = foreground_color;
 800a9e4:	4e07      	ldr	r6, [pc, #28]	@ (800aa04 <cell_drawstring_big+0x170>)
 800a9e6:	f8d6 e000 	ldr.w	lr, [r6]
 800a9ea:	eb0e 0601 	add.w	r6, lr, r1
 800a9ee:	f826 cc3e 	strh.w	ip, [r6, #-62]
      if ((unsigned)px < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 800a9f2:	9e00      	ldr	r6, [sp, #0]
 800a9f4:	2e1f      	cmp	r6, #31
 800a9f6:	d8a4      	bhi.n	800a942 <cell_drawstring_big+0xae>
        cell_buffer[(py + 1) * CELLWIDTH + px] = foreground_color;
 800a9f8:	f8ba c000 	ldrh.w	ip, [sl]
 800a9fc:	f82e c001 	strh.w	ip, [lr, r1]
      if ((unsigned)(px + 1) < CELLWIDTH && (unsigned)(py + 1) < CELLHEIGHT)
 800aa00:	e799      	b.n	800a936 <cell_drawstring_big+0xa2>
 800aa02:	bf00      	nop
 800aa04:	200089ec 	.word	0x200089ec
 800aa08:	080154e0 	.word	0x080154e0
 800aa0c:	20008a3a 	.word	0x20008a3a

0800aa10 <groupdelay_from_array>:
{
 800aa10:	b510      	push	{r4, lr}
  int top = (i == sweep_points - 1) ? 0 : 1; // get next point
 800aa12:	4c1b      	ldr	r4, [pc, #108]	@ (800aa80 <groupdelay_from_array+0x70>)
 800aa14:	8b63      	ldrh	r3, [r4, #26]
 800aa16:	3b01      	subs	r3, #1
 800aa18:	1a1a      	subs	r2, r3, r0
 800aa1a:	bf18      	it	ne
 800aa1c:	2201      	movne	r2, #1
  int bottom = (i == 0) ? 0 : -1;            // get prev point
 800aa1e:	2800      	cmp	r0, #0
 800aa20:	bf14      	ite	ne
 800aa22:	2001      	movne	r0, #1
 800aa24:	2000      	moveq	r0, #0
  freq_t deltaf = get_sweep_frequency(ST_SPAN) / ((sweep_points - 1) / (top - bottom));
 800aa26:	4410      	add	r0, r2
  return groupdelay(&v[2 * bottom], &v[2 * top], deltaf);
 800aa28:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  float r = w[0] * v[0] + w[1] * v[1];
 800aa2c:	ed92 7a00 	vldr	s14, [r2]
 800aa30:	edd2 0a01 	vldr	s1, [r2, #4]
  freq_t deltaf = get_sweep_frequency(ST_SPAN) / ((sweep_points - 1) / (top - bottom));
 800aa34:	fb93 f2f0 	sdiv	r2, r3, r0
  return groupdelay(&v[2 * bottom], &v[2 * top], deltaf);
 800aa38:	bf14      	ite	ne
 800aa3a:	f06f 0307 	mvnne.w	r3, #7
 800aa3e:	2300      	moveq	r3, #0
 800aa40:	4419      	add	r1, r3
  float r = w[0] * v[0] + w[1] * v[1];
 800aa42:	edd1 7a00 	vldr	s15, [r1]
 800aa46:	edd1 6a01 	vldr	s13, [r1, #4]
  float i = w[0] * v[1] - w[1] * v[0];
 800aa4a:	ee20 0ae7 	vnmul.f32	s0, s1, s15
 800aa4e:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
  float r = w[0] * v[0] + w[1] * v[1];
 800aa52:	ee60 0aa6 	vmul.f32	s1, s1, s13
  return vna_atan2f(i, r) / (2 * VNA_PI * deltaf);
 800aa56:	eea7 0a26 	vfma.f32	s0, s14, s13
 800aa5a:	1a5b      	subs	r3, r3, r1
  freq_t deltaf = get_sweep_frequency(ST_SPAN) / ((sweep_points - 1) / (top - bottom));
 800aa5c:	fbb3 f4f2 	udiv	r4, r3, r2
  return vna_atan2f(i, r) / (2 * VNA_PI * deltaf);
 800aa60:	eee7 0a27 	vfma.f32	s1, s14, s15
 800aa64:	f007 fc9e 	bl	80123a4 <vna_atan2f>
 800aa68:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 800aa84 <groupdelay_from_array+0x74>
 800aa6c:	ee07 4a90 	vmov	s15, r4
 800aa70:	ee20 0a07 	vmul.f32	s0, s0, s14
 800aa74:	eef8 7a67 	vcvt.f32.u32	s15, s15
}
 800aa78:	ee80 0a27 	vdiv.f32	s0, s0, s15
 800aa7c:	bd10      	pop	{r4, pc}
 800aa7e:	bf00      	nop
 800aa80:	20000aa8 	.word	0x20000aa8
 800aa84:	3e22f983 	.word	0x3e22f983

0800aa88 <phase>:
{
 800aa88:	b508      	push	{r3, lr}
  return (180.0f / VNA_PI) * vna_atan2f(v[1], v[0]);
 800aa8a:	edd1 0a00 	vldr	s1, [r1]
 800aa8e:	ed91 0a01 	vldr	s0, [r1, #4]
 800aa92:	f007 fc87 	bl	80123a4 <vna_atan2f>
 800aa96:	eddf 7a02 	vldr	s15, [pc, #8]	@ 800aaa0 <phase+0x18>
}
 800aa9a:	ee20 0a27 	vmul.f32	s0, s0, s15
 800aa9e:	bd08      	pop	{r3, pc}
 800aaa0:	42652ee0 	.word	0x42652ee0

0800aaa4 <get_w>:
static float get_w(int i) { return 2 * VNA_PI * getFrequency(i); }
 800aaa4:	b508      	push	{r3, lr}
 800aaa6:	b280      	uxth	r0, r0
 800aaa8:	f7fc f8ac 	bl	8006c04 <getFrequency>
 800aaac:	ee07 0a90 	vmov	s15, r0
 800aab0:	ed9f 0a03 	vldr	s0, [pc, #12]	@ 800aac0 <get_w+0x1c>
 800aab4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800aab8:	ee27 0a80 	vmul.f32	s0, s15, s0
 800aabc:	bd08      	pop	{r3, pc}
 800aabe:	bf00      	nop
 800aac0:	40c90fdb 	.word	0x40c90fdb

0800aac4 <s11index>:

static float s11loss(uint16_t i) {
  return -0.5f * logmag(i, measured[0][i]);
}

static float s11index(uint16_t i) {
 800aac4:	b508      	push	{r3, lr}
  return vna_sqrtf(getFrequency(i) * 1e-9f);
 800aac6:	f7fc f89d 	bl	8006c04 <getFrequency>
 800aaca:	ee00 0a10 	vmov	s0, r0
 800aace:	eddf 7a04 	vldr	s15, [pc, #16]	@ 800aae0 <s11index+0x1c>
 800aad2:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 800aad6:	ee20 0a27 	vmul.f32	s0, s0, s15
 800aada:	eeb1 0ac0 	vsqrt.f32	s0, s0
}
 800aade:	bd08      	pop	{r3, pc}
 800aae0:	3089705f 	.word	0x3089705f

0800aae4 <measure_search_value>:
static float measure_search_value(uint16_t *idx, float y, get_value_t get, int16_t mode, int16_t marker_idx) {
 800aae4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800aae8:	ed2d 8b04 	vpush	{d8-d9}
  uint16_t x = *idx;
 800aaec:	8804      	ldrh	r4, [r0, #0]
  for(; x < sweep_points; x+=mode) {
 800aaee:	f8df 90f0 	ldr.w	r9, [pc, #240]	@ 800abe0 <measure_search_value+0xfc>
static float measure_search_value(uint16_t *idx, float y, get_value_t get, int16_t mode, int16_t marker_idx) {
 800aaf2:	b082      	sub	sp, #8
 800aaf4:	4606      	mov	r6, r0
  y1 = y2 = y3 = get(x);
 800aaf6:	4620      	mov	r0, r4
static float measure_search_value(uint16_t *idx, float y, get_value_t get, int16_t mode, int16_t marker_idx) {
 800aaf8:	eeb0 9a40 	vmov.f32	s18, s0
 800aafc:	460f      	mov	r7, r1
 800aafe:	4615      	mov	r5, r2
 800ab00:	4698      	mov	r8, r3
  y1 = y2 = y3 = get(x);
 800ab02:	4788      	blx	r1
  bool result = (y3 > y); // current position depend from start point
 800ab04:	eeb4 0ac9 	vcmpe.f32	s0, s18
 800ab08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  y1 = y2 = y3 = get(x);
 800ab0c:	eef0 8a40 	vmov.f32	s17, s0
  bool result = (y3 > y); // current position depend from start point
 800ab10:	bfcc      	ite	gt
 800ab12:	f04f 0a01 	movgt.w	sl, #1
 800ab16:	f04f 0a00 	movle.w	sl, #0
  y1 = y2 = y3 = get(x);
 800ab1a:	eef0 9a40 	vmov.f32	s19, s0
  for(; x < sweep_points; x+=mode) {
 800ab1e:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800ab22:	42a3      	cmp	r3, r4
 800ab24:	d917      	bls.n	800ab56 <measure_search_value+0x72>
    y3 = get(x);
 800ab26:	4620      	mov	r0, r4
 800ab28:	47b8      	blx	r7
    if(result != (y3 > y)) break;
 800ab2a:	eeb4 9ac0 	vcmpe.f32	s18, s0
 800ab2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ab32:	bf4c      	ite	mi
 800ab34:	2301      	movmi	r3, #1
 800ab36:	2300      	movpl	r3, #0
 800ab38:	4553      	cmp	r3, sl
    y3 = get(x);
 800ab3a:	eeb0 8a40 	vmov.f32	s16, s0
    if(result != (y3 > y)) break;
 800ab3e:	d106      	bne.n	800ab4e <measure_search_value+0x6a>
  for(; x < sweep_points; x+=mode) {
 800ab40:	442c      	add	r4, r5
    y1 = y2;
 800ab42:	eef0 8a69 	vmov.f32	s17, s19
  for(; x < sweep_points; x+=mode) {
 800ab46:	b2a4      	uxth	r4, r4
    y2 = y3;
 800ab48:	eef0 9a40 	vmov.f32	s19, s0
 800ab4c:	e7e7      	b.n	800ab1e <measure_search_value+0x3a>
  if (x >= sweep_points) return 0;
 800ab4e:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800ab52:	42a3      	cmp	r3, r4
 800ab54:	d802      	bhi.n	800ab5c <measure_search_value+0x78>
 800ab56:	ed9f 0a21 	vldr	s0, [pc, #132]	@ 800abdc <measure_search_value+0xf8>
 800ab5a:	e03a      	b.n	800abd2 <measure_search_value+0xee>
  x-=mode;
 800ab5c:	1b64      	subs	r4, r4, r5
 800ab5e:	b2a4      	uxth	r4, r4
  set_marker_index(marker_idx, x);
 800ab60:	4640      	mov	r0, r8
  *idx = x;
 800ab62:	8034      	strh	r4, [r6, #0]
  set_marker_index(marker_idx, x);
 800ab64:	4621      	mov	r1, r4
 800ab66:	f7fc fe2b 	bl	80077c0 <set_marker_index>
  const float a = 0.5f * (y1 + y3) - y2;
 800ab6a:	ee38 7a88 	vadd.f32	s14, s17, s16
  const float b = 0.5f * (y3 - y1);
 800ab6e:	ee78 0a68 	vsub.f32	s1, s16, s17
  const float a = 0.5f * (y1 + y3) - y2;
 800ab72:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
  match_quadratic_equation(a, b, c, r);
 800ab76:	eeb0 0a69 	vmov.f32	s0, s19
 800ab7a:	ee97 0a27 	vfnms.f32	s0, s14, s15
 800ab7e:	4668      	mov	r0, sp
 800ab80:	ee39 1ac9 	vsub.f32	s2, s19, s18
 800ab84:	ee60 0aa7 	vmul.f32	s1, s1, s15
 800ab88:	f7ff fe08 	bl	800a79c <match_quadratic_equation>
  float res = (r[0] > 0 && r[0] < 1.0) ? r[0] : r[1];
 800ab8c:	eddd 8a00 	vldr	s17, [sp]
 800ab90:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 800ab94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ab98:	dd06      	ble.n	800aba8 <measure_search_value+0xc4>
 800ab9a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800ab9e:	eef4 8ae7 	vcmpe.f32	s17, s15
 800aba2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aba6:	d401      	bmi.n	800abac <measure_search_value+0xc8>
 800aba8:	eddd 8a01 	vldr	s17, [sp, #4]
  if (mode < 0) res=-res;
 800abac:	3501      	adds	r5, #1
  return getFrequency(x) + getFrequencyStep() * res;
 800abae:	4620      	mov	r0, r4
  if (mode < 0) res=-res;
 800abb0:	bf08      	it	eq
 800abb2:	eef1 8a68 	vnegeq.f32	s17, s17
  return getFrequency(x) + getFrequencyStep() * res;
 800abb6:	f7fc f825 	bl	8006c04 <getFrequency>
 800abba:	ee08 0a10 	vmov	s16, r0
 800abbe:	f7fc fdf9 	bl	80077b4 <getFrequencyStep>
 800abc2:	ee07 0a90 	vmov	s15, r0
 800abc6:	eeb8 0a48 	vcvt.f32.u32	s0, s16
 800abca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800abce:	eea7 0aa8 	vfma.f32	s0, s15, s17
}
 800abd2:	b002      	add	sp, #8
 800abd4:	ecbd 8b04 	vpop	{d8-d9}
 800abd8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800abdc:	00000000 	.word	0x00000000
 800abe0:	20000aa8 	.word	0x20000aa8

0800abe4 <cell_printf>:
{
 800abe4:	b40c      	push	{r2, r3}
 800abe6:	b500      	push	{lr}
  if ((uint32_t)(y + FONT_GET_HEIGHT) >= CELLHEIGHT + FONT_GET_HEIGHT || x >= CELLWIDTH)
 800abe8:	f101 020b 	add.w	r2, r1, #11
 800abec:	2a2a      	cmp	r2, #42	@ 0x2a
{
 800abee:	b085      	sub	sp, #20
  if ((uint32_t)(y + FONT_GET_HEIGHT) >= CELLHEIGHT + FONT_GET_HEIGHT || x >= CELLWIDTH)
 800abf0:	d801      	bhi.n	800abf6 <cell_printf+0x12>
 800abf2:	281f      	cmp	r0, #31
 800abf4:	dd05      	ble.n	800ac02 <cell_printf+0x1e>
    return 0;
 800abf6:	2000      	movs	r0, #0
}
 800abf8:	b005      	add	sp, #20
 800abfa:	f85d eb04 	ldr.w	lr, [sp], #4
 800abfe:	b002      	add	sp, #8
 800ac00:	4770      	bx	lr
  cellPrintStream ps = {&cell_vmt, x, y};
 800ac02:	460b      	mov	r3, r1
 800ac04:	4908      	ldr	r1, [pc, #32]	@ (800ac28 <cell_printf+0x44>)
 800ac06:	9102      	str	r1, [sp, #8]
  va_start(ap, fmt);
 800ac08:	aa07      	add	r2, sp, #28
  cellPrintStream ps = {&cell_vmt, x, y};
 800ac0a:	f8ad 000c 	strh.w	r0, [sp, #12]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 800ac0e:	9906      	ldr	r1, [sp, #24]
  cellPrintStream ps = {&cell_vmt, x, y};
 800ac10:	f8ad 300e 	strh.w	r3, [sp, #14]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 800ac14:	a802      	add	r0, sp, #8
  va_start(ap, fmt);
 800ac16:	9201      	str	r2, [sp, #4]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 800ac18:	f7f7 fd00 	bl	800261c <chvprintf>
}
 800ac1c:	b005      	add	sp, #20
 800ac1e:	f85d eb04 	ldr.w	lr, [sp], #4
 800ac22:	b002      	add	sp, #8
 800ac24:	4770      	bx	lr
 800ac26:	bf00      	nop
 800ac28:	0801619c 	.word	0x0801619c

0800ac2c <draw_s11_resonance>:

static float s11_resonance_min(uint16_t i) {
  return fabsf(reactance(i, measured[0][i]));
}

static void draw_s11_resonance(int xp, int yp) {
 800ac2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  cell_printf(xp, yp, "S11 RESONANCE");
  if (s11_resonance->count == 0) {
 800ac30:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 800acb4 <draw_s11_resonance+0x88>
  cell_printf(xp, yp, "S11 RESONANCE");
 800ac34:	4a1c      	ldr	r2, [pc, #112]	@ (800aca8 <draw_s11_resonance+0x7c>)
 800ac36:	b205      	sxth	r5, r0
static void draw_s11_resonance(int xp, int yp) {
 800ac38:	b085      	sub	sp, #20
 800ac3a:	460c      	mov	r4, r1
  cell_printf(xp, yp, "S11 RESONANCE");
 800ac3c:	4628      	mov	r0, r5
 800ac3e:	b209      	sxth	r1, r1
 800ac40:	f7ff ffd0 	bl	800abe4 <cell_printf>
  if (s11_resonance->count == 0) {
 800ac44:	f898 3048 	ldrb.w	r3, [r8, #72]	@ 0x48
 800ac48:	b113      	cbz	r3, 800ac50 <draw_s11_resonance+0x24>
 800ac4a:	4646      	mov	r6, r8
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Not found");
    return;
  }
  for (int i = 0; i < s11_resonance->count; i++)
 800ac4c:	2700      	movs	r7, #0
 800ac4e:	e009      	b.n	800ac64 <draw_s11_resonance+0x38>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Not found");
 800ac50:	f104 010c 	add.w	r1, r4, #12
 800ac54:	4a15      	ldr	r2, [pc, #84]	@ (800acac <draw_s11_resonance+0x80>)
 800ac56:	b209      	sxth	r1, r1
 800ac58:	4628      	mov	r0, r5
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "%q" S_Hz ", %F%+jF" S_OHM, s11_resonance->data[i].f, s11_resonance->data[i].r, s11_resonance->data[i].x);
}
 800ac5a:	b005      	add	sp, #20
 800ac5c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Not found");
 800ac60:	f7ff bfc0 	b.w	800abe4 <cell_printf>
  for (int i = 0; i < s11_resonance->count; i++)
 800ac64:	f898 3048 	ldrb.w	r3, [r8, #72]	@ 0x48
 800ac68:	42bb      	cmp	r3, r7
 800ac6a:	f106 060c 	add.w	r6, r6, #12
 800ac6e:	dd17      	ble.n	800aca0 <draw_s11_resonance+0x74>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "%q" S_Hz ", %F%+jF" S_OHM, s11_resonance->data[i].f, s11_resonance->data[i].r, s11_resonance->data[i].x);
 800ac70:	f856 0c04 	ldr.w	r0, [r6, #-4]
 800ac74:	f7f5 fc94 	bl	80005a0 <__aeabi_f2d>
 800ac78:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800ac7c:	f856 0c08 	ldr.w	r0, [r6, #-8]
 800ac80:	f7f5 fc8e 	bl	80005a0 <__aeabi_f2d>
 800ac84:	e9cd 0100 	strd	r0, r1, [sp]
 800ac88:	340c      	adds	r4, #12
 800ac8a:	fa0f f984 	sxth.w	r9, r4
 800ac8e:	f856 3c0c 	ldr.w	r3, [r6, #-12]
 800ac92:	4a07      	ldr	r2, [pc, #28]	@ (800acb0 <draw_s11_resonance+0x84>)
 800ac94:	4649      	mov	r1, r9
 800ac96:	4628      	mov	r0, r5
 800ac98:	f7ff ffa4 	bl	800abe4 <cell_printf>
  for (int i = 0; i < s11_resonance->count; i++)
 800ac9c:	3701      	adds	r7, #1
 800ac9e:	e7e1      	b.n	800ac64 <draw_s11_resonance+0x38>
}
 800aca0:	b005      	add	sp, #20
 800aca2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800aca6:	bf00      	nop
 800aca8:	08014856 	.word	0x08014856
 800acac:	08014864 	.word	0x08014864
 800acb0:	0801486e 	.word	0x0801486e
 800acb4:	200069fc 	.word	0x200069fc

0800acb8 <draw_s11_cable>:
static void draw_s11_cable(int xp, int yp){
 800acb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800acbc:	ed2d 8b02 	vpush	{d8}
  if (s11_cable->R){
 800acc0:	4e44      	ldr	r6, [pc, #272]	@ (800add4 <draw_s11_cable+0x11c>)
  cell_printf(xp, yp, "S11 CABLE");
 800acc2:	4a45      	ldr	r2, [pc, #276]	@ (800add8 <draw_s11_cable+0x120>)
 800acc4:	b205      	sxth	r5, r0
static void draw_s11_cable(int xp, int yp){
 800acc6:	b084      	sub	sp, #16
 800acc8:	460c      	mov	r4, r1
  cell_printf(xp, yp, "S11 CABLE");
 800acca:	4628      	mov	r0, r5
 800accc:	b209      	sxth	r1, r1
 800acce:	f7ff ff89 	bl	800abe4 <cell_printf>
  if (s11_cable->R){
 800acd2:	edd6 7a01 	vldr	s15, [r6, #4]
 800acd6:	eef5 7a40 	vcmp.f32	s15, #0.0
 800acda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800acde:	d00c      	beq.n	800acfa <draw_s11_cable+0x42>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Z0 = %F" S_OHM, s11_cable->R);
 800ace0:	ee17 0a90 	vmov	r0, s15
 800ace4:	f7f5 fc5c 	bl	80005a0 <__aeabi_f2d>
 800ace8:	340c      	adds	r4, #12
 800acea:	b227      	sxth	r7, r4
 800acec:	e9cd 0100 	strd	r0, r1, [sp]
 800acf0:	4a3a      	ldr	r2, [pc, #232]	@ (800addc <draw_s11_cable+0x124>)
 800acf2:	4639      	mov	r1, r7
 800acf4:	4628      	mov	r0, r5
 800acf6:	f7ff ff75 	bl	800abe4 <cell_printf>
  if (s11_cable->vf)
 800acfa:	ed96 8a05 	vldr	s16, [r6, #20]
 800acfe:	eeb5 8a40 	vcmp.f32	s16, #0.0
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "VF=%.2f%% (Length = %F" S_METRE ")", s11_cable->vf, real_cable_len);
 800ad02:	f104 080c 	add.w	r8, r4, #12
  if (s11_cable->vf)
 800ad06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "VF=%.2f%% (Length = %F" S_METRE ")", s11_cable->vf, real_cable_len);
 800ad0a:	fa0f f788 	sxth.w	r7, r8
  if (s11_cable->vf)
 800ad0e:	d012      	beq.n	800ad36 <draw_s11_cable+0x7e>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "VF=%.2f%% (Length = %F" S_METRE ")", s11_cable->vf, real_cable_len);
 800ad10:	4b33      	ldr	r3, [pc, #204]	@ (800ade0 <draw_s11_cable+0x128>)
 800ad12:	6818      	ldr	r0, [r3, #0]
 800ad14:	f7f5 fc44 	bl	80005a0 <__aeabi_f2d>
 800ad18:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800ad1c:	ee18 0a10 	vmov	r0, s16
 800ad20:	f7f5 fc3e 	bl	80005a0 <__aeabi_f2d>
 800ad24:	4a2f      	ldr	r2, [pc, #188]	@ (800ade4 <draw_s11_cable+0x12c>)
 800ad26:	e9cd 0100 	strd	r0, r1, [sp]
 800ad2a:	4639      	mov	r1, r7
 800ad2c:	4628      	mov	r0, r5
 800ad2e:	f7ff ff59 	bl	800abe4 <cell_printf>
 800ad32:	4644      	mov	r4, r8
 800ad34:	e016      	b.n	800ad64 <draw_s11_cable+0xac>
  else if (s11_cable->len)
 800ad36:	edd6 7a02 	vldr	s15, [r6, #8]
 800ad3a:	eef5 7a40 	vcmp.f32	s15, #0.0
 800ad3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ad42:	d00f      	beq.n	800ad64 <draw_s11_cable+0xac>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Length = %F" S_METRE " (VF=%d%%)", s11_cable->len, velocity_factor);
 800ad44:	4b28      	ldr	r3, [pc, #160]	@ (800ade8 <draw_s11_cable+0x130>)
 800ad46:	ee17 0a90 	vmov	r0, s15
 800ad4a:	f893 3099 	ldrb.w	r3, [r3, #153]	@ 0x99
 800ad4e:	9302      	str	r3, [sp, #8]
 800ad50:	f7f5 fc26 	bl	80005a0 <__aeabi_f2d>
 800ad54:	4a25      	ldr	r2, [pc, #148]	@ (800adec <draw_s11_cable+0x134>)
 800ad56:	e9cd 0100 	strd	r0, r1, [sp]
 800ad5a:	4639      	mov	r1, r7
 800ad5c:	4628      	mov	r0, r5
 800ad5e:	f7ff ff41 	bl	800abe4 <cell_printf>
 800ad62:	e7e6      	b.n	800ad32 <draw_s11_cable+0x7a>
  cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Loss = %F" S_dB " (%.4F" S_Hz ")", s11_cable->mloss, s11_cable->freq);
 800ad64:	6830      	ldr	r0, [r6, #0]
 800ad66:	f7f5 fc1b 	bl	80005a0 <__aeabi_f2d>
 800ad6a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800ad6e:	6930      	ldr	r0, [r6, #16]
 800ad70:	f7f5 fc16 	bl	80005a0 <__aeabi_f2d>
 800ad74:	f104 070c 	add.w	r7, r4, #12
 800ad78:	b23f      	sxth	r7, r7
 800ad7a:	e9cd 0100 	strd	r0, r1, [sp]
 800ad7e:	4a1c      	ldr	r2, [pc, #112]	@ (800adf0 <draw_s11_cable+0x138>)
 800ad80:	4639      	mov	r1, r7
 800ad82:	4628      	mov	r0, r5
 800ad84:	f7ff ff2e 	bl	800abe4 <cell_printf>
  if (s11_cable->len) {
 800ad88:	ed96 8a02 	vldr	s16, [r6, #8]
 800ad8c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800ad90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ad94:	d019      	beq.n	800adca <draw_s11_cable+0x112>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Att (" S_dB "/100" S_METRE "): %F" S_dB " (%.4F" S_Hz ")", s11_cable->mloss * 100.0f / l, s11_cable->freq);
 800ad96:	6830      	ldr	r0, [r6, #0]
 800ad98:	f7f5 fc02 	bl	80005a0 <__aeabi_f2d>
 800ad9c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800ada0:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800adf4 <draw_s11_cable+0x13c>
 800ada4:	edd6 7a04 	vldr	s15, [r6, #16]
 800ada8:	ee67 7a87 	vmul.f32	s15, s15, s14
 800adac:	3418      	adds	r4, #24
 800adae:	eec7 7a88 	vdiv.f32	s15, s15, s16
 800adb2:	b224      	sxth	r4, r4
 800adb4:	ee17 0a90 	vmov	r0, s15
 800adb8:	f7f5 fbf2 	bl	80005a0 <__aeabi_f2d>
 800adbc:	4a0e      	ldr	r2, [pc, #56]	@ (800adf8 <draw_s11_cable+0x140>)
 800adbe:	e9cd 0100 	strd	r0, r1, [sp]
 800adc2:	4621      	mov	r1, r4
 800adc4:	4628      	mov	r0, r5
 800adc6:	f7ff ff0d 	bl	800abe4 <cell_printf>
}
 800adca:	b004      	add	sp, #16
 800adcc:	ecbd 8b02 	vpop	{d8}
 800add0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800add4:	200069fc 	.word	0x200069fc
 800add8:	0801487c 	.word	0x0801487c
 800addc:	08014886 	.word	0x08014886
 800ade0:	200069f8 	.word	0x200069f8
 800ade4:	0801488f 	.word	0x0801488f
 800ade8:	20000aa8 	.word	0x20000aa8
 800adec:	080148a8 	.word	0x080148a8
 800adf0:	080148bf 	.word	0x080148bf
 800adf4:	42c80000 	.word	0x42c80000
 800adf8:	080148d4 	.word	0x080148d4

0800adfc <draw_s21_pass>:
static void draw_s21_pass(int xp, int yp, s21_pass *p, const char *name) {
 800adfc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  cell_printf(xp, yp, name);
 800adfe:	b205      	sxth	r5, r0
static void draw_s21_pass(int xp, int yp, s21_pass *p, const char *name) {
 800ae00:	4616      	mov	r6, r2
 800ae02:	460c      	mov	r4, r1
  cell_printf(xp, yp, name);
 800ae04:	461a      	mov	r2, r3
 800ae06:	b209      	sxth	r1, r1
 800ae08:	4628      	mov	r0, r5
 800ae0a:	f7ff feeb 	bl	800abe4 <cell_printf>
  if (p->f[_3dB]) cell_printf(xp, yp +   STR_MEASURE_HEIGHT, "%.6F" S_Hz,  p->f[_3dB]);
 800ae0e:	edd6 7a00 	vldr	s15, [r6]
 800ae12:	eef5 7a40 	vcmp.f32	s15, #0.0
 800ae16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae1a:	d00d      	beq.n	800ae38 <draw_s21_pass+0x3c>
 800ae1c:	ee17 0a90 	vmov	r0, s15
 800ae20:	f7f5 fbbe 	bl	80005a0 <__aeabi_f2d>
 800ae24:	f104 070c 	add.w	r7, r4, #12
 800ae28:	b23f      	sxth	r7, r7
 800ae2a:	e9cd 0100 	strd	r0, r1, [sp]
 800ae2e:	4a1e      	ldr	r2, [pc, #120]	@ (800aea8 <draw_s21_pass+0xac>)
 800ae30:	4639      	mov	r1, r7
 800ae32:	4628      	mov	r0, r5
 800ae34:	f7ff fed6 	bl	800abe4 <cell_printf>
  if (p->f[_6dB]) cell_printf(xp, yp + 2*STR_MEASURE_HEIGHT, "%.6F" S_Hz,  p->f[_6dB]);
 800ae38:	edd6 7a01 	vldr	s15, [r6, #4]
 800ae3c:	eef5 7a40 	vcmp.f32	s15, #0.0
 800ae40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae44:	d00d      	beq.n	800ae62 <draw_s21_pass+0x66>
 800ae46:	ee17 0a90 	vmov	r0, s15
 800ae4a:	f7f5 fba9 	bl	80005a0 <__aeabi_f2d>
 800ae4e:	f104 0718 	add.w	r7, r4, #24
 800ae52:	b23f      	sxth	r7, r7
 800ae54:	e9cd 0100 	strd	r0, r1, [sp]
 800ae58:	4a13      	ldr	r2, [pc, #76]	@ (800aea8 <draw_s21_pass+0xac>)
 800ae5a:	4639      	mov	r1, r7
 800ae5c:	4628      	mov	r0, r5
 800ae5e:	f7ff fec1 	bl	800abe4 <cell_printf>
  if (p->decade) {
 800ae62:	edd6 7a04 	vldr	s15, [r6, #16]
 800ae66:	eef5 7a40 	vcmp.f32	s15, #0.0
 800ae6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae6e:	d019      	beq.n	800aea4 <draw_s21_pass+0xa8>
    cell_printf(xp, yp                     , "%F" S_dB "/dec", p->decade);
 800ae70:	ee17 0a90 	vmov	r0, s15
 800ae74:	f7f5 fb94 	bl	80005a0 <__aeabi_f2d>
  yp+= 3 * STR_MEASURE_HEIGHT;
 800ae78:	f104 0724 	add.w	r7, r4, #36	@ 0x24
    cell_printf(xp, yp                     , "%F" S_dB "/dec", p->decade);
 800ae7c:	b23f      	sxth	r7, r7
 800ae7e:	e9cd 0100 	strd	r0, r1, [sp]
 800ae82:	4a0a      	ldr	r2, [pc, #40]	@ (800aeac <draw_s21_pass+0xb0>)
 800ae84:	4639      	mov	r1, r7
 800ae86:	4628      	mov	r0, r5
 800ae88:	f7ff feac 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp + STR_MEASURE_HEIGHT, "%F" S_dB "/oct", p->octave);
 800ae8c:	6970      	ldr	r0, [r6, #20]
 800ae8e:	f7f5 fb87 	bl	80005a0 <__aeabi_f2d>
 800ae92:	3430      	adds	r4, #48	@ 0x30
 800ae94:	b224      	sxth	r4, r4
 800ae96:	e9cd 0100 	strd	r0, r1, [sp]
 800ae9a:	4a05      	ldr	r2, [pc, #20]	@ (800aeb0 <draw_s21_pass+0xb4>)
 800ae9c:	4621      	mov	r1, r4
 800ae9e:	4628      	mov	r0, r5
 800aea0:	f7ff fea0 	bl	800abe4 <cell_printf>
}
 800aea4:	b003      	add	sp, #12
 800aea6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800aea8:	08014951 	.word	0x08014951
 800aeac:	080148f1 	.word	0x080148f1
 800aeb0:	080148fa 	.word	0x080148fa

0800aeb4 <draw_filter_result>:
static void draw_filter_result(int xp, int yp){
 800aeb4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800aeb8:	ed2d 8b02 	vpush	{d8}
  if (s21_filter->vmax < S21_MEASURE_FILTER_THRESHOLD) return;
 800aebc:	4c60      	ldr	r4, [pc, #384]	@ (800b040 <draw_filter_result+0x18c>)
  cell_printf(xp, yp, "S21 FILTER");
 800aebe:	4a61      	ldr	r2, [pc, #388]	@ (800b044 <draw_filter_result+0x190>)
 800aec0:	b205      	sxth	r5, r0
static void draw_filter_result(int xp, int yp){
 800aec2:	b085      	sub	sp, #20
 800aec4:	4680      	mov	r8, r0
 800aec6:	460f      	mov	r7, r1
  cell_printf(xp, yp, "S21 FILTER");
 800aec8:	4628      	mov	r0, r5
 800aeca:	b209      	sxth	r1, r1
 800aecc:	f7ff fe8a 	bl	800abe4 <cell_printf>
  if (s21_filter->vmax < S21_MEASURE_FILTER_THRESHOLD) return;
 800aed0:	edd4 7a01 	vldr	s15, [r4, #4]
 800aed4:	ed9f 7a5c 	vldr	s14, [pc, #368]	@ 800b048 <draw_filter_result+0x194>
 800aed8:	eef4 7ac7 	vcmpe.f32	s15, s14
 800aedc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aee0:	f100 80a8 	bmi.w	800b034 <draw_filter_result+0x180>
  if (s21_filter->f_center) {
 800aee4:	ed94 8a0e 	vldr	s16, [r4, #56]	@ 0x38
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->f_center, s21_filter->vmax);
 800aee8:	ee17 0a90 	vmov	r0, s15
 800aeec:	f7f5 fb58 	bl	80005a0 <__aeabi_f2d>
  if (s21_filter->f_center) {
 800aef0:	eeb5 8a40 	vcmp.f32	s16, #0.0
  yp+= STR_MEASURE_HEIGHT;
 800aef4:	f107 060c 	add.w	r6, r7, #12
  if (s21_filter->f_center) {
 800aef8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->f_center, s21_filter->vmax);
 800aefc:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800af00:	fa0f f986 	sxth.w	r9, r6
  if (s21_filter->f_center) {
 800af04:	d034      	beq.n	800af70 <draw_filter_result+0xbc>
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->f_center, s21_filter->vmax);
 800af06:	ee18 0a10 	vmov	r0, s16
 800af0a:	f7f5 fb49 	bl	80005a0 <__aeabi_f2d>
 800af0e:	4a4f      	ldr	r2, [pc, #316]	@ (800b04c <draw_filter_result+0x198>)
 800af10:	e9cd 0100 	strd	r0, r1, [sp]
 800af14:	4649      	mov	r1, r9
 800af16:	4628      	mov	r0, r5
 800af18:	f7ff fe64 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Bw (-%d" S_dB "): %.6F" S_Hz, 3, s21_filter->bw_3dB);
 800af1c:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 800af1e:	f7f5 fb3f 	bl	80005a0 <__aeabi_f2d>
 800af22:	f107 0618 	add.w	r6, r7, #24
 800af26:	b236      	sxth	r6, r6
 800af28:	e9cd 0100 	strd	r0, r1, [sp]
 800af2c:	4a48      	ldr	r2, [pc, #288]	@ (800b050 <draw_filter_result+0x19c>)
 800af2e:	2303      	movs	r3, #3
 800af30:	4631      	mov	r1, r6
 800af32:	4628      	mov	r0, r5
 800af34:	f7ff fe56 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Bw (-%d" S_dB "): %.6F" S_Hz, 6, s21_filter->bw_6dB);
 800af38:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 800af3a:	f7f5 fb31 	bl	80005a0 <__aeabi_f2d>
 800af3e:	f107 0624 	add.w	r6, r7, #36	@ 0x24
 800af42:	b236      	sxth	r6, r6
 800af44:	e9cd 0100 	strd	r0, r1, [sp]
 800af48:	4a41      	ldr	r2, [pc, #260]	@ (800b050 <draw_filter_result+0x19c>)
 800af4a:	2306      	movs	r3, #6
 800af4c:	4631      	mov	r1, r6
 800af4e:	4628      	mov	r0, r5
 800af50:	f7ff fe48 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Q: %F", s21_filter->q);
 800af54:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 800af56:	f7f5 fb23 	bl	80005a0 <__aeabi_f2d>
 800af5a:	f107 0630 	add.w	r6, r7, #48	@ 0x30
 800af5e:	b237      	sxth	r7, r6
 800af60:	e9cd 0100 	strd	r0, r1, [sp]
 800af64:	4a3b      	ldr	r2, [pc, #236]	@ (800b054 <draw_filter_result+0x1a0>)
 800af66:	4639      	mov	r1, r7
 800af68:	4628      	mov	r0, r5
 800af6a:	f7ff fe3b 	bl	800abe4 <cell_printf>
 800af6e:	e009      	b.n	800af84 <draw_filter_result+0xd0>
    cell_printf(xp, yp, "f: %.6F" S_Hz " (%F" S_dB ")", s21_filter->fmax, s21_filter->vmax);
 800af70:	6820      	ldr	r0, [r4, #0]
 800af72:	f7f5 fb15 	bl	80005a0 <__aeabi_f2d>
 800af76:	4a35      	ldr	r2, [pc, #212]	@ (800b04c <draw_filter_result+0x198>)
 800af78:	e9cd 0100 	strd	r0, r1, [sp]
 800af7c:	4649      	mov	r1, r9
 800af7e:	4628      	mov	r0, r5
 800af80:	f7ff fe30 	bl	800abe4 <cell_printf>
  if (s21_filter->lo_pass.f[_3dB] || s21_filter->hi_pass.f[_3dB]) {
 800af84:	edd4 7a02 	vldr	s15, [r4, #8]
 800af88:	eef5 7a40 	vcmp.f32	s15, #0.0
 800af8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800af90:	d106      	bne.n	800afa0 <draw_filter_result+0xec>
 800af92:	edd4 7a08 	vldr	s15, [r4, #32]
 800af96:	eef5 7a40 	vcmp.f32	s15, #0.0
 800af9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800af9e:	d049      	beq.n	800b034 <draw_filter_result+0x180>
    yp+= STR_MEASURE_HEIGHT;
 800afa0:	360c      	adds	r6, #12
    cell_printf(xp, yp + 1 * STR_MEASURE_HEIGHT, "f(-%d):", 3);
 800afa2:	b2b7      	uxth	r7, r6
 800afa4:	f107 010c 	add.w	r1, r7, #12
 800afa8:	4a2b      	ldr	r2, [pc, #172]	@ (800b058 <draw_filter_result+0x1a4>)
 800afaa:	2303      	movs	r3, #3
 800afac:	b209      	sxth	r1, r1
 800afae:	4628      	mov	r0, r5
 800afb0:	f7ff fe18 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp + 2 * STR_MEASURE_HEIGHT, "f(-%d):", 6);
 800afb4:	f107 0118 	add.w	r1, r7, #24
 800afb8:	4a27      	ldr	r2, [pc, #156]	@ (800b058 <draw_filter_result+0x1a4>)
 800afba:	2306      	movs	r3, #6
 800afbc:	b209      	sxth	r1, r1
 800afbe:	4628      	mov	r0, r5
 800afc0:	f7ff fe10 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp + 3 * STR_MEASURE_HEIGHT, "Roll:");
 800afc4:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 800afc8:	4a24      	ldr	r2, [pc, #144]	@ (800b05c <draw_filter_result+0x1a8>)
 800afca:	b209      	sxth	r1, r1
 800afcc:	4628      	mov	r0, r5
 800afce:	f7ff fe09 	bl	800abe4 <cell_printf>
    if (s21_filter->hi_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->hi_pass, s21_filter->f_center ? "Low-side"  : "High-pass"); xp+= width1; }
 800afd2:	edd4 7a08 	vldr	s15, [r4, #32]
 800afd6:	eef5 7a40 	vcmp.f32	s15, #0.0
 800afda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    xp+= width0;
 800afde:	f108 002a 	add.w	r0, r8, #42	@ 0x2a
    if (s21_filter->hi_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->hi_pass, s21_filter->f_center ? "Low-side"  : "High-pass"); xp+= width1; }
 800afe2:	d00e      	beq.n	800b002 <draw_filter_result+0x14e>
 800afe4:	edd4 7a0e 	vldr	s15, [r4, #56]	@ 0x38
 800afe8:	4a1d      	ldr	r2, [pc, #116]	@ (800b060 <draw_filter_result+0x1ac>)
 800afea:	eef5 7a40 	vcmp.f32	s15, #0.0
 800afee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aff2:	bf14      	ite	ne
 800aff4:	4b1b      	ldrne	r3, [pc, #108]	@ (800b064 <draw_filter_result+0x1b0>)
 800aff6:	4b1c      	ldreq	r3, [pc, #112]	@ (800b068 <draw_filter_result+0x1b4>)
 800aff8:	4631      	mov	r1, r6
 800affa:	f7ff feff 	bl	800adfc <draw_s21_pass>
 800affe:	f108 007e 	add.w	r0, r8, #126	@ 0x7e
    if (s21_filter->lo_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->lo_pass, s21_filter->f_center ? "High-side" : "Low-pass");               }
 800b002:	edd4 7a02 	vldr	s15, [r4, #8]
 800b006:	eef5 7a40 	vcmp.f32	s15, #0.0
 800b00a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b00e:	d011      	beq.n	800b034 <draw_filter_result+0x180>
 800b010:	edd4 7a0e 	vldr	s15, [r4, #56]	@ 0x38
 800b014:	4a15      	ldr	r2, [pc, #84]	@ (800b06c <draw_filter_result+0x1b8>)
 800b016:	eef5 7a40 	vcmp.f32	s15, #0.0
 800b01a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b01e:	bf14      	ite	ne
 800b020:	4b13      	ldrne	r3, [pc, #76]	@ (800b070 <draw_filter_result+0x1bc>)
 800b022:	4b14      	ldreq	r3, [pc, #80]	@ (800b074 <draw_filter_result+0x1c0>)
 800b024:	4631      	mov	r1, r6
}
 800b026:	b005      	add	sp, #20
 800b028:	ecbd 8b02 	vpop	{d8}
 800b02c:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (s21_filter->lo_pass.f[_3dB]) {draw_s21_pass(xp, yp, &s21_filter->lo_pass, s21_filter->f_center ? "High-side" : "Low-pass");               }
 800b030:	f7ff bee4 	b.w	800adfc <draw_s21_pass>
}
 800b034:	b005      	add	sp, #20
 800b036:	ecbd 8b02 	vpop	{d8}
 800b03a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800b03e:	bf00      	nop
 800b040:	200069fc 	.word	0x200069fc
 800b044:	08014929 	.word	0x08014929
 800b048:	c2480000 	.word	0xc2480000
 800b04c:	08014934 	.word	0x08014934
 800b050:	08014945 	.word	0x08014945
 800b054:	08014958 	.word	0x08014958
 800b058:	0801495e 	.word	0x0801495e
 800b05c:	08014966 	.word	0x08014966
 800b060:	20006a1c 	.word	0x20006a1c
 800b064:	08014903 	.word	0x08014903
 800b068:	0801490c 	.word	0x0801490c
 800b06c:	20006a04 	.word	0x20006a04
 800b070:	08014916 	.word	0x08014916
 800b074:	08014920 	.word	0x08014920

0800b078 <draw_serial_result>:
static void draw_serial_result(int xp, int yp) {
 800b078:	b5f0      	push	{r4, r5, r6, r7, lr}
  cell_printf(xp, yp, s21_measure->header);
 800b07a:	4d2d      	ldr	r5, [pc, #180]	@ (800b130 <draw_serial_result+0xb8>)
 800b07c:	b206      	sxth	r6, r0
static void draw_serial_result(int xp, int yp) {
 800b07e:	460f      	mov	r7, r1
  cell_printf(xp, yp, s21_measure->header);
 800b080:	682a      	ldr	r2, [r5, #0]
static void draw_serial_result(int xp, int yp) {
 800b082:	b087      	sub	sp, #28
  cell_printf(xp, yp, s21_measure->header);
 800b084:	b209      	sxth	r1, r1
 800b086:	4630      	mov	r0, r6
 800b088:	f7ff fdac 	bl	800abe4 <cell_printf>
  if (s21_measure->freq == 0 && s21_measure->freq1 == 0) {
 800b08c:	686b      	ldr	r3, [r5, #4]
  yp+=STR_MEASURE_HEIGHT;
 800b08e:	f107 040c 	add.w	r4, r7, #12
  if (s21_measure->freq == 0 && s21_measure->freq1 == 0) {
 800b092:	b953      	cbnz	r3, 800b0aa <draw_serial_result+0x32>
 800b094:	68ab      	ldr	r3, [r5, #8]
 800b096:	2b00      	cmp	r3, #0
 800b098:	d130      	bne.n	800b0fc <draw_serial_result+0x84>
    cell_printf(xp, yp, "Not found");
 800b09a:	4a26      	ldr	r2, [pc, #152]	@ (800b134 <draw_serial_result+0xbc>)
 800b09c:	b221      	sxth	r1, r4
 800b09e:	4630      	mov	r0, r6
}
 800b0a0:	b007      	add	sp, #28
 800b0a2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    cell_printf(xp, yp, "Not found");
 800b0a6:	f7ff bd9d 	b.w	800abe4 <cell_printf>
    cell_printf(xp, yp                    , "Fs=%q" S_Hz, s21_measure->freq);
 800b0aa:	4a23      	ldr	r2, [pc, #140]	@ (800b138 <draw_serial_result+0xc0>)
 800b0ac:	b221      	sxth	r1, r4
 800b0ae:	4630      	mov	r0, r6
 800b0b0:	f7ff fd98 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Lm=%F" S_HENRY "  Cm=%F" S_FARAD "  Rm=%F" S_OHM, s21_measure->l, s21_measure->c, s21_measure->r);
 800b0b4:	69e8      	ldr	r0, [r5, #28]
 800b0b6:	f7f5 fa73 	bl	80005a0 <__aeabi_f2d>
 800b0ba:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800b0be:	6968      	ldr	r0, [r5, #20]
 800b0c0:	f7f5 fa6e 	bl	80005a0 <__aeabi_f2d>
 800b0c4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800b0c8:	6928      	ldr	r0, [r5, #16]
 800b0ca:	f7f5 fa69 	bl	80005a0 <__aeabi_f2d>
 800b0ce:	f107 0418 	add.w	r4, r7, #24
 800b0d2:	b224      	sxth	r4, r4
 800b0d4:	e9cd 0100 	strd	r0, r1, [sp]
 800b0d8:	4a18      	ldr	r2, [pc, #96]	@ (800b13c <draw_serial_result+0xc4>)
 800b0da:	4621      	mov	r1, r4
 800b0dc:	4630      	mov	r0, r6
 800b0de:	f7ff fd81 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Q=%.3f", s21_measure->q);
 800b0e2:	6a28      	ldr	r0, [r5, #32]
 800b0e4:	f7f5 fa5c 	bl	80005a0 <__aeabi_f2d>
 800b0e8:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 800b0ec:	b227      	sxth	r7, r4
 800b0ee:	e9cd 0100 	strd	r0, r1, [sp]
 800b0f2:	4a13      	ldr	r2, [pc, #76]	@ (800b140 <draw_serial_result+0xc8>)
 800b0f4:	4639      	mov	r1, r7
 800b0f6:	4630      	mov	r0, r6
 800b0f8:	f7ff fd74 	bl	800abe4 <cell_printf>
  if (s21_measure->freq1){
 800b0fc:	68ab      	ldr	r3, [r5, #8]
 800b0fe:	b1a3      	cbz	r3, 800b12a <draw_serial_result+0xb2>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Fp=%q" S_Hz "  " S_DELTA "F=%d", s21_measure->freq1, s21_measure->df);
 800b100:	68ea      	ldr	r2, [r5, #12]
 800b102:	9200      	str	r2, [sp, #0]
 800b104:	f104 010c 	add.w	r1, r4, #12
 800b108:	4a0e      	ldr	r2, [pc, #56]	@ (800b144 <draw_serial_result+0xcc>)
 800b10a:	b209      	sxth	r1, r1
 800b10c:	4630      	mov	r0, r6
 800b10e:	f7ff fd69 	bl	800abe4 <cell_printf>
    cell_printf(xp, yp+=STR_MEASURE_HEIGHT, "Cp=%F" S_FARAD, s21_measure->c1);
 800b112:	69a8      	ldr	r0, [r5, #24]
 800b114:	f7f5 fa44 	bl	80005a0 <__aeabi_f2d>
 800b118:	3418      	adds	r4, #24
 800b11a:	b224      	sxth	r4, r4
 800b11c:	e9cd 0100 	strd	r0, r1, [sp]
 800b120:	4a09      	ldr	r2, [pc, #36]	@ (800b148 <draw_serial_result+0xd0>)
 800b122:	4621      	mov	r1, r4
 800b124:	4630      	mov	r0, r6
 800b126:	f7ff fd5d 	bl	800abe4 <cell_printf>
}
 800b12a:	b007      	add	sp, #28
 800b12c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b12e:	bf00      	nop
 800b130:	200069fc 	.word	0x200069fc
 800b134:	08014864 	.word	0x08014864
 800b138:	0801496c 	.word	0x0801496c
 800b13c:	08014974 	.word	0x08014974
 800b140:	0801498b 	.word	0x0801498b
 800b144:	08014992 	.word	0x08014992
 800b148:	080149a1 	.word	0x080149a1

0800b14c <lc_match_x_str>:
  if (isnan(X) || 0.0f == X || -0.0f == X)
 800b14c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b150:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b154:	d027      	beq.n	800b1a6 <lc_match_x_str+0x5a>
  if (X < 0.0f) {X = -1.0f / X; type = S_FARAD[0];}
 800b156:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800b15a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b15e:	bf44      	itt	mi
 800b160:	eebf 7a00 	vmovmi.f32	s14, #240	@ 0xbf800000 -1.0
 800b164:	ee87 0a00 	vdivmi.f32	s0, s14, s0
{
 800b168:	b530      	push	{r4, r5, lr}
 800b16a:	b085      	sub	sp, #20
  if (X < 0.0f) {X = -1.0f / X; type = S_FARAD[0];}
 800b16c:	bf4c      	ite	mi
 800b16e:	2346      	movmi	r3, #70	@ 0x46
  else          {               type = S_HENRY[0];}
 800b170:	2348      	movpl	r3, #72	@ 0x48
  cell_printf(xp, yp, "%4.2F%c", val, type);
 800b172:	b215      	sxth	r5, r2
 800b174:	b20c      	sxth	r4, r1
 800b176:	9302      	str	r3, [sp, #8]
  float val = X / ((2.0f * VNA_PI) * FHz);
 800b178:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 800b1a8 <lc_match_x_str+0x5c>
 800b17c:	ee07 0a90 	vmov	s15, r0
 800b180:	ee20 0a07 	vmul.f32	s0, s0, s14
 800b184:	eef8 7a67 	vcvt.f32.u32	s15, s15
  cell_printf(xp, yp, "%4.2F%c", val, type);
 800b188:	eec0 7a27 	vdiv.f32	s15, s0, s15
 800b18c:	ee17 0a90 	vmov	r0, s15
 800b190:	f7f5 fa06 	bl	80005a0 <__aeabi_f2d>
 800b194:	4a05      	ldr	r2, [pc, #20]	@ (800b1ac <lc_match_x_str+0x60>)
 800b196:	e9cd 0100 	strd	r0, r1, [sp]
 800b19a:	4629      	mov	r1, r5
 800b19c:	4620      	mov	r0, r4
 800b19e:	f7ff fd21 	bl	800abe4 <cell_printf>
}
 800b1a2:	b005      	add	sp, #20
 800b1a4:	bd30      	pop	{r4, r5, pc}
 800b1a6:	4770      	bx	lr
 800b1a8:	3e22f983 	.word	0x3e22f983
 800b1ac:	080149a8 	.word	0x080149a8

0800b1b0 <draw_lc_match>:
static void draw_lc_match(int xp, int yp) {
 800b1b0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800b1b4:	4e30      	ldr	r6, [pc, #192]	@ (800b278 <draw_lc_match+0xc8>)
 800b1b6:	fa0f f880 	sxth.w	r8, r0
static void draw_lc_match(int xp, int yp) {
 800b1ba:	4605      	mov	r5, r0
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800b1bc:	6870      	ldr	r0, [r6, #4]
static void draw_lc_match(int xp, int yp) {
 800b1be:	460c      	mov	r4, r1
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800b1c0:	b20f      	sxth	r7, r1
 800b1c2:	f7f5 f9ed 	bl	80005a0 <__aeabi_f2d>
  yp += STR_MEASURE_HEIGHT;
 800b1c6:	340c      	adds	r4, #12
  cell_printf(xp, yp, "L/C match for source Z0 = %0.1f" S_OHM, lc_match_array->R0);
 800b1c8:	e9cd 0100 	strd	r0, r1, [sp]
 800b1cc:	4a2b      	ldr	r2, [pc, #172]	@ (800b27c <draw_lc_match+0xcc>)
 800b1ce:	4639      	mov	r1, r7
 800b1d0:	4640      	mov	r0, r8
 800b1d2:	f7ff fd07 	bl	800abe4 <cell_printf>
  if (yp >= CELLHEIGHT) return;
 800b1d6:	2c1f      	cmp	r4, #31
 800b1d8:	dc4b      	bgt.n	800b272 <draw_lc_match+0xc2>
  if (lc_match_array->num_matches < 0)
 800b1da:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	@ 0x38
 800b1de:	2b00      	cmp	r3, #0
    cell_printf(xp, yp, "No LC match for this");
 800b1e0:	b227      	sxth	r7, r4
  if (lc_match_array->num_matches < 0)
 800b1e2:	da01      	bge.n	800b1e8 <draw_lc_match+0x38>
    cell_printf(xp, yp, "No LC match for this");
 800b1e4:	4a26      	ldr	r2, [pc, #152]	@ (800b280 <draw_lc_match+0xd0>)
 800b1e6:	e001      	b.n	800b1ec <draw_lc_match+0x3c>
  else if (lc_match_array->num_matches == 0)
 800b1e8:	d107      	bne.n	800b1fa <draw_lc_match+0x4a>
    cell_printf(xp, yp, "No need for LC match");
 800b1ea:	4a26      	ldr	r2, [pc, #152]	@ (800b284 <draw_lc_match+0xd4>)
 800b1ec:	4639      	mov	r1, r7
 800b1ee:	4640      	mov	r0, r8
}
 800b1f0:	b002      	add	sp, #8
 800b1f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cell_printf(xp, yp, "No need for LC match");
 800b1f6:	f7ff bcf5 	b.w	800abe4 <cell_printf>
    cell_printf(xp                      , yp, "Src shunt" );
 800b1fa:	4639      	mov	r1, r7
 800b1fc:	4a22      	ldr	r2, [pc, #136]	@ (800b288 <draw_lc_match+0xd8>)
 800b1fe:	4640      	mov	r0, r8
    cell_printf(xp +   STR_MEASURE_WIDTH, yp, "Series"    );
 800b200:	fa1f f885 	uxth.w	r8, r5
    cell_printf(xp                      , yp, "Src shunt" );
 800b204:	f7ff fcee 	bl	800abe4 <cell_printf>
    cell_printf(xp +   STR_MEASURE_WIDTH, yp, "Series"    );
 800b208:	f108 0046 	add.w	r0, r8, #70	@ 0x46
 800b20c:	4639      	mov	r1, r7
 800b20e:	4a1f      	ldr	r2, [pc, #124]	@ (800b28c <draw_lc_match+0xdc>)
 800b210:	b200      	sxth	r0, r0
 800b212:	f7ff fce7 	bl	800abe4 <cell_printf>
    cell_printf(xp + 2*STR_MEASURE_WIDTH, yp, "Load shunt");
 800b216:	f108 008c 	add.w	r0, r8, #140	@ 0x8c
 800b21a:	4639      	mov	r1, r7
 800b21c:	4a1c      	ldr	r2, [pc, #112]	@ (800b290 <draw_lc_match+0xe0>)
 800b21e:	b200      	sxth	r0, r0
 800b220:	f7ff fce0 	bl	800abe4 <cell_printf>
    for (int i = 0; i < lc_match_array->num_matches; i++){
 800b224:	4637      	mov	r7, r6
 800b226:	f04f 0800 	mov.w	r8, #0
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xs , xp +   STR_MEASURE_WIDTH, yp);
 800b22a:	f105 0a46 	add.w	sl, r5, #70	@ 0x46
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xpl, xp + 2*STR_MEASURE_WIDTH, yp);
 800b22e:	f105 098c 	add.w	r9, r5, #140	@ 0x8c
    for (int i = 0; i < lc_match_array->num_matches; i++){
 800b232:	f9b6 3038 	ldrsh.w	r3, [r6, #56]	@ 0x38
 800b236:	4543      	cmp	r3, r8
 800b238:	dd1b      	ble.n	800b272 <draw_lc_match+0xc2>
      yp += STR_MEASURE_HEIGHT;
 800b23a:	340c      	adds	r4, #12
      if (yp >= CELLHEIGHT) return;
 800b23c:	2c1f      	cmp	r4, #31
 800b23e:	dc18      	bgt.n	800b272 <draw_lc_match+0xc2>
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xps, xp                      , yp);
 800b240:	ed97 0a02 	vldr	s0, [r7, #8]
 800b244:	6830      	ldr	r0, [r6, #0]
 800b246:	4622      	mov	r2, r4
 800b248:	4629      	mov	r1, r5
 800b24a:	f7ff ff7f 	bl	800b14c <lc_match_x_str>
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xs , xp +   STR_MEASURE_WIDTH, yp);
 800b24e:	ed97 0a03 	vldr	s0, [r7, #12]
 800b252:	6830      	ldr	r0, [r6, #0]
 800b254:	4622      	mov	r2, r4
 800b256:	4651      	mov	r1, sl
 800b258:	f7ff ff78 	bl	800b14c <lc_match_x_str>
      lc_match_x_str(lc_match_array->Hz, lc_match_array->matches[i].xpl, xp + 2*STR_MEASURE_WIDTH, yp);
 800b25c:	ed97 0a04 	vldr	s0, [r7, #16]
 800b260:	6830      	ldr	r0, [r6, #0]
 800b262:	4622      	mov	r2, r4
 800b264:	4649      	mov	r1, r9
 800b266:	f7ff ff71 	bl	800b14c <lc_match_x_str>
    for (int i = 0; i < lc_match_array->num_matches; i++){
 800b26a:	f108 0801 	add.w	r8, r8, #1
 800b26e:	370c      	adds	r7, #12
 800b270:	e7df      	b.n	800b232 <draw_lc_match+0x82>
}
 800b272:	b002      	add	sp, #8
 800b274:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b278:	200069fc 	.word	0x200069fc
 800b27c:	080149b0 	.word	0x080149b0
 800b280:	080149d1 	.word	0x080149d1
 800b284:	080149e6 	.word	0x080149e6
 800b288:	080149fb 	.word	0x080149fb
 800b28c:	08014a05 	.word	0x08014a05
 800b290:	08014a0c 	.word	0x08014a0c

0800b294 <trace_print_value_string>:
{
 800b294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint8_t type = trace[t].type;
 800b298:	f8df c190 	ldr.w	ip, [pc, #400]	@ 800b42c <trace_print_value_string+0x198>
{
 800b29c:	ed2d 8b02 	vpush	{d8}
 800b2a0:	461f      	mov	r7, r3
  uint8_t type = trace[t].type;
 800b2a2:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800b2a6:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
{
 800b2aa:	b089      	sub	sp, #36	@ 0x24
  uint8_t type = trace[t].type;
 800b2ac:	f893 4029 	ldrb.w	r4, [r3, #41]	@ 0x29
{
 800b2b0:	460e      	mov	r6, r1
  if (type >= MAX_TRACE_TYPE)
 800b2b2:	2c1d      	cmp	r4, #29
  uint8_t type = trace[t].type;
 800b2b4:	ea4f 0142 	mov.w	r1, r2, lsl #1
 800b2b8:	9106      	str	r1, [sp, #24]
  if (type >= MAX_TRACE_TYPE)
 800b2ba:	d83a      	bhi.n	800b332 <trace_print_value_string+0x9e>
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800b2bc:	f8df a170 	ldr.w	sl, [pc, #368]	@ 800b430 <trace_print_value_string+0x19c>
  float (*array)[2] = measured[trace[t].channel];
 800b2c0:	f893 e02a 	ldrb.w	lr, [r3, #42]	@ 0x2a
 800b2c4:	4957      	ldr	r1, [pc, #348]	@ (800b424 <trace_print_value_string+0x190>)
 800b2c6:	4605      	mov	r5, r0
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800b2c8:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800b2cc:	9814      	ldr	r0, [sp, #80]	@ 0x50
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800b2ce:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
  float (*array)[2] = measured[trace[t].channel];
 800b2d2:	f640 4888 	movw	r8, #3208	@ 0xc88
 800b2d6:	fb08 180e 	mla	r8, r8, lr, r1
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800b2da:	3001      	adds	r0, #1
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800b2dc:	f8d3 9018 	ldr.w	r9, [r3, #24]
  float *coeff = array[index];
 800b2e0:	eb08 01c7 	add.w	r1, r8, r7, lsl #3
  get_value_cb_t c = trace_info_list[type].get_value_cb;
 800b2e4:	ea4f 0bc4 	mov.w	fp, r4, lsl #3
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800b2e8:	d028      	beq.n	800b33c <trace_print_value_string+0xa8>
  if (c)
 800b2ea:	f1b9 0f00 	cmp.w	r9, #0
 800b2ee:	d145      	bne.n	800b37c <trace_print_value_string+0xe8>
    format_smith_value(xpos, ypos, coeff, index, type == TRC_SMITH ? trace[t].smith_format : MS_REIM);
 800b2f0:	2c03      	cmp	r4, #3
 800b2f2:	d061      	beq.n	800b3b8 <trace_print_value_string+0x124>
  float zr = re(idx, coeff);
 800b2f4:	4638      	mov	r0, r7
 800b2f6:	f7ff f9f3 	bl	800a6e0 <real>
 800b2fa:	ee10 4a10 	vmov	r4, s0
  float zi = im(idx, coeff);
 800b2fe:	f7ff f9f3 	bl	800a6e8 <imag>
  const char *format = marker_info_list[m].format;
 800b302:	f8df 8130 	ldr.w	r8, [pc, #304]	@ 800b434 <trace_print_value_string+0x1a0>
  float zi = im(idx, coeff);
 800b306:	eeb0 8a40 	vmov.f32	s16, s0
 800b30a:	2300      	movs	r3, #0
  cell_printf(xpos, ypos, format, zr, zi, value);
 800b30c:	ee18 0a10 	vmov	r0, s16
 800b310:	9304      	str	r3, [sp, #16]
 800b312:	f7f5 f945 	bl	80005a0 <__aeabi_f2d>
 800b316:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800b31a:	4620      	mov	r0, r4
 800b31c:	f7f5 f940 	bl	80005a0 <__aeabi_f2d>
 800b320:	b236      	sxth	r6, r6
 800b322:	b22d      	sxth	r5, r5
 800b324:	e9cd 0100 	strd	r0, r1, [sp]
 800b328:	4642      	mov	r2, r8
 800b32a:	4631      	mov	r1, r6
 800b32c:	4628      	mov	r0, r5
 800b32e:	f7ff fc59 	bl	800abe4 <cell_printf>
}
 800b332:	b009      	add	sp, #36	@ 0x24
 800b334:	ecbd 8b02 	vpop	{d8}
 800b338:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800b33c:	685b      	ldr	r3, [r3, #4]
 800b33e:	9306      	str	r3, [sp, #24]
  if (c)
 800b340:	f1b9 0f00 	cmp.w	r9, #0
 800b344:	d0d4      	beq.n	800b2f0 <trace_print_value_string+0x5c>
    float v = c(index, coeff); // Get value
 800b346:	4638      	mov	r0, r7
 800b348:	47c8      	blx	r9
 800b34a:	ee10 3a10 	vmov	r3, s0
    cell_printf(xpos, ypos, format, v, trace_info_list[type].symbol);
 800b34e:	ebab 0404 	sub.w	r4, fp, r4
 800b352:	eb0a 0484 	add.w	r4, sl, r4, lsl #2
 800b356:	4618      	mov	r0, r3
 800b358:	68e3      	ldr	r3, [r4, #12]
 800b35a:	9302      	str	r3, [sp, #8]
 800b35c:	f7f5 f920 	bl	80005a0 <__aeabi_f2d>
 800b360:	b236      	sxth	r6, r6
 800b362:	b22d      	sxth	r5, r5
 800b364:	e9cd 0100 	strd	r0, r1, [sp]
 800b368:	9a06      	ldr	r2, [sp, #24]
 800b36a:	4631      	mov	r1, r6
 800b36c:	4628      	mov	r0, r5
 800b36e:	f7ff fc39 	bl	800abe4 <cell_printf>
}
 800b372:	b009      	add	sp, #36	@ 0x24
 800b374:	ecbd 8b02 	vpop	{d8}
 800b378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const char *format = index_ref >= 0 ? trace_info_list[type].dformat : trace_info_list[type].format; // Format string
 800b37c:	689b      	ldr	r3, [r3, #8]
 800b37e:	9306      	str	r3, [sp, #24]
    float v = c(index, coeff); // Get value
 800b380:	4638      	mov	r0, r7
 800b382:	47c8      	blx	r9
 800b384:	ed8d 0a07 	vstr	s0, [sp, #28]
    if (index_ref >= 0 && v != infinityf())
 800b388:	f007 f890 	bl	80124ac <infinityf>
 800b38c:	9b07      	ldr	r3, [sp, #28]
 800b38e:	ee07 3a90 	vmov	s15, r3
 800b392:	eeb4 0a67 	vcmp.f32	s0, s15
 800b396:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b39a:	d0d8      	beq.n	800b34e <trace_print_value_string+0xba>
      v -= c(index, array[index_ref]); // Calculate delta value
 800b39c:	9307      	str	r3, [sp, #28]
 800b39e:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 800b3a0:	4638      	mov	r0, r7
 800b3a2:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
 800b3a6:	47c8      	blx	r9
 800b3a8:	9b07      	ldr	r3, [sp, #28]
 800b3aa:	ee07 3a90 	vmov	s15, r3
 800b3ae:	ee77 7ac0 	vsub.f32	s15, s15, s0
 800b3b2:	ee17 3a90 	vmov	r3, s15
 800b3b6:	e7ca      	b.n	800b34e <trace_print_value_string+0xba>
    format_smith_value(xpos, ypos, coeff, index, type == TRC_SMITH ? trace[t].smith_format : MS_REIM);
 800b3b8:	0050      	lsls	r0, r2, #1
 800b3ba:	4410      	add	r0, r2
 800b3bc:	eb0c 0c80 	add.w	ip, ip, r0, lsl #2
 800b3c0:	f89c 902b 	ldrb.w	r9, [ip, #43]	@ 0x2b
  if (m >= MS_END)
 800b3c4:	f1b9 0f0c 	cmp.w	r9, #12
 800b3c8:	d8b3      	bhi.n	800b332 <trace_print_value_string+0x9e>
  get_value_cb_t im = marker_info_list[m].get_im_cb;
 800b3ca:	4b17      	ldr	r3, [pc, #92]	@ (800b428 <trace_print_value_string+0x194>)
  float zr = re(idx, coeff);
 800b3cc:	9106      	str	r1, [sp, #24]
  get_value_cb_t im = marker_info_list[m].get_im_cb;
 800b3ce:	eb03 1309 	add.w	r3, r3, r9, lsl #4
  float zr = re(idx, coeff);
 800b3d2:	4638      	mov	r0, r7
 800b3d4:	689a      	ldr	r2, [r3, #8]
  get_value_cb_t im = marker_info_list[m].get_im_cb;
 800b3d6:	f8d3 a00c 	ldr.w	sl, [r3, #12]
  const char *format = marker_info_list[m].format;
 800b3da:	f8d3 8004 	ldr.w	r8, [r3, #4]
  float zr = re(idx, coeff);
 800b3de:	4790      	blx	r2
  float zi = im(idx, coeff);
 800b3e0:	9906      	ldr	r1, [sp, #24]
 800b3e2:	4638      	mov	r0, r7
  float zr = re(idx, coeff);
 800b3e4:	ee10 4a10 	vmov	r4, s0
  float zi = im(idx, coeff);
 800b3e8:	47d0      	blx	sl
  if (LC_MARKER_VALUE(m))
 800b3ea:	f241 5350 	movw	r3, #5456	@ 0x1550
 800b3ee:	fa43 f309 	asr.w	r3, r3, r9
 800b3f2:	f013 0301 	ands.w	r3, r3, #1
  float zi = im(idx, coeff);
 800b3f6:	eeb0 8a40 	vmov.f32	s16, s0
  if (LC_MARKER_VALUE(m))
 800b3fa:	d087      	beq.n	800b30c <trace_print_value_string+0x78>
    float w = get_w(idx);
 800b3fc:	4638      	mov	r0, r7
 800b3fe:	f7ff fb51 	bl	800aaa4 <get_w>
    if (zi < 0)
 800b402:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800b406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b40a:	d403      	bmi.n	800b414 <trace_print_value_string+0x180>
      zi = zi / (w);
 800b40c:	ee88 8a00 	vdiv.f32	s16, s16, s0
 800b410:	2348      	movs	r3, #72	@ 0x48
 800b412:	e77b      	b.n	800b30c <trace_print_value_string+0x78>
      zi = -1.0f / (w * zi);
 800b414:	ee28 0a00 	vmul.f32	s0, s16, s0
 800b418:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
 800b41c:	ee87 8a80 	vdiv.f32	s16, s15, s0
      value = S_FARAD[0];
 800b420:	2346      	movs	r3, #70	@ 0x46
 800b422:	e773      	b.n	800b30c <trace_print_value_string+0x78>
 800b424:	20004f54 	.word	0x20004f54
 800b428:	0801643c 	.word	0x0801643c
 800b42c:	20000aa8 	.word	0x20000aa8
 800b430:	0801650c 	.word	0x0801650c
 800b434:	08013c38 	.word	0x08013c38

0800b438 <find_filter_pass>:
static void find_filter_pass(float max, s21_pass *p, uint16_t idx, int16_t mode) {
 800b438:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b43c:	ed2d 8b02 	vpush	{d8}
 800b440:	b082      	sub	sp, #8
 800b442:	f8df 80a8 	ldr.w	r8, [pc, #168]	@ 800b4ec <find_filter_pass+0xb4>
 800b446:	f8ad 1006 	strh.w	r1, [sp, #6]
 800b44a:	eeb0 8a40 	vmov.f32	s16, s0
 800b44e:	4604      	mov	r4, r0
 800b450:	4616      	mov	r6, r2
 800b452:	4607      	mov	r7, r0
  for (int i = 0; i < _end; i++)
 800b454:	2500      	movs	r5, #0
    p->f[i] = measure_search_value(&idx, max - filter_att[i], s21logmag, mode, i == 0 ? (mode == MEASURE_SEARCH_LEFT ? 1 : 2) : MARKER_INVALID);
 800b456:	ecb8 0a01 	vldmia	r8!, {s0}
 800b45a:	ee38 0a40 	vsub.f32	s0, s16, s0
 800b45e:	b925      	cbnz	r5, 800b46a <find_filter_pass+0x32>
 800b460:	1c72      	adds	r2, r6, #1
 800b462:	bf14      	ite	ne
 800b464:	2302      	movne	r3, #2
 800b466:	2301      	moveq	r3, #1
 800b468:	e001      	b.n	800b46e <find_filter_pass+0x36>
 800b46a:	f04f 33ff 	mov.w	r3, #4294967295
 800b46e:	491c      	ldr	r1, [pc, #112]	@ (800b4e0 <find_filter_pass+0xa8>)
 800b470:	4632      	mov	r2, r6
 800b472:	f10d 0006 	add.w	r0, sp, #6
 800b476:	f7ff fb35 	bl	800aae4 <measure_search_value>
  for (int i = 0; i < _end; i++)
 800b47a:	3501      	adds	r5, #1
 800b47c:	2d04      	cmp	r5, #4
    p->f[i] = measure_search_value(&idx, max - filter_att[i], s21logmag, mode, i == 0 ? (mode == MEASURE_SEARCH_LEFT ? 1 : 2) : MARKER_INVALID);
 800b47e:	eca7 0a01 	vstmia	r7!, {s0}
  for (int i = 0; i < _end; i++)
 800b482:	d1e8      	bne.n	800b456 <find_filter_pass+0x1e>
  if (p->f[_10dB] != 0 && p->f[_20dB] != 0) {
 800b484:	edd4 7a02 	vldr	s15, [r4, #8]
 800b488:	eef5 7a40 	vcmp.f32	s15, #0.0
  p->decade = p->octave = 0.0f;
 800b48c:	2300      	movs	r3, #0
  if (p->f[_10dB] != 0 && p->f[_20dB] != 0) {
 800b48e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  p->decade = p->octave = 0.0f;
 800b492:	6163      	str	r3, [r4, #20]
 800b494:	6123      	str	r3, [r4, #16]
  if (p->f[_10dB] != 0 && p->f[_20dB] != 0) {
 800b496:	d01e      	beq.n	800b4d6 <find_filter_pass+0x9e>
 800b498:	ed94 0a03 	vldr	s0, [r4, #12]
 800b49c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b4a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b4a4:	d017      	beq.n	800b4d6 <find_filter_pass+0x9e>
    float k = vna_fabsf(vna_logf(p->f[_20dB]) - vna_logf(p->f[_10dB]));
 800b4a6:	f006 ff15 	bl	80122d4 <vna_logf>
 800b4aa:	eeb0 8a40 	vmov.f32	s16, s0
 800b4ae:	ed94 0a02 	vldr	s0, [r4, #8]
 800b4b2:	f006 ff0f 	bl	80122d4 <vna_logf>
    p->decade = (10.0f * logf(10.0f)) / k;
 800b4b6:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 800b4e4 <find_filter_pass+0xac>
    float k = vna_fabsf(vna_logf(p->f[_20dB]) - vna_logf(p->f[_10dB]));
 800b4ba:	ee38 0a40 	vsub.f32	s0, s16, s0
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800b4be:	eeb0 0ac0 	vabs.f32	s0, s0
    p->decade = (10.0f * logf(10.0f)) / k;
 800b4c2:	eec7 7a00 	vdiv.f32	s15, s14, s0
    p->octave = (10.0f * logf( 2.0f)) / k;
 800b4c6:	ed9f 7a08 	vldr	s14, [pc, #32]	@ 800b4e8 <find_filter_pass+0xb0>
    p->decade = (10.0f * logf(10.0f)) / k;
 800b4ca:	edc4 7a04 	vstr	s15, [r4, #16]
    p->octave = (10.0f * logf( 2.0f)) / k;
 800b4ce:	eec7 7a00 	vdiv.f32	s15, s14, s0
 800b4d2:	edc4 7a05 	vstr	s15, [r4, #20]
}
 800b4d6:	b002      	add	sp, #8
 800b4d8:	ecbd 8b02 	vpop	{d8}
 800b4dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800b4e0:	0800bacd 	.word	0x0800bacd
 800b4e4:	41b834f2 	.word	0x41b834f2
 800b4e8:	40ddce9e 	.word	0x40ddce9e
 800b4ec:	0801622c 	.word	0x0801622c

0800b4f0 <marker_area_max>:
{
 800b4f0:	b538      	push	{r3, r4, r5, lr}
 800b4f2:	4b1a      	ldr	r3, [pc, #104]	@ (800b55c <marker_area_max+0x6c>)
  int t_count = 0, m_count = 0, i;
 800b4f4:	2400      	movs	r4, #0
 800b4f6:	f103 0030 	add.w	r0, r3, #48	@ 0x30
{
 800b4fa:	461d      	mov	r5, r3
 800b4fc:	461a      	mov	r2, r3
    if (trace[i].enabled)
 800b4fe:	f892 1028 	ldrb.w	r1, [r2, #40]	@ 0x28
  for (i = 0; i < TRACES_MAX; i++)
 800b502:	320c      	adds	r2, #12
    if (trace[i].enabled)
 800b504:	b101      	cbz	r1, 800b508 <marker_area_max+0x18>
      t_count++;
 800b506:	3401      	adds	r4, #1
  for (i = 0; i < TRACES_MAX; i++)
 800b508:	4290      	cmp	r0, r2
 800b50a:	d1f8      	bne.n	800b4fe <marker_area_max+0xe>
  for (i = 0; i < MARKERS_MAX; i++)
 800b50c:	4814      	ldr	r0, [pc, #80]	@ (800b560 <marker_area_max+0x70>)
  int t_count = 0, m_count = 0, i;
 800b50e:	2100      	movs	r1, #0
    if (markers[i].enabled)
 800b510:	f893 2058 	ldrb.w	r2, [r3, #88]	@ 0x58
  for (i = 0; i < MARKERS_MAX; i++)
 800b514:	3308      	adds	r3, #8
    if (markers[i].enabled)
 800b516:	b102      	cbz	r2, 800b51a <marker_area_max+0x2a>
      m_count++;
 800b518:	3101      	adds	r1, #1
  for (i = 0; i < MARKERS_MAX; i++)
 800b51a:	4298      	cmp	r0, r3
 800b51c:	d1f8      	bne.n	800b510 <marker_area_max+0x20>
  int cnt = t_count > m_count ? t_count : m_count;
 800b51e:	428c      	cmp	r4, r1
 800b520:	bfb8      	it	lt
 800b522:	460c      	movlt	r4, r1
  if (get_electrical_delay() != 0.0f)
 800b524:	f7fd ff84 	bl	8009430 <get_electrical_delay>
  if (s21_offset != 0.0f)
 800b528:	edd5 7a2a 	vldr	s15, [r5, #168]	@ 0xa8
 800b52c:	eef5 7a40 	vcmp.f32	s15, #0.0
 800b530:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b534:	d010      	beq.n	800b558 <marker_area_max+0x68>
  if (get_electrical_delay() != 0.0f)
 800b536:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b53a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b53e:	bf14      	ite	ne
 800b540:	2301      	movne	r3, #1
 800b542:	2300      	moveq	r3, #0
 800b544:	005b      	lsls	r3, r3, #1
    extra += 2;
 800b546:	3302      	adds	r3, #2
  cnt = (cnt + extra + 1) >> 1;
 800b548:	4423      	add	r3, r4
 800b54a:	3301      	adds	r3, #1
 800b54c:	105b      	asrs	r3, r3, #1
  return cnt * FONT_STR_HEIGHT;
 800b54e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
}
 800b552:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 800b556:	bd38      	pop	{r3, r4, r5, pc}
 800b558:	2302      	movs	r3, #2
 800b55a:	e7f5      	b.n	800b548 <marker_area_max+0x58>
 800b55c:	20000aa8 	.word	0x20000aa8
 800b560:	20000ae8 	.word	0x20000ae8

0800b564 <cell_fill_bg_rect.constprop.0>:
static void cell_fill_bg_rect(int x0, int y0, int x, int y, int w, int h)
 800b564:	b510      	push	{r4, lr}
  w += PAD * 2;
 800b566:	9c02      	ldr	r4, [sp, #8]
 800b568:	f104 0e06 	add.w	lr, r4, #6
  if (w <= 0 || h <= 0)
 800b56c:	f1be 0f00 	cmp.w	lr, #0
 800b570:	dd3d      	ble.n	800b5ee <cell_fill_bg_rect.constprop.0+0x8a>
  x -= PAD;
 800b572:	f1a2 0c03 	sub.w	ip, r2, #3
  int xe = x + w;
 800b576:	44e6      	add	lr, ip
  if (xs < x0)
 800b578:	4584      	cmp	ip, r0
  if (xe > x0 + CELLWIDTH)
 800b57a:	f100 0220 	add.w	r2, r0, #32
  if (xs < x0)
 800b57e:	bfb8      	it	lt
 800b580:	4684      	movlt	ip, r0
  if (xe > x0 + CELLWIDTH)
 800b582:	4596      	cmp	lr, r2
 800b584:	bfa8      	it	ge
 800b586:	4696      	movge	lr, r2
  if (xe <= xs || ye <= ys)
 800b588:	45f4      	cmp	ip, lr
 800b58a:	da30      	bge.n	800b5ee <cell_fill_bg_rect.constprop.0+0x8a>
  y -= PAD;
 800b58c:	1eda      	subs	r2, r3, #3
  if (ys < y0)
 800b58e:	428a      	cmp	r2, r1
  int ye = y + h;
 800b590:	f103 0319 	add.w	r3, r3, #25
  if (ye > y0 + CELLHEIGHT)
 800b594:	f101 0420 	add.w	r4, r1, #32
  if (ys < y0)
 800b598:	bfb8      	it	lt
 800b59a:	460a      	movlt	r2, r1
  if (ye > y0 + CELLHEIGHT)
 800b59c:	42a3      	cmp	r3, r4
 800b59e:	bfa8      	it	ge
 800b5a0:	4623      	movge	r3, r4
  if (xe <= xs || ye <= ys)
 800b5a2:	429a      	cmp	r2, r3
 800b5a4:	da23      	bge.n	800b5ee <cell_fill_bg_rect.constprop.0+0x8a>
  const pixel_t bg = GET_PALTETTE_COLOR(LCD_BG_COLOR);
 800b5a6:	1a52      	subs	r2, r2, r1
    pixel_t *row = cell_buffer + (yy - y0) * CELLWIDTH + (xs - x0);
 800b5a8:	ebac 0000 	sub.w	r0, ip, r0
 800b5ac:	1a59      	subs	r1, r3, r1
 800b5ae:	eb00 1342 	add.w	r3, r0, r2, lsl #5
 800b5b2:	4a0f      	ldr	r2, [pc, #60]	@ (800b5f0 <cell_fill_bg_rect.constprop.0+0x8c>)
 800b5b4:	6812      	ldr	r2, [r2, #0]
 800b5b6:	4473      	add	r3, lr
 800b5b8:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 800b5bc:	eba3 010c 	sub.w	r1, r3, ip
 800b5c0:	eb00 030e 	add.w	r3, r0, lr
 800b5c4:	eba2 004c 	sub.w	r0, r2, ip, lsl #1
 800b5c8:	eb00 0043 	add.w	r0, r0, r3, lsl #1
  const pixel_t bg = GET_PALTETTE_COLOR(LCD_BG_COLOR);
 800b5cc:	4b09      	ldr	r3, [pc, #36]	@ (800b5f4 <cell_fill_bg_rect.constprop.0+0x90>)
 800b5ce:	ebac 0e0e 	sub.w	lr, ip, lr
 800b5d2:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 800b5d6:	8bd9      	ldrh	r1, [r3, #30]
  for (int yy = ys; yy < ye; yy++)
 800b5d8:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    pixel_t *row = cell_buffer + (yy - y0) * CELLWIDTH + (xs - x0);
 800b5dc:	eb02 030e 	add.w	r3, r2, lr
      *row++ = bg;
 800b5e0:	f823 1b02 	strh.w	r1, [r3], #2
    for (int xx = xs; xx < xe; xx++)
 800b5e4:	4293      	cmp	r3, r2
 800b5e6:	d1fb      	bne.n	800b5e0 <cell_fill_bg_rect.constprop.0+0x7c>
  for (int yy = ys; yy < ye; yy++)
 800b5e8:	3240      	adds	r2, #64	@ 0x40
 800b5ea:	4282      	cmp	r2, r0
 800b5ec:	d1f6      	bne.n	800b5dc <cell_fill_bg_rect.constprop.0+0x78>
}
 800b5ee:	bd10      	pop	{r4, pc}
 800b5f0:	200089ec 	.word	0x200089ec
 800b5f4:	20000318 	.word	0x20000318

0800b5f8 <search_peak_value.constprop.0>:
static float search_peak_value(uint16_t *xp, get_value_t get, bool mode) {
 800b5f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  bool (*compare)(float x, float y) = mode ? _greaterf : _lesserf;
 800b5fc:	4b28      	ldr	r3, [pc, #160]	@ (800b6a0 <search_peak_value.constprop.0+0xa8>)
  for(int i = 1; i < sweep_points; i++) {
 800b5fe:	f8df 90a8 	ldr.w	r9, [pc, #168]	@ 800b6a8 <search_peak_value.constprop.0+0xb0>
static float search_peak_value(uint16_t *xp, get_value_t get, bool mode) {
 800b602:	460d      	mov	r5, r1
  bool (*compare)(float x, float y) = mode ? _greaterf : _lesserf;
 800b604:	4927      	ldr	r1, [pc, #156]	@ (800b6a4 <search_peak_value.constprop.0+0xac>)
static float search_peak_value(uint16_t *xp, get_value_t get, bool mode) {
 800b606:	ed2d 8b02 	vpush	{d8}
 800b60a:	4607      	mov	r7, r0
  float y2 = get(x), ytemp;
 800b60c:	2000      	movs	r0, #0
  bool (*compare)(float x, float y) = mode ? _greaterf : _lesserf;
 800b60e:	2a00      	cmp	r2, #0
 800b610:	bf0c      	ite	eq
 800b612:	468a      	moveq	sl, r1
 800b614:	469a      	movne	sl, r3
  float y2 = get(x), ytemp;
 800b616:	47a8      	blx	r5
  for(int i = 1; i < sweep_points; i++) {
 800b618:	2601      	movs	r6, #1
  float y2 = get(x), ytemp;
 800b61a:	eeb0 8a40 	vmov.f32	s16, s0
  uint16_t x = 0;
 800b61e:	2400      	movs	r4, #0
  for(int i = 1; i < sweep_points; i++) {
 800b620:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800b624:	429e      	cmp	r6, r3
 800b626:	da11      	bge.n	800b64c <search_peak_value.constprop.0+0x54>
    if(compare(ytemp = get(i), y2)) {
 800b628:	fa1f f886 	uxth.w	r8, r6
 800b62c:	4640      	mov	r0, r8
 800b62e:	47a8      	blx	r5
 800b630:	eef0 0a48 	vmov.f32	s1, s16
 800b634:	eef0 8a40 	vmov.f32	s17, s0
 800b638:	47d0      	blx	sl
 800b63a:	2800      	cmp	r0, #0
  for(int i = 1; i < sweep_points; i++) {
 800b63c:	f106 0601 	add.w	r6, r6, #1
 800b640:	bf18      	it	ne
 800b642:	eeb0 8a68 	vmovne.f32	s16, s17
 800b646:	bf18      	it	ne
 800b648:	4644      	movne	r4, r8
 800b64a:	e7e9      	b.n	800b620 <search_peak_value.constprop.0+0x28>
  if (x < 1 || x >= sweep_points - 1) return y2;
 800b64c:	b314      	cbz	r4, 800b694 <search_peak_value.constprop.0+0x9c>
 800b64e:	3b01      	subs	r3, #1
 800b650:	429c      	cmp	r4, r3
 800b652:	da1f      	bge.n	800b694 <search_peak_value.constprop.0+0x9c>
  float y1 = get(x-1);
 800b654:	1e60      	subs	r0, r4, #1
 800b656:	b280      	uxth	r0, r0
  *xp = x;
 800b658:	803c      	strh	r4, [r7, #0]
  float y1 = get(x-1);
 800b65a:	47a8      	blx	r5
  float y3 = get(x+1);
 800b65c:	1c60      	adds	r0, r4, #1
 800b65e:	b280      	uxth	r0, r0
  float y1 = get(x-1);
 800b660:	eef0 8a40 	vmov.f32	s17, s0
  float y3 = get(x+1);
 800b664:	47a8      	blx	r5
  if (y1 == y3) return y2;
 800b666:	eef4 8a40 	vcmp.f32	s17, s0
 800b66a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b66e:	d011      	beq.n	800b694 <search_peak_value.constprop.0+0x9c>
  const float a = 8.0f * (y1 - 2.0f * y2 + y3);
 800b670:	ee38 7a80 	vadd.f32	s14, s17, s0
  const float b = y3 - y1;
 800b674:	ee70 7a68 	vsub.f32	s15, s0, s17
  const float a = 8.0f * (y1 - 2.0f * y2 + y3);
 800b678:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 800b67c:	eea8 7a66 	vfms.f32	s14, s16, s13
  return c - b * b / a;
 800b680:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800b684:	eef4 6a00 	vmov.f32	s13, #64	@ 0x3e000000  0.125
 800b688:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800b68c:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800b690:	ee38 8a66 	vsub.f32	s16, s16, s13
}
 800b694:	eeb0 0a48 	vmov.f32	s0, s16
 800b698:	ecbd 8b02 	vpop	{d8}
 800b69c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b6a0:	0800a7e1 	.word	0x0800a7e1
 800b6a4:	0800a7f1 	.word	0x0800a7f1
 800b6a8:	20000aa8 	.word	0x20000aa8

0800b6ac <prepare_filter>:
static void prepare_filter(uint8_t type, uint8_t update_mask) {
 800b6ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800b6ae:	2201      	movs	r2, #1
 800b6b0:	492d      	ldr	r1, [pc, #180]	@ (800b768 <prepare_filter+0xbc>)
 800b6b2:	4c2e      	ldr	r4, [pc, #184]	@ (800b76c <prepare_filter+0xc0>)
  uint16_t xp = 0;
 800b6b4:	2600      	movs	r6, #0
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800b6b6:	f10d 0006 	add.w	r0, sp, #6
  uint16_t xp = 0;
 800b6ba:	f8ad 6006 	strh.w	r6, [sp, #6]
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800b6be:	f7ff ff9b 	bl	800b5f8 <search_peak_value.constprop.0>
  if (s21_filter->vmax >= S21_MEASURE_FILTER_THRESHOLD) {
 800b6c2:	eddf 7a2b 	vldr	s15, [pc, #172]	@ 800b770 <prepare_filter+0xc4>
  s21_filter->vmax = search_peak_value(&xp, s21logmag, MEASURE_SEARCH_MAX);            // Maximum search
 800b6c6:	ed84 0a01 	vstr	s0, [r4, #4]
  if (s21_filter->vmax >= S21_MEASURE_FILTER_THRESHOLD) {
 800b6ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800b6ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b6d2:	db40      	blt.n	800b756 <prepare_filter+0xaa>
    set_marker_index(0, xp);                                                           // Put marker on maximum value point
 800b6d4:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800b6d8:	4630      	mov	r0, r6
 800b6da:	4629      	mov	r1, r5
 800b6dc:	f7fc f870 	bl	80077c0 <set_marker_index>
    s21_filter->fmax = getFrequency(xp);                                               // Get maximum value frequency
 800b6e0:	4628      	mov	r0, r5
 800b6e2:	f7fb fa8f 	bl	8006c04 <getFrequency>
 800b6e6:	ee07 0a90 	vmov	s15, r0
 800b6ea:	4620      	mov	r0, r4
 800b6ec:	eef8 7a67 	vcvt.f32.u32	s15, s15
    find_filter_pass(s21_filter->vmax, &s21_filter->hi_pass, xp, MEASURE_SEARCH_LEFT); // Search High-pass filter data (or Low side for bandpass)
 800b6f0:	ed94 0a01 	vldr	s0, [r4, #4]
    s21_filter->fmax = getFrequency(xp);                                               // Get maximum value frequency
 800b6f4:	edc4 7a00 	vstr	s15, [r4]
 800b6f8:	3020      	adds	r0, #32
    find_filter_pass(s21_filter->vmax, &s21_filter->hi_pass, xp, MEASURE_SEARCH_LEFT); // Search High-pass filter data (or Low side for bandpass)
 800b6fa:	f04f 32ff 	mov.w	r2, #4294967295
 800b6fe:	4629      	mov	r1, r5
 800b700:	f7ff fe9a 	bl	800b438 <find_filter_pass>
    find_filter_pass(s21_filter->vmax, &s21_filter->lo_pass, xp, MEASURE_SEARCH_RIGHT);// Search Low-pass filter data (or High side for bandpass)
 800b704:	ed94 0a01 	vldr	s0, [r4, #4]
 800b708:	2201      	movs	r2, #1
 800b70a:	4629      	mov	r1, r5
 800b70c:	f104 0008 	add.w	r0, r4, #8
 800b710:	f7ff fe92 	bl	800b438 <find_filter_pass>
    s21_filter->f_center = s21_filter->lo_pass.f[_3dB] * s21_filter->hi_pass.f[_3dB];  // Center frequency (if 0, one or both points not found)
 800b714:	ed94 7a02 	vldr	s14, [r4, #8]
 800b718:	edd4 6a08 	vldr	s13, [r4, #32]
 800b71c:	ee67 7a26 	vmul.f32	s15, s14, s13
    if (s21_filter->f_center) {
 800b720:	eef5 7a40 	vcmp.f32	s15, #0.0
 800b724:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    s21_filter->f_center = s21_filter->lo_pass.f[_3dB] * s21_filter->hi_pass.f[_3dB];  // Center frequency (if 0, one or both points not found)
 800b728:	edc4 7a0e 	vstr	s15, [r4, #56]	@ 0x38
    if (s21_filter->f_center) {
 800b72c:	d013      	beq.n	800b756 <prepare_filter+0xaa>
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800b72e:	eef1 7ae7 	vsqrt.f32	s15, s15
      s21_filter->bw_3dB = s21_filter->lo_pass.f[_3dB] - s21_filter->hi_pass.f[_3dB];
 800b732:	ee37 7a66 	vsub.f32	s14, s14, s13
      s21_filter->bw_6dB = s21_filter->lo_pass.f[_6dB] - s21_filter->hi_pass.f[_6dB];
 800b736:	ed94 6a09 	vldr	s12, [r4, #36]	@ 0x24
 800b73a:	edd4 6a03 	vldr	s13, [r4, #12]
      s21_filter->bw_3dB = s21_filter->lo_pass.f[_3dB] - s21_filter->hi_pass.f[_3dB];
 800b73e:	ed84 7a0f 	vstr	s14, [r4, #60]	@ 0x3c
      s21_filter->bw_6dB = s21_filter->lo_pass.f[_6dB] - s21_filter->hi_pass.f[_6dB];
 800b742:	ee76 6ac6 	vsub.f32	s13, s13, s12
      s21_filter->f_center = vna_sqrtf(s21_filter->f_center);
 800b746:	edc4 7a0e 	vstr	s15, [r4, #56]	@ 0x38
      s21_filter->bw_6dB = s21_filter->lo_pass.f[_6dB] - s21_filter->hi_pass.f[_6dB];
 800b74a:	edc4 6a10 	vstr	s13, [r4, #64]	@ 0x40
      s21_filter->q = s21_filter->f_center / s21_filter->bw_3dB;
 800b74e:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800b752:	edc4 6a11 	vstr	s13, [r4, #68]	@ 0x44
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b756:	2306      	movs	r3, #6
 800b758:	2207      	movs	r2, #7
 800b75a:	2102      	movs	r1, #2
 800b75c:	2000      	movs	r0, #0
}
 800b75e:	b002      	add	sp, #8
 800b760:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800b764:	f7fe bf9c 	b.w	800a6a0 <invalidate_rect_func>
 800b768:	0800bacd 	.word	0x0800bacd
 800b76c:	200069fc 	.word	0x200069fc
 800b770:	c2480000 	.word	0xc2480000

0800b774 <analysis_lcseries>:
static void analysis_lcseries(void) {
 800b774:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b776:	ed2d 8b02 	vpush	{d8}
  s21_measure->header = "LC-SERIES";
 800b77a:	4c40      	ldr	r4, [pc, #256]	@ (800b87c <analysis_lcseries+0x108>)
 800b77c:	4b40      	ldr	r3, [pc, #256]	@ (800b880 <analysis_lcseries+0x10c>)
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MAX);
 800b77e:	4941      	ldr	r1, [pc, #260]	@ (800b884 <analysis_lcseries+0x110>)
static void analysis_lcseries(void) {
 800b780:	b083      	sub	sp, #12
  uint16_t xp=0, x2;
 800b782:	2700      	movs	r7, #0
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MAX);
 800b784:	2201      	movs	r2, #1
 800b786:	a801      	add	r0, sp, #4
  uint16_t xp=0, x2;
 800b788:	f8ad 7004 	strh.w	r7, [sp, #4]
  s21_measure->header = "LC-SERIES";
 800b78c:	6023      	str	r3, [r4, #0]
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MAX);
 800b78e:	f7ff ff33 	bl	800b5f8 <search_peak_value.constprop.0>
  if (xp == 0) return; // peak not found
 800b792:	f8bd 5004 	ldrh.w	r5, [sp, #4]
 800b796:	2d00      	cmp	r5, #0
 800b798:	d06c      	beq.n	800b874 <analysis_lcseries+0x100>
 800b79a:	eeb1 7ac0 	vsqrt.f32	s14, s0
  s21_measure->r = 2 * config._measure_r * (1.0f / vna_sqrtf(ypeak) - 1.0f);
 800b79e:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 800b7a2:	eec8 6a07 	vdiv.f32	s13, s16, s14
 800b7a6:	4e38      	ldr	r6, [pc, #224]	@ (800b888 <analysis_lcseries+0x114>)
 800b7a8:	edd6 7a1a 	vldr	s15, [r6, #104]	@ 0x68
 800b7ac:	ee36 7ac8 	vsub.f32	s14, s13, s16
 800b7b0:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800b7b4:	ee67 7a87 	vmul.f32	s15, s15, s14
  if(s21_measure->r < 0) return;
 800b7b8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800b7bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  s21_measure->r = 2 * config._measure_r * (1.0f / vna_sqrtf(ypeak) - 1.0f);
 800b7c0:	edc4 7a07 	vstr	s15, [r4, #28]
  if(s21_measure->r < 0) return;
 800b7c4:	d456      	bmi.n	800b874 <analysis_lcseries+0x100>
  set_marker_index(0, xp);
 800b7c6:	4629      	mov	r1, r5
 800b7c8:	4638      	mov	r0, r7
 800b7ca:	f7fb fff9 	bl	80077c0 <set_marker_index>
  float f1 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b7ce:	eeb0 0a48 	vmov.f32	s0, s16
 800b7d2:	492e      	ldr	r1, [pc, #184]	@ (800b88c <analysis_lcseries+0x118>)
  x2 = xp;
 800b7d4:	f8ad 5006 	strh.w	r5, [sp, #6]
  float f1 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b7d8:	2301      	movs	r3, #1
 800b7da:	f04f 32ff 	mov.w	r2, #4294967295
 800b7de:	f10d 0006 	add.w	r0, sp, #6
 800b7e2:	f7ff f97f 	bl	800aae4 <measure_search_value>
  if (f1 == 0) return; // not found
 800b7e6:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b7ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float f1 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800b7ee:	eeb0 8a40 	vmov.f32	s16, s0
  if (f1 == 0) return; // not found
 800b7f2:	d03f      	beq.n	800b874 <analysis_lcseries+0x100>
  float f2 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800b7f4:	4925      	ldr	r1, [pc, #148]	@ (800b88c <analysis_lcseries+0x118>)
  x2 = xp;
 800b7f6:	f8ad 5006 	strh.w	r5, [sp, #6]
  float f2 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800b7fa:	2302      	movs	r3, #2
 800b7fc:	2201      	movs	r2, #1
 800b7fe:	eebf 0a00 	vmov.f32	s0, #240	@ 0xbf800000 -1.0
 800b802:	f10d 0006 	add.w	r0, sp, #6
 800b806:	f7ff f96d 	bl	800aae4 <measure_search_value>
  if (f2 == 0) return; // not found
 800b80a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800b80e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b812:	d02f      	beq.n	800b874 <analysis_lcseries+0x100>
  float reff = 2.0f * config._measure_r + s21_measure->r;
 800b814:	ed94 6a07 	vldr	s12, [r4, #28]
 800b818:	edd6 6a1a 	vldr	s13, [r6, #104]	@ 0x68
 800b81c:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800b820:	eef0 5a46 	vmov.f32	s11, s12
 800b824:	eee6 5aa7 	vfma.f32	s11, s13, s15
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800b828:	eddf 6a19 	vldr	s13, [pc, #100]	@ 800b890 <analysis_lcseries+0x11c>
  float bw = f2 - f1;
 800b82c:	ee30 7a48 	vsub.f32	s14, s0, s16
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800b830:	ee25 5aa6 	vmul.f32	s10, s11, s13
  float fpeak = vna_sqrtf(f2 * f1);
 800b834:	ee28 0a00 	vmul.f32	s0, s16, s0
 800b838:	eeb1 0ac0 	vsqrt.f32	s0, s0
  s21_measure->freq = fpeak;
 800b83c:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800b840:	edc4 7a01 	vstr	s15, [r4, #4]
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800b844:	eec5 7a07 	vdiv.f32	s15, s10, s14
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * reff);
 800b848:	ee27 7a26 	vmul.f32	s14, s14, s13
 800b84c:	ee60 6a00 	vmul.f32	s13, s0, s0
  s21_measure->l = reff / ((2.0f * VNA_PI) * bw);
 800b850:	edc4 7a04 	vstr	s15, [r4, #16]
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * reff);
 800b854:	ee66 6aa5 	vmul.f32	s13, s13, s11
 800b858:	eec7 5a26 	vdiv.f32	s11, s14, s13
  s21_measure->q = (2.0f * VNA_PI) * fpeak * s21_measure->l / s21_measure->r;
 800b85c:	ed9f 7a0d 	vldr	s14, [pc, #52]	@ 800b894 <analysis_lcseries+0x120>
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * reff);
 800b860:	edc4 5a05 	vstr	s11, [r4, #20]
  s21_measure->q = (2.0f * VNA_PI) * fpeak * s21_measure->l / s21_measure->r;
 800b864:	ee67 7a87 	vmul.f32	s15, s15, s14
 800b868:	ee67 7a80 	vmul.f32	s15, s15, s0
 800b86c:	ee87 7a86 	vdiv.f32	s14, s15, s12
 800b870:	ed84 7a08 	vstr	s14, [r4, #32]
}
 800b874:	b003      	add	sp, #12
 800b876:	ecbd 8b02 	vpop	{d8}
 800b87a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b87c:	200069fc 	.word	0x200069fc
 800b880:	08014a17 	.word	0x08014a17
 800b884:	0800a801 	.word	0x0800a801
 800b888:	20000318 	.word	0x20000318
 800b88c:	0800a829 	.word	0x0800a829
 800b890:	3e22f983 	.word	0x3e22f983
 800b894:	40c90fdb 	.word	0x40c90fdb

0800b898 <cellPut>:
{
 800b898:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (ps->x < CELLWIDTH && ps->y < CELLHEIGHT)
 800b89c:	f9b0 6004 	ldrsh.w	r6, [r0, #4]
 800b8a0:	2e1f      	cmp	r6, #31
{
 800b8a2:	b08b      	sub	sp, #44	@ 0x2c
  if (ps->x < CELLWIDTH && ps->y < CELLHEIGHT)
 800b8a4:	dc05      	bgt.n	800b8b2 <cellPut+0x1a>
 800b8a6:	f9b0 8006 	ldrsh.w	r8, [r0, #6]
 800b8aa:	f1b8 0f1f 	cmp.w	r8, #31
 800b8ae:	4604      	mov	r4, r0
 800b8b0:	dd03      	ble.n	800b8ba <cellPut+0x22>
}
 800b8b2:	2000      	movs	r0, #0
 800b8b4:	b00b      	add	sp, #44	@ 0x2c
 800b8b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t w = FONT_GET_WIDTH(ch);
 800b8ba:	3916      	subs	r1, #22
 800b8bc:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 800b8c0:	4d31      	ldr	r5, [pc, #196]	@ (800b988 <cellPut+0xf0>)
 800b8c2:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 800b8c6:	f815 9001 	ldrb.w	r9, [r5, r1]
 800b8ca:	f009 0907 	and.w	r9, r9, #7
 800b8ce:	f1c9 0708 	rsb	r7, r9, #8
 800b8d2:	b2bf      	uxth	r7, r7
  if (x + w < 0 || h + y < 0)
 800b8d4:	42fe      	cmn	r6, r7
  cell_blit_bitmap_shadow(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 800b8d6:	440d      	add	r5, r1
  if (x + w < 0 || h + y < 0)
 800b8d8:	d447      	bmi.n	800b96a <cellPut+0xd2>
 800b8da:	f118 0f0b 	cmn.w	r8, #11
 800b8de:	db44      	blt.n	800b96a <cellPut+0xd2>
  dst[0] = dst[1] = 0;
 800b8e0:	2300      	movs	r3, #0
    p = (bmp[i] << 8) & mask; // extend from 8 bit width to 16 bit
 800b8e2:	469b      	mov	fp, r3
  dst[0] = dst[1] = 0;
 800b8e4:	9302      	str	r3, [sp, #8]
  uint16_t dst[16], mask = 0xFFFF << (16 - w), p;
 800b8e6:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 800b8ea:	f1c7 0310 	rsb	r3, r7, #16
 800b8ee:	4099      	lsls	r1, r3
    p = (bmp[i] << 8) & mask; // extend from 8 bit width to 16 bit
 800b8f0:	b209      	sxth	r1, r1
 800b8f2:	f105 3eff 	add.w	lr, r5, #4294967295
 800b8f6:	a802      	add	r0, sp, #8
 800b8f8:	f105 0a0a 	add.w	sl, r5, #10
 800b8fc:	465b      	mov	r3, fp
 800b8fe:	469c      	mov	ip, r3
 800b900:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
 800b904:	ea01 2303 	and.w	r3, r1, r3, lsl #8
    p |= (p >> 1) | (p >> 2); // shadow horizontally
 800b908:	465a      	mov	r2, fp
 800b90a:	ea4f 0b93 	mov.w	fp, r3, lsr #2
 800b90e:	ea4b 0b53 	orr.w	fp, fp, r3, lsr #1
 800b912:	ea43 030b 	orr.w	r3, r3, fp
    p = (p >> 8) | (p << 8);  // swap bytes (render do by 8 bit)
 800b916:	ba5b      	rev16	r3, r3
    dst[i + 2] = p;           // shadow vertically
 800b918:	8083      	strh	r3, [r0, #4]
    p = (p >> 8) | (p << 8);  // swap bytes (render do by 8 bit)
 800b91a:	b29b      	uxth	r3, r3
    dst[i + 1] |= dst[i + 2];
 800b91c:	ea43 0b0c 	orr.w	fp, r3, ip
    dst[i] |= dst[i + 1];
 800b920:	ea4b 0202 	orr.w	r2, fp, r2
  for (i = 0; i < h; i++)
 800b924:	45f2      	cmp	sl, lr
    dst[i + 1] |= dst[i + 2];
 800b926:	f8a0 b002 	strh.w	fp, [r0, #2]
    dst[i] |= dst[i + 1];
 800b92a:	f820 2b02 	strh.w	r2, [r0], #2
  for (i = 0; i < h; i++)
 800b92e:	d1e6      	bne.n	800b8fe <cellPut+0x66>
  pixel_t t = foreground_color;             // remember color
 800b930:	f8df a058 	ldr.w	sl, [pc, #88]	@ 800b98c <cellPut+0xf4>
  lcd_set_foreground(LCD_TXT_SHADOW_COLOR); // set shadow color
 800b934:	201a      	movs	r0, #26
  pixel_t t = foreground_color;             // remember color
 800b936:	f8ba b000 	ldrh.w	fp, [sl]
  lcd_set_foreground(LCD_TXT_SHADOW_COLOR); // set shadow color
 800b93a:	f005 fba5 	bl	8011088 <lcd_set_foreground>
  w += 2;
 800b93e:	f1c9 020a 	rsb	r2, r9, #10
  cell_blit_bitmap(x - 1, y - 1, w < 9 ? 9 : w, h, (uint8_t *)dst);
 800b942:	b292      	uxth	r2, r2
 800b944:	ab02      	add	r3, sp, #8
 800b946:	f108 31ff 	add.w	r1, r8, #4294967295
 800b94a:	1e70      	subs	r0, r6, #1
 800b94c:	2a09      	cmp	r2, #9
 800b94e:	9300      	str	r3, [sp, #0]
 800b950:	bf38      	it	cc
 800b952:	2209      	movcc	r2, #9
 800b954:	b209      	sxth	r1, r1
 800b956:	b200      	sxth	r0, r0
 800b958:	230d      	movs	r3, #13
 800b95a:	f7fe fdc9 	bl	800a4f0 <cell_blit_bitmap>
  cell_blit_bitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 800b95e:	f9b4 6004 	ldrsh.w	r6, [r4, #4]
 800b962:	f9b4 8006 	ldrsh.w	r8, [r4, #6]
  foreground_color = t; // restore color
 800b966:	f8aa b000 	strh.w	fp, [sl]
  cell_blit_bitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 800b96a:	4630      	mov	r0, r6
 800b96c:	463a      	mov	r2, r7
 800b96e:	9500      	str	r5, [sp, #0]
 800b970:	230b      	movs	r3, #11
 800b972:	4641      	mov	r1, r8
 800b974:	f7fe fdbc 	bl	800a4f0 <cell_blit_bitmap>
  ps->x += w;
 800b978:	88a3      	ldrh	r3, [r4, #4]
}
 800b97a:	2000      	movs	r0, #0
  ps->x += w;
 800b97c:	441f      	add	r7, r3
 800b97e:	80a7      	strh	r7, [r4, #4]
}
 800b980:	b00b      	add	sp, #44	@ 0x2c
 800b982:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800b986:	bf00      	nop
 800b988:	080154e0 	.word	0x080154e0
 800b98c:	20008a3a 	.word	0x20008a3a

0800b990 <conductance>:
  return get_s11_r(1.0f + v[0], v[1], 1.0f / PORT_Z);
 800b990:	edd1 7a00 	vldr	s15, [r1]
 800b994:	ed91 7a01 	vldr	s14, [r1, #4]
 800b998:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800b99c:	ee77 7aa6 	vadd.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800b9a0:	ee27 7a07 	vmul.f32	s14, s14, s14
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800b9a4:	eddf 6a07 	vldr	s13, [pc, #28]	@ 800b9c4 <conductance+0x34>
static float get_l(float re, float im) { return (re * re + im * im); }
 800b9a8:	eea7 7aa7 	vfma.f32	s14, s15, s15
static float get_s11_r(float re, float im, float z) { return vna_fabsf(2.0f * z * re / get_l(re, im) - z); }
 800b9ac:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800b9b0:	eddf 6a05 	vldr	s13, [pc, #20]	@ 800b9c8 <conductance+0x38>
 800b9b4:	ee87 0a87 	vdiv.f32	s0, s15, s14
 800b9b8:	ee30 0a66 	vsub.f32	s0, s0, s13
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800b9bc:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800b9c0:	4770      	bx	lr
 800b9c2:	bf00      	nop
 800b9c4:	3d23d70a 	.word	0x3d23d70a
 800b9c8:	3ca3d70a 	.word	0x3ca3d70a

0800b9cc <parallel_r>:
{
 800b9cc:	b508      	push	{r3, lr}
  return 1.0f / conductance(i, v);
 800b9ce:	f7ff ffdf 	bl	800b990 <conductance>
 800b9d2:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
}
 800b9d6:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800b9da:	bd08      	pop	{r3, pc}

0800b9dc <s21series_r>:
  return get_s21_r(v[0], v[1], 2.0f * PORT_Z);
 800b9dc:	edd1 7a01 	vldr	s15, [r1, #4]
 800b9e0:	ed91 7a00 	vldr	s14, [r1]
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800b9e4:	eddf 6a06 	vldr	s13, [pc, #24]	@ 800ba00 <s21series_r+0x24>
static float get_l(float re, float im) { return (re * re + im * im); }
 800b9e8:	ee67 7aa7 	vmul.f32	s15, s15, s15
 800b9ec:	eee7 7a07 	vfma.f32	s15, s14, s14
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800b9f0:	ee27 7a26 	vmul.f32	s14, s14, s13
 800b9f4:	ee87 0a27 	vdiv.f32	s0, s14, s15
}
 800b9f8:	ee30 0a66 	vsub.f32	s0, s0, s13
 800b9fc:	4770      	bx	lr
 800b9fe:	bf00      	nop
 800ba00:	42c80000 	.word	0x42c80000

0800ba04 <susceptance>:
  return get_s11_x(1.0f + v[0], v[1], 1.0f / PORT_Z);
 800ba04:	edd1 7a01 	vldr	s15, [r1, #4]
 800ba08:	ed91 7a00 	vldr	s14, [r1]
 800ba0c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800ba10:	ee37 7a26 	vadd.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800ba14:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800ba18:	eddf 6a04 	vldr	s13, [pc, #16]	@ 800ba2c <susceptance+0x28>
static float get_l(float re, float im) { return (re * re + im * im); }
 800ba1c:	eea7 0a07 	vfma.f32	s0, s14, s14
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800ba20:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
 800ba24:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ba28:	4770      	bx	lr
 800ba2a:	bf00      	nop
 800ba2c:	bd23d70a 	.word	0xbd23d70a

0800ba30 <parallel_x>:
{
 800ba30:	b508      	push	{r3, lr}
  return -1.0f / susceptance(i, v);
 800ba32:	f7ff ffe7 	bl	800ba04 <susceptance>
 800ba36:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
}
 800ba3a:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ba3e:	bd08      	pop	{r3, pc}

0800ba40 <parallel_l>:
{
 800ba40:	b508      	push	{r3, lr}
 800ba42:	ed2d 8b02 	vpush	{d8}
  const float xp = parallel_x(i, v);
 800ba46:	f7ff fff3 	bl	800ba30 <parallel_x>
 800ba4a:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800ba4e:	f7ff f829 	bl	800aaa4 <get_w>
}
 800ba52:	ee88 0a00 	vdiv.f32	s0, s16, s0
 800ba56:	ecbd 8b02 	vpop	{d8}
 800ba5a:	bd08      	pop	{r3, pc}

0800ba5c <parallel_c>:
{
 800ba5c:	b508      	push	{r3, lr}
 800ba5e:	ed2d 8b02 	vpush	{d8}
  const float yi = susceptance(i, v);
 800ba62:	f7ff ffcf 	bl	800ba04 <susceptance>
 800ba66:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800ba6a:	f7ff f81b 	bl	800aaa4 <get_w>
}
 800ba6e:	ee88 0a00 	vdiv.f32	s0, s16, s0
 800ba72:	ecbd 8b02 	vpop	{d8}
 800ba76:	bd08      	pop	{r3, pc}

0800ba78 <s21series_x>:
  return get_s21_x(v[0], v[1], 2.0f * PORT_Z);
 800ba78:	edd1 7a01 	vldr	s15, [r1, #4]
 800ba7c:	ed91 7a00 	vldr	s14, [r1]
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800ba80:	eddf 6a05 	vldr	s13, [pc, #20]	@ 800ba98 <s21series_x+0x20>
static float get_l(float re, float im) { return (re * re + im * im); }
 800ba84:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800ba88:	ee67 7aa6 	vmul.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800ba8c:	eea7 0a07 	vfma.f32	s0, s14, s14
}
 800ba90:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800ba94:	4770      	bx	lr
 800ba96:	bf00      	nop
 800ba98:	c2c80000 	.word	0xc2c80000

0800ba9c <logmag>:
  return vna_log10f_x_10(get_l(v[0], v[1]));
 800ba9c:	ed91 0a01 	vldr	s0, [r1, #4]
 800baa0:	edd1 7a00 	vldr	s15, [r1]
static float get_l(float re, float im) { return (re * re + im * im); }
 800baa4:	ee20 0a00 	vmul.f32	s0, s0, s0
  return vna_log10f_x_10(get_l(v[0], v[1]));
 800baa8:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800baac:	f006 bc46 	b.w	801233c <vna_log10f_x_10>

0800bab0 <s11loss>:
  return -0.5f * logmag(i, measured[0][i]);
 800bab0:	4905      	ldr	r1, [pc, #20]	@ (800bac8 <s11loss+0x18>)
static float s11loss(uint16_t i) {
 800bab2:	b508      	push	{r3, lr}
  return -0.5f * logmag(i, measured[0][i]);
 800bab4:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800bab8:	f7ff fff0 	bl	800ba9c <logmag>
}
 800babc:	eefe 7a00 	vmov.f32	s15, #224	@ 0xbf000000 -0.5
 800bac0:	ee20 0a27 	vmul.f32	s0, s0, s15
 800bac4:	bd08      	pop	{r3, pc}
 800bac6:	bf00      	nop
 800bac8:	20004f54 	.word	0x20004f54

0800bacc <s21logmag>:
  return logmag(i, measured[1][i]);
 800bacc:	4903      	ldr	r1, [pc, #12]	@ (800badc <s21logmag+0x10>)
 800bace:	f200 1391 	addw	r3, r0, #401	@ 0x191
 800bad2:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 800bad6:	f7ff bfe1 	b.w	800ba9c <logmag>
 800bada:	bf00      	nop
 800badc:	20004f54 	.word	0x20004f54

0800bae0 <phase_z>:
  const float r = 1.0f - get_l(v[0], v[1]);
 800bae0:	edd1 7a00 	vldr	s15, [r1]
 800bae4:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 800bae8:	eee7 0ae7 	vfms.f32	s1, s15, s15
{
 800baec:	b508      	push	{r3, lr}
  const float r = 1.0f - get_l(v[0], v[1]);
 800baee:	edd1 7a01 	vldr	s15, [r1, #4]
  return (180.0f / VNA_PI) * vna_atan2f(x, r);
 800baf2:	eee7 0ae7 	vfms.f32	s1, s15, s15
 800baf6:	ee37 0aa7 	vadd.f32	s0, s15, s15
 800bafa:	f006 fc53 	bl	80123a4 <vna_atan2f>
 800bafe:	eddf 7a02 	vldr	s15, [pc, #8]	@ 800bb08 <phase_z+0x28>
}
 800bb02:	ee20 0a27 	vmul.f32	s0, s0, s15
 800bb06:	bd08      	pop	{r3, pc}
 800bb08:	42652ee0 	.word	0x42652ee0

0800bb0c <s21_qualityfactor>:
  return vna_fabsf(v[1] / (v[0] - get_l(v[0], v[1])));
 800bb0c:	edd1 6a00 	vldr	s13, [r1]
 800bb10:	ed91 7a01 	vldr	s14, [r1, #4]
 800bb14:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800bb18:	ee77 7ae6 	vsub.f32	s15, s15, s13
 800bb1c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800bb20:	eee7 7a47 	vfms.f32	s15, s14, s14
 800bb24:	ee87 0a27 	vdiv.f32	s0, s14, s15
 800bb28:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800bb2c:	4770      	bx	lr
 800bb2e:	bf00      	nop

0800bb30 <s21series_z>:
  float l1 = get_l(v[0], v[1]);
 800bb30:	edd1 7a01 	vldr	s15, [r1, #4]
 800bb34:	edd1 6a00 	vldr	s13, [r1]
  return 2.0f * PORT_Z * vna_sqrtf(l2 / l1);
 800bb38:	ed9f 0a0a 	vldr	s0, [pc, #40]	@ 800bb64 <s21series_z+0x34>
static float get_l(float re, float im) { return (re * re + im * im); }
 800bb3c:	ee67 7aa7 	vmul.f32	s15, s15, s15
  float l2 = get_l(1.0f - v[0], v[1]);
 800bb40:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800bb44:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800bb48:	eeb0 6a67 	vmov.f32	s12, s15
 800bb4c:	eea6 6aa6 	vfma.f32	s12, s13, s13
 800bb50:	eee7 7a07 	vfma.f32	s15, s14, s14
  return 2.0f * PORT_Z * vna_sqrtf(l2 / l1);
 800bb54:	ee87 7a86 	vdiv.f32	s14, s15, s12
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800bb58:	eeb1 7ac7 	vsqrt.f32	s14, s14
}
 800bb5c:	ee27 0a00 	vmul.f32	s0, s14, s0
 800bb60:	4770      	bx	lr
 800bb62:	bf00      	nop
 800bb64:	42c80000 	.word	0x42c80000

0800bb68 <s21shunt_z>:
  float l1 = get_l(v[0], v[1]);
 800bb68:	edd1 7a01 	vldr	s15, [r1, #4]
 800bb6c:	edd1 6a00 	vldr	s13, [r1]
static float get_l(float re, float im) { return (re * re + im * im); }
 800bb70:	ee67 7aa7 	vmul.f32	s15, s15, s15
  float l2 = get_l(1.0f - v[0], v[1]);
 800bb74:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800bb78:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800bb7c:	eeb0 6a67 	vmov.f32	s12, s15
 800bb80:	eea6 6aa6 	vfma.f32	s12, s13, s13
 800bb84:	eee7 7a07 	vfma.f32	s15, s14, s14
  return 0.5f * PORT_Z * vna_sqrtf(l1 / l2);
 800bb88:	eeb3 0a09 	vmov.f32	s0, #57	@ 0x41c80000  25.0
 800bb8c:	ee86 7a27 	vdiv.f32	s14, s12, s15
 800bb90:	eeb1 7ac7 	vsqrt.f32	s14, s14
}
 800bb94:	ee27 0a00 	vmul.f32	s0, s14, s0
 800bb98:	4770      	bx	lr
 800bb9a:	bf00      	nop

0800bb9c <qualityfactor>:
  const float r = 1.0f - get_l(v[0], v[1]);
 800bb9c:	ed91 7a00 	vldr	s14, [r1]
 800bba0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800bba4:	eee7 7a47 	vfms.f32	s15, s14, s14
 800bba8:	ed91 7a01 	vldr	s14, [r1, #4]
 800bbac:	eee7 7a47 	vfms.f32	s15, s14, s14
  const float x = 2.0f * v[1];
 800bbb0:	ee77 6a07 	vadd.f32	s13, s14, s14
  return vna_fabsf(x / r);
 800bbb4:	ee86 0aa7 	vdiv.f32	s0, s13, s15
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800bbb8:	eeb0 0ac0 	vabs.f32	s0, s0
}
 800bbbc:	4770      	bx	lr
 800bbbe:	bf00      	nop

0800bbc0 <mod_z>:
  return z0 * vna_sqrtf(get_l(1.0f + v[0], v[1]) / get_l(1.0f - v[0], v[1])); // always >= 0
 800bbc0:	edd1 7a01 	vldr	s15, [r1, #4]
 800bbc4:	ed91 6a00 	vldr	s12, [r1]
 800bbc8:	ed9f 0a0b 	vldr	s0, [pc, #44]	@ 800bbf8 <mod_z+0x38>
static float get_l(float re, float im) { return (re * re + im * im); }
 800bbcc:	ee67 7aa7 	vmul.f32	s15, s15, s15
  return z0 * vna_sqrtf(get_l(1.0f + v[0], v[1]) / get_l(1.0f - v[0], v[1])); // always >= 0
 800bbd0:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800bbd4:	ee76 6a07 	vadd.f32	s13, s12, s14
 800bbd8:	ee37 7a46 	vsub.f32	s14, s14, s12
static float get_l(float re, float im) { return (re * re + im * im); }
 800bbdc:	eeb0 6a67 	vmov.f32	s12, s15
 800bbe0:	eea6 6aa6 	vfma.f32	s12, s13, s13
 800bbe4:	eee7 7a07 	vfma.f32	s15, s14, s14
  return z0 * vna_sqrtf(get_l(1.0f + v[0], v[1]) / get_l(1.0f - v[0], v[1])); // always >= 0
 800bbe8:	ee86 7a27 	vdiv.f32	s14, s12, s15
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800bbec:	eeb1 7ac7 	vsqrt.f32	s14, s14
}
 800bbf0:	ee27 0a00 	vmul.f32	s0, s14, s0
 800bbf4:	4770      	bx	lr
 800bbf6:	bf00      	nop
 800bbf8:	42480000 	.word	0x42480000

0800bbfc <mod_y>:
{
 800bbfc:	b508      	push	{r3, lr}
  return 1.0f / mod_z(i, v); // always >= 0
 800bbfe:	f7ff ffdf 	bl	800bbc0 <mod_z>
 800bc02:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
}
 800bc06:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800bc0a:	bd08      	pop	{r3, pc}

0800bc0c <linear>:
  return vna_sqrtf(get_l(v[0], v[1]));
 800bc0c:	ed91 0a01 	vldr	s0, [r1, #4]
 800bc10:	edd1 7a00 	vldr	s15, [r1]
static float get_l(float re, float im) { return (re * re + im * im); }
 800bc14:	ee20 0a00 	vmul.f32	s0, s0, s0
 800bc18:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800bc1c:	eeb1 0ac0 	vsqrt.f32	s0, s0
}
 800bc20:	4770      	bx	lr
 800bc22:	bf00      	nop

0800bc24 <swr>:
{
 800bc24:	b508      	push	{r3, lr}
  float x = linear(i, v);
 800bc26:	f7ff fff1 	bl	800bc0c <linear>
  if (x > 0.99f)
 800bc2a:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 800bc54 <swr+0x30>
 800bc2e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bc32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bc36:	dc08      	bgt.n	800bc4a <swr+0x26>
  return (1.0f + x) / (1.0f - x);
 800bc38:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800bc3c:	ee30 7a27 	vadd.f32	s14, s0, s15
 800bc40:	ee37 0ac0 	vsub.f32	s0, s15, s0
}
 800bc44:	ee87 0a00 	vdiv.f32	s0, s14, s0
 800bc48:	bd08      	pop	{r3, pc}
 800bc4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return infinityf();
 800bc4e:	f006 bc2d 	b.w	80124ac <infinityf>
 800bc52:	bf00      	nop
 800bc54:	3f7d70a4 	.word	0x3f7d70a4

0800bc58 <s21shunt_x>:
  return get_s21_x(1.0f - v[0], -v[1], 0.5f * PORT_Z);
 800bc58:	edd1 7a01 	vldr	s15, [r1, #4]
 800bc5c:	edd1 6a00 	vldr	s13, [r1]
 800bc60:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800bc64:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800bc68:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800bc6c:	eef3 6a09 	vmov.f32	s13, #57	@ 0x41c80000  25.0
static float get_l(float re, float im) { return (re * re + im * im); }
 800bc70:	eea7 0a07 	vfma.f32	s0, s14, s14
static float get_s21_x(float re, float im, float z) { return -1.0f * z * im / get_l(re, im); }
 800bc74:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
 800bc78:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800bc7c:	4770      	bx	lr
 800bc7e:	bf00      	nop

0800bc80 <reactance>:
  return get_s11_x(1.0f - v[0], -v[1], PORT_Z);
 800bc80:	edd1 7a01 	vldr	s15, [r1, #4]
 800bc84:	edd1 6a00 	vldr	s13, [r1]
 800bc88:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800bc8c:	ee37 7a66 	vsub.f32	s14, s14, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800bc90:	ee27 0aa7 	vmul.f32	s0, s15, s15
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800bc94:	eddf 6a04 	vldr	s13, [pc, #16]	@ 800bca8 <reactance+0x28>
static float get_l(float re, float im) { return (re * re + im * im); }
 800bc98:	eea7 0a07 	vfma.f32	s0, s14, s14
static float get_s11_x(float re, float im, float z) { return -2.0f * z * im / get_l(re, im); }
 800bc9c:	ee67 7aa6 	vmul.f32	s15, s15, s13
}
 800bca0:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800bca4:	4770      	bx	lr
 800bca6:	bf00      	nop
 800bca8:	42c80000 	.word	0x42c80000

0800bcac <s11_resonance_min>:
  return fabsf(reactance(i, measured[0][i]));
 800bcac:	4904      	ldr	r1, [pc, #16]	@ (800bcc0 <s11_resonance_min+0x14>)
static float s11_resonance_min(uint16_t i) {
 800bcae:	b508      	push	{r3, lr}
  return fabsf(reactance(i, measured[0][i]));
 800bcb0:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800bcb4:	f7ff ffe4 	bl	800bc80 <reactance>
}
 800bcb8:	eeb0 0ac0 	vabs.f32	s0, s0
 800bcbc:	bd08      	pop	{r3, pc}
 800bcbe:	bf00      	nop
 800bcc0:	20004f54 	.word	0x20004f54

0800bcc4 <series_l>:
{
 800bcc4:	b508      	push	{r3, lr}
 800bcc6:	ed2d 8b02 	vpush	{d8}
  const float zi = reactance(i, v);
 800bcca:	f7ff ffd9 	bl	800bc80 <reactance>
 800bcce:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800bcd2:	f7fe fee7 	bl	800aaa4 <get_w>
}
 800bcd6:	ee88 0a00 	vdiv.f32	s0, s16, s0
 800bcda:	ecbd 8b02 	vpop	{d8}
 800bcde:	bd08      	pop	{r3, pc}

0800bce0 <series_c>:
{
 800bce0:	b508      	push	{r3, lr}
 800bce2:	ed2d 8b02 	vpush	{d8}
  const float zi = reactance(i, v);
 800bce6:	f7ff ffcb 	bl	800bc80 <reactance>
 800bcea:	eeb0 8a40 	vmov.f32	s16, s0
  const float w = get_w(i);
 800bcee:	f7fe fed9 	bl	800aaa4 <get_w>
  return -1.0f / (w * zi);
 800bcf2:	ee28 0a00 	vmul.f32	s0, s16, s0
}
 800bcf6:	ecbd 8b02 	vpop	{d8}
  return -1.0f / (w * zi);
 800bcfa:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
}
 800bcfe:	ee87 0a80 	vdiv.f32	s0, s15, s0
 800bd02:	bd08      	pop	{r3, pc}

0800bd04 <prepare_lc_match>:
static void prepare_lc_match(uint8_t mode, uint8_t update_mask) {
 800bd04:	b530      	push	{r4, r5, lr}
 800bd06:	ed2d 8b04 	vpush	{d8-d9}
  freq_t freq = get_marker_frequency(active_marker);
 800bd0a:	4d75      	ldr	r5, [pc, #468]	@ (800bee0 <prepare_lc_match+0x1dc>)
static void prepare_lc_match(uint8_t mode, uint8_t update_mask) {
 800bd0c:	b083      	sub	sp, #12
  freq_t freq = get_marker_frequency(active_marker);
 800bd0e:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800bd12:	f7fb fed5 	bl	8007ac0 <get_marker_frequency>
  if (freq == 0)// || lc_match_array->Hz == freq)
 800bd16:	2800      	cmp	r0, #0
 800bd18:	f000 80de 	beq.w	800bed8 <prepare_lc_match+0x1d4>
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800bd1c:	f995 301d 	ldrsb.w	r3, [r5, #29]
  lc_match_array->R0 = PORT_Z; // 50.0f
 800bd20:	4c70      	ldr	r4, [pc, #448]	@ (800bee4 <prepare_lc_match+0x1e0>)
  const float RL = resistance(index, coeff);
 800bd22:	4971      	ldr	r1, [pc, #452]	@ (800bee8 <prepare_lc_match+0x1e4>)
  lc_match_array->Hz = freq;
 800bd24:	6020      	str	r0, [r4, #0]
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800bd26:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
  lc_match_array->R0 = PORT_Z; // 50.0f
 800bd2a:	ed9f 9a70 	vldr	s18, [pc, #448]	@ 800beec <prepare_lc_match+0x1e8>
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800bd2e:	f8b5 005a 	ldrh.w	r0, [r5, #90]	@ 0x5a
  lc_match_array->R0 = PORT_Z; // 50.0f
 800bd32:	ed84 9a01 	vstr	s18, [r4, #4]
  const float RL = resistance(index, coeff);
 800bd36:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 800bd3a:	f7fe fcd9 	bl	800a6f0 <resistance>
 800bd3e:	eef0 8a40 	vmov.f32	s17, s0
  const float XL = reactance(index, coeff);
 800bd42:	f7ff ff9d 	bl	800bc80 <reactance>
  if (RL <= 0.5f)
 800bd46:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 800bd4a:	eef4 8ae7 	vcmpe.f32	s17, s15
 800bd4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  const float XL = reactance(index, coeff);
 800bd52:	eeb0 8a40 	vmov.f32	s16, s0
  if (RL <= 0.5f)
 800bd56:	f240 80ad 	bls.w	800beb4 <prepare_lc_match+0x1b0>
  const float vswr = swr(index, coeff);
 800bd5a:	f7ff ff63 	bl	800bc24 <swr>
  if (vswr <= 1.1f || q_factor >= 100.0f)
 800bd5e:	eddf 7a64 	vldr	s15, [pc, #400]	@ 800bef0 <prepare_lc_match+0x1ec>
 800bd62:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800bd66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd6a:	f240 80a6 	bls.w	800beba <prepare_lc_match+0x1b6>
  const float q_factor = XL / RL;
 800bd6e:	eec8 7a28 	vdiv.f32	s15, s16, s17
  if (vswr <= 1.1f || q_factor >= 100.0f)
 800bd72:	eddf 0a60 	vldr	s1, [pc, #384]	@ 800bef4 <prepare_lc_match+0x1f0>
 800bd76:	eef4 7ae0 	vcmpe.f32	s15, s1
 800bd7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd7e:	f280 809c 	bge.w	800beba <prepare_lc_match+0x1b6>
  if ((RL * 1.1f) > R0 && RL < (R0 * 1.1f)) {
 800bd82:	eddf 7a5d 	vldr	s15, [pc, #372]	@ 800bef8 <prepare_lc_match+0x1f4>
 800bd86:	eef4 8ae7 	vcmpe.f32	s17, s15
 800bd8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd8e:	f04f 0500 	mov.w	r5, #0
 800bd92:	dd0e      	ble.n	800bdb2 <prepare_lc_match+0xae>
 800bd94:	eddf 7a59 	vldr	s15, [pc, #356]	@ 800befc <prepare_lc_match+0x1f8>
 800bd98:	eef4 8ae7 	vcmpe.f32	s17, s15
 800bd9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bda0:	d512      	bpl.n	800bdc8 <prepare_lc_match+0xc4>
    matches[0].xs  = -XL;
 800bda2:	eeb1 8a48 	vneg.f32	s16, s16
    matches[0].xpl = 0.0f;
 800bda6:	6125      	str	r5, [r4, #16]
    matches[0].xps = 0.0f;
 800bda8:	60a5      	str	r5, [r4, #8]
    matches[0].xs  = -XL;
 800bdaa:	ed84 8a03 	vstr	s16, [r4, #12]
    return 1;
 800bdae:	2301      	movs	r3, #1
 800bdb0:	e086      	b.n	800bec0 <prepare_lc_match+0x1bc>
  if (RL >= R0 || RL * RL + XL * XL > R0 * RL) {
 800bdb2:	ee68 6a08 	vmul.f32	s13, s16, s16
 800bdb6:	ee68 7a89 	vmul.f32	s15, s17, s18
 800bdba:	eee8 6aa8 	vfma.f32	s13, s17, s17
 800bdbe:	eef4 6ae7 	vcmpe.f32	s13, s15
 800bdc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bdc6:	dd3d      	ble.n	800be44 <prepare_lc_match+0x140>
  const float c = R0 * (XL * XL + RL * RL);
 800bdc8:	ee28 6aa8 	vmul.f32	s12, s17, s17
  match_quadratic_equation(a, b, c, xp);
 800bdcc:	ee68 0a20 	vmul.f32	s1, s16, s1
  const float c = R0 * (XL * XL + RL * RL);
 800bdd0:	eef0 6a46 	vmov.f32	s13, s12
 800bdd4:	eee8 6a08 	vfma.f32	s13, s16, s16
  match_quadratic_equation(a, b, c, xp);
 800bdd8:	4668      	mov	r0, sp
 800bdda:	ee39 0a68 	vsub.f32	s0, s18, s17
 800bdde:	ee26 1a89 	vmul.f32	s2, s13, s18
 800bde2:	f7fe fcdb 	bl	800a79c <match_quadratic_equation>
  const float XL1 = XL + xp[0];
 800bde6:	eddd 7a00 	vldr	s15, [sp]
  matches[0].xps = 0.0f;
 800bdea:	60a5      	str	r5, [r4, #8]
  const float XL1 = XL + xp[0];
 800bdec:	ee38 7a27 	vadd.f32	s14, s16, s15
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800bdf0:	eeb0 5a46 	vmov.f32	s10, s12
 800bdf4:	ee67 5aa7 	vmul.f32	s11, s15, s15
 800bdf8:	eea7 5a07 	vfma.f32	s10, s14, s14
  matches[1].xps = 0.0f;
 800bdfc:	6165      	str	r5, [r4, #20]
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800bdfe:	ee65 5a87 	vmul.f32	s11, s11, s14
  matches[0].xpl = xp[0];
 800be02:	edc4 7a04 	vstr	s15, [r4, #16]
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800be06:	ee85 7a85 	vdiv.f32	s14, s11, s10
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800be0a:	eef4 8ac9 	vcmpe.f32	s17, s18
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800be0e:	ee37 7a67 	vsub.f32	s14, s14, s15
  const float XL2 = XL + xp[1];
 800be12:	eddd 7a01 	vldr	s15, [sp, #4]
  matches[0].xs  = xp[0] * xp[0] * XL1 / (RL * RL + XL1 * XL1) - xp[0];
 800be16:	ed84 7a03 	vstr	s14, [r4, #12]
  const float XL2 = XL + xp[1];
 800be1a:	ee38 7a27 	vadd.f32	s14, s16, s15
  matches[1].xs  = xp[1] * xp[1] * XL2 / (RL * RL + XL2 * XL2) - xp[1];
 800be1e:	ee67 5aa7 	vmul.f32	s11, s15, s15
 800be22:	eea7 6a07 	vfma.f32	s12, s14, s14
 800be26:	ee65 5a87 	vmul.f32	s11, s11, s14
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800be2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  matches[1].xs  = xp[1] * xp[1] * XL2 / (RL * RL + XL2 * XL2) - xp[1];
 800be2e:	ee85 7a86 	vdiv.f32	s14, s11, s12
  matches[1].xpl = xp[1];
 800be32:	edc4 7a07 	vstr	s15, [r4, #28]
  matches[1].xs  = xp[1] * xp[1] * XL2 / (RL * RL + XL2 * XL2) - xp[1];
 800be36:	ee37 7a67 	vsub.f32	s14, s14, s15
 800be3a:	ed84 7a06 	vstr	s14, [r4, #24]
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800be3e:	da3e      	bge.n	800bebe <prepare_lc_match+0x1ba>
    n = 2;
 800be40:	2202      	movs	r2, #2
 800be42:	e000      	b.n	800be46 <prepare_lc_match+0x142>
  int16_t n = 0;
 800be44:	2200      	movs	r2, #0
  match_quadratic_equation(a, b, c, xs);
 800be46:	eee8 6ac9 	vfms.f32	s13, s17, s18
  lc_match_calc_lo(R0, RL, XL, &matches[n]);   // Compute Lo-Z solutions
 800be4a:	492d      	ldr	r1, [pc, #180]	@ (800bf00 <prepare_lc_match+0x1fc>)
 800be4c:	230c      	movs	r3, #12
  match_quadratic_equation(a, b, c, xs);
 800be4e:	ee78 0a08 	vadd.f32	s1, s16, s16
 800be52:	eeb0 1a66 	vmov.f32	s2, s13
 800be56:	4668      	mov	r0, sp
 800be58:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
  lc_match_calc_lo(R0, RL, XL, &matches[n]);   // Compute Lo-Z solutions
 800be5c:	fb03 1102 	mla	r1, r3, r2, r1
  match_quadratic_equation(a, b, c, xs);
 800be60:	f7fe fc9c 	bl	800a79c <match_quadratic_equation>
  const float XL1 = XL + xs[0];
 800be64:	ed9d 7a00 	vldr	s14, [sp]
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800be68:	eddf 6a26 	vldr	s13, [pc, #152]	@ 800bf04 <prepare_lc_match+0x200>
  matches[0].xs  = xs[0];
 800be6c:	ed81 7a01 	vstr	s14, [r1, #4]
  const float XL1 = XL + xs[0];
 800be70:	ee78 7a07 	vadd.f32	s15, s16, s14
  const float RL1 = RL - R0;
 800be74:	ee78 8ac9 	vsub.f32	s17, s17, s18
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800be78:	ee27 7aa7 	vmul.f32	s14, s15, s15
 800be7c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800be80:	eea8 7aa8 	vfma.f32	s14, s17, s17
  matches[0].xpl = 0.0f;
 800be84:	608d      	str	r5, [r1, #8]
  matches[1].xpl = 0.0f;
 800be86:	614d      	str	r5, [r1, #20]
  return n + 2;
 800be88:	1c93      	adds	r3, r2, #2
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800be8a:	ee87 6a87 	vdiv.f32	s12, s15, s14
  const float XL2 = XL + xs[1];
 800be8e:	eddd 7a01 	vldr	s15, [sp, #4]
  matches[0].xps = - R0 * R0 * XL1 / (RL1 * RL1 + XL1 * XL1);
 800be92:	ed81 6a00 	vstr	s12, [r1]
  const float XL2 = XL + xs[1];
 800be96:	ee38 8a27 	vadd.f32	s16, s16, s15
  matches[1].xs  = xs[1];
 800be9a:	edc1 7a04 	vstr	s15, [r1, #16]
  matches[1].xps = - R0 * R0 * XL2 / (RL1 * RL1 + XL2 * XL2);
 800be9e:	ee68 7a08 	vmul.f32	s15, s16, s16
 800bea2:	ee28 8a26 	vmul.f32	s16, s16, s13
 800bea6:	eee8 7aa8 	vfma.f32	s15, s17, s17
 800beaa:	ee88 7a27 	vdiv.f32	s14, s16, s15
 800beae:	ed81 7a03 	vstr	s14, [r1, #12]
  return n + 2;
 800beb2:	e005      	b.n	800bec0 <prepare_lc_match+0x1bc>
    return -1;
 800beb4:	f04f 33ff 	mov.w	r3, #4294967295
 800beb8:	e002      	b.n	800bec0 <prepare_lc_match+0x1bc>
    return 0;
 800beba:	2300      	movs	r3, #0
 800bebc:	e000      	b.n	800bec0 <prepare_lc_match+0x1bc>
    if (RL >= R0) return 2;                    // Only Hi-Z solution present
 800bebe:	2302      	movs	r3, #2
  lc_match_array->num_matches = lc_match_calc(markers[active_marker].index);
 800bec0:	8723      	strh	r3, [r4, #56]	@ 0x38
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800bec2:	2207      	movs	r2, #7
 800bec4:	2304      	movs	r3, #4
 800bec6:	2102      	movs	r1, #2
 800bec8:	2000      	movs	r0, #0
}
 800beca:	b003      	add	sp, #12
 800becc:	ecbd 8b04 	vpop	{d8-d9}
 800bed0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800bed4:	f7fe bbe4 	b.w	800a6a0 <invalidate_rect_func>
}
 800bed8:	b003      	add	sp, #12
 800beda:	ecbd 8b04 	vpop	{d8-d9}
 800bede:	bd30      	pop	{r4, r5, pc}
 800bee0:	20000aa8 	.word	0x20000aa8
 800bee4:	200069fc 	.word	0x200069fc
 800bee8:	20004f54 	.word	0x20004f54
 800beec:	42480000 	.word	0x42480000
 800bef0:	3f8ccccd 	.word	0x3f8ccccd
 800bef4:	42c80000 	.word	0x42c80000
 800bef8:	4235d174 	.word	0x4235d174
 800befc:	425c0000 	.word	0x425c0000
 800bf00:	20006a04 	.word	0x20006a04
 800bf04:	c51c4000 	.word	0xc51c4000

0800bf08 <s21shunt_r>:
  return get_s21_r(1.0f - v[0], -v[1], 0.5f * PORT_Z);
 800bf08:	edd1 6a00 	vldr	s13, [r1]
 800bf0c:	ed91 7a01 	vldr	s14, [r1, #4]
 800bf10:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800bf14:	ee77 7ae6 	vsub.f32	s15, s15, s13
static float get_l(float re, float im) { return (re * re + im * im); }
 800bf18:	ee27 7a07 	vmul.f32	s14, s14, s14
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800bf1c:	eef3 6a09 	vmov.f32	s13, #57	@ 0x41c80000  25.0
static float get_l(float re, float im) { return (re * re + im * im); }
 800bf20:	eea7 7aa7 	vfma.f32	s14, s15, s15
static float get_s21_r(float re, float im, float z) { return 1.0f * z * re / get_l(re, im) - z; }
 800bf24:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800bf28:	ee87 0a87 	vdiv.f32	s0, s15, s14
}
 800bf2c:	ee30 0a66 	vsub.f32	s0, s0, s13
 800bf30:	4770      	bx	lr
 800bf32:	bf00      	nop

0800bf34 <s11_resonance_value>:
static float s11_resonance_value(uint16_t i) {
 800bf34:	4b02      	ldr	r3, [pc, #8]	@ (800bf40 <s11_resonance_value+0xc>)
 800bf36:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800bf3a:	ed93 0a01 	vldr	s0, [r3, #4]
 800bf3e:	4770      	bx	lr
 800bf40:	20004f54 	.word	0x20004f54

0800bf44 <measure_get_value.constprop.0>:
  if (f < frequency0 || f > frequency1)
 800bf44:	4b3e      	ldr	r3, [pc, #248]	@ (800c040 <measure_get_value.constprop.0+0xfc>)
static bool measure_get_value(uint16_t ch, freq_t f, float *data){
 800bf46:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (f < frequency0 || f > frequency1)
 800bf4a:	685a      	ldr	r2, [r3, #4]
 800bf4c:	4282      	cmp	r2, r0
 800bf4e:	d872      	bhi.n	800c036 <measure_get_value.constprop.0+0xf2>
 800bf50:	689d      	ldr	r5, [r3, #8]
 800bf52:	42a8      	cmp	r0, r5
 800bf54:	d86f      	bhi.n	800c036 <measure_get_value.constprop.0+0xf2>
  uint16_t _points = sweep_points - 1;
 800bf56:	8b5e      	ldrh	r6, [r3, #26]
 800bf58:	3e01      	subs	r6, #1
 800bf5a:	b2b6      	uxth	r6, r6
  uint32_t idx = (uint64_t)(f - frequency0) * (uint64_t)_points / span;
 800bf5c:	f04f 0b00 	mov.w	fp, #0
  freq_t span = frequency1 - frequency0;
 800bf60:	1aad      	subs	r5, r5, r2
  uint32_t idx = (uint64_t)(f - frequency0) * (uint64_t)_points / span;
 800bf62:	1a84      	subs	r4, r0, r2
 800bf64:	465b      	mov	r3, fp
 800bf66:	462a      	mov	r2, r5
 800bf68:	468a      	mov	sl, r1
 800bf6a:	fba4 0106 	umull	r0, r1, r4, r6
 800bf6e:	f7f4 fccd 	bl	800090c <__aeabi_uldivmod>
  uint64_t v = (uint64_t)span * idx + _points/2;
 800bf72:	ea4f 0856 	mov.w	r8, r6, lsr #1
 800bf76:	465b      	mov	r3, fp
 800bf78:	fbe5 8300 	umlal	r8, r3, r5, r0
 800bf7c:	9301      	str	r3, [sp, #4]
  freq_t src_f0 = frequency0 + (v       ) / _points;
 800bf7e:	4632      	mov	r2, r6
 800bf80:	465b      	mov	r3, fp
 800bf82:	9901      	ldr	r1, [sp, #4]
  uint32_t idx = (uint64_t)(f - frequency0) * (uint64_t)_points / span;
 800bf84:	4607      	mov	r7, r0
  freq_t src_f0 = frequency0 + (v       ) / _points;
 800bf86:	4640      	mov	r0, r8
 800bf88:	f7f4 fcc0 	bl	800090c <__aeabi_uldivmod>
  freq_t src_f1 = frequency0 + (v + span) / _points;
 800bf8c:	9901      	ldr	r1, [sp, #4]
  freq_t src_f0 = frequency0 + (v       ) / _points;
 800bf8e:	4681      	mov	r9, r0
  freq_t src_f1 = frequency0 + (v + span) / _points;
 800bf90:	eb15 0008 	adds.w	r0, r5, r8
 800bf94:	f141 0100 	adc.w	r1, r1, #0
 800bf98:	4632      	mov	r2, r6
 800bf9a:	465b      	mov	r3, fp
 800bf9c:	f7f4 fcb6 	bl	800090c <__aeabi_uldivmod>
  float k1 = (delta == 0) ? 0.0f : (float)(f - src_f0) / delta;
 800bfa0:	ebb0 0009 	subs.w	r0, r0, r9
 800bfa4:	d00c      	beq.n	800bfc0 <measure_get_value.constprop.0+0x7c>
 800bfa6:	eba4 0409 	sub.w	r4, r4, r9
 800bfaa:	ee07 4a90 	vmov	s15, r4
 800bfae:	ee07 0a10 	vmov	s14, r0
 800bfb2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800bfb6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 800bfba:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800bfbe:	e001      	b.n	800bfc4 <measure_get_value.constprop.0+0x80>
 800bfc0:	eddf 6a20 	vldr	s13, [pc, #128]	@ 800c044 <measure_get_value.constprop.0+0x100>
  data[0] = bilinear_interpolation(measured[ch][idx-1][0], measured[ch][idx  ][0], measured[ch][idx+1][0],k1);
 800bfc4:	4b20      	ldr	r3, [pc, #128]	@ (800c048 <measure_get_value.constprop.0+0x104>)
 800bfc6:	1e7a      	subs	r2, r7, #1
 800bfc8:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 800bfcc:	3701      	adds	r7, #1
 800bfce:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 800bfd2:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 800bfd6:	ed92 5a00 	vldr	s10, [r2]
 800bfda:	edd3 5a00 	vldr	s11, [r3]
 800bfde:	ed91 7a00 	vldr	s14, [r1]
  const float a = 0.5f * (y1 + y3) - y2;
 800bfe2:	ee75 4a25 	vadd.f32	s9, s10, s11
 800bfe6:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 800bfea:	eef0 7a47 	vmov.f32	s15, s14
 800bfee:	eed4 7a86 	vfnms.f32	s15, s9, s12
  return true;
 800bff2:	2001      	movs	r0, #1
  const float b = 0.5f * (y3 - y1);
 800bff4:	ee75 5ac5 	vsub.f32	s11, s11, s10
  return a * x * x + b * x + c;
 800bff8:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800bffc:	eee5 7a86 	vfma.f32	s15, s11, s12
 800c000:	eea6 7aa7 	vfma.f32	s14, s13, s15
  data[0] = bilinear_interpolation(measured[ch][idx-1][0], measured[ch][idx  ][0], measured[ch][idx+1][0],k1);
 800c004:	ed8a 7a00 	vstr	s14, [sl]
  data[1] = bilinear_interpolation(measured[ch][idx-1][1], measured[ch][idx  ][1], measured[ch][idx+1][1],k1);
 800c008:	ed92 5a01 	vldr	s10, [r2, #4]
 800c00c:	edd3 5a01 	vldr	s11, [r3, #4]
 800c010:	ed91 7a01 	vldr	s14, [r1, #4]
  const float a = 0.5f * (y1 + y3) - y2;
 800c014:	ee75 4a25 	vadd.f32	s9, s10, s11
 800c018:	eef0 7a47 	vmov.f32	s15, s14
 800c01c:	eed4 7a86 	vfnms.f32	s15, s9, s12
  const float b = 0.5f * (y3 - y1);
 800c020:	ee75 5ac5 	vsub.f32	s11, s11, s10
  return a * x * x + b * x + c;
 800c024:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800c028:	eee5 7a86 	vfma.f32	s15, s11, s12
 800c02c:	eea6 7aa7 	vfma.f32	s14, s13, s15
  data[1] = bilinear_interpolation(measured[ch][idx-1][1], measured[ch][idx  ][1], measured[ch][idx+1][1],k1);
 800c030:	ed8a 7a01 	vstr	s14, [sl, #4]
  return true;
 800c034:	e000      	b.n	800c038 <measure_get_value.constprop.0+0xf4>
    return false;
 800c036:	2000      	movs	r0, #0
}
 800c038:	b003      	add	sp, #12
 800c03a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c03e:	bf00      	nop
 800c040:	20000aa8 	.word	0x20000aa8
 800c044:	00000000 	.word	0x00000000
 800c048:	20004f54 	.word	0x20004f54

0800c04c <add_resonance_value>:

static bool add_resonance_value(int i, uint16_t x, freq_t f) {
 800c04c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c04e:	4604      	mov	r4, r0
 800c050:	460f      	mov	r7, r1
  float data[2];
  if (measure_get_value(0, f, data)) {
 800c052:	4610      	mov	r0, r2
 800c054:	4669      	mov	r1, sp
static bool add_resonance_value(int i, uint16_t x, freq_t f) {
 800c056:	4616      	mov	r6, r2
  if (measure_get_value(0, f, data)) {
 800c058:	f7ff ff74 	bl	800bf44 <measure_get_value.constprop.0>
 800c05c:	4605      	mov	r5, r0
 800c05e:	b170      	cbz	r0, 800c07e <add_resonance_value+0x32>
    s11_resonance->data[i].f = f;
 800c060:	230c      	movs	r3, #12
 800c062:	4908      	ldr	r1, [pc, #32]	@ (800c084 <add_resonance_value+0x38>)
 800c064:	4363      	muls	r3, r4
 800c066:	18ca      	adds	r2, r1, r3
 800c068:	50ce      	str	r6, [r1, r3]
    //set_marker_index(i, x);
    s11_resonance->data[i].r = resistance(x, data);
 800c06a:	4638      	mov	r0, r7
 800c06c:	4669      	mov	r1, sp
 800c06e:	f7fe fb3f 	bl	800a6f0 <resistance>
 800c072:	ed82 0a01 	vstr	s0, [r2, #4]
    s11_resonance->data[i].x = reactance(x, data);
 800c076:	f7ff fe03 	bl	800bc80 <reactance>
 800c07a:	ed82 0a02 	vstr	s0, [r2, #8]
    return true;
  }
  return false;
}
 800c07e:	4628      	mov	r0, r5
 800c080:	b003      	add	sp, #12
 800c082:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c084:	200069fc 	.word	0x200069fc

0800c088 <prepare_s11_resonance>:

static void prepare_s11_resonance(uint8_t type, uint8_t update_mask) {
 800c088:	b530      	push	{r4, r5, lr}
 800c08a:	ed2d 8b02 	vpush	{d8}
  (void)type;
  if (update_mask & MEASURE_UPD_SWEEP) {
 800c08e:	07cb      	lsls	r3, r1, #31
static void prepare_s11_resonance(uint8_t type, uint8_t update_mask) {
 800c090:	b083      	sub	sp, #12
  if (update_mask & MEASURE_UPD_SWEEP) {
 800c092:	d538      	bpl.n	800c106 <prepare_s11_resonance+0x7e>
    int i;
    freq_t f;
    uint16_t x = 0;
 800c094:	2400      	movs	r4, #0
    // Search resonances (X == 0)
    for (i = 0; i < MEASURE_RESONANCE_COUNT && i < MARKERS_MAX;) {
      f = measure_search_value(&x, 0.0f, s11_resonance_value, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800c096:	ed9f 8a21 	vldr	s16, [pc, #132]	@ 800c11c <prepare_s11_resonance+0x94>
    uint16_t x = 0;
 800c09a:	f8ad 4006 	strh.w	r4, [sp, #6]
      f = measure_search_value(&x, 0.0f, s11_resonance_value, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800c09e:	2201      	movs	r2, #1
 800c0a0:	491f      	ldr	r1, [pc, #124]	@ (800c120 <prepare_s11_resonance+0x98>)
 800c0a2:	f04f 33ff 	mov.w	r3, #4294967295
 800c0a6:	eeb0 0a48 	vmov.f32	s0, s16
 800c0aa:	f10d 0006 	add.w	r0, sp, #6
 800c0ae:	f7fe fd19 	bl	800aae4 <measure_search_value>
 800c0b2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800c0b6:	ee17 2a90 	vmov	r2, s15
      if (f == 0) break;
 800c0ba:	b162      	cbz	r2, 800c0d6 <prepare_s11_resonance+0x4e>
      if (add_resonance_value(i, x, f))
 800c0bc:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800c0c0:	4620      	mov	r0, r4
 800c0c2:	4629      	mov	r1, r5
 800c0c4:	f7ff ffc2 	bl	800c04c <add_resonance_value>
 800c0c8:	4404      	add	r4, r0
        i++;
      x++;
 800c0ca:	3501      	adds	r5, #1
    for (i = 0; i < MEASURE_RESONANCE_COUNT && i < MARKERS_MAX;) {
 800c0cc:	2c06      	cmp	r4, #6
      x++;
 800c0ce:	f8ad 5006 	strh.w	r5, [sp, #6]
    for (i = 0; i < MEASURE_RESONANCE_COUNT && i < MARKERS_MAX;) {
 800c0d2:	d1e4      	bne.n	800c09e <prepare_s11_resonance+0x16>
 800c0d4:	e014      	b.n	800c100 <prepare_s11_resonance+0x78>
    }
    if (i == 0) { // Search minimum position, if resonances not found
 800c0d6:	b99c      	cbnz	r4, 800c100 <prepare_s11_resonance+0x78>
      x = 0;
      search_peak_value(&x, s11_resonance_min, MEASURE_SEARCH_MIN);
 800c0d8:	4912      	ldr	r1, [pc, #72]	@ (800c124 <prepare_s11_resonance+0x9c>)
      x = 0;
 800c0da:	f8ad 4006 	strh.w	r4, [sp, #6]
      search_peak_value(&x, s11_resonance_min, MEASURE_SEARCH_MIN);
 800c0de:	4622      	mov	r2, r4
 800c0e0:	f10d 0006 	add.w	r0, sp, #6
 800c0e4:	f7ff fa88 	bl	800b5f8 <search_peak_value.constprop.0>
      if (x && add_resonance_value(0, x, getFrequency(x)))
 800c0e8:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800c0ec:	b145      	cbz	r5, 800c100 <prepare_s11_resonance+0x78>
 800c0ee:	4628      	mov	r0, r5
 800c0f0:	f7fa fd88 	bl	8006c04 <getFrequency>
 800c0f4:	4629      	mov	r1, r5
 800c0f6:	4602      	mov	r2, r0
 800c0f8:	4620      	mov	r0, r4
 800c0fa:	f7ff ffa7 	bl	800c04c <add_resonance_value>
 800c0fe:	4604      	mov	r4, r0
        i = 1;
    }
    s11_resonance->count = i;
 800c100:	4b09      	ldr	r3, [pc, #36]	@ (800c128 <prepare_s11_resonance+0xa0>)
 800c102:	f883 4048 	strb.w	r4, [r3, #72]	@ 0x48
  }
  // Prepare for update
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800c106:	2305      	movs	r3, #5
 800c108:	2207      	movs	r2, #7
 800c10a:	2102      	movs	r1, #2
 800c10c:	2000      	movs	r0, #0
                  STR_MEASURE_X + 3 * STR_MEASURE_WIDTH, STR_MEASURE_Y + (MEASURE_RESONANCE_COUNT + 1) * STR_MEASURE_HEIGHT);
}
 800c10e:	b003      	add	sp, #12
 800c110:	ecbd 8b02 	vpop	{d8}
 800c114:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800c118:	f7fe bac2 	b.w	800a6a0 <invalidate_rect_func>
 800c11c:	00000000 	.word	0x00000000
 800c120:	0800bf35 	.word	0x0800bf35
 800c124:	0800bcad 	.word	0x0800bcad
 800c128:	200069fc 	.word	0x200069fc

0800c12c <update_grid>:
{
 800c12c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (fspan == 0)
 800c12e:	1a0d      	subs	r5, r1, r0
 800c130:	d02b      	beq.n	800c18a <update_grid+0x5e>
  freq_t dgrid = 1000000000, grid; // Max grid step = pattern * 1GHz grid
 800c132:	4c1b      	ldr	r4, [pc, #108]	@ (800c1a0 <update_grid+0x74>)
  } while (dgrid /= 10);
 800c134:	4a1b      	ldr	r2, [pc, #108]	@ (800c1a4 <update_grid+0x78>)
 800c136:	f04f 0e0a 	mov.w	lr, #10
 800c13a:	e000      	b.n	800c13e <update_grid+0x12>
 800c13c:	4664      	mov	r4, ip
 800c13e:	fba2 3c04 	umull	r3, ip, r2, r4
    k = fspan / grid;
 800c142:	fbb5 f3f4 	udiv	r3, r5, r4
    if (k >= N * 5)
 800c146:	2b13      	cmp	r3, #19
  } while (dgrid /= 10);
 800c148:	ea4f 0cdc 	mov.w	ip, ip, lsr #3
    if (k >= N * 5)
 800c14c:	d822      	bhi.n	800c194 <update_grid+0x68>
    if (k >= N * 2)
 800c14e:	2b07      	cmp	r3, #7
 800c150:	d823      	bhi.n	800c19a <update_grid+0x6e>
    if (k >= N * 1)
 800c152:	2b03      	cmp	r3, #3
 800c154:	d802      	bhi.n	800c15c <update_grid+0x30>
  } while (dgrid /= 10);
 800c156:	f1be 0e01 	subs.w	lr, lr, #1
 800c15a:	d1ef      	bne.n	800c13c <update_grid+0x10>
  grid_offset = ((uint64_t)(fstart % grid) * (WIDTH << GRID_BITS)) / fspan;
 800c15c:	fbb0 f3f4 	udiv	r3, r0, r4
 800c160:	f24e 3680 	movw	r6, #58240	@ 0xe380
 800c164:	fb04 0013 	mls	r0, r4, r3, r0
 800c168:	462a      	mov	r2, r5
 800c16a:	2300      	movs	r3, #0
 800c16c:	fba0 0106 	umull	r0, r1, r0, r6
 800c170:	f7f4 fbcc 	bl	800090c <__aeabi_uldivmod>
 800c174:	4f0c      	ldr	r7, [pc, #48]	@ (800c1a8 <update_grid+0x7c>)
  grid_width = ((uint64_t)grid * (WIDTH << GRID_BITS)) / fspan;
 800c176:	462a      	mov	r2, r5
  grid_offset = ((uint64_t)(fstart % grid) * (WIDTH << GRID_BITS)) / fspan;
 800c178:	8038      	strh	r0, [r7, #0]
  grid_width = ((uint64_t)grid * (WIDTH << GRID_BITS)) / fspan;
 800c17a:	2300      	movs	r3, #0
 800c17c:	fba4 0106 	umull	r0, r1, r4, r6
 800c180:	f7f4 fbc4 	bl	800090c <__aeabi_uldivmod>
 800c184:	4c09      	ldr	r4, [pc, #36]	@ (800c1ac <update_grid+0x80>)
 800c186:	8020      	strh	r0, [r4, #0]
}
 800c188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    grid_offset = grid_width = 0;
 800c18a:	4a08      	ldr	r2, [pc, #32]	@ (800c1ac <update_grid+0x80>)
 800c18c:	4b06      	ldr	r3, [pc, #24]	@ (800c1a8 <update_grid+0x7c>)
 800c18e:	8015      	strh	r5, [r2, #0]
 800c190:	801d      	strh	r5, [r3, #0]
}
 800c192:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      grid *= 5;
 800c194:	eb04 0484 	add.w	r4, r4, r4, lsl #2
      break;
 800c198:	e7e0      	b.n	800c15c <update_grid+0x30>
      grid *= 2;
 800c19a:	0064      	lsls	r4, r4, #1
      break;
 800c19c:	e7de      	b.n	800c15c <update_grid+0x30>
 800c19e:	bf00      	nop
 800c1a0:	3b9aca00 	.word	0x3b9aca00
 800c1a4:	cccccccd 	.word	0xcccccccd
 800c1a8:	20006a80 	.word	0x20006a80
 800c1ac:	20006a7e 	.word	0x20006a7e

0800c1b0 <get_trace_typename>:
  if (t == TRC_SMITH && ADMIT_MARKER_VALUE(marker_smith_format))
 800c1b0:	2803      	cmp	r0, #3
 800c1b2:	d005      	beq.n	800c1c0 <get_trace_typename+0x10>
  return trace_info_list[t].name;
 800c1b4:	4b06      	ldr	r3, [pc, #24]	@ (800c1d0 <get_trace_typename+0x20>)
 800c1b6:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 800c1ba:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800c1be:	4770      	bx	lr
  if (t == TRC_SMITH && ADMIT_MARKER_VALUE(marker_smith_format))
 800c1c0:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 800c1c4:	410b      	asrs	r3, r1
 800c1c6:	07db      	lsls	r3, r3, #31
 800c1c8:	d5f4      	bpl.n	800c1b4 <get_trace_typename+0x4>
    return "ADMIT";
 800c1ca:	4802      	ldr	r0, [pc, #8]	@ (800c1d4 <get_trace_typename+0x24>)
}
 800c1cc:	4770      	bx	lr
 800c1ce:	bf00      	nop
 800c1d0:	0801650c 	.word	0x0801650c
 800c1d4:	08013c40 	.word	0x08013c40

0800c1d8 <request_to_draw_marker>:
{
 800c1d8:	b570      	push	{r4, r5, r6, lr}
 800c1da:	4c15      	ldr	r4, [pc, #84]	@ (800c230 <request_to_draw_marker+0x58>)
 800c1dc:	4d15      	ldr	r5, [pc, #84]	@ (800c234 <request_to_draw_marker+0x5c>)
 800c1de:	f104 0630 	add.w	r6, r4, #48	@ 0x30
 800c1e2:	eb05 0580 	add.w	r5, r5, r0, lsl #2
    if (!trace[t].enabled)
 800c1e6:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 800c1ea:	b1db      	cbz	r3, 800c224 <request_to_draw_marker+0x4c>
    int y = index[mk_idx].y + ((index[mk_idx].y < MARKER_HEIGHT * 2) ? 1 : -Y_MARKER_OFFSET);
 800c1ec:	8869      	ldrh	r1, [r5, #2]
    int x = index[mk_idx].x - X_MARKER_OFFSET;
 800c1ee:	8828      	ldrh	r0, [r5, #0]
    int y = index[mk_idx].y + ((index[mk_idx].y < MARKER_HEIGHT * 2) ? 1 : -Y_MARKER_OFFSET);
 800c1f0:	291b      	cmp	r1, #27
 800c1f2:	bf8c      	ite	hi
 800c1f4:	f06f 030d 	mvnhi.w	r3, #13
 800c1f8:	2301      	movls	r3, #1
 800c1fa:	4419      	add	r1, r3
    invalidate_rect(x, y, x + MARKER_WIDTH - 1, y + MARKER_HEIGHT - 1);
 800c1fc:	f111 030d 	adds.w	r3, r1, #13
 800c200:	f100 0205 	add.w	r2, r0, #5
 800c204:	bf48      	it	mi
 800c206:	f101 032c 	addmi.w	r3, r1, #44	@ 0x2c
    int x = index[mk_idx].x - X_MARKER_OFFSET;
 800c20a:	3805      	subs	r0, #5
    invalidate_rect(x, y, x + MARKER_WIDTH - 1, y + MARKER_HEIGHT - 1);
 800c20c:	2900      	cmp	r1, #0
 800c20e:	bfb8      	it	lt
 800c210:	311f      	addlt	r1, #31
 800c212:	2800      	cmp	r0, #0
 800c214:	bfb8      	it	lt
 800c216:	301f      	addlt	r0, #31
 800c218:	1152      	asrs	r2, r2, #5
 800c21a:	115b      	asrs	r3, r3, #5
 800c21c:	1149      	asrs	r1, r1, #5
 800c21e:	1140      	asrs	r0, r0, #5
 800c220:	f7fe fa3e 	bl	800a6a0 <invalidate_rect_func>
  for (int t = 0; t < TRACES_MAX; t++)
 800c224:	340c      	adds	r4, #12
 800c226:	42a6      	cmp	r6, r4
 800c228:	f205 6544 	addw	r5, r5, #1604	@ 0x644
 800c22c:	d1db      	bne.n	800c1e6 <request_to_draw_marker+0xe>
}
 800c22e:	bd70      	pop	{r4, r5, r6, pc}
 800c230:	20000aa8 	.word	0x20000aa8
 800c234:	20006a84 	.word	0x20006a84

0800c238 <markmap_all_markers>:
{
 800c238:	b570      	push	{r4, r5, r6, lr}
 800c23a:	4c0b      	ldr	r4, [pc, #44]	@ (800c268 <markmap_all_markers+0x30>)
 800c23c:	f104 0540 	add.w	r5, r4, #64	@ 0x40
    if (!markers[i].enabled)
 800c240:	f894 3058 	ldrb.w	r3, [r4, #88]	@ 0x58
 800c244:	b11b      	cbz	r3, 800c24e <markmap_all_markers+0x16>
    request_to_draw_marker(markers[i].index);
 800c246:	f8b4 005a 	ldrh.w	r0, [r4, #90]	@ 0x5a
 800c24a:	f7ff ffc5 	bl	800c1d8 <request_to_draw_marker>
  for (i = 0; i < MARKERS_MAX; i++)
 800c24e:	3408      	adds	r4, #8
 800c250:	42ac      	cmp	r4, r5
 800c252:	d1f5      	bne.n	800c240 <markmap_all_markers+0x8>
  invalidate_rect(0, 0, AREA_WIDTH_NORMAL, marker_area_max());
 800c254:	f7ff f94c 	bl	800b4f0 <marker_area_max>
 800c258:	2100      	movs	r1, #0
 800c25a:	1143      	asrs	r3, r0, #5
}
 800c25c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  invalidate_rect(0, 0, AREA_WIDTH_NORMAL, marker_area_max());
 800c260:	220e      	movs	r2, #14
 800c262:	4608      	mov	r0, r1
 800c264:	f7fe ba1c 	b.w	800a6a0 <invalidate_rect_func>
 800c268:	20000aa8 	.word	0x20000aa8

0800c26c <prepare_series>:
static void prepare_series(uint8_t type, uint8_t update_mask) {
 800c26c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c270:	ed2d 8b02 	vpush	{d8}
  s21_measure->freq  = 0;
 800c274:	4c67      	ldr	r4, [pc, #412]	@ (800c414 <prepare_series+0x1a8>)
 800c276:	2500      	movs	r5, #0
  switch (type){
 800c278:	2803      	cmp	r0, #3
static void prepare_series(uint8_t type, uint8_t update_mask) {
 800c27a:	b082      	sub	sp, #8
  s21_measure->freq1 = 0;
 800c27c:	e9c4 5501 	strd	r5, r5, [r4, #4]
  switch (type){
 800c280:	f000 8082 	beq.w	800c388 <prepare_series+0x11c>
 800c284:	2804      	cmp	r0, #4
 800c286:	4606      	mov	r6, r0
 800c288:	f000 8081 	beq.w	800c38e <prepare_series+0x122>
 800c28c:	2802      	cmp	r0, #2
 800c28e:	f040 80bb 	bne.w	800c408 <prepare_series+0x19c>
  s21_measure->r = config._measure_r * att / (2.0f * (1.0f - att));
 800c292:	f8df 8198 	ldr.w	r8, [pc, #408]	@ 800c42c <prepare_series+0x1c0>
  s21_measure->header = "LC-SHUNT";
 800c296:	4b60      	ldr	r3, [pc, #384]	@ (800c418 <prepare_series+0x1ac>)
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800c298:	4960      	ldr	r1, [pc, #384]	@ (800c41c <prepare_series+0x1b0>)
  uint16_t xp = 0, x2;
 800c29a:	f8ad 5004 	strh.w	r5, [sp, #4]
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800c29e:	462a      	mov	r2, r5
 800c2a0:	a801      	add	r0, sp, #4
  s21_measure->header = "LC-SHUNT";
 800c2a2:	6023      	str	r3, [r4, #0]
  float ypeak = search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800c2a4:	f7ff f9a8 	bl	800b5f8 <search_peak_value.constprop.0>
 800c2a8:	eeb1 0ac0 	vsqrt.f32	s0, s0
  s21_measure->r = config._measure_r * att / (2.0f * (1.0f - att));
 800c2ac:	edd8 7a1a 	vldr	s15, [r8, #104]	@ 0x68
 800c2b0:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 800c2b4:	ee67 7a87 	vmul.f32	s15, s15, s14
 800c2b8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800c2bc:	ee67 7a80 	vmul.f32	s15, s15, s0
 800c2c0:	ee37 7a40 	vsub.f32	s14, s14, s0
 800c2c4:	eec7 6a87 	vdiv.f32	s13, s15, s14
  if(s21_measure->r < 0.0f) return;
 800c2c8:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 800c2cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  s21_measure->r = config._measure_r * att / (2.0f * (1.0f - att));
 800c2d0:	edc4 6a07 	vstr	s13, [r4, #28]
  if(s21_measure->r < 0.0f) return;
 800c2d4:	f100 808b 	bmi.w	800c3ee <prepare_series+0x182>
  set_marker_index(0, xp);
 800c2d8:	f8bd 7004 	ldrh.w	r7, [sp, #4]
 800c2dc:	4628      	mov	r0, r5
 800c2de:	4639      	mov	r1, r7
 800c2e0:	f7fb fa6e 	bl	80077c0 <set_marker_index>
  float tan45 = config._measure_r/(config._measure_r + 4.0f * s21_measure->r);
 800c2e4:	edd8 7a1a 	vldr	s15, [r8, #104]	@ 0x68
 800c2e8:	ed94 6a07 	vldr	s12, [r4, #28]
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800c2ec:	494c      	ldr	r1, [pc, #304]	@ (800c420 <prepare_series+0x1b4>)
  x2 = xp;
 800c2ee:	f8ad 7006 	strh.w	r7, [sp, #6]
  float tan45 = config._measure_r/(config._measure_r + 4.0f * s21_measure->r);
 800c2f2:	eef1 6a00 	vmov.f32	s13, #16	@ 0x40800000  4.0
 800c2f6:	eeb0 7a67 	vmov.f32	s14, s15
 800c2fa:	eea6 7a26 	vfma.f32	s14, s12, s13
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800c2fe:	2301      	movs	r3, #1
 800c300:	f04f 32ff 	mov.w	r2, #4294967295
 800c304:	f10d 0006 	add.w	r0, sp, #6
  float tan45 = config._measure_r/(config._measure_r + 4.0f * s21_measure->r);
 800c308:	eec7 8a87 	vdiv.f32	s17, s15, s14
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800c30c:	eeb1 0a68 	vneg.f32	s0, s17
 800c310:	f7fe fbe8 	bl	800aae4 <measure_search_value>
  if (f1 == 0) return;
 800c314:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800c318:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float f1 = measure_search_value(&x2, -tan45, s21tan, MEASURE_SEARCH_LEFT, 1);
 800c31c:	eeb0 8a40 	vmov.f32	s16, s0
  if (f1 == 0) return;
 800c320:	d065      	beq.n	800c3ee <prepare_series+0x182>
  float f2 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800c322:	493f      	ldr	r1, [pc, #252]	@ (800c420 <prepare_series+0x1b4>)
  x2 = xp;
 800c324:	f8ad 7006 	strh.w	r7, [sp, #6]
  float f2 = measure_search_value(&x2,  tan45, s21tan, MEASURE_SEARCH_RIGHT, 2);
 800c328:	4633      	mov	r3, r6
 800c32a:	2201      	movs	r2, #1
 800c32c:	eeb0 0a68 	vmov.f32	s0, s17
 800c330:	f10d 0006 	add.w	r0, sp, #6
 800c334:	f7fe fbd6 	bl	800aae4 <measure_search_value>
  if (f2 == 0) return;
 800c338:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800c33c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c340:	d055      	beq.n	800c3ee <prepare_series+0x182>
  float bw = f2 - f1;
 800c342:	ee70 7a48 	vsub.f32	s15, s0, s16
  float fpeak = vna_sqrtf(f2 * f1);
 800c346:	ee28 0a00 	vmul.f32	s0, s16, s0
 800c34a:	eeb1 0ac0 	vsqrt.f32	s0, s0
  s21_measure->freq = fpeak;
 800c34e:	eebc 7ac0 	vcvt.u32.f32	s14, s0
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800c352:	eddf 6a34 	vldr	s13, [pc, #208]	@ 800c424 <prepare_series+0x1b8>
  s21_measure->freq = fpeak;
 800c356:	ed84 7a01 	vstr	s14, [r4, #4]
  s21_measure->q = fpeak / bw;
 800c35a:	ee80 7a27 	vdiv.f32	s14, s0, s15
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800c35e:	ee20 0a00 	vmul.f32	s0, s0, s0
  s21_measure->q = fpeak / bw;
 800c362:	ed84 7a08 	vstr	s14, [r4, #32]
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800c366:	ed94 7a07 	vldr	s14, [r4, #28]
 800c36a:	ee67 5a26 	vmul.f32	s11, s14, s13
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800c36e:	ee20 0a07 	vmul.f32	s0, s0, s14
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800c372:	ee85 6aa7 	vdiv.f32	s12, s11, s15
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800c376:	ee67 7aa6 	vmul.f32	s15, s15, s13
  s21_measure->l = s21_measure->r / ((2.0f * VNA_PI) * bw);
 800c37a:	ed84 6a04 	vstr	s12, [r4, #16]
  s21_measure->c = bw / ((2.0f * VNA_PI) * fpeak * fpeak * s21_measure->r);
 800c37e:	ee87 7a80 	vdiv.f32	s14, s15, s0
 800c382:	ed84 7a05 	vstr	s14, [r4, #20]
 800c386:	e032      	b.n	800c3ee <prepare_series+0x182>
    case MEASURE_SERIES_LC:   n = 4;   analysis_lcseries(); break;
 800c388:	f7ff f9f4 	bl	800b774 <analysis_lcseries>
 800c38c:	e02f      	b.n	800c3ee <prepare_series+0x182>
  analysis_lcseries();
 800c38e:	f7ff f9f1 	bl	800b774 <analysis_lcseries>
  s21_measure->header = "XTAL-SERIES";
 800c392:	4b25      	ldr	r3, [pc, #148]	@ (800c428 <prepare_series+0x1bc>)
  search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800c394:	4921      	ldr	r1, [pc, #132]	@ (800c41c <prepare_series+0x1b0>)
  uint16_t xp=0;
 800c396:	f8ad 5006 	strh.w	r5, [sp, #6]
  search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800c39a:	462a      	mov	r2, r5
 800c39c:	f10d 0006 	add.w	r0, sp, #6
  s21_measure->header = "XTAL-SERIES";
 800c3a0:	6023      	str	r3, [r4, #0]
  search_peak_value(&xp, s21pow2, MEASURE_SEARCH_MIN);
 800c3a2:	f7ff f929 	bl	800b5f8 <search_peak_value.constprop.0>
  if (xp == 0) return;
 800c3a6:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800c3aa:	b305      	cbz	r5, 800c3ee <prepare_series+0x182>
  set_marker_index(3, xp);
 800c3ac:	4629      	mov	r1, r5
 800c3ae:	2003      	movs	r0, #3
 800c3b0:	f7fb fa06 	bl	80077c0 <set_marker_index>
  freq_t freq1 = getFrequency(xp);
 800c3b4:	4628      	mov	r0, r5
 800c3b6:	f7fa fc25 	bl	8006c04 <getFrequency>
  if(freq1 < s21_measure->freq) return;
 800c3ba:	6863      	ldr	r3, [r4, #4]
 800c3bc:	4298      	cmp	r0, r3
 800c3be:	d316      	bcc.n	800c3ee <prepare_series+0x182>
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800c3c0:	ed94 7a05 	vldr	s14, [r4, #20]
  s21_measure->freq1 = freq1;
 800c3c4:	60a0      	str	r0, [r4, #8]
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800c3c6:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 800c3ca:	ee27 7a27 	vmul.f32	s14, s14, s15
 800c3ce:	ee07 3a90 	vmov	s15, r3
 800c3d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
  s21_measure->df = s21_measure->freq1 - s21_measure->freq;
 800c3d6:	1ac0      	subs	r0, r0, r3
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800c3d8:	ee27 7a27 	vmul.f32	s14, s14, s15
 800c3dc:	ee07 0a90 	vmov	s15, r0
 800c3e0:	eef8 7a67 	vcvt.f32.u32	s15, s15
  s21_measure->df = s21_measure->freq1 - s21_measure->freq;
 800c3e4:	60e0      	str	r0, [r4, #12]
  s21_measure->c1 = s21_measure->c * s21_measure->freq / (2.0f * s21_measure->df);
 800c3e6:	eec7 6a27 	vdiv.f32	s13, s14, s15
 800c3ea:	edc4 6a06 	vstr	s13, [r4, #24]
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800c3ee:	2304      	movs	r3, #4
 800c3f0:	2207      	movs	r2, #7
 800c3f2:	2102      	movs	r1, #2
 800c3f4:	2000      	movs	r0, #0
 800c3f6:	f7fe f953 	bl	800a6a0 <invalidate_rect_func>
}
 800c3fa:	b002      	add	sp, #8
 800c3fc:	ecbd 8b02 	vpop	{d8}
 800c400:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  markmap_all_markers();
 800c404:	f7ff bf18 	b.w	800c238 <markmap_all_markers>
}
 800c408:	b002      	add	sp, #8
 800c40a:	ecbd 8b02 	vpop	{d8}
 800c40e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c412:	bf00      	nop
 800c414:	200069fc 	.word	0x200069fc
 800c418:	08014a21 	.word	0x08014a21
 800c41c:	0800a801 	.word	0x0800a801
 800c420:	0800a829 	.word	0x0800a829
 800c424:	3e22f983 	.word	0x3e22f983
 800c428:	08014a2a 	.word	0x08014a2a
 800c42c:	20000318 	.word	0x20000318

0800c430 <marker_search>:
{
 800c430:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (current_trace == TRACE_INVALID || active_marker == MARKER_INVALID)
 800c434:	4e19      	ldr	r6, [pc, #100]	@ (800c49c <marker_search+0x6c>)
 800c436:	f996 301c 	ldrsb.w	r3, [r6, #28]
 800c43a:	1c59      	adds	r1, r3, #1
 800c43c:	d02b      	beq.n	800c496 <marker_search+0x66>
 800c43e:	f996 001d 	ldrsb.w	r0, [r6, #29]
 800c442:	1c42      	adds	r2, r0, #1
 800c444:	d027      	beq.n	800c496 <marker_search+0x66>
  index_t *index = trace_index[current_trace];
 800c446:	4d16      	ldr	r5, [pc, #88]	@ (800c4a0 <marker_search+0x70>)
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800c448:	4a16      	ldr	r2, [pc, #88]	@ (800c4a4 <marker_search+0x74>)
  index_t *index = trace_index[current_trace];
 800c44a:	f240 6144 	movw	r1, #1604	@ 0x644
 800c44e:	fb01 5503 	mla	r5, r1, r3, r5
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800c452:	8a93      	ldrh	r3, [r2, #20]
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800c454:	886f      	ldrh	r7, [r5, #2]
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800c456:	071b      	lsls	r3, r3, #28
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800c458:	8b73      	ldrh	r3, [r6, #26]
  bool (*compare)(int x, int y) = VNA_MODE(VNA_MODE_SEARCH) ? _lesser : _greater;
 800c45a:	bf4c      	ite	mi
 800c45c:	f8df 8048 	ldrmi.w	r8, [pc, #72]	@ 800c4a8 <marker_search+0x78>
 800c460:	f8df 8048 	ldrpl.w	r8, [pc, #72]	@ 800c4ac <marker_search+0x7c>
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800c464:	2b01      	cmp	r3, #1
  int found = 0;
 800c466:	f04f 0900 	mov.w	r9, #0
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800c46a:	d90f      	bls.n	800c48c <marker_search+0x5c>
 800c46c:	3502      	adds	r5, #2
 800c46e:	2401      	movs	r4, #1
    if ((*compare)(value, index[i].y))
 800c470:	f835 1024 	ldrh.w	r1, [r5, r4, lsl #2]
 800c474:	4638      	mov	r0, r7
 800c476:	47c0      	blx	r8
 800c478:	b110      	cbz	r0, 800c480 <marker_search+0x50>
      value = index[i].y;
 800c47a:	f835 7024 	ldrh.w	r7, [r5, r4, lsl #2]
      found = i;
 800c47e:	46a1      	mov	r9, r4
  for (i = 1, value = index[0].y; i < sweep_points; i++)
 800c480:	8b73      	ldrh	r3, [r6, #26]
 800c482:	3401      	adds	r4, #1
 800c484:	42a3      	cmp	r3, r4
 800c486:	dcf3      	bgt.n	800c470 <marker_search+0x40>
  set_marker_index(active_marker, found);
 800c488:	f996 001d 	ldrsb.w	r0, [r6, #29]
 800c48c:	4649      	mov	r1, r9
}
 800c48e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  set_marker_index(active_marker, found);
 800c492:	f7fb b995 	b.w	80077c0 <set_marker_index>
}
 800c496:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c49a:	bf00      	nop
 800c49c:	20000aa8 	.word	0x20000aa8
 800c4a0:	20006a84 	.word	0x20006a84
 800c4a4:	20000318 	.word	0x20000318
 800c4a8:	0800a791 	.word	0x0800a791
 800c4ac:	0800a785 	.word	0x0800a785

0800c4b0 <distance_to_index>:
{
 800c4b0:	b410      	push	{r4}
  x -= index[idx].x;
 800c4b2:	f240 6444 	movw	r4, #1604	@ 0x644
 800c4b6:	fb04 f000 	mul.w	r0, r4, r0
 800c4ba:	4c09      	ldr	r4, [pc, #36]	@ (800c4e0 <distance_to_index+0x30>)
 800c4bc:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800c4c0:	eb01 0c04 	add.w	ip, r1, r4
 800c4c4:	5a60      	ldrh	r0, [r4, r1]
  y -= index[idx].y;
 800c4c6:	f8bc 1002 	ldrh.w	r1, [ip, #2]
}
 800c4ca:	f85d 4b04 	ldr.w	r4, [sp], #4
  x -= index[idx].x;
 800c4ce:	1a10      	subs	r0, r2, r0
  y -= index[idx].y;
 800c4d0:	1a5b      	subs	r3, r3, r1
  x -= index[idx].x;
 800c4d2:	b200      	sxth	r0, r0
  return x * x + y * y;
 800c4d4:	fb13 f303 	smulbb	r3, r3, r3
}
 800c4d8:	fb00 3000 	mla	r0, r0, r0, r3
 800c4dc:	4770      	bx	lr
 800c4de:	bf00      	nop
 800c4e0:	20006a84 	.word	0x20006a84

0800c4e4 <search_nearest_index>:
{
 800c4e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  for (i = 0; i < sweep_points; i++)
 800c4e8:	4b12      	ldr	r3, [pc, #72]	@ (800c534 <search_nearest_index+0x50>)
 800c4ea:	f8b3 901a 	ldrh.w	r9, [r3, #26]
 800c4ee:	f1b9 0f00 	cmp.w	r9, #0
 800c4f2:	d019      	beq.n	800c528 <search_nearest_index+0x44>
    int d = distance_to_index(t, i, x, y);
 800c4f4:	fa4f f882 	sxtb.w	r8, r2
 800c4f8:	b20f      	sxth	r7, r1
 800c4fa:	b202      	sxth	r2, r0
  for (i = 0; i < sweep_points; i++)
 800c4fc:	2400      	movs	r4, #0
  int min_d = MARKER_PICKUP_DISTANCE * MARKER_PICKUP_DISTANCE;
 800c4fe:	f44f 7561 	mov.w	r5, #900	@ 0x384
  int min_i = -1;
 800c502:	f04f 36ff 	mov.w	r6, #4294967295
    int d = distance_to_index(t, i, x, y);
 800c506:	b2a1      	uxth	r1, r4
 800c508:	463b      	mov	r3, r7
 800c50a:	4640      	mov	r0, r8
 800c50c:	f7ff ffd0 	bl	800c4b0 <distance_to_index>
    min_i = i;
 800c510:	42a8      	cmp	r0, r5
 800c512:	bfb8      	it	lt
 800c514:	4626      	movlt	r6, r4
  for (i = 0; i < sweep_points; i++)
 800c516:	f104 0401 	add.w	r4, r4, #1
    min_i = i;
 800c51a:	bfb8      	it	lt
 800c51c:	4605      	movlt	r5, r0
  for (i = 0; i < sweep_points; i++)
 800c51e:	454c      	cmp	r4, r9
 800c520:	d1f1      	bne.n	800c506 <search_nearest_index+0x22>
}
 800c522:	4630      	mov	r0, r6
 800c524:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  int min_i = -1;
 800c528:	f04f 36ff 	mov.w	r6, #4294967295
}
 800c52c:	4630      	mov	r0, r6
 800c52e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c532:	bf00      	nop
 800c534:	20000aa8 	.word	0x20000aa8

0800c538 <parabolic_regression>:
void parabolic_regression(int N, get_value_t getx, get_value_t gety, float *result) {
 800c538:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c53c:	ed2d 8b08 	vpush	{d8-d11}
  x = y = xx = xy = xxy = xxx = xxxx = 0.0f;
 800c540:	ed9f 8a32 	vldr	s16, [pc, #200]	@ 800c60c <parabolic_regression+0xd4>
void parabolic_regression(int N, get_value_t getx, get_value_t gety, float *result) {
 800c544:	4604      	mov	r4, r0
 800c546:	4688      	mov	r8, r1
 800c548:	4617      	mov	r7, r2
 800c54a:	461d      	mov	r5, r3
  for (int i = 0; i < N; ++i) {
 800c54c:	2600      	movs	r6, #0
  x = y = xx = xy = xxy = xxx = xxxx = 0.0f;
 800c54e:	eef0 9a48 	vmov.f32	s19, s16
 800c552:	eef0 8a48 	vmov.f32	s17, s16
 800c556:	eef0 aa48 	vmov.f32	s21, s16
 800c55a:	eeb0 9a48 	vmov.f32	s18, s16
 800c55e:	eef0 ba48 	vmov.f32	s23, s16
 800c562:	eeb0 ba48 	vmov.f32	s22, s16
  for (int i = 0; i < N; ++i) {
 800c566:	42a6      	cmp	r6, r4
 800c568:	da1b      	bge.n	800c5a2 <parabolic_regression+0x6a>
    _x   = getx(i); _y   = gety(i); // Get x and y
 800c56a:	fa1f f986 	uxth.w	r9, r6
 800c56e:	4648      	mov	r0, r9
 800c570:	47c0      	blx	r8
 800c572:	4648      	mov	r0, r9
 800c574:	eeb0 aa40 	vmov.f32	s20, s0
 800c578:	47b8      	blx	r7
    _xx  =   _x*_x; _xy  =   _x*_y;
 800c57a:	ee6a 7a0a 	vmul.f32	s15, s20, s20
 800c57e:	ee2a 7a00 	vmul.f32	s14, s20, s0
    xxx +=  _x*_xx; xxy +=  _x*_xy; // SUMM(x^3) and SUMM(x^2 * y)
 800c582:	eeea 9a27 	vfma.f32	s19, s20, s15
  for (int i = 0; i < N; ++i) {
 800c586:	3601      	adds	r6, #1
    xxx +=  _x*_xx; xxy +=  _x*_xy; // SUMM(x^3) and SUMM(x^2 * y)
 800c588:	eeea 8a07 	vfma.f32	s17, s20, s14
    xxxx+= _xx*_xx;                 // SUMM(x^4)
 800c58c:	eea7 8aa7 	vfma.f32	s16, s15, s15
    x   +=      _x; y   +=      _y; // SUMM(x^1) and SUMM(x^0 * y)
 800c590:	ee3b ba0a 	vadd.f32	s22, s22, s20
 800c594:	ee7b ba80 	vadd.f32	s23, s23, s0
    xx  +=     _xx; xy  +=     _xy; // SUMM(x^2) and SUMM(x^1 * y)
 800c598:	ee39 9a27 	vadd.f32	s18, s18, s15
 800c59c:	ee7a aa87 	vadd.f32	s21, s21, s14
  for (int i = 0; i < N; ++i) {
 800c5a0:	e7e1      	b.n	800c566 <parabolic_regression+0x2e>
  float xm  = x / N, ym  = y / N, xxm = xx / N, a, b, c;
 800c5a2:	ee07 4a90 	vmov	s15, r4
 800c5a6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c5aa:	ee8b 6a27 	vdiv.f32	s12, s22, s15
 800c5ae:	ee8b 7aa7 	vdiv.f32	s14, s23, s15
 800c5b2:	eec9 4a27 	vdiv.f32	s9, s18, s15
  xxx -= xx* xm; xxy -= xx* ym;
 800c5b6:	eef0 7a69 	vmov.f32	s15, s19
 800c5ba:	eee9 7a46 	vfms.f32	s15, s18, s12
  xx  -=  x* xm; xy  -=  x* ym;
 800c5be:	eeeb aa47 	vfms.f32	s21, s22, s14
  xxxx-= xx*xxm;
 800c5c2:	eea9 8a64 	vfms.f32	s16, s18, s9
  xxx -= xx* xm; xxy -= xx* ym;
 800c5c6:	eee9 8a47 	vfms.f32	s17, s18, s14
  xx  -=  x* xm; xy  -=  x* ym;
 800c5ca:	eeab 9a46 	vfms.f32	s18, s22, s12
  c = (xx  *xxy - xxx* xy) / (xxxx*xx - xxx*xxx);
 800c5ce:	ee6a 5ae7 	vnmul.f32	s11, s21, s15
 800c5d2:	ee67 6ae7 	vnmul.f32	s13, s15, s15
 800c5d6:	eee8 5a89 	vfma.f32	s11, s17, s18
  b = (xxxx* xy - xxx*xxy) / (xxxx*xx - xxx*xxx);
 800c5da:	ee68 8ae7 	vnmul.f32	s17, s17, s15
  c = (xx  *xxy - xxx* xy) / (xxxx*xx - xxx*xxx);
 800c5de:	eee8 6a09 	vfma.f32	s13, s16, s18
  b = (xxxx* xy - xxx*xxy) / (xxxx*xx - xxx*xxx);
 800c5e2:	eee8 8a2a 	vfma.f32	s17, s16, s21
  c = (xx  *xxy - xxx* xy) / (xxxx*xx - xxx*xxx);
 800c5e6:	ee85 5aa6 	vdiv.f32	s10, s11, s13
  b = (xxxx* xy - xxx*xxy) / (xxxx*xx - xxx*xxx);
 800c5ea:	eec8 7aa6 	vdiv.f32	s15, s17, s13
}
 800c5ee:	ecbd 8b08 	vpop	{d8-d11}
  result[2] = c;
 800c5f2:	ed85 5a02 	vstr	s10, [r5, #8]
  a = ym - b*xm - c*xxm;
 800c5f6:	eea6 7a67 	vfms.f32	s14, s12, s15
  result[1] = b;
 800c5fa:	edc5 7a01 	vstr	s15, [r5, #4]
  a = ym - b*xm - c*xxm;
 800c5fe:	eea4 7ac5 	vfms.f32	s14, s9, s10
  result[0] = a;
 800c602:	ed85 7a00 	vstr	s14, [r5]
}
 800c606:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c60a:	bf00      	nop
 800c60c:	00000000 	.word	0x00000000

0800c610 <prepare_s11_cable>:
static void prepare_s11_cable(uint8_t type, uint8_t update_mask) {
 800c610:	b530      	push	{r4, r5, lr}
  if (update_mask & MEASURE_UPD_SWEEP) {
 800c612:	07cc      	lsls	r4, r1, #31
static void prepare_s11_cable(uint8_t type, uint8_t update_mask) {
 800c614:	b085      	sub	sp, #20
  if (update_mask & MEASURE_UPD_SWEEP) {
 800c616:	d54c      	bpl.n	800c6b2 <prepare_s11_cable+0xa2>
    s11_cable->R = 0.0f;
 800c618:	ed9f 0a3d 	vldr	s0, [pc, #244]	@ 800c710 <prepare_s11_cable+0x100>
 800c61c:	4c3d      	ldr	r4, [pc, #244]	@ (800c714 <prepare_s11_cable+0x104>)
    f1 = measure_search_value(&x,  0, s11imag, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800c61e:	493e      	ldr	r1, [pc, #248]	@ (800c718 <prepare_s11_cable+0x108>)
    s11_cable->R = 0.0f;
 800c620:	ed84 0a01 	vstr	s0, [r4, #4]
    uint16_t x = 0;
 800c624:	2300      	movs	r3, #0
 800c626:	f8ad 3006 	strh.w	r3, [sp, #6]
    f1 = measure_search_value(&x,  0, s11imag, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800c62a:	f10d 0006 	add.w	r0, sp, #6
 800c62e:	f04f 33ff 	mov.w	r3, #4294967295
 800c632:	2201      	movs	r2, #1
    s11_cable->len = 0.0f;
 800c634:	ed84 0a02 	vstr	s0, [r4, #8]
    s11_cable->vf = 0.0f;
 800c638:	ed84 0a05 	vstr	s0, [r4, #20]
    f1 = measure_search_value(&x,  0, s11imag, MEASURE_SEARCH_RIGHT, MARKER_INVALID);
 800c63c:	f7fe fa52 	bl	800aae4 <measure_search_value>
 800c640:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800c644:	4d35      	ldr	r5, [pc, #212]	@ (800c71c <prepare_s11_cable+0x10c>)
 800c646:	ee17 0a90 	vmov	r0, s15
    if (f1){
 800c64a:	b358      	cbz	r0, 800c6a4 <prepare_s11_cable+0x94>
      float electric_lengh = (SPEED_OF_LIGHT / 400.0f) / f1;
 800c64c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c650:	eddf 6a33 	vldr	s13, [pc, #204]	@ 800c720 <prepare_s11_cable+0x110>
      if (real_cable_len != 0.0f) {
 800c654:	4b33      	ldr	r3, [pc, #204]	@ (800c724 <prepare_s11_cable+0x114>)
      float electric_lengh = (SPEED_OF_LIGHT / 400.0f) / f1;
 800c656:	ee86 7aa7 	vdiv.f32	s14, s13, s15
      if (real_cable_len != 0.0f) {
 800c65a:	edd3 7a00 	vldr	s15, [r3]
 800c65e:	eef5 7a40 	vcmp.f32	s15, #0.0
 800c662:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c666:	d006      	beq.n	800c676 <prepare_s11_cable+0x66>
        s11_cable->vf = real_cable_len / electric_lengh;
 800c668:	eec7 6a87 	vdiv.f32	s13, s15, s14
        s11_cable->len = real_cable_len;
 800c66c:	edc4 7a02 	vstr	s15, [r4, #8]
        s11_cable->vf = real_cable_len / electric_lengh;
 800c670:	edc4 6a05 	vstr	s13, [r4, #20]
 800c674:	e009      	b.n	800c68a <prepare_s11_cable+0x7a>
      } else s11_cable->len = velocity_factor * electric_lengh;
 800c676:	f895 3099 	ldrb.w	r3, [r5, #153]	@ 0x99
 800c67a:	ee07 3a90 	vmov	s15, r3
 800c67e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800c682:	ee67 7a87 	vmul.f32	s15, s15, s14
 800c686:	edc4 7a02 	vstr	s15, [r4, #8]
      if (measure_get_value(0, f1/2, data)){
 800c68a:	a902      	add	r1, sp, #8
 800c68c:	0840      	lsrs	r0, r0, #1
 800c68e:	f7ff fc59 	bl	800bf44 <measure_get_value.constprop.0>
 800c692:	b138      	cbz	r0, 800c6a4 <prepare_s11_cable+0x94>
        s11_cable->R = vna_fabsf(reactance(0, data));
 800c694:	a902      	add	r1, sp, #8
 800c696:	2000      	movs	r0, #0
 800c698:	f7ff faf2 	bl	800bc80 <reactance>
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800c69c:	eeb0 0ac0 	vabs.f32	s0, s0
 800c6a0:	ed84 0a01 	vstr	s0, [r4, #4]
    parabolic_regression(sweep_points, s11index, s11loss, &s11_cable->a);
 800c6a4:	4b20      	ldr	r3, [pc, #128]	@ (800c728 <prepare_s11_cable+0x118>)
 800c6a6:	4a21      	ldr	r2, [pc, #132]	@ (800c72c <prepare_s11_cable+0x11c>)
 800c6a8:	4921      	ldr	r1, [pc, #132]	@ (800c730 <prepare_s11_cable+0x120>)
 800c6aa:	8b68      	ldrh	r0, [r5, #26]
 800c6ac:	f7ff ff44 	bl	800c538 <parabolic_regression>
  if ((update_mask & MEASURE_UPD_ALL) && active_marker != MARKER_INVALID) {
 800c6b0:	e001      	b.n	800c6b6 <prepare_s11_cable+0xa6>
 800c6b2:	0788      	lsls	r0, r1, #30
 800c6b4:	d023      	beq.n	800c6fe <prepare_s11_cable+0xee>
 800c6b6:	4b19      	ldr	r3, [pc, #100]	@ (800c71c <prepare_s11_cable+0x10c>)
 800c6b8:	f993 201d 	ldrsb.w	r2, [r3, #29]
 800c6bc:	1c51      	adds	r1, r2, #1
 800c6be:	d01e      	beq.n	800c6fe <prepare_s11_cable+0xee>
    int idx = markers[active_marker].index;
 800c6c0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    s11_cable->freq = (float)getFrequency(idx);
 800c6c4:	f8b3 005a 	ldrh.w	r0, [r3, #90]	@ 0x5a
 800c6c8:	f7fa fa9c 	bl	8006c04 <getFrequency>
 800c6cc:	ee07 0a90 	vmov	s15, r0
 800c6d0:	4b10      	ldr	r3, [pc, #64]	@ (800c714 <prepare_s11_cable+0x104>)
    float f = s11_cable->freq * 1e-9f;
 800c6d2:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800c734 <prepare_s11_cable+0x124>
    s11_cable->mloss = s11_cable->a + s11_cable->b * vna_sqrtf(f) + s11_cable->c * f;
 800c6d6:	ed93 6a08 	vldr	s12, [r3, #32]
    s11_cable->freq = (float)getFrequency(idx);
 800c6da:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c6de:	edc3 7a00 	vstr	s15, [r3]
    float f = s11_cable->freq * 1e-9f;
 800c6e2:	ee67 7a87 	vmul.f32	s15, s15, s14
    s11_cable->mloss = s11_cable->a + s11_cable->b * vna_sqrtf(f) + s11_cable->c * f;
 800c6e6:	ed93 7a07 	vldr	s14, [r3, #28]
__attribute__((always_inline)) __STATIC_INLINE float vna_sqrtf(float x){__asm__ ("vsqrt.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 800c6ea:	eef1 6ae7 	vsqrt.f32	s13, s15
 800c6ee:	eea6 7a26 	vfma.f32	s14, s12, s13
 800c6f2:	edd3 6a09 	vldr	s13, [r3, #36]	@ 0x24
 800c6f6:	eea6 7aa7 	vfma.f32	s14, s13, s15
 800c6fa:	ed83 7a04 	vstr	s14, [r3, #16]
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800c6fe:	2304      	movs	r3, #4
 800c700:	2207      	movs	r2, #7
 800c702:	2102      	movs	r1, #2
 800c704:	2000      	movs	r0, #0
}
 800c706:	b005      	add	sp, #20
 800c708:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  invalidate_rect(STR_MEASURE_X                        , STR_MEASURE_Y,
 800c70c:	f7fd bfc8 	b.w	800a6a0 <invalidate_rect_func>
 800c710:	00000000 	.word	0x00000000
 800c714:	200069fc 	.word	0x200069fc
 800c718:	0800a84d 	.word	0x0800a84d
 800c71c:	20000aa8 	.word	0x20000aa8
 800c720:	4936fa92 	.word	0x4936fa92
 800c724:	200069f8 	.word	0x200069f8
 800c728:	20006a18 	.word	0x20006a18
 800c72c:	0800bab1 	.word	0x0800bab1
 800c730:	0800aac5 	.word	0x0800aac5
 800c734:	3089705f 	.word	0x3089705f

0800c738 <plot_get_measure_channels>:
  return measure[current_props._measure].option;
 800c738:	4b04      	ldr	r3, [pc, #16]	@ (800c74c <plot_get_measure_channels+0x14>)
 800c73a:	4a05      	ldr	r2, [pc, #20]	@ (800c750 <plot_get_measure_channels+0x18>)
 800c73c:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800c740:	eb03 0343 	add.w	r3, r3, r3, lsl #1
}
 800c744:	f812 0023 	ldrb.w	r0, [r2, r3, lsl #2]
 800c748:	4770      	bx	lr
 800c74a:	bf00      	nop
 800c74c:	20000aa8 	.word	0x20000aa8
 800c750:	080161cc 	.word	0x080161cc

0800c754 <set_area_size>:
  lcd_bulk_continue(OFFSETX + x0, OFFSETY + y0, w, h);
}

void set_area_size(uint16_t w, uint16_t h)
{
  area_width = w;
 800c754:	4a02      	ldr	r2, [pc, #8]	@ (800c760 <set_area_size+0xc>)
  area_height = h;
 800c756:	4b03      	ldr	r3, [pc, #12]	@ (800c764 <set_area_size+0x10>)
  area_width = w;
 800c758:	8010      	strh	r0, [r2, #0]
  area_height = h;
 800c75a:	8019      	strh	r1, [r3, #0]
}
 800c75c:	4770      	bx	lr
 800c75e:	bf00      	nop
 800c760:	200003da 	.word	0x200003da
 800c764:	200003d8 	.word	0x200003d8

0800c768 <request_to_redraw>:
//**************************************************************************************
//            Set update mask for next screen update
//**************************************************************************************
void request_to_redraw(uint16_t mask)
{
  redraw_request |= mask;
 800c768:	4b02      	ldr	r3, [pc, #8]	@ (800c774 <request_to_redraw+0xc>)
 800c76a:	881a      	ldrh	r2, [r3, #0]
 800c76c:	4310      	orrs	r0, r2
 800c76e:	8018      	strh	r0, [r3, #0]
}
 800c770:	4770      	bx	lr
 800c772:	bf00      	nop
 800c774:	200089f0 	.word	0x200089f0

0800c778 <request_to_draw_cells_behind_menu>:
{
 800c778:	b508      	push	{r3, lr}
  invalidate_rect(LCD_WIDTH - MENU_BUTTON_WIDTH - OFFSETX, 0, LCD_WIDTH - OFFSETX, LCD_HEIGHT - 1);
 800c77a:	200b      	movs	r0, #11
 800c77c:	2309      	movs	r3, #9
 800c77e:	220e      	movs	r2, #14
 800c780:	2100      	movs	r1, #0
 800c782:	f7fd ff8d 	bl	800a6a0 <invalidate_rect_func>
}
 800c786:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_CELLS | REDRAW_FREQUENCY);
 800c78a:	200c      	movs	r0, #12
 800c78c:	f7ff bfec 	b.w	800c768 <request_to_redraw>

0800c790 <plot_set_measure_mode>:
  if (mode >= MEASURE_END)
 800c790:	2807      	cmp	r0, #7
 800c792:	d900      	bls.n	800c796 <plot_set_measure_mode+0x6>
 800c794:	4770      	bx	lr
{
 800c796:	b410      	push	{r4}
  data_update = 0xFF;
 800c798:	4a05      	ldr	r2, [pc, #20]	@ (800c7b0 <plot_set_measure_mode+0x20>)
  current_props._measure = mode;
 800c79a:	4c06      	ldr	r4, [pc, #24]	@ (800c7b4 <plot_set_measure_mode+0x24>)
 800c79c:	4603      	mov	r3, r0
  data_update = 0xFF;
 800c79e:	21ff      	movs	r1, #255	@ 0xff
  current_props._measure = mode;
 800c7a0:	f884 3021 	strb.w	r3, [r4, #33]	@ 0x21
  data_update = 0xFF;
 800c7a4:	7011      	strb	r1, [r2, #0]
}
 800c7a6:	f85d 4b04 	ldr.w	r4, [sp], #4
  request_to_redraw(REDRAW_AREA);
 800c7aa:	2002      	movs	r0, #2
 800c7ac:	f7ff bfdc 	b.w	800c768 <request_to_redraw>
 800c7b0:	20006a7c 	.word	0x20006a7c
 800c7b4:	20000aa8 	.word	0x20000aa8

0800c7b8 <draw_all>:
{
 800c7b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (redraw_request & REDRAW_PLOT)
 800c7bc:	4b98      	ldr	r3, [pc, #608]	@ (800ca20 <draw_all+0x268>)
{
 800c7be:	ed2d 8b04 	vpush	{d8-d9}
  if (redraw_request & REDRAW_PLOT)
 800c7c2:	881b      	ldrh	r3, [r3, #0]
 800c7c4:	07da      	lsls	r2, r3, #31
{
 800c7c6:	b0b7      	sub	sp, #220	@ 0xdc
  if (redraw_request & REDRAW_PLOT)
 800c7c8:	f100 81ca 	bmi.w	800cb60 <draw_all+0x3a8>
  if (area_width == 0)
 800c7cc:	4b95      	ldr	r3, [pc, #596]	@ (800ca24 <draw_all+0x26c>)
 800c7ce:	881b      	ldrh	r3, [r3, #0]
 800c7d0:	2b00      	cmp	r3, #0
 800c7d2:	f000 81be 	beq.w	800cb52 <draw_all+0x39a>
  if (redraw_request & REDRAW_CLRSCR)
 800c7d6:	4b92      	ldr	r3, [pc, #584]	@ (800ca20 <draw_all+0x268>)
 800c7d8:	881c      	ldrh	r4, [r3, #0]
 800c7da:	05a7      	lsls	r7, r4, #22
 800c7dc:	f100 81ae 	bmi.w	800cb3c <draw_all+0x384>
  if (redraw_request & REDRAW_AREA)
 800c7e0:	07a6      	lsls	r6, r4, #30
 800c7e2:	d42a      	bmi.n	800c83a <draw_all+0x82>
    if (redraw_request & REDRAW_MARKER)
 800c7e4:	06a5      	lsls	r5, r4, #26
 800c7e6:	f101 82f9 	bmi.w	800dddc <draw_all+0x1624>
    if (redraw_request & REDRAW_REFERENCE)
 800c7ea:	0660      	lsls	r0, r4, #25
 800c7ec:	f101 82fd 	bmi.w	800ddea <draw_all+0x1632>
    if (redraw_request & REDRAW_GRID_VALUE)
 800c7f0:	0622      	lsls	r2, r4, #24
 800c7f2:	f101 8302 	bmi.w	800ddfa <draw_all+0x1642>
  if (redraw_request & (REDRAW_CELLS | REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_REFERENCE | REDRAW_AREA))
 800c7f6:	f014 0fe6 	tst.w	r4, #230	@ 0xe6
 800c7fa:	f041 8303 	bne.w	800de04 <draw_all+0x164c>
  if (redraw_request & REDRAW_FREQUENCY)
 800c7fe:	0725      	lsls	r5, r4, #28
 800c800:	f100 8086 	bmi.w	800c910 <draw_all+0x158>
  if (redraw_request & REDRAW_CAL_STATUS)
 800c804:	06e0      	lsls	r0, r4, #27
 800c806:	f100 80d5 	bmi.w	800c9b4 <draw_all+0x1fc>
  if (redraw_request & REDRAW_BATTERY)
 800c80a:	05e7      	lsls	r7, r4, #23
 800c80c:	f100 815e 	bmi.w	800cacc <draw_all+0x314>


static void plot_draw_swr_reference_lines(void)
{
  
  if (drawTheSWRLines == false)
 800c810:	4b85      	ldr	r3, [pc, #532]	@ (800ca28 <draw_all+0x270>)
  redraw_request = 0;
 800c812:	4983      	ldr	r1, [pc, #524]	@ (800ca20 <draw_all+0x268>)
  if (drawTheSWRLines == false)
 800c814:	781b      	ldrb	r3, [r3, #0]
  redraw_request = 0;
 800c816:	2200      	movs	r2, #0
 800c818:	800a      	strh	r2, [r1, #0]
  if (drawTheSWRLines == false)
 800c81a:	b14b      	cbz	r3, 800c830 <draw_all+0x78>
    return;

  const trace_t *t = &trace[3]; // typically trace 3 is SWR
  if (t->type != TRC_SWR || !t->enabled)
 800c81c:	4b83      	ldr	r3, [pc, #524]	@ (800ca2c <draw_all+0x274>)
 800c81e:	f893 204d 	ldrb.w	r2, [r3, #77]	@ 0x4d
 800c822:	2a06      	cmp	r2, #6
 800c824:	d104      	bne.n	800c830 <draw_all+0x78>
 800c826:	f893 204c 	ldrb.w	r2, [r3, #76]	@ 0x4c
 800c82a:	2a00      	cmp	r2, #0
 800c82c:	f040 820d 	bne.w	800cc4a <draw_all+0x492>
}
 800c830:	b037      	add	sp, #220	@ 0xdc
 800c832:	ecbd 8b04 	vpop	{d8-d9}
 800c836:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    markmap[n] = (map_t)-1;
 800c83a:	4e7d      	ldr	r6, [pc, #500]	@ (800ca30 <draw_all+0x278>)
 800c83c:	f04f 33ff 	mov.w	r3, #4294967295
 800c840:	e9c6 3300 	strd	r3, r3, [r6]
 800c844:	e9c6 3302 	strd	r3, r3, [r6, #8]
 800c848:	6133      	str	r3, [r6, #16]
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800c84a:	4b76      	ldr	r3, [pc, #472]	@ (800ca24 <draw_all+0x26c>)
  if (current_props._measure >= MEASURE_END)
 800c84c:	4c77      	ldr	r4, [pc, #476]	@ (800ca2c <draw_all+0x274>)
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800c84e:	881f      	ldrh	r7, [r3, #0]
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800c850:	4b78      	ldr	r3, [pc, #480]	@ (800ca34 <draw_all+0x27c>)
  if (current_props._measure >= MEASURE_END)
 800c852:	f894 0021 	ldrb.w	r0, [r4, #33]	@ 0x21
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800c856:	881b      	ldrh	r3, [r3, #0]
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800c858:	371f      	adds	r7, #31
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800c85a:	331f      	adds	r3, #31
  if (current_props._measure >= MEASURE_END)
 800c85c:	2807      	cmp	r0, #7
  uint16_t w = (area_width + CELLWIDTH - 1) / CELLWIDTH;
 800c85e:	ea4f 1767 	mov.w	r7, r7, asr #5
  uint16_t h = (area_height + CELLHEIGHT - 1) / CELLHEIGHT;
 800c862:	ea4f 1863 	mov.w	r8, r3, asr #5
 800c866:	ea4f 1553 	mov.w	r5, r3, lsr #5
  if (current_props._measure >= MEASURE_END)
 800c86a:	d810      	bhi.n	800c88e <draw_all+0xd6>
  measure_prepare_cb_t measure_cb = measure[current_props._measure].measure_prepare;
 800c86c:	4a72      	ldr	r2, [pc, #456]	@ (800ca38 <draw_all+0x280>)
 800c86e:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 800c872:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800c876:	6893      	ldr	r3, [r2, #8]
  if (measure_cb && (data_update & measure[current_props._measure].update))
 800c878:	2b00      	cmp	r3, #0
 800c87a:	f001 838c 	beq.w	800df96 <draw_all+0x17de>
 800c87e:	4c6f      	ldr	r4, [pc, #444]	@ (800ca3c <draw_all+0x284>)
 800c880:	7852      	ldrb	r2, [r2, #1]
 800c882:	7821      	ldrb	r1, [r4, #0]
 800c884:	4211      	tst	r1, r2
 800c886:	d000      	beq.n	800c88a <draw_all+0xd2>
    measure_cb(current_props._measure, data_update);
 800c888:	4798      	blx	r3
  data_update = 0;
 800c88a:	2300      	movs	r3, #0
 800c88c:	7023      	strb	r3, [r4, #0]
  for (n = 0; n < h; n++)
 800c88e:	f1b8 0f00 	cmp.w	r8, #0
 800c892:	d030      	beq.n	800c8f6 <draw_all+0x13e>
 800c894:	017b      	lsls	r3, r7, #5
 800c896:	9309      	str	r3, [sp, #36]	@ 0x24
 800c898:	f06f 03ea 	mvn.w	r3, #234	@ 0xea
 800c89c:	4c64      	ldr	r4, [pc, #400]	@ (800ca30 <draw_all+0x278>)
 800c89e:	930d      	str	r3, [sp, #52]	@ 0x34
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800c8a0:	eddf 8a67 	vldr	s17, [pc, #412]	@ 800ca40 <draw_all+0x288>
  for (n = 0; n < h; n++)
 800c8a4:	9518      	str	r5, [sp, #96]	@ 0x60
 800c8a6:	2300      	movs	r3, #0
 800c8a8:	9315      	str	r3, [sp, #84]	@ 0x54
 800c8aa:	9416      	str	r4, [sp, #88]	@ 0x58
 800c8ac:	961a      	str	r6, [sp, #104]	@ 0x68
    map_t update_map = markmap[n];
 800c8ae:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 800c8b0:	f833 2b02 	ldrh.w	r2, [r3], #2
 800c8b4:	9207      	str	r2, [sp, #28]
 800c8b6:	9316      	str	r3, [sp, #88]	@ 0x58
    for (m = 0; update_map && m < w; update_map >>= 1, m++)
 800c8b8:	b192      	cbz	r2, 800c8e0 <draw_all+0x128>
 800c8ba:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800c8bc:	33eb      	adds	r3, #235	@ 0xeb
 800c8be:	9308      	str	r3, [sp, #32]
 800c8c0:	2300      	movs	r3, #0
 800c8c2:	469b      	mov	fp, r3
 800c8c4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800c8c6:	459b      	cmp	fp, r3
 800c8c8:	d00a      	beq.n	800c8e0 <draw_all+0x128>
      if (update_map & 1)
 800c8ca:	9b07      	ldr	r3, [sp, #28]
 800c8cc:	07dd      	lsls	r5, r3, #31
 800c8ce:	f100 8249 	bmi.w	800cd64 <draw_all+0x5ac>
    for (m = 0; update_map && m < w; update_map >>= 1, m++)
 800c8d2:	085b      	lsrs	r3, r3, #1
 800c8d4:	9307      	str	r3, [sp, #28]
 800c8d6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 800c8d8:	f10b 0b20 	add.w	fp, fp, #32
 800c8dc:	459b      	cmp	fp, r3
 800c8de:	d1f4      	bne.n	800c8ca <draw_all+0x112>
  for (n = 0; n < h; n++)
 800c8e0:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800c8e2:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 800c8e4:	3220      	adds	r2, #32
 800c8e6:	3301      	adds	r3, #1
 800c8e8:	920d      	str	r2, [sp, #52]	@ 0x34
 800c8ea:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 800c8ec:	b29b      	uxth	r3, r3
 800c8ee:	429a      	cmp	r2, r3
 800c8f0:	9315      	str	r3, [sp, #84]	@ 0x54
 800c8f2:	d1dc      	bne.n	800c8ae <draw_all+0xf6>
 800c8f4:	9e1a      	ldr	r6, [sp, #104]	@ 0x68
    markmap[n] = (map_t)0;
 800c8f6:	2300      	movs	r3, #0
 800c8f8:	e9c6 3300 	strd	r3, r3, [r6]
 800c8fc:	e9c6 3302 	strd	r3, r3, [r6, #8]
 800c900:	6133      	str	r3, [r6, #16]
  lcd_bulk_finish();
 800c902:	f004 faa9 	bl	8010e58 <lcd_bulk_finish>
  if (redraw_request & REDRAW_FREQUENCY)
 800c906:	4b46      	ldr	r3, [pc, #280]	@ (800ca20 <draw_all+0x268>)
 800c908:	881c      	ldrh	r4, [r3, #0]
 800c90a:	0725      	lsls	r5, r4, #28
 800c90c:	f57f af7a 	bpl.w	800c804 <draw_all+0x4c>
  char lm0 = lever_mode == LM_FREQ_0 ? S_SARROW[0] : ' ';
 800c910:	4f4c      	ldr	r7, [pc, #304]	@ (800ca44 <draw_all+0x28c>)
 800c912:	7f3b      	ldrb	r3, [r7, #28]
 800c914:	2b02      	cmp	r3, #2
 800c916:	f000 81f7 	beq.w	800cd08 <draw_all+0x550>
  char lm1 = lever_mode == LM_FREQ_1 ? S_SARROW[0] : ' ';
 800c91a:	2b03      	cmp	r3, #3
 800c91c:	f04f 0520 	mov.w	r5, #32
 800c920:	f041 82ab 	bne.w	800de7a <draw_all+0x16c2>
 800c924:	2618      	movs	r6, #24
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800c926:	2100      	movs	r1, #0
 800c928:	2001      	movs	r0, #1
  if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800c92a:	4c40      	ldr	r4, [pc, #256]	@ (800ca2c <draw_all+0x274>)
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800c92c:	f004 fbc4 	bl	80110b8 <lcd_set_colors>
  lcd_fill(0, HEIGHT + OFFSETY + 1, LCD_WIDTH, LCD_HEIGHT - HEIGHT - OFFSETY - 1);
 800c930:	f240 1131 	movw	r1, #305	@ 0x131
 800c934:	2000      	movs	r0, #0
 800c936:	230f      	movs	r3, #15
 800c938:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800c93c:	f004 fab6 	bl	8010eac <lcd_fill>
  if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800c940:	8b21      	ldrh	r1, [r4, #24]
 800c942:	07c8      	lsls	r0, r1, #31
 800c944:	f101 8275 	bmi.w	800de32 <draw_all+0x167a>
    if (FREQ_IS_CW())
 800c948:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
 800c94c:	429a      	cmp	r2, r3
 800c94e:	f001 839c 	beq.w	800e08a <draw_all+0x18d2>
    else if (FREQ_IS_STARTSTOP())
 800c952:	0649      	lsls	r1, r1, #25
 800c954:	f101 8294 	bmi.w	800de80 <draw_all+0x16c8>
      lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm0, "START", get_sweep_frequency(ST_START));
 800c958:	9201      	str	r2, [sp, #4]
 800c95a:	4a3b      	ldr	r2, [pc, #236]	@ (800ca48 <draw_all+0x290>)
 800c95c:	9200      	str	r2, [sp, #0]
 800c95e:	462b      	mov	r3, r5
 800c960:	4a3a      	ldr	r2, [pc, #232]	@ (800ca4c <draw_all+0x294>)
 800c962:	f240 1133 	movw	r1, #307	@ 0x133
 800c966:	200f      	movs	r0, #15
 800c968:	f004 fc36 	bl	80111d8 <lcd_printf>
      lcd_printf(FREQUENCIES_XPOS2, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm1, "STOP", get_sweep_frequency(ST_STOP));
 800c96c:	68a3      	ldr	r3, [r4, #8]
 800c96e:	9301      	str	r3, [sp, #4]
 800c970:	4b37      	ldr	r3, [pc, #220]	@ (800ca50 <draw_all+0x298>)
 800c972:	9300      	str	r3, [sp, #0]
 800c974:	4a35      	ldr	r2, [pc, #212]	@ (800ca4c <draw_all+0x294>)
 800c976:	4633      	mov	r3, r6
 800c978:	f240 1133 	movw	r1, #307	@ 0x133
 800c97c:	f44f 70a3 	mov.w	r0, #326	@ 0x146
 800c980:	f004 fc2a 	bl	80111d8 <lcd_printf>
  lcd_set_foreground(LCD_BW_TEXT_COLOR);
 800c984:	2012      	movs	r0, #18
 800c986:	f004 fb7f 	bl	8011088 <lcd_set_foreground>
  lcd_set_colors(LCD_SPEC_INPUT_COLOR, LCD_BG_COLOR);
 800c98a:	2100      	movs	r1, #0
 800c98c:	200e      	movs	r0, #14
 800c98e:	f004 fb93 	bl	80110b8 <lcd_set_colors>
  lcd_printf(FREQUENCIES_XPOS3, FREQUENCIES_YPOS, "BW:%u" S_Hz " %up", get_bandwidth_frequency(config._bandwidth), sweep_points);
 800c992:	8b78      	ldrh	r0, [r7, #26]
 800c994:	f7fa f930 	bl	8006bf8 <get_bandwidth_frequency>
 800c998:	8b61      	ldrh	r1, [r4, #26]
 800c99a:	9100      	str	r1, [sp, #0]
 800c99c:	4603      	mov	r3, r0
 800c99e:	4a2d      	ldr	r2, [pc, #180]	@ (800ca54 <draw_all+0x29c>)
 800c9a0:	f240 1133 	movw	r1, #307	@ 0x133
 800c9a4:	20ce      	movs	r0, #206	@ 0xce
 800c9a6:	f004 fc17 	bl	80111d8 <lcd_printf>
  if (redraw_request & REDRAW_CAL_STATUS)
 800c9aa:	4b1d      	ldr	r3, [pc, #116]	@ (800ca20 <draw_all+0x268>)
 800c9ac:	881c      	ldrh	r4, [r3, #0]
 800c9ae:	06e0      	lsls	r0, r4, #27
 800c9b0:	f57f af2b 	bpl.w	800c80a <draw_all+0x52>
  lcd_set_colors(LCD_DISABLE_CAL_COLOR, LCD_BG_COLOR);
 800c9b4:	2100      	movs	r1, #0
 800c9b6:	2018      	movs	r0, #24
  if (cal_status & CALSTAT_APPLY)
 800c9b8:	4c1c      	ldr	r4, [pc, #112]	@ (800ca2c <draw_all+0x274>)
  lcd_set_colors(LCD_DISABLE_CAL_COLOR, LCD_BG_COLOR);
 800c9ba:	f004 fb7d 	bl	80110b8 <lcd_set_colors>
  lcd_fill(x, y, OFFSETX - x, 10 * (sFONT_STR_HEIGHT));
 800c9be:	220f      	movs	r2, #15
 800c9c0:	2164      	movs	r1, #100	@ 0x64
 800c9c2:	236e      	movs	r3, #110	@ 0x6e
 800c9c4:	2000      	movs	r0, #0
 800c9c6:	f004 fa71 	bl	8010eac <lcd_fill>
  if (cal_status & CALSTAT_APPLY)
 800c9ca:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
 800c9cc:	05d1      	lsls	r1, r2, #23
 800c9ce:	d522      	bpl.n	800ca16 <draw_all+0x25e>
    char c[4] = {'C', '0' + lastsaveid, 0, 0};
 800c9d0:	4b21      	ldr	r3, [pc, #132]	@ (800ca58 <draw_all+0x2a0>)
 800c9d2:	2143      	movs	r1, #67	@ 0x43
 800c9d4:	881b      	ldrh	r3, [r3, #0]
 800c9d6:	f88d 1088 	strb.w	r1, [sp, #136]	@ 0x88
 800c9da:	2100      	movs	r1, #0
 800c9dc:	f8ad 108a 	strh.w	r1, [sp, #138]	@ 0x8a
    if (lastsaveid == NO_SAVE_SLOT)
 800c9e0:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 800c9e4:	428b      	cmp	r3, r1
    char c[4] = {'C', '0' + lastsaveid, 0, 0};
 800c9e6:	bf1a      	itte	ne
 800c9e8:	3330      	addne	r3, #48	@ 0x30
 800c9ea:	b2db      	uxtbne	r3, r3
      c[1] = '*';
 800c9ec:	232a      	moveq	r3, #42	@ 0x2a
    if (cal_status & CALSTAT_INTERPOLATED)
 800c9ee:	0592      	lsls	r2, r2, #22
 800c9f0:	f88d 3089 	strb.w	r3, [sp, #137]	@ 0x89
 800c9f4:	f141 8264 	bpl.w	800dec0 <draw_all+0x1708>
      lcd_set_foreground(LCD_INTERP_CAL_COLOR);
 800c9f8:	2017      	movs	r0, #23
 800c9fa:	f004 fb45 	bl	8011088 <lcd_set_foreground>
      c[0] = 'c';
 800c9fe:	2363      	movs	r3, #99	@ 0x63
 800ca00:	f88d 3088 	strb.w	r3, [sp, #136]	@ 0x88
    lcd_drawstring(x, y, c);
 800ca04:	aa22      	add	r2, sp, #136	@ 0x88
 800ca06:	2164      	movs	r1, #100	@ 0x64
 800ca08:	2000      	movs	r0, #0
 800ca0a:	f004 fbe5 	bl	80111d8 <lcd_printf>
    lcd_set_foreground(LCD_FG_COLOR);
 800ca0e:	2001      	movs	r0, #1
 800ca10:	f004 fb3a 	bl	8011088 <lcd_set_foreground>
    if (cal_status & calibration_text[i].mask)
 800ca14:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800ca16:	4d11      	ldr	r5, [pc, #68]	@ (800ca5c <draw_all+0x2a4>)
      c[1] = '*';
 800ca18:	2664      	movs	r6, #100	@ 0x64
 800ca1a:	f105 0724 	add.w	r7, r5, #36	@ 0x24
 800ca1e:	e022      	b.n	800ca66 <draw_all+0x2ae>
 800ca20:	200089f0 	.word	0x200089f0
 800ca24:	200003da 	.word	0x200003da
 800ca28:	20006874 	.word	0x20006874
 800ca2c:	20000aa8 	.word	0x20000aa8
 800ca30:	200089d8 	.word	0x200089d8
 800ca34:	200003d8 	.word	0x200003d8
 800ca38:	080161cc 	.word	0x080161cc
 800ca3c:	20006a7c 	.word	0x20006a7c
 800ca40:	42180000 	.word	0x42180000
 800ca44:	20000318 	.word	0x20000318
 800ca48:	08013d90 	.word	0x08013d90
 800ca4c:	08013d80 	.word	0x08013d80
 800ca50:	08013d98 	.word	0x08013d98
 800ca54:	08013dd8 	.word	0x08013dd8
 800ca58:	20009a3e 	.word	0x20009a3e
 800ca5c:	08016178 	.word	0x08016178
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800ca60:	3504      	adds	r5, #4
 800ca62:	42bd      	cmp	r5, r7
 800ca64:	d00c      	beq.n	800ca80 <draw_all+0x2c8>
    if (cal_status & calibration_text[i].mask)
 800ca66:	886b      	ldrh	r3, [r5, #2]
 800ca68:	421a      	tst	r2, r3
 800ca6a:	d0f9      	beq.n	800ca60 <draw_all+0x2a8>
      lcd_drawstring(x, y += sFONT_STR_HEIGHT, &calibration_text[i].text);
 800ca6c:	360b      	adds	r6, #11
 800ca6e:	462a      	mov	r2, r5
 800ca70:	b231      	sxth	r1, r6
 800ca72:	2000      	movs	r0, #0
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800ca74:	3504      	adds	r5, #4
      lcd_drawstring(x, y += sFONT_STR_HEIGHT, &calibration_text[i].text);
 800ca76:	f004 fbaf 	bl	80111d8 <lcd_printf>
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800ca7a:	42bd      	cmp	r5, r7
  if ((cal_status & CALSTAT_APPLY) && cal_power != current_props._power)
 800ca7c:	8ca2      	ldrh	r2, [r4, #36]	@ 0x24
  for (i = 0; i < ARRAY_COUNT(calibration_text); i++)
 800ca7e:	d1f2      	bne.n	800ca66 <draw_all+0x2ae>
  if ((cal_status & CALSTAT_APPLY) && cal_power != current_props._power)
 800ca80:	05d3      	lsls	r3, r2, #23
 800ca82:	d507      	bpl.n	800ca94 <draw_all+0x2dc>
 800ca84:	f894 2020 	ldrb.w	r2, [r4, #32]
 800ca88:	7fe3      	ldrb	r3, [r4, #31]
 800ca8a:	429a      	cmp	r2, r3
 800ca8c:	d002      	beq.n	800ca94 <draw_all+0x2dc>
    lcd_set_foreground(LCD_DISABLE_CAL_COLOR);
 800ca8e:	2018      	movs	r0, #24
 800ca90:	f004 fafa 	bl	8011088 <lcd_set_foreground>
  lcd_set_foreground(LCD_BG_COLOR); // ADDED BY ME to hide power level when cal not applied
 800ca94:	2000      	movs	r0, #0
 800ca96:	f004 faf7 	bl	8011088 <lcd_set_foreground>
  lcd_printf(x, y += sFONT_STR_HEIGHT, "P%c", current_props._power > 3 ? ('a') : (current_props._power * 2 + '2'));
 800ca9a:	7fe3      	ldrb	r3, [r4, #31]
 800ca9c:	4aa2      	ldr	r2, [pc, #648]	@ (800cd28 <draw_all+0x570>)
 800ca9e:	2b03      	cmp	r3, #3
 800caa0:	bf98      	it	ls
 800caa2:	3319      	addls	r3, #25
 800caa4:	f106 010b 	add.w	r1, r6, #11
 800caa8:	b209      	sxth	r1, r1
 800caaa:	bf94      	ite	ls
 800caac:	005b      	lslls	r3, r3, #1
 800caae:	2361      	movhi	r3, #97	@ 0x61
 800cab0:	2000      	movs	r0, #0
 800cab2:	f004 fb91 	bl	80111d8 <lcd_printf>
  uint8_t smooth = get_smooth_factor();
 800cab6:	f7f8 ffeb 	bl	8005a90 <get_smooth_factor>
  if (smooth > 0)
 800caba:	4604      	mov	r4, r0
 800cabc:	2800      	cmp	r0, #0
 800cabe:	f040 8126 	bne.w	800cd0e <draw_all+0x556>
  if (redraw_request & REDRAW_BATTERY)
 800cac2:	4b9a      	ldr	r3, [pc, #616]	@ (800cd2c <draw_all+0x574>)
 800cac4:	881c      	ldrh	r4, [r3, #0]
 800cac6:	05e7      	lsls	r7, r4, #23
 800cac8:	f57f aea2 	bpl.w	800c810 <draw_all+0x58>
  int16_t vbat = adc_vbat_read();
 800cacc:	f004 ffda 	bl	8011a84 <adc_vbat_read>
  if (vbat <= 0)
 800cad0:	1e04      	subs	r4, r0, #0
 800cad2:	f77f ae9d 	ble.w	800c810 <draw_all+0x58>
  if (vbat >= BATTERY_WARNING_LEVEL) {
 800cad6:	f640 43e3 	movw	r3, #3299	@ 0xce3
 800cada:	429c      	cmp	r4, r3
    lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 800cadc:	f04f 0100 	mov.w	r1, #0
  if (vbat >= BATTERY_WARNING_LEVEL) {
 800cae0:	f301 81f3 	bgt.w	800deca <draw_all+0x1712>
  lcd_set_colors(LCD_LOW_BAT_COLOR, LCD_BG_COLOR);
 800cae4:	200d      	movs	r0, #13
 800cae6:	f004 fae7 	bl	80110b8 <lcd_set_colors>
  string_buf[x++] = 0b00000000;
 800caea:	4b91      	ldr	r3, [pc, #580]	@ (800cd30 <draw_all+0x578>)
 800caec:	9322      	str	r3, [sp, #136]	@ 0x88
  for (int power = BATTERY_TOP_LEVEL; power > BATTERY_BOTTOM_LEVEL;)
 800caee:	f241 0104 	movw	r1, #4100	@ 0x1004
 800caf2:	f10d 008b 	add.w	r0, sp, #139	@ 0x8b
  string_buf[x++] = 0b11111111;
 800caf6:	2304      	movs	r3, #4
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800caf8:	2581      	movs	r5, #129	@ 0x81
    if ((x & 3) == 0)
 800cafa:	079e      	lsls	r6, r3, #30
      string_buf[x++] = 0b10000001;
 800cafc:	f103 0201 	add.w	r2, r3, #1
    if ((x & 3) == 0)
 800cb00:	f001 8028 	beq.w	800db54 <draw_all+0x139c>
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800cb04:	428c      	cmp	r4, r1
    power -= 100;
 800cb06:	f1a1 0164 	sub.w	r1, r1, #100	@ 0x64
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800cb0a:	f2c1 8028 	blt.w	800db5e <draw_all+0x13a6>
 800cb0e:	f103 01d8 	add.w	r1, r3, #216	@ 0xd8
 800cb12:	4469      	add	r1, sp
 800cb14:	20bd      	movs	r0, #189	@ 0xbd
 800cb16:	f801 0c50 	strb.w	r0, [r1, #-80]
  string_buf[x++] = 0b10000001;
 800cb1a:	446a      	add	r2, sp
 800cb1c:	2081      	movs	r0, #129	@ 0x81
 800cb1e:	f882 0088 	strb.w	r0, [r2, #136]	@ 0x88
  string_buf[x++] = 0b11111111;
 800cb22:	3303      	adds	r3, #3
  lcd_blitBitmap(BATTERY_ICON_POSX, BATTERY_ICON_POSY, 8, x, string_buf);
 800cb24:	aa22      	add	r2, sp, #136	@ 0x88
  string_buf[x++] = 0b11111111;
 800cb26:	20ff      	movs	r0, #255	@ 0xff
 800cb28:	f801 0c4e 	strb.w	r0, [r1, #-78]
  lcd_blitBitmap(BATTERY_ICON_POSX, BATTERY_ICON_POSY, 8, x, string_buf);
 800cb2c:	b29b      	uxth	r3, r3
 800cb2e:	9200      	str	r2, [sp, #0]
 800cb30:	2102      	movs	r1, #2
 800cb32:	2208      	movs	r2, #8
 800cb34:	2003      	movs	r0, #3
 800cb36:	f004 fad1 	bl	80110dc <lcd_blitBitmap>
 800cb3a:	e669      	b.n	800c810 <draw_all+0x58>
    lcd_set_background(LCD_BG_COLOR);
 800cb3c:	2000      	movs	r0, #0
 800cb3e:	f004 faaf 	bl	80110a0 <lcd_set_background>
    lcd_clear_screen();
 800cb42:	f004 fa53 	bl	8010fec <lcd_clear_screen>
  if (redraw_request & REDRAW_AREA)
 800cb46:	4b79      	ldr	r3, [pc, #484]	@ (800cd2c <draw_all+0x574>)
 800cb48:	881c      	ldrh	r4, [r3, #0]
 800cb4a:	07a6      	lsls	r6, r4, #30
 800cb4c:	f57f ae4a 	bpl.w	800c7e4 <draw_all+0x2c>
 800cb50:	e673      	b.n	800c83a <draw_all+0x82>
    redraw_request = 0;
 800cb52:	4a76      	ldr	r2, [pc, #472]	@ (800cd2c <draw_all+0x574>)
 800cb54:	8013      	strh	r3, [r2, #0]
}
 800cb56:	b037      	add	sp, #220	@ 0xdc
 800cb58:	ecbd 8b04 	vpop	{d8-d9}
 800cb5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  markmap_all_markers();
 800cb60:	4c74      	ldr	r4, [pc, #464]	@ (800cd34 <draw_all+0x57c>)
 800cb62:	f8df a1fc 	ldr.w	sl, [pc, #508]	@ 800cd60 <draw_all+0x5a8>
 800cb66:	f7ff fb67 	bl	800c238 <markmap_all_markers>
  float (*array)[2] = measured[trace[t].channel];
 800cb6a:	46a0      	mov	r8, r4
 800cb6c:	9407      	str	r4, [sp, #28]
 800cb6e:	4654      	mov	r4, sl
    if (trace[t].enabled)
 800cb70:	f898 3028 	ldrb.w	r3, [r8, #40]	@ 0x28
 800cb74:	b9a3      	cbnz	r3, 800cba0 <draw_all+0x3e8>
  for (int t = 0; t < TRACES_MAX; t++)
 800cb76:	4b70      	ldr	r3, [pc, #448]	@ (800cd38 <draw_all+0x580>)
 800cb78:	f108 080c 	add.w	r8, r8, #12
 800cb7c:	4598      	cmp	r8, r3
 800cb7e:	f204 6444 	addw	r4, r4, #1604	@ 0x644
 800cb82:	d1f5      	bne.n	800cb70 <draw_all+0x3b8>
  if (props_mode & TD_MARKER_TRACK)
 800cb84:	9c07      	ldr	r4, [sp, #28]
 800cb86:	8b23      	ldrh	r3, [r4, #24]
 800cb88:	061b      	lsls	r3, r3, #24
 800cb8a:	f101 813e 	bmi.w	800de0a <draw_all+0x1652>
  data_update |= flag;
 800cb8e:	4c6b      	ldr	r4, [pc, #428]	@ (800cd3c <draw_all+0x584>)
 800cb90:	7823      	ldrb	r3, [r4, #0]
  request_to_redraw(REDRAW_MARKER | REDRAW_CELLS);
 800cb92:	2024      	movs	r0, #36	@ 0x24
  data_update |= flag;
 800cb94:	f043 0301 	orr.w	r3, r3, #1
 800cb98:	7023      	strb	r3, [r4, #0]
  request_to_redraw(REDRAW_MARKER | REDRAW_CELLS);
 800cb9a:	f7ff fde5 	bl	800c768 <request_to_redraw>
}
 800cb9e:	e615      	b.n	800c7cc <draw_all+0x14>
  uint16_t start = 0, stop = sweep_points - 1, i;
 800cba0:	9b07      	ldr	r3, [sp, #28]
  float (*array)[2] = measured[trace[t].channel];
 800cba2:	4a67      	ldr	r2, [pc, #412]	@ (800cd40 <draw_all+0x588>)
 800cba4:	f898 602a 	ldrb.w	r6, [r8, #42]	@ 0x2a
  uint16_t start = 0, stop = sweep_points - 1, i;
 800cba8:	8b59      	ldrh	r1, [r3, #26]
  uint32_t type = 1 << trace[t].type;
 800cbaa:	f898 3029 	ldrb.w	r3, [r8, #41]	@ 0x29
  float scale = get_trace_scale(t);
 800cbae:	edd8 7a0b 	vldr	s15, [r8, #44]	@ 0x2c
  float (*array)[2] = measured[trace[t].channel];
 800cbb2:	f640 4088 	movw	r0, #3208	@ 0xc88
 800cbb6:	fb00 2606 	mla	r6, r0, r6, r2
  if (type & RECTANGULAR_GRID_MASK)
 800cbba:	4862      	ldr	r0, [pc, #392]	@ (800cd44 <draw_all+0x58c>)
  uint32_t type = 1 << trace[t].type;
 800cbbc:	2201      	movs	r2, #1
 800cbbe:	409a      	lsls	r2, r3
  uint16_t start = 0, stop = sweep_points - 1, i;
 800cbc0:	3901      	subs	r1, #1
  if (type & RECTANGULAR_GRID_MASK)
 800cbc2:	ea12 0500 	ands.w	r5, r2, r0
  uint16_t start = 0, stop = sweep_points - 1, i;
 800cbc6:	b28f      	uxth	r7, r1
  if (type & RECTANGULAR_GRID_MASK)
 800cbc8:	f041 8070 	bne.w	800dcac <draw_all+0x14f4>
  if (type & ROUND_GRID_MASK)
 800cbcc:	f012 0f18 	tst.w	r2, #24
 800cbd0:	d0d1      	beq.n	800cb76 <draw_all+0x3be>
    const float rscale = P_RADIUS / scale;
 800cbd2:	ed9f 7a5d 	vldr	s14, [pc, #372]	@ 800cd48 <draw_all+0x590>
 800cbd6:	ee87 6a27 	vdiv.f32	s12, s14, s15
    for (i = start; i <= stop; i++)
 800cbda:	4629      	mov	r1, r5
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800cbdc:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
      cartesian_scale(array[i], &x, &y, rscale);
 800cbe0:	b2ab      	uxth	r3, r5
 800cbe2:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800cbe6:	edd3 7a00 	vldr	s15, [r3]
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800cbea:	edd3 5a01 	vldr	s11, [r3, #4]
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800cbee:	eeb0 7a66 	vmov.f32	s14, s13
 800cbf2:	eea6 7a27 	vfma.f32	s14, s12, s15
      mark_set_index(index, i, x, y);
 800cbf6:	4620      	mov	r0, r4
    for (i = start; i <= stop; i++)
 800cbf8:	3501      	adds	r5, #1
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800cbfa:	eef0 7a66 	vmov.f32	s15, s13
 800cbfe:	eee6 7a25 	vfma.f32	s15, s12, s11
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800cc02:	eebd 7ac7 	vcvt.s32.f32	s14, s14
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800cc06:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  int16_t x = P_CENTER_X + float2int(v[0] * scale);
 800cc0a:	ee17 2a10 	vmov	r2, s14
 800cc0e:	32e8      	adds	r2, #232	@ 0xe8
  else if (x > CELLOFFSETX + WIDTH)
 800cc10:	b212      	sxth	r2, r2
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800cc12:	ee17 3a90 	vmov	r3, s15
  if (x < CELLOFFSETX)
 800cc16:	f5b2 7fe6 	cmp.w	r2, #460	@ 0x1cc
 800cc1a:	bfa8      	it	ge
 800cc1c:	f44f 72e6 	movge.w	r2, #460	@ 0x1cc
  int16_t y = P_CENTER_Y - float2int(v[1] * scale);
 800cc20:	f1c3 0398 	rsb	r3, r3, #152	@ 0x98
  if (x < CELLOFFSETX)
 800cc24:	2a05      	cmp	r2, #5
  else if (y > HEIGHT)
 800cc26:	b21b      	sxth	r3, r3
  if (x < CELLOFFSETX)
 800cc28:	bfb8      	it	lt
 800cc2a:	2205      	movlt	r2, #5
  if (y < 0)
 800cc2c:	f5b3 7f98 	cmp.w	r3, #304	@ 0x130
 800cc30:	bfa8      	it	ge
 800cc32:	f44f 7398 	movge.w	r3, #304	@ 0x130
 800cc36:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
      mark_set_index(index, i, x, y);
 800cc3a:	b292      	uxth	r2, r2
 800cc3c:	b29b      	uxth	r3, r3
 800cc3e:	f7fd fce3 	bl	800a608 <mark_set_index>
    for (i = start; i <= stop; i++)
 800cc42:	b2a9      	uxth	r1, r5
 800cc44:	428f      	cmp	r7, r1
 800cc46:	d2cb      	bcs.n	800cbe0 <draw_all+0x428>
 800cc48:	e795      	b.n	800cb76 <draw_all+0x3be>
    return;

  float scale  = get_trace_scale(3);
  float refpos = HEIGHT - (get_trace_refpos(3)) * GRIDY + 0.5f;
 800cc4a:	eddf 7a40 	vldr	s15, [pc, #256]	@ 800cd4c <draw_all+0x594>
  float scale  = get_trace_scale(3);
 800cc4e:	edd3 6a14 	vldr	s13, [r3, #80]	@ 0x50
  float dscale = GRIDY / scale;

  // --- SWR reference lines (cyan) ---
  const float refs[] = {1.5f, 2.0f, 3.0f};
 800cc52:	4d3f      	ldr	r5, [pc, #252]	@ (800cd50 <draw_all+0x598>)
  float refpos = HEIGHT - (get_trace_refpos(3)) * GRIDY + 0.5f;
 800cc54:	ed93 7a15 	vldr	s14, [r3, #84]	@ 0x54
 800cc58:	ed9f 8a3e 	vldr	s16, [pc, #248]	@ 800cd54 <draw_all+0x59c>
  float dscale = GRIDY / scale;
 800cc5c:	eec7 8aa6 	vdiv.f32	s17, s15, s13
  const float refs[] = {1.5f, 2.0f, 3.0f};
 800cc60:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800cc64:	ac1c      	add	r4, sp, #112	@ 0x70
 800cc66:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  const int nrefs = sizeof(refs) / sizeof(refs[0]);

  lcd_set_foreground(LCD_TRACE_1_COLOR + 1); // match SWR trace color (your "cyan")
 800cc6a:	2007      	movs	r0, #7
 800cc6c:	ae1f      	add	r6, sp, #124	@ 0x7c
  float refpos = HEIGHT - (get_trace_refpos(3)) * GRIDY + 0.5f;
 800cc6e:	eea7 8a67 	vfms.f32	s16, s14, s15
  lcd_set_foreground(LCD_TRACE_1_COLOR + 1); // match SWR trace color (your "cyan")
 800cc72:	f004 fa09 	bl	8011088 <lcd_set_foreground>

  for (int i = 0; i < nrefs; i++)
  {
    float v = refs[i] - 1.0f;            // SWR offset from 1.0 baseline
 800cc76:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
 800cc7a:	eef1 8a68 	vneg.f32	s17, s17
 800cc7e:	ecb4 7a01 	vldmia	r4!, {s14}
 800cc82:	ee37 7a49 	vsub.f32	s14, s14, s18
    int y   = (int)(refpos - v * dscale);
 800cc86:	eef0 7a48 	vmov.f32	s15, s16
 800cc8a:	eee8 7a87 	vfma.f32	s15, s17, s14
 800cc8e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800cc92:	ee17 3a90 	vmov	r3, s15

    if (y >= 0 && y < HEIGHT)
 800cc96:	f5b3 7f98 	cmp.w	r3, #304	@ 0x130
 800cc9a:	f0c1 80ba 	bcc.w	800de12 <draw_all+0x165a>
  for (int i = 0; i < nrefs; i++)
 800cc9e:	42a6      	cmp	r6, r4
 800cca0:	d1ed      	bne.n	800cc7e <draw_all+0x4c6>
  }

  // --- Labels in the left margin (aligned to the same Y) ---
  // If you also want "1.0", add it here:
  // const float labs[] = {1.0f, 1.5f, 2.0f, 3.0f};
  const float labs[] = {1.5f, 2.0f, 3.0f};
 800cca2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800cca6:	ad22      	add	r5, sp, #136	@ 0x88
 800cca8:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  const int nlabs = sizeof(labs) / sizeof(labs[0]);

  lcd_set_font(FONT_SMALL);
  lcd_set_colors(LCD_TRACE_1_COLOR + 1, LCD_BG_COLOR);
 800ccac:	2100      	movs	r1, #0
 800ccae:	2007      	movs	r0, #7
 800ccb0:	f004 fa02 	bl	80110b8 <lcd_set_colors>

  int x = UI_SCALE_REF_X0;               // left margin anchor (OFFSETX - 5)

  for (int i = 0; i < nlabs; i++)
  {
    float v = labs[i] - 1.0f;
 800ccb4:	eeb7 9a00 	vmov.f32	s18, #112	@ 0x3f800000  1.0
 800ccb8:	af25      	add	r7, sp, #148	@ 0x94
    int font_h = sFONT_STR_HEIGHT;
    int y_text = y - (font_h / 2);

    // Clamp so top-most label (often 1.5) never disappears
    if (y_text < 0) y_text = 0;
    if (y_text > (HEIGHT - font_h)) y_text = HEIGHT - font_h;
 800ccba:	f240 1625 	movw	r6, #293	@ 0x125
    float v = labs[i] - 1.0f;
 800ccbe:	ecb5 7a01 	vldmia	r5!, {s14}
 800ccc2:	ee77 6a49 	vsub.f32	s13, s14, s18
    int y   = (int)(refpos - v * dscale);
 800ccc6:	eef0 7a48 	vmov.f32	s15, s16
 800ccca:	eee8 7aa6 	vfma.f32	s15, s17, s13

    lcd_printf(x, y_text, "%.1f", labs[i]);
 800ccce:	ee17 0a10 	vmov	r0, s14
    int y   = (int)(refpos - v * dscale);
 800ccd2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ccd6:	ee17 3a90 	vmov	r3, s15
    int y_text = y - (font_h / 2);
 800ccda:	3b05      	subs	r3, #5
    if (y_text > (HEIGHT - font_h)) y_text = HEIGHT - font_h;
 800ccdc:	42b3      	cmp	r3, r6
 800ccde:	bfa8      	it	ge
 800cce0:	4633      	movge	r3, r6
    if (y_text < 0) y_text = 0;
 800cce2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    lcd_printf(x, y_text, "%.1f", labs[i]);
 800cce6:	b21c      	sxth	r4, r3
 800cce8:	f7f3 fc5a 	bl	80005a0 <__aeabi_f2d>
 800ccec:	4a1a      	ldr	r2, [pc, #104]	@ (800cd58 <draw_all+0x5a0>)
 800ccee:	e9cd 0100 	strd	r0, r1, [sp]
 800ccf2:	4621      	mov	r1, r4
 800ccf4:	200a      	movs	r0, #10
 800ccf6:	f004 fa6f 	bl	80111d8 <lcd_printf>
  for (int i = 0; i < nlabs; i++)
 800ccfa:	42af      	cmp	r7, r5
 800ccfc:	d1df      	bne.n	800ccbe <draw_all+0x506>
}
 800ccfe:	b037      	add	sp, #220	@ 0xdc
 800cd00:	ecbd 8b04 	vpop	{d8-d9}
 800cd04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  char lm0 = lever_mode == LM_FREQ_0 ? S_SARROW[0] : ' ';
 800cd08:	2518      	movs	r5, #24
  char lm1 = lever_mode == LM_FREQ_1 ? S_SARROW[0] : ' ';
 800cd0a:	2620      	movs	r6, #32
 800cd0c:	e60b      	b.n	800c926 <draw_all+0x16e>
    lcd_set_foreground(LCD_FG_COLOR);
 800cd0e:	2001      	movs	r0, #1
 800cd10:	f004 f9ba 	bl	8011088 <lcd_set_foreground>
    lcd_printf(x, y += sFONT_STR_HEIGHT, "s%d", smooth);
 800cd14:	f106 0121 	add.w	r1, r6, #33	@ 0x21
 800cd18:	4a10      	ldr	r2, [pc, #64]	@ (800cd5c <draw_all+0x5a4>)
 800cd1a:	4623      	mov	r3, r4
 800cd1c:	b209      	sxth	r1, r1
 800cd1e:	2000      	movs	r0, #0
 800cd20:	f004 fa5a 	bl	80111d8 <lcd_printf>
 800cd24:	e6cd      	b.n	800cac2 <draw_all+0x30a>
 800cd26:	bf00      	nop
 800cd28:	08013de4 	.word	0x08013de4
 800cd2c:	200089f0 	.word	0x200089f0
 800cd30:	ff3c3c00 	.word	0xff3c3c00
 800cd34:	20000aa8 	.word	0x20000aa8
 800cd38:	20000ad8 	.word	0x20000ad8
 800cd3c:	20006a7c 	.word	0x20006a7c
 800cd40:	20004f54 	.word	0x20004f54
 800cd44:	3fffffe7 	.word	0x3fffffe7
 800cd48:	43180000 	.word	0x43180000
 800cd4c:	42180000 	.word	0x42180000
 800cd50:	08012848 	.word	0x08012848
 800cd54:	43984000 	.word	0x43984000
 800cd58:	08013dec 	.word	0x08013dec
 800cd5c:	08013de8 	.word	0x08013de8
 800cd60:	20006a84 	.word	0x20006a84
  if (w > area_width - x0)
 800cd64:	4bb8      	ldr	r3, [pc, #736]	@ (800d048 <draw_all+0x890>)
 800cd66:	881b      	ldrh	r3, [r3, #0]
 800cd68:	eba3 030b 	sub.w	r3, r3, fp
  if (w <= 0 || h <= 0)
 800cd6c:	2b00      	cmp	r3, #0
  if (w > area_width - x0)
 800cd6e:	930e      	str	r3, [sp, #56]	@ 0x38
  if (w <= 0 || h <= 0)
 800cd70:	f340 8161 	ble.w	800d036 <draw_all+0x87e>
  if (h > area_height - y0)
 800cd74:	4bb5      	ldr	r3, [pc, #724]	@ (800d04c <draw_all+0x894>)
 800cd76:	9a08      	ldr	r2, [sp, #32]
 800cd78:	881b      	ldrh	r3, [r3, #0]
 800cd7a:	1a9b      	subs	r3, r3, r2
  if (w <= 0 || h <= 0)
 800cd7c:	2b00      	cmp	r3, #0
 800cd7e:	f340 815a 	ble.w	800d036 <draw_all+0x87e>
  if (h > area_height - y0)
 800cd82:	2b20      	cmp	r3, #32
 800cd84:	bfa8      	it	ge
 800cd86:	2320      	movge	r3, #32
 800cd88:	461c      	mov	r4, r3
 800cd8a:	930a      	str	r3, [sp, #40]	@ 0x28
  cell_buffer = lcd_get_cell_buffer();
 800cd8c:	f003 ffa6 	bl	8010cdc <lcd_get_cell_buffer>
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800cd90:	4baf      	ldr	r3, [pc, #700]	@ (800d050 <draw_all+0x898>)
  cell_buffer = lcd_get_cell_buffer();
 800cd92:	4ab0      	ldr	r2, [pc, #704]	@ (800d054 <draw_all+0x89c>)
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800cd94:	930f      	str	r3, [sp, #60]	@ 0x3c
  cell_buffer = lcd_get_cell_buffer();
 800cd96:	6010      	str	r0, [r2, #0]
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800cd98:	8bda      	ldrh	r2, [r3, #30]
  int count = h * CELLWIDTH / 8;
 800cd9a:	b223      	sxth	r3, r4
 800cd9c:	0099      	lsls	r1, r3, #2
  cell_buffer = lcd_get_cell_buffer();
 800cd9e:	4680      	mov	r8, r0
  uint32_t clr = GET_PALTETTE_COLOR(LCD_BG_COLOR) | (GET_PALTETTE_COLOR(LCD_BG_COLOR) << 16);
 800cda0:	eb02 4202 	add.w	r2, r2, r2, lsl #16
  uint32_t *p = (uint32_t *)cell_buffer;
 800cda4:	4603      	mov	r3, r0
  } while (--count);
 800cda6:	3901      	subs	r1, #1
    p[0] = clr;
 800cda8:	e9c3 2200 	strd	r2, r2, [r3]
 800cdac:	e9c3 2202 	strd	r2, r2, [r3, #8]
    p += 4;
 800cdb0:	f103 0310 	add.w	r3, r3, #16
  } while (--count);
 800cdb4:	d1f7      	bne.n	800cda6 <draw_all+0x5ee>
 800cdb6:	4ba8      	ldr	r3, [pc, #672]	@ (800d058 <draw_all+0x8a0>)
 800cdb8:	9117      	str	r1, [sp, #92]	@ 0x5c
 800cdba:	468c      	mov	ip, r1
  bool use_smith = false;
 800cdbc:	468a      	mov	sl, r1
 800cdbe:	930c      	str	r3, [sp, #48]	@ 0x30
 800cdc0:	f103 0130 	add.w	r1, r3, #48	@ 0x30
  } while (--count);
 800cdc4:	930b      	str	r3, [sp, #44]	@ 0x2c
      trace_type |= (1 << trace[t].type);
 800cdc6:	2401      	movs	r4, #1
    if (trace[t].enabled)
 800cdc8:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 800cdcc:	b182      	cbz	r2, 800cdf0 <draw_all+0x638>
      trace_type |= (1 << trace[t].type);
 800cdce:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800cdd2:	fa04 f002 	lsl.w	r0, r4, r2
      if (trace[t].type == TRC_SMITH && !ADMIT_MARKER_VALUE(trace[t].smith_format))
 800cdd6:	2a03      	cmp	r2, #3
      trace_type |= (1 << trace[t].type);
 800cdd8:	ea4c 0c00 	orr.w	ip, ip, r0
      if (trace[t].type == TRC_SMITH && !ADMIT_MARKER_VALUE(trace[t].smith_format))
 800cddc:	d108      	bne.n	800cdf0 <draw_all+0x638>
 800cdde:	f893 002b 	ldrb.w	r0, [r3, #43]	@ 0x2b
 800cde2:	f46f 72f0 	mvn.w	r2, #480	@ 0x1e0
 800cde6:	4102      	asrs	r2, r0
 800cde8:	f002 0201 	and.w	r2, r2, #1
 800cdec:	ea4a 0a02 	orr.w	sl, sl, r2
  for (t = 0; t < TRACES_MAX; t++)
 800cdf0:	330c      	adds	r3, #12
 800cdf2:	428b      	cmp	r3, r1
 800cdf4:	d1e8      	bne.n	800cdc8 <draw_all+0x610>
  c = GET_PALTETTE_COLOR(LCD_GRID_COLOR);
 800cdf6:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 800cdf8:	8c54      	ldrh	r4, [r2, #34]	@ 0x22
  if (w > area_width - x0)
 800cdfa:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
  if (trace_type & RECTANGULAR_GRID_MASK)
 800cdfc:	f02c 4340 	bic.w	r3, ip, #3221225472	@ 0xc0000000
  if (w > area_width - x0)
 800ce00:	2a20      	cmp	r2, #32
 800ce02:	bfa8      	it	ge
 800ce04:	2220      	movge	r2, #32
  if (trace_type & RECTANGULAR_GRID_MASK)
 800ce06:	f023 0318 	bic.w	r3, r3, #24
  if (w > area_width - x0)
 800ce0a:	9214      	str	r2, [sp, #80]	@ 0x50
  if (trace_type & RECTANGULAR_GRID_MASK)
 800ce0c:	2b00      	cmp	r3, #0
 800ce0e:	f000 8139 	beq.w	800d084 <draw_all+0x8cc>
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800ce12:	4b92      	ldr	r3, [pc, #584]	@ (800d05c <draw_all+0x8a4>)
  if (x == 0 || x == WIDTH)
 800ce14:	f8cd 8010 	str.w	r8, [sp, #16]
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800ce18:	8818      	ldrh	r0, [r3, #0]
    const int step = VNA_MODE(VNA_MODE_DOT_GRID) ? 2 : 1;
 800ce1a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800ce1c:	8a9b      	ldrh	r3, [r3, #20]
 800ce1e:	f013 0f20 	tst.w	r3, #32
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800ce22:	4b8f      	ldr	r3, [pc, #572]	@ (800d060 <draw_all+0x8a8>)
 800ce24:	f8b3 e000 	ldrh.w	lr, [r3]
        for (y = 0; y < h * CELLWIDTH; y += step * CELLWIDTH)
 800ce28:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800ce2a:	f5a0 7020 	sub.w	r0, r0, #640	@ 0x280
 800ce2e:	4641      	mov	r1, r8
 800ce30:	eb00 10cb 	add.w	r0, r0, fp, lsl #7
  if (x == 0 || x == WIDTH)
 800ce34:	f8dd 8050 	ldr.w	r8, [sp, #80]	@ 0x50
    const int step = VNA_MODE(VNA_MODE_DOT_GRID) ? 2 : 1;
 800ce38:	bf0c      	ite	eq
 800ce3a:	2720      	moveq	r7, #32
 800ce3c:	2740      	movne	r7, #64	@ 0x40
        for (y = 0; y < h * CELLWIDTH; y += step * CELLWIDTH)
 800ce3e:	015e      	lsls	r6, r3, #5
 800ce40:	f1ab 0205 	sub.w	r2, fp, #5
    for (x = 0; x < w; x++)
 800ce44:	2500      	movs	r5, #0
  if (x == 0 || x == WIDTH)
 800ce46:	f240 19c7 	movw	r9, #455	@ 0x1c7
 800ce4a:	e011      	b.n	800ce70 <draw_all+0x6b8>
 800ce4c:	454a      	cmp	r2, r9
 800ce4e:	d014      	beq.n	800ce7a <draw_all+0x6c2>
  return (((x << GRID_BITS) + grid_offset) % grid_width) < (1 << GRID_BITS);
 800ce50:	fbb0 f3fe 	udiv	r3, r0, lr
 800ce54:	fb0e 0313 	mls	r3, lr, r3, r0
      if (rectangular_grid_x(x + x0))
 800ce58:	2b7f      	cmp	r3, #127	@ 0x7f
 800ce5a:	d90e      	bls.n	800ce7a <draw_all+0x6c2>
    for (x = 0; x < w; x++)
 800ce5c:	3501      	adds	r5, #1
 800ce5e:	45a8      	cmp	r8, r5
 800ce60:	f102 0201 	add.w	r2, r2, #1
 800ce64:	f100 0080 	add.w	r0, r0, #128	@ 0x80
 800ce68:	f101 0102 	add.w	r1, r1, #2
 800ce6c:	f340 8108 	ble.w	800d080 <draw_all+0x8c8>
  if ((uint32_t)x > WIDTH)
 800ce70:	f5b2 7fe4 	cmp.w	r2, #456	@ 0x1c8
 800ce74:	d2f2      	bcs.n	800ce5c <draw_all+0x6a4>
  if (x == 0 || x == WIDTH)
 800ce76:	2a00      	cmp	r2, #0
 800ce78:	d1e8      	bne.n	800ce4c <draw_all+0x694>
 800ce7a:	2300      	movs	r3, #0
          cell_buffer[y + x] = c;
 800ce7c:	f821 4013 	strh.w	r4, [r1, r3, lsl #1]
        for (y = 0; y < h * CELLWIDTH; y += step * CELLWIDTH)
 800ce80:	443b      	add	r3, r7
 800ce82:	42b3      	cmp	r3, r6
 800ce84:	dbfa      	blt.n	800ce7c <draw_all+0x6c4>
 800ce86:	e7e9      	b.n	800ce5c <draw_all+0x6a4>
  if (y0 <= marker_area_max())
 800ce88:	f7fe fb32 	bl	800b4f0 <marker_area_max>
 800ce8c:	9b08      	ldr	r3, [sp, #32]
 800ce8e:	4283      	cmp	r3, r0
 800ce90:	f340 835a 	ble.w	800d548 <draw_all+0xd90>
  if (y0 == CELLHEIGHT)
 800ce94:	9b15      	ldr	r3, [sp, #84]	@ 0x54
  if (mla_resonance_locked && (swr > 0.0f) && (swr < 100.0f)) {
 800ce96:	4e73      	ldr	r6, [pc, #460]	@ (800d064 <draw_all+0x8ac>)
  if (y0 == CELLHEIGHT)
 800ce98:	2b01      	cmp	r3, #1
 800ce9a:	f000 8543 	beq.w	800d924 <draw_all+0x116c>
 800ce9e:	ac22      	add	r4, sp, #136	@ 0x88
  const uint32_t bw_hz = (uint32_t)mla_bw_swr2;
 800cea0:	4d71      	ldr	r5, [pc, #452]	@ (800d068 <draw_all+0x8b0>)
 800cea2:	682b      	ldr	r3, [r5, #0]
  if (bw_hz > 0)
 800cea4:	2b00      	cmp	r3, #0
 800cea6:	f000 82e7 	beq.w	800d478 <draw_all+0xcc0>
  const uint32_t bw_khz = (bw_hz + 500U) / 1000U;
 800ceaa:	4a70      	ldr	r2, [pc, #448]	@ (800d06c <draw_all+0x8b4>)
 800ceac:	f503 73fa 	add.w	r3, r3, #500	@ 0x1f4
 800ceb0:	fba2 2303 	umull	r2, r3, r2, r3
    plot_printf(msg, (int)sizeof(msg), "BW2=%u kHz", (unsigned)bw_khz);
 800ceb4:	099b      	lsrs	r3, r3, #6
 800ceb6:	4a6e      	ldr	r2, [pc, #440]	@ (800d070 <draw_all+0x8b8>)
 800ceb8:	2120      	movs	r1, #32
 800ceba:	4620      	mov	r0, r4
 800cebc:	f7f5 ff58 	bl	8002d70 <plot_printf>
  const int text_w = cell_string_width(msg) * 2;
 800cec0:	4620      	mov	r0, r4
 800cec2:	f7fd fccb 	bl	800a85c <cell_string_width>
 800cec6:	0040      	lsls	r0, r0, #1
  if (x >= x0 + CELLWIDTH || x + text_w <= x0)
 800cec8:	f100 0209 	add.w	r2, r0, #9
 800cecc:	4593      	cmp	fp, r2
 800cece:	dc14      	bgt.n	800cefa <draw_all+0x742>
  if (y >= y0 + CELLHEIGHT || y + text_h <= y0)
 800ced0:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800ced2:	2b34      	cmp	r3, #52	@ 0x34
 800ced4:	d811      	bhi.n	800cefa <draw_all+0x742>
  cell_fill_bg_rect(x0, y0, x, y, text_wt, text_ht);
 800ced6:	220a      	movs	r2, #10
 800ced8:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800cedc:	9000      	str	r0, [sp, #0]
 800cede:	f44f 7385 	mov.w	r3, #266	@ 0x10a
 800cee2:	4658      	mov	r0, fp
 800cee4:	f7fe fb3e 	bl	800b564 <cell_fill_bg_rect.constprop.0>
  lcd_set_foreground(LCD_SPEC_INPUT_COLOR);
 800cee8:	200e      	movs	r0, #14
 800ceea:	f004 f8cd 	bl	8011088 <lcd_set_foreground>
  cell_drawstring_big(msg, x - x0, y - y0);
 800ceee:	220a      	movs	r2, #10
 800cef0:	eba2 010b 	sub.w	r1, r2, fp
 800cef4:	4620      	mov	r0, r4
 800cef6:	f7fd fccd 	bl	800a894 <cell_drawstring_big>
  if (mla_resonance_locked && mla_res_freq != 0 && mla_bw_swr2 != 0)
 800cefa:	7833      	ldrb	r3, [r6, #0]
 800cefc:	b133      	cbz	r3, 800cf0c <draw_all+0x754>
 800cefe:	4b5d      	ldr	r3, [pc, #372]	@ (800d074 <draw_all+0x8bc>)
 800cf00:	681b      	ldr	r3, [r3, #0]
 800cf02:	b11b      	cbz	r3, 800cf0c <draw_all+0x754>
 800cf04:	682a      	ldr	r2, [r5, #0]
 800cf06:	2a00      	cmp	r2, #0
 800cf08:	f040 867d 	bne.w	800dc06 <draw_all+0x144e>
    plot_printf(msg, (int)sizeof(msg), "Q=--");
 800cf0c:	4a5a      	ldr	r2, [pc, #360]	@ (800d078 <draw_all+0x8c0>)
 800cf0e:	2118      	movs	r1, #24
 800cf10:	4620      	mov	r0, r4
 800cf12:	f7f5 ff2d 	bl	8002d70 <plot_printf>
  const int text_w = cell_string_width(msg) * 2; // big font = 2x
 800cf16:	4620      	mov	r0, r4
 800cf18:	f7fd fca0 	bl	800a85c <cell_string_width>
 800cf1c:	0045      	lsls	r5, r0, #1
  const int x = CELLOFFSETX + WIDTH - margin - text_w;
 800cf1e:	f5c5 75e2 	rsb	r5, r5, #452	@ 0x1c4
  if (x >= x0 + CELLWIDTH || x + text_w <= x0)
 800cf22:	f10b 031f 	add.w	r3, fp, #31
 800cf26:	429d      	cmp	r5, r3
 800cf28:	dc1c      	bgt.n	800cf64 <draw_all+0x7ac>
 800cf2a:	f5bb 7fe2 	cmp.w	fp, #452	@ 0x1c4
 800cf2e:	f080 84cd 	bcs.w	800d8cc <draw_all+0x1114>
  if (y >= y0 + CELLHEIGHT || y + text_h <= y0)
 800cf32:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800cf34:	2b34      	cmp	r3, #52	@ 0x34
 800cf36:	d815      	bhi.n	800cf64 <draw_all+0x7ac>
  lcd_set_foreground(LCD_SPEC_INPUT_COLOR); // bright green
 800cf38:	200e      	movs	r0, #14
 800cf3a:	f004 f8a5 	bl	8011088 <lcd_set_foreground>
  const int text_wt = cell_string_width(msg) * 2;
 800cf3e:	4620      	mov	r0, r4
 800cf40:	f7fd fc8c 	bl	800a85c <cell_string_width>
 800cf44:	0040      	lsls	r0, r0, #1
  cell_fill_bg_rect(x0, y0, x, y, text_wt, text_ht);
 800cf46:	9000      	str	r0, [sp, #0]
 800cf48:	462a      	mov	r2, r5
 800cf4a:	f44f 7180 	mov.w	r1, #256	@ 0x100
 800cf4e:	4658      	mov	r0, fp
 800cf50:	f44f 7385 	mov.w	r3, #266	@ 0x10a
 800cf54:	f7fe fb06 	bl	800b564 <cell_fill_bg_rect.constprop.0>
  cell_drawstring_big(msg, x - x0, y - y0);
 800cf58:	eba5 010b 	sub.w	r1, r5, fp
 800cf5c:	4620      	mov	r0, r4
 800cf5e:	220a      	movs	r2, #10
 800cf60:	f7fd fc98 	bl	800a894 <cell_drawstring_big>
  if (current_props._measure >= MEASURE_END)
 800cf64:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800cf66:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800cf6a:	2b07      	cmp	r3, #7
 800cf6c:	d811      	bhi.n	800cf92 <draw_all+0x7da>
  measure_cell_cb_t measure_draw_cb = measure[current_props._measure].measure_cell;
 800cf6e:	4a43      	ldr	r2, [pc, #268]	@ (800d07c <draw_all+0x8c4>)
 800cf70:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800cf74:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800cf78:	685c      	ldr	r4, [r3, #4]
  if (measure_draw_cb)
 800cf7a:	b154      	cbz	r4, 800cf92 <draw_all+0x7da>
    lcd_set_colors(LCD_MEASURE_COLOR, LCD_BG_COLOR);
 800cf7c:	2100      	movs	r1, #0
 800cf7e:	2015      	movs	r0, #21
 800cf80:	f004 f89a 	bl	80110b8 <lcd_set_colors>
    measure_draw_cb(STR_MEASURE_X - x0, STR_MEASURE_Y - y0);
 800cf84:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800cf86:	f06f 019a 	mvn.w	r1, #154	@ 0x9a
 800cf8a:	1ac9      	subs	r1, r1, r3
 800cf8c:	f1cb 000f 	rsb	r0, fp, #15
 800cf90:	47a0      	blx	r4
  if ((uint32_t)(x + REFERENCE_WIDTH) >= CELLWIDTH + REFERENCE_WIDTH)
 800cf92:	f1cb 0306 	rsb	r3, fp, #6
 800cf96:	2b25      	cmp	r3, #37	@ 0x25
 800cf98:	d828      	bhi.n	800cfec <draw_all+0x834>
    if (!trace[t].enabled || ((1 << trace[t].type) & (ROUND_GRID_MASK)))
 800cf9a:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800cf9e:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800cfa0:	eeb6 8a00 	vmov.f32	s16, #96	@ 0x3f000000  0.5
 800cfa4:	2406      	movs	r4, #6
    if (!trace[t].enabled || ((1 << trace[t].type) & (ROUND_GRID_MASK)))
 800cfa6:	2518      	movs	r5, #24
 800cfa8:	f896 3028 	ldrb.w	r3, [r6, #40]	@ 0x28
 800cfac:	b1c3      	cbz	r3, 800cfe0 <draw_all+0x828>
 800cfae:	f896 3029 	ldrb.w	r3, [r6, #41]	@ 0x29
 800cfb2:	fa45 f303 	asr.w	r3, r5, r3
 800cfb6:	f013 0901 	ands.w	r9, r3, #1
 800cfba:	d111      	bne.n	800cfe0 <draw_all+0x828>
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800cfbc:	ed96 7a0c 	vldr	s14, [r6, #48]	@ 0x30
 800cfc0:	eef0 7a48 	vmov.f32	s15, s16
 800cfc4:	eee7 7a28 	vfma.f32	s15, s14, s17
 800cfc8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800cfcc:	ee17 7a90 	vmov	r7, s15
 800cfd0:	f5c7 7798 	rsb	r7, r7, #304	@ 0x130
 800cfd4:	eba7 0708 	sub.w	r7, r7, r8
    if ((uint32_t)(y + REFERENCE_HEIGHT) < CELLHEIGHT + REFERENCE_HEIGHT)
 800cfd8:	1cfb      	adds	r3, r7, #3
 800cfda:	2b24      	cmp	r3, #36	@ 0x24
 800cfdc:	f240 82a7 	bls.w	800d52e <draw_all+0xd76>
  for (int t = 0; t < TRACES_MAX; t++)
 800cfe0:	3401      	adds	r4, #1
 800cfe2:	b2a4      	uxth	r4, r4
 800cfe4:	2c0a      	cmp	r4, #10
 800cfe6:	f106 060c 	add.w	r6, r6, #12
 800cfea:	d1dd      	bne.n	800cfa8 <draw_all+0x7f0>
  if (w < CELLWIDTH)
 800cfec:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 800cfee:	2b1f      	cmp	r3, #31
 800cff0:	dc1a      	bgt.n	800d028 <draw_all+0x870>
    pixel_t *src = cell_buffer + CELLWIDTH;
 800cff2:	4b18      	ldr	r3, [pc, #96]	@ (800d054 <draw_all+0x89c>)
    for (y = h; --y; src += CELLWIDTH - w)
 800cff4:	990a      	ldr	r1, [sp, #40]	@ 0x28
    pixel_t *src = cell_buffer + CELLWIDTH;
 800cff6:	681c      	ldr	r4, [r3, #0]
    pixel_t *dst = cell_buffer + w;
 800cff8:	9a14      	ldr	r2, [sp, #80]	@ 0x50
    for (y = h; --y; src += CELLWIDTH - w)
 800cffa:	1e4d      	subs	r5, r1, #1
    pixel_t *src = cell_buffer + CELLWIDTH;
 800cffc:	f104 0340 	add.w	r3, r4, #64	@ 0x40
    pixel_t *dst = cell_buffer + w;
 800d000:	ea4f 0642 	mov.w	r6, r2, lsl #1
 800d004:	eb04 0442 	add.w	r4, r4, r2, lsl #1
    for (y = h; --y; src += CELLWIDTH - w)
 800d008:	d00e      	beq.n	800d028 <draw_all+0x870>
 800d00a:	f1c2 0720 	rsb	r7, r2, #32
 800d00e:	007f      	lsls	r7, r7, #1
      for (x = w; x--;)
 800d010:	1ea2      	subs	r2, r4, #2
 800d012:	1998      	adds	r0, r3, r6
        *dst++ = *src++;
 800d014:	f833 1b02 	ldrh.w	r1, [r3], #2
 800d018:	f822 1f02 	strh.w	r1, [r2, #2]!
      for (x = w; x--;)
 800d01c:	4283      	cmp	r3, r0
 800d01e:	d1f9      	bne.n	800d014 <draw_all+0x85c>
    for (y = h; --y; src += CELLWIDTH - w)
 800d020:	3d01      	subs	r5, #1
 800d022:	4434      	add	r4, r6
 800d024:	443b      	add	r3, r7
 800d026:	d1f3      	bne.n	800d010 <draw_all+0x858>
  lcd_bulk_continue(OFFSETX + x0, OFFSETY + y0, w, h);
 800d028:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800d02a:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 800d02c:	9908      	ldr	r1, [sp, #32]
 800d02e:	f10b 000f 	add.w	r0, fp, #15
 800d032:	f003 ff19 	bl	8010e68 <lcd_bulk_continue>
    for (m = 0; update_map && m < w; update_map >>= 1, m++)
 800d036:	9b07      	ldr	r3, [sp, #28]
 800d038:	085b      	lsrs	r3, r3, #1
 800d03a:	f10b 0b20 	add.w	fp, fp, #32
 800d03e:	9307      	str	r3, [sp, #28]
 800d040:	f47f ac40 	bne.w	800c8c4 <draw_all+0x10c>
 800d044:	e44c      	b.n	800c8e0 <draw_all+0x128>
 800d046:	bf00      	nop
 800d048:	200003da 	.word	0x200003da
 800d04c:	200003d8 	.word	0x200003d8
 800d050:	20000318 	.word	0x20000318
 800d054:	200089ec 	.word	0x200089ec
 800d058:	20000aa8 	.word	0x20000aa8
 800d05c:	20006a80 	.word	0x20006a80
 800d060:	20006a7e 	.word	0x20006a7e
 800d064:	2000687d 	.word	0x2000687d
 800d068:	20006870 	.word	0x20006870
 800d06c:	10624dd3 	.word	0x10624dd3
 800d070:	08013d58 	.word	0x08013d58
 800d074:	20006884 	.word	0x20006884
 800d078:	08013d78 	.word	0x08013d78
 800d07c:	080161cc 	.word	0x080161cc
 800d080:	f8dd 8010 	ldr.w	r8, [sp, #16]
  if (trace_type & (1 << TRC_SMITH))
 800d084:	f01c 0908 	ands.w	r9, ip, #8
 800d088:	f000 81fc 	beq.w	800d484 <draw_all+0xccc>
    if (use_smith)
 800d08c:	f1ba 0f00 	cmp.w	sl, #0
 800d090:	f000 83fa 	beq.w	800d888 <draw_all+0x10d0>
  for (y = 0; y < h; y++)
 800d094:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800d096:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 800d09a:	f8cd 8010 	str.w	r8, [sp, #16]
 800d09e:	4646      	mov	r6, r8
 800d0a0:	2300      	movs	r3, #0
 800d0a2:	f1ab 05e8 	sub.w	r5, fp, #232	@ 0xe8
 800d0a6:	f8cd b040 	str.w	fp, [sp, #64]	@ 0x40
 800d0aa:	f102 0a53 	add.w	sl, r2, #83	@ 0x53
 800d0ae:	4698      	mov	r8, r3
 800d0b0:	46b3      	mov	fp, r6
      if (smith_grid(x + x0, y + y0))
 800d0b2:	eb0a 0708 	add.w	r7, sl, r8
    for (x = 0; x < w; x++)
 800d0b6:	2600      	movs	r6, #0
      if (smith_grid(x + x0, y + y0))
 800d0b8:	4639      	mov	r1, r7
 800d0ba:	19a8      	adds	r0, r5, r6
 800d0bc:	f7fd f9ba 	bl	800a434 <smith_grid>
 800d0c0:	b108      	cbz	r0, 800d0c6 <draw_all+0x90e>
        cell_buffer[y * CELLWIDTH + x] = color;
 800d0c2:	f82b 4016 	strh.w	r4, [fp, r6, lsl #1]
    for (x = 0; x < w; x++)
 800d0c6:	3601      	adds	r6, #1
 800d0c8:	45b1      	cmp	r9, r6
 800d0ca:	dcf5      	bgt.n	800d0b8 <draw_all+0x900>
  for (y = 0; y < h; y++)
 800d0cc:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800d0ce:	f108 0801 	add.w	r8, r8, #1
 800d0d2:	4543      	cmp	r3, r8
 800d0d4:	f10b 0b40 	add.w	fp, fp, #64	@ 0x40
 800d0d8:	dceb      	bgt.n	800d0b2 <draw_all+0x8fa>
 800d0da:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800d0de:	f8dd b040 	ldr.w	fp, [sp, #64]	@ 0x40
    if (((1 << trace[t].type) & RECTANGULAR_GRID_MASK) && !enabled_store_trace && sweep_points > 30)
 800d0e2:	4bb2      	ldr	r3, [pc, #712]	@ (800d3ac <draw_all+0xbf4>)
 800d0e4:	4ab2      	ldr	r2, [pc, #712]	@ (800d3b0 <draw_all+0xbf8>)
 800d0e6:	f893 a000 	ldrb.w	sl, [r3]
    if (!needProcessTrace(t))
 800d0ea:	f01a 0f01 	tst.w	sl, #1
 800d0ee:	f000 85a3 	beq.w	800dc38 <draw_all+0x1480>
  int head = 0, tail = sweep_points;
 800d0f2:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800d0f4:	f8b3 901a 	ldrh.w	r9, [r3, #26]
    c = GET_PALTETTE_COLOR(LCD_TRACE_1_COLOR + t);
 800d0f8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
      i1 = sweep_points - 1;
 800d0fa:	f109 39ff 	add.w	r9, r9, #4294967295
    for (int i = i0; i < i1; i++)
 800d0fe:	f1b9 0f00 	cmp.w	r9, #0
    c = GET_PALTETTE_COLOR(LCD_TRACE_1_COLOR + t);
 800d102:	f8b3 e032 	ldrh.w	lr, [r3, #50]	@ 0x32
    for (int i = i0; i < i1; i++)
 800d106:	f340 8597 	ble.w	800dc38 <draw_all+0x1480>
 800d10a:	4baa      	ldr	r3, [pc, #680]	@ (800d3b4 <draw_all+0xbfc>)
    int i0 = 0, i1 = 0;
 800d10c:	f04f 0c00 	mov.w	ip, #0
    for (int i = i0; i < i1; i++)
 800d110:	2004      	movs	r0, #4
 800d112:	eb02 0989 	add.w	r9, r2, r9, lsl #2
 800d116:	e9cd a010 	strd	sl, r0, [sp, #64]	@ 0x40
 800d11a:	e9cd 3212 	strd	r3, r2, [sp, #72]	@ 0x48
 800d11e:	f8cd 9010 	str.w	r9, [sp, #16]
 800d122:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800d126:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
      int x1 = index[i].x - x0;
 800d12a:	f8bc 3000 	ldrh.w	r3, [ip]
      int y1 = index[i].y - y0;
 800d12e:	f8bc 0002 	ldrh.w	r0, [ip, #2]
      int x2 = index[i + 1].x - x0;
 800d132:	f8bc a004 	ldrh.w	sl, [ip, #4]
      int y2 = index[i + 1].y - y0;
 800d136:	f8bc 6006 	ldrh.w	r6, [ip, #6]
  if (x0 < 0 && x1 < 0)
 800d13a:	ebb3 050b 	subs.w	r5, r3, fp
      int y1 = index[i].y - y0;
 800d13e:	eba0 0709 	sub.w	r7, r0, r9
      int x2 = index[i + 1].x - x0;
 800d142:	ebaa 020b 	sub.w	r2, sl, fp
      int y2 = index[i + 1].y - y0;
 800d146:	eba6 0109 	sub.w	r1, r6, r9
  if (x0 < 0 && x1 < 0)
 800d14a:	f100 8089 	bmi.w	800d260 <draw_all+0xaa8>
  if (y0 < 0 && y1 < 0)
 800d14e:	2f00      	cmp	r7, #0
 800d150:	f2c0 80a8 	blt.w	800d2a4 <draw_all+0xaec>
  if (x0 >= CELLWIDTH && x1 >= CELLWIDTH)
 800d154:	2d1f      	cmp	r5, #31
 800d156:	f340 80d2 	ble.w	800d2fe <draw_all+0xb46>
 800d15a:	2a1f      	cmp	r2, #31
 800d15c:	dc34      	bgt.n	800d1c8 <draw_all+0xa10>
  if (y0 >= CELLHEIGHT && y1 >= CELLHEIGHT)
 800d15e:	2f1f      	cmp	r7, #31
 800d160:	f340 80a7 	ble.w	800d2b2 <draw_all+0xafa>
 800d164:	291f      	cmp	r1, #31
 800d166:	dc2f      	bgt.n	800d1c8 <draw_all+0xa10>
  if (y1 < y0)
 800d168:	42b0      	cmp	r0, r6
 800d16a:	f240 8084 	bls.w	800d276 <draw_all+0xabe>
  int dx = (x0 - x1), sx = 1;
 800d16e:	ebaa 0403 	sub.w	r4, sl, r3
 800d172:	f04f 0a01 	mov.w	sl, #1
  int dy = (y1 - y0);
 800d176:	1a78      	subs	r0, r7, r1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d178:	42e0      	cmn	r0, r4
 800d17a:	f100 80aa 	bmi.w	800d2d2 <draw_all+0xb1a>
 800d17e:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
 800d182:	105b      	asrs	r3, r3, #1
 800d184:	425b      	negs	r3, r3
  if (y0 < 0)
 800d186:	2900      	cmp	r1, #0
 800d188:	db5d      	blt.n	800d246 <draw_all+0xa8e>
  y0 *= CELLWIDTH;
 800d18a:	0149      	lsls	r1, r1, #5
      cell_buffer[y0 + x0] = c;
 800d18c:	1856      	adds	r6, r2, r1
    if ((uint32_t)x0 < CELLWIDTH)
 800d18e:	2a1f      	cmp	r2, #31
    if (x0 + y0 == y1 + x1)
 800d190:	eb05 1547 	add.w	r5, r5, r7, lsl #5
      cell_buffer[y0 + x0] = c;
 800d194:	bf98      	it	ls
 800d196:	f828 e016 	strhls.w	lr, [r8, r6, lsl #1]
    if (x0 + y0 == y1 + x1)
 800d19a:	42b5      	cmp	r5, r6
 800d19c:	d014      	beq.n	800d1c8 <draw_all+0xa10>
    if (e2 > dx)
 800d19e:	42a3      	cmp	r3, r4
      err -= dy;
 800d1a0:	bfc6      	itte	gt
 800d1a2:	1a1e      	subgt	r6, r3, r0
      x0 += sx;
 800d1a4:	4452      	addgt	r2, sl
 800d1a6:	461e      	movle	r6, r3
    if (e2 < dy)
 800d1a8:	4283      	cmp	r3, r0
 800d1aa:	da05      	bge.n	800d1b8 <draw_all+0xa00>
      y0 += CELLWIDTH;
 800d1ac:	3120      	adds	r1, #32
      if (y0 >= CELLHEIGHT * CELLWIDTH)
 800d1ae:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
      err -= dx;
 800d1b2:	eba6 0604 	sub.w	r6, r6, r4
      if (y0 >= CELLHEIGHT * CELLWIDTH)
 800d1b6:	da07      	bge.n	800d1c8 <draw_all+0xa10>
 800d1b8:	4633      	mov	r3, r6
      cell_buffer[y0 + x0] = c;
 800d1ba:	1856      	adds	r6, r2, r1
    if ((uint32_t)x0 < CELLWIDTH)
 800d1bc:	2a1f      	cmp	r2, #31
      cell_buffer[y0 + x0] = c;
 800d1be:	bf98      	it	ls
 800d1c0:	f828 e016 	strhls.w	lr, [r8, r6, lsl #1]
    if (x0 + y0 == y1 + x1)
 800d1c4:	42b5      	cmp	r5, r6
 800d1c6:	d1ea      	bne.n	800d19e <draw_all+0x9e6>
    for (int i = i0; i < i1; i++)
 800d1c8:	9b04      	ldr	r3, [sp, #16]
 800d1ca:	f10c 0c04 	add.w	ip, ip, #4
 800d1ce:	459c      	cmp	ip, r3
 800d1d0:	d1ab      	bne.n	800d12a <draw_all+0x972>
 800d1d2:	e9dd a010 	ldrd	sl, r0, [sp, #64]	@ 0x40
 800d1d6:	e9dd 3212 	ldrd	r3, r2, [sp, #72]	@ 0x48
  for (t = TRACE_INDEX_COUNT - 1; t >= 0; t--)
 800d1da:	3801      	subs	r0, #1
 800d1dc:	1c44      	adds	r4, r0, #1
 800d1de:	f1a3 030c 	sub.w	r3, r3, #12
 800d1e2:	f2a2 6244 	subw	r2, r2, #1604	@ 0x644
 800d1e6:	f000 8098 	beq.w	800d31a <draw_all+0xb62>
    if (!needProcessTrace(t))
 800d1ea:	f893 1058 	ldrb.w	r1, [r3, #88]	@ 0x58
 800d1ee:	2900      	cmp	r1, #0
 800d1f0:	d0f3      	beq.n	800d1da <draw_all+0xa22>
    if (((1 << trace[t].type) & RECTANGULAR_GRID_MASK) && !enabled_store_trace && sweep_points > 30)
 800d1f2:	f893 4059 	ldrb.w	r4, [r3, #89]	@ 0x59
 800d1f6:	4970      	ldr	r1, [pc, #448]	@ (800d3b8 <draw_all+0xc00>)
 800d1f8:	4121      	asrs	r1, r4
    c = GET_PALTETTE_COLOR(LCD_TRACE_1_COLOR + t);
 800d1fa:	4c70      	ldr	r4, [pc, #448]	@ (800d3bc <draw_all+0xc04>)
 800d1fc:	f834 e010 	ldrh.w	lr, [r4, r0, lsl #1]
    if (((1 << trace[t].type) & RECTANGULAR_GRID_MASK) && !enabled_store_trace && sweep_points > 30)
 800d200:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
 800d202:	07c9      	lsls	r1, r1, #31
 800d204:	8b66      	ldrh	r6, [r4, #26]
 800d206:	d505      	bpl.n	800d214 <draw_all+0xa5c>
 800d208:	f1ba 0f00 	cmp.w	sl, #0
 800d20c:	d102      	bne.n	800d214 <draw_all+0xa5c>
 800d20e:	2e1e      	cmp	r6, #30
 800d210:	f200 83fe 	bhi.w	800da10 <draw_all+0x1258>
      i1 = sweep_points - 1;
 800d214:	f106 39ff 	add.w	r9, r6, #4294967295
    int i0 = 0, i1 = 0;
 800d218:	f04f 0c00 	mov.w	ip, #0
    for (int i = i0; i < i1; i++)
 800d21c:	45cc      	cmp	ip, r9
 800d21e:	f6ff af78 	blt.w	800d112 <draw_all+0x95a>
 800d222:	e7da      	b.n	800d1da <draw_all+0xa22>
  int dy = (y1 - y0);
 800d224:	1a30      	subs	r0, r6, r0
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d226:	4613      	mov	r3, r2
 800d228:	42e0      	cmn	r0, r4
 800d22a:	462a      	mov	r2, r5
 800d22c:	461d      	mov	r5, r3
 800d22e:	bf4c      	ite	mi
 800d230:	eb04 73d4 	addmi.w	r3, r4, r4, lsr #31
 800d234:	eb00 73d0 	addpl.w	r3, r0, r0, lsr #31
 800d238:	463e      	mov	r6, r7
 800d23a:	105b      	asrs	r3, r3, #1
 800d23c:	460f      	mov	r7, r1
 800d23e:	425b      	negs	r3, r3
 800d240:	4631      	mov	r1, r6
  int dx = (x0 - x1), sx = 1;
 800d242:	f04f 0a01 	mov.w	sl, #1
      if (e2 > dx)
 800d246:	42a3      	cmp	r3, r4
    sx = -sx;
 800d248:	461e      	mov	r6, r3
        x0 += sx;
 800d24a:	bfc4      	itt	gt
 800d24c:	4452      	addgt	r2, sl
        err -= dy;
 800d24e:	1a1b      	subgt	r3, r3, r0
      if (e2 < dy)
 800d250:	4286      	cmp	r6, r0
 800d252:	daf8      	bge.n	800d246 <draw_all+0xa8e>
        if (y0 == 0)
 800d254:	1c4e      	adds	r6, r1, #1
        err -= dx;
 800d256:	eba3 0304 	sub.w	r3, r3, r4
        if (y0 == 0)
 800d25a:	d03f      	beq.n	800d2dc <draw_all+0xb24>
        y0++;
 800d25c:	3101      	adds	r1, #1
 800d25e:	e7f2      	b.n	800d246 <draw_all+0xa8e>
  if (x0 < 0 && x1 < 0)
 800d260:	2a00      	cmp	r2, #0
 800d262:	dbb1      	blt.n	800d1c8 <draw_all+0xa10>
  if (y0 < 0 && y1 < 0)
 800d264:	2f00      	cmp	r7, #0
 800d266:	db3b      	blt.n	800d2e0 <draw_all+0xb28>
  if (y0 >= CELLHEIGHT && y1 >= CELLHEIGHT)
 800d268:	2f1f      	cmp	r7, #31
 800d26a:	f340 80de 	ble.w	800d42a <draw_all+0xc72>
 800d26e:	291f      	cmp	r1, #31
 800d270:	dcaa      	bgt.n	800d1c8 <draw_all+0xa10>
  if (y1 < y0)
 800d272:	42b0      	cmp	r0, r6
 800d274:	d826      	bhi.n	800d2c4 <draw_all+0xb0c>
  int dx = (x0 - x1), sx = 1;
 800d276:	eba3 040a 	sub.w	r4, r3, sl
  if (dx > 0)
 800d27a:	2c00      	cmp	r4, #0
 800d27c:	f340 80c7 	ble.w	800d40e <draw_all+0xc56>
    dx = -dx;
 800d280:	ebaa 0403 	sub.w	r4, sl, r3
  int dy = (y1 - y0);
 800d284:	1a30      	subs	r0, r6, r0
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d286:	4613      	mov	r3, r2
 800d288:	463e      	mov	r6, r7
 800d28a:	42e0      	cmn	r0, r4
 800d28c:	460f      	mov	r7, r1
 800d28e:	462a      	mov	r2, r5
 800d290:	4631      	mov	r1, r6
 800d292:	461d      	mov	r5, r3
 800d294:	d42c      	bmi.n	800d2f0 <draw_all+0xb38>
 800d296:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
 800d29a:	105b      	asrs	r3, r3, #1
 800d29c:	425b      	negs	r3, r3
    sx = -sx;
 800d29e:	f04f 3aff 	mov.w	sl, #4294967295
 800d2a2:	e772      	b.n	800d18a <draw_all+0x9d2>
  if (y0 < 0 && y1 < 0)
 800d2a4:	2900      	cmp	r1, #0
 800d2a6:	db8f      	blt.n	800d1c8 <draw_all+0xa10>
  if (x0 >= CELLWIDTH && x1 >= CELLWIDTH)
 800d2a8:	2d1f      	cmp	r5, #31
 800d2aa:	f340 80cc 	ble.w	800d446 <draw_all+0xc8e>
 800d2ae:	2a1f      	cmp	r2, #31
 800d2b0:	dc8a      	bgt.n	800d1c8 <draw_all+0xa10>
  if (y1 < y0)
 800d2b2:	42b0      	cmp	r0, r6
 800d2b4:	f63f af5b 	bhi.w	800d16e <draw_all+0x9b6>
 800d2b8:	4638      	mov	r0, r7
 800d2ba:	4613      	mov	r3, r2
 800d2bc:	460f      	mov	r7, r1
 800d2be:	462a      	mov	r2, r5
 800d2c0:	4601      	mov	r1, r0
 800d2c2:	461d      	mov	r5, r3
    dx = -dx;
 800d2c4:	1aac      	subs	r4, r5, r2
  int dy = (y1 - y0);
 800d2c6:	1a78      	subs	r0, r7, r1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d2c8:	42e0      	cmn	r0, r4
    sx = -sx;
 800d2ca:	f04f 3aff 	mov.w	sl, #4294967295
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d2ce:	f57f af56 	bpl.w	800d17e <draw_all+0x9c6>
 800d2d2:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
 800d2d6:	105b      	asrs	r3, r3, #1
 800d2d8:	425b      	negs	r3, r3
 800d2da:	e754      	b.n	800d186 <draw_all+0x9ce>
 800d2dc:	2100      	movs	r1, #0
 800d2de:	e755      	b.n	800d18c <draw_all+0x9d4>
  if (y0 < 0 && y1 < 0)
 800d2e0:	2900      	cmp	r1, #0
 800d2e2:	f6ff af71 	blt.w	800d1c8 <draw_all+0xa10>
  if (y1 < y0)
 800d2e6:	42b0      	cmp	r0, r6
    dx = -dx;
 800d2e8:	eba3 040a 	sub.w	r4, r3, sl
  if (y1 < y0)
 800d2ec:	d99a      	bls.n	800d224 <draw_all+0xa6c>
  int dy = (y1 - y0);
 800d2ee:	1b80      	subs	r0, r0, r6
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d2f0:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
 800d2f4:	105b      	asrs	r3, r3, #1
 800d2f6:	425b      	negs	r3, r3
    sx = -sx;
 800d2f8:	f04f 3aff 	mov.w	sl, #4294967295
 800d2fc:	e745      	b.n	800d18a <draw_all+0x9d2>
  if (y0 >= CELLHEIGHT && y1 >= CELLHEIGHT)
 800d2fe:	2f1f      	cmp	r7, #31
 800d300:	f340 80b0 	ble.w	800d464 <draw_all+0xcac>
 800d304:	291f      	cmp	r1, #31
 800d306:	f73f af5f 	bgt.w	800d1c8 <draw_all+0xa10>
  if (y1 < y0)
 800d30a:	42b0      	cmp	r0, r6
 800d30c:	d9b3      	bls.n	800d276 <draw_all+0xabe>
  int dx = (x0 - x1), sx = 1;
 800d30e:	1b54      	subs	r4, r2, r5
  if (dx > 0)
 800d310:	2c00      	cmp	r4, #0
 800d312:	dcd7      	bgt.n	800d2c4 <draw_all+0xb0c>
  int dx = (x0 - x1), sx = 1;
 800d314:	f04f 0a01 	mov.w	sl, #1
 800d318:	e72d      	b.n	800d176 <draw_all+0x9be>
  if (VNA_MODE(VNA_MODE_SHOW_GRID) && x0 > (GRID_X_TEXT - CELLWIDTH))
 800d31a:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800d31c:	8a9b      	ldrh	r3, [r3, #20]
 800d31e:	06de      	lsls	r6, r3, #27
 800d320:	d503      	bpl.n	800d32a <draw_all+0xb72>
 800d322:	f5bb 7fc2 	cmp.w	fp, #388	@ 0x184
 800d326:	f200 8394 	bhi.w	800da52 <draw_all+0x129a>
  for (int i = 0; i < MARKERS_MAX; i++)
 800d32a:	f8df 90a4 	ldr.w	r9, [pc, #164]	@ 800d3d0 <draw_all+0xc18>
 800d32e:	4e21      	ldr	r6, [pc, #132]	@ (800d3b4 <draw_all+0xbfc>)
 800d330:	46ca      	mov	sl, r9
 800d332:	e007      	b.n	800d344 <draw_all+0xb8c>
 800d334:	4b22      	ldr	r3, [pc, #136]	@ (800d3c0 <draw_all+0xc08>)
 800d336:	f10a 0a38 	add.w	sl, sl, #56	@ 0x38
 800d33a:	459a      	cmp	sl, r3
 800d33c:	f106 0608 	add.w	r6, r6, #8
 800d340:	f43f ada2 	beq.w	800ce88 <draw_all+0x6d0>
    if (!markers[i].enabled)
 800d344:	f896 3058 	ldrb.w	r3, [r6, #88]	@ 0x58
 800d348:	2b00      	cmp	r3, #0
 800d34a:	d0f3      	beq.n	800d334 <draw_all+0xb7c>
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800d34c:	f8b6 505a 	ldrh.w	r5, [r6, #90]	@ 0x5a
 800d350:	4b1c      	ldr	r3, [pc, #112]	@ (800d3c4 <draw_all+0xc0c>)
        marker = MARKER_RBITMAP(i + 1);
 800d352:	f8dd 8030 	ldr.w	r8, [sp, #48]	@ 0x30
 800d356:	9604      	str	r6, [sp, #16]
        marker = MARKER_BITMAP(i + 1);
 800d358:	f1aa 091c 	sub.w	r9, sl, #28
 800d35c:	eb03 0585 	add.w	r5, r3, r5, lsl #2
        marker = MARKER_RBITMAP(i + 1);
 800d360:	2406      	movs	r4, #6
 800d362:	464e      	mov	r6, r9
      if (!trace[t].enabled)
 800d364:	f898 3028 	ldrb.w	r3, [r8, #40]	@ 0x28
 800d368:	b193      	cbz	r3, 800d390 <draw_all+0xbd8>
      if (index[mk_idx].y < MARKER_HEIGHT * 2)
 800d36a:	886a      	ldrh	r2, [r5, #2]
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800d36c:	882f      	ldrh	r7, [r5, #0]
        y = index[mk_idx].y - y0 + 1;
 800d36e:	9b08      	ldr	r3, [sp, #32]
      if (index[mk_idx].y < MARKER_HEIGHT * 2)
 800d370:	2a1b      	cmp	r2, #27
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800d372:	eba7 070b 	sub.w	r7, r7, fp
        y = index[mk_idx].y - y0 + 1;
 800d376:	eba2 0303 	sub.w	r3, r2, r3
      if (index[mk_idx].y < MARKER_HEIGHT * 2)
 800d37a:	d813      	bhi.n	800d3a4 <draw_all+0xbec>
        plate = MARKER_RBITMAP(0);
 800d37c:	4a12      	ldr	r2, [pc, #72]	@ (800d3c8 <draw_all+0xc10>)
        y = index[mk_idx].y - y0 + 1;
 800d37e:	3301      	adds	r3, #1
        marker = MARKER_RBITMAP(i + 1);
 800d380:	46d1      	mov	r9, sl
      if ((uint32_t)(x + MARKER_WIDTH) < (CELLWIDTH + MARKER_WIDTH) &&
 800d382:	1db9      	adds	r1, r7, #6
 800d384:	292a      	cmp	r1, #42	@ 0x2a
          (uint32_t)(y + MARKER_HEIGHT) < (CELLHEIGHT + MARKER_HEIGHT))
 800d386:	f103 000e 	add.w	r0, r3, #14
      if ((uint32_t)(x + MARKER_WIDTH) < (CELLWIDTH + MARKER_WIDTH) &&
 800d38a:	d801      	bhi.n	800d390 <draw_all+0xbd8>
 800d38c:	282d      	cmp	r0, #45	@ 0x2d
 800d38e:	d921      	bls.n	800d3d4 <draw_all+0xc1c>
    for (t = 0; t < TRACES_MAX; t++)
 800d390:	3401      	adds	r4, #1
 800d392:	b2a4      	uxth	r4, r4
 800d394:	2c0a      	cmp	r4, #10
 800d396:	f108 080c 	add.w	r8, r8, #12
 800d39a:	f205 6544 	addw	r5, r5, #1604	@ 0x644
 800d39e:	d1e1      	bne.n	800d364 <draw_all+0xbac>
 800d3a0:	9e04      	ldr	r6, [sp, #16]
 800d3a2:	e7c7      	b.n	800d334 <draw_all+0xb7c>
        plate = MARKER_BITMAP(0);
 800d3a4:	4a09      	ldr	r2, [pc, #36]	@ (800d3cc <draw_all+0xc14>)
        y = index[mk_idx].y - y0 - Y_MARKER_OFFSET;
 800d3a6:	3b0e      	subs	r3, #14
        marker = MARKER_BITMAP(i + 1);
 800d3a8:	46b1      	mov	r9, r6
 800d3aa:	e7ea      	b.n	800d382 <draw_all+0xbca>
 800d3ac:	20006a7d 	.word	0x20006a7d
 800d3b0:	20008394 	.word	0x20008394
 800d3b4:	20000aa8 	.word	0x20000aa8
 800d3b8:	3fffffe7 	.word	0x3fffffe7
 800d3bc:	20000342 	.word	0x20000342
 800d3c0:	08016450 	.word	0x08016450
 800d3c4:	20006a84 	.word	0x20006a84
 800d3c8:	08016258 	.word	0x08016258
 800d3cc:	0801623c 	.word	0x0801623c
 800d3d0:	08016290 	.word	0x08016290
        lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d3d4:	4620      	mov	r0, r4
 800d3d6:	e9cd 3210 	strd	r3, r2, [sp, #64]	@ 0x40
      x = index[mk_idx].x - x0 - X_MARKER_OFFSET;
 800d3da:	3f05      	subs	r7, #5
        lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d3dc:	f003 fe54 	bl	8011088 <lcd_set_foreground>
        cell_blit_bitmap(x, y, MARKER_WIDTH, MARKER_HEIGHT, plate);
 800d3e0:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 800d3e2:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 800d3e4:	9200      	str	r2, [sp, #0]
 800d3e6:	b23f      	sxth	r7, r7
 800d3e8:	b219      	sxth	r1, r3
 800d3ea:	220b      	movs	r2, #11
 800d3ec:	230e      	movs	r3, #14
 800d3ee:	4638      	mov	r0, r7
 800d3f0:	9110      	str	r1, [sp, #64]	@ 0x40
 800d3f2:	f7fd f87d 	bl	800a4f0 <cell_blit_bitmap>
        lcd_set_foreground(LCD_TXT_SHADOW_COLOR);
 800d3f6:	201a      	movs	r0, #26
 800d3f8:	f003 fe46 	bl	8011088 <lcd_set_foreground>
        cell_blit_bitmap(x, y, MARKER_WIDTH, MARKER_HEIGHT, marker);
 800d3fc:	9910      	ldr	r1, [sp, #64]	@ 0x40
 800d3fe:	f8cd 9000 	str.w	r9, [sp]
 800d402:	230e      	movs	r3, #14
 800d404:	4638      	mov	r0, r7
 800d406:	220b      	movs	r2, #11
 800d408:	f7fd f872 	bl	800a4f0 <cell_blit_bitmap>
 800d40c:	e7c0      	b.n	800d390 <draw_all+0xbd8>
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d40e:	4613      	mov	r3, r2
 800d410:	462a      	mov	r2, r5
 800d412:	461d      	mov	r5, r3
 800d414:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
  int dy = (y1 - y0);
 800d418:	1a30      	subs	r0, r6, r0
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d41a:	105b      	asrs	r3, r3, #1
 800d41c:	463e      	mov	r6, r7
 800d41e:	425b      	negs	r3, r3
 800d420:	460f      	mov	r7, r1
  int dx = (x0 - x1), sx = 1;
 800d422:	f04f 0a01 	mov.w	sl, #1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d426:	4631      	mov	r1, r6
 800d428:	e6af      	b.n	800d18a <draw_all+0x9d2>
  if (y1 < y0)
 800d42a:	42b0      	cmp	r0, r6
 800d42c:	f63f af4a 	bhi.w	800d2c4 <draw_all+0xb0c>
  int dx = (x0 - x1), sx = 1;
 800d430:	eba3 040a 	sub.w	r4, r3, sl
 800d434:	4638      	mov	r0, r7
 800d436:	4613      	mov	r3, r2
 800d438:	460f      	mov	r7, r1
 800d43a:	462a      	mov	r2, r5
 800d43c:	4601      	mov	r1, r0
 800d43e:	461d      	mov	r5, r3
 800d440:	f04f 0a01 	mov.w	sl, #1
 800d444:	e697      	b.n	800d176 <draw_all+0x9be>
  if (y1 < y0)
 800d446:	42b0      	cmp	r0, r6
 800d448:	d90f      	bls.n	800d46a <draw_all+0xcb2>
  int dx = (x0 - x1), sx = 1;
 800d44a:	ebaa 0403 	sub.w	r4, sl, r3
  if (dx > 0)
 800d44e:	2c00      	cmp	r4, #0
 800d450:	f73f af38 	bgt.w	800d2c4 <draw_all+0xb0c>
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d454:	eb04 73d4 	add.w	r3, r4, r4, lsr #31
 800d458:	105b      	asrs	r3, r3, #1
  int dy = (y1 - y0);
 800d45a:	1b80      	subs	r0, r0, r6
  int dx = (x0 - x1), sx = 1;
 800d45c:	f04f 0a01 	mov.w	sl, #1
  int err = ((dy + dx) < 0 ? -dx : -dy) / 2;
 800d460:	425b      	negs	r3, r3
 800d462:	e690      	b.n	800d186 <draw_all+0x9ce>
  if (y1 < y0)
 800d464:	42b0      	cmp	r0, r6
 800d466:	f63f af52 	bhi.w	800d30e <draw_all+0xb56>
 800d46a:	4608      	mov	r0, r1
 800d46c:	4613      	mov	r3, r2
 800d46e:	4639      	mov	r1, r7
 800d470:	462a      	mov	r2, r5
 800d472:	4607      	mov	r7, r0
 800d474:	461d      	mov	r5, r3
 800d476:	e74a      	b.n	800d30e <draw_all+0xb56>
    plot_printf(msg, (int)sizeof(msg), "BW2=-- kHz");
 800d478:	4a72      	ldr	r2, [pc, #456]	@ (800d644 <draw_all+0xe8c>)
 800d47a:	2120      	movs	r1, #32
 800d47c:	4620      	mov	r0, r4
 800d47e:	f7f5 fc77 	bl	8002d70 <plot_printf>
 800d482:	e51d      	b.n	800cec0 <draw_all+0x708>
  else if (trace_type & (1 << TRC_POLAR))
 800d484:	f01c 0f10 	tst.w	ip, #16
 800d488:	f43f ae2b 	beq.w	800d0e2 <draw_all+0x92a>
  for (y = 0; y < h; y++)
 800d48c:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 800d48e:	f8cd 8040 	str.w	r8, [sp, #64]	@ 0x40
 800d492:	46c4      	mov	ip, r8
 800d494:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 800d498:	f8dd 8050 	ldr.w	r8, [sp, #80]	@ 0x50
 800d49c:	f103 0753 	add.w	r7, r3, #83	@ 0x53
 800d4a0:	f1ab 05e8 	sub.w	r5, fp, #232	@ 0xe8
  if (d > P_RADIUS * P_RADIUS + P_RADIUS)
 800d4a4:	f645 26d8 	movw	r6, #23256	@ 0x5ad8
  if (d > P_RADIUS * P_RADIUS - P_RADIUS)
 800d4a8:	f645 1ea8 	movw	lr, #22952	@ 0x59a8
  uint32_t d = x * x + y * y;
 800d4ac:	fb07 f007 	mul.w	r0, r7, r7
 800d4b0:	462b      	mov	r3, r5
    for (x = 0; x < w; x++)
 800d4b2:	2200      	movs	r2, #0
 800d4b4:	9504      	str	r5, [sp, #16]
  uint32_t d = x * x + y * y;
 800d4b6:	fb03 0103 	mla	r1, r3, r3, r0
  if (d > P_RADIUS * P_RADIUS + P_RADIUS)
 800d4ba:	42b1      	cmp	r1, r6
 800d4bc:	dc26      	bgt.n	800d50c <draw_all+0xd54>
  if (d > P_RADIUS * P_RADIUS - P_RADIUS)
 800d4be:	4571      	cmp	r1, lr
 800d4c0:	dc22      	bgt.n	800d508 <draw_all+0xd50>
  if (x == 0 || y == 0)
 800d4c2:	b30b      	cbz	r3, 800d508 <draw_all+0xd50>
 800d4c4:	b307      	cbz	r7, 800d508 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS / 25 - P_RADIUS / 5)
 800d4c6:	f240 357d 	movw	r5, #893	@ 0x37d
 800d4ca:	42a9      	cmp	r1, r5
 800d4cc:	dd1e      	ble.n	800d50c <draw_all+0xd54>
  if (d < P_RADIUS * P_RADIUS / 25 + P_RADIUS / 5)
 800d4ce:	f240 35b9 	movw	r5, #953	@ 0x3b9
 800d4d2:	42a9      	cmp	r1, r5
 800d4d4:	dd18      	ble.n	800d508 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS * 4 / 25 - P_RADIUS * 2 / 5)
 800d4d6:	f640 6533 	movw	r5, #3635	@ 0xe33
 800d4da:	42a9      	cmp	r1, r5
 800d4dc:	dd16      	ble.n	800d50c <draw_all+0xd54>
  if (d < P_RADIUS * P_RADIUS * 4 / 25 + P_RADIUS * 2 / 5)
 800d4de:	f640 65ab 	movw	r5, #3755	@ 0xeab
 800d4e2:	42a9      	cmp	r1, r5
 800d4e4:	dd10      	ble.n	800d508 <draw_all+0xd50>
  if (x == y || x == -y)
 800d4e6:	42bb      	cmp	r3, r7
 800d4e8:	d00e      	beq.n	800d508 <draw_all+0xd50>
 800d4ea:	42fb      	cmn	r3, r7
 800d4ec:	d00c      	beq.n	800d508 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS * 9 / 25 - P_RADIUS * 3 / 5)
 800d4ee:	f242 0521 	movw	r5, #8225	@ 0x2021
 800d4f2:	42a9      	cmp	r1, r5
 800d4f4:	dd0a      	ble.n	800d50c <draw_all+0xd54>
  if (d < P_RADIUS * P_RADIUS * 9 / 25 + P_RADIUS * 3 / 5)
 800d4f6:	f242 05d7 	movw	r5, #8407	@ 0x20d7
 800d4fa:	42a9      	cmp	r1, r5
 800d4fc:	dd04      	ble.n	800d508 <draw_all+0xd50>
  if (d < P_RADIUS * P_RADIUS * 16 / 25 - P_RADIUS * 4 / 5)
 800d4fe:	f5a1 5165 	sub.w	r1, r1, #14656	@ 0x3940
 800d502:	3909      	subs	r1, #9
 800d504:	29f1      	cmp	r1, #241	@ 0xf1
 800d506:	d801      	bhi.n	800d50c <draw_all+0xd54>
        cell_buffer[y * CELLWIDTH + x] = color;
 800d508:	f82c 4012 	strh.w	r4, [ip, r2, lsl #1]
    for (x = 0; x < w; x++)
 800d50c:	3201      	adds	r2, #1
 800d50e:	4590      	cmp	r8, r2
 800d510:	f103 0301 	add.w	r3, r3, #1
 800d514:	dccf      	bgt.n	800d4b6 <draw_all+0xcfe>
  for (y = 0; y < h; y++)
 800d516:	f109 0901 	add.w	r9, r9, #1
 800d51a:	45ca      	cmp	sl, r9
 800d51c:	9d04      	ldr	r5, [sp, #16]
 800d51e:	f107 0701 	add.w	r7, r7, #1
 800d522:	f10c 0c40 	add.w	ip, ip, #64	@ 0x40
 800d526:	dcc1      	bgt.n	800d4ac <draw_all+0xcf4>
 800d528:	f8dd 8040 	ldr.w	r8, [sp, #64]	@ 0x40
 800d52c:	e5d9      	b.n	800d0e2 <draw_all+0x92a>
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d52e:	4620      	mov	r0, r4
 800d530:	f003 fdaa 	bl	8011088 <lcd_set_foreground>
      cell_blit_bitmap(x, y, REFERENCE_WIDTH, REFERENCE_HEIGHT, (const uint8_t *)reference_bitmap);
 800d534:	4b44      	ldr	r3, [pc, #272]	@ (800d648 <draw_all+0xe90>)
 800d536:	9300      	str	r3, [sp, #0]
    int y = HEIGHT - float2int(get_trace_refpos(t) * GRIDY) - y0 - REFERENCE_Y_OFFSET;
 800d538:	1eb9      	subs	r1, r7, #2
      cell_blit_bitmap(x, y, REFERENCE_WIDTH, REFERENCE_HEIGHT, (const uint8_t *)reference_bitmap);
 800d53a:	b209      	sxth	r1, r1
 800d53c:	4648      	mov	r0, r9
 800d53e:	2305      	movs	r3, #5
 800d540:	2206      	movs	r2, #6
 800d542:	f7fc ffd5 	bl	800a4f0 <cell_blit_bitmap>
 800d546:	e54b      	b.n	800cfe0 <draw_all+0x828>
  if (active_marker == MARKER_INVALID)
 800d548:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 800d54a:	f991 301d 	ldrsb.w	r3, [r1, #29]
 800d54e:	1c5c      	adds	r4, r3, #1
 800d550:	f000 8167 	beq.w	800d822 <draw_all+0x106a>
  int active_marker_idx = markers[active_marker].index;
 800d554:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800d558:	f8b3 305a 	ldrh.w	r3, [r3, #90]	@ 0x5a
 800d55c:	9304      	str	r3, [sp, #16]
  if (previous_marker != MARKER_INVALID && current_trace != TRACE_INVALID)
 800d55e:	f991 301e 	ldrsb.w	r3, [r1, #30]
 800d562:	3301      	adds	r3, #1
 800d564:	d07c      	beq.n	800d660 <draw_all+0xea8>
 800d566:	f991 201c 	ldrsb.w	r2, [r1, #28]
 800d56a:	1c50      	adds	r0, r2, #1
  int j = 0;
 800d56c:	f04f 0800 	mov.w	r8, #0
  if (previous_marker != MARKER_INVALID && current_trace != TRACE_INVALID)
 800d570:	f000 8413 	beq.w	800dd9a <draw_all+0x15e2>
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d574:	1d93      	adds	r3, r2, #6
 800d576:	b29b      	uxth	r3, r3
    t = current_trace;
 800d578:	f8cd b048 	str.w	fp, [sp, #72]	@ 0x48
 800d57c:	f8df 90dc 	ldr.w	r9, [pc, #220]	@ 800d65c <draw_all+0xea4>
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d580:	9313      	str	r3, [sp, #76]	@ 0x4c
    t = current_trace;
 800d582:	4644      	mov	r4, r8
 800d584:	9219      	str	r2, [sp, #100]	@ 0x64
 800d586:	468b      	mov	fp, r1
 800d588:	e020      	b.n	800d5cc <draw_all+0xe14>
 800d58a:	931b      	str	r3, [sp, #108]	@ 0x6c
        freq_t freq1 = get_marker_frequency(active_marker);
 800d58c:	f7fa fa98 	bl	8007ac0 <get_marker_frequency>
        freq_t delta = freq > freq1 ? freq - freq1 : freq1 - freq;
 800d590:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
        cell_printf(xpos, ypos, S_DELTA MARKER_FREQ, delta);
 800d592:	4a2e      	ldr	r2, [pc, #184]	@ (800d64c <draw_all+0xe94>)
        freq_t delta = freq > freq1 ? freq - freq1 : freq1 - freq;
 800d594:	4283      	cmp	r3, r0
 800d596:	bf8c      	ite	hi
 800d598:	1a1b      	subhi	r3, r3, r0
 800d59a:	1ac3      	subls	r3, r0, r3
        cell_printf(xpos, ypos, S_DELTA MARKER_FREQ, delta);
 800d59c:	4651      	mov	r1, sl
 800d59e:	f9bd 0040 	ldrsh.w	r0, [sp, #64]	@ 0x40
 800d5a2:	f7fd fb1f 	bl	800abe4 <cell_printf>
        delta_index = active_marker_idx;
 800d5a6:	9f04      	ldr	r7, [sp, #16]
      lcd_set_foreground(LCD_FG_COLOR);
 800d5a8:	2001      	movs	r0, #1
 800d5aa:	f003 fd6d 	bl	8011088 <lcd_set_foreground>
      trace_print_value_string(xpos, ypos, t, mk_index, delta_index);
 800d5ae:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 800d5b0:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 800d5b2:	9700      	str	r7, [sp, #0]
 800d5b4:	4631      	mov	r1, r6
 800d5b6:	f105 008e 	add.w	r0, r5, #142	@ 0x8e
      j++;
 800d5ba:	f108 0801 	add.w	r8, r8, #1
      trace_print_value_string(xpos, ypos, t, mk_index, delta_index);
 800d5be:	f7fd fe69 	bl	800b294 <trace_print_value_string>
    for (mk = 0; mk < MARKERS_MAX; mk++)
 800d5c2:	2c08      	cmp	r4, #8
 800d5c4:	f109 0908 	add.w	r9, r9, #8
 800d5c8:	f000 82d3 	beq.w	800db72 <draw_all+0x13ba>
      if (!markers[mk].enabled)
 800d5cc:	f899 3058 	ldrb.w	r3, [r9, #88]	@ 0x58
 800d5d0:	4627      	mov	r7, r4
 800d5d2:	3401      	adds	r4, #1
 800d5d4:	2b00      	cmp	r3, #0
 800d5d6:	d0f4      	beq.n	800d5c2 <draw_all+0xe0a>
      ypos = marker_pos[j].y - y0;
 800d5d8:	4a1d      	ldr	r2, [pc, #116]	@ (800d650 <draw_all+0xe98>)
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d5da:	9813      	ldr	r0, [sp, #76]	@ 0x4c
      xpos = marker_pos[j].x - x0;
 800d5dc:	f832 5028 	ldrh.w	r5, [r2, r8, lsl #2]
      ypos = marker_pos[j].y - y0;
 800d5e0:	eb02 0388 	add.w	r3, r2, r8, lsl #2
 800d5e4:	885e      	ldrh	r6, [r3, #2]
 800d5e6:	9b08      	ldr	r3, [sp, #32]
 800d5e8:	1af6      	subs	r6, r6, r3
      xpos = marker_pos[j].x - x0;
 800d5ea:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 800d5ec:	1aed      	subs	r5, r5, r3
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d5ee:	f003 fd4b 	bl	8011088 <lcd_set_foreground>
      if (mk == active_marker && lever_mode == LM_MARKER)
 800d5f2:	f99b 301d 	ldrsb.w	r3, [fp, #29]
 800d5f6:	42bb      	cmp	r3, r7
        cell_printf(xpos, ypos, S_SARROW);
 800d5f8:	fa0f fa86 	sxth.w	sl, r6
      if (mk == active_marker && lever_mode == LM_MARKER)
 800d5fc:	f000 829f 	beq.w	800db3e <draw_all+0x1386>
      xpos += FONT_WIDTH;
 800d600:	1de8      	adds	r0, r5, #7
      cell_printf(xpos, ypos, "M%d", mk + 1);
 800d602:	4a14      	ldr	r2, [pc, #80]	@ (800d654 <draw_all+0xe9c>)
 800d604:	4623      	mov	r3, r4
 800d606:	4651      	mov	r1, sl
 800d608:	b200      	sxth	r0, r0
 800d60a:	f7fd faeb 	bl	800abe4 <cell_printf>
      uint32_t mk_index = markers[mk].index;
 800d60e:	f8b9 305a 	ldrh.w	r3, [r9, #90]	@ 0x5a
 800d612:	9311      	str	r3, [sp, #68]	@ 0x44
      freq_t freq = get_marker_frequency(mk);
 800d614:	4638      	mov	r0, r7
      xpos += 3 * FONT_WIDTH - 2;
 800d616:	f105 031a 	add.w	r3, r5, #26
 800d61a:	9310      	str	r3, [sp, #64]	@ 0x40
      freq_t freq = get_marker_frequency(mk);
 800d61c:	f7fa fa50 	bl	8007ac0 <get_marker_frequency>
      if ((props_mode & TD_MARKER_DELTA) && mk != active_marker)
 800d620:	f8bb 2018 	ldrh.w	r2, [fp, #24]
 800d624:	05d2      	lsls	r2, r2, #23
      freq_t freq = get_marker_frequency(mk);
 800d626:	4603      	mov	r3, r0
      if ((props_mode & TD_MARKER_DELTA) && mk != active_marker)
 800d628:	d503      	bpl.n	800d632 <draw_all+0xe7a>
 800d62a:	f99b 001d 	ldrsb.w	r0, [fp, #29]
 800d62e:	42b8      	cmp	r0, r7
 800d630:	d1ab      	bne.n	800d58a <draw_all+0xdd2>
        cell_printf(xpos, ypos, MARKER_FREQ, freq);
 800d632:	f9bd 0040 	ldrsh.w	r0, [sp, #64]	@ 0x40
 800d636:	4a08      	ldr	r2, [pc, #32]	@ (800d658 <draw_all+0xea0>)
 800d638:	4651      	mov	r1, sl
 800d63a:	f7fd fad3 	bl	800abe4 <cell_printf>
      int32_t delta_index = -1;
 800d63e:	f04f 37ff 	mov.w	r7, #4294967295
 800d642:	e7b1      	b.n	800d5a8 <draw_all+0xdf0>
 800d644:	08013d64 	.word	0x08013d64
 800d648:	08016434 	.word	0x08016434
 800d64c:	08013c70 	.word	0x08013c70
 800d650:	080161ac 	.word	0x080161ac
 800d654:	08013c6c 	.word	0x08013c6c
 800d658:	08013c78 	.word	0x08013c78
 800d65c:	20000aa8 	.word	0x20000aa8
 800d660:	f04f 0800 	mov.w	r8, #0
 800d664:	4da2      	ldr	r5, [pc, #648]	@ (800d8f0 <draw_all+0x1138>)
 800d666:	4644      	mov	r4, r8
      if (!trace[t].enabled)
 800d668:	f895 3028 	ldrb.w	r3, [r5, #40]	@ 0x28
 800d66c:	2b00      	cmp	r3, #0
 800d66e:	d058      	beq.n	800d722 <draw_all+0xf6a>
      ypos = marker_pos[j].y - y0;
 800d670:	4aa0      	ldr	r2, [pc, #640]	@ (800d8f4 <draw_all+0x113c>)
 800d672:	eb02 0388 	add.w	r3, r2, r8, lsl #2
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d676:	1da0      	adds	r0, r4, #6
      ypos = marker_pos[j].y - y0;
 800d678:	885f      	ldrh	r7, [r3, #2]
 800d67a:	9b08      	ldr	r3, [sp, #32]
      xpos = marker_pos[j].x - x0;
 800d67c:	f832 6028 	ldrh.w	r6, [r2, r8, lsl #2]
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d680:	b280      	uxth	r0, r0
      ypos = marker_pos[j].y - y0;
 800d682:	1aff      	subs	r7, r7, r3
      lcd_set_foreground(LCD_TRACE_1_COLOR + t);
 800d684:	f003 fd00 	bl	8011088 <lcd_set_foreground>
      if (t == current_trace)
 800d688:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800d68a:	f993 301c 	ldrsb.w	r3, [r3, #28]
 800d68e:	42a3      	cmp	r3, r4
      xpos = marker_pos[j].x - x0;
 800d690:	eba6 060b 	sub.w	r6, r6, fp
        cell_printf(xpos, ypos, S_SARROW);
 800d694:	fa0f f987 	sxth.w	r9, r7
      if (t == current_trace)
 800d698:	f000 8382 	beq.w	800dda0 <draw_all+0x15e8>
      cell_printf(xpos, ypos, get_trace_chname(t));
 800d69c:	4620      	mov	r0, r4
 800d69e:	f7fa fcab 	bl	8007ff8 <get_trace_chname>
 800d6a2:	4602      	mov	r2, r0
      xpos += FONT_WIDTH;
 800d6a4:	1df0      	adds	r0, r6, #7
      cell_printf(xpos, ypos, get_trace_chname(t));
 800d6a6:	4649      	mov	r1, r9
 800d6a8:	b200      	sxth	r0, r0
 800d6aa:	f7fd fa9b 	bl	800abe4 <cell_printf>
  int type = trace[t].type;
 800d6ae:	f895 0029 	ldrb.w	r0, [r5, #41]	@ 0x29
  const char *v = trace_info_list[trace[t].type].symbol;
 800d6b2:	4a91      	ldr	r2, [pc, #580]	@ (800d8f8 <draw_all+0x1140>)
  float scale = get_trace_scale(t);
 800d6b4:	f8d5 a02c 	ldr.w	sl, [r5, #44]	@ 0x2c
  int smith = trace[t].smith_format;
 800d6b8:	f895 102b 	ldrb.w	r1, [r5, #43]	@ 0x2b
  const char *v = trace_info_list[trace[t].type].symbol;
 800d6bc:	ebc0 03c0 	rsb	r3, r0, r0, lsl #3
 800d6c0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    format = (scale != 1.0f) ? "%s %0.1fFS" : "%s ";
 800d6c4:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
  const char *v = trace_info_list[trace[t].type].symbol;
 800d6c8:	68da      	ldr	r2, [r3, #12]
  switch (type)
 800d6ca:	1ec3      	subs	r3, r0, #3
 800d6cc:	2b01      	cmp	r3, #1
      xpos += 4 * FONT_WIDTH - 2;
 800d6ce:	f106 0621 	add.w	r6, r6, #33	@ 0x21
  switch (type)
 800d6d2:	f240 82b7 	bls.w	800dc44 <draw_all+0x148c>
    format = "%s %F%s/";
 800d6d6:	4b89      	ldr	r3, [pc, #548]	@ (800d8fc <draw_all+0x1144>)
 800d6d8:	9310      	str	r3, [sp, #64]	@ 0x40
  return cell_printf(xpos, ypos, format, get_trace_typename(type, smith), scale, v);
 800d6da:	f7fe fd69 	bl	800c1b0 <get_trace_typename>
 800d6de:	4603      	mov	r3, r0
 800d6e0:	4650      	mov	r0, sl
 800d6e2:	9202      	str	r2, [sp, #8]
 800d6e4:	9311      	str	r3, [sp, #68]	@ 0x44
 800d6e6:	f7f2 ff5b 	bl	80005a0 <__aeabi_f2d>
 800d6ea:	fa0f fa86 	sxth.w	sl, r6
 800d6ee:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 800d6f2:	e9cd 0100 	strd	r0, r1, [sp]
 800d6f6:	4649      	mov	r1, r9
 800d6f8:	4650      	mov	r0, sl
 800d6fa:	f7fd fa73 	bl	800abe4 <cell_printf>
      xpos += n * FONT_WIDTH - 5;
 800d6fe:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 800d702:	1c83      	adds	r3, r0, #2
      lcd_set_foreground(LCD_FG_COLOR);
 800d704:	2001      	movs	r0, #1
      xpos += n * FONT_WIDTH - 5;
 800d706:	441e      	add	r6, r3
      lcd_set_foreground(LCD_FG_COLOR);
 800d708:	f003 fcbe 	bl	8011088 <lcd_set_foreground>
      trace_print_value_string(xpos, ypos, t, active_marker_idx, -1);
 800d70c:	f04f 33ff 	mov.w	r3, #4294967295
 800d710:	9300      	str	r3, [sp, #0]
 800d712:	4639      	mov	r1, r7
 800d714:	9b04      	ldr	r3, [sp, #16]
 800d716:	4630      	mov	r0, r6
 800d718:	4622      	mov	r2, r4
      j++;
 800d71a:	f108 0801 	add.w	r8, r8, #1
      trace_print_value_string(xpos, ypos, t, active_marker_idx, -1);
 800d71e:	f7fd fdb9 	bl	800b294 <trace_print_value_string>
    for (t = 0; t < TRACES_MAX; t++)
 800d722:	3401      	adds	r4, #1
 800d724:	2c04      	cmp	r4, #4
 800d726:	f105 050c 	add.w	r5, r5, #12
 800d72a:	d19d      	bne.n	800d668 <draw_all+0xeb0>
    ypos = 1 + ((j + 1) / 2) * FONT_STR_HEIGHT - y0;
 800d72c:	f108 0301 	add.w	r3, r8, #1
 800d730:	105b      	asrs	r3, r3, #1
 800d732:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800d736:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800d73a:	9a08      	ldr	r2, [sp, #32]
 800d73c:	3301      	adds	r3, #1
 800d73e:	1a9d      	subs	r5, r3, r2
    if (lever_mode == LM_MARKER)
 800d740:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800d742:	7f1b      	ldrb	r3, [r3, #28]
      cell_printf(xpos, ypos, S_SARROW);
 800d744:	b22e      	sxth	r6, r5
    if (lever_mode == LM_MARKER)
 800d746:	2b00      	cmp	r3, #0
 800d748:	f000 836b 	beq.w	800de22 <draw_all+0x166a>
    cell_printf(xpos, ypos, "M%d:", active_marker + 1);
 800d74c:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800d74e:	fa1f f48b 	uxth.w	r4, fp
 800d752:	f992 301d 	ldrsb.w	r3, [r2, #29]
 800d756:	4a6a      	ldr	r2, [pc, #424]	@ (800d900 <draw_all+0x1148>)
 800d758:	f5c4 7082 	rsb	r0, r4, #260	@ 0x104
 800d75c:	3301      	adds	r3, #1
 800d75e:	b200      	sxth	r0, r0
 800d760:	4631      	mov	r1, r6
 800d762:	f7fd fa3f 	bl	800abe4 <cell_printf>
    if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800d766:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800d768:	8b13      	ldrh	r3, [r2, #24]
      cell_printf(xpos, ypos, "%q" S_Hz, get_marker_frequency(active_marker));
 800d76a:	f5c4 748e 	rsb	r4, r4, #284	@ 0x11c
 800d76e:	3401      	adds	r4, #1
    if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800d770:	07db      	lsls	r3, r3, #31
      cell_printf(xpos, ypos, "%q" S_Hz, get_marker_frequency(active_marker));
 800d772:	b227      	sxth	r7, r4
    if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800d774:	f100 82f6 	bmi.w	800dd64 <draw_all+0x15ac>
      cell_printf(xpos, ypos, "%q" S_Hz, get_marker_frequency(active_marker));
 800d778:	f992 001d 	ldrsb.w	r0, [r2, #29]
 800d77c:	f7fa f9a0 	bl	8007ac0 <get_marker_frequency>
 800d780:	4a60      	ldr	r2, [pc, #384]	@ (800d904 <draw_all+0x114c>)
 800d782:	4603      	mov	r3, r0
 800d784:	4631      	mov	r1, r6
 800d786:	4638      	mov	r0, r7
 800d788:	f7fd fa2c 	bl	800abe4 <cell_printf>
  float electrical_delay = get_electrical_delay();
 800d78c:	f7fb fe50 	bl	8009430 <get_electrical_delay>
  if (electrical_delay != 0.0f)
 800d790:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800d794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  float electrical_delay = get_electrical_delay();
 800d798:	eeb0 8a40 	vmov.f32	s16, s0
  if (electrical_delay != 0.0f)
 800d79c:	d02a      	beq.n	800d7f4 <draw_all+0x103c>
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800d79e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800d7a0:	ed9f 7a59 	vldr	s14, [pc, #356]	@ 800d908 <draw_all+0x1150>
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800d7a4:	7f1b      	ldrb	r3, [r3, #28]
 800d7a6:	2b04      	cmp	r3, #4
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800d7a8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800d7aa:	f893 3099 	ldrb.w	r3, [r3, #153]	@ 0x99
 800d7ae:	ee07 3a90 	vmov	s15, r3
 800d7b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800d7b6:	f1cb 0318 	rsb	r3, fp, #24
 800d7ba:	ee67 7a87 	vmul.f32	s15, s15, s14
 800d7be:	b21e      	sxth	r6, r3
 800d7c0:	ee67 7a80 	vmul.f32	s15, s15, s0
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800d7c4:	bf18      	it	ne
 800d7c6:	2720      	movne	r7, #32
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800d7c8:	ee17 0a90 	vmov	r0, s15
    char sel = lever_mode == LM_EDELAY ? S_SARROW[0] : ' ';
 800d7cc:	bf08      	it	eq
 800d7ce:	2718      	moveq	r7, #24
    cell_printf(xpos, ypos, "%cEdelay: %F" S_SECOND " (%F" S_METRE ")", sel, electrical_delay, electrical_delay * (SPEED_OF_LIGHT / 100.0f) * velocity_factor);
 800d7d0:	f7f2 fee6 	bl	80005a0 <__aeabi_f2d>
 800d7d4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800d7d8:	ee18 0a10 	vmov	r0, s16
 800d7dc:	f7f2 fee0 	bl	80005a0 <__aeabi_f2d>
 800d7e0:	b22c      	sxth	r4, r5
 800d7e2:	e9cd 0100 	strd	r0, r1, [sp]
 800d7e6:	4a49      	ldr	r2, [pc, #292]	@ (800d90c <draw_all+0x1154>)
 800d7e8:	463b      	mov	r3, r7
 800d7ea:	4621      	mov	r1, r4
 800d7ec:	4630      	mov	r0, r6
 800d7ee:	f7fd f9f9 	bl	800abe4 <cell_printf>
    ypos += FONT_STR_HEIGHT;
 800d7f2:	350b      	adds	r5, #11
  if (s21_offset != 0.0f)
 800d7f4:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800d7f6:	edd3 7a2a 	vldr	s15, [r3, #168]	@ 0xa8
 800d7fa:	eef5 7a40 	vcmp.f32	s15, #0.0
 800d7fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d802:	d00e      	beq.n	800d822 <draw_all+0x106a>
    cell_printf(xpos, ypos, "S21 offset: %.3F" S_dB, s21_offset);
 800d804:	ee17 0a90 	vmov	r0, s15
 800d808:	f7f2 feca 	bl	80005a0 <__aeabi_f2d>
 800d80c:	b22c      	sxth	r4, r5
 800d80e:	f1cb 0518 	rsb	r5, fp, #24
 800d812:	b22d      	sxth	r5, r5
 800d814:	e9cd 0100 	strd	r0, r1, [sp]
 800d818:	4a3d      	ldr	r2, [pc, #244]	@ (800d910 <draw_all+0x1158>)
 800d81a:	4621      	mov	r1, r4
 800d81c:	4628      	mov	r0, r5
 800d81e:	f7fd f9e1 	bl	800abe4 <cell_printf>
  if (y0 == 0)
 800d822:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 800d824:	2b00      	cmp	r3, #0
 800d826:	f47f ab35 	bne.w	800ce94 <draw_all+0x6dc>
  if (mla_resonance_locked && mla_res_freq != 0)
 800d82a:	4e3a      	ldr	r6, [pc, #232]	@ (800d914 <draw_all+0x115c>)
 800d82c:	7833      	ldrb	r3, [r6, #0]
 800d82e:	b123      	cbz	r3, 800d83a <draw_all+0x1082>
 800d830:	4b39      	ldr	r3, [pc, #228]	@ (800d918 <draw_all+0x1160>)
 800d832:	6819      	ldr	r1, [r3, #0]
 800d834:	2900      	cmp	r1, #0
 800d836:	f040 83b1 	bne.w	800df9c <draw_all+0x17e4>
    plot_printf(msg, (int)sizeof(msg), "F Res ---.---.--- Hz");
 800d83a:	ac22      	add	r4, sp, #136	@ 0x88
 800d83c:	4a37      	ldr	r2, [pc, #220]	@ (800d91c <draw_all+0x1164>)
 800d83e:	2128      	movs	r1, #40	@ 0x28
 800d840:	4620      	mov	r0, r4
 800d842:	f7f5 fa95 	bl	8002d70 <plot_printf>
  const int text_w = cell_string_width(msg) * 2;
 800d846:	4620      	mov	r0, r4
 800d848:	f7fd f808 	bl	800a85c <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800d84c:	f240 13c7 	movw	r3, #455	@ 0x1c7
 800d850:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
 800d854:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
  lcd_set_foreground(LCD_INTERP_CAL_COLOR); // bright green
 800d858:	2017      	movs	r0, #23
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800d85a:	105d      	asrs	r5, r3, #1
  lcd_set_foreground(LCD_INTERP_CAL_COLOR); // bright green
 800d85c:	f003 fc14 	bl	8011088 <lcd_set_foreground>
  const int text_wt = cell_string_width(msg) * 2;
 800d860:	4620      	mov	r0, r4
 800d862:	f7fc fffb 	bl	800a85c <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800d866:	3505      	adds	r5, #5
  const int text_wt = cell_string_width(msg) * 2;
 800d868:	0040      	lsls	r0, r0, #1
  cell_fill_bg_rect(x0, y0, x, y, text_wt, text_ht);
 800d86a:	9000      	str	r0, [sp, #0]
 800d86c:	462a      	mov	r2, r5
 800d86e:	4658      	mov	r0, fp
 800d870:	2301      	movs	r3, #1
 800d872:	2100      	movs	r1, #0
 800d874:	f7fd fe76 	bl	800b564 <cell_fill_bg_rect.constprop.0>
  cell_drawstring_big(msg, x - x0, y - y0);
 800d878:	eba5 010b 	sub.w	r1, r5, fp
 800d87c:	2201      	movs	r2, #1
 800d87e:	4620      	mov	r0, r4
 800d880:	f7fd f808 	bl	800a894 <cell_drawstring_big>
  if (y0 == CELLHEIGHT)
 800d884:	f7ff bb0c 	b.w	800cea0 <draw_all+0x6e8>
  for (y = 0; y < h; y++)
 800d888:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800d88a:	f8dd 9050 	ldr.w	r9, [sp, #80]	@ 0x50
 800d88e:	f8cd b040 	str.w	fp, [sp, #64]	@ 0x40
 800d892:	4653      	mov	r3, sl
 800d894:	f1cb 07e8 	rsb	r7, fp, #232	@ 0xe8
 800d898:	f102 0a53 	add.w	sl, r2, #83	@ 0x53
 800d89c:	f8cd 8010 	str.w	r8, [sp, #16]
 800d8a0:	469b      	mov	fp, r3
      if (smith_grid(-x + x0, y + y0))
 800d8a2:	eb0a 050b 	add.w	r5, sl, fp
    for (x = 0; x < w; x++)
 800d8a6:	2600      	movs	r6, #0
      if (smith_grid(-x + x0, y + y0))
 800d8a8:	4629      	mov	r1, r5
 800d8aa:	1bb8      	subs	r0, r7, r6
 800d8ac:	f7fc fdc2 	bl	800a434 <smith_grid>
 800d8b0:	b108      	cbz	r0, 800d8b6 <draw_all+0x10fe>
        cell_buffer[y * CELLWIDTH + x] = color;
 800d8b2:	f828 4016 	strh.w	r4, [r8, r6, lsl #1]
    for (x = 0; x < w; x++)
 800d8b6:	3601      	adds	r6, #1
 800d8b8:	45b1      	cmp	r9, r6
 800d8ba:	dcf5      	bgt.n	800d8a8 <draw_all+0x10f0>
  for (y = 0; y < h; y++)
 800d8bc:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 800d8be:	f10b 0b01 	add.w	fp, fp, #1
 800d8c2:	455b      	cmp	r3, fp
 800d8c4:	f108 0840 	add.w	r8, r8, #64	@ 0x40
 800d8c8:	dceb      	bgt.n	800d8a2 <draw_all+0x10ea>
 800d8ca:	e406      	b.n	800d0da <draw_all+0x922>
  if (current_props._measure >= MEASURE_END)
 800d8cc:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 800d8ce:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800d8d2:	2b07      	cmp	r3, #7
 800d8d4:	f63f ab8a 	bhi.w	800cfec <draw_all+0x834>
  measure_cell_cb_t measure_draw_cb = measure[current_props._measure].measure_cell;
 800d8d8:	4a11      	ldr	r2, [pc, #68]	@ (800d920 <draw_all+0x1168>)
 800d8da:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800d8de:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800d8e2:	685c      	ldr	r4, [r3, #4]
  if (measure_draw_cb)
 800d8e4:	2c00      	cmp	r4, #0
 800d8e6:	f47f ab49 	bne.w	800cf7c <draw_all+0x7c4>
 800d8ea:	f7ff bb7f 	b.w	800cfec <draw_all+0x834>
 800d8ee:	bf00      	nop
 800d8f0:	20000aa8 	.word	0x20000aa8
 800d8f4:	080161ac 	.word	0x080161ac
 800d8f8:	0801650c 	.word	0x0801650c
 800d8fc:	08013c48 	.word	0x08013c48
 800d900:	08013c9c 	.word	0x08013c9c
 800d904:	08013c78 	.word	0x08013c78
 800d908:	4a36fa92 	.word	0x4a36fa92
 800d90c:	08013ca4 	.word	0x08013ca4
 800d910:	08013cb8 	.word	0x08013cb8
 800d914:	2000687d 	.word	0x2000687d
 800d918:	20006884 	.word	0x20006884
 800d91c:	08013cd8 	.word	0x08013cd8
 800d920:	080161cc 	.word	0x080161cc
  if (mla_resonance_locked && (swr > 0.0f) && (swr < 100.0f)) {
 800d924:	7833      	ldrb	r3, [r6, #0]
 800d926:	2b00      	cmp	r3, #0
 800d928:	f000 80d7 	beq.w	800dada <draw_all+0x1322>
  float swr = mla_res_swr;
 800d92c:	4bce      	ldr	r3, [pc, #824]	@ (800dc68 <draw_all+0x14b0>)
 800d92e:	ed93 8a00 	vldr	s16, [r3]
  if (mla_resonance_locked && (swr > 0.0f) && (swr < 100.0f)) {
 800d932:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 800d936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d93a:	f340 80ce 	ble.w	800dada <draw_all+0x1322>
 800d93e:	ed9f 9acb 	vldr	s18, [pc, #812]	@ 800dc6c <draw_all+0x14b4>
 800d942:	eeb4 8ac9 	vcmpe.f32	s16, s18
 800d946:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d94a:	f140 80c6 	bpl.w	800dada <draw_all+0x1322>
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800d94e:	ee18 0a10 	vmov	r0, s16
 800d952:	f7f2 fe25 	bl	80005a0 <__aeabi_f2d>
    if (swr > 1.0001f) {
 800d956:	eddf 7ac6 	vldr	s15, [pc, #792]	@ 800dc70 <draw_all+0x14b8>
 800d95a:	eeb4 8ae7 	vcmpe.f32	s16, s15
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800d95e:	4604      	mov	r4, r0
 800d960:	460d      	mov	r5, r1
    if (swr > 1.0001f) {
 800d962:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800d966:	e9cd 4504 	strd	r4, r5, [sp, #16]
    if (swr > 1.0001f) {
 800d96a:	f300 82b9 	bgt.w	800dee0 <draw_all+0x1728>
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800d96e:	ed9d 7b04 	vldr	d7, [sp, #16]
 800d972:	ac22      	add	r4, sp, #136	@ 0x88
 800d974:	f04f 0800 	mov.w	r8, #0
 800d978:	f04f 0900 	mov.w	r9, #0
 800d97c:	4abd      	ldr	r2, [pc, #756]	@ (800dc74 <draw_all+0x14bc>)
 800d97e:	2150      	movs	r1, #80	@ 0x50
 800d980:	ed8d 7b00 	vstr	d7, [sp]
 800d984:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800d988:	4620      	mov	r0, r4
 800d98a:	f7f5 f9f1 	bl	8002d70 <plot_printf>
  int text_w = cell_string_width(msg) * 2; // BIG font => *2
 800d98e:	4620      	mov	r0, r4
 800d990:	f7fc ff64 	bl	800a85c <cell_string_width>
 800d994:	0040      	lsls	r0, r0, #1
  if (text_w > max_w) {
 800d996:	f5b0 7fe2 	cmp.w	r0, #452	@ 0x1c4
 800d99a:	f2c0 838f 	blt.w	800e0bc <draw_all+0x1904>
      plot_printf(msg, (int)sizeof(msg), "SWR %.2f Refl %.1f%%", swr, pref_pct);
 800d99e:	ed9d 7b04 	vldr	d7, [sp, #16]
 800d9a2:	4ab5      	ldr	r2, [pc, #724]	@ (800dc78 <draw_all+0x14c0>)
 800d9a4:	2150      	movs	r1, #80	@ 0x50
 800d9a6:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800d9aa:	ed8d 7b00 	vstr	d7, [sp]
 800d9ae:	4620      	mov	r0, r4
 800d9b0:	f7f5 f9de 	bl	8002d70 <plot_printf>
    text_w = cell_string_width(msg) * 2;
 800d9b4:	4620      	mov	r0, r4
 800d9b6:	f7fc ff51 	bl	800a85c <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800d9ba:	f240 12c7 	movw	r2, #455	@ 0x1c7
 800d9be:	eba2 0240 	sub.w	r2, r2, r0, lsl #1
 800d9c2:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 800d9c6:	1057      	asrs	r7, r2, #1
    text_w = cell_string_width(msg) * 2;
 800d9c8:	0040      	lsls	r0, r0, #1
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800d9ca:	3705      	adds	r7, #5
    if      (swr <= 1.10f) color_idx = LCD_INTERP_CAL_COLOR; // bright green
 800d9cc:	eddf 7aab 	vldr	s15, [pc, #684]	@ 800dc7c <draw_all+0x14c4>
 800d9d0:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800d9d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d9d8:	f240 82d9 	bls.w	800df8e <draw_all+0x17d6>
    else if (swr <= 1.50f) color_idx = LCD_TRACE_3_COLOR;    // green
 800d9dc:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 800d9e0:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800d9e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d9e8:	f240 82d3 	bls.w	800df92 <draw_all+0x17da>
    else if (swr <= 2.00f) color_idx = LCD_TRACE_1_COLOR;    // yellow
 800d9ec:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800d9f0:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800d9f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d9f8:	f240 835a 	bls.w	800e0b0 <draw_all+0x18f8>
    else if (swr <= 3.00f) color_idx = LCD_TRACE_4_COLOR;    // magenta
 800d9fc:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
    else                   color_idx = LCD_DISABLE_CAL_COLOR;// red
 800da00:	eeb4 8ae7 	vcmpe.f32	s16, s15
 800da04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800da08:	bf94      	ite	ls
 800da0a:	2509      	movls	r5, #9
 800da0c:	2518      	movhi	r5, #24
 800da0e:	e084      	b.n	800db1a <draw_all+0x1362>
      search_index_range_x(x0, x0 + w, index, &i0, &i1);
 800da10:	9914      	ldr	r1, [sp, #80]	@ 0x50
  int head = 0, tail = sweep_points;
 800da12:	4634      	mov	r4, r6
      search_index_range_x(x0, x0 + w, index, &i0, &i1);
 800da14:	eb0b 0701 	add.w	r7, fp, r1
  int head = 0, tail = sweep_points;
 800da18:	4655      	mov	r5, sl
    i = (head + tail) >> 1;
 800da1a:	eb05 0904 	add.w	r9, r5, r4
 800da1e:	ea4f 0969 	mov.w	r9, r9, asr #1
    if (index[i].x >= x2)
 800da22:	f832 1029 	ldrh.w	r1, [r2, r9, lsl #2]
 800da26:	428f      	cmp	r7, r1
 800da28:	dc0b      	bgt.n	800da42 <draw_all+0x128a>
      if (tail == i)
 800da2a:	454c      	cmp	r4, r9
 800da2c:	f43f abd5 	beq.w	800d1da <draw_all+0xa22>
      tail = i;
 800da30:	464c      	mov	r4, r9
    i = (head + tail) >> 1;
 800da32:	eb05 0904 	add.w	r9, r5, r4
 800da36:	ea4f 0969 	mov.w	r9, r9, asr #1
    if (index[i].x >= x2)
 800da3a:	f832 1029 	ldrh.w	r1, [r2, r9, lsl #2]
 800da3e:	428f      	cmp	r7, r1
 800da40:	ddf3      	ble.n	800da2a <draw_all+0x1272>
    else if (index[i].x < x1)
 800da42:	458b      	cmp	fp, r1
 800da44:	f340 81b2 	ble.w	800ddac <draw_all+0x15f4>
      if (head == i)
 800da48:	454d      	cmp	r5, r9
 800da4a:	f43f abc6 	beq.w	800d1da <draw_all+0xa22>
      head = i;
 800da4e:	464d      	mov	r5, r9
 800da50:	e7e3      	b.n	800da1a <draw_all+0x1262>
  if (current_trace == TRACE_INVALID)
 800da52:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 800da54:	f991 301c 	ldrsb.w	r3, [r1, #28]
 800da58:	1c5d      	adds	r5, r3, #1
 800da5a:	f43f ac66 	beq.w	800d32a <draw_all+0xb72>
  uint32_t trace_type = 1 << trace[current_trace].type;
 800da5e:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 800da62:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800da66:	2101      	movs	r1, #1
 800da68:	f892 0029 	ldrb.w	r0, [r2, #41]	@ 0x29
 800da6c:	4081      	lsls	r1, r0
  if (trace_type & ROUND_GRID_MASK)
 800da6e:	f011 0f18 	tst.w	r1, #24
 800da72:	f47f ac5a 	bne.w	800d32a <draw_all+0xb72>
  float ref = NGRIDY - get_trace_refpos(current_trace);
 800da76:	edd2 7a0c 	vldr	s15, [r2, #48]	@ 0x30
  float scale = get_trace_scale(current_trace);
 800da7a:	ed92 9a0b 	vldr	s18, [r2, #44]	@ 0x2c
  int16_t ypos = 0 - y0 + 2;
 800da7e:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 800da80:	f5c2 447f 	rsb	r4, r2, #65280	@ 0xff00
  float ref = NGRIDY - get_trace_refpos(current_trace);
 800da84:	eeb2 8a00 	vmov.f32	s16, #32	@ 0x41000000  8.0
  int16_t ypos = 0 - y0 + 2;
 800da88:	3417      	adds	r4, #23
  int16_t xpos = GRID_X_TEXT - x0;
 800da8a:	f5cb 75d2 	rsb	r5, fp, #420	@ 0x1a4
  if (trace_type & (1 << TRC_SWR))
 800da8e:	2806      	cmp	r0, #6
  float ref = NGRIDY - get_trace_refpos(current_trace);
 800da90:	ee38 8a67 	vsub.f32	s16, s16, s15
  int16_t ypos = 0 - y0 + 2;
 800da94:	b224      	sxth	r4, r4
  int16_t xpos = GRID_X_TEXT - x0;
 800da96:	b22d      	sxth	r5, r5
  if (trace_type & (1 << TRC_SWR))
 800da98:	d105      	bne.n	800daa6 <draw_all+0x12ee>
    ref += 1.0f / scale; // For SWR trace, value shift by 1.0
 800da9a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800da9e:	eec7 7a09 	vdiv.f32	s15, s14, s18
 800daa2:	ee38 8a27 	vadd.f32	s16, s16, s15
  lcd_set_foreground(LCD_TRACE_1_COLOR + current_trace);
 800daa6:	3306      	adds	r3, #6
 800daa8:	b298      	uxth	r0, r3
 800daaa:	f003 faed 	bl	8011088 <lcd_set_foreground>
    ref -= 1.0f;
 800daae:	eef7 9a00 	vmov.f32	s19, #112	@ 0x3f800000  1.0
    cell_printf(xpos, ypos, "% 6.3F", ref * scale);
 800dab2:	ee69 7a08 	vmul.f32	s15, s18, s16
    ref -= 1.0f;
 800dab6:	ee38 8a69 	vsub.f32	s16, s16, s19
    cell_printf(xpos, ypos, "% 6.3F", ref * scale);
 800daba:	ee17 0a90 	vmov	r0, s15
 800dabe:	f7f2 fd6f 	bl	80005a0 <__aeabi_f2d>
 800dac2:	e9cd 0100 	strd	r0, r1, [sp]
 800dac6:	4621      	mov	r1, r4
 800dac8:	3426      	adds	r4, #38	@ 0x26
 800daca:	4a6d      	ldr	r2, [pc, #436]	@ (800dc80 <draw_all+0x14c8>)
 800dacc:	4628      	mov	r0, r5
  } while ((ypos += GRIDY) < CELLHEIGHT);
 800dace:	b224      	sxth	r4, r4
    cell_printf(xpos, ypos, "% 6.3F", ref * scale);
 800dad0:	f7fd f888 	bl	800abe4 <cell_printf>
  } while ((ypos += GRIDY) < CELLHEIGHT);
 800dad4:	2c1f      	cmp	r4, #31
 800dad6:	ddec      	ble.n	800dab2 <draw_all+0x12fa>
 800dad8:	e427      	b.n	800d32a <draw_all+0xb72>
    plot_printf(msg, (int)sizeof(msg), "SWR --.--  |  Refl --.-%%");
 800dada:	ac22      	add	r4, sp, #136	@ 0x88
 800dadc:	4a69      	ldr	r2, [pc, #420]	@ (800dc84 <draw_all+0x14cc>)
 800dade:	2150      	movs	r1, #80	@ 0x50
 800dae0:	4620      	mov	r0, r4
 800dae2:	f7f5 f945 	bl	8002d70 <plot_printf>
  int text_w = cell_string_width(msg) * 2; // BIG font => *2
 800dae6:	4620      	mov	r0, r4
 800dae8:	f7fc feb8 	bl	800a85c <cell_string_width>
 800daec:	0040      	lsls	r0, r0, #1
  if (text_w > max_w) {
 800daee:	f5b0 7fe2 	cmp.w	r0, #452	@ 0x1c4
 800daf2:	f2c0 80b2 	blt.w	800dc5a <draw_all+0x14a2>
      plot_printf(msg, (int)sizeof(msg), "SWR --.-- Refl --.-%%");
 800daf6:	4a64      	ldr	r2, [pc, #400]	@ (800dc88 <draw_all+0x14d0>)
 800daf8:	2150      	movs	r1, #80	@ 0x50
 800dafa:	4620      	mov	r0, r4
 800dafc:	f7f5 f938 	bl	8002d70 <plot_printf>
    text_w = cell_string_width(msg) * 2;
 800db00:	4620      	mov	r0, r4
 800db02:	f7fc feab 	bl	800a85c <cell_string_width>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800db06:	f240 12c7 	movw	r2, #455	@ 0x1c7
 800db0a:	eba2 0240 	sub.w	r2, r2, r0, lsl #1
 800db0e:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 800db12:	1057      	asrs	r7, r2, #1
    text_w = cell_string_width(msg) * 2;
 800db14:	0040      	lsls	r0, r0, #1
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800db16:	3705      	adds	r7, #5
  uint16_t color_idx = LCD_BW_TEXT_COLOR; // gray for invalid/unlocked
 800db18:	2512      	movs	r5, #18
  cell_fill_bg_rect(x0, y0, x, y, text_w, text_ht);
 800db1a:	463a      	mov	r2, r7
 800db1c:	9000      	str	r0, [sp, #0]
 800db1e:	232a      	movs	r3, #42	@ 0x2a
 800db20:	2120      	movs	r1, #32
 800db22:	4658      	mov	r0, fp
 800db24:	f7fd fd1e 	bl	800b564 <cell_fill_bg_rect.constprop.0>
  lcd_set_foreground(color_idx);
 800db28:	4628      	mov	r0, r5
 800db2a:	f003 faad 	bl	8011088 <lcd_set_foreground>
  cell_drawstring_big(msg, x - x0, y - y0);
 800db2e:	eba7 010b 	sub.w	r1, r7, fp
 800db32:	220a      	movs	r2, #10
 800db34:	4620      	mov	r0, r4
 800db36:	f7fc fead 	bl	800a894 <cell_drawstring_big>
}
 800db3a:	f7ff b9b1 	b.w	800cea0 <draw_all+0x6e8>
      if (mk == active_marker && lever_mode == LM_MARKER)
 800db3e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 800db40:	7f1b      	ldrb	r3, [r3, #28]
 800db42:	2b00      	cmp	r3, #0
 800db44:	f47f ad5c 	bne.w	800d600 <draw_all+0xe48>
        cell_printf(xpos, ypos, S_SARROW);
 800db48:	4a50      	ldr	r2, [pc, #320]	@ (800dc8c <draw_all+0x14d4>)
 800db4a:	4651      	mov	r1, sl
 800db4c:	b228      	sxth	r0, r5
 800db4e:	f7fd f849 	bl	800abe4 <cell_printf>
 800db52:	e555      	b.n	800d600 <draw_all+0xe48>
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800db54:	f800 5f01 	strb.w	r5, [r0, #1]!
  lcd_printf(x, y += sFONT_STR_HEIGHT, "P%c", current_props._power > 3 ? ('a') : (current_props._power * 2 + '2'));
 800db58:	4613      	mov	r3, r2
 800db5a:	f7fe bfce 	b.w	800cafa <draw_all+0x342>
  for (int power = BATTERY_TOP_LEVEL; power > BATTERY_BOTTOM_LEVEL;)
 800db5e:	f5b1 6f48 	cmp.w	r1, #3200	@ 0xc80
    string_buf[x++] = (power > vbat) ? 0b10000001 : 0b10111101;
 800db62:	f800 5f01 	strb.w	r5, [r0, #1]!
  for (int power = BATTERY_TOP_LEVEL; power > BATTERY_BOTTOM_LEVEL;)
 800db66:	dcf7      	bgt.n	800db58 <draw_all+0x13a0>
 800db68:	f103 01d8 	add.w	r1, r3, #216	@ 0xd8
 800db6c:	4469      	add	r1, sp
 800db6e:	f7fe bfd4 	b.w	800cb1a <draw_all+0x362>
    ypos = 1 + ((j + 1) / 2) * FONT_STR_HEIGHT - y0;
 800db72:	f108 0301 	add.w	r3, r8, #1
 800db76:	105b      	asrs	r3, r3, #1
 800db78:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800db7c:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    if (!(props_mode & TD_MARKER_DELTA) && active_marker != previous_marker)
 800db80:	990b      	ldr	r1, [sp, #44]	@ 0x2c
    ypos = 1 + ((j + 1) / 2) * FONT_STR_HEIGHT - y0;
 800db82:	9a08      	ldr	r2, [sp, #32]
 800db84:	f8dd b048 	ldr.w	fp, [sp, #72]	@ 0x48
 800db88:	3301      	adds	r3, #1
 800db8a:	1a9d      	subs	r5, r3, r2
    if (!(props_mode & TD_MARKER_DELTA) && active_marker != previous_marker)
 800db8c:	8b0b      	ldrh	r3, [r1, #24]
 800db8e:	05d8      	lsls	r0, r3, #23
 800db90:	f53f adfc 	bmi.w	800d78c <draw_all+0xfd4>
 800db94:	f991 301d 	ldrsb.w	r3, [r1, #29]
 800db98:	f991 201e 	ldrsb.w	r2, [r1, #30]
 800db9c:	4293      	cmp	r3, r2
 800db9e:	f43f adf5 	beq.w	800d78c <draw_all+0xfd4>
      int previous_marker_idx = markers[previous_marker].index;
 800dba2:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 800dba6:	fa1f f48b 	uxth.w	r4, fp
      cell_printf(xpos, ypos, S_DELTA "%d-%d:", active_marker + 1, previous_marker + 1);
 800dbaa:	3201      	adds	r2, #1
 800dbac:	f1c4 00fd 	rsb	r0, r4, #253	@ 0xfd
 800dbb0:	b22e      	sxth	r6, r5
      int previous_marker_idx = markers[previous_marker].index;
 800dbb2:	f8b1 705a 	ldrh.w	r7, [r1, #90]	@ 0x5a
      cell_printf(xpos, ypos, S_DELTA "%d-%d:", active_marker + 1, previous_marker + 1);
 800dbb6:	9200      	str	r2, [sp, #0]
 800dbb8:	3301      	adds	r3, #1
 800dbba:	4a35      	ldr	r2, [pc, #212]	@ (800dc90 <draw_all+0x14d8>)
 800dbbc:	4631      	mov	r1, r6
 800dbbe:	b200      	sxth	r0, r0
 800dbc0:	f7fd f810 	bl	800abe4 <cell_printf>
      if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800dbc4:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 800dbc6:	8b13      	ldrh	r3, [r2, #24]
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800dbc8:	f5c4 7491 	rsb	r4, r4, #290	@ 0x122
      if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800dbcc:	07d9      	lsls	r1, r3, #31
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800dbce:	b224      	sxth	r4, r4
      if ((props_mode & DOMAIN_MODE) == DOMAIN_FREQ)
 800dbd0:	f100 81b2 	bmi.w	800df38 <draw_all+0x1780>
        freq_t freq = get_marker_frequency(active_marker);
 800dbd4:	f992 001d 	ldrsb.w	r0, [r2, #29]
 800dbd8:	f7f9 ff72 	bl	8007ac0 <get_marker_frequency>
        freq_t freq1 = get_marker_frequency(previous_marker);
 800dbdc:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
        freq_t freq = get_marker_frequency(active_marker);
 800dbde:	4607      	mov	r7, r0
        freq_t freq1 = get_marker_frequency(previous_marker);
 800dbe0:	f992 001e 	ldrsb.w	r0, [r2, #30]
 800dbe4:	f7f9 ff6c 	bl	8007ac0 <get_marker_frequency>
        freq_t delta = freq >= freq1 ? freq - freq1 : freq1 - freq;
 800dbe8:	4287      	cmp	r7, r0
        freq_t freq1 = get_marker_frequency(previous_marker);
 800dbea:	4603      	mov	r3, r0
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800dbec:	bf27      	ittee	cs
 800dbee:	222b      	movcs	r2, #43	@ 0x2b
        freq_t delta = freq >= freq1 ? freq - freq1 : freq1 - freq;
 800dbf0:	1a3b      	subcs	r3, r7, r0
 800dbf2:	1bdb      	subcc	r3, r3, r7
        cell_printf(xpos, ypos, "%c%q" S_Hz, freq >= freq1 ? '+' : '-', delta);
 800dbf4:	222d      	movcc	r2, #45	@ 0x2d
 800dbf6:	9300      	str	r3, [sp, #0]
 800dbf8:	4631      	mov	r1, r6
 800dbfa:	4613      	mov	r3, r2
 800dbfc:	4620      	mov	r0, r4
 800dbfe:	4a25      	ldr	r2, [pc, #148]	@ (800dc94 <draw_all+0x14dc>)
 800dc00:	f7fc fff0 	bl	800abe4 <cell_printf>
 800dc04:	e5c2      	b.n	800d78c <draw_all+0xfd4>
    float q = (float)mla_res_freq / (float)mla_bw_swr2;
 800dc06:	ee07 3a90 	vmov	s15, r3
 800dc0a:	ee07 2a10 	vmov	s14, r2
 800dc0e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800dc12:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    q_int = (uint32_t)(q + 0.5f); // round to nearest integer
 800dc16:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
    float q = (float)mla_res_freq / (float)mla_bw_swr2;
 800dc1a:	eec7 6a87 	vdiv.f32	s13, s15, s14
    plot_printf(msg, (int)sizeof(msg), "Q2=%u", (unsigned)q_int);
 800dc1e:	4a1e      	ldr	r2, [pc, #120]	@ (800dc98 <draw_all+0x14e0>)
 800dc20:	2118      	movs	r1, #24
 800dc22:	4620      	mov	r0, r4
    q_int = (uint32_t)(q + 0.5f); // round to nearest integer
 800dc24:	ee76 7a86 	vadd.f32	s15, s13, s12
    plot_printf(msg, (int)sizeof(msg), "Q2=%u", (unsigned)q_int);
 800dc28:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800dc2c:	ee17 3a90 	vmov	r3, s15
 800dc30:	f7f5 f89e 	bl	8002d70 <plot_printf>
  {
 800dc34:	f7ff b96f 	b.w	800cf16 <draw_all+0x75e>
  for (t = TRACE_INDEX_COUNT - 1; t >= 0; t--)
 800dc38:	4b18      	ldr	r3, [pc, #96]	@ (800dc9c <draw_all+0x14e4>)
 800dc3a:	f2a2 6244 	subw	r2, r2, #1604	@ 0x644
 800dc3e:	2003      	movs	r0, #3
 800dc40:	f7ff bad3 	b.w	800d1ea <draw_all+0xa32>
    format = (scale != 1.0f) ? "%s %0.1fFS" : "%s ";
 800dc44:	ee07 aa10 	vmov	s14, sl
 800dc48:	eeb4 7a67 	vcmp.f32	s14, s15
 800dc4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800dc50:	f040 80a0 	bne.w	800dd94 <draw_all+0x15dc>
 800dc54:	4b12      	ldr	r3, [pc, #72]	@ (800dca0 <draw_all+0x14e8>)
 800dc56:	9310      	str	r3, [sp, #64]	@ 0x40
 800dc58:	e53f      	b.n	800d6da <draw_all+0xf22>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800dc5a:	f5c0 72e3 	rsb	r2, r0, #454	@ 0x1c6
 800dc5e:	3201      	adds	r2, #1
 800dc60:	1052      	asrs	r2, r2, #1
 800dc62:	1d57      	adds	r7, r2, #5
  uint16_t color_idx = LCD_BW_TEXT_COLOR; // gray for invalid/unlocked
 800dc64:	2512      	movs	r5, #18
 800dc66:	e758      	b.n	800db1a <draw_all+0x1362>
 800dc68:	20006880 	.word	0x20006880
 800dc6c:	42c80000 	.word	0x42c80000
 800dc70:	3f800347 	.word	0x3f800347
 800dc74:	08013cf0 	.word	0x08013cf0
 800dc78:	08013d28 	.word	0x08013d28
 800dc7c:	3f8ccccd 	.word	0x3f8ccccd
 800dc80:	08013c60 	.word	0x08013c60
 800dc84:	08013d0c 	.word	0x08013d0c
 800dc88:	08013d40 	.word	0x08013d40
 800dc8c:	08013c68 	.word	0x08013c68
 800dc90:	08013c80 	.word	0x08013c80
 800dc94:	08013c88 	.word	0x08013c88
 800dc98:	08013d70 	.word	0x08013d70
 800dc9c:	20000a9c 	.word	0x20000a9c
 800dca0:	08013164 	.word	0x08013164
 800dca4:	42180000 	.word	0x42180000
 800dca8:	43984000 	.word	0x43984000
  float refpos = HEIGHT - (get_trace_refpos(t)) * GRIDY + 0.5f;   // 0.5 for pixel align
 800dcac:	ed1f 7a03 	vldr	s14, [pc, #-12]	@ 800dca4 <draw_all+0x14ec>
 800dcb0:	edd8 6a0c 	vldr	s13, [r8, #48]	@ 0x30
 800dcb4:	ed5f 8a04 	vldr	s17, [pc, #-16]	@ 800dca8 <draw_all+0x14f0>
  get_value_cb_t c = trace_info_list[trace[t].type].get_value_cb; // Get callback for value calculation
 800dcb8:	4ac9      	ldr	r2, [pc, #804]	@ (800dfe0 <draw_all+0x1828>)
      float v = c ? c(i, array[i]) : 0.0f; // Get value
 800dcba:	eddf 9aca 	vldr	s19, [pc, #808]	@ 800dfe4 <draw_all+0x182c>
    const float dscale = GRIDY / scale;
 800dcbe:	ee87 9a27 	vdiv.f32	s18, s14, s15
    if (type & (1 << TRC_SWR))
 800dcc2:	2b06      	cmp	r3, #6
  get_value_cb_t c = trace_info_list[trace[t].type].get_value_cb; // Get callback for value calculation
 800dcc4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800dcc8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    uint32_t dx = ((WIDTH) << 16) / (sweep_points - 1), x = (CELLOFFSETX << 16) + dx * start + 0x8000;
 800dccc:	f04f 0a00 	mov.w	sl, #0
  get_value_cb_t c = trace_info_list[trace[t].type].get_value_cb; // Get callback for value calculation
 800dcd0:	f8d3 b018 	ldr.w	fp, [r3, #24]
    uint32_t dx = ((WIDTH) << 16) / (sweep_points - 1), x = (CELLOFFSETX << 16) + dx * start + 0x8000;
 800dcd4:	4bc4      	ldr	r3, [pc, #784]	@ (800dfe8 <draw_all+0x1830>)
 800dcd6:	fb93 f3f1 	sdiv	r3, r3, r1
 800dcda:	9304      	str	r3, [sp, #16]
 800dcdc:	4623      	mov	r3, r4
 800dcde:	f44f 29b0 	mov.w	r9, #360448	@ 0x58000
 800dce2:	465c      	mov	r4, fp
 800dce4:	4655      	mov	r5, sl
 800dce6:	469b      	mov	fp, r3
  float refpos = HEIGHT - (get_trace_refpos(t)) * GRIDY + 0.5f;   // 0.5 for pixel align
 800dce8:	eee6 8ac7 	vfms.f32	s17, s13, s14
      refpos += dscale; // For SWR need shift value by 1.0 down
 800dcec:	bf08      	it	eq
 800dcee:	ee78 8a89 	vaddeq.f32	s17, s17, s18
        y = refpos - v * dscale;
 800dcf2:	eeb1 9a49 	vneg.f32	s18, s18
 800dcf6:	e02b      	b.n	800dd50 <draw_all+0x1598>
      float v = c ? c(i, array[i]) : 0.0f; // Get value
 800dcf8:	eb06 01c0 	add.w	r1, r6, r0, lsl #3
 800dcfc:	47a0      	blx	r4
 800dcfe:	eeb0 8a40 	vmov.f32	s16, s0
      if (v == infinityf())
 800dd02:	f004 fbd3 	bl	80124ac <infinityf>
 800dd06:	eeb4 0a48 	vcmp.f32	s0, s16
        y = refpos - v * dscale;
 800dd0a:	eef0 7a68 	vmov.f32	s15, s17
      if (v == infinityf())
 800dd0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        y = refpos - v * dscale;
 800dd12:	eee8 7a09 	vfma.f32	s15, s16, s18
        if (y < 0)
 800dd16:	f04f 0300 	mov.w	r3, #0
      if (v == infinityf())
 800dd1a:	d00b      	beq.n	800dd34 <draw_all+0x157c>
        y = refpos - v * dscale;
 800dd1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800dd20:	ee17 3a90 	vmov	r3, s15
        else if (y > HEIGHT)
 800dd24:	f5b3 7f98 	cmp.w	r3, #304	@ 0x130
 800dd28:	bfa8      	it	ge
 800dd2a:	f44f 7398 	movge.w	r3, #304	@ 0x130
        if (y < 0)
 800dd2e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
      mark_set_index(index, i, (uint16_t)(x >> 16), y);
 800dd32:	b29b      	uxth	r3, r3
 800dd34:	4629      	mov	r1, r5
 800dd36:	ea4f 4219 	mov.w	r2, r9, lsr #16
 800dd3a:	4658      	mov	r0, fp
    for (i = start; i <= stop; i++, x += dx)
 800dd3c:	f10a 0a01 	add.w	sl, sl, #1
      mark_set_index(index, i, (uint16_t)(x >> 16), y);
 800dd40:	f7fc fc62 	bl	800a608 <mark_set_index>
    for (i = start; i <= stop; i++, x += dx)
 800dd44:	fa1f f58a 	uxth.w	r5, sl
 800dd48:	9b04      	ldr	r3, [sp, #16]
 800dd4a:	42af      	cmp	r7, r5
 800dd4c:	4499      	add	r9, r3
 800dd4e:	d306      	bcc.n	800dd5e <draw_all+0x15a6>
      float v = c ? c(i, array[i]) : 0.0f; // Get value
 800dd50:	fa1f f08a 	uxth.w	r0, sl
 800dd54:	2c00      	cmp	r4, #0
 800dd56:	d1cf      	bne.n	800dcf8 <draw_all+0x1540>
 800dd58:	eeb0 8a69 	vmov.f32	s16, s19
 800dd5c:	e7d1      	b.n	800dd02 <draw_all+0x154a>
 800dd5e:	465c      	mov	r4, fp
 800dd60:	f7fe bf09 	b.w	800cb76 <draw_all+0x3be>
      cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx), distance_of_index(active_marker_idx));
 800dd64:	9804      	ldr	r0, [sp, #16]
 800dd66:	f7fc fce1 	bl	800a72c <time_of_index>
 800dd6a:	ee10 4a10 	vmov	r4, s0
 800dd6e:	f7fc fcf3 	bl	800a758 <distance_of_index>
 800dd72:	ee10 0a10 	vmov	r0, s0
 800dd76:	f7f2 fc13 	bl	80005a0 <__aeabi_f2d>
 800dd7a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800dd7e:	4620      	mov	r0, r4
 800dd80:	f7f2 fc0e 	bl	80005a0 <__aeabi_f2d>
 800dd84:	4a99      	ldr	r2, [pc, #612]	@ (800dfec <draw_all+0x1834>)
 800dd86:	e9cd 0100 	strd	r0, r1, [sp]
 800dd8a:	4631      	mov	r1, r6
 800dd8c:	4638      	mov	r0, r7
 800dd8e:	f7fc ff29 	bl	800abe4 <cell_printf>
 800dd92:	e4fb      	b.n	800d78c <draw_all+0xfd4>
    format = (scale != 1.0f) ? "%s %0.1fFS" : "%s ";
 800dd94:	4b96      	ldr	r3, [pc, #600]	@ (800dff0 <draw_all+0x1838>)
 800dd96:	9310      	str	r3, [sp, #64]	@ 0x40
 800dd98:	e49f      	b.n	800d6da <draw_all+0xf22>
 800dd9a:	4d96      	ldr	r5, [pc, #600]	@ (800dff4 <draw_all+0x183c>)
 800dd9c:	4644      	mov	r4, r8
 800dd9e:	e463      	b.n	800d668 <draw_all+0xeb0>
        cell_printf(xpos, ypos, S_SARROW);
 800dda0:	4a95      	ldr	r2, [pc, #596]	@ (800dff8 <draw_all+0x1840>)
 800dda2:	4649      	mov	r1, r9
 800dda4:	b230      	sxth	r0, r6
 800dda6:	f7fc ff1d 	bl	800abe4 <cell_printf>
 800ddaa:	e477      	b.n	800d69c <draw_all+0xee4>
  *i0 = *i1 = i;
 800ddac:	46cc      	mov	ip, r9
 800ddae:	e005      	b.n	800ddbc <draw_all+0x1604>
  while (*i0 > 0 && x1 <= index[--*i0].x)
 800ddb0:	f10c 3cff 	add.w	ip, ip, #4294967295
 800ddb4:	f832 102c 	ldrh.w	r1, [r2, ip, lsl #2]
 800ddb8:	458b      	cmp	fp, r1
 800ddba:	dc02      	bgt.n	800ddc2 <draw_all+0x160a>
 800ddbc:	f1bc 0f00 	cmp.w	ip, #0
 800ddc0:	dcf6      	bgt.n	800ddb0 <draw_all+0x15f8>
  while (*i1 < sweep_points - 1 && x2 > index[++*i1].x)
 800ddc2:	3e01      	subs	r6, #1
 800ddc4:	e006      	b.n	800ddd4 <draw_all+0x161c>
 800ddc6:	f109 0901 	add.w	r9, r9, #1
 800ddca:	f832 1029 	ldrh.w	r1, [r2, r9, lsl #2]
 800ddce:	428f      	cmp	r7, r1
 800ddd0:	f77f aa24 	ble.w	800d21c <draw_all+0xa64>
 800ddd4:	45b1      	cmp	r9, r6
 800ddd6:	dbf6      	blt.n	800ddc6 <draw_all+0x160e>
 800ddd8:	f7ff ba20 	b.w	800d21c <draw_all+0xa64>
      markmap_all_markers();
 800dddc:	f7fe fa2c 	bl	800c238 <markmap_all_markers>
    if (redraw_request & REDRAW_REFERENCE)
 800dde0:	4b86      	ldr	r3, [pc, #536]	@ (800dffc <draw_all+0x1844>)
 800dde2:	881c      	ldrh	r4, [r3, #0]
 800dde4:	0660      	lsls	r0, r4, #25
 800dde6:	f57e ad03 	bpl.w	800c7f0 <draw_all+0x38>
  invalidate_rect(0, 0, CELLOFFSETX + 1, AREA_HEIGHT_NORMAL);
 800ddea:	2200      	movs	r2, #0
 800ddec:	4611      	mov	r1, r2
 800ddee:	2309      	movs	r3, #9
 800ddf0:	4610      	mov	r0, r2
 800ddf2:	f7fc fc55 	bl	800a6a0 <invalidate_rect_func>
    if (redraw_request & REDRAW_GRID_VALUE)
 800ddf6:	0621      	lsls	r1, r4, #24
 800ddf8:	d504      	bpl.n	800de04 <draw_all+0x164c>
  if (VNA_MODE(VNA_MODE_SHOW_GRID))
 800ddfa:	4b81      	ldr	r3, [pc, #516]	@ (800e000 <draw_all+0x1848>)
 800ddfc:	8a9b      	ldrh	r3, [r3, #20]
 800ddfe:	06db      	lsls	r3, r3, #27
 800de00:	f100 814f 	bmi.w	800e0a2 <draw_all+0x18ea>
  if (redraw_request & (REDRAW_CELLS | REDRAW_MARKER | REDRAW_GRID_VALUE | REDRAW_REFERENCE | REDRAW_AREA))
 800de04:	4e7f      	ldr	r6, [pc, #508]	@ (800e004 <draw_all+0x184c>)
 800de06:	f7fe bd20 	b.w	800c84a <draw_all+0x92>
    marker_search();
 800de0a:	f7fe fb11 	bl	800c430 <marker_search>
 800de0e:	f7fe bebe 	b.w	800cb8e <draw_all+0x3d6>
      lcd_line(CELLOFFSETX + 10, y, CELLOFFSETX + WIDTH - 1, y);
 800de12:	f240 12cb 	movw	r2, #459	@ 0x1cb
 800de16:	4619      	mov	r1, r3
 800de18:	200f      	movs	r0, #15
 800de1a:	f003 f893 	bl	8010f44 <lcd_line>
 800de1e:	f7fe bf3e 	b.w	800cc9e <draw_all+0x4e6>
      cell_printf(xpos, ypos, S_SARROW);
 800de22:	f1cb 00fd 	rsb	r0, fp, #253	@ 0xfd
 800de26:	4a74      	ldr	r2, [pc, #464]	@ (800dff8 <draw_all+0x1840>)
 800de28:	4631      	mov	r1, r6
 800de2a:	b200      	sxth	r0, r0
 800de2c:	f7fc feda 	bl	800abe4 <cell_printf>
 800de30:	e48c      	b.n	800d74c <draw_all+0xf94>
    lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "START 0" S_SECOND "    VF = %d%%", velocity_factor);
 800de32:	f894 3099 	ldrb.w	r3, [r4, #153]	@ 0x99
 800de36:	4a74      	ldr	r2, [pc, #464]	@ (800e008 <draw_all+0x1850>)
 800de38:	f240 1133 	movw	r1, #307	@ 0x133
 800de3c:	200f      	movs	r0, #15
 800de3e:	f003 f9cb 	bl	80111d8 <lcd_printf>
    lcd_printf(FREQUENCIES_XPOS2, FREQUENCIES_YPOS, "STOP %F" S_SECOND " (%F" S_METRE ")", time_of_index(sweep_points - 1), distance_of_index(sweep_points - 1));
 800de42:	8b60      	ldrh	r0, [r4, #26]
 800de44:	3801      	subs	r0, #1
 800de46:	f7fc fc71 	bl	800a72c <time_of_index>
 800de4a:	ee10 5a10 	vmov	r5, s0
 800de4e:	f7fc fc83 	bl	800a758 <distance_of_index>
 800de52:	ee10 0a10 	vmov	r0, s0
 800de56:	f7f2 fba3 	bl	80005a0 <__aeabi_f2d>
 800de5a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800de5e:	4628      	mov	r0, r5
 800de60:	f7f2 fb9e 	bl	80005a0 <__aeabi_f2d>
 800de64:	4a69      	ldr	r2, [pc, #420]	@ (800e00c <draw_all+0x1854>)
 800de66:	e9cd 0100 	strd	r0, r1, [sp]
 800de6a:	f240 1133 	movw	r1, #307	@ 0x133
 800de6e:	f44f 70a3 	mov.w	r0, #326	@ 0x146
 800de72:	f003 f9b1 	bl	80111d8 <lcd_printf>
 800de76:	f7fe bd85 	b.w	800c984 <draw_all+0x1cc>
  char lm1 = lever_mode == LM_FREQ_1 ? S_SARROW[0] : ' ';
 800de7a:	462e      	mov	r6, r5
 800de7c:	f7fe bd53 	b.w	800c926 <draw_all+0x16e>
    case ST_CENTER: return (frequency0>>1) + (frequency1>>1) + (frequency0&1);
 800de80:	085b      	lsrs	r3, r3, #1
 800de82:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 800de86:	f002 0201 	and.w	r2, r2, #1
 800de8a:	4413      	add	r3, r2
      lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm0, "CENTER", get_sweep_frequency(ST_CENTER));
 800de8c:	4a60      	ldr	r2, [pc, #384]	@ (800e010 <draw_all+0x1858>)
 800de8e:	9301      	str	r3, [sp, #4]
 800de90:	9200      	str	r2, [sp, #0]
 800de92:	462b      	mov	r3, r5
 800de94:	4a5f      	ldr	r2, [pc, #380]	@ (800e014 <draw_all+0x185c>)
 800de96:	f240 1133 	movw	r1, #307	@ 0x133
 800de9a:	200f      	movs	r0, #15
 800de9c:	f003 f99c 	bl	80111d8 <lcd_printf>
    case ST_SPAN:   return frequency1 - frequency0;
 800dea0:	6861      	ldr	r1, [r4, #4]
 800dea2:	68a2      	ldr	r2, [r4, #8]
 800dea4:	1a52      	subs	r2, r2, r1
      lcd_printf(FREQUENCIES_XPOS2, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm1, "SPAN", get_sweep_frequency(ST_SPAN));
 800dea6:	9201      	str	r2, [sp, #4]
 800dea8:	4a5b      	ldr	r2, [pc, #364]	@ (800e018 <draw_all+0x1860>)
 800deaa:	9200      	str	r2, [sp, #0]
 800deac:	4633      	mov	r3, r6
 800deae:	4a59      	ldr	r2, [pc, #356]	@ (800e014 <draw_all+0x185c>)
 800deb0:	f240 1133 	movw	r1, #307	@ 0x133
 800deb4:	f44f 70a3 	mov.w	r0, #326	@ 0x146
 800deb8:	f003 f98e 	bl	80111d8 <lcd_printf>
 800debc:	f7fe bd62 	b.w	800c984 <draw_all+0x1cc>
      lcd_set_foreground(LCD_FG_COLOR);
 800dec0:	2001      	movs	r0, #1
 800dec2:	f003 f8e1 	bl	8011088 <lcd_set_foreground>
 800dec6:	f7fe bd9d 	b.w	800ca04 <draw_all+0x24c>
    lcd_set_colors(LCD_BG_COLOR, LCD_BG_COLOR);
 800deca:	4608      	mov	r0, r1
 800decc:	f003 f8f4 	bl	80110b8 <lcd_set_colors>
    lcd_fill(BATTERY_ICON_POSX, BATTERY_ICON_POSY, 8, 18);  // 18 is a safe icon height
 800ded0:	2312      	movs	r3, #18
 800ded2:	2208      	movs	r2, #8
 800ded4:	2102      	movs	r1, #2
 800ded6:	2003      	movs	r0, #3
 800ded8:	f002 ffe8 	bl	8010eac <lcd_fill>
    return;
 800dedc:	f7fe bc98 	b.w	800c810 <draw_all+0x58>
      g = (swr - 1.0f) / (swr + 1.0f);
 800dee0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800dee4:	ee78 6a67 	vsub.f32	s13, s16, s15
 800dee8:	ee38 7a27 	vadd.f32	s14, s16, s15
 800deec:	eec6 7a87 	vdiv.f32	s15, s13, s14
      pref_pct = 100.0f * g * g;
 800def0:	ee67 7aa7 	vmul.f32	s15, s15, s15
    plot_printf(msg, (int)sizeof(msg), "SWR %.2f  |  Refl %.1f%%", swr, pref_pct);
 800def4:	ee67 7a89 	vmul.f32	s15, s15, s18
 800def8:	ee17 0a90 	vmov	r0, s15
 800defc:	f7f2 fb50 	bl	80005a0 <__aeabi_f2d>
 800df00:	ec45 4b17 	vmov	d7, r4, r5
 800df04:	4680      	mov	r8, r0
 800df06:	4689      	mov	r9, r1
 800df08:	ac22      	add	r4, sp, #136	@ 0x88
 800df0a:	4a44      	ldr	r2, [pc, #272]	@ (800e01c <draw_all+0x1864>)
 800df0c:	2150      	movs	r1, #80	@ 0x50
 800df0e:	ed8d 7b00 	vstr	d7, [sp]
 800df12:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800df16:	4620      	mov	r0, r4
 800df18:	f7f4 ff2a 	bl	8002d70 <plot_printf>
  int text_w = cell_string_width(msg) * 2; // BIG font => *2
 800df1c:	4620      	mov	r0, r4
 800df1e:	f7fc fc9d 	bl	800a85c <cell_string_width>
 800df22:	0040      	lsls	r0, r0, #1
  if (text_w > max_w) {
 800df24:	f5b0 7fe2 	cmp.w	r0, #452	@ 0x1c4
 800df28:	f6bf ad39 	bge.w	800d99e <draw_all+0x11e6>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800df2c:	f5c0 72e3 	rsb	r2, r0, #454	@ 0x1c6
 800df30:	3201      	adds	r2, #1
 800df32:	1052      	asrs	r2, r2, #1
 800df34:	1d57      	adds	r7, r2, #5
  if (valid) {
 800df36:	e549      	b.n	800d9cc <draw_all+0x1214>
        cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx) - time_of_index(previous_marker_idx),
 800df38:	f8dd 8010 	ldr.w	r8, [sp, #16]
 800df3c:	4640      	mov	r0, r8
 800df3e:	f7fc fbf5 	bl	800a72c <time_of_index>
 800df42:	4638      	mov	r0, r7
 800df44:	eeb0 9a40 	vmov.f32	s18, s0
 800df48:	f7fc fbf0 	bl	800a72c <time_of_index>
                    distance_of_index(active_marker_idx) - distance_of_index(previous_marker_idx));
 800df4c:	4640      	mov	r0, r8
        cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx) - time_of_index(previous_marker_idx),
 800df4e:	eeb0 8a40 	vmov.f32	s16, s0
                    distance_of_index(active_marker_idx) - distance_of_index(previous_marker_idx));
 800df52:	f7fc fc01 	bl	800a758 <distance_of_index>
 800df56:	4638      	mov	r0, r7
 800df58:	eef0 6a40 	vmov.f32	s13, s0
 800df5c:	f7fc fbfc 	bl	800a758 <distance_of_index>
        cell_printf(xpos, ypos, "%F" S_SECOND " (%F" S_METRE ")", time_of_index(active_marker_idx) - time_of_index(previous_marker_idx),
 800df60:	ee76 7ac0 	vsub.f32	s15, s13, s0
 800df64:	ee17 0a90 	vmov	r0, s15
 800df68:	f7f2 fb1a 	bl	80005a0 <__aeabi_f2d>
 800df6c:	ee79 7a48 	vsub.f32	s15, s18, s16
 800df70:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800df74:	ee17 0a90 	vmov	r0, s15
 800df78:	f7f2 fb12 	bl	80005a0 <__aeabi_f2d>
 800df7c:	4a1b      	ldr	r2, [pc, #108]	@ (800dfec <draw_all+0x1834>)
 800df7e:	e9cd 0100 	strd	r0, r1, [sp]
 800df82:	4631      	mov	r1, r6
 800df84:	4620      	mov	r0, r4
 800df86:	f7fc fe2d 	bl	800abe4 <cell_printf>
 800df8a:	f7ff bbff 	b.w	800d78c <draw_all+0xfd4>
    if      (swr <= 1.10f) color_idx = LCD_INTERP_CAL_COLOR; // bright green
 800df8e:	2517      	movs	r5, #23
 800df90:	e5c3      	b.n	800db1a <draw_all+0x1362>
    else if (swr <= 1.50f) color_idx = LCD_TRACE_3_COLOR;    // green
 800df92:	2508      	movs	r5, #8
 800df94:	e5c1      	b.n	800db1a <draw_all+0x1362>
 800df96:	4c22      	ldr	r4, [pc, #136]	@ (800e020 <draw_all+0x1868>)
 800df98:	f7fe bc77 	b.w	800c88a <draw_all+0xd2>
  int group = 0;
 800df9c:	9a15      	ldr	r2, [sp, #84]	@ 0x54
      rev[ri++] = (char)('0' + (hz % 10));
 800df9e:	f8df c084 	ldr.w	ip, [pc, #132]	@ 800e024 <draw_all+0x186c>
  int group = 0;
 800dfa2:	4617      	mov	r7, r2
      rev[ri++] = (char)('0' + (hz % 10));
 800dfa4:	fbac 3001 	umull	r3, r0, ip, r1
 800dfa8:	08c0      	lsrs	r0, r0, #3
 800dfaa:	eb00 0480 	add.w	r4, r0, r0, lsl #2
 800dfae:	eba1 0444 	sub.w	r4, r1, r4, lsl #1
      group++;
 800dfb2:	3701      	adds	r7, #1
      rev[ri++] = (char)('0' + (hz % 10));
 800dfb4:	eb0d 0502 	add.w	r5, sp, r2
 800dfb8:	3430      	adds	r4, #48	@ 0x30
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800dfba:	2f03      	cmp	r7, #3
      rev[ri++] = (char)('0' + (hz % 10));
 800dfbc:	f885 4088 	strb.w	r4, [r5, #136]	@ 0x88
 800dfc0:	f102 0301 	add.w	r3, r2, #1
      hz /= 10;
 800dfc4:	460c      	mov	r4, r1
 800dfc6:	4601      	mov	r1, r0
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800dfc8:	d02e      	beq.n	800e028 <draw_all+0x1870>
    while (hz > 0 && ri < (int)sizeof(rev) - 1)
 800dfca:	2c09      	cmp	r4, #9
 800dfcc:	d939      	bls.n	800e042 <draw_all+0x188a>
 800dfce:	461a      	mov	r2, r3
 800dfd0:	2a17      	cmp	r2, #23
 800dfd2:	d1e7      	bne.n	800dfa4 <draw_all+0x17ec>
  rev[ri] = 0;
 800dfd4:	2300      	movs	r3, #0
 800dfd6:	f88d 309f 	strb.w	r3, [sp, #159]	@ 0x9f
 800dfda:	2317      	movs	r3, #23
 800dfdc:	e038      	b.n	800e050 <draw_all+0x1898>
 800dfde:	bf00      	nop
 800dfe0:	0801650c 	.word	0x0801650c
 800dfe4:	00000000 	.word	0x00000000
 800dfe8:	01c70000 	.word	0x01c70000
 800dfec:	08013c90 	.word	0x08013c90
 800dff0:	08013c54 	.word	0x08013c54
 800dff4:	20000aa8 	.word	0x20000aa8
 800dff8:	08013c68 	.word	0x08013c68
 800dffc:	200089f0 	.word	0x200089f0
 800e000:	20000318 	.word	0x20000318
 800e004:	200089d8 	.word	0x200089d8
 800e008:	08013db0 	.word	0x08013db0
 800e00c:	08013dc8 	.word	0x08013dc8
 800e010:	08013da0 	.word	0x08013da0
 800e014:	08013d80 	.word	0x08013d80
 800e018:	08013da8 	.word	0x08013da8
 800e01c:	08013cf0 	.word	0x08013cf0
 800e020:	20006a7c 	.word	0x20006a7c
 800e024:	cccccccd 	.word	0xcccccccd
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800e028:	2c09      	cmp	r4, #9
 800e02a:	d90a      	bls.n	800e042 <draw_all+0x188a>
        rev[ri++] = '.';
 800e02c:	f103 00d8 	add.w	r0, r3, #216	@ 0xd8
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800e030:	2b17      	cmp	r3, #23
        rev[ri++] = '.';
 800e032:	4468      	add	r0, sp
      if (group == 3 && hz > 0 && ri < (int)sizeof(rev) - 1)
 800e034:	d0ce      	beq.n	800dfd4 <draw_all+0x181c>
        rev[ri++] = '.';
 800e036:	232e      	movs	r3, #46	@ 0x2e
 800e038:	3202      	adds	r2, #2
 800e03a:	f800 3c50 	strb.w	r3, [r0, #-80]
        group = 0;
 800e03e:	2700      	movs	r7, #0
 800e040:	e7c6      	b.n	800dfd0 <draw_all+0x1818>
  rev[ri] = 0;
 800e042:	2100      	movs	r1, #0
 800e044:	eb0d 0203 	add.w	r2, sp, r3
  while (ri > 0 && oi < out_len - 1)
 800e048:	428b      	cmp	r3, r1
  rev[ri] = 0;
 800e04a:	f882 1088 	strb.w	r1, [r2, #136]	@ 0x88
  while (ri > 0 && oi < out_len - 1)
 800e04e:	dd31      	ble.n	800e0b4 <draw_all+0x18fc>
 800e050:	ac22      	add	r4, sp, #136	@ 0x88
 800e052:	18e2      	adds	r2, r4, r3
 800e054:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 800e056:	ab1c      	add	r3, sp, #112	@ 0x70
 800e058:	4619      	mov	r1, r3
    out[oi++] = rev[--ri];
 800e05a:	f812 5d01 	ldrb.w	r5, [r2, #-1]!
 800e05e:	f801 5b01 	strb.w	r5, [r1], #1
  while (ri > 0 && oi < out_len - 1)
 800e062:	42a2      	cmp	r2, r4
    out[oi++] = rev[--ri];
 800e064:	f100 0001 	add.w	r0, r0, #1
  while (ri > 0 && oi < out_len - 1)
 800e068:	d00c      	beq.n	800e084 <draw_all+0x18cc>
 800e06a:	2817      	cmp	r0, #23
 800e06c:	d1f5      	bne.n	800e05a <draw_all+0x18a2>
 800e06e:	f10d 0287 	add.w	r2, sp, #135	@ 0x87
  out[oi] = 0;
 800e072:	2100      	movs	r1, #0
 800e074:	7011      	strb	r1, [r2, #0]
    plot_printf(msg, (int)sizeof(msg), "F Res %s Hz", fbuf);
 800e076:	4620      	mov	r0, r4
 800e078:	4a14      	ldr	r2, [pc, #80]	@ (800e0cc <draw_all+0x1914>)
 800e07a:	2128      	movs	r1, #40	@ 0x28
 800e07c:	f7f4 fe78 	bl	8002d70 <plot_printf>
  {
 800e080:	f7ff bbe1 	b.w	800d846 <draw_all+0x108e>
  out[oi] = 0;
 800e084:	4602      	mov	r2, r0
 800e086:	441a      	add	r2, r3
 800e088:	e7f3      	b.n	800e072 <draw_all+0x18ba>
      lcd_printf(FREQUENCIES_XPOS1, FREQUENCIES_YPOS, "%c%s %15q" S_Hz, lm0, "CW", get_sweep_frequency(ST_CW));
 800e08a:	4b11      	ldr	r3, [pc, #68]	@ (800e0d0 <draw_all+0x1918>)
 800e08c:	9201      	str	r2, [sp, #4]
 800e08e:	9300      	str	r3, [sp, #0]
 800e090:	4a10      	ldr	r2, [pc, #64]	@ (800e0d4 <draw_all+0x191c>)
 800e092:	462b      	mov	r3, r5
 800e094:	f240 1133 	movw	r1, #307	@ 0x133
 800e098:	200f      	movs	r0, #15
 800e09a:	f003 f89d 	bl	80111d8 <lcd_printf>
 800e09e:	f7fe bc71 	b.w	800c984 <draw_all+0x1cc>
    invalidate_rect(GRID_X_TEXT, 0, LCD_WIDTH - OFFSETX, LCD_HEIGHT - 1);
 800e0a2:	2309      	movs	r3, #9
 800e0a4:	220e      	movs	r2, #14
 800e0a6:	2100      	movs	r1, #0
 800e0a8:	200d      	movs	r0, #13
 800e0aa:	f7fc faf9 	bl	800a6a0 <invalidate_rect_func>
 800e0ae:	e6a9      	b.n	800de04 <draw_all+0x164c>
    else if (swr <= 2.00f) color_idx = LCD_TRACE_1_COLOR;    // yellow
 800e0b0:	2506      	movs	r5, #6
 800e0b2:	e532      	b.n	800db1a <draw_all+0x1362>
  while (ri > 0 && oi < out_len - 1)
 800e0b4:	ab1c      	add	r3, sp, #112	@ 0x70
 800e0b6:	461a      	mov	r2, r3
 800e0b8:	ac22      	add	r4, sp, #136	@ 0x88
 800e0ba:	e7da      	b.n	800e072 <draw_all+0x18ba>
  const int x = CELLOFFSETX + (WIDTH - text_w) / 2;
 800e0bc:	f5c0 72e3 	rsb	r2, r0, #454	@ 0x1c6
 800e0c0:	3201      	adds	r2, #1
 800e0c2:	1052      	asrs	r2, r2, #1
 800e0c4:	1d57      	adds	r7, r2, #5
    if      (swr <= 1.10f) color_idx = LCD_INTERP_CAL_COLOR; // bright green
 800e0c6:	2517      	movs	r5, #23
 800e0c8:	e527      	b.n	800db1a <draw_all+0x1362>
 800e0ca:	bf00      	nop
 800e0cc:	08013ccc 	.word	0x08013ccc
 800e0d0:	08013d8c 	.word	0x08013d8c
 800e0d4:	08013d80 	.word	0x08013d80

0800e0d8 <redraw_marker>:
  if (marker == MARKER_INVALID || !markers[marker].enabled)
 800e0d8:	1c42      	adds	r2, r0, #1
 800e0da:	d029      	beq.n	800e130 <redraw_marker+0x58>
{
 800e0dc:	b508      	push	{r3, lr}
  if (marker == MARKER_INVALID || !markers[marker].enabled)
 800e0de:	f100 020b 	add.w	r2, r0, #11
 800e0e2:	4b14      	ldr	r3, [pc, #80]	@ (800e134 <redraw_marker+0x5c>)
 800e0e4:	f813 1032 	ldrb.w	r1, [r3, r2, lsl #3]
 800e0e8:	b1d9      	cbz	r1, 800e122 <redraw_marker+0x4a>
  if (marker == active_marker)
 800e0ea:	f993 101d 	ldrsb.w	r1, [r3, #29]
 800e0ee:	4281      	cmp	r1, r0
 800e0f0:	d018      	beq.n	800e124 <redraw_marker+0x4c>
  request_to_draw_marker(markers[marker].index);
 800e0f2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e0f6:	8858      	ldrh	r0, [r3, #2]
 800e0f8:	f7fe f86e 	bl	800c1d8 <request_to_draw_marker>
  invalidate_rect(0, 0, AREA_WIDTH_NORMAL, marker_area_max());
 800e0fc:	f7fd f9f8 	bl	800b4f0 <marker_area_max>
 800e100:	2100      	movs	r1, #0
 800e102:	1143      	asrs	r3, r0, #5
 800e104:	220e      	movs	r2, #14
 800e106:	4608      	mov	r0, r1
 800e108:	f7fc faca 	bl	800a6a0 <invalidate_rect_func>
  redraw_request |= REDRAW_CELLS;     // Update cells
 800e10c:	4a0a      	ldr	r2, [pc, #40]	@ (800e138 <redraw_marker+0x60>)
  redraw_request &= ~(REDRAW_MARKER); // reset all marker update
 800e10e:	8813      	ldrh	r3, [r2, #0]
 800e110:	f023 0320 	bic.w	r3, r3, #32
  redraw_request |= REDRAW_CELLS;     // Update cells
 800e114:	f043 0304 	orr.w	r3, r3, #4
 800e118:	8013      	strh	r3, [r2, #0]
}
 800e11a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  draw_all();
 800e11e:	f7fe bb4b 	b.w	800c7b8 <draw_all>
}
 800e122:	bd08      	pop	{r3, pc}
  data_update |= flag;
 800e124:	4805      	ldr	r0, [pc, #20]	@ (800e13c <redraw_marker+0x64>)
 800e126:	7801      	ldrb	r1, [r0, #0]
 800e128:	f041 0102 	orr.w	r1, r1, #2
 800e12c:	7001      	strb	r1, [r0, #0]
}
 800e12e:	e7e0      	b.n	800e0f2 <redraw_marker+0x1a>
 800e130:	4770      	bx	lr
 800e132:	bf00      	nop
 800e134:	20000aa8 	.word	0x20000aa8
 800e138:	200089f0 	.word	0x200089f0
 800e13c:	20006a7c 	.word	0x20006a7c

0800e140 <plot_init>:
{
 800e140:	b508      	push	{r3, lr}
  request_to_redraw(REDRAW_PLOT | REDRAW_ALL);
 800e142:	f240 301b 	movw	r0, #795	@ 0x31b
 800e146:	f7fe fb0f 	bl	800c768 <request_to_redraw>
}
 800e14a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  draw_all();
 800e14e:	f7fe bb33 	b.w	800c7b8 <draw_all>
 800e152:	bf00      	nop

0800e154 <NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 800e154:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800e158:	4905      	ldr	r1, [pc, #20]	@ (800e170 <NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800e15a:	4b06      	ldr	r3, [pc, #24]	@ (800e174 <NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 800e15c:	68ca      	ldr	r2, [r1, #12]
 800e15e:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 800e162:	4313      	orrs	r3, r2
 800e164:	60cb      	str	r3, [r1, #12]
 800e166:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 800e16a:	bf00      	nop
  while(1) { __NOP(); }                                             /* wait until reset */
 800e16c:	e7fd      	b.n	800e16a <NVIC_SystemReset+0x16>
 800e16e:	bf00      	nop
 800e170:	e000ed00 	.word	0xe000ed00
 800e174:	05fa0004 	.word	0x05fa0004

0800e178 <get_buttons>:
// Icons for UI
#include "icons_menu.c"

static uint16_t get_buttons(void)
{
  uint16_t cur_button = READ_BUTTONS();
 800e178:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 800e17c:	6918      	ldr	r0, [r3, #16]
#ifdef __FLIP_DISPLAY__
  // swap bits in byte (swap leveler left and right bits for rotated display)
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY) && (((cur_button >> GPIOA_LEVER1) ^ (cur_button >> GPIOA_LEVER2)) & 1))
 800e17e:	4b07      	ldr	r3, [pc, #28]	@ (800e19c <get_buttons+0x24>)
 800e180:	8a9b      	ldrh	r3, [r3, #20]
 800e182:	065b      	lsls	r3, r3, #25
  uint16_t cur_button = READ_BUTTONS();
 800e184:	f000 000e 	and.w	r0, r0, #14
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY) && (((cur_button >> GPIOA_LEVER1) ^ (cur_button >> GPIOA_LEVER2)) & 1))
 800e188:	d507      	bpl.n	800e19a <get_buttons+0x22>
 800e18a:	f3c0 0340 	ubfx	r3, r0, #1, #1
 800e18e:	ea83 03d0 	eor.w	r3, r3, r0, lsr #3
 800e192:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800e196:	ea80 0043 	eor.w	r0, r0, r3, lsl #1
    cur_button ^= (1 << GPIOA_LEVER1) | (1 << GPIOA_LEVER2);
#endif
  return cur_button;
}
 800e19a:	4770      	bx	lr
 800e19c:	20000318 	.word	0x20000318

0800e1a0 <touch_position>:
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
  getTouchPoint(x2, y2, "LOWER RIGHT", &config._touch_cal[p2]);
}

static void touch_position(int *x, int *y)
{
 800e1a0:	b5f0      	push	{r4, r5, r6, r7, lr}
#ifdef __REMOTE_DESKTOP__
  if (touch_remote != REMOTE_NONE)
  {
    *x = last_touch_x;
 800e1a2:	4b1d      	ldr	r3, [pc, #116]	@ (800e218 <touch_position+0x78>)
  if (touch_remote != REMOTE_NONE)
 800e1a4:	4c1d      	ldr	r4, [pc, #116]	@ (800e21c <touch_position+0x7c>)
    *x = last_touch_x;
 800e1a6:	f9b3 2000 	ldrsh.w	r2, [r3]
  if (touch_remote != REMOTE_NONE)
 800e1aa:	7824      	ldrb	r4, [r4, #0]
    *y = last_touch_y;
 800e1ac:	4b1c      	ldr	r3, [pc, #112]	@ (800e220 <touch_position+0x80>)
 800e1ae:	f9b3 3000 	ldrsh.w	r3, [r3]
  if (touch_remote != REMOTE_NONE)
 800e1b2:	bb6c      	cbnz	r4, 800e210 <touch_position+0x70>
    return;
  }
#endif
  int tx, ty;
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800e1b4:	4c1b      	ldr	r4, [pc, #108]	@ (800e224 <touch_position+0x84>)
 800e1b6:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
  if (tx < 0)
    tx = 0;
  else if (tx >= LCD_WIDTH)
    tx = LCD_WIDTH - 1;
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800e1ba:	f9b4 700e 	ldrsh.w	r7, [r4, #14]
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800e1be:	1b92      	subs	r2, r2, r6
 800e1c0:	f240 15bf 	movw	r5, #447	@ 0x1bf
 800e1c4:	436a      	muls	r2, r5
 800e1c6:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800e1ca:	1bdb      	subs	r3, r3, r7
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800e1cc:	1bad      	subs	r5, r5, r6
 800e1ce:	fb92 f2f5 	sdiv	r2, r2, r5
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800e1d2:	f240 151f 	movw	r5, #287	@ 0x11f
 800e1d6:	436b      	muls	r3, r5
 800e1d8:	f9b4 5012 	ldrsh.w	r5, [r4, #18]
  if (ty < 0)
    ty = 0;
  else if (ty >= LCD_HEIGHT)
    ty = LCD_HEIGHT - 1;
#ifdef __FLIP_DISPLAY__
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 800e1dc:	8aa4      	ldrh	r4, [r4, #20]
  tx = (LCD_WIDTH - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_x - config._touch_cal[0]) / (config._touch_cal[2] - config._touch_cal[0]) + CALIBRATION_OFFSET;
 800e1de:	3210      	adds	r2, #16
  else if (tx >= LCD_WIDTH)
 800e1e0:	f240 16df 	movw	r6, #479	@ 0x1df
 800e1e4:	42b2      	cmp	r2, r6
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800e1e6:	eba5 0507 	sub.w	r5, r5, r7
 800e1ea:	fb93 f3f5 	sdiv	r3, r3, r5
  else if (ty >= LCD_HEIGHT)
 800e1ee:	f240 153f 	movw	r5, #319	@ 0x13f
  ty = (LCD_HEIGHT - 1 - 2 * CALIBRATION_OFFSET) * (last_touch_y - config._touch_cal[1]) / (config._touch_cal[3] - config._touch_cal[1]) + CALIBRATION_OFFSET;
 800e1f2:	f103 0310 	add.w	r3, r3, #16
  else if (tx >= LCD_WIDTH)
 800e1f6:	bfa8      	it	ge
 800e1f8:	4632      	movge	r2, r6
  else if (ty >= LCD_HEIGHT)
 800e1fa:	42ab      	cmp	r3, r5
 800e1fc:	bfa8      	it	ge
 800e1fe:	462b      	movge	r3, r5
  if (tx < 0)
 800e200:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 800e204:	0664      	lsls	r4, r4, #25
  if (ty < 0)
 800e206:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  {
    tx = LCD_WIDTH - 1 - tx;
 800e20a:	bf44      	itt	mi
 800e20c:	1ab2      	submi	r2, r6, r2
    ty = LCD_HEIGHT - 1 - ty;
 800e20e:	1aeb      	submi	r3, r5, r3
    *x = last_touch_x;
 800e210:	6002      	str	r2, [r0, #0]
    *y = last_touch_y;
 800e212:	600b      	str	r3, [r1, #0]
  }
#endif
  *x = tx;
  *y = ty;
}
 800e214:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e216:	bf00      	nop
 800e218:	20008a26 	.word	0x20008a26
 800e21c:	20008a04 	.word	0x20008a04
 800e220:	20008a24 	.word	0x20008a24
 800e224:	20000318 	.word	0x20000318

0800e228 <menu_reboot_cb>:
  (void)data;
  ui_enter_dfu();
}

static UI_FUNCTION_CALLBACK(menu_reboot_cb)
{
 800e228:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 800e22a:	b672      	cpsid	i
  chSysDisable();          // optional
  NVIC_SystemReset();
 800e22c:	f7ff ff92 	bl	800e154 <NVIC_SystemReset>

0800e230 <menu_measure_cb>:
}

static UI_FUNCTION_CALLBACK(menu_measure_cb)
{

HB9II_mode=2;
 800e230:	4b01      	ldr	r3, [pc, #4]	@ (800e238 <menu_measure_cb+0x8>)
 800e232:	2202      	movs	r2, #2
 800e234:	601a      	str	r2, [r3, #0]
 // menu_push_submenu(menu_measure_list[current_props._measure]);




}
 800e236:	4770      	bx	lr
 800e238:	200068f4 	.word	0x200068f4

0800e23c <browser_get_button_pos>:
  // File button, only size and start position, must be idx = FILE_BUTTON_FILE
  [FILE_BUTTON_FILE] = {                              0,                               0,           LCD_WIDTH/FILES_COLUMNS, FILE_BUTTON_HEIGHT,                                   FONT_WIDTH/2 + 3},
};

static void browser_get_button_pos(int idx, browser_btn_t *b) {
  int n = idx >= FILE_BUTTON_FILE ? FILE_BUTTON_FILE : idx;
 800e23c:	2804      	cmp	r0, #4
 800e23e:	4602      	mov	r2, r0
#if 0
  memcpy(b, &browser_btn[n], sizeof(browser_btn_t));
#else
  b->x = browser_btn[n].x;
 800e240:	4b0f      	ldr	r3, [pc, #60]	@ (800e280 <browser_get_button_pos+0x44>)
  int n = idx >= FILE_BUTTON_FILE ? FILE_BUTTON_FILE : idx;
 800e242:	bfa8      	it	ge
 800e244:	2204      	movge	r2, #4
static void browser_get_button_pos(int idx, browser_btn_t *b) {
 800e246:	b5f0      	push	{r4, r5, r6, r7, lr}
  b->x = browser_btn[n].x;
 800e248:	f833 6032 	ldrh.w	r6, [r3, r2, lsl #3]
 800e24c:	800e      	strh	r6, [r1, #0]
  b->y = browser_btn[n].y;
 800e24e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
  b->w = browser_btn[n].w;
  b->h = browser_btn[n].h;
  b->ofs = browser_btn[n].ofs;
#endif
  if (idx > FILE_BUTTON_FILE) { // for file buttons use multiplier from start offset
 800e252:	2804      	cmp	r0, #4
  b->y = browser_btn[n].y;
 800e254:	885a      	ldrh	r2, [r3, #2]
  b->w = browser_btn[n].w;
 800e256:	889c      	ldrh	r4, [r3, #4]
  b->y = browser_btn[n].y;
 800e258:	804a      	strh	r2, [r1, #2]
  b->w = browser_btn[n].w;
 800e25a:	808c      	strh	r4, [r1, #4]
  b->h = browser_btn[n].h;
 800e25c:	799f      	ldrb	r7, [r3, #6]
 800e25e:	88db      	ldrh	r3, [r3, #6]
 800e260:	80cb      	strh	r3, [r1, #6]
  if (idx > FILE_BUTTON_FILE) { // for file buttons use multiplier from start offset
 800e262:	dd0c      	ble.n	800e27e <browser_get_button_pos+0x42>
    idx-= FILE_BUTTON_FILE;
 800e264:	3804      	subs	r0, #4
    b->x+= b->w * (idx / FILES_ROWS);
 800e266:	250a      	movs	r5, #10
 800e268:	fbb0 f3f5 	udiv	r3, r0, r5
    b->y+= b->h * (idx % FILES_ROWS);
 800e26c:	fb05 0013 	mls	r0, r5, r3, r0
 800e270:	fb10 f007 	smulbb	r0, r0, r7
    b->x+= b->w * (idx / FILES_ROWS);
 800e274:	fb13 6404 	smlabb	r4, r3, r4, r6
    b->y+= b->h * (idx % FILES_ROWS);
 800e278:	4402      	add	r2, r0
    b->x+= b->w * (idx / FILES_ROWS);
 800e27a:	800c      	strh	r4, [r1, #0]
    b->y+= b->h * (idx % FILES_ROWS);
 800e27c:	804a      	strh	r2, [r1, #2]
  }
}
 800e27e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e280:	08016b74 	.word	0x08016b74

0800e284 <browser_get_max>:
  }
}

static int browser_get_max(void) {
  // get max buttons depend from page and file count
  int max = current_page == page_count ? (file_count % FILES_PER_PAGE) : FILES_PER_PAGE;
 800e284:	4b0a      	ldr	r3, [pc, #40]	@ (800e2b0 <browser_get_max+0x2c>)
 800e286:	881a      	ldrh	r2, [r3, #0]
 800e288:	4b0a      	ldr	r3, [pc, #40]	@ (800e2b4 <browser_get_max+0x30>)
 800e28a:	881b      	ldrh	r3, [r3, #0]
 800e28c:	429a      	cmp	r2, r3
 800e28e:	d10c      	bne.n	800e2aa <browser_get_max+0x26>
 800e290:	4b09      	ldr	r3, [pc, #36]	@ (800e2b8 <browser_get_max+0x34>)
 800e292:	8818      	ldrh	r0, [r3, #0]
  if (file_count > 0 && max == 0) max = FILES_PER_PAGE;
 800e294:	b150      	cbz	r0, 800e2ac <browser_get_max+0x28>
  int max = current_page == page_count ? (file_count % FILES_PER_PAGE) : FILES_PER_PAGE;
 800e296:	231e      	movs	r3, #30
 800e298:	fbb0 f2f3 	udiv	r2, r0, r3
 800e29c:	fb03 0012 	mls	r0, r3, r2, r0
 800e2a0:	b280      	uxth	r0, r0
 800e2a2:	2800      	cmp	r0, #0
 800e2a4:	bf08      	it	eq
 800e2a6:	4618      	moveq	r0, r3
 800e2a8:	e000      	b.n	800e2ac <browser_get_max+0x28>
  if (file_count > 0 && max == 0) max = FILES_PER_PAGE;
 800e2aa:	201e      	movs	r0, #30
  return max + FILE_BUTTON_FILE - 1;
}
 800e2ac:	3003      	adds	r0, #3
 800e2ae:	4770      	bx	lr
 800e2b0:	200089f4 	.word	0x200089f4
 800e2b4:	200089f6 	.word	0x200089f6
 800e2b8:	200089f8 	.word	0x200089f8

0800e2bc <ui_keyboard_cb>:
};

// Keyboard callback function for UI button
void ui_keyboard_cb(uint16_t data, button_t *b)
{
  const keyboard_cb_t cb = keypads_mode_tbl[data].cb;
 800e2bc:	4b04      	ldr	r3, [pc, #16]	@ (800e2d0 <ui_keyboard_cb+0x14>)
 800e2be:	220a      	movs	r2, #10
 800e2c0:	fb02 3000 	mla	r0, r2, r0, r3
 800e2c4:	f8d0 3006 	ldr.w	r3, [r0, #6]
  if (cb)
 800e2c8:	b10b      	cbz	r3, 800e2ce <ui_keyboard_cb+0x12>
    cb(keypads_mode_tbl[data].data, b);
 800e2ca:	7840      	ldrb	r0, [r0, #1]
 800e2cc:	4718      	bx	r3
}
 800e2ce:	4770      	bx	lr
 800e2d0:	08016874 	.word	0x08016874

0800e2d4 <period_pos>:
}

static int period_pos(void)
{
  int j;
  for (j = 0; kp_buf[j] && kp_buf[j] != '.'; j++)
 800e2d4:	4b04      	ldr	r3, [pc, #16]	@ (800e2e8 <period_pos+0x14>)
 800e2d6:	2000      	movs	r0, #0
 800e2d8:	f813 2b01 	ldrb.w	r2, [r3], #1
 800e2dc:	b11a      	cbz	r2, 800e2e6 <period_pos+0x12>
 800e2de:	2a2e      	cmp	r2, #46	@ 0x2e
 800e2e0:	d001      	beq.n	800e2e6 <period_pos+0x12>
 800e2e2:	3001      	adds	r0, #1
 800e2e4:	e7f8      	b.n	800e2d8 <period_pos+0x4>
    ;
  return j;
}
 800e2e6:	4770      	bx	lr
 800e2e8:	20008a10 	.word	0x20008a10

0800e2ec <step_round>:

// ex. 10942 -> 10000
//      6791 ->  5000
//       341 ->   200
static freq_t step_round(freq_t v)
{
 800e2ec:	4603      	mov	r3, r0
  // decade step
  freq_t nx, x = 1;
 800e2ee:	2201      	movs	r2, #1
  while ((nx = x * 10) < v)
 800e2f0:	210a      	movs	r1, #10
 800e2f2:	4610      	mov	r0, r2
 800e2f4:	434a      	muls	r2, r1
 800e2f6:	429a      	cmp	r2, r3
 800e2f8:	d3fb      	bcc.n	800e2f2 <step_round+0x6>
    x = nx;
  // 1-2-5 step
  if (x * 2 > v)
 800e2fa:	ebb3 0f40 	cmp.w	r3, r0, lsl #1
 800e2fe:	ea4f 0240 	mov.w	r2, r0, lsl #1
 800e302:	d304      	bcc.n	800e30e <step_round+0x22>
    return x;
  if (x * 5 > v)
 800e304:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    return x * 2;
 800e308:	4298      	cmp	r0, r3
 800e30a:	bf88      	it	hi
 800e30c:	4610      	movhi	r0, r2
  return x * 5;
}
 800e30e:	4770      	bx	lr

0800e310 <touch_stop_watchdog>:
  if (!(touch_status_flag & TOUCH_INTERRUPT_ENABLED))
 800e310:	4a04      	ldr	r2, [pc, #16]	@ (800e324 <touch_stop_watchdog+0x14>)
 800e312:	7813      	ldrb	r3, [r2, #0]
 800e314:	07d9      	lsls	r1, r3, #31
 800e316:	d504      	bpl.n	800e322 <touch_stop_watchdog+0x12>
  touch_status_flag ^= TOUCH_INTERRUPT_ENABLED;
 800e318:	f083 0301 	eor.w	r3, r3, #1
 800e31c:	7013      	strb	r3, [r2, #0]
  adc_stop_analog_watchdog();
 800e31e:	f003 bc19 	b.w	8011b54 <adc_stop_analog_watchdog>
}
 800e322:	4770      	bx	lr
 800e324:	20008a29 	.word	0x20008a29

0800e328 <touch_prepare_sense>:
{
 800e328:	b510      	push	{r4, lr}
  palSetPadMode(GPIOB, GPIOB_YN, PAL_MODE_INPUT);          // Hi-z mode
 800e32a:	480f      	ldr	r0, [pc, #60]	@ (800e368 <touch_prepare_sense+0x40>)
 800e32c:	2200      	movs	r2, #0
 800e32e:	2101      	movs	r1, #1
 800e330:	f003 fe4c 	bl	8011fcc <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_YP, PAL_MODE_INPUT_PULLDOWN); // Use pull
 800e334:	2240      	movs	r2, #64	@ 0x40
 800e336:	2107      	movs	r1, #7
 800e338:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800e33c:	f003 fe46 	bl	8011fcc <palSetPadMode>
  palSetPad(GPIOB, GPIOB_XN);
 800e340:	4b09      	ldr	r3, [pc, #36]	@ (800e368 <touch_prepare_sense+0x40>)
  palSetPadMode(GPIOB, GPIOB_XN, PAL_MODE_OUTPUT_PUSHPULL);
 800e342:	4809      	ldr	r0, [pc, #36]	@ (800e368 <touch_prepare_sense+0x40>)
  palSetPad(GPIOB, GPIOB_XN);
 800e344:	2401      	movs	r4, #1
  palSetPad(GPIOA, GPIOA_XP);
 800e346:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
  palSetPad(GPIOB, GPIOB_XN);
 800e34a:	619c      	str	r4, [r3, #24]
  palSetPad(GPIOA, GPIOA_XP);
 800e34c:	2340      	movs	r3, #64	@ 0x40
 800e34e:	6193      	str	r3, [r2, #24]
  palSetPadMode(GPIOB, GPIOB_XN, PAL_MODE_OUTPUT_PUSHPULL);
 800e350:	2100      	movs	r1, #0
 800e352:	4622      	mov	r2, r4
 800e354:	f003 fe3a 	bl	8011fcc <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_XP, PAL_MODE_OUTPUT_PUSHPULL);
 800e358:	4622      	mov	r2, r4
 800e35a:	2106      	movs	r1, #6
}
 800e35c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  palSetPadMode(GPIOA, GPIOA_XP, PAL_MODE_OUTPUT_PUSHPULL);
 800e360:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800e364:	f003 be32 	b.w	8011fcc <palSetPadMode>
 800e368:	48000400 	.word	0x48000400

0800e36c <touch_measure_y>:
{
 800e36c:	b508      	push	{r3, lr}
  palClearPad(GPIOB, GPIOB_XN);
 800e36e:	4b07      	ldr	r3, [pc, #28]	@ (800e38c <touch_measure_y+0x20>)
 800e370:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800e374:	619a      	str	r2, [r3, #24]
  palSetPadMode(GPIOA, GPIOA_YP, PAL_MODE_INPUT_ANALOG); // <- ADC_TOUCH_Y channel
 800e376:	2107      	movs	r1, #7
 800e378:	f640 0203 	movw	r2, #2051	@ 0x803
 800e37c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800e380:	f003 fe24 	bl	8011fcc <palSetPadMode>
  return adc_single_read(ADC_TOUCH_Y);
 800e384:	2004      	movs	r0, #4
 800e386:	f003 fb6d 	bl	8011a64 <adc_single_read>
}
 800e38a:	bd08      	pop	{r3, pc}
 800e38c:	48000400 	.word	0x48000400

0800e390 <touch_measure_x>:
  palSetPad(GPIOB, GPIOB_YN);
 800e390:	4a11      	ldr	r2, [pc, #68]	@ (800e3d8 <touch_measure_x+0x48>)
  palSetPadMode(GPIOB, GPIOB_YN, PAL_MODE_OUTPUT_PUSHPULL);
 800e392:	4811      	ldr	r0, [pc, #68]	@ (800e3d8 <touch_measure_x+0x48>)
{
 800e394:	b508      	push	{r3, lr}
  palSetPad(GPIOB, GPIOB_YN);
 800e396:	2302      	movs	r3, #2
 800e398:	6193      	str	r3, [r2, #24]
  palClearPad(GPIOA, GPIOA_YP);
 800e39a:	f04f 4290 	mov.w	r2, #1207959552	@ 0x48000000
 800e39e:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
 800e3a2:	6193      	str	r3, [r2, #24]
  palSetPadMode(GPIOB, GPIOB_YN, PAL_MODE_OUTPUT_PUSHPULL);
 800e3a4:	2201      	movs	r2, #1
 800e3a6:	4611      	mov	r1, r2
 800e3a8:	f003 fe10 	bl	8011fcc <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_YP, PAL_MODE_OUTPUT_PUSHPULL);
 800e3ac:	2201      	movs	r2, #1
 800e3ae:	2107      	movs	r1, #7
 800e3b0:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800e3b4:	f003 fe0a 	bl	8011fcc <palSetPadMode>
  palSetPadMode(GPIOB, GPIOB_XN, PAL_MODE_INPUT);        // Hi-z mode
 800e3b8:	2200      	movs	r2, #0
 800e3ba:	4611      	mov	r1, r2
 800e3bc:	4806      	ldr	r0, [pc, #24]	@ (800e3d8 <touch_measure_x+0x48>)
 800e3be:	f003 fe05 	bl	8011fcc <palSetPadMode>
  palSetPadMode(GPIOA, GPIOA_XP, PAL_MODE_INPUT_ANALOG); // <- ADC_TOUCH_X channel
 800e3c2:	f640 0203 	movw	r2, #2051	@ 0x803
 800e3c6:	2106      	movs	r1, #6
 800e3c8:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800e3cc:	f003 fdfe 	bl	8011fcc <palSetPadMode>
  return adc_single_read(ADC_TOUCH_X);
 800e3d0:	2003      	movs	r0, #3
 800e3d2:	f003 fb47 	bl	8011a64 <adc_single_read>
}
 800e3d6:	bd08      	pop	{r3, pc}
 800e3d8:	48000400 	.word	0x48000400

0800e3dc <touch_status>:
{
 800e3dc:	b508      	push	{r3, lr}
  return adc_single_read(ADC_TOUCH_Y) > TOUCH_THRESHOLD;
 800e3de:	2004      	movs	r0, #4
 800e3e0:	f003 fb40 	bl	8011a64 <adc_single_read>
}
 800e3e4:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
 800e3e8:	bf94      	ite	ls
 800e3ea:	2000      	movls	r0, #0
 800e3ec:	2001      	movhi	r0, #1
 800e3ee:	bd08      	pop	{r3, pc}

0800e3f0 <touch_check>:
{
 800e3f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  touch_stop_watchdog();
 800e3f2:	f7ff ff8d 	bl	800e310 <touch_stop_watchdog>
  int stat = touch_status();
 800e3f6:	f7ff fff1 	bl	800e3dc <touch_status>
  if (stat)
 800e3fa:	4f11      	ldr	r7, [pc, #68]	@ (800e440 <touch_check+0x50>)
 800e3fc:	b190      	cbz	r0, 800e424 <touch_check+0x34>
 800e3fe:	4604      	mov	r4, r0
    int y = touch_measure_y();
 800e400:	f7ff ffb4 	bl	800e36c <touch_measure_y>
 800e404:	4605      	mov	r5, r0
    int x = touch_measure_x();
 800e406:	f7ff ffc3 	bl	800e390 <touch_measure_x>
 800e40a:	4606      	mov	r6, r0
    touch_prepare_sense();
 800e40c:	f7ff ff8c 	bl	800e328 <touch_prepare_sense>
    if (touch_status())
 800e410:	f7ff ffe4 	bl	800e3dc <touch_status>
 800e414:	b118      	cbz	r0, 800e41e <touch_check+0x2e>
      last_touch_x = x;
 800e416:	4b0b      	ldr	r3, [pc, #44]	@ (800e444 <touch_check+0x54>)
 800e418:	801e      	strh	r6, [r3, #0]
      last_touch_y = y;
 800e41a:	4b0b      	ldr	r3, [pc, #44]	@ (800e448 <touch_check+0x58>)
 800e41c:	801d      	strh	r5, [r3, #0]
    touch_remote = REMOTE_NONE;
 800e41e:	2300      	movs	r3, #0
 800e420:	703b      	strb	r3, [r7, #0]
 800e422:	e003      	b.n	800e42c <touch_check+0x3c>
    stat = touch_remote == REMOTE_PRESS;
 800e424:	783c      	ldrb	r4, [r7, #0]
 800e426:	1e63      	subs	r3, r4, #1
 800e428:	425c      	negs	r4, r3
 800e42a:	415c      	adcs	r4, r3
  if (stat != last_touch_status)
 800e42c:	4b07      	ldr	r3, [pc, #28]	@ (800e44c <touch_check+0x5c>)
 800e42e:	781a      	ldrb	r2, [r3, #0]
 800e430:	42a2      	cmp	r2, r4
    last_touch_status = stat;
 800e432:	bf1c      	itt	ne
 800e434:	701c      	strbne	r4, [r3, #0]
    return stat ? EVT_TOUCH_PRESSED : EVT_TOUCH_RELEASED;
 800e436:	f1c4 0403 	rsbne	r4, r4, #3
}
 800e43a:	4620      	mov	r0, r4
 800e43c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e43e:	bf00      	nop
 800e440:	20008a04 	.word	0x20008a04
 800e444:	20008a26 	.word	0x20008a26
 800e448:	20008a24 	.word	0x20008a24
 800e44c:	20008a28 	.word	0x20008a28

0800e450 <touch_wait_release>:
{
 800e450:	b508      	push	{r3, lr}
  while (touch_check() != EVT_TOUCH_RELEASED)
 800e452:	f7ff ffcd 	bl	800e3f0 <touch_check>
 800e456:	2803      	cmp	r0, #3
 800e458:	d1fb      	bne.n	800e452 <touch_wait_release+0x2>
}
 800e45a:	bd08      	pop	{r3, pc}

0800e45c <select_lever_mode>:
{
 800e45c:	b508      	push	{r3, lr}
  if (lever_mode == mode)
 800e45e:	4b06      	ldr	r3, [pc, #24]	@ (800e478 <select_lever_mode+0x1c>)
 800e460:	7f1a      	ldrb	r2, [r3, #28]
 800e462:	4282      	cmp	r2, r0
 800e464:	d006      	beq.n	800e474 <select_lever_mode+0x18>
  lever_mode = mode;
 800e466:	7718      	strb	r0, [r3, #28]
  request_to_redraw(REDRAW_BACKUP | REDRAW_FREQUENCY | REDRAW_MARKER);
 800e468:	f44f 6085 	mov.w	r0, #1064	@ 0x428
 800e46c:	f7fe f97c 	bl	800c768 <request_to_redraw>
  return true;
 800e470:	2001      	movs	r0, #1
 800e472:	e000      	b.n	800e476 <select_lever_mode+0x1a>
    return false;
 800e474:	2000      	movs	r0, #0
}
 800e476:	bd08      	pop	{r3, pc}
 800e478:	20000318 	.word	0x20000318

0800e47c <btn_check>:
{
 800e47c:	b538      	push	{r3, r4, r5, lr}
    if (ticks - last_button_down_ticks > BUTTON_DEBOUNCE_TICKS)
 800e47e:	4c10      	ldr	r4, [pc, #64]	@ (800e4c0 <btn_check+0x44>)
 800e480:	f04f 4580 	mov.w	r5, #1073741824	@ 0x40000000
 800e484:	6a69      	ldr	r1, [r5, #36]	@ 0x24
 800e486:	6823      	ldr	r3, [r4, #0]
 800e488:	1acb      	subs	r3, r1, r3
 800e48a:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 800e48e:	d803      	bhi.n	800e498 <btn_check+0x1c>
    chThdSleepMilliseconds(2);
 800e490:	20c8      	movs	r0, #200	@ 0xc8
 800e492:	f7f2 fcfd 	bl	8000e90 <chThdSleep>
    ticks = chVTGetSystemTimeX();
 800e496:	e7f5      	b.n	800e484 <btn_check+0x8>
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800e498:	4a0a      	ldr	r2, [pc, #40]	@ (800e4c4 <btn_check+0x48>)
  uint16_t cur_button = get_buttons();
 800e49a:	f7ff fe6d 	bl	800e178 <get_buttons>
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800e49e:	8813      	ldrh	r3, [r2, #0]
  last_button = cur_button;
 800e4a0:	8010      	strh	r0, [r2, #0]
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800e4a2:	ea20 0303 	bic.w	r3, r0, r3
  if (button_set & BUTTON_PUSH)
 800e4a6:	f3c3 0080 	ubfx	r0, r3, #2, #1
  if (button_set & BUTTON_UP)
 800e4aa:	071a      	lsls	r2, r3, #28
  uint16_t button_set = (last_button ^ cur_button) & cur_button;
 800e4ac:	b29d      	uxth	r5, r3
    status |= EVT_UP;
 800e4ae:	bf48      	it	mi
 800e4b0:	f040 0010 	orrmi.w	r0, r0, #16
  if (button_set & BUTTON_DOWN)
 800e4b4:	07ab      	lsls	r3, r5, #30
  last_button_down_ticks = ticks;
 800e4b6:	6021      	str	r1, [r4, #0]
    status |= EVT_DOWN;
 800e4b8:	bf48      	it	mi
 800e4ba:	f040 0020 	orrmi.w	r0, r0, #32
}
 800e4be:	bd38      	pop	{r3, r4, r5, pc}
 800e4c0:	20008a30 	.word	0x20008a30
 800e4c4:	20008a34 	.word	0x20008a34

0800e4c8 <btn_wait_release>:
{
 800e4c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    systime_t dt = ticks - last_button_down_ticks;
 800e4cc:	4f1e      	ldr	r7, [pc, #120]	@ (800e548 <btn_wait_release+0x80>)
    uint16_t changed = last_button ^ cur_button;
 800e4ce:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 800e550 <btn_wait_release+0x88>
        ticks > last_button_repeat_ticks)
 800e4d2:	4e1e      	ldr	r6, [pc, #120]	@ (800e54c <btn_wait_release+0x84>)
 800e4d4:	f04f 4980 	mov.w	r9, #1073741824	@ 0x40000000
    chThdSleepMilliseconds(10);
 800e4d8:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 800e4dc:	f8d9 4024 	ldr.w	r4, [r9, #36]	@ 0x24
    systime_t dt = ticks - last_button_down_ticks;
 800e4e0:	683d      	ldr	r5, [r7, #0]
    chThdSleepMilliseconds(10);
 800e4e2:	f7f2 fcd5 	bl	8000e90 <chThdSleep>
    uint16_t cur_button = get_buttons();
 800e4e6:	f7ff fe47 	bl	800e178 <get_buttons>
    uint16_t changed = last_button ^ cur_button;
 800e4ea:	f8b8 1000 	ldrh.w	r1, [r8]
    systime_t dt = ticks - last_button_down_ticks;
 800e4ee:	1b65      	subs	r5, r4, r5
    uint16_t changed = last_button ^ cur_button;
 800e4f0:	ea81 0300 	eor.w	r3, r1, r0
    uint16_t cur_button = get_buttons();
 800e4f4:	4602      	mov	r2, r0
    if (dt >= BUTTON_DOWN_LONG_TICKS && (cur_button & BUTTON_PUSH))
 800e4f6:	f24c 304f 	movw	r0, #49999	@ 0xc34f
 800e4fa:	4285      	cmp	r5, r0
    uint16_t changed = last_button ^ cur_button;
 800e4fc:	b29b      	uxth	r3, r3
    if (dt >= BUTTON_DOWN_LONG_TICKS && (cur_button & BUTTON_PUSH))
 800e4fe:	d901      	bls.n	800e504 <btn_wait_release+0x3c>
 800e500:	0750      	lsls	r0, r2, #29
 800e502:	d41b      	bmi.n	800e53c <btn_wait_release+0x74>
    if (changed & BUTTON_PUSH) // release
 800e504:	f013 0004 	ands.w	r0, r3, #4
 800e508:	d11a      	bne.n	800e540 <btn_wait_release+0x78>
    if (changed)
 800e50a:	4291      	cmp	r1, r2
 800e50c:	d003      	beq.n	800e516 <btn_wait_release+0x4e>
      last_button = cur_button;
 800e50e:	f8a8 2000 	strh.w	r2, [r8]
      last_button_down_ticks = ticks;
 800e512:	603c      	str	r4, [r7, #0]
      return 0;
 800e514:	e015      	b.n	800e542 <btn_wait_release+0x7a>
    if (dt > BUTTON_DOWN_LONG_TICKS &&
 800e516:	f24c 3350 	movw	r3, #50000	@ 0xc350
 800e51a:	429d      	cmp	r5, r3
 800e51c:	d9dc      	bls.n	800e4d8 <btn_wait_release+0x10>
 800e51e:	6833      	ldr	r3, [r6, #0]
 800e520:	42a3      	cmp	r3, r4
 800e522:	d2d9      	bcs.n	800e4d8 <btn_wait_release+0x10>
        status |= EVT_DOWN | EVT_REPEAT;
 800e524:	f011 0002 	ands.w	r0, r1, #2
 800e528:	bf18      	it	ne
 800e52a:	2060      	movne	r0, #96	@ 0x60
      last_button_repeat_ticks = ticks + BUTTON_REPEAT_TICKS;
 800e52c:	f604 34b8 	addw	r4, r4, #3000	@ 0xbb8
      if (cur_button & BUTTON_UP)
 800e530:	070b      	lsls	r3, r1, #28
        status |= EVT_UP | EVT_REPEAT;
 800e532:	bf48      	it	mi
 800e534:	f040 0050 	orrmi.w	r0, r0, #80	@ 0x50
      last_button_repeat_ticks = ticks + BUTTON_REPEAT_TICKS;
 800e538:	6034      	str	r4, [r6, #0]
      return status;
 800e53a:	e002      	b.n	800e542 <btn_wait_release+0x7a>
      return EVT_BUTTON_DOWN_LONG;
 800e53c:	2004      	movs	r0, #4
 800e53e:	e000      	b.n	800e542 <btn_wait_release+0x7a>
      return EVT_BUTTON_SINGLE_CLICK;
 800e540:	2001      	movs	r0, #1
}
 800e542:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800e546:	bf00      	nop
 800e548:	20008a30 	.word	0x20008a30
 800e54c:	20008a2c 	.word	0x20008a2c
 800e550:	20008a34 	.word	0x20008a34

0800e554 <ui_draw_button>:
{
 800e554:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e558:	f8dd a020 	ldr.w	sl, [sp, #32]
  uint16_t type = b->border;
 800e55c:	f89a 7002 	ldrb.w	r7, [sl, #2]
  if (bw)
 800e560:	f017 0407 	ands.w	r4, r7, #7
{
 800e564:	4605      	mov	r5, r0
 800e566:	460e      	mov	r6, r1
 800e568:	4690      	mov	r8, r2
 800e56a:	4699      	mov	r9, r3
  if (bw)
 800e56c:	d037      	beq.n	800e5de <ui_draw_button+0x8a>
    lcd_set_background(type & BUTTON_BORDER_TOP ? br : bd);
 800e56e:	f017 0f10 	tst.w	r7, #16
 800e572:	bf0c      	ite	eq
 800e574:	2010      	moveq	r0, #16
 800e576:	200f      	movne	r0, #15
 800e578:	f002 fd92 	bl	80110a0 <lcd_set_background>
    lcd_fill(x, y, w, bw); // top
 800e57c:	4628      	mov	r0, r5
 800e57e:	4623      	mov	r3, r4
 800e580:	4642      	mov	r2, r8
 800e582:	4631      	mov	r1, r6
 800e584:	f002 fc92 	bl	8010eac <lcd_fill>
    lcd_set_background(type & BUTTON_BORDER_LEFT ? br : bd);
 800e588:	f017 0f40 	tst.w	r7, #64	@ 0x40
 800e58c:	bf0c      	ite	eq
 800e58e:	2010      	moveq	r0, #16
 800e590:	200f      	movne	r0, #15
 800e592:	f002 fd85 	bl	80110a0 <lcd_set_background>
    lcd_fill(x, y, bw, h); // left
 800e596:	4628      	mov	r0, r5
 800e598:	464b      	mov	r3, r9
 800e59a:	4622      	mov	r2, r4
 800e59c:	4631      	mov	r1, r6
 800e59e:	f002 fc85 	bl	8010eac <lcd_fill>
    lcd_set_background(type & BUTTON_BORDER_RIGHT ? br : bd);
 800e5a2:	f017 0f80 	tst.w	r7, #128	@ 0x80
 800e5a6:	bf0c      	ite	eq
 800e5a8:	2010      	moveq	r0, #16
 800e5aa:	200f      	movne	r0, #15
 800e5ac:	f002 fd78 	bl	80110a0 <lcd_set_background>
    lcd_fill(x + w - bw, y, bw, h); // right
 800e5b0:	eb05 0008 	add.w	r0, r5, r8
 800e5b4:	1b00      	subs	r0, r0, r4
 800e5b6:	464b      	mov	r3, r9
 800e5b8:	4622      	mov	r2, r4
 800e5ba:	4631      	mov	r1, r6
 800e5bc:	f002 fc76 	bl	8010eac <lcd_fill>
    lcd_set_background(type & BUTTON_BORDER_BOTTOM ? br : bd);
 800e5c0:	f017 0f20 	tst.w	r7, #32
 800e5c4:	bf0c      	ite	eq
 800e5c6:	2010      	moveq	r0, #16
 800e5c8:	200f      	movne	r0, #15
 800e5ca:	f002 fd69 	bl	80110a0 <lcd_set_background>
    lcd_fill(x, y + h - bw, w, bw); // bottom
 800e5ce:	eb06 0109 	add.w	r1, r6, r9
 800e5d2:	4623      	mov	r3, r4
 800e5d4:	4642      	mov	r2, r8
 800e5d6:	1b09      	subs	r1, r1, r4
 800e5d8:	4628      	mov	r0, r5
 800e5da:	f002 fc67 	bl	8010eac <lcd_fill>
  lcd_set_colors(b->fg, b->bg);
 800e5de:	f89a 1000 	ldrb.w	r1, [sl]
 800e5e2:	f89a 0001 	ldrb.w	r0, [sl, #1]
 800e5e6:	f002 fd67 	bl	80110b8 <lcd_set_colors>
  if (type & BUTTON_BORDER_NO_FILL)
 800e5ea:	073b      	lsls	r3, r7, #28
 800e5ec:	d409      	bmi.n	800e602 <ui_draw_button+0xae>
  lcd_fill(x + bw, y + bw, w - (bw * 2), h - (bw * 2));
 800e5ee:	eba9 0344 	sub.w	r3, r9, r4, lsl #1
 800e5f2:	eba8 0244 	sub.w	r2, r8, r4, lsl #1
 800e5f6:	1931      	adds	r1, r6, r4
 800e5f8:	1928      	adds	r0, r5, r4
}
 800e5fa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  lcd_fill(x + bw, y + bw, w - (bw * 2), h - (bw * 2));
 800e5fe:	f002 bc55 	b.w	8010eac <lcd_fill>
}
 800e602:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

0800e608 <browser_draw_button>:
static void browser_draw_button(int idx, const char *txt) {
 800e608:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (idx < 0) return;
 800e60a:	1e04      	subs	r4, r0, #0
static void browser_draw_button(int idx, const char *txt) {
 800e60c:	b08f      	sub	sp, #60	@ 0x3c
  if (idx < 0) return;
 800e60e:	db3f      	blt.n	800e690 <browser_draw_button+0x88>
 800e610:	460d      	mov	r5, r1
  browser_get_button_pos(idx, &btn);
 800e612:	a902      	add	r1, sp, #8
 800e614:	f7ff fe12 	bl	800e23c <browser_get_button_pos>
  b.bg = (idx == FILE_BUTTON_DEL && (browser_mode & BROWSER_DELETE)) ? LCD_LOW_BAT_COLOR : LCD_MENU_COLOR;
 800e618:	2c03      	cmp	r4, #3
 800e61a:	d107      	bne.n	800e62c <browser_draw_button+0x24>
 800e61c:	4b1d      	ldr	r3, [pc, #116]	@ (800e694 <browser_draw_button+0x8c>)
 800e61e:	881b      	ldrh	r3, [r3, #0]
 800e620:	f013 0f01 	tst.w	r3, #1
 800e624:	bf14      	ite	ne
 800e626:	230d      	movne	r3, #13
 800e628:	2303      	moveq	r3, #3
 800e62a:	e000      	b.n	800e62e <browser_draw_button+0x26>
 800e62c:	2303      	movs	r3, #3
 800e62e:	f88d 3010 	strb.w	r3, [sp, #16]
  b.fg = LCD_MENU_TEXT_COLOR;
 800e632:	2304      	movs	r3, #4
 800e634:	f88d 3011 	strb.w	r3, [sp, #17]
  b.border = (idx == selection) ? BROWSER_BUTTON_BORDER|BUTTON_BORDER_FALLING : BROWSER_BUTTON_BORDER|BUTTON_BORDER_RISE;
 800e638:	4b17      	ldr	r3, [pc, #92]	@ (800e698 <browser_draw_button+0x90>)
 800e63a:	f993 3000 	ldrsb.w	r3, [r3]
 800e63e:	42a3      	cmp	r3, r4
 800e640:	bf14      	ite	ne
 800e642:	2391      	movne	r3, #145	@ 0x91
 800e644:	2361      	moveq	r3, #97	@ 0x61
  if (txt == NULL) b.border|= BUTTON_BORDER_NO_FILL;
 800e646:	b90d      	cbnz	r5, 800e64c <browser_draw_button+0x44>
 800e648:	f043 0308 	orr.w	r3, r3, #8
  ui_draw_button(btn.x, btn.y, btn.w, btn.h, &b);
 800e64c:	f8bd 6008 	ldrh.w	r6, [sp, #8]
 800e650:	f8bd 700a 	ldrh.w	r7, [sp, #10]
 800e654:	f89d 400e 	ldrb.w	r4, [sp, #14]
  b.border = (idx == selection) ? BROWSER_BUTTON_BORDER|BUTTON_BORDER_FALLING : BROWSER_BUTTON_BORDER|BUTTON_BORDER_RISE;
 800e658:	f88d 3012 	strb.w	r3, [sp, #18]
  ui_draw_button(btn.x, btn.y, btn.w, btn.h, &b);
 800e65c:	ab04      	add	r3, sp, #16
 800e65e:	9300      	str	r3, [sp, #0]
 800e660:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 800e664:	4623      	mov	r3, r4
 800e666:	4639      	mov	r1, r7
 800e668:	4630      	mov	r0, r6
 800e66a:	f7ff ff73 	bl	800e554 <ui_draw_button>
  if (txt) lcd_printf(btn.x + btn.ofs, btn.y + (btn.h - FONT_STR_HEIGHT) / 2, txt);
 800e66e:	b17d      	cbz	r5, 800e690 <browser_draw_button+0x88>
 800e670:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800e674:	3c0b      	subs	r4, #11
 800e676:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 800e67a:	eb07 0164 	add.w	r1, r7, r4, asr #1
 800e67e:	18f0      	adds	r0, r6, r3
 800e680:	462a      	mov	r2, r5
 800e682:	b209      	sxth	r1, r1
 800e684:	b200      	sxth	r0, r0
}
 800e686:	b00f      	add	sp, #60	@ 0x3c
 800e688:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  if (txt) lcd_printf(btn.x + btn.ofs, btn.y + (btn.h - FONT_STR_HEIGHT) / 2, txt);
 800e68c:	f002 bda4 	b.w	80111d8 <lcd_printf>
}
 800e690:	b00f      	add	sp, #60	@ 0x3c
 800e692:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e694:	200089f2 	.word	0x200089f2
 800e698:	200003f0 	.word	0x200003f0

0800e69c <browser_draw_buttons>:
static void browser_draw_buttons(void) {
 800e69c:	b508      	push	{r3, lr}
  browser_draw_button(FILE_BUTTON_DEL, "DEL");
 800e69e:	4909      	ldr	r1, [pc, #36]	@ (800e6c4 <browser_draw_buttons+0x28>)
 800e6a0:	2003      	movs	r0, #3
 800e6a2:	f7ff ffb1 	bl	800e608 <browser_draw_button>
  browser_draw_button(FILE_BUTTON_LEFT,  "<");
 800e6a6:	4908      	ldr	r1, [pc, #32]	@ (800e6c8 <browser_draw_buttons+0x2c>)
 800e6a8:	2000      	movs	r0, #0
 800e6aa:	f7ff ffad 	bl	800e608 <browser_draw_button>
  browser_draw_button(FILE_BUTTON_RIGHT, ">");
 800e6ae:	4907      	ldr	r1, [pc, #28]	@ (800e6cc <browser_draw_buttons+0x30>)
 800e6b0:	2001      	movs	r0, #1
 800e6b2:	f7ff ffa9 	bl	800e608 <browser_draw_button>
}
 800e6b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  browser_draw_button(FILE_BUTTON_EXIT,  "X");
 800e6ba:	4905      	ldr	r1, [pc, #20]	@ (800e6d0 <browser_draw_buttons+0x34>)
 800e6bc:	2002      	movs	r0, #2
 800e6be:	f7ff bfa3 	b.w	800e608 <browser_draw_button>
 800e6c2:	bf00      	nop
 800e6c4:	08014a4d 	.word	0x08014a4d
 800e6c8:	08014a51 	.word	0x08014a51
 800e6cc:	08014a53 	.word	0x08014a53
 800e6d0:	08014a55 	.word	0x08014a55

0800e6d4 <getTouchPoint>:
{
 800e6d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e6d6:	4606      	mov	r6, r0
 800e6d8:	460f      	mov	r7, r1
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800e6da:	2001      	movs	r0, #1
 800e6dc:	2100      	movs	r1, #0
{
 800e6de:	461c      	mov	r4, r3
 800e6e0:	4615      	mov	r5, r2
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800e6e2:	f002 fce9 	bl	80110b8 <lcd_set_colors>
  lcd_clear_screen();
 800e6e6:	f002 fc81 	bl	8010fec <lcd_clear_screen>
  lcd_blitBitmap(x, y, TOUCH_MARK_W, TOUCH_MARK_H, (const uint8_t *)touch_bitmap);
 800e6ea:	4b0c      	ldr	r3, [pc, #48]	@ (800e71c <getTouchPoint+0x48>)
 800e6ec:	9300      	str	r3, [sp, #0]
 800e6ee:	2309      	movs	r3, #9
 800e6f0:	461a      	mov	r2, r3
 800e6f2:	4639      	mov	r1, r7
 800e6f4:	4630      	mov	r0, r6
 800e6f6:	f002 fcf1 	bl	80110dc <lcd_blitBitmap>
  lcd_printf((LCD_WIDTH - FONT_STR_WIDTH(18)) / 2, (LCD_HEIGHT - FONT_GET_HEIGHT) / 2, "TOUCH %s *", name);
 800e6fa:	462b      	mov	r3, r5
 800e6fc:	4a08      	ldr	r2, [pc, #32]	@ (800e720 <getTouchPoint+0x4c>)
 800e6fe:	219a      	movs	r1, #154	@ 0x9a
 800e700:	20b1      	movs	r0, #177	@ 0xb1
 800e702:	f002 fd69 	bl	80111d8 <lcd_printf>
  touch_wait_release();
 800e706:	f7ff fea3 	bl	800e450 <touch_wait_release>
  data[0] = last_touch_x;
 800e70a:	4b06      	ldr	r3, [pc, #24]	@ (800e724 <getTouchPoint+0x50>)
 800e70c:	881b      	ldrh	r3, [r3, #0]
 800e70e:	8023      	strh	r3, [r4, #0]
  data[1] = last_touch_y;
 800e710:	4b05      	ldr	r3, [pc, #20]	@ (800e728 <getTouchPoint+0x54>)
 800e712:	881b      	ldrh	r3, [r3, #0]
 800e714:	8063      	strh	r3, [r4, #2]
}
 800e716:	b003      	add	sp, #12
 800e718:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e71a:	bf00      	nop
 800e71c:	08016eb4 	.word	0x08016eb4
 800e720:	08014a57 	.word	0x08014a57
 800e724:	20008a26 	.word	0x20008a26
 800e728:	20008a24 	.word	0x20008a24

0800e72c <ui_mode_normal>:
{
 800e72c:	b510      	push	{r4, lr}
  if (ui_mode == UI_NORMAL)
 800e72e:	4c0c      	ldr	r4, [pc, #48]	@ (800e760 <ui_mode_normal+0x34>)
 800e730:	7823      	ldrb	r3, [r4, #0]
 800e732:	b1a3      	cbz	r3, 800e75e <ui_mode_normal+0x32>
  set_area_size(AREA_WIDTH_NORMAL, AREA_HEIGHT_NORMAL);
 800e734:	f240 1131 	movw	r1, #305	@ 0x131
 800e738:	f240 10d1 	movw	r0, #465	@ 0x1d1
 800e73c:	f7fe f80a 	bl	800c754 <set_area_size>
  if (ui_mode == UI_MENU)
 800e740:	7823      	ldrb	r3, [r4, #0]
 800e742:	2b01      	cmp	r3, #1
 800e744:	d101      	bne.n	800e74a <ui_mode_normal+0x1e>
    request_to_draw_cells_behind_menu();
 800e746:	f7fe f817 	bl	800c778 <request_to_draw_cells_behind_menu>
  if (ui_mode == UI_KEYPAD || ui_mode == UI_BROWSER)
 800e74a:	7823      	ldrb	r3, [r4, #0]
 800e74c:	3b02      	subs	r3, #2
 800e74e:	2b01      	cmp	r3, #1
 800e750:	d803      	bhi.n	800e75a <ui_mode_normal+0x2e>
    request_to_redraw(REDRAW_ALL);
 800e752:	f240 301a 	movw	r0, #794	@ 0x31a
 800e756:	f7fe f807 	bl	800c768 <request_to_redraw>
  ui_mode = UI_NORMAL;
 800e75a:	2300      	movs	r3, #0
 800e75c:	7023      	strb	r3, [r4, #0]
}
 800e75e:	bd10      	pop	{r4, pc}
 800e760:	20008a0c 	.word	0x20008a0c

0800e764 <keypad_draw_button>:
  if (id < 0)
 800e764:	2800      	cmp	r0, #0
 800e766:	db4b      	blt.n	800e800 <keypad_draw_button+0x9c>
{
 800e768:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e76a:	b08d      	sub	sp, #52	@ 0x34
  button.fg = LCD_MENU_TEXT_COLOR;
 800e76c:	2304      	movs	r3, #4
 800e76e:	f88d 3009 	strb.w	r3, [sp, #9]
  if (id == selection)
 800e772:	4b24      	ldr	r3, [pc, #144]	@ (800e804 <keypad_draw_button+0xa0>)
  const keypad_pos_t *p = &key_pos[keypads->type];
 800e774:	4f24      	ldr	r7, [pc, #144]	@ (800e808 <keypad_draw_button+0xa4>)
  if (id == selection)
 800e776:	f993 3000 	ldrsb.w	r3, [r3]
 800e77a:	4283      	cmp	r3, r0
 800e77c:	bf14      	ite	ne
 800e77e:	2391      	movne	r3, #145	@ 0x91
 800e780:	2361      	moveq	r3, #97	@ 0x61
    button.border = KEYBOARD_BUTTON_BORDER | BUTTON_BORDER_FALLING;
 800e782:	f88d 300a 	strb.w	r3, [sp, #10]
  const keypad_pos_t *p = &key_pos[keypads->type];
 800e786:	683b      	ldr	r3, [r7, #0]
 800e788:	785c      	ldrb	r4, [r3, #1]
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800e78a:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800e78e:	ea4f 0640 	mov.w	r6, r0, lsl #1
 800e792:	7899      	ldrb	r1, [r3, #2]
 800e794:	4b1d      	ldr	r3, [pc, #116]	@ (800e80c <keypad_draw_button+0xa8>)
 800e796:	eb03 00c4 	add.w	r0, r3, r4, lsl #3
  if (id == selection)
 800e79a:	bf14      	ite	ne
 800e79c:	2203      	movne	r2, #3
 800e79e:	2205      	moveq	r2, #5
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800e7a0:	f833 4034 	ldrh.w	r4, [r3, r4, lsl #3]
    button.bg = LCD_MENU_ACTIVE_COLOR;
 800e7a4:	f88d 2008 	strb.w	r2, [sp, #8]
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800e7a8:	8882      	ldrh	r2, [r0, #4]
  int y = p->y_offs + (keypads->buttons[id].pos & 0xF) * p->height;
 800e7aa:	88c3      	ldrh	r3, [r0, #6]
  int x = p->x_offs + (keypads->buttons[id].pos >> 4) * p->width;
 800e7ac:	090d      	lsrs	r5, r1, #4
 800e7ae:	fb02 4405 	mla	r4, r2, r5, r4
  int y = p->y_offs + (keypads->buttons[id].pos & 0xF) * p->height;
 800e7b2:	8845      	ldrh	r5, [r0, #2]
 800e7b4:	f001 010f 	and.w	r1, r1, #15
 800e7b8:	fb03 5501 	mla	r5, r3, r1, r5
  ui_draw_button(x, y, p->width, p->height, &button);
 800e7bc:	a902      	add	r1, sp, #8
 800e7be:	9100      	str	r1, [sp, #0]
 800e7c0:	b2a0      	uxth	r0, r4
 800e7c2:	b2a9      	uxth	r1, r5
 800e7c4:	f7ff fec6 	bl	800e554 <ui_draw_button>
  uint8_t ch = keypads->buttons[id].c;
 800e7c8:	683b      	ldr	r3, [r7, #0]
 800e7ca:	441e      	add	r6, r3
 800e7cc:	78f0      	ldrb	r0, [r6, #3]
  if (ch == KP_EMPTY)
 800e7ce:	28ff      	cmp	r0, #255	@ 0xff
 800e7d0:	d014      	beq.n	800e7fc <keypad_draw_button+0x98>
  if (keypads->type == NUM_KEYBOARD)
 800e7d2:	785b      	ldrb	r3, [r3, #1]
 800e7d4:	b943      	cbnz	r3, 800e7e8 <keypad_draw_button+0x84>
    lcd_drawfont(ch,
 800e7d6:	f105 0219 	add.w	r2, r5, #25
 800e7da:	f104 0134 	add.w	r1, r4, #52	@ 0x34
}
 800e7de:	b00d      	add	sp, #52	@ 0x34
 800e7e0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    lcd_drawfont(ch,
 800e7e4:	f002 bdfe 	b.w	80113e4 <lcd_drawfont>
    lcd_drawchar_size(ch,
 800e7e8:	2302      	movs	r3, #2
 800e7ea:	f105 020d 	add.w	r2, r5, #13
 800e7ee:	f104 0112 	add.w	r1, r4, #18
}
 800e7f2:	b00d      	add	sp, #52	@ 0x34
 800e7f4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    lcd_drawchar_size(ch,
 800e7f8:	f002 bd76 	b.w	80112e8 <lcd_drawchar_size>
}
 800e7fc:	b00d      	add	sp, #52	@ 0x34
 800e7fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e800:	4770      	bx	lr
 800e802:	bf00      	nop
 800e804:	200003f0 	.word	0x200003f0
 800e808:	20008a08 	.word	0x20008a08
 800e80c:	08016b30 	.word	0x08016b30

0800e810 <ui_mode_keypad>:
{
 800e810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (ui_mode == UI_KEYPAD)
 800e812:	4b27      	ldr	r3, [pc, #156]	@ (800e8b0 <ui_mode_keypad+0xa0>)
 800e814:	781a      	ldrb	r2, [r3, #0]
 800e816:	2a02      	cmp	r2, #2
 800e818:	d048      	beq.n	800e8ac <ui_mode_keypad+0x9c>
  set_area_size(0, 0);
 800e81a:	2100      	movs	r1, #0
 800e81c:	4604      	mov	r4, r0
  ui_mode = UI_KEYPAD;
 800e81e:	2202      	movs	r2, #2
  keypad_mode = mode;
 800e820:	4e24      	ldr	r6, [pc, #144]	@ (800e8b4 <ui_mode_keypad+0xa4>)
  ui_mode = UI_KEYPAD;
 800e822:	701a      	strb	r2, [r3, #0]
  set_area_size(0, 0);
 800e824:	4608      	mov	r0, r1
 800e826:	f7fd ff95 	bl	800c754 <set_area_size>
  keypads = keypad_type_list[keypads_mode_tbl[mode].keypad_type];
 800e82a:	230a      	movs	r3, #10
 800e82c:	4d22      	ldr	r5, [pc, #136]	@ (800e8b8 <ui_mode_keypad+0xa8>)
  keypad_mode = mode;
 800e82e:	7034      	strb	r4, [r6, #0]
  keypads = keypad_type_list[keypads_mode_tbl[mode].keypad_type];
 800e830:	435c      	muls	r4, r3
 800e832:	4b22      	ldr	r3, [pc, #136]	@ (800e8bc <ui_mode_keypad+0xac>)
 800e834:	5d2a      	ldrb	r2, [r5, r4]
 800e836:	4f22      	ldr	r7, [pc, #136]	@ (800e8c0 <ui_mode_keypad+0xb0>)
 800e838:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e83c:	603b      	str	r3, [r7, #0]
  selection = -1;
 800e83e:	4b21      	ldr	r3, [pc, #132]	@ (800e8c4 <ui_mode_keypad+0xb4>)
 800e840:	22ff      	movs	r2, #255	@ 0xff
 800e842:	701a      	strb	r2, [r3, #0]
  kp_buf[0] = 0;
 800e844:	4b20      	ldr	r3, [pc, #128]	@ (800e8c8 <ui_mode_keypad+0xb8>)
 800e846:	2400      	movs	r4, #0
 800e848:	701c      	strb	r4, [r3, #0]
  for (int i = 0; i < keypads->size; i++)
 800e84a:	683b      	ldr	r3, [r7, #0]
 800e84c:	781b      	ldrb	r3, [r3, #0]
 800e84e:	429c      	cmp	r4, r3
 800e850:	da04      	bge.n	800e85c <ui_mode_keypad+0x4c>
    keypad_draw_button(i);
 800e852:	4620      	mov	r0, r4
 800e854:	f7ff ff86 	bl	800e764 <keypad_draw_button>
  for (int i = 0; i < keypads->size; i++)
 800e858:	3401      	adds	r4, #1
 800e85a:	e7f6      	b.n	800e84a <ui_mode_keypad+0x3a>
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800e85c:	2114      	movs	r1, #20
 800e85e:	2013      	movs	r0, #19
 800e860:	f002 fc2a 	bl	80110b8 <lcd_set_colors>
  lcd_fill(0, LCD_HEIGHT - NUM_INPUT_HEIGHT, LCD_WIDTH, NUM_INPUT_HEIGHT);
 800e864:	2320      	movs	r3, #32
 800e866:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800e86a:	f44f 7190 	mov.w	r1, #288	@ 0x120
 800e86e:	2000      	movs	r0, #0
 800e870:	f002 fb1c 	bl	8010eac <lcd_fill>
  const char *label = keypads_mode_tbl[keypad_mode].name;
 800e874:	7833      	ldrb	r3, [r6, #0]
 800e876:	220a      	movs	r2, #10
 800e878:	fb02 5503 	mla	r5, r2, r3, r5
  int n = 1;
 800e87c:	2301      	movs	r3, #1
  const char *label = keypads_mode_tbl[keypad_mode].name;
 800e87e:	f8d5 2002 	ldr.w	r2, [r5, #2]
  while (*label)
 800e882:	1e51      	subs	r1, r2, #1
 800e884:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 800e888:	b118      	cbz	r0, 800e892 <ui_mode_keypad+0x82>
    if (*label++ == '\n')
 800e88a:	280a      	cmp	r0, #10
      n++;
 800e88c:	bf08      	it	eq
 800e88e:	3301      	addeq	r3, #1
 800e890:	e7f8      	b.n	800e884 <ui_mode_keypad+0x74>
  lcd_drawstring(10, LCD_HEIGHT - (FONT_STR_HEIGHT * lines + NUM_INPUT_HEIGHT) / 2, label);
 800e892:	210b      	movs	r1, #11
 800e894:	434b      	muls	r3, r1
 800e896:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 800e89a:	1059      	asrs	r1, r3, #1
 800e89c:	f5c1 7198 	rsb	r1, r1, #304	@ 0x130
}
 800e8a0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  lcd_drawstring(10, LCD_HEIGHT - (FONT_STR_HEIGHT * lines + NUM_INPUT_HEIGHT) / 2, label);
 800e8a4:	b209      	sxth	r1, r1
 800e8a6:	200a      	movs	r0, #10
 800e8a8:	f002 bc96 	b.w	80111d8 <lcd_printf>
}
 800e8ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e8ae:	bf00      	nop
 800e8b0:	20008a0c 	.word	0x20008a0c
 800e8b4:	20008a07 	.word	0x20008a07
 800e8b8:	08016874 	.word	0x08016874
 800e8bc:	080169c0 	.word	0x080169c0
 800e8c0:	20008a08 	.word	0x20008a08
 800e8c4:	200003f0 	.word	0x200003f0
 800e8c8:	20008a10 	.word	0x20008a10

0800e8cc <load_cmd>:
{
 800e8cc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800e8d0:	4e16      	ldr	r6, [pc, #88]	@ (800e92c <load_cmd+0x60>)
{
 800e8d2:	4607      	mov	r7, r0
  uint16_t j = 0, i;
 800e8d4:	2500      	movs	r5, #0
        line[j++] = (char)c; // Store
 800e8d6:	f506 7880 	add.w	r8, r6, #256	@ 0x100
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800e8da:	ab01      	add	r3, sp, #4
 800e8dc:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800e8e0:	4631      	mov	r1, r6
 800e8e2:	4638      	mov	r0, r7
 800e8e4:	f7f6 f980 	bl	8004be8 <f_read>
 800e8e8:	4604      	mov	r4, r0
 800e8ea:	b9d0      	cbnz	r0, 800e922 <load_cmd+0x56>
 800e8ec:	9b01      	ldr	r3, [sp, #4]
 800e8ee:	b1c3      	cbz	r3, 800e922 <load_cmd+0x56>
        line[j] = 0;
 800e8f0:	46a1      	mov	r9, r4
    for (i = 0; i < size; i++)
 800e8f2:	9a01      	ldr	r2, [sp, #4]
 800e8f4:	b2a3      	uxth	r3, r4
 800e8f6:	429a      	cmp	r2, r3
 800e8f8:	d9ef      	bls.n	800e8da <load_cmd+0xe>
      uint8_t c = buf_8[i];
 800e8fa:	5cf3      	ldrb	r3, [r6, r3]
      if (c == '\r')
 800e8fc:	2b0d      	cmp	r3, #13
 800e8fe:	d106      	bne.n	800e90e <load_cmd+0x42>
        line[j] = 0;
 800e900:	f808 9005 	strb.w	r9, [r8, r5]
        VNAShell_executeCMDLine(line);
 800e904:	480a      	ldr	r0, [pc, #40]	@ (800e930 <load_cmd+0x64>)
 800e906:	f7fa fe45 	bl	8009594 <VNAShell_executeCMDLine>
        j = 0;
 800e90a:	2500      	movs	r5, #0
 800e90c:	e007      	b.n	800e91e <load_cmd+0x52>
      else if (c < 0x20)
 800e90e:	2b1f      	cmp	r3, #31
 800e910:	d905      	bls.n	800e91e <load_cmd+0x52>
      else if (j < line_size)
 800e912:	2d7f      	cmp	r5, #127	@ 0x7f
 800e914:	d803      	bhi.n	800e91e <load_cmd+0x52>
        line[j++] = (char)c; // Store
 800e916:	1c6a      	adds	r2, r5, #1
 800e918:	f808 3005 	strb.w	r3, [r8, r5]
 800e91c:	b295      	uxth	r5, r2
    for (i = 0; i < size; i++)
 800e91e:	3401      	adds	r4, #1
 800e920:	e7e7      	b.n	800e8f2 <load_cmd+0x26>
}
 800e922:	2000      	movs	r0, #0
 800e924:	b003      	add	sp, #12
 800e926:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800e92a:	bf00      	nop
 800e92c:	20008a3c 	.word	0x20008a3c
 800e930:	20008b3c 	.word	0x20008b3c

0800e934 <save_bin>:
{
 800e934:	b507      	push	{r0, r1, r2, lr}
  return f_write(f, src, total, &size);
 800e936:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 800e93a:	ab01      	add	r3, sp, #4
 800e93c:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
 800e940:	f7f6 fa26 	bl	8004d90 <f_write>
}
 800e944:	b003      	add	sp, #12
 800e946:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800e94c <save_cal>:
{
 800e94c:	b507      	push	{r0, r1, r2, lr}
  return f_write(f, src, total, &size);
 800e94e:	4904      	ldr	r1, [pc, #16]	@ (800e960 <save_cal+0x14>)
 800e950:	ab01      	add	r3, sp, #4
 800e952:	f643 727c 	movw	r2, #16252	@ 0x3f7c
 800e956:	f7f6 fa1b 	bl	8004d90 <f_write>
}
 800e95a:	b003      	add	sp, #12
 800e95c:	f85d fb04 	ldr.w	pc, [sp], #4
 800e960:	20000aa8 	.word	0x20000aa8

0800e964 <load_cal>:
  if (fno->fsize != sizeof(current_props) || f_read(f, &magic, sizeof(magic), &size) != FR_OK ||
 800e964:	e9d1 3200 	ldrd	r3, r2, [r1]
 800e968:	f5a3 537d 	sub.w	r3, r3, #16192	@ 0x3f40
 800e96c:	3b3c      	subs	r3, #60	@ 0x3c
 800e96e:	4313      	orrs	r3, r2
{
 800e970:	b513      	push	{r0, r1, r4, lr}
  if (fno->fsize != sizeof(current_props) || f_read(f, &magic, sizeof(magic), &size) != FR_OK ||
 800e972:	d001      	beq.n	800e978 <load_cal+0x14>
    return "Format err";
 800e974:	480f      	ldr	r0, [pc, #60]	@ (800e9b4 <load_cal+0x50>)
 800e976:	e01b      	b.n	800e9b0 <load_cal+0x4c>
  if (fno->fsize != sizeof(current_props) || f_read(f, &magic, sizeof(magic), &size) != FR_OK ||
 800e978:	2204      	movs	r2, #4
 800e97a:	466b      	mov	r3, sp
 800e97c:	eb0d 0102 	add.w	r1, sp, r2
 800e980:	4604      	mov	r4, r0
 800e982:	f7f6 f931 	bl	8004be8 <f_read>
 800e986:	2800      	cmp	r0, #0
 800e988:	d1f4      	bne.n	800e974 <load_cal+0x10>
 800e98a:	4b0b      	ldr	r3, [pc, #44]	@ (800e9b8 <load_cal+0x54>)
 800e98c:	9a01      	ldr	r2, [sp, #4]
 800e98e:	429a      	cmp	r2, r3
 800e990:	d1f0      	bne.n	800e974 <load_cal+0x10>
      magic != PROPERTIES_MAGIC || f_read(f, src, total, &size) != FR_OK)
 800e992:	4620      	mov	r0, r4
 800e994:	4909      	ldr	r1, [pc, #36]	@ (800e9bc <load_cal+0x58>)
 800e996:	466b      	mov	r3, sp
 800e998:	f643 7278 	movw	r2, #16248	@ 0x3f78
 800e99c:	f7f6 f924 	bl	8004be8 <f_read>
 800e9a0:	4604      	mov	r4, r0
 800e9a2:	2800      	cmp	r0, #0
 800e9a4:	d1e6      	bne.n	800e974 <load_cal+0x10>
  load_properties(NO_SAVE_SLOT);
 800e9a6:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 800e9aa:	f7f8 ffa5 	bl	80078f8 <load_properties>
  return NULL;
 800e9ae:	4620      	mov	r0, r4
}
 800e9b0:	b002      	add	sp, #8
 800e9b2:	bd10      	pop	{r4, pc}
 800e9b4:	08014a62 	.word	0x08014a62
 800e9b8:	434f4e54 	.word	0x434f4e54
 800e9bc:	20000aac 	.word	0x20000aac

0800e9c0 <load_tiff>:
{
 800e9c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FRESULT res = f_read(f, (void *)buf_16, sizeof(tif_header), &size); // read header
 800e9c4:	4d3f      	ldr	r5, [pc, #252]	@ (800eac4 <load_tiff+0x104>)
{
 800e9c6:	b085      	sub	sp, #20
 800e9c8:	4688      	mov	r8, r1
  FRESULT res = f_read(f, (void *)buf_16, sizeof(tif_header), &size); // read header
 800e9ca:	ab03      	add	r3, sp, #12
 800e9cc:	2268      	movs	r2, #104	@ 0x68
 800e9ce:	4629      	mov	r1, r5
{
 800e9d0:	4607      	mov	r7, r0
  FRESULT res = f_read(f, (void *)buf_16, sizeof(tif_header), &size); // read header
 800e9d2:	f7f6 f909 	bl	8004be8 <f_read>
  if (res != FR_OK ||
 800e9d6:	2800      	cmp	r0, #0
 800e9d8:	d16f      	bne.n	800eaba <load_tiff+0xfa>
 800e9da:	882a      	ldrh	r2, [r5, #0]
 800e9dc:	f644 1349 	movw	r3, #18761	@ 0x4949
 800e9e0:	429a      	cmp	r2, r3
 800e9e2:	d16a      	bne.n	800eaba <load_tiff+0xfa>
      buf_16[0] != 0x4949 ||      // Check header ID
 800e9e4:	8a6b      	ldrh	r3, [r5, #18]
 800e9e6:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 800e9ea:	d166      	bne.n	800eaba <load_tiff+0xfa>
      buf_16[9] != LCD_WIDTH ||   // Check Width
 800e9ec:	8beb      	ldrh	r3, [r5, #30]
 800e9ee:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800e9f2:	d162      	bne.n	800eaba <load_tiff+0xfa>
      buf_16[15] != LCD_HEIGHT || // Check Height
 800e9f4:	8eea      	ldrh	r2, [r5, #54]	@ 0x36
 800e9f6:	f248 0305 	movw	r3, #32773	@ 0x8005
 800e9fa:	429a      	cmp	r2, r3
 800e9fc:	d15d      	bne.n	800eaba <load_tiff+0xfa>
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800e9fe:	f8df 90cc 	ldr.w	r9, [pc, #204]	@ 800eacc <load_tiff+0x10c>
 800ea02:	4604      	mov	r4, r0
    for (int x = 0; x < LCD_WIDTH * 3;)
 800ea04:	f04f 0a00 	mov.w	sl, #0
      res = f_read(f, data, 2, &size); // Read count and value
 800ea08:	ab03      	add	r3, sp, #12
 800ea0a:	2202      	movs	r2, #2
 800ea0c:	a902      	add	r1, sp, #8
 800ea0e:	4638      	mov	r0, r7
 800ea10:	f7f6 f8ea 	bl	8004be8 <f_read>
      int count = data[0];             // count
 800ea14:	f99d 2008 	ldrsb.w	r2, [sp, #8]
      res = f_read(f, data, 2, &size); // Read count and value
 800ea18:	4606      	mov	r6, r0
      if (count > 0)
 800ea1a:	2a00      	cmp	r2, #0
      buf_8[x++] = data[1];            // copy first value
 800ea1c:	f89d 0009 	ldrb.w	r0, [sp, #9]
 800ea20:	f805 000a 	strb.w	r0, [r5, sl]
      int count = data[0];             // count
 800ea24:	4611      	mov	r1, r2
      buf_8[x++] = data[1];            // copy first value
 800ea26:	f10a 0b01 	add.w	fp, sl, #1
 800ea2a:	eb05 030a 	add.w	r3, r5, sl
      if (count > 0)
 800ea2e:	dd0b      	ble.n	800ea48 <load_tiff+0x88>
        res = f_read(f, &buf_8[x], count, &size);
 800ea30:	ab03      	add	r3, sp, #12
 800ea32:	eb05 010b 	add.w	r1, r5, fp
 800ea36:	4638      	mov	r0, r7
 800ea38:	9201      	str	r2, [sp, #4]
 800ea3a:	f7f6 f8d5 	bl	8004be8 <f_read>
        x += count;
 800ea3e:	9a01      	ldr	r2, [sp, #4]
        res = f_read(f, &buf_8[x], count, &size);
 800ea40:	4606      	mov	r6, r0
        x += count;
 800ea42:	eb02 0a0b 	add.w	sl, r2, fp
 800ea46:	e007      	b.n	800ea58 <load_tiff+0x98>
        while (count++ < 0)
 800ea48:	3101      	adds	r1, #1
 800ea4a:	2901      	cmp	r1, #1
 800ea4c:	d002      	beq.n	800ea54 <load_tiff+0x94>
          buf_8[x++] = data[1]; // if count < 0 need repeat value -count times
 800ea4e:	f803 0f01 	strb.w	r0, [r3, #1]!
 800ea52:	e7f9      	b.n	800ea48 <load_tiff+0x88>
 800ea54:	ebab 0a02 	sub.w	sl, fp, r2
    for (int x = 0; x < LCD_WIDTH * 3;)
 800ea58:	f5ba 6fb4 	cmp.w	sl, #1440	@ 0x5a0
 800ea5c:	dbd4      	blt.n	800ea08 <load_tiff+0x48>
    for (int x = 0; x < LCD_WIDTH; x++)
 800ea5e:	f8df c064 	ldr.w	ip, [pc, #100]	@ 800eac4 <load_tiff+0x104>
 800ea62:	2200      	movs	r2, #0
    for (int x = 0; x < LCD_WIDTH * 3;)
 800ea64:	4660      	mov	r0, ip
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800ea66:	7881      	ldrb	r1, [r0, #2]
 800ea68:	f890 e001 	ldrb.w	lr, [r0, #1]
 800ea6c:	0149      	lsls	r1, r1, #5
 800ea6e:	ea09 23ce 	and.w	r3, r9, lr, lsl #11
 800ea72:	f401 51f8 	and.w	r1, r1, #7936	@ 0x1f00
 800ea76:	4319      	orrs	r1, r3
 800ea78:	f810 3b03 	ldrb.w	r3, [r0], #3
 800ea7c:	f023 0307 	bic.w	r3, r3, #7
 800ea80:	ea43 135e 	orr.w	r3, r3, lr, lsr #5
    for (int x = 0; x < LCD_WIDTH; x++)
 800ea84:	3201      	adds	r2, #1
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800ea86:	430b      	orrs	r3, r1
    for (int x = 0; x < LCD_WIDTH; x++)
 800ea88:	f5b2 7ff0 	cmp.w	r2, #480	@ 0x1e0
      buf_16[x] = RGB565(buf_8[3 * x + 0], buf_8[3 * x + 1], buf_8[3 * x + 2]);
 800ea8c:	f82c 3b02 	strh.w	r3, [ip], #2
    for (int x = 0; x < LCD_WIDTH; x++)
 800ea90:	d1e9      	bne.n	800ea66 <load_tiff+0xa6>
    lcd_bulk(0, y, LCD_WIDTH, 1);
 800ea92:	4621      	mov	r1, r4
 800ea94:	2301      	movs	r3, #1
 800ea96:	2000      	movs	r0, #0
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800ea98:	3401      	adds	r4, #1
    lcd_bulk(0, y, LCD_WIDTH, 1);
 800ea9a:	f002 f9f9 	bl	8010e90 <lcd_bulk>
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800ea9e:	f5b4 7fa0 	cmp.w	r4, #320	@ 0x140
 800eaa2:	d001      	beq.n	800eaa8 <load_tiff+0xe8>
 800eaa4:	2e00      	cmp	r6, #0
 800eaa6:	d0ad      	beq.n	800ea04 <load_tiff+0x44>
  lcd_printf(0, LCD_HEIGHT - 3 * FONT_STR_HEIGHT, fno->fname);
 800eaa8:	f108 021a 	add.w	r2, r8, #26
 800eaac:	f240 111f 	movw	r1, #287	@ 0x11f
 800eab0:	2000      	movs	r0, #0
 800eab2:	f002 fb91 	bl	80111d8 <lcd_printf>
  return NULL;
 800eab6:	2000      	movs	r0, #0
 800eab8:	e000      	b.n	800eabc <load_tiff+0xfc>
    return "Format err";
 800eaba:	4803      	ldr	r0, [pc, #12]	@ (800eac8 <load_tiff+0x108>)
}
 800eabc:	b005      	add	sp, #20
 800eabe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800eac2:	bf00      	nop
 800eac4:	20008a3c 	.word	0x20008a3c
 800eac8:	08014a62 	.word	0x08014a62
 800eacc:	ffffe000 	.word	0xffffe000

0800ead0 <save_tiff>:
{
 800ead0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ead2:	b085      	sub	sp, #20
  FRESULT res = f_write(f, tif_header, sizeof(tif_header), &size); // Write header struct
 800ead4:	4925      	ldr	r1, [pc, #148]	@ (800eb6c <save_tiff+0x9c>)
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800ead6:	4f26      	ldr	r7, [pc, #152]	@ (800eb70 <save_tiff+0xa0>)
  FRESULT res = f_write(f, tif_header, sizeof(tif_header), &size); // Write header struct
 800ead8:	ab03      	add	r3, sp, #12
 800eada:	2268      	movs	r2, #104	@ 0x68
{
 800eadc:	4606      	mov	r6, r0
  FRESULT res = f_write(f, tif_header, sizeof(tif_header), &size); // Write header struct
 800eade:	f7f6 f957 	bl	8004d90 <f_write>
 800eae2:	4604      	mov	r4, r0
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 800eae4:	2011      	movs	r0, #17
 800eae6:	f002 fadb 	bl	80110a0 <lcd_set_background>
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800eaea:	2500      	movs	r5, #0
 800eaec:	2c00      	cmp	r4, #0
 800eaee:	d13a      	bne.n	800eb66 <save_tiff+0x96>
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800eaf0:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800eaf4:	4629      	mov	r1, r5
 800eaf6:	9700      	str	r7, [sp, #0]
 800eaf8:	2301      	movs	r3, #1
 800eafa:	4620      	mov	r0, r4
 800eafc:	f002 f96a 	bl	8010dd4 <lcd_read_memory>
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800eb00:	4a1b      	ldr	r2, [pc, #108]	@ (800eb70 <save_tiff+0xa0>)
 800eb02:	f240 11df 	movw	r1, #479	@ 0x1df
      uint16_t color = (buf_16[x] << 8) | (buf_16[x] >> 8);
 800eb06:	f837 3011 	ldrh.w	r3, [r7, r1, lsl #1]
 800eb0a:	ba5b      	rev16	r3, r3
      buf_8[3 * x + 0] = (color >> 8) & 0xF8; // if (buf_8[3*x + 0] < 0) buf_8[3*x + 0]+= 7;
 800eb0c:	f3c3 2007 	ubfx	r0, r3, #8, #8
 800eb10:	f020 0007 	bic.w	r0, r0, #7
 800eb14:	f882 061d 	strb.w	r0, [r2, #1565]	@ 0x61d
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800eb18:	3901      	subs	r1, #1
      buf_8[3 * x + 1] = (color >> 3) & 0xFC; // if (buf_8[3*x + 1] < 0) buf_8[3*x + 1]+= 3;
 800eb1a:	f3c3 00cc 	ubfx	r0, r3, #3, #13
      buf_8[3 * x + 2] = (color << 3) & 0xF8; // if (buf_8[3*x + 2] < 0) buf_8[3*x + 2]+= 7;
 800eb1e:	00db      	lsls	r3, r3, #3
 800eb20:	f882 361f 	strb.w	r3, [r2, #1567]	@ 0x61f
      buf_8[3 * x + 1] = (color >> 3) & 0xFC; // if (buf_8[3*x + 1] < 0) buf_8[3*x + 1]+= 3;
 800eb24:	f020 0003 	bic.w	r0, r0, #3
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800eb28:	1c4b      	adds	r3, r1, #1
      buf_8[3 * x + 1] = (color >> 3) & 0xFC; // if (buf_8[3*x + 1] < 0) buf_8[3*x + 1]+= 3;
 800eb2a:	f882 061e 	strb.w	r0, [r2, #1566]	@ 0x61e
    for (int x = LCD_WIDTH - 1; x >= 0; x--)
 800eb2e:	f1a2 0203 	sub.w	r2, r2, #3
 800eb32:	d1e8      	bne.n	800eb06 <save_tiff+0x36>
    size = packbits(buf_8, (char *)buf_16, LCD_WIDTH * 3);
 800eb34:	f44f 62b4 	mov.w	r2, #1440	@ 0x5a0
 800eb38:	4639      	mov	r1, r7
 800eb3a:	480e      	ldr	r0, [pc, #56]	@ (800eb74 <save_tiff+0xa4>)
 800eb3c:	f7fb f810 	bl	8009b60 <packbits>
    res = f_write(f, buf_16, size, &size);
 800eb40:	ab03      	add	r3, sp, #12
    size = packbits(buf_8, (char *)buf_16, LCD_WIDTH * 3);
 800eb42:	4602      	mov	r2, r0
 800eb44:	9003      	str	r0, [sp, #12]
    res = f_write(f, buf_16, size, &size);
 800eb46:	4639      	mov	r1, r7
 800eb48:	4630      	mov	r0, r6
 800eb4a:	f7f6 f921 	bl	8004d90 <f_write>
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800eb4e:	2301      	movs	r3, #1
 800eb50:	4629      	mov	r1, r5
    res = f_write(f, buf_16, size, &size);
 800eb52:	4604      	mov	r4, r0
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800eb54:	461a      	mov	r2, r3
 800eb56:	f240 10df 	movw	r0, #479	@ 0x1df
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800eb5a:	3501      	adds	r5, #1
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800eb5c:	f002 f9a6 	bl	8010eac <lcd_fill>
  for (int y = 0; y < LCD_HEIGHT && res == FR_OK; y++)
 800eb60:	f5b5 7fa0 	cmp.w	r5, #320	@ 0x140
 800eb64:	d1c2      	bne.n	800eaec <save_tiff+0x1c>
}
 800eb66:	4620      	mov	r0, r4
 800eb68:	b005      	add	sp, #20
 800eb6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800eb6c:	08016c0c 	.word	0x08016c0c
 800eb70:	20008a3c 	.word	0x20008a3c
 800eb74:	20008abc 	.word	0x20008abc

0800eb78 <load_bmp>:
{
 800eb78:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  FRESULT res = f_read(f, (void *)buf_16, sizeof(bmp_header_v4), &size); // read header
 800eb7c:	4c1d      	ldr	r4, [pc, #116]	@ (800ebf4 <load_bmp+0x7c>)
{
 800eb7e:	460e      	mov	r6, r1
  FRESULT res = f_read(f, (void *)buf_16, sizeof(bmp_header_v4), &size); // read header
 800eb80:	ab01      	add	r3, sp, #4
 800eb82:	227a      	movs	r2, #122	@ 0x7a
 800eb84:	4621      	mov	r1, r4
{
 800eb86:	4607      	mov	r7, r0
  FRESULT res = f_read(f, (void *)buf_16, sizeof(bmp_header_v4), &size); // read header
 800eb88:	f7f6 f82e 	bl	8004be8 <f_read>
  if (res != FR_OK || buf_16[9] != LCD_WIDTH || buf_16[11] != LCD_HEIGHT || buf_16[14] != 16)
 800eb8c:	bb70      	cbnz	r0, 800ebec <load_bmp+0x74>
 800eb8e:	8a63      	ldrh	r3, [r4, #18]
 800eb90:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
 800eb94:	d12a      	bne.n	800ebec <load_bmp+0x74>
 800eb96:	8ae3      	ldrh	r3, [r4, #22]
 800eb98:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800eb9c:	d126      	bne.n	800ebec <load_bmp+0x74>
 800eb9e:	8ba3      	ldrh	r3, [r4, #28]
 800eba0:	2b10      	cmp	r3, #16
 800eba2:	d123      	bne.n	800ebec <load_bmp+0x74>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800eba4:	f240 153f 	movw	r5, #319	@ 0x13f
    res = f_read(f, (void *)buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800eba8:	ab01      	add	r3, sp, #4
 800ebaa:	f44f 7270 	mov.w	r2, #960	@ 0x3c0
 800ebae:	4621      	mov	r1, r4
 800ebb0:	4638      	mov	r0, r7
 800ebb2:	f7f6 f819 	bl	8004be8 <f_read>
    swap_bytes(buf_16, LCD_WIDTH);
 800ebb6:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
    res = f_read(f, (void *)buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800ebba:	4680      	mov	r8, r0
    swap_bytes(buf_16, LCD_WIDTH);
 800ebbc:	4620      	mov	r0, r4
 800ebbe:	f7fa ffc3 	bl	8009b48 <swap_bytes>
    lcd_bulk(0, y, LCD_WIDTH, 1);
 800ebc2:	4629      	mov	r1, r5
 800ebc4:	2301      	movs	r3, #1
 800ebc6:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800ebca:	2000      	movs	r0, #0
 800ebcc:	f002 f960 	bl	8010e90 <lcd_bulk>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800ebd0:	3d01      	subs	r5, #1
 800ebd2:	d302      	bcc.n	800ebda <load_bmp+0x62>
 800ebd4:	f1b8 0f00 	cmp.w	r8, #0
 800ebd8:	d0e6      	beq.n	800eba8 <load_bmp+0x30>
  lcd_printf(0, LCD_HEIGHT - 3 * FONT_STR_HEIGHT, fno->fname);
 800ebda:	f106 021a 	add.w	r2, r6, #26
 800ebde:	f240 111f 	movw	r1, #287	@ 0x11f
 800ebe2:	2000      	movs	r0, #0
 800ebe4:	f002 faf8 	bl	80111d8 <lcd_printf>
  return NULL;
 800ebe8:	2000      	movs	r0, #0
 800ebea:	e000      	b.n	800ebee <load_bmp+0x76>
    return "Format err";
 800ebec:	4802      	ldr	r0, [pc, #8]	@ (800ebf8 <load_bmp+0x80>)
}
 800ebee:	b002      	add	sp, #8
 800ebf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ebf4:	20008a3c 	.word	0x20008a3c
 800ebf8:	08014a62 	.word	0x08014a62

0800ebfc <save_bmp>:
{
 800ebfc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ebfe:	b085      	sub	sp, #20
  FRESULT res = f_write(f, bmp_header_v4, sizeof(bmp_header_v4), &size); // Write header struct
 800ec00:	4917      	ldr	r1, [pc, #92]	@ (800ec60 <save_bmp+0x64>)
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800ec02:	4f18      	ldr	r7, [pc, #96]	@ (800ec64 <save_bmp+0x68>)
  FRESULT res = f_write(f, bmp_header_v4, sizeof(bmp_header_v4), &size); // Write header struct
 800ec04:	ab03      	add	r3, sp, #12
 800ec06:	227a      	movs	r2, #122	@ 0x7a
{
 800ec08:	4606      	mov	r6, r0
  FRESULT res = f_write(f, bmp_header_v4, sizeof(bmp_header_v4), &size); // Write header struct
 800ec0a:	f7f6 f8c1 	bl	8004d90 <f_write>
 800ec0e:	4604      	mov	r4, r0
  lcd_set_background(LCD_SWEEP_LINE_COLOR);
 800ec10:	2011      	movs	r0, #17
 800ec12:	f002 fa45 	bl	80110a0 <lcd_set_background>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800ec16:	f240 153f 	movw	r5, #319	@ 0x13f
 800ec1a:	b9ec      	cbnz	r4, 800ec58 <save_bmp+0x5c>
    lcd_read_memory(0, y, LCD_WIDTH, 1, buf_16);
 800ec1c:	2301      	movs	r3, #1
 800ec1e:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800ec22:	4629      	mov	r1, r5
 800ec24:	4620      	mov	r0, r4
 800ec26:	9700      	str	r7, [sp, #0]
 800ec28:	f002 f8d4 	bl	8010dd4 <lcd_read_memory>
    swap_bytes(buf_16, LCD_WIDTH);
 800ec2c:	480d      	ldr	r0, [pc, #52]	@ (800ec64 <save_bmp+0x68>)
 800ec2e:	f44f 71f0 	mov.w	r1, #480	@ 0x1e0
 800ec32:	f7fa ff89 	bl	8009b48 <swap_bytes>
    res = f_write(f, buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800ec36:	490b      	ldr	r1, [pc, #44]	@ (800ec64 <save_bmp+0x68>)
 800ec38:	ab03      	add	r3, sp, #12
 800ec3a:	f44f 7270 	mov.w	r2, #960	@ 0x3c0
 800ec3e:	4630      	mov	r0, r6
 800ec40:	f7f6 f8a6 	bl	8004d90 <f_write>
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800ec44:	2301      	movs	r3, #1
 800ec46:	4629      	mov	r1, r5
    res = f_write(f, buf_16, LCD_WIDTH * sizeof(uint16_t), &size);
 800ec48:	4604      	mov	r4, r0
    lcd_fill(LCD_WIDTH - 1, y, 1, 1);
 800ec4a:	461a      	mov	r2, r3
 800ec4c:	f240 10df 	movw	r0, #479	@ 0x1df
 800ec50:	f002 f92c 	bl	8010eac <lcd_fill>
  for (int y = LCD_HEIGHT - 1; y >= 0 && res == FR_OK; y--)
 800ec54:	3d01      	subs	r5, #1
 800ec56:	d2e0      	bcs.n	800ec1a <save_bmp+0x1e>
}
 800ec58:	4620      	mov	r0, r4
 800ec5a:	b005      	add	sp, #20
 800ec5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ec5e:	bf00      	nop
 800ec60:	08016c74 	.word	0x08016c74
 800ec64:	20008a3c 	.word	0x20008a3c

0800ec68 <load_snp>:
{
 800ec68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ec6c:	ed2d 8b02 	vpush	{d8}
 800ec70:	b095      	sub	sp, #84	@ 0x54
  freq_t start = 0, stop = 0, freq;
 800ec72:	2500      	movs	r5, #0
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800ec74:	f8df b144 	ldr.w	fp, [pc, #324]	@ 800edbc <load_snp+0x154>
        measured[0][count][0] = my_atof(args[1]);
 800ec78:	f8df 8144 	ldr.w	r8, [pc, #324]	@ 800edc0 <load_snp+0x158>
{
 800ec7c:	9200      	str	r2, [sp, #0]
 800ec7e:	4681      	mov	r9, r0
  freq_t start = 0, stop = 0, freq;
 800ec80:	46aa      	mov	sl, r5
  uint16_t j = 0, i, count = 0;
 800ec82:	462c      	mov	r4, r5
 800ec84:	462f      	mov	r7, r5
  while (f_read(f, buf_8, buffer_size, &size) == FR_OK && size > 0)
 800ec86:	ab03      	add	r3, sp, #12
 800ec88:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800ec8c:	4659      	mov	r1, fp
 800ec8e:	4648      	mov	r0, r9
 800ec90:	f7f5 ffaa 	bl	8004be8 <f_read>
 800ec94:	4606      	mov	r6, r0
 800ec96:	2800      	cmp	r0, #0
 800ec98:	d168      	bne.n	800ed6c <load_snp+0x104>
 800ec9a:	9b03      	ldr	r3, [sp, #12]
 800ec9c:	2b00      	cmp	r3, #0
 800ec9e:	d065      	beq.n	800ed6c <load_snp+0x104>
          measured[1][count][0] = 0.0f;
 800eca0:	ed9f 8a41 	vldr	s16, [pc, #260]	@ 800eda8 <load_snp+0x140>
    for (i = 0; i < size; i++)
 800eca4:	9a03      	ldr	r2, [sp, #12]
 800eca6:	b2b3      	uxth	r3, r6
 800eca8:	429a      	cmp	r2, r3
 800ecaa:	d9ec      	bls.n	800ec86 <load_snp+0x1e>
      uint8_t c = buf_8[i];
 800ecac:	f81b 3003 	ldrb.w	r3, [fp, r3]
      if (c == '\r')
 800ecb0:	2b0d      	cmp	r3, #13
 800ecb2:	d151      	bne.n	800ed58 <load_snp+0xf0>
        line[j] = 0;
 800ecb4:	4a3d      	ldr	r2, [pc, #244]	@ (800edac <load_snp+0x144>)
        int nargs = parse_line(line, args, 16); // Parse line to 16 args
 800ecb6:	483d      	ldr	r0, [pc, #244]	@ (800edac <load_snp+0x144>)
        line[j] = 0;
 800ecb8:	2300      	movs	r3, #0
 800ecba:	55d3      	strb	r3, [r2, r7]
        int nargs = parse_line(line, args, 16); // Parse line to 16 args
 800ecbc:	2210      	movs	r2, #16
 800ecbe:	eb0d 0102 	add.w	r1, sp, r2
 800ecc2:	f7fa ff0f 	bl	8009ae4 <parse_line>
        if (nargs < 2 || args[0][0] == '#' || args[0][0] == '!')
 800ecc6:	2801      	cmp	r0, #1
        int nargs = parse_line(line, args, 16); // Parse line to 16 args
 800ecc8:	4607      	mov	r7, r0
        if (nargs < 2 || args[0][0] == '#' || args[0][0] == '!')
 800ecca:	dd43      	ble.n	800ed54 <load_snp+0xec>
 800eccc:	9804      	ldr	r0, [sp, #16]
 800ecce:	7803      	ldrb	r3, [r0, #0]
 800ecd0:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
 800ecd4:	2b21      	cmp	r3, #33	@ 0x21
 800ecd6:	d03d      	beq.n	800ed54 <load_snp+0xec>
        freq = my_atoui(args[0]); // Get frequency
 800ecd8:	f7fa fe28 	bl	800992c <my_atoui>
        if (count >= SWEEP_POINTS_MAX || freq > FREQUENCY_MAX)
 800ecdc:	f5b4 7fc8 	cmp.w	r4, #400	@ 0x190
        freq = my_atoui(args[0]); // Get frequency
 800ece0:	4605      	mov	r5, r0
        if (count >= SWEEP_POINTS_MAX || freq > FREQUENCY_MAX)
 800ece2:	d802      	bhi.n	800ecea <load_snp+0x82>
 800ece4:	4b32      	ldr	r3, [pc, #200]	@ (800edb0 <load_snp+0x148>)
 800ece6:	4298      	cmp	r0, r3
 800ece8:	d901      	bls.n	800ecee <load_snp+0x86>
          return "Format err";
 800ecea:	4832      	ldr	r0, [pc, #200]	@ (800edb4 <load_snp+0x14c>)
 800ecec:	e056      	b.n	800ed9c <load_snp+0x134>
          start = freq; // For index 0 set as start
 800ecee:	2c00      	cmp	r4, #0
 800ecf0:	bf08      	it	eq
 800ecf2:	4682      	moveq	sl, r0
        measured[0][count][0] = my_atof(args[1]);
 800ecf4:	9805      	ldr	r0, [sp, #20]
 800ecf6:	f7fa fe3f 	bl	8009978 <my_atof>
 800ecfa:	eb08 03c4 	add.w	r3, r8, r4, lsl #3
        measured[0][count][1] = my_atof(args[2]); // get S11 data
 800ecfe:	9806      	ldr	r0, [sp, #24]
        measured[0][count][0] = my_atof(args[1]);
 800ed00:	ed83 0a00 	vstr	s0, [r3]
 800ed04:	9301      	str	r3, [sp, #4]
        measured[0][count][1] = my_atof(args[2]); // get S11 data
 800ed06:	f7fa fe37 	bl	8009978 <my_atof>
 800ed0a:	9b01      	ldr	r3, [sp, #4]
 800ed0c:	ed83 0a01 	vstr	s0, [r3, #4]
        if (format == FMT_S2P_FILE && nargs >= 4)
 800ed10:	9b00      	ldr	r3, [sp, #0]
 800ed12:	2b01      	cmp	r3, #1
 800ed14:	f204 1391 	addw	r3, r4, #401	@ 0x191
 800ed18:	d10e      	bne.n	800ed38 <load_snp+0xd0>
 800ed1a:	2f03      	cmp	r7, #3
 800ed1c:	dd0c      	ble.n	800ed38 <load_snp+0xd0>
          measured[1][count][0] = my_atof(args[3]);
 800ed1e:	9807      	ldr	r0, [sp, #28]
 800ed20:	9301      	str	r3, [sp, #4]
 800ed22:	f7fa fe29 	bl	8009978 <my_atof>
 800ed26:	9b01      	ldr	r3, [sp, #4]
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ed28:	9808      	ldr	r0, [sp, #32]
          measured[1][count][0] = my_atof(args[3]);
 800ed2a:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 800ed2e:	ed83 0a00 	vstr	s0, [r3]
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ed32:	f7fa fe21 	bl	8009978 <my_atof>
 800ed36:	e005      	b.n	800ed44 <load_snp+0xdc>
          measured[1][count][0] = 0.0f;
 800ed38:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 800ed3c:	ed83 8a00 	vstr	s16, [r3]
 800ed40:	eeb0 0a48 	vmov.f32	s0, s16
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ed44:	00e3      	lsls	r3, r4, #3
 800ed46:	4443      	add	r3, r8
 800ed48:	f603 438c 	addw	r3, r3, #3212	@ 0xc8c
        count++;
 800ed4c:	3401      	adds	r4, #1
          measured[1][count][1] = my_atof(args[4]); // get S11 data
 800ed4e:	ed83 0a00 	vstr	s0, [r3]
        count++;
 800ed52:	b2a4      	uxth	r4, r4
        j = 0;
 800ed54:	2700      	movs	r7, #0
 800ed56:	e007      	b.n	800ed68 <load_snp+0x100>
      else if (c < 0x20)
 800ed58:	2b1f      	cmp	r3, #31
 800ed5a:	d905      	bls.n	800ed68 <load_snp+0x100>
      else if (j < line_size)
 800ed5c:	2f7f      	cmp	r7, #127	@ 0x7f
 800ed5e:	d803      	bhi.n	800ed68 <load_snp+0x100>
        line[j++] = (char)c; // Store
 800ed60:	4912      	ldr	r1, [pc, #72]	@ (800edac <load_snp+0x144>)
 800ed62:	1c7a      	adds	r2, r7, #1
 800ed64:	55cb      	strb	r3, [r1, r7]
 800ed66:	b297      	uxth	r7, r2
    for (i = 0; i < size; i++)
 800ed68:	3601      	adds	r6, #1
 800ed6a:	e79b      	b.n	800eca4 <load_snp+0x3c>
  if (count != 0)
 800ed6c:	b90c      	cbnz	r4, 800ed72 <load_snp+0x10a>
  return NULL;
 800ed6e:	2000      	movs	r0, #0
 800ed70:	e014      	b.n	800ed9c <load_snp+0x134>
    pause_sweep();
 800ed72:	f7f7 f943 	bl	8005ffc <pause_sweep>
    current_props._electrical_delay[0] = 0.0f; // Reset delays
 800ed76:	4b10      	ldr	r3, [pc, #64]	@ (800edb8 <load_snp+0x150>)
 800ed78:	2200      	movs	r2, #0
    set_sweep_frequency(ST_START, start);
 800ed7a:	4651      	mov	r1, sl
 800ed7c:	2000      	movs	r0, #0
    current_props._electrical_delay[0] = 0.0f; // Reset delays
 800ed7e:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
    current_props._electrical_delay[1] = 0.0f; // Reset delays
 800ed82:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    current_props._sweep_points = count;
 800ed86:	835c      	strh	r4, [r3, #26]
    set_sweep_frequency(ST_START, start);
 800ed88:	f7f8 fea4 	bl	8007ad4 <set_sweep_frequency>
    set_sweep_frequency(ST_STOP, stop);
 800ed8c:	4629      	mov	r1, r5
 800ed8e:	2001      	movs	r0, #1
 800ed90:	f7f8 fea0 	bl	8007ad4 <set_sweep_frequency>
    request_to_redraw(REDRAW_PLOT);
 800ed94:	2001      	movs	r0, #1
 800ed96:	f7fd fce7 	bl	800c768 <request_to_redraw>
 800ed9a:	e7e8      	b.n	800ed6e <load_snp+0x106>
}
 800ed9c:	b015      	add	sp, #84	@ 0x54
 800ed9e:	ecbd 8b02 	vpop	{d8}
 800eda2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800eda6:	bf00      	nop
 800eda8:	00000000 	.word	0x00000000
 800edac:	20008b3c 	.word	0x20008b3c
 800edb0:	a0eebb00 	.word	0xa0eebb00
 800edb4:	08014a62 	.word	0x08014a62
 800edb8:	20000aa8 	.word	0x20000aa8
 800edbc:	20008a3c 	.word	0x20008a3c
 800edc0:	20004f54 	.word	0x20004f54

0800edc4 <save_snp>:
{
 800edc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800edc8:	b08a      	sub	sp, #40	@ 0x28
 800edca:	4607      	mov	r7, r0
    res = f_write(f, s1_file_header, sizeof(s1_file_header) - 1, &size);
 800edcc:	ab09      	add	r3, sp, #36	@ 0x24
 800edce:	222a      	movs	r2, #42	@ 0x2a
  if (format == FMT_S1P_FILE)
 800edd0:	b929      	cbnz	r1, 800edde <save_snp+0x1a>
    res = f_write(f, s1_file_header, sizeof(s1_file_header) - 1, &size);
 800edd2:	4923      	ldr	r1, [pc, #140]	@ (800ee60 <save_snp+0x9c>)
    s_file_format = s1_file_param;
 800edd4:	f8df 8098 	ldr.w	r8, [pc, #152]	@ 800ee70 <save_snp+0xac>
    res = f_write(f, s1_file_header, sizeof(s1_file_header) - 1, &size);
 800edd8:	f7f5 ffda 	bl	8004d90 <f_write>
 800eddc:	e004      	b.n	800ede8 <save_snp+0x24>
    res = f_write(f, s2_file_header, sizeof(s2_file_header) - 1, &size);
 800edde:	4921      	ldr	r1, [pc, #132]	@ (800ee64 <save_snp+0xa0>)
    s_file_format = s2_file_param;
 800ede0:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 800ee74 <save_snp+0xb0>
    res = f_write(f, s2_file_header, sizeof(s2_file_header) - 1, &size);
 800ede4:	f7f5 ffd4 	bl	8004d90 <f_write>
  for (int i = 0; i < sweep_points && res == FR_OK; i++)
 800ede8:	4c1f      	ldr	r4, [pc, #124]	@ (800ee68 <save_snp+0xa4>)
 800edea:	f8df 908c 	ldr.w	r9, [pc, #140]	@ 800ee78 <save_snp+0xb4>
 800edee:	f604 4688 	addw	r6, r4, #3208	@ 0xc88
 800edf2:	2500      	movs	r5, #0
 800edf4:	f8b9 301a 	ldrh.w	r3, [r9, #26]
 800edf8:	42ab      	cmp	r3, r5
 800edfa:	dd2d      	ble.n	800ee58 <save_snp+0x94>
 800edfc:	3408      	adds	r4, #8
 800edfe:	3608      	adds	r6, #8
 800ee00:	bb50      	cbnz	r0, 800ee58 <save_snp+0x94>
    size = plot_printf(buf_8, 128, s_file_format, getFrequency(i), measured[0][i][0], measured[0][i][1], measured[1][i][0], measured[1][i][1]);
 800ee02:	b2a8      	uxth	r0, r5
 800ee04:	f7f7 fefe 	bl	8006c04 <getFrequency>
 800ee08:	4682      	mov	sl, r0
 800ee0a:	f856 0c04 	ldr.w	r0, [r6, #-4]
 800ee0e:	f7f1 fbc7 	bl	80005a0 <__aeabi_f2d>
 800ee12:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800ee16:	f856 0c08 	ldr.w	r0, [r6, #-8]
 800ee1a:	f7f1 fbc1 	bl	80005a0 <__aeabi_f2d>
 800ee1e:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800ee22:	f854 0c04 	ldr.w	r0, [r4, #-4]
 800ee26:	f7f1 fbbb 	bl	80005a0 <__aeabi_f2d>
 800ee2a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800ee2e:	f854 0c08 	ldr.w	r0, [r4, #-8]
 800ee32:	f7f1 fbb5 	bl	80005a0 <__aeabi_f2d>
 800ee36:	4653      	mov	r3, sl
 800ee38:	e9cd 0100 	strd	r0, r1, [sp]
 800ee3c:	4642      	mov	r2, r8
 800ee3e:	2180      	movs	r1, #128	@ 0x80
 800ee40:	480a      	ldr	r0, [pc, #40]	@ (800ee6c <save_snp+0xa8>)
 800ee42:	f7f3 ff95 	bl	8002d70 <plot_printf>
    res = f_write(f, buf_8, size, &size);
 800ee46:	4909      	ldr	r1, [pc, #36]	@ (800ee6c <save_snp+0xa8>)
    size = plot_printf(buf_8, 128, s_file_format, getFrequency(i), measured[0][i][0], measured[0][i][1], measured[1][i][0], measured[1][i][1]);
 800ee48:	9009      	str	r0, [sp, #36]	@ 0x24
 800ee4a:	4602      	mov	r2, r0
    res = f_write(f, buf_8, size, &size);
 800ee4c:	ab09      	add	r3, sp, #36	@ 0x24
 800ee4e:	4638      	mov	r0, r7
 800ee50:	f7f5 ff9e 	bl	8004d90 <f_write>
  for (int i = 0; i < sweep_points && res == FR_OK; i++)
 800ee54:	3501      	adds	r5, #1
 800ee56:	e7cd      	b.n	800edf4 <save_snp+0x30>
}
 800ee58:	b00a      	add	sp, #40	@ 0x28
 800ee5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ee5e:	bf00      	nop
 800ee60:	08016d4c 	.word	0x08016d4c
 800ee64:	08016d10 	.word	0x08016d10
 800ee68:	20004f54 	.word	0x20004f54
 800ee6c:	20008a3c 	.word	0x20008a3c
 800ee70:	08016d3c 	.word	0x08016d3c
 800ee74:	08016cf0 	.word	0x08016cf0
 800ee78:	20000aa8 	.word	0x20000aa8

0800ee7c <sd_findnext>:
static FRESULT sd_findnext(DIR* dp, FILINFO* fno) {
 800ee7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ee80:	4605      	mov	r5, r0
 800ee82:	460c      	mov	r4, r1
 800ee84:	f101 0719 	add.w	r7, r1, #25
    if (compare_ext(fno->fname, dp->pat)) return FR_OK;
 800ee88:	f101 061a 	add.w	r6, r1, #26
  while (f_readdir(dp, fno) == FR_OK && fno->fname[0]) {
 800ee8c:	4621      	mov	r1, r4
 800ee8e:	4628      	mov	r0, r5
 800ee90:	f7f6 f964 	bl	800515c <f_readdir>
 800ee94:	b9d8      	cbnz	r0, 800eece <sd_findnext+0x52>
 800ee96:	7ea3      	ldrb	r3, [r4, #26]
 800ee98:	b1cb      	cbz	r3, 800eece <sd_findnext+0x52>
    if (fno->fattrib & AM_DIR) continue;
 800ee9a:	7b23      	ldrb	r3, [r4, #12]
 800ee9c:	f013 0310 	ands.w	r3, r3, #16
 800eea0:	d1f4      	bne.n	800ee8c <sd_findnext+0x10>
  while (name[i]) if (name[i++] == '.') j = i;    // Get last '.' position + 1
 800eea2:	463a      	mov	r2, r7
 800eea4:	f892 8001 	ldrb.w	r8, [r2, #1]
 800eea8:	1c51      	adds	r1, r2, #1
 800eeaa:	f1b8 0f00 	cmp.w	r8, #0
 800eeae:	d006      	beq.n	800eebe <sd_findnext+0x42>
 800eeb0:	f1b8 0f2e 	cmp.w	r8, #46	@ 0x2e
 800eeb4:	bf04      	itt	eq
 800eeb6:	3a18      	subeq	r2, #24
 800eeb8:	1b13      	subeq	r3, r2, r4
static FRESULT sd_findnext(DIR* dp, FILINFO* fno) {
 800eeba:	460a      	mov	r2, r1
 800eebc:	e7f2      	b.n	800eea4 <sd_findnext+0x28>
  return j == 0 ? false : strcmpi(&name[j], ext); // Compare text after '.' and ext
 800eebe:	2b00      	cmp	r3, #0
 800eec0:	d0e4      	beq.n	800ee8c <sd_findnext+0x10>
 800eec2:	6d29      	ldr	r1, [r5, #80]	@ 0x50
 800eec4:	18f0      	adds	r0, r6, r3
 800eec6:	f7fa fdd1 	bl	8009a6c <strcmpi>
 800eeca:	b910      	cbnz	r0, 800eed2 <sd_findnext+0x56>
 800eecc:	e7de      	b.n	800ee8c <sd_findnext+0x10>
  return FR_NO_FILE;
 800eece:	f04f 0804 	mov.w	r8, #4
}
 800eed2:	4640      	mov	r0, r8
 800eed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800eed8 <input_date_time>:
  if (b)
 800eed8:	2900      	cmp	r1, #0
 800eeda:	d17d      	bne.n	800efd8 <input_date_time+0x100>
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 800eedc:	4a3f      	ldr	r2, [pc, #252]	@ (800efdc <input_date_time+0x104>)
{
 800eede:	b4f3      	push	{r0, r1, r4, r5, r6, r7}
  dt_buf[0] = rtc_get_tr_bcd(); // TR should be read first for sync
 800eee0:	6813      	ldr	r3, [r2, #0]
 800eee2:	4c3f      	ldr	r4, [pc, #252]	@ (800efe0 <input_date_time+0x108>)
 800eee4:	f003 337f 	and.w	r3, r3, #2139062143	@ 0x7f7f7f7f
 800eee8:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 800eeec:	9300      	str	r3, [sp, #0]
  dt_buf[1] = rtc_get_dr_bcd(); // DR should be read second
 800eeee:	6852      	ldr	r2, [r2, #4]
 800eef0:	4b3c      	ldr	r3, [pc, #240]	@ (800efe4 <input_date_time+0x10c>)
 800eef2:	4013      	ands	r3, r2
 800eef4:	9301      	str	r3, [sp, #4]
  for (; i < 6 && kp_buf[i] != 0; i++)
 800eef6:	4622      	mov	r2, r4
 800eef8:	f814 3b01 	ldrb.w	r3, [r4], #1
 800eefc:	b133      	cbz	r3, 800ef0c <input_date_time+0x34>
 800eefe:	3101      	adds	r1, #1
    kp_buf[i] -= '0';
 800ef00:	3b30      	subs	r3, #48	@ 0x30
  for (; i < 6 && kp_buf[i] != 0; i++)
 800ef02:	2906      	cmp	r1, #6
    kp_buf[i] -= '0';
 800ef04:	f804 3c01 	strb.w	r3, [r4, #-1]
  for (; i < 6 && kp_buf[i] != 0; i++)
 800ef08:	d1f6      	bne.n	800eef8 <input_date_time+0x20>
 800ef0a:	e004      	b.n	800ef16 <input_date_time+0x3e>
  for (; i < 6; i++)
 800ef0c:	2906      	cmp	r1, #6
 800ef0e:	d002      	beq.n	800ef16 <input_date_time+0x3e>
    kp_buf[i] = 0;
 800ef10:	5453      	strb	r3, [r2, r1]
  for (; i < 6; i++)
 800ef12:	3101      	adds	r1, #1
 800ef14:	e7fa      	b.n	800ef0c <input_date_time+0x34>
    kp_buf[i] = (kp_buf[2 * i] << 4) | kp_buf[2 * i + 1]; // BCD format
 800ef16:	7813      	ldrb	r3, [r2, #0]
 800ef18:	7854      	ldrb	r4, [r2, #1]
 800ef1a:	7891      	ldrb	r1, [r2, #2]
 800ef1c:	7915      	ldrb	r5, [r2, #4]
 800ef1e:	ea44 1403 	orr.w	r4, r4, r3, lsl #4
 800ef22:	78d3      	ldrb	r3, [r2, #3]
 800ef24:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800ef28:	7951      	ldrb	r1, [r2, #5]
 800ef2a:	ea41 1105 	orr.w	r1, r1, r5, lsl #4
 800ef2e:	b2e4      	uxtb	r4, r4
 800ef30:	b2db      	uxtb	r3, r3
 800ef32:	b2c9      	uxtb	r1, r1
  if (data == KM_RTC_DATE)
 800ef34:	2818      	cmp	r0, #24
    kp_buf[i] = (kp_buf[2 * i] << 4) | kp_buf[2 * i + 1]; // BCD format
 800ef36:	7014      	strb	r4, [r2, #0]
 800ef38:	7053      	strb	r3, [r2, #1]
 800ef3a:	7091      	strb	r1, [r2, #2]
  if (data == KM_RTC_DATE)
 800ef3c:	d134      	bne.n	800efa8 <input_date_time+0xd0>
    if (kp_buf[1] < 1)
 800ef3e:	b90b      	cbnz	r3, 800ef44 <input_date_time+0x6c>
      kp_buf[1] = 1;
 800ef40:	2301      	movs	r3, #1
 800ef42:	e002      	b.n	800ef4a <input_date_time+0x72>
    else if (kp_buf[1] > 0x12)
 800ef44:	2b12      	cmp	r3, #18
 800ef46:	d901      	bls.n	800ef4c <input_date_time+0x74>
      kp_buf[1] = 0x12;
 800ef48:	2312      	movs	r3, #18
 800ef4a:	7053      	strb	r3, [r2, #1]
    uint8_t day_max = 28 + ((0b11101100000000000010111110111011001100 >> (kp_buf[1] << 1)) & 3);
 800ef4c:	7855      	ldrb	r5, [r2, #1]
    if (kp_buf[2] < 1)
 800ef4e:	b911      	cbnz	r1, 800ef56 <input_date_time+0x7e>
      kp_buf[2] = 1;
 800ef50:	2101      	movs	r1, #1
 800ef52:	7091      	strb	r1, [r2, #2]
 800ef54:	e021      	b.n	800ef9a <input_date_time+0xc2>
    uint8_t day_max = 28 + ((0b11101100000000000010111110111011001100 >> (kp_buf[1] << 1)) & 3);
 800ef56:	0068      	lsls	r0, r5, #1
 800ef58:	4b23      	ldr	r3, [pc, #140]	@ (800efe8 <input_date_time+0x110>)
 800ef5a:	f04f 0c3b 	mov.w	ip, #59	@ 0x3b
 800ef5e:	f1c0 0720 	rsb	r7, r0, #32
 800ef62:	f1b0 0620 	subs.w	r6, r0, #32
 800ef66:	fa23 f300 	lsr.w	r3, r3, r0
 800ef6a:	fa0c f707 	lsl.w	r7, ip, r7
 800ef6e:	ea43 0307 	orr.w	r3, r3, r7
 800ef72:	bf5c      	itt	pl
 800ef74:	fa4c f606 	asrpl.w	r6, ip, r6
 800ef78:	4333      	orrpl	r3, r6
 800ef7a:	f003 0303 	and.w	r3, r3, #3
 800ef7e:	331c      	adds	r3, #28
    day_max = ((day_max / 10) << 4) | (day_max % 10); // to BCD
 800ef80:	270a      	movs	r7, #10
 800ef82:	fbb3 f6f7 	udiv	r6, r3, r7
 800ef86:	0130      	lsls	r0, r6, #4
 800ef88:	fb07 3316 	mls	r3, r7, r6, r3
 800ef8c:	b2c0      	uxtb	r0, r0
 800ef8e:	b2db      	uxtb	r3, r3
 800ef90:	4303      	orrs	r3, r0
    else if (kp_buf[2] > day_max)
 800ef92:	428b      	cmp	r3, r1
      kp_buf[2] = day_max;
 800ef94:	bf3c      	itt	cc
 800ef96:	7093      	strbcc	r3, [r2, #2]
 800ef98:	4619      	movcc	r1, r3
    time[6] = kp_buf[0]; // year
 800ef9a:	f88d 4006 	strb.w	r4, [sp, #6]
    time[5] = kp_buf[1]; // month
 800ef9e:	f88d 5005 	strb.w	r5, [sp, #5]
    time[4] = kp_buf[2]; // day
 800efa2:	f88d 1004 	strb.w	r1, [sp, #4]
 800efa6:	e011      	b.n	800efcc <input_date_time+0xf4>
    if (kp_buf[0] > 0x23)
 800efa8:	2c23      	cmp	r4, #35	@ 0x23
 800efaa:	bf28      	it	cs
 800efac:	2423      	movcs	r4, #35	@ 0x23
    if (kp_buf[1] > 0x59)
 800efae:	2b59      	cmp	r3, #89	@ 0x59
 800efb0:	bf28      	it	cs
 800efb2:	2359      	movcs	r3, #89	@ 0x59
    if (kp_buf[2] > 0x59)
 800efb4:	2959      	cmp	r1, #89	@ 0x59
 800efb6:	bf28      	it	cs
 800efb8:	2159      	movcs	r1, #89	@ 0x59
 800efba:	7014      	strb	r4, [r2, #0]
    if (kp_buf[1] > 0x59)
 800efbc:	7053      	strb	r3, [r2, #1]
    if (kp_buf[2] > 0x59)
 800efbe:	7091      	strb	r1, [r2, #2]
    time[2] = kp_buf[0]; // hour
 800efc0:	f88d 4002 	strb.w	r4, [sp, #2]
    time[1] = kp_buf[1]; // min
 800efc4:	f88d 3001 	strb.w	r3, [sp, #1]
    time[0] = kp_buf[2]; // sec
 800efc8:	f88d 1000 	strb.w	r1, [sp]
  rtc_set_time(dt_buf[1], dt_buf[0]);
 800efcc:	e9dd 1000 	ldrd	r1, r0, [sp]
}
 800efd0:	b002      	add	sp, #8
 800efd2:	bcf0      	pop	{r4, r5, r6, r7}
  rtc_set_time(dt_buf[1], dt_buf[0]);
 800efd4:	f002 be6e 	b.w	8011cb4 <rtc_set_time>
 800efd8:	4770      	bx	lr
 800efda:	bf00      	nop
 800efdc:	40002800 	.word	0x40002800
 800efe0:	20008a10 	.word	0x20008a10
 800efe4:	00ff1f3f 	.word	0x00ff1f3f
 800efe8:	000beecc 	.word	0x000beecc

0800efec <touch_start_watchdog>:
{
 800efec:	b510      	push	{r4, lr}
  if (touch_status_flag & TOUCH_INTERRUPT_ENABLED)
 800efee:	4a06      	ldr	r2, [pc, #24]	@ (800f008 <touch_start_watchdog+0x1c>)
 800eff0:	7813      	ldrb	r3, [r2, #0]
 800eff2:	f013 0401 	ands.w	r4, r3, #1
 800eff6:	d106      	bne.n	800f006 <touch_start_watchdog+0x1a>
  touch_status_flag ^= TOUCH_INTERRUPT_ENABLED;
 800eff8:	f083 0301 	eor.w	r3, r3, #1
 800effc:	7013      	strb	r3, [r2, #0]
  adc_start_analog_watchdog();
 800effe:	f002 fd8f 	bl	8011b20 <adc_start_analog_watchdog>
  touch_remote = REMOTE_NONE;
 800f002:	4b02      	ldr	r3, [pc, #8]	@ (800f00c <touch_start_watchdog+0x20>)
 800f004:	701c      	strb	r4, [r3, #0]
}
 800f006:	bd10      	pop	{r4, pc}
 800f008:	20008a29 	.word	0x20008a29
 800f00c:	20008a04 	.word	0x20008a04

0800f010 <keypad_click>:
  int c = keypads->buttons[key].c; // !!! Use key + 1 (zero key index used or size define)
 800f010:	4b81      	ldr	r3, [pc, #516]	@ (800f218 <keypad_click+0x208>)
{
 800f012:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  int c = keypads->buttons[key].c; // !!! Use key + 1 (zero key index used or size define)
 800f016:	681f      	ldr	r7, [r3, #0]
  int index = strlen(kp_buf);
 800f018:	4e80      	ldr	r6, [pc, #512]	@ (800f21c <keypad_click+0x20c>)
  int c = keypads->buttons[key].c; // !!! Use key + 1 (zero key index used or size define)
 800f01a:	eb07 0040 	add.w	r0, r7, r0, lsl #1
 800f01e:	78c4      	ldrb	r4, [r0, #3]
  int index = strlen(kp_buf);
 800f020:	4630      	mov	r0, r6
 800f022:	f7f1 fc8d 	bl	8000940 <strlen>
  int result = keypads->type == NUM_KEYBOARD ? num_keypad_click(c, index) : txt_keypad_click(c, index);
 800f026:	787a      	ldrb	r2, [r7, #1]
 800f028:	2a00      	cmp	r2, #0
 800f02a:	f040 80c4 	bne.w	800f1b6 <keypad_click+0x1a6>
  if (c >= KP_k && c <= KP_PERCENT)
 800f02e:	f1a4 030d 	sub.w	r3, r4, #13
 800f032:	2b09      	cmp	r3, #9
 800f034:	4605      	mov	r5, r0
 800f036:	d832      	bhi.n	800f09e <keypad_click+0x8e>
    if (kp_index == 0)
 800f038:	2800      	cmp	r0, #0
 800f03a:	f000 80e7 	beq.w	800f20c <keypad_click+0x1fc>
    if (c >= KP_k && c <= KP_G)
 800f03e:	2b02      	cmp	r3, #2
 800f040:	d81c      	bhi.n	800f07c <keypad_click+0x6c>
      int i = period_pos();
 800f042:	f7ff f947 	bl	800e2d4 <period_pos>
      uint16_t scale = c - KP_k + 1;
 800f046:	3c0c      	subs	r4, #12
 800f048:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800f04c:	b2a4      	uxth	r4, r4
      if (scale + i > NUMINPUT_LEN)
 800f04e:	1823      	adds	r3, r4, r0
 800f050:	2b0c      	cmp	r3, #12
        scale = NUMINPUT_LEN - i;
 800f052:	bfc4      	itt	gt
 800f054:	f1c0 040c 	rsbgt	r4, r0, #12
 800f058:	b2a4      	uxthgt	r4, r4
 800f05a:	4430      	add	r0, r6
          kp_buf[i + 2] = 0;
 800f05c:	2100      	movs	r1, #0
        char v = kp_buf[i + 1];
 800f05e:	7843      	ldrb	r3, [r0, #1]
        if (v == 0 || kp_buf[i] == 0)
 800f060:	7802      	ldrb	r2, [r0, #0]
 800f062:	b103      	cbz	r3, 800f066 <keypad_click+0x56>
 800f064:	b90a      	cbnz	r2, 800f06a <keypad_click+0x5a>
          kp_buf[i + 2] = 0;
 800f066:	7081      	strb	r1, [r0, #2]
          v = '0';
 800f068:	2330      	movs	r3, #48	@ 0x30
        kp_buf[i + 1] = kp_buf[i];
 800f06a:	f800 2f01 	strb.w	r2, [r0, #1]!
      } while (--scale);
 800f06e:	3c01      	subs	r4, #1
 800f070:	b2a4      	uxth	r4, r4
        kp_buf[i++] = v;
 800f072:	f800 3c01 	strb.w	r3, [r0, #-1]
      } while (--scale);
 800f076:	2c00      	cmp	r4, #0
 800f078:	d1f1      	bne.n	800f05e <keypad_click+0x4e>
 800f07a:	e0c2      	b.n	800f202 <keypad_click+0x1f2>
    else if (c >= KP_m && c <= KP_p)
 800f07c:	f1a4 0310 	sub.w	r3, r4, #16
 800f080:	2b03      	cmp	r3, #3
 800f082:	f200 80be 	bhi.w	800f202 <keypad_click+0x1f2>
      const char prefix[] = {'m', 'u', 'n', 'p'};
 800f086:	4b66      	ldr	r3, [pc, #408]	@ (800f220 <keypad_click+0x210>)
 800f088:	9301      	str	r3, [sp, #4]
      kp_buf[kp_index] = prefix[c - KP_m];
 800f08a:	f104 0308 	add.w	r3, r4, #8
 800f08e:	eb0d 0403 	add.w	r4, sp, r3
      kp_buf[kp_index + 1] = 0;
 800f092:	4435      	add	r5, r6
      kp_buf[kp_index] = prefix[c - KP_m];
 800f094:	f814 3c14 	ldrb.w	r3, [r4, #-20]
 800f098:	5433      	strb	r3, [r6, r0]
      kp_buf[kp_index + 1] = 0;
 800f09a:	706a      	strb	r2, [r5, #1]
  if (result == K_DONE)
 800f09c:	e0b1      	b.n	800f202 <keypad_click+0x1f2>
  int maxlength = (1 << keypad_mode) & ((1 << KM_RTC_DATE) | (1 << KM_RTC_TIME)) ? 6 : NUMINPUT_LEN;
 800f09e:	4b61      	ldr	r3, [pc, #388]	@ (800f224 <keypad_click+0x214>)
 800f0a0:	781a      	ldrb	r2, [r3, #0]
 800f0a2:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
 800f0a6:	4113      	asrs	r3, r2
 800f0a8:	f013 0701 	ands.w	r7, r3, #1
 800f0ac:	bf0c      	ite	eq
 800f0ae:	f04f 080c 	moveq.w	r8, #12
 800f0b2:	f04f 0806 	movne.w	r8, #6
  if (c == KP_BS)
 800f0b6:	2c0c      	cmp	r4, #12
 800f0b8:	d101      	bne.n	800f0be <keypad_click+0xae>
    if (kp_index == 0)
 800f0ba:	b958      	cbnz	r0, 800f0d4 <keypad_click+0xc4>
 800f0bc:	e0a6      	b.n	800f20c <keypad_click+0x1fc>
  else if (c == KP_MINUS)
 800f0be:	2c0b      	cmp	r4, #11
 800f0c0:	d113      	bne.n	800f0ea <keypad_click+0xda>
    if (kp_buf[0] == '-')
 800f0c2:	7833      	ldrb	r3, [r6, #0]
 800f0c4:	2b2d      	cmp	r3, #45	@ 0x2d
        kp_buf[i] = kp_buf[i + 1];
 800f0c6:	f04f 020c 	mov.w	r2, #12
    if (kp_buf[0] == '-')
 800f0ca:	d105      	bne.n	800f0d8 <keypad_click+0xc8>
        kp_buf[i] = kp_buf[i + 1];
 800f0cc:	1c71      	adds	r1, r6, #1
 800f0ce:	4630      	mov	r0, r6
 800f0d0:	f003 fb6e 	bl	80127b0 <memmove>
      --kp_index;
 800f0d4:	3d01      	subs	r5, #1
 800f0d6:	e01b      	b.n	800f110 <keypad_click+0x100>
        kp_buf[i] = kp_buf[i - 1];
 800f0d8:	4631      	mov	r1, r6
 800f0da:	1c70      	adds	r0, r6, #1
 800f0dc:	f003 fb68 	bl	80127b0 <memmove>
      kp_buf[0] = '-';
 800f0e0:	232d      	movs	r3, #45	@ 0x2d
      if (kp_index < maxlength)
 800f0e2:	4545      	cmp	r5, r8
      kp_buf[0] = '-';
 800f0e4:	7033      	strb	r3, [r6, #0]
      if (kp_index < maxlength)
 800f0e6:	da13      	bge.n	800f110 <keypad_click+0x100>
 800f0e8:	e011      	b.n	800f10e <keypad_click+0xfe>
  else if (kp_index < maxlength)
 800f0ea:	4540      	cmp	r0, r8
 800f0ec:	da10      	bge.n	800f110 <keypad_click+0x100>
    if (c <= KP_9)
 800f0ee:	2c09      	cmp	r4, #9
 800f0f0:	dc02      	bgt.n	800f0f8 <keypad_click+0xe8>
      kp_buf[kp_index++] = '0' + c;
 800f0f2:	3430      	adds	r4, #48	@ 0x30
 800f0f4:	5434      	strb	r4, [r6, r0]
 800f0f6:	e00a      	b.n	800f10e <keypad_click+0xfe>
    else if (c == KP_PERIOD && kp_index == period_pos() && maxlength == NUMINPUT_LEN) // append period if there are no period and for num input (skip for date/time)
 800f0f8:	2c0a      	cmp	r4, #10
 800f0fa:	d109      	bne.n	800f110 <keypad_click+0x100>
 800f0fc:	f7ff f8ea 	bl	800e2d4 <period_pos>
 800f100:	4285      	cmp	r5, r0
 800f102:	d105      	bne.n	800f110 <keypad_click+0x100>
 800f104:	f1b8 0f0c 	cmp.w	r8, #12
 800f108:	d102      	bne.n	800f110 <keypad_click+0x100>
      kp_buf[kp_index++] = '.';
 800f10a:	232e      	movs	r3, #46	@ 0x2e
 800f10c:	5573      	strb	r3, [r6, r5]
 800f10e:	3501      	adds	r5, #1
  kp_buf[kp_index] = '\0';
 800f110:	2300      	movs	r3, #0
 800f112:	5573      	strb	r3, [r6, r5]
  if ((1 << keypad_mode) & ((1 << KM_RTC_DATE) | (1 << KM_RTC_TIME)))
 800f114:	b987      	cbnz	r7, 800f138 <keypad_click+0x128>
    xsim = (0b00100100100100100 >> (2 - (period_pos() % 3))) & (~1);
 800f116:	f7ff f8dd 	bl	800e2d4 <period_pos>
 800f11a:	2303      	movs	r3, #3
 800f11c:	fbb0 f3f3 	udiv	r3, r0, r3
 800f120:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800f124:	1ac0      	subs	r0, r0, r3
 800f126:	f1c0 0002 	rsb	r0, r0, #2
 800f12a:	f644 1424 	movw	r4, #18724	@ 0x4924
 800f12e:	4104      	asrs	r4, r0
 800f130:	f024 0401 	bic.w	r4, r4, #1
 800f134:	b2a4      	uxth	r4, r4
 800f136:	e000      	b.n	800f13a <keypad_click+0x12a>
    xsim = 0b01010100;
 800f138:	2454      	movs	r4, #84	@ 0x54
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800f13a:	2114      	movs	r1, #20
 800f13c:	2013      	movs	r0, #19
 800f13e:	f001 ffbb 	bl	80110b8 <lcd_set_colors>
  while (*buf)
 800f142:	4e36      	ldr	r6, [pc, #216]	@ (800f21c <keypad_click+0x20c>)
  uint16_t x = 14 + FONT_STR_WIDTH(12), space;
 800f144:	f04f 0862 	mov.w	r8, #98	@ 0x62
  while (*buf)
 800f148:	f816 7b01 	ldrb.w	r7, [r6], #1
 800f14c:	b34f      	cbz	r7, 800f1a2 <keypad_click+0x192>
    if (c == '.')
 800f14e:	2f2e      	cmp	r7, #46	@ 0x2e
 800f150:	d103      	bne.n	800f15a <keypad_click+0x14a>
      xsim <<= 4;
 800f152:	0124      	lsls	r4, r4, #4
 800f154:	b2a4      	uxth	r4, r4
      c = KP_PERIOD;
 800f156:	270a      	movs	r7, #10
 800f158:	e009      	b.n	800f16e <keypad_click+0x15e>
    else if (c == '-')
 800f15a:	2f2d      	cmp	r7, #45	@ 0x2d
 800f15c:	d104      	bne.n	800f168 <keypad_click+0x158>
      xsim &= ~3;
 800f15e:	f024 0403 	bic.w	r4, r4, #3
 800f162:	b2a4      	uxth	r4, r4
      c = KP_MINUS;
 800f164:	270b      	movs	r7, #11
 800f166:	e002      	b.n	800f16e <keypad_click+0x15e>
    else if (c >= '0' && c <= '9')
 800f168:	3f30      	subs	r7, #48	@ 0x30
 800f16a:	2f09      	cmp	r7, #9
 800f16c:	d8ec      	bhi.n	800f148 <keypad_click+0x138>
    space = 2 + 10 * (xsim & 1);
 800f16e:	f004 0501 	and.w	r5, r4, #1
 800f172:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 800f176:	006d      	lsls	r5, r5, #1
 800f178:	3502      	adds	r5, #2
    lcd_fill(x, y, space, NUM_FONT_GET_HEIGHT);
 800f17a:	462a      	mov	r2, r5
    x += space;
 800f17c:	4445      	add	r5, r8
    lcd_fill(x, y, space, NUM_FONT_GET_HEIGHT);
 800f17e:	4640      	mov	r0, r8
 800f180:	2316      	movs	r3, #22
 800f182:	f240 1125 	movw	r1, #293	@ 0x125
    x += space;
 800f186:	b2ad      	uxth	r5, r5
    lcd_fill(x, y, space, NUM_FONT_GET_HEIGHT);
 800f188:	f001 fe90 	bl	8010eac <lcd_fill>
    lcd_drawfont(c, x, y);
 800f18c:	4629      	mov	r1, r5
 800f18e:	f240 1225 	movw	r2, #293	@ 0x125
 800f192:	b2f8      	uxtb	r0, r7
    x += NUM_FONT_GET_WIDTH;
 800f194:	3510      	adds	r5, #16
    lcd_drawfont(c, x, y);
 800f196:	f002 f925 	bl	80113e4 <lcd_drawfont>
    xsim >>= 1;
 800f19a:	0864      	lsrs	r4, r4, #1
    x += NUM_FONT_GET_WIDTH;
 800f19c:	fa1f f885 	uxth.w	r8, r5
 800f1a0:	e7d2      	b.n	800f148 <keypad_click+0x138>
  lcd_fill(x, y, NUM_FONT_GET_WIDTH + 2 + 10, NUM_FONT_GET_HEIGHT);
 800f1a2:	2316      	movs	r3, #22
 800f1a4:	221c      	movs	r2, #28
 800f1a6:	f240 1125 	movw	r1, #293	@ 0x125
 800f1aa:	4640      	mov	r0, r8
}
 800f1ac:	b002      	add	sp, #8
 800f1ae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  lcd_fill(x, y, NUM_FONT_GET_WIDTH + 2 + 10, NUM_FONT_GET_HEIGHT);
 800f1b2:	f001 be7b 	b.w	8010eac <lcd_fill>
  if (c == S_ENTER[0])
 800f1b6:	2c16      	cmp	r4, #22
 800f1b8:	d101      	bne.n	800f1be <keypad_click+0x1ae>
    return kp_index == 0 ? K_CANCEL : K_DONE;
 800f1ba:	b338      	cbz	r0, 800f20c <keypad_click+0x1fc>
 800f1bc:	e021      	b.n	800f202 <keypad_click+0x1f2>
  if (c == S_LARROW[0])
 800f1be:	2c1a      	cmp	r4, #26
 800f1c0:	d102      	bne.n	800f1c8 <keypad_click+0x1b8>
    if (kp_index == 0)
 800f1c2:	b318      	cbz	r0, 800f20c <keypad_click+0x1fc>
    --kp_index;
 800f1c4:	1e42      	subs	r2, r0, #1
 800f1c6:	e004      	b.n	800f1d2 <keypad_click+0x1c2>
  else if (kp_index < TXTINPUT_LEN)
 800f1c8:	2812      	cmp	r0, #18
    kp_buf[kp_index++] = c;
 800f1ca:	bf1a      	itte	ne
 800f1cc:	5434      	strbne	r4, [r6, r0]
 800f1ce:	1c42      	addne	r2, r0, #1
 800f1d0:	4602      	moveq	r2, r0
  kp_buf[kp_index] = '\0';
 800f1d2:	2300      	movs	r3, #0
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800f1d4:	2114      	movs	r1, #20
 800f1d6:	2013      	movs	r0, #19
  kp_buf[kp_index] = '\0';
 800f1d8:	54b3      	strb	r3, [r6, r2]
  lcd_set_colors(LCD_INPUT_TEXT_COLOR, LCD_INPUT_BG_COLOR);
 800f1da:	f001 ff6d 	bl	80110b8 <lcd_set_colors>
  lcd_fill(x, y, FONT_STR_WIDTH(20) * n, FONT_GET_HEIGHT * n);
 800f1de:	2316      	movs	r3, #22
 800f1e0:	f44f 728c 	mov.w	r2, #280	@ 0x118
 800f1e4:	f240 1125 	movw	r1, #293	@ 0x125
 800f1e8:	2031      	movs	r0, #49	@ 0x31
 800f1ea:	f001 fe5f 	bl	8010eac <lcd_fill>
  lcd_drawstring_size(buf, x, y, n);
 800f1ee:	480b      	ldr	r0, [pc, #44]	@ (800f21c <keypad_click+0x20c>)
 800f1f0:	2302      	movs	r3, #2
 800f1f2:	f240 1225 	movw	r2, #293	@ 0x125
 800f1f6:	2131      	movs	r1, #49	@ 0x31
}
 800f1f8:	b002      	add	sp, #8
 800f1fa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  lcd_drawstring_size(buf, x, y, n);
 800f1fe:	f002 b909 	b.w	8011414 <lcd_drawstring_size>
    ui_keyboard_cb(keypad_mode, NULL); // apply input done
 800f202:	4b08      	ldr	r3, [pc, #32]	@ (800f224 <keypad_click+0x214>)
 800f204:	2100      	movs	r1, #0
 800f206:	7818      	ldrb	r0, [r3, #0]
 800f208:	f7ff f858 	bl	800e2bc <ui_keyboard_cb>
}
 800f20c:	b002      	add	sp, #8
 800f20e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ui_mode_normal();
 800f212:	f7ff ba8b 	b.w	800e72c <ui_mode_normal>
 800f216:	bf00      	nop
 800f218:	20008a08 	.word	0x20008a08
 800f21c:	20008a10 	.word	0x20008a10
 800f220:	706e756d 	.word	0x706e756d
 800f224:	20008a07 	.word	0x20008a07

0800f228 <ui_keypad_touch>:
{
 800f228:	b570      	push	{r4, r5, r6, lr}
  const keypad_pos_t *p = &key_pos[keypads->type];
 800f22a:	4b21      	ldr	r3, [pc, #132]	@ (800f2b0 <ui_keypad_touch+0x88>)
  if (touch_x < p->x_offs || touch_y < p->y_offs)
 800f22c:	4a21      	ldr	r2, [pc, #132]	@ (800f2b4 <ui_keypad_touch+0x8c>)
  const keypad_pos_t *p = &key_pos[keypads->type];
 800f22e:	681d      	ldr	r5, [r3, #0]
 800f230:	786b      	ldrb	r3, [r5, #1]
  if (touch_x < p->x_offs || touch_y < p->y_offs)
 800f232:	f832 4033 	ldrh.w	r4, [r2, r3, lsl #3]
 800f236:	4284      	cmp	r4, r0
 800f238:	dc38      	bgt.n	800f2ac <ui_keypad_touch+0x84>
 800f23a:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800f23e:	8853      	ldrh	r3, [r2, #2]
 800f240:	428b      	cmp	r3, r1
 800f242:	dc33      	bgt.n	800f2ac <ui_keypad_touch+0x84>
  touch_x -= p->x_offs;
 800f244:	1b00      	subs	r0, r0, r4
  touch_y -= p->y_offs;
 800f246:	1acb      	subs	r3, r1, r3
  touch_y /= p->height;
 800f248:	88d1      	ldrh	r1, [r2, #6]
  touch_x /= p->width;
 800f24a:	8892      	ldrh	r2, [r2, #4]
 800f24c:	fbb0 f0f2 	udiv	r0, r0, r2
  for (int i = 0; i < keypads->size; i++)
 800f250:	462a      	mov	r2, r5
  touch_y /= p->height;
 800f252:	fbb3 f3f1 	udiv	r3, r3, r1
  uint8_t pos = (touch_y & 0x0F) | (touch_x << 4);
 800f256:	f003 030f 	and.w	r3, r3, #15
 800f25a:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
  for (int i = 0; i < keypads->size; i++)
 800f25e:	f812 1b02 	ldrb.w	r1, [r2], #2
  uint8_t pos = (touch_y & 0x0F) | (touch_x << 4);
 800f262:	b2db      	uxtb	r3, r3
  for (int i = 0; i < keypads->size; i++)
 800f264:	2400      	movs	r4, #0
 800f266:	42a1      	cmp	r1, r4
 800f268:	dd20      	ble.n	800f2ac <ui_keypad_touch+0x84>
    if (keypads->buttons[i].pos != pos)
 800f26a:	f812 0014 	ldrb.w	r0, [r2, r4, lsl #1]
 800f26e:	4298      	cmp	r0, r3
 800f270:	d001      	beq.n	800f276 <ui_keypad_touch+0x4e>
  for (int i = 0; i < keypads->size; i++)
 800f272:	3401      	adds	r4, #1
 800f274:	e7f7      	b.n	800f266 <ui_keypad_touch+0x3e>
    if (keypads->buttons[i].c == KP_EMPTY)
 800f276:	eb05 0544 	add.w	r5, r5, r4, lsl #1
 800f27a:	78eb      	ldrb	r3, [r5, #3]
 800f27c:	2bff      	cmp	r3, #255	@ 0xff
 800f27e:	d015      	beq.n	800f2ac <ui_keypad_touch+0x84>
    int old = selection;
 800f280:	4d0d      	ldr	r5, [pc, #52]	@ (800f2b8 <ui_keypad_touch+0x90>)
 800f282:	f995 6000 	ldrsb.w	r6, [r5]
    keypad_draw_button(selection = i); // draw new focus
 800f286:	b260      	sxtb	r0, r4
 800f288:	7028      	strb	r0, [r5, #0]
 800f28a:	f7ff fa6b 	bl	800e764 <keypad_draw_button>
    keypad_draw_button(old);           // Erase old focus
 800f28e:	4630      	mov	r0, r6
 800f290:	f7ff fa68 	bl	800e764 <keypad_draw_button>
    touch_wait_release();
 800f294:	f7ff f8dc 	bl	800e450 <touch_wait_release>
    keypad_draw_button(i); // erase new focus
 800f298:	4620      	mov	r0, r4
    selection = -1;
 800f29a:	23ff      	movs	r3, #255	@ 0xff
 800f29c:	702b      	strb	r3, [r5, #0]
    keypad_draw_button(i); // erase new focus
 800f29e:	f7ff fa61 	bl	800e764 <keypad_draw_button>
    keypad_click(i);       // Process input
 800f2a2:	4620      	mov	r0, r4
}
 800f2a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    keypad_click(i);       // Process input
 800f2a8:	f7ff beb2 	b.w	800f010 <keypad_click>
}
 800f2ac:	bd70      	pop	{r4, r5, r6, pc}
 800f2ae:	bf00      	nop
 800f2b0:	20008a08 	.word	0x20008a08
 800f2b4:	08016b30 	.word	0x08016b30
 800f2b8:	200003f0 	.word	0x200003f0

0800f2bc <ui_keypad_lever>:
  if (status == EVT_BUTTON_SINGLE_CLICK)
 800f2bc:	2801      	cmp	r0, #1
{
 800f2be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f2c2:	4d22      	ldr	r5, [pc, #136]	@ (800f34c <ui_keypad_lever+0x90>)
  if (status == EVT_BUTTON_SINGLE_CLICK)
 800f2c4:	d107      	bne.n	800f2d6 <ui_keypad_lever+0x1a>
    if (selection >= 0) // Process input
 800f2c6:	f995 0000 	ldrsb.w	r0, [r5]
 800f2ca:	2800      	cmp	r0, #0
 800f2cc:	db3c      	blt.n	800f348 <ui_keypad_lever+0x8c>
}
 800f2ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      keypad_click(selection);
 800f2d2:	f7ff be9d 	b.w	800f010 <keypad_click>
  int keypads_last_index = keypads->size - 1;
 800f2d6:	4e1e      	ldr	r6, [pc, #120]	@ (800f350 <ui_keypad_lever+0x94>)
 800f2d8:	6833      	ldr	r3, [r6, #0]
 800f2da:	781c      	ldrb	r4, [r3, #0]
 800f2dc:	4602      	mov	r2, r0
 800f2de:	3c01      	subs	r4, #1
    int old = selection;
 800f2e0:	f995 3000 	ldrsb.w	r3, [r5]
    } while (keypads->buttons[selection].c == KP_EMPTY); // Skip empty
 800f2e4:	f8d6 e000 	ldr.w	lr, [r6]
      if ((status & EVT_DOWN) && --selection < 0)
 800f2e8:	f002 0c20 	and.w	ip, r2, #32
    int old = selection;
 800f2ec:	4618      	mov	r0, r3
    } while (keypads->buttons[selection].c == KP_EMPTY); // Skip empty
 800f2ee:	2100      	movs	r1, #0
        selection = keypads_last_index;
 800f2f0:	b267      	sxtb	r7, r4
      if ((status & EVT_UP) && ++selection > keypads_last_index)
 800f2f2:	f002 0210 	and.w	r2, r2, #16
      if ((status & EVT_DOWN) && --selection < 0)
 800f2f6:	f1bc 0f00 	cmp.w	ip, #0
 800f2fa:	d005      	beq.n	800f308 <ui_keypad_lever+0x4c>
 800f2fc:	3b01      	subs	r3, #1
 800f2fe:	b25b      	sxtb	r3, r3
 800f300:	2b00      	cmp	r3, #0
        selection = keypads_last_index;
 800f302:	bfb8      	it	lt
 800f304:	463b      	movlt	r3, r7
 800f306:	2101      	movs	r1, #1
      if ((status & EVT_UP) && ++selection > keypads_last_index)
 800f308:	b132      	cbz	r2, 800f318 <ui_keypad_lever+0x5c>
 800f30a:	3301      	adds	r3, #1
 800f30c:	b25b      	sxtb	r3, r3
 800f30e:	42a3      	cmp	r3, r4
 800f310:	f04f 0101 	mov.w	r1, #1
        selection = 0;
 800f314:	bfc8      	it	gt
 800f316:	2300      	movgt	r3, #0
    } while (keypads->buttons[selection].c == KP_EMPTY); // Skip empty
 800f318:	eb0e 0843 	add.w	r8, lr, r3, lsl #1
 800f31c:	f898 8003 	ldrb.w	r8, [r8, #3]
 800f320:	f1b8 0fff 	cmp.w	r8, #255	@ 0xff
 800f324:	d0e7      	beq.n	800f2f6 <ui_keypad_lever+0x3a>
 800f326:	b101      	cbz	r1, 800f32a <ui_keypad_lever+0x6e>
 800f328:	702b      	strb	r3, [r5, #0]
    keypad_draw_button(old);
 800f32a:	f7ff fa1b 	bl	800e764 <keypad_draw_button>
    keypad_draw_button(selection);
 800f32e:	f995 0000 	ldrsb.w	r0, [r5]
 800f332:	f7ff fa17 	bl	800e764 <keypad_draw_button>
    chThdSleepMilliseconds(100);
 800f336:	f242 7010 	movw	r0, #10000	@ 0x2710
 800f33a:	f7f1 fda9 	bl	8000e90 <chThdSleep>
  } while ((status = btn_wait_release()) != 0);
 800f33e:	f7ff f8c3 	bl	800e4c8 <btn_wait_release>
 800f342:	4602      	mov	r2, r0
 800f344:	2800      	cmp	r0, #0
 800f346:	d1cb      	bne.n	800f2e0 <ui_keypad_lever+0x24>
}
 800f348:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f34c:	200003f0 	.word	0x200003f0
 800f350:	20008a08 	.word	0x20008a08

0800f354 <menu_draw>:
{
 800f354:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  menu_draw_buttons(menu_stack[menu_current_level], mask);
 800f358:	4b54      	ldr	r3, [pc, #336]	@ (800f4ac <menu_draw+0x158>)
 800f35a:	f8df 8164 	ldr.w	r8, [pc, #356]	@ 800f4c0 <menu_draw+0x16c>
 800f35e:	781a      	ldrb	r2, [r3, #0]
 800f360:	4b53      	ldr	r3, [pc, #332]	@ (800f4b0 <menu_draw+0x15c>)
 800f362:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
{
 800f366:	b08d      	sub	sp, #52	@ 0x34
 800f368:	4681      	mov	r9, r0
  int y = MENU_BUTTON_Y_OFFSET;
 800f36a:	f04f 0b01 	mov.w	fp, #1
  for (i = 0; i < MENU_BUTTON_MAX && m; i++, m = menu_next_item(m), y += menu_button_height)
 800f36e:	2600      	movs	r6, #0
 800f370:	2c00      	cmp	r4, #0
 800f372:	f000 8086 	beq.w	800f482 <menu_draw+0x12e>
    if ((mask & (1 << i)) == 0)
 800f376:	2301      	movs	r3, #1
 800f378:	40b3      	lsls	r3, r6
 800f37a:	ea13 0f09 	tst.w	r3, r9
 800f37e:	d074      	beq.n	800f46a <menu_draw+0x116>
    button.fg = LCD_MENU_TEXT_COLOR;
 800f380:	2304      	movs	r3, #4
 800f382:	f88d 3009 	strb.w	r3, [sp, #9]
    button.icon = BUTTON_ICON_NONE;
 800f386:	23ff      	movs	r3, #255	@ 0xff
 800f388:	f88d 300b 	strb.w	r3, [sp, #11]
    if (ui_mode == UI_MENU && i == selection)
 800f38c:	4b49      	ldr	r3, [pc, #292]	@ (800f4b4 <menu_draw+0x160>)
 800f38e:	781b      	ldrb	r3, [r3, #0]
 800f390:	2b01      	cmp	r3, #1
 800f392:	d104      	bne.n	800f39e <menu_draw+0x4a>
 800f394:	4b48      	ldr	r3, [pc, #288]	@ (800f4b8 <menu_draw+0x164>)
 800f396:	f993 3000 	ldrsb.w	r3, [r3]
 800f39a:	429e      	cmp	r6, r3
 800f39c:	d002      	beq.n	800f3a4 <menu_draw+0x50>
 800f39e:	2203      	movs	r2, #3
 800f3a0:	2391      	movs	r3, #145	@ 0x91
 800f3a2:	e001      	b.n	800f3a8 <menu_draw+0x54>
 800f3a4:	2205      	movs	r2, #5
 800f3a6:	2361      	movs	r3, #97	@ 0x61
      button.bg = LCD_MENU_ACTIVE_COLOR;
 800f3a8:	f88d 2008 	strb.w	r2, [sp, #8]
      button.border = MENU_BUTTON_BORDER | BUTTON_BORDER_FALLING;
 800f3ac:	f88d 300a 	strb.w	r3, [sp, #10]
    if (m->type == MT_ADV_CALLBACK)
 800f3b0:	7823      	ldrb	r3, [r4, #0]
 800f3b2:	2b03      	cmp	r3, #3
 800f3b4:	f10d 0a08 	add.w	sl, sp, #8
 800f3b8:	d116      	bne.n	800f3e8 <menu_draw+0x94>
      button.label[0] = 0;
 800f3ba:	2300      	movs	r3, #0
 800f3bc:	f88d 3010 	strb.w	r3, [sp, #16]
      if (m->reference)
 800f3c0:	f8d4 3006 	ldr.w	r3, [r4, #6]
 800f3c4:	b943      	cbnz	r3, 800f3d8 <menu_draw+0x84>
        plot_printf(button.label, sizeof(button.label), m->label, button.p1.u);
 800f3c6:	9b03      	ldr	r3, [sp, #12]
 800f3c8:	f8d4 2002 	ldr.w	r2, [r4, #2]
 800f3cc:	2120      	movs	r1, #32
 800f3ce:	a804      	add	r0, sp, #16
 800f3d0:	f7f3 fcce 	bl	8002d70 <plot_printf>
      text = button.label;
 800f3d4:	ad04      	add	r5, sp, #16
 800f3d6:	e009      	b.n	800f3ec <menu_draw+0x98>
        ((menuaction_acb_t)m->reference)(m->data, &button);
 800f3d8:	7860      	ldrb	r0, [r4, #1]
 800f3da:	4651      	mov	r1, sl
 800f3dc:	4798      	blx	r3
      if (button.label[0] == 0)
 800f3de:	f89d 3010 	ldrb.w	r3, [sp, #16]
 800f3e2:	2b00      	cmp	r3, #0
 800f3e4:	d1f6      	bne.n	800f3d4 <menu_draw+0x80>
 800f3e6:	e7ee      	b.n	800f3c6 <menu_draw+0x72>
      text = m->label;
 800f3e8:	f8d4 5002 	ldr.w	r5, [r4, #2]
    ui_draw_button(LCD_WIDTH - MENU_BUTTON_WIDTH, y, MENU_BUTTON_WIDTH, menu_button_height, &button);
 800f3ec:	f8cd a000 	str.w	sl, [sp]
 800f3f0:	fa1f f78b 	uxth.w	r7, fp
 800f3f4:	225b      	movs	r2, #91	@ 0x5b
 800f3f6:	f8b8 3000 	ldrh.w	r3, [r8]
 800f3fa:	4639      	mov	r1, r7
 800f3fc:	f240 1085 	movw	r0, #389	@ 0x185
 800f400:	f7ff f8a8 	bl	800e554 <ui_draw_button>
    if (button.icon >= 0)
 800f404:	f99d 200b 	ldrsb.w	r2, [sp, #11]
 800f408:	2a00      	cmp	r2, #0
 800f40a:	db15      	blt.n	800f438 <menu_draw+0xe4>
      lcd_blitBitmap(LCD_WIDTH - MENU_BUTTON_WIDTH + MENU_BUTTON_BORDER + MENU_ICON_OFFSET, y + (menu_button_height - ICON_HEIGHT) / 2, ICON_WIDTH, ICON_HEIGHT, ICON_GET_DATA(button.icon));
 800f40c:	f8b8 1000 	ldrh.w	r1, [r8]
 800f410:	482a      	ldr	r0, [pc, #168]	@ (800f4bc <menu_draw+0x168>)
 800f412:	390b      	subs	r1, #11
 800f414:	2316      	movs	r3, #22
 800f416:	fb02 0303 	mla	r3, r2, r3, r0
 800f41a:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800f41e:	9300      	str	r3, [sp, #0]
 800f420:	eb07 0161 	add.w	r1, r7, r1, asr #1
 800f424:	230b      	movs	r3, #11
 800f426:	f44f 70c5 	mov.w	r0, #394	@ 0x18a
 800f42a:	461a      	mov	r2, r3
 800f42c:	b289      	uxth	r1, r1
 800f42e:	f001 fe55 	bl	80110dc <lcd_blitBitmap>
      text_offs = LCD_WIDTH - MENU_BUTTON_WIDTH + MENU_BUTTON_BORDER + MENU_ICON_OFFSET + ICON_SIZE;
 800f432:	f44f 70cc 	mov.w	r0, #408	@ 0x198
 800f436:	e001      	b.n	800f43c <menu_draw+0xe8>
      text_offs = LCD_WIDTH - MENU_BUTTON_WIDTH + MENU_BUTTON_BORDER + MENU_TEXT_OFFSET;
 800f438:	f44f 70c6 	mov.w	r0, #396	@ 0x18c
  while (*label)
 800f43c:	1e6a      	subs	r2, r5, #1
  int n = 1;
 800f43e:	2301      	movs	r3, #1
  while (*label)
 800f440:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 800f444:	b119      	cbz	r1, 800f44e <menu_draw+0xfa>
    if (*label++ == '\n')
 800f446:	290a      	cmp	r1, #10
      n++;
 800f448:	bf08      	it	eq
 800f44a:	3301      	addeq	r3, #1
 800f44c:	e7f8      	b.n	800f440 <menu_draw+0xec>
    lcd_printf(text_offs, y + (menu_button_height - lines * FONT_STR_HEIGHT + (FONT_STR_HEIGHT - FONT_GET_HEIGHT)) / 2, text);
 800f44e:	f8b8 1000 	ldrh.w	r1, [r8]
 800f452:	f06f 020a 	mvn.w	r2, #10
 800f456:	fb02 1103 	mla	r1, r2, r3, r1
 800f45a:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800f45e:	eb07 0161 	add.w	r1, r7, r1, asr #1
 800f462:	462a      	mov	r2, r5
 800f464:	b209      	sxth	r1, r1
 800f466:	f001 feb7 	bl	80111d8 <lcd_printf>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f46a:	7aa3      	ldrb	r3, [r4, #10]
  for (i = 0; i < MENU_BUTTON_MAX && m; i++, m = menu_next_item(m), y += menu_button_height)
 800f46c:	3601      	adds	r6, #1
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f46e:	b10b      	cbz	r3, 800f474 <menu_draw+0x120>
  m++; // Next item
 800f470:	340a      	adds	r4, #10
 800f472:	e000      	b.n	800f476 <menu_draw+0x122>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f474:	6924      	ldr	r4, [r4, #16]
  for (i = 0; i < MENU_BUTTON_MAX && m; i++, m = menu_next_item(m), y += menu_button_height)
 800f476:	f8b8 3000 	ldrh.w	r3, [r8]
 800f47a:	2e10      	cmp	r6, #16
 800f47c:	449b      	add	fp, r3
 800f47e:	f47f af77 	bne.w	800f370 <menu_draw+0x1c>
  if (AREA_HEIGHT_NORMAL + OFFSETY > y)
 800f482:	f5bb 7f98 	cmp.w	fp, #304	@ 0x130
 800f486:	dc0e      	bgt.n	800f4a6 <menu_draw+0x152>
    lcd_set_background(LCD_BG_COLOR);
 800f488:	2000      	movs	r0, #0
 800f48a:	f001 fe09 	bl	80110a0 <lcd_set_background>
    lcd_fill(LCD_WIDTH - MENU_BUTTON_WIDTH, y, MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL + OFFSETY - y);
 800f48e:	f5cb 7398 	rsb	r3, fp, #304	@ 0x130
 800f492:	3301      	adds	r3, #1
 800f494:	225b      	movs	r2, #91	@ 0x5b
 800f496:	4659      	mov	r1, fp
 800f498:	f240 1085 	movw	r0, #389	@ 0x185
}
 800f49c:	b00d      	add	sp, #52	@ 0x34
 800f49e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    lcd_fill(LCD_WIDTH - MENU_BUTTON_WIDTH, y, MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL + OFFSETY - y);
 800f4a2:	f001 bd03 	b.w	8010eac <lcd_fill>
}
 800f4a6:	b00d      	add	sp, #52	@ 0x34
 800f4a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f4ac:	20008a05 	.word	0x20008a05
 800f4b0:	200003dc 	.word	0x200003dc
 800f4b4:	20008a0c 	.word	0x20008a0c
 800f4b8:	200003f0 	.word	0x200003f0
 800f4bc:	08016e30 	.word	0x08016e30
 800f4c0:	200003f2 	.word	0x200003f2

0800f4c4 <current_menu_get_count>:
  const menuitem_t *m = menu_stack[menu_current_level];
 800f4c4:	4b07      	ldr	r3, [pc, #28]	@ (800f4e4 <current_menu_get_count+0x20>)
 800f4c6:	781a      	ldrb	r2, [r3, #0]
 800f4c8:	4b07      	ldr	r3, [pc, #28]	@ (800f4e8 <current_menu_get_count+0x24>)
 800f4ca:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  int i = 0;
 800f4ce:	2000      	movs	r0, #0
  while (m)
 800f4d0:	b133      	cbz	r3, 800f4e0 <current_menu_get_count+0x1c>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f4d2:	7a9a      	ldrb	r2, [r3, #10]
 800f4d4:	3001      	adds	r0, #1
 800f4d6:	b10a      	cbz	r2, 800f4dc <current_menu_get_count+0x18>
  m++; // Next item
 800f4d8:	330a      	adds	r3, #10
  while (m)
 800f4da:	e7fa      	b.n	800f4d2 <current_menu_get_count+0xe>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f4dc:	691b      	ldr	r3, [r3, #16]
    i++;
 800f4de:	e7f7      	b.n	800f4d0 <current_menu_get_count+0xc>
}
 800f4e0:	4770      	bx	lr
 800f4e2:	bf00      	nop
 800f4e4:	20008a05 	.word	0x20008a05
 800f4e8:	200003dc 	.word	0x200003dc

0800f4ec <ensure_selection>:
{
 800f4ec:	b508      	push	{r3, lr}
  int i = current_menu_get_count();
 800f4ee:	f7ff ffe9 	bl	800f4c4 <current_menu_get_count>
  if (selection < 0)
 800f4f2:	4b0c      	ldr	r3, [pc, #48]	@ (800f524 <ensure_selection+0x38>)
 800f4f4:	f993 2000 	ldrsb.w	r2, [r3]
 800f4f8:	2a00      	cmp	r2, #0
 800f4fa:	da01      	bge.n	800f500 <ensure_selection+0x14>
    selection = -1;
 800f4fc:	22ff      	movs	r2, #255	@ 0xff
 800f4fe:	e002      	b.n	800f506 <ensure_selection+0x1a>
  else if (selection >= i)
 800f500:	4282      	cmp	r2, r0
 800f502:	db01      	blt.n	800f508 <ensure_selection+0x1c>
    selection = i - 1;
 800f504:	1e42      	subs	r2, r0, #1
 800f506:	701a      	strb	r2, [r3, #0]
  else if (i >= MENU_BUTTON_MAX)
 800f508:	2810      	cmp	r0, #16
 800f50a:	bfa8      	it	ge
 800f50c:	2010      	movge	r0, #16
  menu_button_height = MENU_BUTTON_HEIGHT(i);
 800f50e:	4a06      	ldr	r2, [pc, #24]	@ (800f528 <ensure_selection+0x3c>)
  if (i < MENU_BUTTON_MIN)
 800f510:	2808      	cmp	r0, #8
 800f512:	bfb8      	it	lt
 800f514:	2008      	movlt	r0, #8
  menu_button_height = MENU_BUTTON_HEIGHT(i);
 800f516:	f240 1331 	movw	r3, #305	@ 0x131
 800f51a:	fbb3 f3f0 	udiv	r3, r3, r0
 800f51e:	8013      	strh	r3, [r2, #0]
}
 800f520:	bd08      	pop	{r3, pc}
 800f522:	bf00      	nop
 800f524:	200003f0 	.word	0x200003f0
 800f528:	200003f2 	.word	0x200003f2

0800f52c <menu_push_submenu>:
  if (menu_current_level < MENU_STACK_DEPTH_MAX - 1)
 800f52c:	4a05      	ldr	r2, [pc, #20]	@ (800f544 <menu_push_submenu+0x18>)
 800f52e:	7813      	ldrb	r3, [r2, #0]
 800f530:	2b03      	cmp	r3, #3
 800f532:	d802      	bhi.n	800f53a <menu_push_submenu+0xe>
    menu_current_level++;
 800f534:	3301      	adds	r3, #1
 800f536:	b2db      	uxtb	r3, r3
 800f538:	7013      	strb	r3, [r2, #0]
  menu_stack[menu_current_level] = submenu;
 800f53a:	4a03      	ldr	r2, [pc, #12]	@ (800f548 <menu_push_submenu+0x1c>)
 800f53c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  ensure_selection();
 800f540:	f7ff bfd4 	b.w	800f4ec <ensure_selection>
 800f544:	20008a05 	.word	0x20008a05
 800f548:	200003dc 	.word	0x200003dc

0800f54c <menu_invoke>:
{
 800f54c:	b508      	push	{r3, lr}
  const menuitem_t *m = menu_stack[menu_current_level];
 800f54e:	4b19      	ldr	r3, [pc, #100]	@ (800f5b4 <menu_invoke+0x68>)
 800f550:	781a      	ldrb	r2, [r3, #0]
 800f552:	4b19      	ldr	r3, [pc, #100]	@ (800f5b8 <menu_invoke+0x6c>)
 800f554:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  while (i--)
 800f558:	3801      	subs	r0, #1
 800f55a:	d307      	bcc.n	800f56c <menu_invoke+0x20>
  if (m == NULL)
 800f55c:	2b00      	cmp	r3, #0
 800f55e:	d0fb      	beq.n	800f558 <menu_invoke+0xc>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f560:	7a9a      	ldrb	r2, [r3, #10]
 800f562:	b10a      	cbz	r2, 800f568 <menu_invoke+0x1c>
  m++; // Next item
 800f564:	330a      	adds	r3, #10
 800f566:	e7f7      	b.n	800f558 <menu_invoke+0xc>
  return m->type == MT_NEXT ? (menuitem_t *)m->reference : m;
 800f568:	691b      	ldr	r3, [r3, #16]
 800f56a:	e7f5      	b.n	800f558 <menu_invoke+0xc>
  if (menu == NULL)
 800f56c:	b30b      	cbz	r3, 800f5b2 <menu_invoke+0x66>
  switch (menu->type)
 800f56e:	781a      	ldrb	r2, [r3, #0]
 800f570:	2a02      	cmp	r2, #2
 800f572:	d008      	beq.n	800f586 <menu_invoke+0x3a>
 800f574:	2a03      	cmp	r2, #3
 800f576:	d00c      	beq.n	800f592 <menu_invoke+0x46>
 800f578:	2a01      	cmp	r2, #1
 800f57a:	d110      	bne.n	800f59e <menu_invoke+0x52>
    menu_push_submenu((const menuitem_t *)menu->reference);
 800f57c:	f8d3 0006 	ldr.w	r0, [r3, #6]
 800f580:	f7ff ffd4 	bl	800f52c <menu_push_submenu>
    break;
 800f584:	e00b      	b.n	800f59e <menu_invoke+0x52>
    if (menu->reference)
 800f586:	f8d3 2006 	ldr.w	r2, [r3, #6]
 800f58a:	b142      	cbz	r2, 800f59e <menu_invoke+0x52>
      ((menuaction_cb_t)menu->reference)(menu->data);
 800f58c:	7858      	ldrb	r0, [r3, #1]
 800f58e:	4790      	blx	r2
 800f590:	e005      	b.n	800f59e <menu_invoke+0x52>
    if (menu->reference)
 800f592:	f8d3 2006 	ldr.w	r2, [r3, #6]
 800f596:	b112      	cbz	r2, 800f59e <menu_invoke+0x52>
      ((menuaction_acb_t)menu->reference)(menu->data, NULL);
 800f598:	7858      	ldrb	r0, [r3, #1]
 800f59a:	2100      	movs	r1, #0
 800f59c:	4790      	blx	r2
  if (ui_mode == UI_MENU)
 800f59e:	4b07      	ldr	r3, [pc, #28]	@ (800f5bc <menu_invoke+0x70>)
 800f5a0:	781b      	ldrb	r3, [r3, #0]
 800f5a2:	2b01      	cmp	r3, #1
 800f5a4:	d105      	bne.n	800f5b2 <menu_invoke+0x66>
}
 800f5a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    menu_draw(-1);
 800f5aa:	f04f 30ff 	mov.w	r0, #4294967295
 800f5ae:	f7ff bed1 	b.w	800f354 <menu_draw>
}
 800f5b2:	bd08      	pop	{r3, pc}
 800f5b4:	20008a05 	.word	0x20008a05
 800f5b8:	200003dc 	.word	0x200003dc
 800f5bc:	20008a0c 	.word	0x20008a0c

0800f5c0 <menu_move_back>:
{
 800f5c0:	b508      	push	{r3, lr}
  if (menu_current_level == 0)
 800f5c2:	4a07      	ldr	r2, [pc, #28]	@ (800f5e0 <menu_move_back+0x20>)
 800f5c4:	7813      	ldrb	r3, [r2, #0]
 800f5c6:	b14b      	cbz	r3, 800f5dc <menu_move_back+0x1c>
 800f5c8:	4601      	mov	r1, r0
  menu_current_level--;
 800f5ca:	3b01      	subs	r3, #1
 800f5cc:	7013      	strb	r3, [r2, #0]
  ensure_selection();
 800f5ce:	f7ff ff8d 	bl	800f4ec <ensure_selection>
  if (leave_ui)
 800f5d2:	b119      	cbz	r1, 800f5dc <menu_move_back+0x1c>
}
 800f5d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ui_mode_normal();
 800f5d8:	f7ff b8a8 	b.w	800e72c <ui_mode_normal>
}
 800f5dc:	bd08      	pop	{r3, pc}
 800f5de:	bf00      	nop
 800f5e0:	20008a05 	.word	0x20008a05

0800f5e4 <ui_mode_menu>:
{
 800f5e4:	b508      	push	{r3, lr}
  if (ui_mode == UI_MENU)
 800f5e6:	4b0a      	ldr	r3, [pc, #40]	@ (800f610 <ui_mode_menu+0x2c>)
 800f5e8:	781a      	ldrb	r2, [r3, #0]
 800f5ea:	2a01      	cmp	r2, #1
 800f5ec:	d00f      	beq.n	800f60e <ui_mode_menu+0x2a>
  ui_mode = UI_MENU;
 800f5ee:	2201      	movs	r2, #1
  set_area_size(AREA_WIDTH_NORMAL - MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL);
 800f5f0:	f44f 70bb 	mov.w	r0, #374	@ 0x176
 800f5f4:	f240 1131 	movw	r1, #305	@ 0x131
  ui_mode = UI_MENU;
 800f5f8:	701a      	strb	r2, [r3, #0]
  set_area_size(AREA_WIDTH_NORMAL - MENU_BUTTON_WIDTH, AREA_HEIGHT_NORMAL);
 800f5fa:	f7fd f8ab 	bl	800c754 <set_area_size>
  ensure_selection();
 800f5fe:	f7ff ff75 	bl	800f4ec <ensure_selection>
}
 800f602:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  menu_draw(-1);
 800f606:	f04f 30ff 	mov.w	r0, #4294967295
 800f60a:	f7ff bea3 	b.w	800f354 <menu_draw>
}
 800f60e:	bd08      	pop	{r3, pc}
 800f610:	20008a0c 	.word	0x20008a0c

0800f614 <ui_normal_lever>:
  }
  return TRUE;
}

static void ui_normal_lever(uint16_t status)
{
 800f614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f616:	4603      	mov	r3, r0
  if (status & EVT_BUTTON_SINGLE_CLICK)
 800f618:	f010 0001 	ands.w	r0, r0, #1
 800f61c:	d003      	beq.n	800f626 <ui_normal_lever+0x12>
    break;
  case LM_EDELAY:
    lever_edelay(status);
    break;
  }
}
 800f61e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ui_mode_menu();
 800f622:	f7ff bfdf 	b.w	800f5e4 <ui_mode_menu>
  switch (lever_mode)
 800f626:	4a5d      	ldr	r2, [pc, #372]	@ (800f79c <ui_normal_lever+0x188>)
 800f628:	7f11      	ldrb	r1, [r2, #28]
 800f62a:	2903      	cmp	r1, #3
 800f62c:	d803      	bhi.n	800f636 <ui_normal_lever+0x22>
 800f62e:	2901      	cmp	r1, #1
 800f630:	d834      	bhi.n	800f69c <ui_normal_lever+0x88>
 800f632:	b119      	cbz	r1, 800f63c <ui_normal_lever+0x28>
 800f634:	e0b1      	b.n	800f79a <ui_normal_lever+0x186>
 800f636:	2904      	cmp	r1, #4
 800f638:	d076      	beq.n	800f728 <ui_normal_lever+0x114>
 800f63a:	e0ae      	b.n	800f79a <ui_normal_lever+0x186>
  if (active_marker == MARKER_INVALID || !markers[active_marker].enabled)
 800f63c:	4d58      	ldr	r5, [pc, #352]	@ (800f7a0 <ui_normal_lever+0x18c>)
 800f63e:	f995 201d 	ldrsb.w	r2, [r5, #29]
 800f642:	1c51      	adds	r1, r2, #1
 800f644:	f000 80a9 	beq.w	800f79a <ui_normal_lever+0x186>
 800f648:	320b      	adds	r2, #11
 800f64a:	f815 2032 	ldrb.w	r2, [r5, r2, lsl #3]
 800f64e:	2a00      	cmp	r2, #0
 800f650:	f000 80a3 	beq.w	800f79a <ui_normal_lever+0x186>
  uint16_t step = 1 << MARKER_SPEEDUP;
 800f654:	2408      	movs	r4, #8
    int idx = (int)markers[active_marker].index;
 800f656:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800f65a:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
    if ((status & EVT_DOWN) && (idx -= step >> MARKER_SPEEDUP) < 0)
 800f65e:	069f      	lsls	r7, r3, #26
    int idx = (int)markers[active_marker].index;
 800f660:	f8b2 105a 	ldrh.w	r1, [r2, #90]	@ 0x5a
    if ((status & EVT_DOWN) && (idx -= step >> MARKER_SPEEDUP) < 0)
 800f664:	bf44      	itt	mi
 800f666:	eba1 01d4 	submi.w	r1, r1, r4, lsr #3
 800f66a:	ea21 71e1 	bicmi.w	r1, r1, r1, asr #31
    if ((status & EVT_UP) && (idx += step >> MARKER_SPEEDUP) > sweep_points - 1)
 800f66e:	06de      	lsls	r6, r3, #27
 800f670:	d506      	bpl.n	800f680 <ui_normal_lever+0x6c>
 800f672:	8b6b      	ldrh	r3, [r5, #26]
 800f674:	eb01 01d4 	add.w	r1, r1, r4, lsr #3
 800f678:	428b      	cmp	r3, r1
      idx = sweep_points - 1;
 800f67a:	bfd8      	it	le
 800f67c:	f103 31ff 	addle.w	r1, r3, #4294967295
    set_marker_index(active_marker, idx);
 800f680:	f7f8 f89e 	bl	80077c0 <set_marker_index>
    redraw_marker(active_marker);
 800f684:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800f688:	f7fe fd26 	bl	800e0d8 <redraw_marker>
  } while ((status = btn_wait_release()) != 0);
 800f68c:	f7fe ff1c 	bl	800e4c8 <btn_wait_release>
    step++;
 800f690:	3401      	adds	r4, #1
 800f692:	b2a4      	uxth	r4, r4
  } while ((status = btn_wait_release()) != 0);
 800f694:	4603      	mov	r3, r0
 800f696:	2800      	cmp	r0, #0
 800f698:	d1dd      	bne.n	800f656 <ui_normal_lever+0x42>
 800f69a:	e07e      	b.n	800f79a <ui_normal_lever+0x186>
    if (FREQ_IS_STARTSTOP())
 800f69c:	4a40      	ldr	r2, [pc, #256]	@ (800f7a0 <ui_normal_lever+0x18c>)
 800f69e:	8b15      	ldrh	r5, [r2, #24]
  if (mode == ST_SPAN && !var_freq)
 800f6a0:	6950      	ldr	r0, [r2, #20]
  if (lever_mode == LM_FREQ_0)
 800f6a2:	2902      	cmp	r1, #2
 800f6a4:	f005 0540 	and.w	r5, r5, #64	@ 0x40
 800f6a8:	f003 0710 	and.w	r7, r3, #16
 800f6ac:	f003 0620 	and.w	r6, r3, #32
 800f6b0:	d10a      	bne.n	800f6c8 <ui_normal_lever+0xb4>
    case ST_START:  return frequency0;
 800f6b2:	6854      	ldr	r4, [r2, #4]
    if (FREQ_IS_STARTSTOP())
 800f6b4:	b1d5      	cbz	r5, 800f6ec <ui_normal_lever+0xd8>
    case ST_CENTER: return (frequency0>>1) + (frequency1>>1) + (frequency0&1);
 800f6b6:	6895      	ldr	r5, [r2, #8]
 800f6b8:	0863      	lsrs	r3, r4, #1
 800f6ba:	eb03 0355 	add.w	r3, r3, r5, lsr #1
 800f6be:	f004 0401 	and.w	r4, r4, #1
 800f6c2:	441c      	add	r4, r3
      mode = ST_CENTER;
 800f6c4:	460d      	mov	r5, r1
 800f6c6:	e011      	b.n	800f6ec <ui_normal_lever+0xd8>
 800f6c8:	6894      	ldr	r4, [r2, #8]
    if (FREQ_IS_STARTSTOP())
 800f6ca:	b175      	cbz	r5, 800f6ea <ui_normal_lever+0xd6>
    case ST_SPAN:   return frequency1 - frequency0;
 800f6cc:	6853      	ldr	r3, [r2, #4]
 800f6ce:	1ae4      	subs	r4, r4, r3
  if (mode == ST_SPAN && !var_freq)
 800f6d0:	b9a0      	cbnz	r0, 800f6fc <ui_normal_lever+0xe8>
    if (status & EVT_UP)
 800f6d2:	b127      	cbz	r7, 800f6de <ui_normal_lever+0xca>
      freq = step_round(freq * 4 + 1);
 800f6d4:	00a0      	lsls	r0, r4, #2
 800f6d6:	3001      	adds	r0, #1
 800f6d8:	f7fe fe08 	bl	800e2ec <step_round>
 800f6dc:	4604      	mov	r4, r0
    if (status & EVT_DOWN)
 800f6de:	b19e      	cbz	r6, 800f708 <ui_normal_lever+0xf4>
      freq = step_round(freq - 1);
 800f6e0:	1e60      	subs	r0, r4, #1
 800f6e2:	f7fe fe03 	bl	800e2ec <step_round>
 800f6e6:	4604      	mov	r4, r0
 800f6e8:	e00e      	b.n	800f708 <ui_normal_lever+0xf4>
      mode = ST_STOP;
 800f6ea:	2501      	movs	r5, #1
    freq_t step = var_freq ? var_freq : step_round(get_sweep_frequency(ST_SPAN) / 4);
 800f6ec:	b938      	cbnz	r0, 800f6fe <ui_normal_lever+0xea>
 800f6ee:	e9d2 3001 	ldrd	r3, r0, [r2, #4]
 800f6f2:	1ac0      	subs	r0, r0, r3
 800f6f4:	0880      	lsrs	r0, r0, #2
 800f6f6:	f7fe fdf9 	bl	800e2ec <step_round>
 800f6fa:	e000      	b.n	800f6fe <ui_normal_lever+0xea>
      mode = ST_SPAN;
 800f6fc:	2504      	movs	r5, #4
    if (status & EVT_UP)
 800f6fe:	b107      	cbz	r7, 800f702 <ui_normal_lever+0xee>
      freq += step;
 800f700:	4404      	add	r4, r0
    if (status & EVT_DOWN)
 800f702:	b116      	cbz	r6, 800f70a <ui_normal_lever+0xf6>
      freq -= step;
 800f704:	1a24      	subs	r4, r4, r0
 800f706:	e000      	b.n	800f70a <ui_normal_lever+0xf6>
      mode = ST_SPAN;
 800f708:	2504      	movs	r5, #4
  while (btn_wait_release() != 0)
 800f70a:	f7fe fedd 	bl	800e4c8 <btn_wait_release>
 800f70e:	2800      	cmp	r0, #0
 800f710:	d1fb      	bne.n	800f70a <ui_normal_lever+0xf6>
  if (freq > FREQUENCY_MAX || freq < FREQUENCY_MIN)
 800f712:	4b24      	ldr	r3, [pc, #144]	@ (800f7a4 <ui_normal_lever+0x190>)
 800f714:	f5a4 7216 	sub.w	r2, r4, #600	@ 0x258
 800f718:	429a      	cmp	r2, r3
 800f71a:	d83e      	bhi.n	800f79a <ui_normal_lever+0x186>
  set_sweep_frequency(mode, freq);
 800f71c:	4621      	mov	r1, r4
 800f71e:	4628      	mov	r0, r5
}
 800f720:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  set_sweep_frequency(mode, freq);
 800f724:	f7f8 b9d6 	b.w	8007ad4 <set_sweep_frequency>
  int ch = current_trace != TRACE_INVALID ? trace[current_trace].channel : 0;
 800f728:	4a1d      	ldr	r2, [pc, #116]	@ (800f7a0 <ui_normal_lever+0x18c>)
 800f72a:	f992 101c 	ldrsb.w	r1, [r2, #28]
 800f72e:	1c4c      	adds	r4, r1, #1
 800f730:	d004      	beq.n	800f73c <ui_normal_lever+0x128>
 800f732:	200c      	movs	r0, #12
 800f734:	fb00 2101 	mla	r1, r0, r1, r2
 800f738:	f891 002a 	ldrb.w	r0, [r1, #42]	@ 0x2a
  if (current_props._var_delay == 0.0f)
 800f73c:	edd2 7a29 	vldr	s15, [r2, #164]	@ 0xa4
 800f740:	eef5 7a40 	vcmp.f32	s15, #0.0
  float value = current_props._electrical_delay[ch];
 800f744:	eb02 0180 	add.w	r1, r2, r0, lsl #2
  if (current_props._var_delay == 0.0f)
 800f748:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f74c:	f003 0210 	and.w	r2, r3, #16
  float value = current_props._electrical_delay[ch];
 800f750:	ed91 0a27 	vldr	s0, [r1, #156]	@ 0x9c
  if (current_props._var_delay == 0.0f)
 800f754:	f003 0320 	and.w	r3, r3, #32
 800f758:	d113      	bne.n	800f782 <ui_normal_lever+0x16e>
    float ratio = value > 0 ? STEPRATIO : -STEPRATIO;
 800f75a:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 800f75e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800f762:	bfcc      	ite	gt
 800f764:	ed9f 7a10 	vldrgt	s14, [pc, #64]	@ 800f7a8 <ui_normal_lever+0x194>
 800f768:	ed9f 7a10 	vldrle	s14, [pc, #64]	@ 800f7ac <ui_normal_lever+0x198>
    if (status & EVT_UP)
 800f76c:	b10a      	cbz	r2, 800f772 <ui_normal_lever+0x15e>
      value *= (1.0f + ratio);
 800f76e:	ee07 0a00 	vmla.f32	s0, s14, s0
    if (status & EVT_DOWN)
 800f772:	b163      	cbz	r3, 800f78e <ui_normal_lever+0x17a>
      value *= (1.0f - ratio);
 800f774:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 800f778:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800f77c:	ee20 0a27 	vmul.f32	s0, s0, s15
 800f780:	e005      	b.n	800f78e <ui_normal_lever+0x17a>
    if (status & EVT_UP)
 800f782:	b10a      	cbz	r2, 800f788 <ui_normal_lever+0x174>
      value += current_props._var_delay;
 800f784:	ee30 0a27 	vadd.f32	s0, s0, s15
    if (status & EVT_DOWN)
 800f788:	b10b      	cbz	r3, 800f78e <ui_normal_lever+0x17a>
      value -= current_props._var_delay;
 800f78a:	ee30 0a67 	vsub.f32	s0, s0, s15
  set_electrical_delay(ch, value);
 800f78e:	f7f9 fdfd 	bl	800938c <set_electrical_delay>
  while (btn_wait_release() != 0)
 800f792:	f7fe fe99 	bl	800e4c8 <btn_wait_release>
 800f796:	2800      	cmp	r0, #0
 800f798:	d1fb      	bne.n	800f792 <ui_normal_lever+0x17e>
}
 800f79a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f79c:	20000318 	.word	0x20000318
 800f7a0:	20000aa8 	.word	0x20000aa8
 800f7a4:	a0eeb8a8 	.word	0xa0eeb8a8
 800f7a8:	3e4ccccd 	.word	0x3e4ccccd
 800f7ac:	be4ccccd 	.word	0xbe4ccccd

0800f7b0 <ui_menu_touch>:
  if (LCD_WIDTH - MENU_BUTTON_WIDTH < touch_x)
 800f7b0:	f5b0 7fc3 	cmp.w	r0, #390	@ 0x186
{
 800f7b4:	b538      	push	{r3, r4, r5, lr}
  if (LCD_WIDTH - MENU_BUTTON_WIDTH < touch_x)
 800f7b6:	db1f      	blt.n	800f7f8 <ui_menu_touch+0x48>
    int16_t i = (touch_y - MENU_BUTTON_Y_OFFSET) / menu_button_height;
 800f7b8:	4b12      	ldr	r3, [pc, #72]	@ (800f804 <ui_menu_touch+0x54>)
 800f7ba:	3901      	subs	r1, #1
 800f7bc:	881b      	ldrh	r3, [r3, #0]
 800f7be:	fb91 f1f3 	sdiv	r1, r1, r3
    if ((uint16_t)i < (uint16_t)current_menu_get_count())
 800f7c2:	f7ff fe7f 	bl	800f4c4 <current_menu_get_count>
 800f7c6:	b28b      	uxth	r3, r1
 800f7c8:	b280      	uxth	r0, r0
 800f7ca:	4298      	cmp	r0, r3
 800f7cc:	d914      	bls.n	800f7f8 <ui_menu_touch+0x48>
      uint32_t mask = (1 << i) | (1 << selection);
 800f7ce:	4c0e      	ldr	r4, [pc, #56]	@ (800f808 <ui_menu_touch+0x58>)
 800f7d0:	f994 0000 	ldrsb.w	r0, [r4]
      selection = i;
 800f7d4:	7021      	strb	r1, [r4, #0]
      uint32_t mask = (1 << i) | (1 << selection);
 800f7d6:	b20d      	sxth	r5, r1
 800f7d8:	2301      	movs	r3, #1
 800f7da:	fa03 f000 	lsl.w	r0, r3, r0
 800f7de:	40ab      	lsls	r3, r5
      menu_draw(mask);
 800f7e0:	4318      	orrs	r0, r3
 800f7e2:	f7ff fdb7 	bl	800f354 <menu_draw>
      touch_wait_release();
 800f7e6:	f7fe fe33 	bl	800e450 <touch_wait_release>
      selection = -1;
 800f7ea:	23ff      	movs	r3, #255	@ 0xff
 800f7ec:	7023      	strb	r3, [r4, #0]
      menu_invoke(i);
 800f7ee:	4628      	mov	r0, r5
}
 800f7f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      menu_invoke(i);
 800f7f4:	f7ff beaa 	b.w	800f54c <menu_invoke>
  touch_wait_release();
 800f7f8:	f7fe fe2a 	bl	800e450 <touch_wait_release>
}
 800f7fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ui_mode_normal();
 800f800:	f7fe bf94 	b.w	800e72c <ui_mode_normal>
 800f804:	200003f2 	.word	0x200003f2
 800f808:	200003f0 	.word	0x200003f0

0800f80c <ui_menu_lever>:
{
 800f80c:	b570      	push	{r4, r5, r6, lr}
 800f80e:	4601      	mov	r1, r0
  uint16_t count = current_menu_get_count();
 800f810:	f7ff fe58 	bl	800f4c4 <current_menu_get_count>
  if (status & EVT_BUTTON_SINGLE_CLICK)
 800f814:	f011 0f01 	tst.w	r1, #1
 800f818:	4d18      	ldr	r5, [pc, #96]	@ (800f87c <ui_menu_lever+0x70>)
  uint16_t count = current_menu_get_count();
 800f81a:	b284      	uxth	r4, r0
  if (status & EVT_BUTTON_SINGLE_CLICK)
 800f81c:	d101      	bne.n	800f822 <ui_menu_lever+0x16>
    uint32_t mask = 1 << selection;
 800f81e:	2601      	movs	r6, #1
 800f820:	e00c      	b.n	800f83c <ui_menu_lever+0x30>
    if ((uint16_t)selection >= count)
 800f822:	f995 0000 	ldrsb.w	r0, [r5]
 800f826:	b283      	uxth	r3, r0
 800f828:	42a3      	cmp	r3, r4
 800f82a:	d303      	bcc.n	800f834 <ui_menu_lever+0x28>
}
 800f82c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ui_mode_normal();
 800f830:	f7fe bf7c 	b.w	800e72c <ui_mode_normal>
}
 800f834:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      menu_invoke(selection);
 800f838:	f7ff be88 	b.w	800f54c <menu_invoke>
    uint32_t mask = 1 << selection;
 800f83c:	f995 3000 	ldrsb.w	r3, [r5]
    if (status & EVT_UP)
 800f840:	06ca      	lsls	r2, r1, #27
    uint32_t mask = 1 << selection;
 800f842:	fa06 f003 	lsl.w	r0, r6, r3
    if (status & EVT_UP)
 800f846:	d502      	bpl.n	800f84e <ui_menu_lever+0x42>
      selection++;
 800f848:	3301      	adds	r3, #1
 800f84a:	b25b      	sxtb	r3, r3
 800f84c:	702b      	strb	r3, [r5, #0]
    if (status & EVT_DOWN)
 800f84e:	068a      	lsls	r2, r1, #26
 800f850:	d502      	bpl.n	800f858 <ui_menu_lever+0x4c>
      selection--;
 800f852:	3b01      	subs	r3, #1
 800f854:	b25b      	sxtb	r3, r3
 800f856:	702b      	strb	r3, [r5, #0]
    if ((uint16_t)selection >= count)
 800f858:	b29a      	uxth	r2, r3
 800f85a:	42a2      	cmp	r2, r4
 800f85c:	d2e6      	bcs.n	800f82c <ui_menu_lever+0x20>
    menu_draw(mask | (1 << selection));
 800f85e:	fa06 f303 	lsl.w	r3, r6, r3
 800f862:	4318      	orrs	r0, r3
 800f864:	f7ff fd76 	bl	800f354 <menu_draw>
    chThdSleepMilliseconds(100);
 800f868:	f242 7010 	movw	r0, #10000	@ 0x2710
 800f86c:	f7f1 fb10 	bl	8000e90 <chThdSleep>
  } while ((status = btn_wait_release()) != 0);
 800f870:	f7fe fe2a 	bl	800e4c8 <btn_wait_release>
 800f874:	4601      	mov	r1, r0
 800f876:	2800      	cmp	r0, #0
 800f878:	d1e0      	bne.n	800f83c <ui_menu_lever+0x30>
}
 800f87a:	bd70      	pop	{r4, r5, r6, pc}
 800f87c:	200003f0 	.word	0x200003f0

0800f880 <touch_checkHB9IIU>:
{
 800f880:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  touch_stop_watchdog();
 800f882:	f7fe fd45 	bl	800e310 <touch_stop_watchdog>
  int stat = touch_status();
 800f886:	f7fe fda9 	bl	800e3dc <touch_status>
  if (stat)
 800f88a:	4f1f      	ldr	r7, [pc, #124]	@ (800f908 <touch_checkHB9IIU+0x88>)
 800f88c:	b1f8      	cbz	r0, 800f8ce <touch_checkHB9IIU+0x4e>
 800f88e:	4604      	mov	r4, r0
    int y = touch_measure_y();
 800f890:	f7fe fd6c 	bl	800e36c <touch_measure_y>
 800f894:	4605      	mov	r5, r0
    int x = touch_measure_x();
 800f896:	f7fe fd7b 	bl	800e390 <touch_measure_x>
 800f89a:	4606      	mov	r6, r0
    touch_prepare_sense();
 800f89c:	f7fe fd44 	bl	800e328 <touch_prepare_sense>
    if (touch_status())
 800f8a0:	f7fe fd9c 	bl	800e3dc <touch_status>
 800f8a4:	b180      	cbz	r0, 800f8c8 <touch_checkHB9IIU+0x48>
      last_touch_x = x;
 800f8a6:	4b19      	ldr	r3, [pc, #100]	@ (800f90c <touch_checkHB9IIU+0x8c>)
 800f8a8:	801e      	strh	r6, [r3, #0]
      last_touch_y = y;
 800f8aa:	4b19      	ldr	r3, [pc, #100]	@ (800f910 <touch_checkHB9IIU+0x90>)
      touch_position(&px, &py);              // uses existing calibration
 800f8ac:	a901      	add	r1, sp, #4
 800f8ae:	4668      	mov	r0, sp
      last_touch_y = y;
 800f8b0:	801d      	strh	r5, [r3, #0]
      touch_position(&px, &py);              // uses existing calibration
 800f8b2:	f7fe fc75 	bl	800e1a0 <touch_position>
g_touch_px = px;
 800f8b6:	4b17      	ldr	r3, [pc, #92]	@ (800f914 <touch_checkHB9IIU+0x94>)
 800f8b8:	9900      	ldr	r1, [sp, #0]
 800f8ba:	6019      	str	r1, [r3, #0]
g_touch_py = py;
 800f8bc:	4b16      	ldr	r3, [pc, #88]	@ (800f918 <touch_checkHB9IIU+0x98>)
 800f8be:	9a01      	ldr	r2, [sp, #4]
      UI_UART_LOG("touch: x=%d y=%d\r\n", px, py);
 800f8c0:	4816      	ldr	r0, [pc, #88]	@ (800f91c <touch_checkHB9IIU+0x9c>)
g_touch_py = py;
 800f8c2:	601a      	str	r2, [r3, #0]
      UI_UART_LOG("touch: x=%d y=%d\r\n", px, py);
 800f8c4:	f7f6 f84a 	bl	800595c <serial_shell_printf>
    touch_remote = REMOTE_NONE;
 800f8c8:	2300      	movs	r3, #0
 800f8ca:	703b      	strb	r3, [r7, #0]
 800f8cc:	e003      	b.n	800f8d6 <touch_checkHB9IIU+0x56>
    stat = touch_remote == REMOTE_PRESS;
 800f8ce:	783c      	ldrb	r4, [r7, #0]
 800f8d0:	1e63      	subs	r3, r4, #1
 800f8d2:	425c      	negs	r4, r3
 800f8d4:	415c      	adcs	r4, r3
  if (stat != last_touch_status)
 800f8d6:	4b12      	ldr	r3, [pc, #72]	@ (800f920 <touch_checkHB9IIU+0xa0>)
 800f8d8:	781a      	ldrb	r2, [r3, #0]
 800f8da:	42a2      	cmp	r2, r4
 800f8dc:	d010      	beq.n	800f900 <touch_checkHB9IIU+0x80>
    touch_position(&px, &py);
 800f8de:	a901      	add	r1, sp, #4
 800f8e0:	4668      	mov	r0, sp
    last_touch_status = stat;
 800f8e2:	701c      	strb	r4, [r3, #0]
    touch_position(&px, &py);
 800f8e4:	f7fe fc5c 	bl	800e1a0 <touch_position>
    UI_UART_LOG("touch evt: %s (x=%d y=%d)\r\n",
 800f8e8:	480e      	ldr	r0, [pc, #56]	@ (800f924 <touch_checkHB9IIU+0xa4>)
 800f8ea:	490f      	ldr	r1, [pc, #60]	@ (800f928 <touch_checkHB9IIU+0xa8>)
 800f8ec:	e9dd 2300 	ldrd	r2, r3, [sp]
 800f8f0:	2c00      	cmp	r4, #0
 800f8f2:	bf08      	it	eq
 800f8f4:	4601      	moveq	r1, r0
 800f8f6:	480d      	ldr	r0, [pc, #52]	@ (800f92c <touch_checkHB9IIU+0xac>)
 800f8f8:	f7f6 f830 	bl	800595c <serial_shell_printf>
    return stat ? EVT_TOUCH_PRESSED : EVT_TOUCH_RELEASED;
 800f8fc:	f1c4 0403 	rsb	r4, r4, #3
}
 800f900:	4620      	mov	r0, r4
 800f902:	b003      	add	sp, #12
 800f904:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f906:	bf00      	nop
 800f908:	20008a04 	.word	0x20008a04
 800f90c:	20008a26 	.word	0x20008a26
 800f910:	20008a24 	.word	0x20008a24
 800f914:	20008a00 	.word	0x20008a00
 800f918:	200089fc 	.word	0x200089fc
 800f91c:	08014a7e 	.word	0x08014a7e
 800f920:	20008a28 	.word	0x20008a28
 800f924:	08014a75 	.word	0x08014a75
 800f928:	08014a6d 	.word	0x08014a6d
 800f92c:	08014a91 	.word	0x08014a91

0800f930 <ui_message_box>:
{
 800f930:	b570      	push	{r4, r5, r6, lr}
 800f932:	b08c      	sub	sp, #48	@ 0x30
  b.bg = LCD_MENU_COLOR;
 800f934:	f240 4303 	movw	r3, #1027	@ 0x403
 800f938:	f8ad 3008 	strh.w	r3, [sp, #8]
  b.border = BUTTON_BORDER_FLAT;
 800f93c:	2300      	movs	r3, #0
{
 800f93e:	460c      	mov	r4, r1
 800f940:	4615      	mov	r5, r2
  b.border = BUTTON_BORDER_FLAT;
 800f942:	f88d 300a 	strb.w	r3, [sp, #10]
  if (header)
 800f946:	b180      	cbz	r0, 800f96a <ui_message_box+0x3a>
    ui_draw_button((LCD_WIDTH - MESSAGE_BOX_WIDTH) / 2, LCD_HEIGHT / 2 - 40, MESSAGE_BOX_WIDTH, 60, &b);
 800f948:	ab02      	add	r3, sp, #8
 800f94a:	4606      	mov	r6, r0
 800f94c:	9300      	str	r3, [sp, #0]
 800f94e:	22b4      	movs	r2, #180	@ 0xb4
 800f950:	233c      	movs	r3, #60	@ 0x3c
 800f952:	2178      	movs	r1, #120	@ 0x78
 800f954:	2096      	movs	r0, #150	@ 0x96
 800f956:	f7fe fdfd 	bl	800e554 <ui_draw_button>
    lcd_drawstring(x, y, header);
 800f95a:	4632      	mov	r2, r6
 800f95c:	217d      	movs	r1, #125	@ 0x7d
 800f95e:	20a0      	movs	r0, #160	@ 0xa0
 800f960:	f001 fc3a 	bl	80111d8 <lcd_printf>
    request_to_redraw(REDRAW_AREA);
 800f964:	2002      	movs	r0, #2
 800f966:	f7fc feff 	bl	800c768 <request_to_redraw>
  if (text)
 800f96a:	b18c      	cbz	r4, 800f990 <ui_message_box+0x60>
    lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_FG_COLOR);
 800f96c:	2101      	movs	r1, #1
 800f96e:	2004      	movs	r0, #4
 800f970:	f001 fba2 	bl	80110b8 <lcd_set_colors>
    lcd_fill((LCD_WIDTH - MESSAGE_BOX_WIDTH) / 2 + 3, LCD_HEIGHT / 2 - 40 + FONT_STR_HEIGHT + 8, MESSAGE_BOX_WIDTH - 6, 60 - FONT_STR_HEIGHT - 8 - 3);
 800f974:	2326      	movs	r3, #38	@ 0x26
 800f976:	22ae      	movs	r2, #174	@ 0xae
 800f978:	218b      	movs	r1, #139	@ 0x8b
 800f97a:	2099      	movs	r0, #153	@ 0x99
 800f97c:	f001 fa96 	bl	8010eac <lcd_fill>
    lcd_drawstring(x, y, text);
 800f980:	4622      	mov	r2, r4
 800f982:	2199      	movs	r1, #153	@ 0x99
 800f984:	20aa      	movs	r0, #170	@ 0xaa
 800f986:	f001 fc27 	bl	80111d8 <lcd_printf>
    request_to_redraw(REDRAW_AREA);
 800f98a:	2002      	movs	r0, #2
 800f98c:	f7fc feec 	bl	800c768 <request_to_redraw>
    chThdSleepMilliseconds(delay == 0 ? 50 : delay);
 800f990:	4c0d      	ldr	r4, [pc, #52]	@ (800f9c8 <ui_message_box+0x98>)
 800f992:	436c      	muls	r4, r5
 800f994:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800f998:	f204 34e7 	addw	r4, r4, #999	@ 0x3e7
 800f99c:	fbb4 f4f3 	udiv	r4, r4, r3
 800f9a0:	f241 3388 	movw	r3, #5000	@ 0x1388
 800f9a4:	2d00      	cmp	r5, #0
 800f9a6:	bf08      	it	eq
 800f9a8:	461c      	moveq	r4, r3
 800f9aa:	4620      	mov	r0, r4
 800f9ac:	f7f1 fa70 	bl	8000e90 <chThdSleep>
  } while (delay == 0 && btn_check() != EVT_BUTTON_SINGLE_CLICK && touch_check() != EVT_TOUCH_PRESSED);
 800f9b0:	b93d      	cbnz	r5, 800f9c2 <ui_message_box+0x92>
 800f9b2:	f7fe fd63 	bl	800e47c <btn_check>
 800f9b6:	2801      	cmp	r0, #1
 800f9b8:	d003      	beq.n	800f9c2 <ui_message_box+0x92>
 800f9ba:	f7fe fd19 	bl	800e3f0 <touch_check>
 800f9be:	2802      	cmp	r0, #2
 800f9c0:	d1f3      	bne.n	800f9aa <ui_message_box+0x7a>
}
 800f9c2:	b00c      	add	sp, #48	@ 0x30
 800f9c4:	bd70      	pop	{r4, r5, r6, pc}
 800f9c6:	bf00      	nop
 800f9c8:	000186a0 	.word	0x000186a0

0800f9cc <browser_draw_page>:
static void browser_draw_page(int page) {
 800f9cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (f_mount(fs_volume, "", 1) != FR_OK ||
 800f9d0:	493d      	ldr	r1, [pc, #244]	@ (800fac8 <browser_draw_page+0xfc>)
static void browser_draw_page(int page) {
 800f9d2:	b0aa      	sub	sp, #168	@ 0xa8
 800f9d4:	4605      	mov	r5, r0
  if (f_mount(fs_volume, "", 1) != FR_OK ||
 800f9d6:	2201      	movs	r2, #1
 800f9d8:	483c      	ldr	r0, [pc, #240]	@ (800facc <browser_draw_page+0x100>)
 800f9da:	f7f4 ffb3 	bl	8004944 <f_mount>
 800f9de:	b140      	cbz	r0, 800f9f2 <browser_draw_page+0x26>
    ui_message_box("ERROR", "NO CARD", 2000);
 800f9e0:	493b      	ldr	r1, [pc, #236]	@ (800fad0 <browser_draw_page+0x104>)
 800f9e2:	483c      	ldr	r0, [pc, #240]	@ (800fad4 <browser_draw_page+0x108>)
 800f9e4:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800f9e8:	f7ff ffa2 	bl	800f930 <ui_message_box>
    ui_mode_normal();
 800f9ec:	f7fe fe9e 	bl	800e72c <ui_mode_normal>
    return;
 800f9f0:	e067      	b.n	800fac2 <browser_draw_page+0xf6>
      sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) {
 800f9f2:	4b39      	ldr	r3, [pc, #228]	@ (800fad8 <browser_draw_page+0x10c>)
  dp->pat = pattern;
 800f9f4:	4a39      	ldr	r2, [pc, #228]	@ (800fadc <browser_draw_page+0x110>)
      sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) {
 800f9f6:	781b      	ldrb	r3, [r3, #0]
  return f_opendir(dp, path);
 800f9f8:	4933      	ldr	r1, [pc, #204]	@ (800fac8 <browser_draw_page+0xfc>)
      sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) {
 800f9fa:	011b      	lsls	r3, r3, #4
  return f_opendir(dp, path);
 800f9fc:	a814      	add	r0, sp, #80	@ 0x50
  dp->pat = pattern;
 800f9fe:	58d3      	ldr	r3, [r2, r3]
 800fa00:	9328      	str	r3, [sp, #160]	@ 0xa0
  return f_opendir(dp, path);
 800fa02:	f7f5 fb5d 	bl	80050c0 <f_opendir>
  if (f_mount(fs_volume, "", 1) != FR_OK ||
 800fa06:	4604      	mov	r4, r0
 800fa08:	2800      	cmp	r0, #0
 800fa0a:	d1e9      	bne.n	800f9e0 <browser_draw_page+0x14>
  uint16_t start_file = (page - 1) * FILES_PER_PAGE;
 800fa0c:	1e6a      	subs	r2, r5, #1
 800fa0e:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 800fa12:	0052      	lsls	r2, r2, #1
  lcd_set_background(LCD_MENU_COLOR);
 800fa14:	2003      	movs	r0, #3
  uint16_t start_file = (page - 1) * FILES_PER_PAGE;
 800fa16:	b296      	uxth	r6, r2
  lcd_set_background(LCD_MENU_COLOR);
 800fa18:	f001 fb42 	bl	80110a0 <lcd_set_background>
  while (sd_findnext(&dj, &fno) == FR_OK) {
 800fa1c:	4f30      	ldr	r7, [pc, #192]	@ (800fae0 <browser_draw_page+0x114>)
    if (cnt >= start_file && cnt < (start_file + FILES_PER_PAGE)) {
 800fa1e:	f106 081d 	add.w	r8, r6, #29
  while (sd_findnext(&dj, &fno) == FR_OK) {
 800fa22:	a904      	add	r1, sp, #16
 800fa24:	a814      	add	r0, sp, #80	@ 0x50
 800fa26:	f7ff fa29 	bl	800ee7c <sd_findnext>
 800fa2a:	b990      	cbnz	r0, 800fa52 <browser_draw_page+0x86>
    if (cnt >= start_file && cnt < (start_file + FILES_PER_PAGE)) {
 800fa2c:	42b4      	cmp	r4, r6
 800fa2e:	db08      	blt.n	800fa42 <browser_draw_page+0x76>
 800fa30:	45a0      	cmp	r8, r4
 800fa32:	db06      	blt.n	800fa42 <browser_draw_page+0x76>
      browser_draw_button(cnt - start_file + FILE_BUTTON_FILE, fno.fname);
 800fa34:	f1c6 0004 	rsb	r0, r6, #4
 800fa38:	f10d 012a 	add.w	r1, sp, #42	@ 0x2a
 800fa3c:	4420      	add	r0, r4
 800fa3e:	f7fe fde3 	bl	800e608 <browser_draw_button>
    if (file_count && (start_file + FILES_PER_PAGE == cnt)) break;
 800fa42:	883b      	ldrh	r3, [r7, #0]
    cnt++;
 800fa44:	3401      	adds	r4, #1
    if (file_count && (start_file + FILES_PER_PAGE == cnt)) break;
 800fa46:	2b00      	cmp	r3, #0
 800fa48:	d0eb      	beq.n	800fa22 <browser_draw_page+0x56>
 800fa4a:	f106 031e 	add.w	r3, r6, #30
 800fa4e:	42a3      	cmp	r3, r4
 800fa50:	d1e7      	bne.n	800fa22 <browser_draw_page+0x56>
  f_closedir(&dj);
 800fa52:	a814      	add	r0, sp, #80	@ 0x50
 800fa54:	f7f5 fb78 	bl	8005148 <f_closedir>
  if (file_count == 0) {
 800fa58:	883b      	ldrh	r3, [r7, #0]
 800fa5a:	b95b      	cbnz	r3, 800fa74 <browser_draw_page+0xa8>
    file_count = cnt;
 800fa5c:	803c      	strh	r4, [r7, #0]
    page_count = cnt == 0 ? 1 : (file_count + FILES_PER_PAGE - 1) / FILES_PER_PAGE;
 800fa5e:	b134      	cbz	r4, 800fa6e <browser_draw_page+0xa2>
 800fa60:	b2a2      	uxth	r2, r4
 800fa62:	321d      	adds	r2, #29
 800fa64:	231e      	movs	r3, #30
 800fa66:	fbb2 f2f3 	udiv	r2, r2, r3
 800fa6a:	b292      	uxth	r2, r2
 800fa6c:	e000      	b.n	800fa70 <browser_draw_page+0xa4>
 800fa6e:	2201      	movs	r2, #1
 800fa70:	4b1c      	ldr	r3, [pc, #112]	@ (800fae4 <browser_draw_page+0x118>)
 800fa72:	801a      	strh	r2, [r3, #0]
  cnt-= start_file;
 800fa74:	1ba4      	subs	r4, r4, r6
  while(cnt < FILES_PER_PAGE) {
 800fa76:	2c1d      	cmp	r4, #29
 800fa78:	dc0f      	bgt.n	800fa9a <browser_draw_page+0xce>
    browser_get_button_pos(cnt + FILE_BUTTON_FILE, &btn);
 800fa7a:	1d20      	adds	r0, r4, #4
 800fa7c:	a902      	add	r1, sp, #8
 800fa7e:	f7fe fbdd 	bl	800e23c <browser_get_button_pos>
    lcd_fill(btn.x, btn.y, btn.w, btn.h);
 800fa82:	f89d 300e 	ldrb.w	r3, [sp, #14]
 800fa86:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 800fa8a:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 800fa8e:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 800fa92:	f001 fa0b 	bl	8010eac <lcd_fill>
    cnt++;
 800fa96:	3401      	adds	r4, #1
 800fa98:	e7ed      	b.n	800fa76 <browser_draw_page+0xaa>
  lcd_fill(0, LCD_HEIGHT - FILE_BOTTOM_HEIGHT, LCD_WIDTH, FILE_BOTTOM_HEIGHT);
 800fa9a:	2314      	movs	r3, #20
 800fa9c:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 800faa0:	f44f 7196 	mov.w	r1, #300	@ 0x12c
 800faa4:	2000      	movs	r0, #0
 800faa6:	f001 fa01 	bl	8010eac <lcd_fill>
  browser_draw_buttons();
 800faaa:	f7fe fdf7 	bl	800e69c <browser_draw_buttons>
  lcd_printf((LCD_WIDTH - FONT_STR_WIDTH(6)) / 2, LCD_HEIGHT - (FILE_BOTTOM_HEIGHT + FONT_STR_HEIGHT) / 2, "- %u | %u -", page, page_count);
 800faae:	4b0d      	ldr	r3, [pc, #52]	@ (800fae4 <browser_draw_page+0x118>)
 800fab0:	4a0d      	ldr	r2, [pc, #52]	@ (800fae8 <browser_draw_page+0x11c>)
 800fab2:	881b      	ldrh	r3, [r3, #0]
 800fab4:	9300      	str	r3, [sp, #0]
 800fab6:	f240 1131 	movw	r1, #305	@ 0x131
 800faba:	462b      	mov	r3, r5
 800fabc:	20db      	movs	r0, #219	@ 0xdb
 800fabe:	f001 fb8b 	bl	80111d8 <lcd_printf>
}
 800fac2:	b02a      	add	sp, #168	@ 0xa8
 800fac4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fac8:	08014855 	.word	0x08014855
 800facc:	20009800 	.word	0x20009800
 800fad0:	08014aad 	.word	0x08014aad
 800fad4:	08014ab5 	.word	0x08014ab5
 800fad8:	20008a07 	.word	0x20008a07
 800fadc:	08016b9c 	.word	0x08016b9c
 800fae0:	200089f8 	.word	0x200089f8
 800fae4:	200089f6 	.word	0x200089f6
 800fae8:	08014abb 	.word	0x08014abb

0800faec <ui_save_file>:
{
 800faec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  file_save_cb_t save = file_opt[format].save;
 800faf0:	4f2e      	ldr	r7, [pc, #184]	@ (800fbac <ui_save_file+0xc0>)
 800faf2:	eb07 1301 	add.w	r3, r7, r1, lsl #4
{
 800faf6:	b08a      	sub	sp, #40	@ 0x28
  file_save_cb_t save = file_opt[format].save;
 800faf8:	685e      	ldr	r6, [r3, #4]
  if (save == NULL)
 800fafa:	2e00      	cmp	r6, #0
 800fafc:	d052      	beq.n	800fba4 <ui_save_file+0xb8>
  if (ui_mode != UI_NORMAL && (file_opt[format].opt & FILE_OPT_REDRAW))
 800fafe:	4a2c      	ldr	r2, [pc, #176]	@ (800fbb0 <ui_save_file+0xc4>)
 800fb00:	7812      	ldrb	r2, [r2, #0]
 800fb02:	4604      	mov	r4, r0
 800fb04:	460d      	mov	r5, r1
 800fb06:	ea4f 1801 	mov.w	r8, r1, lsl #4
 800fb0a:	b132      	cbz	r2, 800fb1a <ui_save_file+0x2e>
 800fb0c:	68db      	ldr	r3, [r3, #12]
 800fb0e:	07db      	lsls	r3, r3, #31
 800fb10:	d503      	bpl.n	800fb1a <ui_save_file+0x2e>
    ui_mode_normal();
 800fb12:	f7fe fe0b 	bl	800e72c <ui_mode_normal>
    draw_all();
 800fb16:	f7fc fe4f 	bl	800c7b8 <draw_all>
    plot_printf(fs_filename, FF_LFN_BUF, "VNA_%06x_%06x.%s", dr, tr, file_opt[format].ext);
 800fb1a:	f857 2008 	ldr.w	r2, [r7, r8]
  if (name == NULL)
 800fb1e:	b984      	cbnz	r4, 800fb42 <ui_save_file+0x56>
    uint32_t tr = rtc_get_tr_bcd(); // TR read first
 800fb20:	4924      	ldr	r1, [pc, #144]	@ (800fbb4 <ui_save_file+0xc8>)
 800fb22:	680b      	ldr	r3, [r1, #0]
    uint32_t dr = rtc_get_dr_bcd(); // DR read second
 800fb24:	6849      	ldr	r1, [r1, #4]
    plot_printf(fs_filename, FF_LFN_BUF, "VNA_%06x_%06x.%s", dr, tr, file_opt[format].ext);
 800fb26:	9201      	str	r2, [sp, #4]
    uint32_t tr = rtc_get_tr_bcd(); // TR read first
 800fb28:	f003 337f 	and.w	r3, r3, #2139062143	@ 0x7f7f7f7f
 800fb2c:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
    plot_printf(fs_filename, FF_LFN_BUF, "VNA_%06x_%06x.%s", dr, tr, file_opt[format].ext);
 800fb30:	9300      	str	r3, [sp, #0]
 800fb32:	4b21      	ldr	r3, [pc, #132]	@ (800fbb8 <ui_save_file+0xcc>)
 800fb34:	4a21      	ldr	r2, [pc, #132]	@ (800fbbc <ui_save_file+0xd0>)
 800fb36:	400b      	ands	r3, r1
 800fb38:	a802      	add	r0, sp, #8
 800fb3a:	2120      	movs	r1, #32
 800fb3c:	f7f3 f918 	bl	8002d70 <plot_printf>
 800fb40:	e006      	b.n	800fb50 <ui_save_file+0x64>
    plot_printf(fs_filename, FF_LFN_BUF, "%s.%s", name, file_opt[format].ext);
 800fb42:	9200      	str	r2, [sp, #0]
 800fb44:	4623      	mov	r3, r4
 800fb46:	4a1e      	ldr	r2, [pc, #120]	@ (800fbc0 <ui_save_file+0xd4>)
 800fb48:	2120      	movs	r1, #32
 800fb4a:	a802      	add	r0, sp, #8
 800fb4c:	f7f3 f910 	bl	8002d70 <plot_printf>
  FRESULT res = f_mount(fs_volume, "", 1);
 800fb50:	491c      	ldr	r1, [pc, #112]	@ (800fbc4 <ui_save_file+0xd8>)
 800fb52:	481d      	ldr	r0, [pc, #116]	@ (800fbc8 <ui_save_file+0xdc>)
 800fb54:	2201      	movs	r2, #1
 800fb56:	f7f4 fef5 	bl	8004944 <f_mount>
  if (res != FR_OK)
 800fb5a:	4604      	mov	r4, r0
 800fb5c:	b968      	cbnz	r0, 800fb7a <ui_save_file+0x8e>
  res = f_open(fs_file, fs_filename, FA_CREATE_ALWAYS | FA_READ | FA_WRITE);
 800fb5e:	481b      	ldr	r0, [pc, #108]	@ (800fbcc <ui_save_file+0xe0>)
 800fb60:	220b      	movs	r2, #11
 800fb62:	a902      	add	r1, sp, #8
 800fb64:	f7f4 ff10 	bl	8004988 <f_open>
  if (res == FR_OK)
 800fb68:	4604      	mov	r4, r0
 800fb6a:	b930      	cbnz	r0, 800fb7a <ui_save_file+0x8e>
    res = save(fs_file, format);
 800fb6c:	4817      	ldr	r0, [pc, #92]	@ (800fbcc <ui_save_file+0xe0>)
 800fb6e:	4629      	mov	r1, r5
 800fb70:	47b0      	blx	r6
 800fb72:	4604      	mov	r4, r0
    f_close(fs_file);
 800fb74:	4815      	ldr	r0, [pc, #84]	@ (800fbcc <ui_save_file+0xe0>)
 800fb76:	f7f5 fa93 	bl	80050a0 <f_close>
  if (keyboard_temp == 1)
 800fb7a:	4b15      	ldr	r3, [pc, #84]	@ (800fbd0 <ui_save_file+0xe4>)
 800fb7c:	781b      	ldrb	r3, [r3, #0]
 800fb7e:	2b01      	cmp	r3, #1
 800fb80:	d101      	bne.n	800fb86 <ui_save_file+0x9a>
    toggle_sweep();
 800fb82:	f7f6 fa45 	bl	8006010 <toggle_sweep>
  ui_message_box("SD CARD SAVE", res == FR_OK ? fs_filename : "  Fail write  ", 2000);
 800fb86:	4913      	ldr	r1, [pc, #76]	@ (800fbd4 <ui_save_file+0xe8>)
 800fb88:	4813      	ldr	r0, [pc, #76]	@ (800fbd8 <ui_save_file+0xec>)
 800fb8a:	ab02      	add	r3, sp, #8
 800fb8c:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800fb90:	2c00      	cmp	r4, #0
 800fb92:	bf08      	it	eq
 800fb94:	4619      	moveq	r1, r3
 800fb96:	f7ff fecb 	bl	800f930 <ui_message_box>
  request_to_redraw(REDRAW_AREA | REDRAW_FREQUENCY);
 800fb9a:	200a      	movs	r0, #10
 800fb9c:	f7fc fde4 	bl	800c768 <request_to_redraw>
  ui_mode_normal();
 800fba0:	f7fe fdc4 	bl	800e72c <ui_mode_normal>
}
 800fba4:	b00a      	add	sp, #40	@ 0x28
 800fba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fbaa:	bf00      	nop
 800fbac:	08016b9c 	.word	0x08016b9c
 800fbb0:	20008a0c 	.word	0x20008a0c
 800fbb4:	40002800 	.word	0x40002800
 800fbb8:	00ff1f3f 	.word	0x00ff1f3f
 800fbbc:	08014ad6 	.word	0x08014ad6
 800fbc0:	08014ae7 	.word	0x08014ae7
 800fbc4:	08014855 	.word	0x08014855
 800fbc8:	20009800 	.word	0x20009800
 800fbcc:	200095b0 	.word	0x200095b0
 800fbd0:	20008a06 	.word	0x20008a06
 800fbd4:	08014ac7 	.word	0x08014ac7
 800fbd8:	08014aed 	.word	0x08014aed

0800fbdc <menu_sdcard_cb>:
{
 800fbdc:	b510      	push	{r4, lr}
  keyboard_temp = (sweep_mode & SWEEP_ENABLE) ? 1 : 0;
 800fbde:	4b10      	ldr	r3, [pc, #64]	@ (800fc20 <menu_sdcard_cb+0x44>)
 800fbe0:	4a10      	ldr	r2, [pc, #64]	@ (800fc24 <menu_sdcard_cb+0x48>)
 800fbe2:	781b      	ldrb	r3, [r3, #0]
 800fbe4:	f003 0301 	and.w	r3, r3, #1
{
 800fbe8:	4604      	mov	r4, r0
  keyboard_temp = (sweep_mode & SWEEP_ENABLE) ? 1 : 0;
 800fbea:	7013      	strb	r3, [r2, #0]
  if (keyboard_temp)
 800fbec:	b10b      	cbz	r3, 800fbf2 <menu_sdcard_cb+0x16>
    toggle_sweep();
 800fbee:	f7f6 fa0f 	bl	8006010 <toggle_sweep>
  if (data == FMT_BMP_FILE && VNA_MODE(VNA_MODE_TIFF))
 800fbf2:	4b0d      	ldr	r3, [pc, #52]	@ (800fc28 <menu_sdcard_cb+0x4c>)
 800fbf4:	2c02      	cmp	r4, #2
 800fbf6:	8a9b      	ldrh	r3, [r3, #20]
 800fbf8:	d103      	bne.n	800fc02 <menu_sdcard_cb+0x26>
    return FMT_TIF_FILE;
 800fbfa:	f413 7f80 	tst.w	r3, #256	@ 0x100
 800fbfe:	bf18      	it	ne
 800fc00:	2403      	movne	r4, #3
  if (VNA_MODE(VNA_MODE_AUTO_NAME))
 800fc02:	07db      	lsls	r3, r3, #31
 800fc04:	d505      	bpl.n	800fc12 <menu_sdcard_cb+0x36>
    ui_save_file(NULL, data);
 800fc06:	b2e1      	uxtb	r1, r4
 800fc08:	2000      	movs	r0, #0
}
 800fc0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ui_save_file(NULL, data);
 800fc0e:	f7ff bf6d 	b.w	800faec <ui_save_file>
    ui_mode_keypad(data + KM_S1P_NAME); // If no auto name, call text keyboard input
 800fc12:	f104 001b 	add.w	r0, r4, #27
}
 800fc16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ui_mode_keypad(data + KM_S1P_NAME); // If no auto name, call text keyboard input
 800fc1a:	f7fe bdf9 	b.w	800e810 <ui_mode_keypad>
 800fc1e:	bf00      	nop
 800fc20:	200003c4 	.word	0x200003c4
 800fc24:	20008a06 	.word	0x20008a06
 800fc28:	20000318 	.word	0x20000318

0800fc2c <ui_normal_touch>:
  return TRUE;
}
#endif

static void ui_normal_touch(int touch_x, int touch_y)
{
 800fc2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fc30:	ed2d 8b02 	vpush	{d8}
 800fc34:	b089      	sub	sp, #36	@ 0x24
  touch_x -= OFFSETX;
 800fc36:	f1a0 060f 	sub.w	r6, r0, #15
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800fc3a:	b20b      	sxth	r3, r1
 800fc3c:	4d8c      	ldr	r5, [pc, #560]	@ (800fe70 <ui_normal_touch+0x244>)
  touch_x -= OFFSETX;
 800fc3e:	9606      	str	r6, [sp, #24]
{
 800fc40:	4607      	mov	r7, r0
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800fc42:	b236      	sxth	r6, r6
 800fc44:	4618      	mov	r0, r3
 800fc46:	4632      	mov	r2, r6
 800fc48:	463b      	mov	r3, r7
 800fc4a:	9107      	str	r1, [sp, #28]
  int min_dist = MARKER_PICKUP_DISTANCE * MARKER_PICKUP_DISTANCE;
 800fc4c:	f44f 7961 	mov.w	r9, #900	@ 0x384
  int i = MARKER_INVALID, mt, m, t;
 800fc50:	f04f 3aff 	mov.w	sl, #4294967295
  for (t = 0; t < TRACES_MAX; t++)
 800fc54:	f04f 0b00 	mov.w	fp, #0
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800fc58:	462e      	mov	r6, r5
 800fc5a:	4607      	mov	r7, r0
    if (!trace[t].enabled)
 800fc5c:	f896 0028 	ldrb.w	r0, [r6, #40]	@ 0x28
 800fc60:	b330      	cbz	r0, 800fcb0 <ui_normal_touch+0x84>
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800fc62:	fa4f f08b 	sxtb.w	r0, fp
 800fc66:	e9cd 0602 	strd	r0, r6, [sp, #8]
 800fc6a:	462c      	mov	r4, r5
 800fc6c:	461e      	mov	r6, r3
    for (m = 0; m < MARKERS_MAX; m++)
 800fc6e:	f04f 0800 	mov.w	r8, #0
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800fc72:	463b      	mov	r3, r7
 800fc74:	460f      	mov	r7, r1
      if (!markers[m].enabled)
 800fc76:	f894 1058 	ldrb.w	r1, [r4, #88]	@ 0x58
 800fc7a:	b171      	cbz	r1, 800fc9a <ui_normal_touch+0x6e>
      int dist = distance_to_index(t, markers[m].index, touch_x, touch_y);
 800fc7c:	f8b4 105a 	ldrh.w	r1, [r4, #90]	@ 0x5a
 800fc80:	9802      	ldr	r0, [sp, #8]
 800fc82:	e9cd 2304 	strd	r2, r3, [sp, #16]
 800fc86:	f7fc fc13 	bl	800c4b0 <distance_to_index>
      if (dist < min_dist)
 800fc8a:	4548      	cmp	r0, r9
 800fc8c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800fc90:	da03      	bge.n	800fc9a <ui_normal_touch+0x6e>
        min_dist = dist;
 800fc92:	4681      	mov	r9, r0
        mt = t;
 800fc94:	f8cd b004 	str.w	fp, [sp, #4]
        i = m;
 800fc98:	46c2      	mov	sl, r8
    for (m = 0; m < MARKERS_MAX; m++)
 800fc9a:	f108 0801 	add.w	r8, r8, #1
 800fc9e:	f1b8 0f08 	cmp.w	r8, #8
 800fca2:	f104 0408 	add.w	r4, r4, #8
 800fca6:	d1e6      	bne.n	800fc76 <ui_normal_touch+0x4a>
 800fca8:	4639      	mov	r1, r7
 800fcaa:	461f      	mov	r7, r3
 800fcac:	4633      	mov	r3, r6
 800fcae:	9e03      	ldr	r6, [sp, #12]
  for (t = 0; t < TRACES_MAX; t++)
 800fcb0:	f10b 0b01 	add.w	fp, fp, #1
 800fcb4:	f1bb 0f04 	cmp.w	fp, #4
 800fcb8:	f106 060c 	add.w	r6, r6, #12
 800fcbc:	d1ce      	bne.n	800fc5c <ui_normal_touch+0x30>
  if (i == MARKER_INVALID)
 800fcbe:	f1ba 3fff 	cmp.w	sl, #4294967295
 800fcc2:	461f      	mov	r7, r3
 800fcc4:	460c      	mov	r4, r1
 800fcc6:	d036      	beq.n	800fd36 <ui_normal_touch+0x10a>
  if (active_marker != i)
 800fcc8:	4b69      	ldr	r3, [pc, #420]	@ (800fe70 <ui_normal_touch+0x244>)
 800fcca:	f993 201d 	ldrsb.w	r2, [r3, #29]
 800fcce:	4552      	cmp	r2, sl
    previous_marker = active_marker;
 800fcd0:	bf1c      	itt	ne
 800fcd2:	779a      	strbne	r2, [r3, #30]
    active_marker = i;
 800fcd4:	f883 a01d 	strbne.w	sl, [r3, #29]
  props_mode &= ~TD_MARKER_TRACK;
 800fcd8:	8b2b      	ldrh	r3, [r5, #24]
  select_lever_mode(LM_MARKER);
 800fcda:	2000      	movs	r0, #0
  props_mode &= ~TD_MARKER_TRACK;
 800fcdc:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800fce0:	832b      	strh	r3, [r5, #24]
  select_lever_mode(LM_MARKER);
 800fce2:	f7fe fbbb 	bl	800e45c <select_lever_mode>
  set_active_trace(mt);
 800fce6:	9801      	ldr	r0, [sp, #4]
 800fce8:	f7f8 f9ac 	bl	8008044 <set_active_trace>
    touch_position(&touch_x, &touch_y);
 800fcec:	a907      	add	r1, sp, #28
 800fcee:	a806      	add	r0, sp, #24
 800fcf0:	f7fe fa56 	bl	800e1a0 <touch_position>
    int index = search_nearest_index(touch_x - OFFSETX, touch_y - OFFSETY, current_trace);
 800fcf4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800fcf8:	f995 201c 	ldrsb.w	r2, [r5, #28]
 800fcfc:	380f      	subs	r0, #15
 800fcfe:	f7fc fbf1 	bl	800c4e4 <search_nearest_index>
    if (index >= 0 && markers[active_marker].index != index)
 800fd02:	1e01      	subs	r1, r0, #0
 800fd04:	db0e      	blt.n	800fd24 <ui_normal_touch+0xf8>
 800fd06:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800fd0a:	eb05 03c0 	add.w	r3, r5, r0, lsl #3
 800fd0e:	f8b3 305a 	ldrh.w	r3, [r3, #90]	@ 0x5a
 800fd12:	4299      	cmp	r1, r3
 800fd14:	d006      	beq.n	800fd24 <ui_normal_touch+0xf8>
      set_marker_index(active_marker, index);
 800fd16:	f7f7 fd53 	bl	80077c0 <set_marker_index>
      redraw_marker(active_marker);
 800fd1a:	f995 001d 	ldrsb.w	r0, [r5, #29]
 800fd1e:	f7fe f9db 	bl	800e0d8 <redraw_marker>
 800fd22:	e003      	b.n	800fd2c <ui_normal_touch+0x100>
      chThdSleepMilliseconds(50); // Not check new position too fast
 800fd24:	f241 3088 	movw	r0, #5000	@ 0x1388
 800fd28:	f7f1 f8b2 	bl	8000e90 <chThdSleep>
  } while (touch_check() != EVT_TOUCH_RELEASED);
 800fd2c:	f7fe fb60 	bl	800e3f0 <touch_check>
 800fd30:	2803      	cmp	r0, #3
 800fd32:	d1db      	bne.n	800fcec <ui_normal_touch+0xc0>
 800fd34:	e097      	b.n	800fe66 <ui_normal_touch+0x23a>
  if (touch_y < HEIGHT || touch_x < FREQUENCIES_XPOS3 || touch_x > FREQUENCIES_XPOS2)
 800fd36:	f5b1 7f98 	cmp.w	r1, #304	@ 0x130
 800fd3a:	db18      	blt.n	800fd6e <ui_normal_touch+0x142>
 800fd3c:	3bce      	subs	r3, #206	@ 0xce
 800fd3e:	2b78      	cmp	r3, #120	@ 0x78
 800fd40:	d809      	bhi.n	800fd56 <ui_normal_touch+0x12a>
  touch_wait_release();
 800fd42:	f7fe fb85 	bl	800e450 <touch_wait_release>
  menu_sdcard_cb(FMT_BMP_FILE);
 800fd46:	2002      	movs	r0, #2
  if (touch_apply_ref_scale(touch_x, touch_y))
    return; // Try apply ref / scale
  // default: switch menu mode after release
  touch_wait_release();
  ui_mode_menu();
}
 800fd48:	b009      	add	sp, #36	@ 0x24
 800fd4a:	ecbd 8b02 	vpop	{d8}
 800fd4e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  menu_sdcard_cb(FMT_BMP_FILE);
 800fd52:	f7ff bf43 	b.w	800fbdc <menu_sdcard_cb>
  if (touch_y > HEIGHT && (props_mode & DOMAIN_MODE) == DOMAIN_FREQ) // Only for frequency domain
 800fd56:	f5b1 7f98 	cmp.w	r1, #304	@ 0x130
 800fd5a:	d039      	beq.n	800fdd0 <ui_normal_touch+0x1a4>
 800fd5c:	8b2b      	ldrh	r3, [r5, #24]
 800fd5e:	07d9      	lsls	r1, r3, #31
 800fd60:	d436      	bmi.n	800fdd0 <ui_normal_touch+0x1a4>
    mode = touch_x < FREQUENCIES_XPOS2 ? LM_FREQ_0 : LM_FREQ_1;
 800fd62:	f5b7 7fa3 	cmp.w	r7, #326	@ 0x146
 800fd66:	bfac      	ite	ge
 800fd68:	2403      	movge	r4, #3
 800fd6a:	2402      	movlt	r4, #2
 800fd6c:	e00f      	b.n	800fd8e <ui_normal_touch+0x162>
  if (touch_y < UI_MARKER_Y0)
 800fd6e:	291d      	cmp	r1, #29
 800fd70:	dc2e      	bgt.n	800fdd0 <ui_normal_touch+0x1a4>
    mode = (touch_x < (LCD_WIDTH / 2) && get_electrical_delay() != 0.0f) ? LM_EDELAY : LM_MARKER;
 800fd72:	2bef      	cmp	r3, #239	@ 0xef
 800fd74:	dc0a      	bgt.n	800fd8c <ui_normal_touch+0x160>
 800fd76:	f7f9 fb5b 	bl	8009430 <get_electrical_delay>
 800fd7a:	eeb5 0a40 	vcmp.f32	s0, #0.0
 800fd7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800fd82:	bf14      	ite	ne
 800fd84:	2401      	movne	r4, #1
 800fd86:	2400      	moveq	r4, #0
 800fd88:	00a4      	lsls	r4, r4, #2
 800fd8a:	e000      	b.n	800fd8e <ui_normal_touch+0x162>
 800fd8c:	2400      	movs	r4, #0
  touch_wait_release();
 800fd8e:	f7fe fb5f 	bl	800e450 <touch_wait_release>
  if (select_lever_mode(mode))
 800fd92:	4620      	mov	r0, r4
 800fd94:	f7fe fb62 	bl	800e45c <select_lever_mode>
 800fd98:	2800      	cmp	r0, #0
 800fd9a:	d164      	bne.n	800fe66 <ui_normal_touch+0x23a>
  switch (mode)
 800fd9c:	2c03      	cmp	r4, #3
 800fd9e:	d008      	beq.n	800fdb2 <ui_normal_touch+0x186>
 800fda0:	2c04      	cmp	r4, #4
 800fda2:	d013      	beq.n	800fdcc <ui_normal_touch+0x1a0>
 800fda4:	2c02      	cmp	r4, #2
 800fda6:	d15e      	bne.n	800fe66 <ui_normal_touch+0x23a>
    ui_mode_keypad(FREQ_IS_CENTERSPAN() ? KM_CENTER : KM_START);
 800fda8:	8b28      	ldrh	r0, [r5, #24]
 800fdaa:	1140      	asrs	r0, r0, #5
 800fdac:	f000 0002 	and.w	r0, r0, #2
 800fdb0:	e005      	b.n	800fdbe <ui_normal_touch+0x192>
    ui_mode_keypad(FREQ_IS_CENTERSPAN() ? KM_SPAN : KM_STOP);
 800fdb2:	8b2b      	ldrh	r3, [r5, #24]
 800fdb4:	f013 0f40 	tst.w	r3, #64	@ 0x40
 800fdb8:	bf14      	ite	ne
 800fdba:	4620      	movne	r0, r4
 800fdbc:	2001      	moveq	r0, #1
}
 800fdbe:	b009      	add	sp, #36	@ 0x24
 800fdc0:	ecbd 8b02 	vpop	{d8}
 800fdc4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ui_mode_keypad(FREQ_IS_CENTERSPAN() ? KM_SPAN : KM_STOP);
 800fdc8:	f7fe bd22 	b.w	800e810 <ui_mode_keypad>
    ui_mode_keypad(KM_EDELAY);
 800fdcc:	200f      	movs	r0, #15
 800fdce:	e7f6      	b.n	800fdbe <ui_normal_touch+0x192>
  int t = current_trace;
 800fdd0:	4b27      	ldr	r3, [pc, #156]	@ (800fe70 <ui_normal_touch+0x244>)
 800fdd2:	f993 501c 	ldrsb.w	r5, [r3, #28]
  if (t == TRACE_INVALID || trace[t].type == TRC_SMITH)
 800fdd6:	1c6a      	adds	r2, r5, #1
 800fdd8:	d03c      	beq.n	800fe54 <ui_normal_touch+0x228>
 800fdda:	220c      	movs	r2, #12
 800fddc:	fb02 3305 	mla	r3, r2, r5, r3
 800fde0:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 800fde4:	2a03      	cmp	r2, #3
 800fde6:	d035      	beq.n	800fe54 <ui_normal_touch+0x228>
  if (touch_x < UI_SCALE_REF_X0 || touch_x > UI_SCALE_REF_X1 ||
 800fde8:	3f0a      	subs	r7, #10
 800fdea:	2f14      	cmp	r7, #20
 800fdec:	d832      	bhi.n	800fe54 <ui_normal_touch+0x228>
      touch_y < OFFSETY || touch_y > AREA_HEIGHT_NORMAL)
 800fdee:	f5b4 7f99 	cmp.w	r4, #306	@ 0x132
 800fdf2:	da2f      	bge.n	800fe54 <ui_normal_touch+0x228>
  if (touch_y < GRIDY * 1 * NGRIDY / 4)
 800fdf4:	2c4b      	cmp	r4, #75	@ 0x4b
  float ref = get_trace_refpos(t);
 800fdf6:	ed93 7a0c 	vldr	s14, [r3, #48]	@ 0x30
  float scale = get_trace_scale(t);
 800fdfa:	ed93 0a0b 	vldr	s0, [r3, #44]	@ 0x2c
  if (touch_y < GRIDY * 1 * NGRIDY / 4)
 800fdfe:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 800fe02:	dc02      	bgt.n	800fe0a <ui_normal_touch+0x1de>
    ref += 0.5f;
 800fe04:	ee37 8a27 	vadd.f32	s16, s14, s15
 800fe08:	e013      	b.n	800fe32 <ui_normal_touch+0x206>
  else if (touch_y < GRIDY * 2 * NGRIDY / 4)
 800fe0a:	2c97      	cmp	r4, #151	@ 0x97
 800fe0c:	dc04      	bgt.n	800fe18 <ui_normal_touch+0x1ec>
    scale *= 2.0f;
 800fe0e:	ee30 0a00 	vadd.f32	s0, s0, s0
    ref = ref / 2.0f - NGRIDY / 4 + NGRIDY / 2;
 800fe12:	eeb0 8a00 	vmov.f32	s16, #0	@ 0x40000000  2.0
 800fe16:	e007      	b.n	800fe28 <ui_normal_touch+0x1fc>
  else if (touch_y < GRIDY * 3 * NGRIDY / 4)
 800fe18:	2ce3      	cmp	r4, #227	@ 0xe3
 800fe1a:	dc08      	bgt.n	800fe2e <ui_normal_touch+0x202>
    scale /= 2.0f;
 800fe1c:	ee20 0a27 	vmul.f32	s0, s0, s15
    ref = ref * 2.0f - NGRIDY + NGRIDY / 2;
 800fe20:	eeb9 8a00 	vmov.f32	s16, #144	@ 0xc0800000 -4.0
 800fe24:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 800fe28:	eea7 8a27 	vfma.f32	s16, s14, s15
 800fe2c:	e001      	b.n	800fe32 <ui_normal_touch+0x206>
    ref -= 0.5f;
 800fe2e:	ee37 8a67 	vsub.f32	s16, s14, s15
  set_trace_scale(t, scale);
 800fe32:	4628      	mov	r0, r5
 800fe34:	f7f8 f914 	bl	8008060 <set_trace_scale>
  set_trace_refpos(t, ref);
 800fe38:	4628      	mov	r0, r5
 800fe3a:	eeb0 0a48 	vmov.f32	s0, s16
 800fe3e:	f7f8 f923 	bl	8008088 <set_trace_refpos>
  chThdSleepMilliseconds(200);
 800fe42:	f644 6020 	movw	r0, #20000	@ 0x4e20
}
 800fe46:	b009      	add	sp, #36	@ 0x24
 800fe48:	ecbd 8b02 	vpop	{d8}
 800fe4c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  chThdSleepMilliseconds(200);
 800fe50:	f7f1 b81e 	b.w	8000e90 <chThdSleep>
  touch_wait_release();
 800fe54:	f7fe fafc 	bl	800e450 <touch_wait_release>
}
 800fe58:	b009      	add	sp, #36	@ 0x24
 800fe5a:	ecbd 8b02 	vpop	{d8}
 800fe5e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ui_mode_menu();
 800fe62:	f7ff bbbf 	b.w	800f5e4 <ui_mode_menu>
}
 800fe66:	b009      	add	sp, #36	@ 0x24
 800fe68:	ecbd 8b02 	vpop	{d8}
 800fe6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fe70:	20000aa8 	.word	0x20000aa8

0800fe74 <input_filename>:
  if (b)
 800fe74:	b919      	cbnz	r1, 800fe7e <input_filename+0xa>
  ui_save_file(kp_buf, data);
 800fe76:	b2c1      	uxtb	r1, r0
 800fe78:	4801      	ldr	r0, [pc, #4]	@ (800fe80 <input_filename+0xc>)
 800fe7a:	f7ff be37 	b.w	800faec <ui_save_file>
}
 800fe7e:	4770      	bx	lr
 800fe80:	20008a10 	.word	0x20008a10

0800fe84 <browser_key_press>:
  switch (key) {
 800fe84:	2802      	cmp	r0, #2
 800fe86:	f000 80ef 	beq.w	8010068 <browser_key_press+0x1e4>
 800fe8a:	dc03      	bgt.n	800fe94 <browser_key_press+0x10>
      page = current_page;
 800fe8c:	4b78      	ldr	r3, [pc, #480]	@ (8010070 <browser_key_press+0x1ec>)
 800fe8e:	881a      	ldrh	r2, [r3, #0]
      if (key == FILE_BUTTON_LEFT  && --current_page < 1) current_page = page_count;
 800fe90:	b1a0      	cbz	r0, 800febc <browser_key_press+0x38>
 800fe92:	e008      	b.n	800fea6 <browser_key_press+0x22>
  switch (key) {
 800fe94:	2803      	cmp	r0, #3
 800fe96:	d11f      	bne.n	800fed8 <browser_key_press+0x54>
      browser_mode^= BROWSER_DELETE;
 800fe98:	4a76      	ldr	r2, [pc, #472]	@ (8010074 <browser_key_press+0x1f0>)
 800fe9a:	8813      	ldrh	r3, [r2, #0]
 800fe9c:	f083 0301 	eor.w	r3, r3, #1
 800fea0:	8013      	strh	r3, [r2, #0]
      browser_draw_buttons();
 800fea2:	f7fe bbfb 	b.w	800e69c <browser_draw_buttons>
      if (key == FILE_BUTTON_RIGHT && ++current_page > page_count) current_page = 1;
 800fea6:	4974      	ldr	r1, [pc, #464]	@ (8010078 <browser_key_press+0x1f4>)
 800fea8:	1c50      	adds	r0, r2, #1
 800feaa:	8809      	ldrh	r1, [r1, #0]
 800feac:	b280      	uxth	r0, r0
 800feae:	4281      	cmp	r1, r0
 800feb0:	8018      	strh	r0, [r3, #0]
 800feb2:	f080 80d4 	bcs.w	801005e <browser_key_press+0x1da>
 800feb6:	2101      	movs	r1, #1
 800feb8:	4608      	mov	r0, r1
 800feba:	e008      	b.n	800fece <browser_key_press+0x4a>
      if (key == FILE_BUTTON_LEFT  && --current_page < 1) current_page = page_count;
 800febc:	1e50      	subs	r0, r2, #1
 800febe:	b280      	uxth	r0, r0
 800fec0:	8018      	strh	r0, [r3, #0]
 800fec2:	2800      	cmp	r0, #0
 800fec4:	f040 80cb 	bne.w	801005e <browser_key_press+0x1da>
 800fec8:	496b      	ldr	r1, [pc, #428]	@ (8010078 <browser_key_press+0x1f4>)
 800feca:	8808      	ldrh	r0, [r1, #0]
 800fecc:	4601      	mov	r1, r0
      if (page != current_page)
 800fece:	4282      	cmp	r2, r0
      if (key == FILE_BUTTON_RIGHT && ++current_page > page_count) current_page = 1;
 800fed0:	8019      	strh	r1, [r3, #0]
      if (page != current_page)
 800fed2:	f000 80cb 	beq.w	801006c <browser_key_press+0x1e8>
 800fed6:	e0c2      	b.n	801005e <browser_key_press+0x1da>
static void browser_key_press(int key) {
 800fed8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      browser_open_file(key - FILE_BUTTON_FILE + (current_page - 1) * FILES_PER_PAGE);
 800fedc:	f8df 9190 	ldr.w	r9, [pc, #400]	@ 8010070 <browser_key_press+0x1ec>
  if ((uint16_t)sel >= file_count) return;
 800fee0:	4e66      	ldr	r6, [pc, #408]	@ (801007c <browser_key_press+0x1f8>)
      browser_open_file(key - FILE_BUTTON_FILE + (current_page - 1) * FILES_PER_PAGE);
 800fee2:	f8b9 3000 	ldrh.w	r3, [r9]
 800fee6:	221e      	movs	r2, #30
 800fee8:	3b01      	subs	r3, #1
 800feea:	3804      	subs	r0, #4
 800feec:	fb02 0403 	mla	r4, r2, r3, r0
  if ((uint16_t)sel >= file_count) return;
 800fef0:	8832      	ldrh	r2, [r6, #0]
 800fef2:	b2a3      	uxth	r3, r4
 800fef4:	429a      	cmp	r2, r3
static void browser_key_press(int key) {
 800fef6:	b0a8      	sub	sp, #160	@ 0xa0
  if ((uint16_t)sel >= file_count) return;
 800fef8:	f240 80a0 	bls.w	801003c <browser_key_press+0x1b8>
  if (f_mount(fs_volume, "", 1) != FR_OK) return;
 800fefc:	4960      	ldr	r1, [pc, #384]	@ (8010080 <browser_key_press+0x1fc>)
 800fefe:	4861      	ldr	r0, [pc, #388]	@ (8010084 <browser_key_press+0x200>)
 800ff00:	2201      	movs	r2, #1
 800ff02:	f7f4 fd1f 	bl	8004944 <f_mount>
 800ff06:	2800      	cmp	r0, #0
 800ff08:	f040 8098 	bne.w	801003c <browser_key_press+0x1b8>
  if (sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) return;  // open dir
 800ff0c:	f8df 8188 	ldr.w	r8, [pc, #392]	@ 8010098 <browser_key_press+0x214>
 800ff10:	4f5d      	ldr	r7, [pc, #372]	@ (8010088 <browser_key_press+0x204>)
 800ff12:	783b      	ldrb	r3, [r7, #0]
  return f_opendir(dp, path);
 800ff14:	495a      	ldr	r1, [pc, #360]	@ (8010080 <browser_key_press+0x1fc>)
  if (sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) return;  // open dir
 800ff16:	011b      	lsls	r3, r3, #4
  return f_opendir(dp, path);
 800ff18:	a812      	add	r0, sp, #72	@ 0x48
  dp->pat = pattern;
 800ff1a:	f858 3003 	ldr.w	r3, [r8, r3]
 800ff1e:	9326      	str	r3, [sp, #152]	@ 0x98
  return f_opendir(dp, path);
 800ff20:	f7f5 f8ce 	bl	80050c0 <f_opendir>
  if (sd_open_dir(&dj, "", file_opt[keypad_mode].ext) != FR_OK) return;  // open dir
 800ff24:	2800      	cmp	r0, #0
 800ff26:	f040 8089 	bne.w	801003c <browser_key_press+0x1b8>
  cnt = sel;
 800ff2a:	4625      	mov	r5, r4
  while (sd_findnext(&dj, &fno) == FR_OK && cnt != 0) cnt--;             // skip cnt files
 800ff2c:	a902      	add	r1, sp, #8
 800ff2e:	a812      	add	r0, sp, #72	@ 0x48
 800ff30:	f7fe ffa4 	bl	800ee7c <sd_findnext>
 800ff34:	b910      	cbnz	r0, 800ff3c <browser_key_press+0xb8>
 800ff36:	b10d      	cbz	r5, 800ff3c <browser_key_press+0xb8>
 800ff38:	3d01      	subs	r5, #1
 800ff3a:	e7f7      	b.n	800ff2c <browser_key_press+0xa8>
  f_closedir(&dj);
 800ff3c:	a812      	add	r0, sp, #72	@ 0x48
 800ff3e:	f7f5 f903 	bl	8005148 <f_closedir>
  if (browser_mode & BROWSER_DELETE) {f_unlink(fno.fname); return;}
 800ff42:	4b4c      	ldr	r3, [pc, #304]	@ (8010074 <browser_key_press+0x1f0>)
 800ff44:	881b      	ldrh	r3, [r3, #0]
 800ff46:	f003 0301 	and.w	r3, r3, #1
  if (cnt != 0) return;
 800ff4a:	2d00      	cmp	r5, #0
 800ff4c:	d176      	bne.n	801003c <browser_key_press+0x1b8>
  if (browser_mode & BROWSER_DELETE) {f_unlink(fno.fname); return;}
 800ff4e:	b123      	cbz	r3, 800ff5a <browser_key_press+0xd6>
 800ff50:	f10d 0022 	add.w	r0, sp, #34	@ 0x22
 800ff54:	f7f5 f93e 	bl	80051d4 <f_unlink>
 800ff58:	e070      	b.n	801003c <browser_key_press+0x1b8>
  file_load_cb_t load = file_opt[keypad_mode].load;
 800ff5a:	783b      	ldrb	r3, [r7, #0]
 800ff5c:	eb08 1303 	add.w	r3, r8, r3, lsl #4
 800ff60:	f8d3 a008 	ldr.w	sl, [r3, #8]
  if (load == NULL) return;
 800ff64:	f1ba 0f00 	cmp.w	sl, #0
 800ff68:	d068      	beq.n	801003c <browser_key_press+0x1b8>
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 800ff6a:	4629      	mov	r1, r5
 800ff6c:	2001      	movs	r0, #1
 800ff6e:	f001 f8a3 	bl	80110b8 <lcd_set_colors>
  if (f_open(fs_file, fno.fname, FA_READ) != FR_OK) return;
 800ff72:	4846      	ldr	r0, [pc, #280]	@ (801008c <browser_key_press+0x208>)
 800ff74:	2201      	movs	r2, #1
 800ff76:	f10d 0122 	add.w	r1, sp, #34	@ 0x22
 800ff7a:	f7f4 fd05 	bl	8004988 <f_open>
 800ff7e:	2800      	cmp	r0, #0
 800ff80:	d15c      	bne.n	801003c <browser_key_press+0x1b8>
  const char *error = load(fs_file, &fno, keypad_mode);
 800ff82:	783a      	ldrb	r2, [r7, #0]
 800ff84:	4841      	ldr	r0, [pc, #260]	@ (801008c <browser_key_press+0x208>)
 800ff86:	a902      	add	r1, sp, #8
 800ff88:	47d0      	blx	sl
 800ff8a:	4682      	mov	sl, r0
  f_close(fs_file);
 800ff8c:	483f      	ldr	r0, [pc, #252]	@ (801008c <browser_key_press+0x208>)
 800ff8e:	f7f5 f887 	bl	80050a0 <f_close>
  bool need_continue = file_opt[keypad_mode].opt & FILE_OPT_CONTINUE;
 800ff92:	783b      	ldrb	r3, [r7, #0]
 800ff94:	eb08 1303 	add.w	r3, r8, r3, lsl #4
 800ff98:	68dd      	ldr	r5, [r3, #12]
 800ff9a:	f005 0502 	and.w	r5, r5, #2
  if (error) {
 800ff9e:	f1ba 0f00 	cmp.w	sl, #0
 800ffa2:	d00b      	beq.n	800ffbc <browser_key_press+0x138>
    lcd_clear_screen();
 800ffa4:	f001 f822 	bl	8010fec <lcd_clear_screen>
    ui_message_box(error, fno.fname, need_continue ? 100 : 2000);
 800ffa8:	2d00      	cmp	r5, #0
 800ffaa:	bf0c      	ite	eq
 800ffac:	f44f 62fa 	moveq.w	r2, #2000	@ 0x7d0
 800ffb0:	2264      	movne	r2, #100	@ 0x64
 800ffb2:	f10d 0122 	add.w	r1, sp, #34	@ 0x22
 800ffb6:	4650      	mov	r0, sl
 800ffb8:	f7ff fcba 	bl	800f930 <ui_message_box>
  if (!need_continue) return;
 800ffbc:	2d00      	cmp	r5, #0
 800ffbe:	d03d      	beq.n	801003c <browser_key_press+0x1b8>
    uint16_t status = btn_check();
 800ffc0:	f7fe fa5c 	bl	800e47c <btn_check>
    if (status & EVT_UP  ) key = 1;
 800ffc4:	06c5      	lsls	r5, r0, #27
    if (status & EVT_DOWN) key = 0;
 800ffc6:	bf5a      	itte	pl
 800ffc8:	f3c0 1540 	ubfxpl	r5, r0, #5, #1
 800ffcc:	f105 35ff 	addpl.w	r5, r5, #4294967295
    if (status & EVT_UP  ) key = 1;
 800ffd0:	2501      	movmi	r5, #1
    if (status & EVT_BUTTON_SINGLE_CLICK) key = 2;
 800ffd2:	f010 0f01 	tst.w	r0, #1
 800ffd6:	bf18      	it	ne
 800ffd8:	2502      	movne	r5, #2
    status = touch_check();
 800ffda:	f7fe fa09 	bl	800e3f0 <touch_check>
    if (status == EVT_TOUCH_PRESSED || status == EVT_TOUCH_DOWN) {
 800ffde:	3801      	subs	r0, #1
 800ffe0:	b280      	uxth	r0, r0
 800ffe2:	2801      	cmp	r0, #1
 800ffe4:	d80f      	bhi.n	8010006 <browser_key_press+0x182>
      touch_position(&touch_x, &touch_y);
 800ffe6:	a901      	add	r1, sp, #4
 800ffe8:	4668      	mov	r0, sp
 800ffea:	f7fe f8d9 	bl	800e1a0 <touch_position>
           if (touch_x < LCD_WIDTH *1/3) key = 0;
 800ffee:	9b00      	ldr	r3, [sp, #0]
 800fff0:	2b9f      	cmp	r3, #159	@ 0x9f
 800fff2:	dd05      	ble.n	8010000 <browser_key_press+0x17c>
      else if (touch_x < LCD_WIDTH *2/3) key = 2;
 800fff4:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800fff8:	bfac      	ite	ge
 800fffa:	2501      	movge	r5, #1
 800fffc:	2502      	movlt	r5, #2
 800fffe:	e000      	b.n	8010002 <browser_key_press+0x17e>
           if (touch_x < LCD_WIDTH *1/3) key = 0;
 8010000:	2500      	movs	r5, #0
      touch_wait_release();
 8010002:	f7fe fa25 	bl	800e450 <touch_wait_release>
inline void delayMilliseconds(uint32_t ms) {_delay_8t(ms*125*STM32_CORE_CLOCK);}
 8010006:	4822      	ldr	r0, [pc, #136]	@ (8010090 <browser_key_press+0x20c>)
 8010008:	f7f9 fdec 	bl	8009be4 <_delay_8t>
         if (key == 0) {if (--sel < 0) sel = file_count - 1;}
 801000c:	b935      	cbnz	r5, 801001c <browser_key_press+0x198>
 801000e:	1e63      	subs	r3, r4, #1
 8010010:	d401      	bmi.n	8010016 <browser_key_press+0x192>
repeat:
 8010012:	461c      	mov	r4, r3
 8010014:	e77d      	b.n	800ff12 <browser_key_press+0x8e>
         if (key == 0) {if (--sel < 0) sel = file_count - 1;}
 8010016:	8833      	ldrh	r3, [r6, #0]
 8010018:	3b01      	subs	r3, #1
 801001a:	e00b      	b.n	8010034 <browser_key_press+0x1b0>
    else if (key == 1) {if (++sel > file_count - 1) sel = 0;}
 801001c:	2d01      	cmp	r5, #1
 801001e:	d105      	bne.n	801002c <browser_key_press+0x1a8>
 8010020:	8832      	ldrh	r2, [r6, #0]
 8010022:	1c63      	adds	r3, r4, #1
 8010024:	429a      	cmp	r2, r3
 8010026:	dcf4      	bgt.n	8010012 <browser_key_press+0x18e>
 8010028:	2300      	movs	r3, #0
 801002a:	e003      	b.n	8010034 <browser_key_press+0x1b0>
    else if (key == 2) break;
 801002c:	2d02      	cmp	r5, #2
 801002e:	d005      	beq.n	801003c <browser_key_press+0x1b8>
 8010030:	4623      	mov	r3, r4
 8010032:	e001      	b.n	8010038 <browser_key_press+0x1b4>
    if (old_sel != sel) goto repeat;
 8010034:	429c      	cmp	r4, r3
 8010036:	d1ec      	bne.n	8010012 <browser_key_press+0x18e>
    ui_message_box(error, fno.fname, need_continue ? 100 : 2000);
 8010038:	461c      	mov	r4, r3
 801003a:	e7c1      	b.n	800ffc0 <browser_key_press+0x13c>
      if (browser_mode & BROWSER_DELETE) {
 801003c:	4a0d      	ldr	r2, [pc, #52]	@ (8010074 <browser_key_press+0x1f0>)
 801003e:	8813      	ldrh	r3, [r2, #0]
 8010040:	07d9      	lsls	r1, r3, #31
 8010042:	d50e      	bpl.n	8010062 <browser_key_press+0x1de>
        file_count = 0;                      // Reeset file count (recalculate on draw page)
 8010044:	2100      	movs	r1, #0
 8010046:	8031      	strh	r1, [r6, #0]
        selection = -1;                      // Reset delection
 8010048:	4912      	ldr	r1, [pc, #72]	@ (8010094 <browser_key_press+0x210>)
 801004a:	20ff      	movs	r0, #255	@ 0xff
 801004c:	7008      	strb	r0, [r1, #0]
        browser_draw_page(current_page);
 801004e:	f8b9 0000 	ldrh.w	r0, [r9]
        browser_mode&=~BROWSER_DELETE;       // Exit file delete mode
 8010052:	f023 0301 	bic.w	r3, r3, #1
 8010056:	8013      	strh	r3, [r2, #0]
}
 8010058:	b028      	add	sp, #160	@ 0xa0
 801005a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        browser_draw_page(current_page);
 801005e:	f7ff bcb5 	b.w	800f9cc <browser_draw_page>
}
 8010062:	b028      	add	sp, #160	@ 0xa0
 8010064:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      ui_mode_normal(); // Exit
 8010068:	f7fe bb60 	b.w	800e72c <ui_mode_normal>
 801006c:	4770      	bx	lr
 801006e:	bf00      	nop
 8010070:	200089f4 	.word	0x200089f4
 8010074:	200089f2 	.word	0x200089f2
 8010078:	200089f6 	.word	0x200089f6
 801007c:	200089f8 	.word	0x200089f8
 8010080:	08014855 	.word	0x08014855
 8010084:	20009800 	.word	0x20009800
 8010088:	20008a07 	.word	0x20008a07
 801008c:	200095b0 	.word	0x200095b0
 8010090:	000dbba0 	.word	0x000dbba0
 8010094:	200003f0 	.word	0x200003f0
 8010098:	08016b9c 	.word	0x08016b9c

0801009c <ui_browser_touch>:
  browser_mode = 0;
  browser_draw_page(current_page);
}

// Process UI input for browser
static void ui_browser_touch(int touch_x, int touch_y) {
 801009c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  browser_btn_t btn;
  int old = selection;
 80100a0:	4f1d      	ldr	r7, [pc, #116]	@ (8010118 <ui_browser_touch+0x7c>)
static void ui_browser_touch(int touch_x, int touch_y) {
 80100a2:	4606      	mov	r6, r0
  int max = browser_get_max();
 80100a4:	f7fe f8ee 	bl	800e284 <browser_get_max>
  int old = selection;
 80100a8:	f997 9000 	ldrsb.w	r9, [r7]
static void ui_browser_touch(int touch_x, int touch_y) {
 80100ac:	460d      	mov	r5, r1
  int max = browser_get_max();
 80100ae:	4680      	mov	r8, r0
  for (int idx = 0; idx <= max; idx++) {
 80100b0:	2400      	movs	r4, #0
    browser_get_button_pos(idx, &btn);
 80100b2:	4669      	mov	r1, sp
 80100b4:	4620      	mov	r0, r4
 80100b6:	f7fe f8c1 	bl	800e23c <browser_get_button_pos>
    if (touch_x < btn.x || touch_x >= btn.x + btn.w ||
 80100ba:	f8bd 2000 	ldrh.w	r2, [sp]
 80100be:	42b2      	cmp	r2, r6
 80100c0:	dc0d      	bgt.n	80100de <ui_browser_touch+0x42>
 80100c2:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 80100c6:	4413      	add	r3, r2
 80100c8:	42b3      	cmp	r3, r6
 80100ca:	dd08      	ble.n	80100de <ui_browser_touch+0x42>
        touch_y < btn.y || touch_y >= btn.y + btn.h) continue;
 80100cc:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    if (touch_x < btn.x || touch_x >= btn.x + btn.w ||
 80100d0:	42aa      	cmp	r2, r5
 80100d2:	dc04      	bgt.n	80100de <ui_browser_touch+0x42>
        touch_y < btn.y || touch_y >= btn.y + btn.h) continue;
 80100d4:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80100d8:	4413      	add	r3, r2
 80100da:	42ab      	cmp	r3, r5
 80100dc:	dc05      	bgt.n	80100ea <ui_browser_touch+0x4e>
  for (int idx = 0; idx <= max; idx++) {
 80100de:	3401      	adds	r4, #1
 80100e0:	45a0      	cmp	r8, r4
 80100e2:	dae6      	bge.n	80100b2 <ui_browser_touch+0x16>
    selection = -1;
    browser_draw_button(idx, NULL);              // clear selection
    browser_key_press(idx);
    return;
  }
}
 80100e4:	b003      	add	sp, #12
 80100e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    browser_draw_button(selection = idx, NULL);  // draw new selection
 80100ea:	4620      	mov	r0, r4
 80100ec:	2100      	movs	r1, #0
 80100ee:	703c      	strb	r4, [r7, #0]
 80100f0:	f7fe fa8a 	bl	800e608 <browser_draw_button>
    browser_draw_button(old, NULL);              // clear old
 80100f4:	4648      	mov	r0, r9
 80100f6:	2100      	movs	r1, #0
 80100f8:	f7fe fa86 	bl	800e608 <browser_draw_button>
    touch_wait_release();
 80100fc:	f7fe f9a8 	bl	800e450 <touch_wait_release>
    selection = -1;
 8010100:	23ff      	movs	r3, #255	@ 0xff
    browser_draw_button(idx, NULL);              // clear selection
 8010102:	4620      	mov	r0, r4
 8010104:	2100      	movs	r1, #0
    selection = -1;
 8010106:	703b      	strb	r3, [r7, #0]
    browser_draw_button(idx, NULL);              // clear selection
 8010108:	f7fe fa7e 	bl	800e608 <browser_draw_button>
    browser_key_press(idx);
 801010c:	4620      	mov	r0, r4
}
 801010e:	b003      	add	sp, #12
 8010110:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    browser_key_press(idx);
 8010114:	f7ff beb6 	b.w	800fe84 <browser_key_press>
 8010118:	200003f0 	.word	0x200003f0

0801011c <ui_browser_lever>:

static void ui_browser_lever(uint16_t status) {
  if (status == EVT_BUTTON_SINGLE_CLICK) {
 801011c:	2801      	cmp	r0, #1
static void ui_browser_lever(uint16_t status) {
 801011e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010120:	4f1c      	ldr	r7, [pc, #112]	@ (8010194 <ui_browser_lever+0x78>)
  if (status == EVT_BUTTON_SINGLE_CLICK) {
 8010122:	d107      	bne.n	8010134 <ui_browser_lever+0x18>
    if (selection >= 0) browser_key_press(selection); // Process click
 8010124:	f997 0000 	ldrsb.w	r0, [r7]
 8010128:	2800      	cmp	r0, #0
 801012a:	db32      	blt.n	8010192 <ui_browser_lever+0x76>
      browser_draw_button(old, NULL);       // clear old selection
      browser_draw_button(selection, NULL); // draw new selection
    }
    chThdSleepMilliseconds(100);
  } while ((status = btn_wait_release()) != 0);
}
 801012c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (selection >= 0) browser_key_press(selection); // Process click
 8010130:	f7ff bea8 	b.w	800fe84 <browser_key_press>
 8010134:	4601      	mov	r1, r0
  int max = browser_get_max();
 8010136:	f7fe f8a5 	bl	800e284 <browser_get_max>
    if((status & EVT_UP)   && ++selection > max) selection = 0;
 801013a:	2600      	movs	r6, #0
  int max = browser_get_max();
 801013c:	4604      	mov	r4, r0
    if((status & EVT_DOWN) && --selection < 0) selection = max;
 801013e:	b245      	sxtb	r5, r0
 8010140:	068b      	lsls	r3, r1, #26
    int old = selection;
 8010142:	f997 0000 	ldrsb.w	r0, [r7]
    if((status & EVT_DOWN) && --selection < 0) selection = max;
 8010146:	d507      	bpl.n	8010158 <ui_browser_lever+0x3c>
 8010148:	1e43      	subs	r3, r0, #1
 801014a:	b25b      	sxtb	r3, r3
 801014c:	2b00      	cmp	r3, #0
 801014e:	bfae      	itee	ge
 8010150:	703b      	strbge	r3, [r7, #0]
 8010152:	462b      	movlt	r3, r5
 8010154:	703d      	strblt	r5, [r7, #0]
 8010156:	e000      	b.n	801015a <ui_browser_lever+0x3e>
 8010158:	4603      	mov	r3, r0
    if((status & EVT_UP)   && ++selection > max) selection = 0;
 801015a:	06ca      	lsls	r2, r1, #27
 801015c:	d506      	bpl.n	801016c <ui_browser_lever+0x50>
 801015e:	3301      	adds	r3, #1
 8010160:	b25b      	sxtb	r3, r3
 8010162:	42a3      	cmp	r3, r4
 8010164:	bfd2      	itee	le
 8010166:	703b      	strble	r3, [r7, #0]
 8010168:	703e      	strbgt	r6, [r7, #0]
 801016a:	2300      	movgt	r3, #0
    if (old != selection) {
 801016c:	4298      	cmp	r0, r3
 801016e:	d007      	beq.n	8010180 <ui_browser_lever+0x64>
      browser_draw_button(old, NULL);       // clear old selection
 8010170:	2100      	movs	r1, #0
 8010172:	f7fe fa49 	bl	800e608 <browser_draw_button>
      browser_draw_button(selection, NULL); // draw new selection
 8010176:	f997 0000 	ldrsb.w	r0, [r7]
 801017a:	2100      	movs	r1, #0
 801017c:	f7fe fa44 	bl	800e608 <browser_draw_button>
    chThdSleepMilliseconds(100);
 8010180:	f242 7010 	movw	r0, #10000	@ 0x2710
 8010184:	f7f0 fe84 	bl	8000e90 <chThdSleep>
  } while ((status = btn_wait_release()) != 0);
 8010188:	f7fe f99e 	bl	800e4c8 <btn_wait_release>
 801018c:	4601      	mov	r1, r0
 801018e:	2800      	cmp	r0, #0
 8010190:	d1d6      	bne.n	8010140 <ui_browser_lever+0x24>
}
 8010192:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010194:	200003f0 	.word	0x200003f0

08010198 <ui_touch_cal_exec>:
{
 8010198:	b570      	push	{r4, r5, r6, lr}
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 801019a:	4d0f      	ldr	r5, [pc, #60]	@ (80101d8 <ui_touch_cal_exec+0x40>)
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
 801019c:	4a0f      	ldr	r2, [pc, #60]	@ (80101dc <ui_touch_cal_exec+0x44>)
 801019e:	8aab      	ldrh	r3, [r5, #20]
  if (VNA_MODE(VNA_MODE_FLIP_DISPLAY))
 80101a0:	f013 0340 	ands.w	r3, r3, #64	@ 0x40
    p1 = 2, p2 = 0;
 80101a4:	bf18      	it	ne
 80101a6:	2302      	movne	r3, #2
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
 80101a8:	f04f 010c 	mov.w	r1, #12
 80101ac:	f103 0306 	add.w	r3, r3, #6
  uint16_t p1 = 0, p2 = 2;
 80101b0:	bf0c      	ite	eq
 80101b2:	2402      	moveq	r4, #2
    p1 = 2, p2 = 0;
 80101b4:	2400      	movne	r4, #0
  getTouchPoint(x1, y1, "UPPER LEFT", &config._touch_cal[p1]);
 80101b6:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 80101ba:	4608      	mov	r0, r1
 80101bc:	f7fe fa8a 	bl	800e6d4 <getTouchPoint>
  getTouchPoint(x2, y2, "LOWER RIGHT", &config._touch_cal[p2]);
 80101c0:	1da3      	adds	r3, r4, #6
 80101c2:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 80101c6:	4a06      	ldr	r2, [pc, #24]	@ (80101e0 <ui_touch_cal_exec+0x48>)
}
 80101c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  getTouchPoint(x2, y2, "LOWER RIGHT", &config._touch_cal[p2]);
 80101cc:	f240 112b 	movw	r1, #299	@ 0x12b
 80101d0:	f240 10cb 	movw	r0, #459	@ 0x1cb
 80101d4:	f7fe ba7e 	b.w	800e6d4 <getTouchPoint>
 80101d8:	20000318 	.word	0x20000318
 80101dc:	08014afa 	.word	0x08014afa
 80101e0:	08014b05 	.word	0x08014b05

080101e4 <ui_touch_draw_test>:
{
 80101e4:	b5f0      	push	{r4, r5, r6, r7, lr}
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 80101e6:	2100      	movs	r1, #0
 80101e8:	2001      	movs	r0, #1
{
 80101ea:	b087      	sub	sp, #28
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 80101ec:	f000 ff64 	bl	80110b8 <lcd_set_colors>
  lcd_clear_screen();
 80101f0:	f000 fefc 	bl	8010fec <lcd_clear_screen>
  lcd_drawstring(OFFSETX, LCD_HEIGHT - FONT_GET_HEIGHT, "TOUCH TEST: DRAG PANEL, PRESS BUTTON TO FINISH");
 80101f4:	4a19      	ldr	r2, [pc, #100]	@ (801025c <ui_touch_draw_test+0x78>)
 80101f6:	f240 1135 	movw	r1, #309	@ 0x135
 80101fa:	200f      	movs	r0, #15
 80101fc:	f000 ffec 	bl	80111d8 <lcd_printf>
    if (btn_check() & EVT_BUTTON_SINGLE_CLICK)
 8010200:	f7fe f93c 	bl	800e47c <btn_check>
 8010204:	07c3      	lsls	r3, r0, #31
 8010206:	d427      	bmi.n	8010258 <ui_touch_draw_test+0x74>
    if (touch_check() == EVT_TOUCH_PRESSED)
 8010208:	f7fe f8f2 	bl	800e3f0 <touch_check>
 801020c:	2802      	cmp	r0, #2
 801020e:	d1f7      	bne.n	8010200 <ui_touch_draw_test+0x1c>
      touch_position(&x0, &y0);
 8010210:	a903      	add	r1, sp, #12
 8010212:	a802      	add	r0, sp, #8
 8010214:	f7fd ffc4 	bl	800e1a0 <touch_position>
        lcd_printf(10, 30, "%3d %3d ", x0, y0);
 8010218:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 801021c:	4a10      	ldr	r2, [pc, #64]	@ (8010260 <ui_touch_draw_test+0x7c>)
 801021e:	9700      	str	r7, [sp, #0]
 8010220:	4633      	mov	r3, r6
 8010222:	211e      	movs	r1, #30
 8010224:	200a      	movs	r0, #10
 8010226:	f000 ffd7 	bl	80111d8 <lcd_printf>
        chThdSleepMilliseconds(50);
 801022a:	f241 3088 	movw	r0, #5000	@ 0x1388
 801022e:	f7f0 fe2f 	bl	8000e90 <chThdSleep>
        touch_position(&x1, &y1);
 8010232:	a905      	add	r1, sp, #20
 8010234:	a804      	add	r0, sp, #16
 8010236:	f7fd ffb3 	bl	800e1a0 <touch_position>
        lcd_line(x0, y0, x1, y1);
 801023a:	e9dd 5404 	ldrd	r5, r4, [sp, #16]
 801023e:	4639      	mov	r1, r7
 8010240:	4623      	mov	r3, r4
 8010242:	462a      	mov	r2, r5
 8010244:	4630      	mov	r0, r6
 8010246:	f000 fe7d 	bl	8010f44 <lcd_line>
        y0 = y1;
 801024a:	e9cd 5402 	strd	r5, r4, [sp, #8]
      } while (touch_check() != EVT_TOUCH_RELEASED);
 801024e:	f7fe f8cf 	bl	800e3f0 <touch_check>
 8010252:	2803      	cmp	r0, #3
 8010254:	d1e0      	bne.n	8010218 <ui_touch_draw_test+0x34>
 8010256:	e7d3      	b.n	8010200 <ui_touch_draw_test+0x1c>
}
 8010258:	b007      	add	sp, #28
 801025a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801025c:	08014b11 	.word	0x08014b11
 8010260:	08014b40 	.word	0x08014b40

08010264 <menu_config_cb>:
{
 8010264:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  switch (data)
 8010266:	2804      	cmp	r0, #4
 8010268:	d877      	bhi.n	801035a <menu_config_cb+0xf6>
 801026a:	e8df f000 	tbb	[pc, r0]
 801026e:	0603      	.short	0x0603
 8010270:	6a09      	.short	0x6a09
 8010272:	72          	.byte	0x72
 8010273:	00          	.byte	0x00
    ui_touch_cal_exec();
 8010274:	f7ff ff90 	bl	8010198 <ui_touch_cal_exec>
    break;
 8010278:	e06f      	b.n	801035a <menu_config_cb+0xf6>
    ui_touch_draw_test();
 801027a:	f7ff ffb3 	bl	80101e4 <ui_touch_draw_test>
    break;
 801027e:	e06c      	b.n	801035a <menu_config_cb+0xf6>
  lcd_clear_screen();
 8010280:	f000 feb4 	bl	8010fec <lcd_clear_screen>
  lcd_set_colors(LCD_TRACE_1_COLOR, LCD_BG_COLOR);
 8010284:	2100      	movs	r1, #0
 8010286:	2006      	movs	r0, #6
 8010288:	f000 ff16 	bl	80110b8 <lcd_set_colors>
  lcd_drawstring_size("HB9IIU MLA ToolBox", x, y, 3);
 801028c:	2205      	movs	r2, #5
 801028e:	4611      	mov	r1, r2
 8010290:	4836      	ldr	r0, [pc, #216]	@ (801036c <menu_config_cb+0x108>)
 8010292:	4f37      	ldr	r7, [pc, #220]	@ (8010370 <menu_config_cb+0x10c>)
 8010294:	2303      	movs	r3, #3
 8010296:	f001 f8bd 	bl	8011414 <lcd_drawstring_size>
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 801029a:	2100      	movs	r1, #0
 801029c:	2001      	movs	r0, #1
 801029e:	f000 ff0b 	bl	80110b8 <lcd_set_colors>
  uint16_t shift = 0b00010010000;
 80102a2:	2690      	movs	r6, #144	@ 0x90
  y += FONT_GET_HEIGHT * 3 + 3 - 5;
 80102a4:	2424      	movs	r4, #36	@ 0x24
  while (info_about[i])
 80102a6:	f857 5f04 	ldr.w	r5, [r7, #4]!
 80102aa:	b16d      	cbz	r5, 80102c8 <menu_config_cb+0x64>
      shift >>= 1;
 80102ac:	0876      	lsrs	r6, r6, #1
    } while (shift & 1);
 80102ae:	07f1      	lsls	r1, r6, #31
 80102b0:	4623      	mov	r3, r4
      y += 5;
 80102b2:	f104 0405 	add.w	r4, r4, #5
    } while (shift & 1);
 80102b6:	d4f9      	bmi.n	80102ac <menu_config_cb+0x48>
    lcd_drawstring(x, y += str_height - 5, info_about[i++]);
 80102b8:	f103 040d 	add.w	r4, r3, #13
 80102bc:	462a      	mov	r2, r5
 80102be:	b221      	sxth	r1, r4
 80102c0:	2005      	movs	r0, #5
 80102c2:	f000 ff89 	bl	80111d8 <lcd_printf>
 80102c6:	e7ee      	b.n	80102a6 <menu_config_cb+0x42>
  uint32_t id0 = *(uint32_t *)0x1FFFF7AC; // MCU id0 address
 80102c8:	4b2a      	ldr	r3, [pc, #168]	@ (8010374 <menu_config_cb+0x110>)
  lcd_printf(x, y += str_height, "SN: %08x-%08x-%08x", id0, id1, id2);
 80102ca:	f8d3 27b4 	ldr.w	r2, [r3, #1972]	@ 0x7b4
 80102ce:	9201      	str	r2, [sp, #4]
 80102d0:	f8d3 27b0 	ldr.w	r2, [r3, #1968]	@ 0x7b0
 80102d4:	9200      	str	r2, [sp, #0]
 80102d6:	f104 010d 	add.w	r1, r4, #13
 80102da:	f8d3 37ac 	ldr.w	r3, [r3, #1964]	@ 0x7ac
 80102de:	4a26      	ldr	r2, [pc, #152]	@ (8010378 <menu_config_cb+0x114>)
 80102e0:	b209      	sxth	r1, r1
 80102e2:	2005      	movs	r0, #5
 80102e4:	f000 ff78 	bl	80111d8 <lcd_printf>
  lcd_blitBitmapScale(LCD_WIDTH - 32 * 3, 240-5-32, 31, 31, 3, qr_code_map);
 80102e8:	4b24      	ldr	r3, [pc, #144]	@ (801037c <menu_config_cb+0x118>)
 80102ea:	9301      	str	r3, [sp, #4]
 80102ec:	2303      	movs	r3, #3
 80102ee:	9300      	str	r3, [sp, #0]
 80102f0:	231f      	movs	r3, #31
 80102f2:	461a      	mov	r2, r3
 80102f4:	21cb      	movs	r1, #203	@ 0xcb
 80102f6:	f44f 70c0 	mov.w	r0, #384	@ 0x180
 80102fa:	f000 ff91 	bl	8011220 <lcd_blitBitmapScale>
    lcd_printf(x, y + str_height, "Batt: %d.%03d" S_VOLT, vbat / 1000, vbat % 1000);
 80102fe:	3434      	adds	r4, #52	@ 0x34
 8010300:	b224      	sxth	r4, r4
    if (touch_check() == EVT_TOUCH_PRESSED)
 8010302:	f7fe f875 	bl	800e3f0 <touch_check>
 8010306:	2802      	cmp	r0, #2
 8010308:	b2ae      	uxth	r6, r5
 801030a:	d026      	beq.n	801035a <menu_config_cb+0xf6>
    if (btn_check() & EVT_BUTTON_SINGLE_CLICK)
 801030c:	f7fe f8b6 	bl	800e47c <btn_check>
 8010310:	07c2      	lsls	r2, r0, #31
 8010312:	d422      	bmi.n	801035a <menu_config_cb+0xf6>
    chThdSleepMilliseconds(40);
 8010314:	f44f 607a 	mov.w	r0, #4000	@ 0xfa0
 8010318:	f7f0 fdba 	bl	8000e90 <chThdSleep>
    if ((cnt++) & 0x07)
 801031c:	0773      	lsls	r3, r6, #29
 801031e:	d001      	beq.n	8010324 <menu_config_cb+0xc0>
 8010320:	3501      	adds	r5, #1
 8010322:	e7ee      	b.n	8010302 <menu_config_cb+0x9e>
    uint32_t vbat = adc_vbat_read();
 8010324:	f001 fbae 	bl	8011a84 <adc_vbat_read>
    lcd_printf(x, y + str_height, "Batt: %d.%03d" S_VOLT, vbat / 1000, vbat % 1000);
 8010328:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 801032c:	fbb0 f3f2 	udiv	r3, r0, r2
 8010330:	fb02 0013 	mls	r0, r2, r3, r0
 8010334:	9000      	str	r0, [sp, #0]
 8010336:	4a12      	ldr	r2, [pc, #72]	@ (8010380 <menu_config_cb+0x11c>)
 8010338:	4621      	mov	r1, r4
 801033a:	2005      	movs	r0, #5
 801033c:	f000 ff4c 	bl	80111d8 <lcd_printf>
 8010340:	e7ee      	b.n	8010320 <menu_config_cb+0xbc>
    config_save();
 8010342:	f001 fa05 	bl	8011750 <config_save>
    menu_move_back(true);
 8010346:	2001      	movs	r0, #1
}
 8010348:	b003      	add	sp, #12
 801034a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    menu_move_back(true);
 801034e:	f7ff b937 	b.w	800f5c0 <menu_move_back>
    clear_all_config_prop_data();
 8010352:	f001 fabf 	bl	80118d4 <clear_all_config_prop_data>
    NVIC_SystemReset();
 8010356:	f7fd fefd 	bl	800e154 <NVIC_SystemReset>
  ui_mode_normal();
 801035a:	f7fe f9e7 	bl	800e72c <ui_mode_normal>
  request_to_redraw(REDRAW_ALL);
 801035e:	f240 301a 	movw	r0, #794	@ 0x31a
}
 8010362:	b003      	add	sp, #12
 8010364:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  request_to_redraw(REDRAW_ALL);
 8010368:	f7fc b9fe 	b.w	800c768 <request_to_redraw>
 801036c:	08014b49 	.word	0x08014b49
 8010370:	2000038c 	.word	0x2000038c
 8010374:	1ffff000 	.word	0x1ffff000
 8010378:	08014b5c 	.word	0x08014b5c
 801037c:	08016db4 	.word	0x08016db4
 8010380:	08014b6f 	.word	0x08014b6f

08010384 <ui_enter_dfu>:
{
 8010384:	b508      	push	{r3, lr}
  touch_stop_watchdog();
 8010386:	f7fd ffc3 	bl	800e310 <touch_stop_watchdog>
  lcd_set_colors(LCD_FG_COLOR, LCD_BG_COLOR);
 801038a:	2100      	movs	r1, #0
 801038c:	2001      	movs	r0, #1
 801038e:	f000 fe93 	bl	80110b8 <lcd_set_colors>
  lcd_clear_screen();
 8010392:	f000 fe2b 	bl	8010fec <lcd_clear_screen>
  lcd_drawstring(x, y, "DFU: Device Firmware Update Mode\n"
 8010396:	4a04      	ldr	r2, [pc, #16]	@ (80103a8 <ui_enter_dfu+0x24>)
 8010398:	2114      	movs	r1, #20
 801039a:	2005      	movs	r0, #5
 801039c:	f000 ff1c 	bl	80111d8 <lcd_printf>
}
 80103a0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  boardDFUEnter();
 80103a4:	f7f2 b88e 	b.w	80024c4 <boardDFUEnter>
 80103a8:	08014b7e 	.word	0x08014b7e

080103ac <menu_dfu_cb>:
  ui_enter_dfu();
 80103ac:	f7ff bfea 	b.w	8010384 <ui_enter_dfu>

080103b0 <apply_VNA_mode>:
{
 80103b0:	b538      	push	{r3, r4, r5, lr}
  uint16_t old = config._vna_mode;
 80103b2:	4d18      	ldr	r5, [pc, #96]	@ (8010414 <apply_VNA_mode+0x64>)
  uint16_t m = 1 << idx;
 80103b4:	2301      	movs	r3, #1
  uint16_t old = config._vna_mode;
 80103b6:	8aaa      	ldrh	r2, [r5, #20]
{
 80103b8:	4604      	mov	r4, r0
  uint16_t m = 1 << idx;
 80103ba:	4083      	lsls	r3, r0
  if (operation == VNA_MODE_CLR)
 80103bc:	b911      	cbnz	r1, 80103c4 <apply_VNA_mode+0x14>
    config._vna_mode &= ~m; // clear
 80103be:	ea22 0303 	bic.w	r3, r2, r3
 80103c2:	e004      	b.n	80103ce <apply_VNA_mode+0x1e>
  uint16_t m = 1 << idx;
 80103c4:	b29b      	uxth	r3, r3
  else if (operation == VNA_MODE_SET)
 80103c6:	2901      	cmp	r1, #1
    config._vna_mode |= m; // set
 80103c8:	bf0c      	ite	eq
 80103ca:	4313      	orreq	r3, r2
    config._vna_mode ^= m; // toggle
 80103cc:	4053      	eorne	r3, r2
  if (old == config._vna_mode)
 80103ce:	429a      	cmp	r2, r3
    config._vna_mode &= ~m; // clear
 80103d0:	82ab      	strh	r3, [r5, #20]
  if (old == config._vna_mode)
 80103d2:	d01d      	beq.n	8010410 <apply_VNA_mode+0x60>
  request_to_redraw(vna_mode_data[idx].update_flag);
 80103d4:	4b10      	ldr	r3, [pc, #64]	@ (8010418 <apply_VNA_mode+0x68>)
 80103d6:	2206      	movs	r2, #6
 80103d8:	fb02 3304 	mla	r3, r2, r4, r3
 80103dc:	8898      	ldrh	r0, [r3, #4]
 80103de:	f7fc f9c3 	bl	800c768 <request_to_redraw>
  switch (idx)
 80103e2:	2c03      	cmp	r4, #3
 80103e4:	d007      	beq.n	80103f6 <apply_VNA_mode+0x46>
 80103e6:	2c06      	cmp	r4, #6
 80103e8:	d009      	beq.n	80103fe <apply_VNA_mode+0x4e>
 80103ea:	2c02      	cmp	r4, #2
 80103ec:	d110      	bne.n	8010410 <apply_VNA_mode+0x60>
}
 80103ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    shell_reset_console();
 80103f2:	f7f9 b8a7 	b.w	8009544 <shell_reset_console>
}
 80103f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    marker_search();
 80103fa:	f7fc b819 	b.w	800c430 <marker_search>
    lcd_set_flip(VNA_MODE(VNA_MODE_FLIP_DISPLAY));
 80103fe:	7d28      	ldrb	r0, [r5, #20]
 8010400:	f3c0 1080 	ubfx	r0, r0, #6, #1
 8010404:	f000 fd1e 	bl	8010e44 <lcd_set_flip>
}
 8010408:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    draw_all();
 801040c:	f7fc b9d4 	b.w	800c7b8 <draw_all>
}
 8010410:	bd38      	pop	{r3, r4, r5, pc}
 8010412:	bf00      	nop
 8010414:	20000318 	.word	0x20000318
 8010418:	08016d78 	.word	0x08016d78

0801041c <ui_show_no_resonance_hint>:
{
 801041c:	b508      	push	{r3, lr}
  if (no_resonance_visible)
 801041e:	4b11      	ldr	r3, [pc, #68]	@ (8010464 <ui_show_no_resonance_hint+0x48>)
 8010420:	781a      	ldrb	r2, [r3, #0]
 8010422:	b9ea      	cbnz	r2, 8010460 <ui_show_no_resonance_hint+0x44>
  no_resonance_visible = true;
 8010424:	2201      	movs	r2, #1
  lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_MENU_COLOR);
 8010426:	2103      	movs	r1, #3
 8010428:	2004      	movs	r0, #4
  no_resonance_visible = true;
 801042a:	701a      	strb	r2, [r3, #0]
  lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_MENU_COLOR);
 801042c:	f000 fe44 	bl	80110b8 <lcd_set_colors>
  lcd_fill(x, y, w, h);
 8010430:	2332      	movs	r3, #50	@ 0x32
 8010432:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8010436:	2187      	movs	r1, #135	@ 0x87
 8010438:	2064      	movs	r0, #100	@ 0x64
 801043a:	f000 fd37 	bl	8010eac <lcd_fill>
  lcd_printf(
 801043e:	4a0a      	ldr	r2, [pc, #40]	@ (8010468 <ui_show_no_resonance_hint+0x4c>)
 8010440:	218a      	movs	r1, #138	@ 0x8a
 8010442:	20b1      	movs	r0, #177	@ 0xb1
 8010444:	f000 fec8 	bl	80111d8 <lcd_printf>
  lcd_printf(
 8010448:	4a08      	ldr	r2, [pc, #32]	@ (801046c <ui_show_no_resonance_hint+0x50>)
 801044a:	219a      	movs	r1, #154	@ 0x9a
 801044c:	20af      	movs	r0, #175	@ 0xaf
 801044e:	f000 fec3 	bl	80111d8 <lcd_printf>
}
 8010452:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  lcd_printf(
 8010456:	4a06      	ldr	r2, [pc, #24]	@ (8010470 <ui_show_no_resonance_hint+0x54>)
 8010458:	21aa      	movs	r1, #170	@ 0xaa
 801045a:	20a9      	movs	r0, #169	@ 0xa9
 801045c:	f000 bebc 	b.w	80111d8 <lcd_printf>
}
 8010460:	bd08      	pop	{r3, pc}
 8010462:	bf00      	nop
 8010464:	200089fb 	.word	0x200089fb
 8010468:	08014bcf 	.word	0x08014bcf
 801046c:	08014be2 	.word	0x08014be2
 8010470:	08014bf4 	.word	0x08014bf4

08010474 <ui_hide_check_amtenna_hint>:
{
 8010474:	b508      	push	{r3, lr}
  if (!checking_antenna_visible)
 8010476:	4b0a      	ldr	r3, [pc, #40]	@ (80104a0 <ui_hide_check_amtenna_hint+0x2c>)
 8010478:	781a      	ldrb	r2, [r3, #0]
 801047a:	b17a      	cbz	r2, 801049c <ui_hide_check_amtenna_hint+0x28>
  checking_antenna_visible = false;
 801047c:	2000      	movs	r0, #0
 801047e:	7018      	strb	r0, [r3, #0]
  lcd_set_background(LCD_BG_COLOR);
 8010480:	f000 fe0e 	bl	80110a0 <lcd_set_background>
  lcd_fill(NO_RESONANCE_X, NO_RESONANCE_Y, NO_RESONANCE_W, NO_RESONANCE_H);
 8010484:	2332      	movs	r3, #50	@ 0x32
 8010486:	2064      	movs	r0, #100	@ 0x64
 8010488:	f44f 728c 	mov.w	r2, #280	@ 0x118
 801048c:	2187      	movs	r1, #135	@ 0x87
 801048e:	f000 fd0d 	bl	8010eac <lcd_fill>
}
 8010492:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_AREA | REDRAW_PLOT | REDRAW_MARKER);
 8010496:	2023      	movs	r0, #35	@ 0x23
 8010498:	f7fc b966 	b.w	800c768 <request_to_redraw>
}
 801049c:	bd08      	pop	{r3, pc}
 801049e:	bf00      	nop
 80104a0:	200089fa 	.word	0x200089fa

080104a4 <ui_show_check_amtenna_hint>:
{
 80104a4:	b508      	push	{r3, lr}
  if (!checking_antenna_visible)
 80104a6:	4b10      	ldr	r3, [pc, #64]	@ (80104e8 <ui_show_check_amtenna_hint+0x44>)
 80104a8:	781a      	ldrb	r2, [r3, #0]
 80104aa:	b90a      	cbnz	r2, 80104b0 <ui_show_check_amtenna_hint+0xc>
    checking_antenna_visible = true;
 80104ac:	2201      	movs	r2, #1
 80104ae:	701a      	strb	r2, [r3, #0]
  lcd_set_colors(LCD_MENU_TEXT_COLOR, LCD_MENU_COLOR);
 80104b0:	2103      	movs	r1, #3
 80104b2:	2004      	movs	r0, #4
 80104b4:	f000 fe00 	bl	80110b8 <lcd_set_colors>
  lcd_fill(x, y, w, h);
 80104b8:	2332      	movs	r3, #50	@ 0x32
 80104ba:	f44f 728c 	mov.w	r2, #280	@ 0x118
 80104be:	2187      	movs	r1, #135	@ 0x87
 80104c0:	2064      	movs	r0, #100	@ 0x64
 80104c2:	f000 fcf3 	bl	8010eac <lcd_fill>
  lcd_printf(
 80104c6:	4a09      	ldr	r2, [pc, #36]	@ (80104ec <ui_show_check_amtenna_hint+0x48>)
 80104c8:	218a      	movs	r1, #138	@ 0x8a
 80104ca:	207c      	movs	r0, #124	@ 0x7c
 80104cc:	f000 fe84 	bl	80111d8 <lcd_printf>
  lcd_printf(
 80104d0:	4a07      	ldr	r2, [pc, #28]	@ (80104f0 <ui_show_check_amtenna_hint+0x4c>)
 80104d2:	219a      	movs	r1, #154	@ 0x9a
 80104d4:	20b8      	movs	r0, #184	@ 0xb8
 80104d6:	f000 fe7f 	bl	80111d8 <lcd_printf>
}
 80104da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  lcd_printf(
 80104de:	4a05      	ldr	r2, [pc, #20]	@ (80104f4 <ui_show_check_amtenna_hint+0x50>)
 80104e0:	21aa      	movs	r1, #170	@ 0xaa
 80104e2:	20c0      	movs	r0, #192	@ 0xc0
 80104e4:	f000 be78 	b.w	80111d8 <lcd_printf>
 80104e8:	200089fa 	.word	0x200089fa
 80104ec:	08014c09 	.word	0x08014c09
 80104f0:	08014c2b 	.word	0x08014c2b
 80104f4:	08014c3b 	.word	0x08014c3b

080104f8 <ui_hide_no_resonance_hint>:
{
 80104f8:	b508      	push	{r3, lr}
  if (!no_resonance_visible)
 80104fa:	4b0a      	ldr	r3, [pc, #40]	@ (8010524 <ui_hide_no_resonance_hint+0x2c>)
 80104fc:	781a      	ldrb	r2, [r3, #0]
 80104fe:	b182      	cbz	r2, 8010522 <ui_hide_no_resonance_hint+0x2a>
  no_resonance_visible = false;
 8010500:	2000      	movs	r0, #0
 8010502:	7018      	strb	r0, [r3, #0]
  lcd_set_background(LCD_BG_COLOR);
 8010504:	f000 fdcc 	bl	80110a0 <lcd_set_background>
  lcd_fill(NO_RESONANCE_X, NO_RESONANCE_Y, NO_RESONANCE_W, NO_RESONANCE_H);
 8010508:	2332      	movs	r3, #50	@ 0x32
 801050a:	2064      	movs	r0, #100	@ 0x64
 801050c:	f44f 728c 	mov.w	r2, #280	@ 0x118
 8010510:	2187      	movs	r1, #135	@ 0x87
 8010512:	f000 fccb 	bl	8010eac <lcd_fill>
}
 8010516:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_BACKUP | REDRAW_AREA);
 801051a:	f240 4002 	movw	r0, #1026	@ 0x402
 801051e:	f7fc b923 	b.w	800c768 <request_to_redraw>
}
 8010522:	bd08      	pop	{r3, pc}
 8010524:	200089fb 	.word	0x200089fb

08010528 <keyboard_get_float>:
float keyboard_get_float(void) { return my_atof(kp_buf); }
 8010528:	4801      	ldr	r0, [pc, #4]	@ (8010530 <keyboard_get_float+0x8>)
 801052a:	f7f9 ba25 	b.w	8009978 <my_atof>
 801052e:	bf00      	nop
 8010530:	20008a10 	.word	0x20008a10

08010534 <input_var_delay>:
{
 8010534:	b513      	push	{r0, r1, r4, lr}
 8010536:	4c0e      	ldr	r4, [pc, #56]	@ (8010570 <input_var_delay+0x3c>)
  if (b)
 8010538:	b1a1      	cbz	r1, 8010564 <input_var_delay+0x30>
    if (current_props._var_delay)
 801053a:	edd4 7a29 	vldr	s15, [r4, #164]	@ 0xa4
 801053e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8010542:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010546:	d011      	beq.n	801056c <input_var_delay+0x38>
      plot_printf(b->label, sizeof(b->label), "JOG STEP\n " R_LINK_COLOR "%F" S_SECOND, current_props._var_delay);
 8010548:	ee17 0a90 	vmov	r0, s15
 801054c:	f101 0408 	add.w	r4, r1, #8
 8010550:	f7f0 f826 	bl	80005a0 <__aeabi_f2d>
 8010554:	4a07      	ldr	r2, [pc, #28]	@ (8010574 <input_var_delay+0x40>)
 8010556:	e9cd 0100 	strd	r0, r1, [sp]
 801055a:	2120      	movs	r1, #32
 801055c:	4620      	mov	r0, r4
 801055e:	f7f2 fc07 	bl	8002d70 <plot_printf>
 8010562:	e003      	b.n	801056c <input_var_delay+0x38>
  current_props._var_delay = keyboard_get_float();
 8010564:	f7ff ffe0 	bl	8010528 <keyboard_get_float>
 8010568:	ed84 0a29 	vstr	s0, [r4, #164]	@ 0xa4
}
 801056c:	b002      	add	sp, #8
 801056e:	bd10      	pop	{r4, pc}
 8010570:	20000aa8 	.word	0x20000aa8
 8010574:	08014c49 	.word	0x08014c49

08010578 <input_amplitude>:
{
 8010578:	b5f0      	push	{r4, r5, r6, r7, lr}
 801057a:	ed2d 8b02 	vpush	{d8}
  int type = trace[current_trace].type;
 801057e:	4d38      	ldr	r5, [pc, #224]	@ (8010660 <input_amplitude+0xe8>)
 8010580:	f995 301c 	ldrsb.w	r3, [r5, #28]
 8010584:	220c      	movs	r2, #12
 8010586:	fb02 5303 	mla	r3, r2, r3, r5
  float ref = get_trace_refpos(current_trace);
 801058a:	ed93 7a0c 	vldr	s14, [r3, #48]	@ 0x30
  float scale = get_trace_scale(current_trace);
 801058e:	edd3 7a0b 	vldr	s15, [r3, #44]	@ 0x2c
  int type = trace[current_trace].type;
 8010592:	f893 6029 	ldrb.w	r6, [r3, #41]	@ 0x29
  float top = (NGRIDY - ref) * scale;
 8010596:	eef2 8a00 	vmov.f32	s17, #32	@ 0x41000000  8.0
 801059a:	ee78 8ac7 	vsub.f32	s17, s17, s14
 801059e:	ee27 8a67 	vnmul.f32	s16, s14, s15
 80105a2:	ee68 8aa7 	vmul.f32	s17, s17, s15
{
 80105a6:	b085      	sub	sp, #20
 80105a8:	4604      	mov	r4, r0
  if (b)
 80105aa:	b331      	cbz	r1, 80105fa <input_amplitude+0x82>
    float val = data == 0 ? top : bot;
 80105ac:	2800      	cmp	r0, #0
 80105ae:	bf08      	it	eq
 80105b0:	eeb0 8a68 	vmoveq.f32	s16, s17
    plot_printf(b->label, sizeof(b->label), "%s\n " R_LINK_COLOR "%.4F%s", data == 0 ? "TOP" : "BOTTOM", val, trace_info_list[type].symbol);
 80105b4:	4b2b      	ldr	r3, [pc, #172]	@ (8010664 <input_amplitude+0xec>)
 80105b6:	4f2c      	ldr	r7, [pc, #176]	@ (8010668 <input_amplitude+0xf0>)
    if (type == TRC_SWR)
 80105b8:	2e06      	cmp	r6, #6
      val += 1.0f;
 80105ba:	bf04      	itt	eq
 80105bc:	eef7 7a00 	vmoveq.f32	s15, #112	@ 0x3f800000  1.0
 80105c0:	ee38 8a27 	vaddeq.f32	s16, s16, s15
    plot_printf(b->label, sizeof(b->label), "%s\n " R_LINK_COLOR "%.4F%s", data == 0 ? "TOP" : "BOTTOM", val, trace_info_list[type].symbol);
 80105c4:	2800      	cmp	r0, #0
 80105c6:	bf08      	it	eq
 80105c8:	461f      	moveq	r7, r3
 80105ca:	4b28      	ldr	r3, [pc, #160]	@ (801066c <input_amplitude+0xf4>)
 80105cc:	221c      	movs	r2, #28
 80105ce:	fb02 3306 	mla	r3, r2, r6, r3
 80105d2:	ee18 0a10 	vmov	r0, s16
 80105d6:	68db      	ldr	r3, [r3, #12]
 80105d8:	9302      	str	r3, [sp, #8]
 80105da:	f101 0508 	add.w	r5, r1, #8
 80105de:	f7ef ffdf 	bl	80005a0 <__aeabi_f2d>
 80105e2:	4a23      	ldr	r2, [pc, #140]	@ (8010670 <input_amplitude+0xf8>)
 80105e4:	e9cd 0100 	strd	r0, r1, [sp]
 80105e8:	463b      	mov	r3, r7
 80105ea:	2120      	movs	r1, #32
 80105ec:	4628      	mov	r0, r5
 80105ee:	f7f2 fbbf 	bl	8002d70 <plot_printf>
}
 80105f2:	b005      	add	sp, #20
 80105f4:	ecbd 8b02 	vpop	{d8}
 80105f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  float value = keyboard_get_float();
 80105fa:	f7ff ff95 	bl	8010528 <keyboard_get_float>
  if (type == TRC_SWR)
 80105fe:	2e06      	cmp	r6, #6
    value -= 1.0f; // Hack for SWR trace!
 8010600:	bf08      	it	eq
 8010602:	eeb7 7a00 	vmoveq.f32	s14, #112	@ 0x3f800000  1.0
  float value = keyboard_get_float();
 8010606:	eef0 7a40 	vmov.f32	s15, s0
    value -= 1.0f; // Hack for SWR trace!
 801060a:	bf08      	it	eq
 801060c:	ee70 7a47 	vsubeq.f32	s15, s0, s14
    top = value; // top value input
 8010610:	2c00      	cmp	r4, #0
 8010612:	bf08      	it	eq
 8010614:	eef0 8a67 	vmoveq.f32	s17, s15
 8010618:	bf18      	it	ne
 801061a:	eeb0 8a67 	vmovne.f32	s16, s15
  scale = (top - bot) / NGRIDY;
 801061e:	ee38 0ac8 	vsub.f32	s0, s17, s16
  ref = (top == bot) ? -value : -bot / scale;
 8010622:	eeb4 8a68 	vcmp.f32	s16, s17
  scale = (top - bot) / NGRIDY;
 8010626:	eeb4 7a00 	vmov.f32	s14, #64	@ 0x3e000000  0.125
  ref = (top == bot) ? -value : -bot / scale;
 801062a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  scale = (top - bot) / NGRIDY;
 801062e:	ee20 0a07 	vmul.f32	s0, s0, s14
  ref = (top == bot) ? -value : -bot / scale;
 8010632:	bf1c      	itt	ne
 8010634:	eeb1 8a48 	vnegne.f32	s16, s16
 8010638:	eec8 8a00 	vdivne.f32	s17, s16, s0
  set_trace_scale(current_trace, scale);
 801063c:	f995 001c 	ldrsb.w	r0, [r5, #28]
  ref = (top == bot) ? -value : -bot / scale;
 8010640:	bf08      	it	eq
 8010642:	eef1 8a67 	vnegeq.f32	s17, s15
  set_trace_scale(current_trace, scale);
 8010646:	f7f7 fd0b 	bl	8008060 <set_trace_scale>
  set_trace_refpos(current_trace, ref);
 801064a:	f995 001c 	ldrsb.w	r0, [r5, #28]
 801064e:	eeb0 0a68 	vmov.f32	s0, s17
}
 8010652:	b005      	add	sp, #20
 8010654:	ecbd 8b02 	vpop	{d8}
 8010658:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  set_trace_refpos(current_trace, ref);
 801065c:	f7f7 bd14 	b.w	8008088 <set_trace_refpos>
 8010660:	20000aa8 	.word	0x20000aa8
 8010664:	08014c59 	.word	0x08014c59
 8010668:	08014c5d 	.word	0x08014c5d
 801066c:	0801650c 	.word	0x0801650c
 8010670:	08014c64 	.word	0x08014c64

08010674 <input_scale>:
  if (b)
 8010674:	b951      	cbnz	r1, 801068c <input_scale+0x18>
{
 8010676:	b510      	push	{r4, lr}
  set_trace_scale(current_trace, keyboard_get_float());
 8010678:	4b05      	ldr	r3, [pc, #20]	@ (8010690 <input_scale+0x1c>)
 801067a:	f993 401c 	ldrsb.w	r4, [r3, #28]
 801067e:	f7ff ff53 	bl	8010528 <keyboard_get_float>
 8010682:	4620      	mov	r0, r4
}
 8010684:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_trace_scale(current_trace, keyboard_get_float());
 8010688:	f7f7 bcea 	b.w	8008060 <set_trace_scale>
 801068c:	4770      	bx	lr
 801068e:	bf00      	nop
 8010690:	20000aa8 	.word	0x20000aa8

08010694 <input_ref>:
  if (b)
 8010694:	b951      	cbnz	r1, 80106ac <input_ref+0x18>
{
 8010696:	b510      	push	{r4, lr}
  set_trace_refpos(current_trace, keyboard_get_float());
 8010698:	4b05      	ldr	r3, [pc, #20]	@ (80106b0 <input_ref+0x1c>)
 801069a:	f993 401c 	ldrsb.w	r4, [r3, #28]
 801069e:	f7ff ff43 	bl	8010528 <keyboard_get_float>
 80106a2:	4620      	mov	r0, r4
}
 80106a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_trace_refpos(current_trace, keyboard_get_float());
 80106a8:	f7f7 bcee 	b.w	8008088 <set_trace_refpos>
 80106ac:	4770      	bx	lr
 80106ae:	bf00      	nop
 80106b0:	20000aa8 	.word	0x20000aa8

080106b4 <input_edelay>:
  if (current_trace == TRACE_INVALID)
 80106b4:	4a14      	ldr	r2, [pc, #80]	@ (8010708 <input_edelay+0x54>)
 80106b6:	f992 301c 	ldrsb.w	r3, [r2, #28]
 80106ba:	f1b3 3fff 	cmp.w	r3, #4294967295
 80106be:	d021      	beq.n	8010704 <input_edelay+0x50>
{
 80106c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  int ch = trace[current_trace].channel;
 80106c2:	200c      	movs	r0, #12
 80106c4:	fb00 2303 	mla	r3, r0, r3, r2
 80106c8:	f893 502a 	ldrb.w	r5, [r3, #42]	@ 0x2a
  if (b)
 80106cc:	b191      	cbz	r1, 80106f4 <input_edelay+0x40>
    plot_printf(b->label, sizeof(b->label), "E-DELAY S%d1\n " R_LINK_COLOR "%.7F" S_SECOND, ch + 1, current_props._electrical_delay[ch]);
 80106ce:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 80106d2:	f101 0408 	add.w	r4, r1, #8
 80106d6:	f8d2 009c 	ldr.w	r0, [r2, #156]	@ 0x9c
 80106da:	f7ef ff61 	bl	80005a0 <__aeabi_f2d>
 80106de:	1c6e      	adds	r6, r5, #1
 80106e0:	e9cd 0100 	strd	r0, r1, [sp]
 80106e4:	4a09      	ldr	r2, [pc, #36]	@ (801070c <input_edelay+0x58>)
 80106e6:	4633      	mov	r3, r6
 80106e8:	2120      	movs	r1, #32
 80106ea:	4620      	mov	r0, r4
 80106ec:	f7f2 fb40 	bl	8002d70 <plot_printf>
}
 80106f0:	b002      	add	sp, #8
 80106f2:	bd70      	pop	{r4, r5, r6, pc}
  set_electrical_delay(ch, keyboard_get_float());
 80106f4:	f7ff ff18 	bl	8010528 <keyboard_get_float>
 80106f8:	4628      	mov	r0, r5
}
 80106fa:	b002      	add	sp, #8
 80106fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  set_electrical_delay(ch, keyboard_get_float());
 8010700:	f7f8 be44 	b.w	800938c <set_electrical_delay>
 8010704:	4770      	bx	lr
 8010706:	bf00      	nop
 8010708:	20000aa8 	.word	0x20000aa8
 801070c:	08014c71 	.word	0x08014c71

08010710 <input_s21_offset>:
{
 8010710:	b508      	push	{r3, lr}
  if (b)
 8010712:	b121      	cbz	r1, 801071e <input_s21_offset+0xe>
    b->p1.f = s21_offset;
 8010714:	4b05      	ldr	r3, [pc, #20]	@ (801072c <input_s21_offset+0x1c>)
 8010716:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 801071a:	604b      	str	r3, [r1, #4]
}
 801071c:	bd08      	pop	{r3, pc}
  set_s21_offset(keyboard_get_float());
 801071e:	f7ff ff03 	bl	8010528 <keyboard_get_float>
}
 8010722:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_s21_offset(keyboard_get_float());
 8010726:	f7f8 be9b 	b.w	8009460 <set_s21_offset>
 801072a:	bf00      	nop
 801072c:	20000aa8 	.word	0x20000aa8

08010730 <input_cable_len>:
{
 8010730:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8010732:	4c10      	ldr	r4, [pc, #64]	@ (8010774 <input_cable_len+0x44>)
  if (b)
 8010734:	b1b9      	cbz	r1, 8010766 <input_cable_len+0x36>
    if (real_cable_len == 0.0f)
 8010736:	edd4 7a00 	vldr	s15, [r4]
 801073a:	eef5 7a40 	vcmp.f32	s15, #0.0
 801073e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8010742:	d014      	beq.n	801076e <input_cable_len+0x3e>
    plot_printf(b->label, sizeof(b->label), "%s\n " R_LINK_COLOR "%.4F%s", "CABLE LENGTH", real_cable_len, S_METRE);
 8010744:	4b0c      	ldr	r3, [pc, #48]	@ (8010778 <input_cable_len+0x48>)
 8010746:	9302      	str	r3, [sp, #8]
 8010748:	ee17 0a90 	vmov	r0, s15
 801074c:	f101 0408 	add.w	r4, r1, #8
 8010750:	f7ef ff26 	bl	80005a0 <__aeabi_f2d>
 8010754:	4b09      	ldr	r3, [pc, #36]	@ (801077c <input_cable_len+0x4c>)
 8010756:	4a0a      	ldr	r2, [pc, #40]	@ (8010780 <input_cable_len+0x50>)
 8010758:	e9cd 0100 	strd	r0, r1, [sp]
 801075c:	2120      	movs	r1, #32
 801075e:	4620      	mov	r0, r4
 8010760:	f7f2 fb06 	bl	8002d70 <plot_printf>
    return;
 8010764:	e003      	b.n	801076e <input_cable_len+0x3e>
  real_cable_len = keyboard_get_float();
 8010766:	f7ff fedf 	bl	8010528 <keyboard_get_float>
 801076a:	ed84 0a00 	vstr	s0, [r4]
}
 801076e:	b004      	add	sp, #16
 8010770:	bd10      	pop	{r4, pc}
 8010772:	bf00      	nop
 8010774:	200069f8 	.word	0x200069f8
 8010778:	08014c94 	.word	0x08014c94
 801077c:	08014c87 	.word	0x08014c87
 8010780:	08014c64 	.word	0x08014c64

08010784 <input_measure_r>:
{
 8010784:	b510      	push	{r4, lr}
 8010786:	4c05      	ldr	r4, [pc, #20]	@ (801079c <input_measure_r+0x18>)
  if (b)
 8010788:	b111      	cbz	r1, 8010790 <input_measure_r+0xc>
    b->p1.f = config._measure_r;
 801078a:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
 801078c:	604b      	str	r3, [r1, #4]
    return;
 801078e:	e003      	b.n	8010798 <input_measure_r+0x14>
  config._measure_r = keyboard_get_float();
 8010790:	f7ff feca 	bl	8010528 <keyboard_get_float>
 8010794:	ed84 0a1a 	vstr	s0, [r4, #104]	@ 0x68
}
 8010798:	bd10      	pop	{r4, pc}
 801079a:	bf00      	nop
 801079c:	20000318 	.word	0x20000318

080107a0 <input_rtc_cal>:
{
 80107a0:	b510      	push	{r4, lr}
  if (b)
 80107a2:	b129      	cbz	r1, 80107b0 <input_rtc_cal+0x10>
 80107a4:	460c      	mov	r4, r1
    b->p1.f = rtc_get_cal();
 80107a6:	f001 fb13 	bl	8011dd0 <rtc_get_cal>
 80107aa:	ed84 0a01 	vstr	s0, [r4, #4]
}
 80107ae:	bd10      	pop	{r4, pc}
  rtc_set_cal(keyboard_get_float());
 80107b0:	f7ff feba 	bl	8010528 <keyboard_get_float>
}
 80107b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  rtc_set_cal(keyboard_get_float());
 80107b8:	f001 baea 	b.w	8011d90 <rtc_set_cal>

080107bc <keyboard_get_freq>:
freq_t keyboard_get_freq(void) { return my_atoui(kp_buf); }
 80107bc:	4801      	ldr	r0, [pc, #4]	@ (80107c4 <keyboard_get_freq+0x8>)
 80107be:	f7f9 b8b5 	b.w	800992c <my_atoui>
 80107c2:	bf00      	nop
 80107c4:	20008a10 	.word	0x20008a10

080107c8 <input_freq>:
{
 80107c8:	b510      	push	{r4, lr}
 80107ca:	4604      	mov	r4, r0
  if (b)
 80107cc:	b309      	cbz	r1, 8010812 <input_freq+0x4a>
    if (data == ST_VAR && var_freq)
 80107ce:	2c06      	cmp	r4, #6
 80107d0:	4608      	mov	r0, r1
 80107d2:	d109      	bne.n	80107e8 <input_freq+0x20>
 80107d4:	4b13      	ldr	r3, [pc, #76]	@ (8010824 <input_freq+0x5c>)
 80107d6:	695b      	ldr	r3, [r3, #20]
 80107d8:	b31b      	cbz	r3, 8010822 <input_freq+0x5a>
}
 80107da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      plot_printf(b->label, sizeof(b->label), "JOG STEP\n " R_LINK_COLOR "%.3q" S_Hz, var_freq);
 80107de:	4a12      	ldr	r2, [pc, #72]	@ (8010828 <input_freq+0x60>)
 80107e0:	2120      	movs	r1, #32
 80107e2:	3008      	adds	r0, #8
 80107e4:	f7f2 bac4 	b.w	8002d70 <plot_printf>
    if (data == ST_STEP)
 80107e8:	2c05      	cmp	r4, #5
 80107ea:	d11a      	bne.n	8010822 <input_freq+0x5a>
    case ST_SPAN:   return frequency1 - frequency0;
 80107ec:	4a0d      	ldr	r2, [pc, #52]	@ (8010824 <input_freq+0x5c>)
 80107ee:	e9d2 1301 	ldrd	r1, r3, [r2, #4]
 80107f2:	1a5b      	subs	r3, r3, r1
      b->p1.f = (float)get_sweep_frequency(ST_SPAN) / (sweep_points - 1);
 80107f4:	ee07 3a90 	vmov	s15, r3
 80107f8:	8b53      	ldrh	r3, [r2, #26]
 80107fa:	3b01      	subs	r3, #1
 80107fc:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8010800:	ee07 3a90 	vmov	s15, r3
 8010804:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8010808:	eec7 6a27 	vdiv.f32	s13, s14, s15
 801080c:	edc0 6a01 	vstr	s13, [r0, #4]
 8010810:	e007      	b.n	8010822 <input_freq+0x5a>
  set_sweep_frequency(data, keyboard_get_freq());
 8010812:	f7ff ffd3 	bl	80107bc <keyboard_get_freq>
 8010816:	4601      	mov	r1, r0
 8010818:	4620      	mov	r0, r4
}
 801081a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  set_sweep_frequency(data, keyboard_get_freq());
 801081e:	f7f7 b959 	b.w	8007ad4 <set_sweep_frequency>
}
 8010822:	bd10      	pop	{r4, pc}
 8010824:	20000aa8 	.word	0x20000aa8
 8010828:	08014c96 	.word	0x08014c96

0801082c <input_vbat>:
{
 801082c:	b510      	push	{r4, lr}
 801082e:	4c04      	ldr	r4, [pc, #16]	@ (8010840 <input_vbat+0x14>)
  if (b)
 8010830:	b111      	cbz	r1, 8010838 <input_vbat+0xc>
    b->p1.u = config._vbat_offset;
 8010832:	8b23      	ldrh	r3, [r4, #24]
 8010834:	604b      	str	r3, [r1, #4]
    return;
 8010836:	e002      	b.n	801083e <input_vbat+0x12>
  config._vbat_offset = keyboard_get_uint();
 8010838:	f7ff ffc0 	bl	80107bc <keyboard_get_freq>
 801083c:	8320      	strh	r0, [r4, #24]
}
 801083e:	bd10      	pop	{r4, pc}
 8010840:	20000318 	.word	0x20000318

08010844 <input_harmonic>:
{
 8010844:	b510      	push	{r4, lr}
 8010846:	4c04      	ldr	r4, [pc, #16]	@ (8010858 <input_harmonic+0x14>)
  if (b)
 8010848:	b111      	cbz	r1, 8010850 <input_harmonic+0xc>
    b->p1.u = config._harmonic_freq_threshold;
 801084a:	6863      	ldr	r3, [r4, #4]
 801084c:	604b      	str	r3, [r1, #4]
    return;
 801084e:	e002      	b.n	8010856 <input_harmonic+0x12>
  config._harmonic_freq_threshold = keyboard_get_uint();
 8010850:	f7ff ffb4 	bl	80107bc <keyboard_get_freq>
 8010854:	6060      	str	r0, [r4, #4]
}
 8010856:	bd10      	pop	{r4, pc}
 8010858:	20000318 	.word	0x20000318

0801085c <input_xtal>:
{
 801085c:	b508      	push	{r3, lr}
  if (b)
 801085e:	b119      	cbz	r1, 8010868 <input_xtal+0xc>
    b->p1.u = config._xtal_freq;
 8010860:	4b04      	ldr	r3, [pc, #16]	@ (8010874 <input_xtal+0x18>)
 8010862:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8010864:	604b      	str	r3, [r1, #4]
}
 8010866:	bd08      	pop	{r3, pc}
  si5351_set_tcxo(keyboard_get_uint());
 8010868:	f7ff ffa8 	bl	80107bc <keyboard_get_freq>
}
 801086c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  si5351_set_tcxo(keyboard_get_uint());
 8010870:	f7f9 bb04 	b.w	8009e7c <si5351_set_tcxo>
 8010874:	20000318 	.word	0x20000318

08010878 <input_velocity>:
{
 8010878:	b510      	push	{r4, lr}
 801087a:	4c05      	ldr	r4, [pc, #20]	@ (8010890 <input_velocity+0x18>)
  if (b)
 801087c:	b119      	cbz	r1, 8010886 <input_velocity+0xe>
    b->p1.u = velocity_factor;
 801087e:	f894 3099 	ldrb.w	r3, [r4, #153]	@ 0x99
 8010882:	604b      	str	r3, [r1, #4]
    return;
 8010884:	e003      	b.n	801088e <input_velocity+0x16>
  velocity_factor = keyboard_get_uint();
 8010886:	f7ff ff99 	bl	80107bc <keyboard_get_freq>
 801088a:	f884 0099 	strb.w	r0, [r4, #153]	@ 0x99
}
 801088e:	bd10      	pop	{r4, pc}
 8010890:	20000aa8 	.word	0x20000aa8

08010894 <input_points>:
{
 8010894:	b508      	push	{r3, lr}
  if (b)
 8010896:	b119      	cbz	r1, 80108a0 <input_points+0xc>
    b->p1.u = sweep_points;
 8010898:	4b05      	ldr	r3, [pc, #20]	@ (80108b0 <input_points+0x1c>)
 801089a:	8b5b      	ldrh	r3, [r3, #26]
 801089c:	604b      	str	r3, [r1, #4]
}
 801089e:	bd08      	pop	{r3, pc}
  set_sweep_points(keyboard_get_uint());
 80108a0:	f7ff ff8c 	bl	80107bc <keyboard_get_freq>
}
 80108a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  set_sweep_points(keyboard_get_uint());
 80108a8:	b280      	uxth	r0, r0
 80108aa:	f7f7 b859 	b.w	8007960 <set_sweep_points>
 80108ae:	bf00      	nop
 80108b0:	20000aa8 	.word	0x20000aa8

080108b4 <ui_process>:
    ui_handler[ui_mode].touch(touch_x, touch_y);
  }
}

void ui_process(void)
{
 80108b4:	b513      	push	{r0, r1, r4, lr}
  // if (ui_mode >= UI_END) return; // for safe

  if (operation_requested & OP_LEVER)
 80108b6:	4c14      	ldr	r4, [pc, #80]	@ (8010908 <ui_process+0x54>)
 80108b8:	7823      	ldrb	r3, [r4, #0]
 80108ba:	07da      	lsls	r2, r3, #31
 80108bc:	d508      	bpl.n	80108d0 <ui_process+0x1c>
  uint16_t status = btn_check();
 80108be:	f7fd fddd 	bl	800e47c <btn_check>
  if (status)
 80108c2:	b128      	cbz	r0, 80108d0 <ui_process+0x1c>
    ui_handler[ui_mode].button(status);
 80108c4:	4b11      	ldr	r3, [pc, #68]	@ (801090c <ui_process+0x58>)
 80108c6:	781a      	ldrb	r2, [r3, #0]
 80108c8:	4b11      	ldr	r3, [pc, #68]	@ (8010910 <ui_process+0x5c>)
 80108ca:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80108ce:	4798      	blx	r3
    ui_process_lever();
  if (operation_requested & OP_TOUCH)
 80108d0:	7823      	ldrb	r3, [r4, #0]
 80108d2:	079b      	lsls	r3, r3, #30
 80108d4:	d511      	bpl.n	80108fa <ui_process+0x46>
  int status = touch_check();
 80108d6:	f7fd fd8b 	bl	800e3f0 <touch_check>
  if (status == EVT_TOUCH_PRESSED || status == EVT_TOUCH_DOWN)
 80108da:	3801      	subs	r0, #1
 80108dc:	2801      	cmp	r0, #1
 80108de:	d80c      	bhi.n	80108fa <ui_process+0x46>
    touch_position(&touch_x, &touch_y);
 80108e0:	a901      	add	r1, sp, #4
 80108e2:	4668      	mov	r0, sp
 80108e4:	f7fd fc5c 	bl	800e1a0 <touch_position>
    ui_handler[ui_mode].touch(touch_x, touch_y);
 80108e8:	4b08      	ldr	r3, [pc, #32]	@ (801090c <ui_process+0x58>)
 80108ea:	781a      	ldrb	r2, [r3, #0]
 80108ec:	4b08      	ldr	r3, [pc, #32]	@ (8010910 <ui_process+0x5c>)
 80108ee:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80108f2:	e9dd 0100 	ldrd	r0, r1, [sp]
 80108f6:	685b      	ldr	r3, [r3, #4]
 80108f8:	4798      	blx	r3
    ui_process_touch();

  touch_start_watchdog();
 80108fa:	f7fe fb77 	bl	800efec <touch_start_watchdog>
  operation_requested = OP_NONE;
 80108fe:	2300      	movs	r3, #0
 8010900:	7023      	strb	r3, [r4, #0]
}
 8010902:	b002      	add	sp, #8
 8010904:	bd10      	pop	{r4, pc}
 8010906:	bf00      	nop
 8010908:	20008a23 	.word	0x20008a23
 801090c:	20008a0c 	.word	0x20008a0c
 8010910:	08016854 	.word	0x08016854

08010914 <handle_button_interrupt>:

void handle_button_interrupt(uint16_t channel)
{
  (void)channel;
  operation_requested |= OP_LEVER;
 8010914:	4a02      	ldr	r2, [pc, #8]	@ (8010920 <handle_button_interrupt+0xc>)
 8010916:	7813      	ldrb	r3, [r2, #0]
 8010918:	f043 0301 	orr.w	r3, r3, #1
 801091c:	7013      	strb	r3, [r2, #0]
  // cur_button = READ_PORT() & BUTTON_MASK;
}
 801091e:	4770      	bx	lr
 8010920:	20008a23 	.word	0x20008a23

08010924 <handle_touch_interrupt>:
// static systime_t t_time = 0;
//  Triggered touch interrupt call
void handle_touch_interrupt(void)
{

if (targetting_mode)
 8010924:	4b04      	ldr	r3, [pc, #16]	@ (8010938 <handle_touch_interrupt+0x14>)
 8010926:	781b      	ldrb	r3, [r3, #0]
 8010928:	b923      	cbnz	r3, 8010934 <handle_touch_interrupt+0x10>
return;


  operation_requested |= OP_TOUCH;
 801092a:	4a04      	ldr	r2, [pc, #16]	@ (801093c <handle_touch_interrupt+0x18>)
 801092c:	7813      	ldrb	r3, [r2, #0]
 801092e:	f043 0302 	orr.w	r3, r3, #2
 8010932:	7013      	strb	r3, [r2, #0]
  //  systime_t n_time = chVTGetSystemTimeX();
  //  shell_printf("%d\r\n", n_time - t_time);
  //  t_time = n_time;
}
 8010934:	4770      	bx	lr
 8010936:	bf00      	nop
 8010938:	200003d6 	.word	0x200003d6
 801093c:	20008a23 	.word	0x20008a23

08010940 <remote_touch_set>:
  touch_remote = state;
 8010940:	4b05      	ldr	r3, [pc, #20]	@ (8010958 <remote_touch_set+0x18>)
 8010942:	7018      	strb	r0, [r3, #0]
  if (x != -1)
 8010944:	1c48      	adds	r0, r1, #1
    last_touch_x = x;
 8010946:	bf1c      	itt	ne
 8010948:	4b04      	ldrne	r3, [pc, #16]	@ (801095c <remote_touch_set+0x1c>)
 801094a:	8019      	strhne	r1, [r3, #0]
  if (y != -1)
 801094c:	1c53      	adds	r3, r2, #1
    last_touch_y = y;
 801094e:	bf1c      	itt	ne
 8010950:	4b03      	ldrne	r3, [pc, #12]	@ (8010960 <remote_touch_set+0x20>)
 8010952:	801a      	strhne	r2, [r3, #0]
  handle_touch_interrupt();
 8010954:	f7ff bfe6 	b.w	8010924 <handle_touch_interrupt>
 8010958:	20008a04 	.word	0x20008a04
 801095c:	20008a26 	.word	0x20008a26
 8010960:	20008a24 	.word	0x20008a24

08010964 <ui_init>:
  ext_channel_enable(3, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
}
#endif

void ui_init()
{
 8010964:	b508      	push	{r3, lr}
  adc_init();
 8010966:	f001 f82f 	bl	80119c8 <adc_init>
  extStart();
 801096a:	f001 fbb3 	bl	80120d4 <extStart>
  ext_channel_enable(1, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
 801096e:	2101      	movs	r1, #1
 8010970:	4608      	mov	r0, r1
 8010972:	f001 fbbf 	bl	80120f4 <ext_channel_enable>
  ext_channel_enable(2, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
 8010976:	2101      	movs	r1, #1
 8010978:	2002      	movs	r0, #2
 801097a:	f001 fbbb 	bl	80120f4 <ext_channel_enable>
  ext_channel_enable(3, EXT_CH_MODE_RISING_EDGE | EXT_MODE_GPIOA);
 801097e:	2101      	movs	r1, #1
 8010980:	2003      	movs	r0, #3
 8010982:	f001 fbb7 	bl	80120f4 <ext_channel_enable>
  touch_prepare_sense();
 8010986:	f7fd fccf 	bl	800e328 <touch_prepare_sense>
  initTimers();
 801098a:	f001 fbef 	bl	801216c <initTimers>
  startTimer(TIM3, 10); // Start timer 10ms period (use 1kHz clock)
 801098e:	4808      	ldr	r0, [pc, #32]	@ (80109b0 <ui_init+0x4c>)
 8010990:	210a      	movs	r1, #10
 8010992:	f001 fbff 	bl	8012194 <startTimer>
  touch_start_watchdog(); // Start ADC watchdog (measure by timer 3 interval and trigger interrupt if touch pressed)
 8010996:	f7fe fb29 	bl	800efec <touch_start_watchdog>
  init_EXT();
  // Init touch subsystem
  touch_init();
  // Set LCD display brightness
#ifdef __LCD_BRIGHTNESS__
  lcd_setBrightness(config._brightness);
 801099a:	4b06      	ldr	r3, [pc, #24]	@ (80109b4 <ui_init+0x50>)
 801099c:	7f58      	ldrb	r0, [r3, #29]
  dac_setvalue_ch2(700 + b * (4000 - 700) / 100);
 801099e:	eb00 1040 	add.w	r0, r0, r0, lsl #5
#endif
}
 80109a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  dac_setvalue_ch2(700 + b * (4000 - 700) / 100);
 80109a6:	f500 702f 	add.w	r0, r0, #700	@ 0x2bc
 80109aa:	f001 ba39 	b.w	8011e20 <dac_setvalue_ch2>
 80109ae:	bf00      	nop
 80109b0:	40000400 	.word	0x40000400
 80109b4:	20000318 	.word	0x20000318

080109b8 <ui_close_all>:


// Close any UI overlay (menu/keypad/browser), and reset menu stack to top.
void ui_close_all(void)
{
 80109b8:	b508      	push	{r3, lr}
  // Reset menu navigation stack
  menu_current_level = 0;
 80109ba:	4b0e      	ldr	r3, [pc, #56]	@ (80109f4 <ui_close_all+0x3c>)
  menu_stack[0] = menu_top;
 80109bc:	4a0e      	ldr	r2, [pc, #56]	@ (80109f8 <ui_close_all+0x40>)
  menu_current_level = 0;
 80109be:	2100      	movs	r1, #0
 80109c0:	7019      	strb	r1, [r3, #0]
  menu_stack[0] = menu_top;
 80109c2:	4b0e      	ldr	r3, [pc, #56]	@ (80109fc <ui_close_all+0x44>)
  for (int i = 1; i < MENU_STACK_DEPTH_MAX; i++)
    menu_stack[i] = NULL;
 80109c4:	e9c3 2100 	strd	r2, r1, [r3]
 80109c8:	e9c3 1102 	strd	r1, r1, [r3, #8]
 80109cc:	6119      	str	r1, [r3, #16]

  selection = -1;
 80109ce:	4b0c      	ldr	r3, [pc, #48]	@ (8010a00 <ui_close_all+0x48>)
 80109d0:	22ff      	movs	r2, #255	@ 0xff
 80109d2:	701a      	strb	r2, [r3, #0]
  ensure_selection();          // recompute menu_button_height safely
 80109d4:	f7fe fd8a 	bl	800f4ec <ensure_selection>

  // Leave any UI overlay state
  ui_mode = UI_NORMAL;         // force "normal"
 80109d8:	4b0a      	ldr	r3, [pc, #40]	@ (8010a04 <ui_close_all+0x4c>)
  set_area_size(AREA_WIDTH_NORMAL, AREA_HEIGHT_NORMAL);
 80109da:	f240 10d1 	movw	r0, #465	@ 0x1d1
  ui_mode = UI_NORMAL;         // force "normal"
 80109de:	7019      	strb	r1, [r3, #0]
  set_area_size(AREA_WIDTH_NORMAL, AREA_HEIGHT_NORMAL);
 80109e0:	f240 1131 	movw	r1, #305	@ 0x131
 80109e4:	f7fb feb6 	bl	800c754 <set_area_size>
  // kp_buf[0] = 0;
  // keypads = NULL;
  // keypad_mode = KM_NONE;

  request_to_redraw(REDRAW_ALL);
}
 80109e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  request_to_redraw(REDRAW_ALL);
 80109ec:	f240 301a 	movw	r0, #794	@ 0x31a
 80109f0:	f7fb beba 	b.w	800c768 <request_to_redraw>
 80109f4:	20008a05 	.word	0x20008a05
 80109f8:	08016b40 	.word	0x08016b40
 80109fc:	200003dc 	.word	0x200003dc
 8010a00:	200003f0 	.word	0x200003f0
 8010a04:	20008a0c 	.word	0x20008a0c

08010a08 <dmaChannelWaitCompletionRxTx>:
    dmaChannelWaitCompletion(LCD_DMA_TX);
}

// Wait DMA Rx completion
static void dmaChannelWaitCompletionRxTx(void) {
  dmaChannelWaitCompletion(LCD_DMA_TX);
 8010a08:	4905      	ldr	r1, [pc, #20]	@ (8010a20 <dmaChannelWaitCompletionRxTx+0x18>)
 8010a0a:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 8010a0c:	2b00      	cmp	r3, #0
 8010a0e:	d1fc      	bne.n	8010a0a <dmaChannelWaitCompletionRxTx+0x2>
  dmaChannelWaitCompletion(LCD_DMA_RX);
 8010a10:	4a03      	ldr	r2, [pc, #12]	@ (8010a20 <dmaChannelWaitCompletionRxTx+0x18>)
  dmaChannelWaitCompletion(LCD_DMA_TX);
 8010a12:	630b      	str	r3, [r1, #48]	@ 0x30
  dmaChannelWaitCompletion(LCD_DMA_RX);
 8010a14:	6a13      	ldr	r3, [r2, #32]
 8010a16:	2b00      	cmp	r3, #0
 8010a18:	d1fc      	bne.n	8010a14 <dmaChannelWaitCompletionRxTx+0xc>
 8010a1a:	61d3      	str	r3, [r2, #28]
//  while (SPI_IS_BUSY(LCD_SPI));   // Wait SPI tx/rx
}
 8010a1c:	4770      	bx	lr
 8010a1e:	bf00      	nop
 8010a20:	40020000 	.word	0x40020000

08010a24 <SD_Select_SPI>:
//               SD card SPI functions
//*******************************************************
#define SD_CS_LOW     palClearPad(GPIOB, GPIOB_SD_CS)
#define SD_CS_HIGH    palSetPad(GPIOB, GPIOB_SD_CS)

static void SD_Select_SPI(uint32_t speed) {
 8010a24:	b410      	push	{r4}
  while (SPI_IS_BUSY(LCD_SPI));
 8010a26:	4a09      	ldr	r2, [pc, #36]	@ (8010a4c <SD_Select_SPI+0x28>)
 8010a28:	6893      	ldr	r3, [r2, #8]
 8010a2a:	061b      	lsls	r3, r3, #24
 8010a2c:	d4fc      	bmi.n	8010a28 <SD_Select_SPI+0x4>
  LCD_CS_HIGH;               // Unselect LCD
 8010a2e:	4908      	ldr	r1, [pc, #32]	@ (8010a50 <SD_Select_SPI+0x2c>)
 8010a30:	2340      	movs	r3, #64	@ 0x40
 8010a32:	618b      	str	r3, [r1, #24]
  SPI_BR_SET(SD_SPI, speed); // Set Baud rate control for SD card
 8010a34:	6813      	ldr	r3, [r2, #0]
 8010a36:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
  SD_CS_LOW;                 // Select SD Card
 8010a3a:	f04f 6400 	mov.w	r4, #134217728	@ 0x8000000
  SPI_BR_SET(SD_SPI, speed); // Set Baud rate control for SD card
 8010a3e:	4303      	orrs	r3, r0
 8010a40:	6013      	str	r3, [r2, #0]
  SD_CS_LOW;                 // Select SD Card
 8010a42:	618c      	str	r4, [r1, #24]
}
 8010a44:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010a48:	4770      	bx	lr
 8010a4a:	bf00      	nop
 8010a4c:	40013000 	.word	0x40013000
 8010a50:	48000400 	.word	0x48000400

08010a54 <spi_TxByte>:
  while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8010a54:	4a02      	ldr	r2, [pc, #8]	@ (8010a60 <spi_TxByte+0xc>)
 8010a56:	6893      	ldr	r3, [r2, #8]
 8010a58:	079b      	lsls	r3, r3, #30
 8010a5a:	d5fc      	bpl.n	8010a56 <spi_TxByte+0x2>
  SPI_WRITE_8BIT(LCD_SPI, data);
 8010a5c:	7310      	strb	r0, [r2, #12]
}
 8010a5e:	4770      	bx	lr
 8010a60:	40013000 	.word	0x40013000

08010a64 <spi_TxBuffer>:
  while(len--) {
 8010a64:	1e4b      	subs	r3, r1, #1
 8010a66:	b29b      	uxth	r3, r3
 8010a68:	b151      	cbz	r1, 8010a80 <spi_TxBuffer+0x1c>
 8010a6a:	3301      	adds	r3, #1
    while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8010a6c:	4a05      	ldr	r2, [pc, #20]	@ (8010a84 <spi_TxBuffer+0x20>)
 8010a6e:	18c1      	adds	r1, r0, r3
 8010a70:	6893      	ldr	r3, [r2, #8]
 8010a72:	079b      	lsls	r3, r3, #30
 8010a74:	d5fc      	bpl.n	8010a70 <spi_TxBuffer+0xc>
    SPI_WRITE_8BIT(LCD_SPI, *buffer++);
 8010a76:	f810 3b01 	ldrb.w	r3, [r0], #1
 8010a7a:	7313      	strb	r3, [r2, #12]
  while(len--) {
 8010a7c:	4288      	cmp	r0, r1
 8010a7e:	d1f7      	bne.n	8010a70 <spi_TxBuffer+0xc>
}
 8010a80:	4770      	bx	lr
 8010a82:	bf00      	nop
 8010a84:	40013000 	.word	0x40013000

08010a88 <lcd_send_command>:
static void lcd_send_command(uint8_t cmd, uint16_t len, const uint8_t *data) {
 8010a88:	b430      	push	{r4, r5}
  while (SPI_IS_BUSY(LCD_SPI));
 8010a8a:	4c0c      	ldr	r4, [pc, #48]	@ (8010abc <lcd_send_command+0x34>)
static void lcd_send_command(uint8_t cmd, uint16_t len, const uint8_t *data) {
 8010a8c:	4684      	mov	ip, r0
 8010a8e:	4610      	mov	r0, r2
  while (SPI_IS_BUSY(LCD_SPI));
 8010a90:	68a3      	ldr	r3, [r4, #8]
 8010a92:	061a      	lsls	r2, r3, #24
 8010a94:	d4fc      	bmi.n	8010a90 <lcd_send_command+0x8>
  LCD_CS_LOW;
 8010a96:	4b0a      	ldr	r3, [pc, #40]	@ (8010ac0 <lcd_send_command+0x38>)
  while (SPI_IS_BUSY(LCD_SPI));
 8010a98:	4d08      	ldr	r5, [pc, #32]	@ (8010abc <lcd_send_command+0x34>)
  LCD_CS_LOW;
 8010a9a:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8010a9e:	619a      	str	r2, [r3, #24]
  LCD_DC_CMD;
 8010aa0:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 8010aa4:	619a      	str	r2, [r3, #24]
  SPI_WRITE_8BIT(LCD_SPI, cmd);
 8010aa6:	f884 c00c 	strb.w	ip, [r4, #12]
  while (SPI_IS_BUSY(LCD_SPI));
 8010aaa:	68ab      	ldr	r3, [r5, #8]
 8010aac:	061b      	lsls	r3, r3, #24
 8010aae:	d4fc      	bmi.n	8010aaa <lcd_send_command+0x22>
  LCD_DC_DATA;
 8010ab0:	4b03      	ldr	r3, [pc, #12]	@ (8010ac0 <lcd_send_command+0x38>)
 8010ab2:	2280      	movs	r2, #128	@ 0x80
}
 8010ab4:	bc30      	pop	{r4, r5}
  LCD_DC_DATA;
 8010ab6:	619a      	str	r2, [r3, #24]
  spi_TxBuffer(data, len);
 8010ab8:	f7ff bfd4 	b.w	8010a64 <spi_TxBuffer>
 8010abc:	40013000 	.word	0x40013000
 8010ac0:	48000400 	.word	0x48000400

08010ac4 <spi_RxByte>:
  SPI_WRITE_8BIT(LCD_SPI, 0xFF);
 8010ac4:	4a03      	ldr	r2, [pc, #12]	@ (8010ad4 <spi_RxByte+0x10>)
 8010ac6:	23ff      	movs	r3, #255	@ 0xff
 8010ac8:	7313      	strb	r3, [r2, #12]
  while (SPI_RX_IS_EMPTY(LCD_SPI));
 8010aca:	6893      	ldr	r3, [r2, #8]
 8010acc:	07db      	lsls	r3, r3, #31
 8010ace:	d5fc      	bpl.n	8010aca <spi_RxByte+0x6>
  return SPI_READ_8BIT(LCD_SPI);
 8010ad0:	7b10      	ldrb	r0, [r2, #12]
}
 8010ad2:	4770      	bx	lr
 8010ad4:	40013000 	.word	0x40013000

08010ad8 <SD_Unselect_SPI>:

static void SD_Unselect_SPI(void) {
 8010ad8:	b508      	push	{r3, lr}
  while (SPI_IS_BUSY(SD_SPI));
 8010ada:	4907      	ldr	r1, [pc, #28]	@ (8010af8 <SD_Unselect_SPI+0x20>)
 8010adc:	688b      	ldr	r3, [r1, #8]
 8010ade:	061b      	lsls	r3, r3, #24
 8010ae0:	d4fc      	bmi.n	8010adc <SD_Unselect_SPI+0x4>
  SD_CS_HIGH;                         // Unselect SD Card
 8010ae2:	4b06      	ldr	r3, [pc, #24]	@ (8010afc <SD_Unselect_SPI+0x24>)
 8010ae4:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8010ae8:	619a      	str	r2, [r3, #24]
  spi_RxByte();                       // Dummy read/write one Byte recommend for SD after CS up
 8010aea:	f7ff ffeb 	bl	8010ac4 <spi_RxByte>
  SPI_BR_SET(LCD_SPI, LCD_SPI_SPEED); // Restore Baud rate for LCD
 8010aee:	680b      	ldr	r3, [r1, #0]
 8010af0:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
 8010af4:	600b      	str	r3, [r1, #0]
}
 8010af6:	bd08      	pop	{r3, pc}
 8010af8:	40013000 	.word	0x40013000
 8010afc:	48000400 	.word	0x48000400

08010b00 <spi_RxBuffer>:
void spi_RxBuffer(uint8_t *buffer, uint16_t len) {
 8010b00:	1e4b      	subs	r3, r1, #1
 8010b02:	b29b      	uxth	r3, r3
 8010b04:	3301      	adds	r3, #1
    SPI_WRITE_8BIT(LCD_SPI, 0xFF);
 8010b06:	4a07      	ldr	r2, [pc, #28]	@ (8010b24 <spi_RxBuffer+0x24>)
 8010b08:	18c1      	adds	r1, r0, r3
 8010b0a:	f04f 3cff 	mov.w	ip, #4294967295
 8010b0e:	f882 c00c 	strb.w	ip, [r2, #12]
    while (SPI_RX_IS_EMPTY(LCD_SPI));
 8010b12:	6893      	ldr	r3, [r2, #8]
 8010b14:	07db      	lsls	r3, r3, #31
 8010b16:	d5fc      	bpl.n	8010b12 <spi_RxBuffer+0x12>
    *buffer++ = SPI_READ_8BIT(LCD_SPI);
 8010b18:	7b13      	ldrb	r3, [r2, #12]
 8010b1a:	f800 3b01 	strb.w	r3, [r0], #1
  }while(--len);
 8010b1e:	4288      	cmp	r0, r1
 8010b20:	d1f5      	bne.n	8010b0e <spi_RxBuffer+0xe>
}
 8010b22:	4770      	bx	lr
 8010b24:	40013000 	.word	0x40013000

08010b28 <spi_DropRx>:
  while (SPI_RX_IS_NOT_EMPTY(LCD_SPI)||SPI_IS_BUSY(LCD_SPI))
 8010b28:	4b05      	ldr	r3, [pc, #20]	@ (8010b40 <spi_DropRx+0x18>)
 8010b2a:	e000      	b.n	8010b2e <spi_DropRx+0x6>
    (void)SPI_READ_8BIT(LCD_SPI);
 8010b2c:	7b1a      	ldrb	r2, [r3, #12]
  while (SPI_RX_IS_NOT_EMPTY(LCD_SPI)||SPI_IS_BUSY(LCD_SPI))
 8010b2e:	689a      	ldr	r2, [r3, #8]
 8010b30:	07d1      	lsls	r1, r2, #31
 8010b32:	d4fb      	bmi.n	8010b2c <spi_DropRx+0x4>
 8010b34:	689a      	ldr	r2, [r3, #8]
 8010b36:	0612      	lsls	r2, r2, #24
 8010b38:	d4f8      	bmi.n	8010b2c <spi_DropRx+0x4>
  (void)SPI_READ_8BIT(LCD_SPI);
 8010b3a:	7b1b      	ldrb	r3, [r3, #12]
}
 8010b3c:	4770      	bx	lr
 8010b3e:	bf00      	nop
 8010b40:	40013000 	.word	0x40013000

08010b44 <SD_WaitNotBusy>:
    ;
  return res&0x1F;
}

// Wait no Busy answer from SD (wait time in systick)
static uint8_t SD_WaitNotBusy(uint32_t wait_time) {
 8010b44:	b570      	push	{r4, r5, r6, lr}
 8010b46:	f04f 4580 	mov.w	r5, #1073741824	@ 0x40000000
 8010b4a:	4604      	mov	r4, r0
 8010b4c:	6a6e      	ldr	r6, [r5, #36]	@ 0x24
  uint8_t res;
  uint32_t time = chVTGetSystemTimeX();
  spi_DropRx();
 8010b4e:	f7ff ffeb 	bl	8010b28 <spi_DropRx>
 8010b52:	e003      	b.n	8010b5c <SD_WaitNotBusy+0x18>
 8010b54:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
  do {
    if ((res = spi_RxByte()) == 0xFF)
      return res;
  } while(chVTGetSystemTimeX() - time < wait_time);
 8010b56:	1b9b      	subs	r3, r3, r6
 8010b58:	42a3      	cmp	r3, r4
 8010b5a:	d204      	bcs.n	8010b66 <SD_WaitNotBusy+0x22>
    if ((res = spi_RxByte()) == 0xFF)
 8010b5c:	f7ff ffb2 	bl	8010ac4 <spi_RxByte>
 8010b60:	28ff      	cmp	r0, #255	@ 0xff
 8010b62:	d1f7      	bne.n	8010b54 <SD_WaitNotBusy+0x10>
  return 0;
}
 8010b64:	bd70      	pop	{r4, r5, r6, pc}
  return 0;
 8010b66:	2000      	movs	r0, #0
}
 8010b68:	bd70      	pop	{r4, r5, r6, pc}
 8010b6a:	bf00      	nop

08010b6c <SD_TxDataBlock.constprop.0>:
#endif
  return TRUE;
}

// Transmit data block to SD
static bool SD_TxDataBlock(const uint8_t *buff, uint16_t len, uint8_t token) {
 8010b6c:	b508      	push	{r3, lr}
 8010b6e:	4603      	mov	r3, r0
  uint8_t r1;
  // Transmit token
  spi_TxByte(token);
 8010b70:	4608      	mov	r0, r1
static bool SD_TxDataBlock(const uint8_t *buff, uint16_t len, uint8_t token) {
 8010b72:	4619      	mov	r1, r3
  spi_TxByte(token);
 8010b74:	f7ff ff6e 	bl	8010a54 <spi_TxByte>
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 8010b78:	4a12      	ldr	r2, [pc, #72]	@ (8010bc4 <SD_TxDataBlock.constprop.0+0x58>)
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 8010b7a:	f44f 7000 	mov.w	r0, #512	@ 0x200
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010b7e:	f241 0391 	movw	r3, #4241	@ 0x1091
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 8010b82:	63d1      	str	r1, [r2, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 8010b84:	6350      	str	r0, [r2, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010b86:	6313      	str	r3, [r2, #48]	@ 0x30
  uint16_t bcrc = crc16(buff, len);
#else
  uint16_t bcrc = 0xFFFF;
#endif
#ifdef __USE_SDCARD_DMA__
  dmaChannelWaitCompletion(SD_DMA_TX);
 8010b88:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 8010b8a:	2b00      	cmp	r3, #0
 8010b8c:	d1fc      	bne.n	8010b88 <SD_TxDataBlock.constprop.0+0x1c>
 8010b8e:	6313      	str	r3, [r2, #48]	@ 0x30
#endif
  spi_TxByte((bcrc>>0) & 0xFF); // Send CRC
 8010b90:	20ff      	movs	r0, #255	@ 0xff
 8010b92:	f7ff ff5f 	bl	8010a54 <spi_TxByte>
  spi_TxByte((bcrc>>8) & 0xFF);
 8010b96:	f7ff ff5d 	bl	8010a54 <spi_TxByte>
  spi_DropRx();
 8010b9a:	f7ff ffc5 	bl	8010b28 <spi_DropRx>
  while((res = spi_RxByte()) == 0xFF && --cnt)
 8010b9e:	2164      	movs	r1, #100	@ 0x64
 8010ba0:	e001      	b.n	8010ba6 <SD_TxDataBlock.constprop.0+0x3a>
 8010ba2:	3901      	subs	r1, #1
 8010ba4:	d00b      	beq.n	8010bbe <SD_TxDataBlock.constprop.0+0x52>
 8010ba6:	f7ff ff8d 	bl	8010ac4 <spi_RxByte>
 8010baa:	28ff      	cmp	r0, #255	@ 0xff
 8010bac:	d0f9      	beq.n	8010ba2 <SD_TxDataBlock.constprop.0+0x36>
  // Receive transmit data response token on next 8 bytes
  if ((r1 = SD_WaitDataAccept(100)) != SD_TOKEN_DATA_ACCEPTED) {
 8010bae:	f000 001f 	and.w	r0, r0, #31
 8010bb2:	f1a0 0005 	sub.w	r0, r0, #5
 8010bb6:	fab0 f080 	clz	r0, r0
 8010bba:	0940      	lsrs	r0, r0, #5
    return FALSE;
  }
#endif
  // Continue execute, wait not busy on next command
  return TRUE;
}
 8010bbc:	bd08      	pop	{r3, pc}
 8010bbe:	4608      	mov	r0, r1
 8010bc0:	bd08      	pop	{r3, pc}
 8010bc2:	bf00      	nop
 8010bc4:	40020000 	.word	0x40020000

08010bc8 <SD_RxDataBlock.constprop.0>:
static bool SD_RxDataBlock(uint8_t *buff, uint16_t len, uint8_t token) {
 8010bc8:	b570      	push	{r4, r5, r6, lr}
 8010bca:	f04f 4480 	mov.w	r4, #1073741824	@ 0x40000000
 8010bce:	b082      	sub	sp, #8
 8010bd0:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 8010bd2:	4606      	mov	r6, r0
  spi_DropRx();
 8010bd4:	f7ff ffa8 	bl	8010b28 <spi_DropRx>
  while((res = spi_RxByte()) != token && chVTGetSystemTimeX() - time < wait_time)
 8010bd8:	f242 710f 	movw	r1, #9999	@ 0x270f
 8010bdc:	e003      	b.n	8010be6 <SD_RxDataBlock.constprop.0+0x1e>
 8010bde:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8010be0:	1b5b      	subs	r3, r3, r5
 8010be2:	428b      	cmp	r3, r1
 8010be4:	d81b      	bhi.n	8010c1e <SD_RxDataBlock.constprop.0+0x56>
 8010be6:	f7ff ff6d 	bl	8010ac4 <spi_RxByte>
 8010bea:	28fe      	cmp	r0, #254	@ 0xfe
 8010bec:	d1f7      	bne.n	8010bde <SD_RxDataBlock.constprop.0+0x16>
  dmaChannelSetMemory(LCD_DMA_RX, buffer);
 8010bee:	4b0d      	ldr	r3, [pc, #52]	@ (8010c24 <SD_RxDataBlock.constprop.0+0x5c>)
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 8010bf0:	480d      	ldr	r0, [pc, #52]	@ (8010c28 <SD_RxDataBlock.constprop.0+0x60>)
  dmaChannelSetMemory(LCD_DMA_RX, buffer);
 8010bf2:	629e      	str	r6, [r3, #40]	@ 0x28
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 8010bf4:	f44f 7200 	mov.w	r2, #512	@ 0x200
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 8010bf8:	f241 0111 	movw	r1, #4113	@ 0x1011
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010bfc:	f241 0481 	movw	r4, #4225	@ 0x1081
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 8010c00:	621a      	str	r2, [r3, #32]
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010c02:	61dc      	str	r4, [r3, #28]
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 8010c04:	63d8      	str	r0, [r3, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 8010c06:	635a      	str	r2, [r3, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 8010c08:	6319      	str	r1, [r3, #48]	@ 0x30
    dmaChannelWaitCompletionRxTx();
 8010c0a:	f7ff fefd 	bl	8010a08 <dmaChannelWaitCompletionRxTx>
  uint16_t crc; spi_RxBuffer((uint8_t*)&crc, 2);
 8010c0e:	f10d 0006 	add.w	r0, sp, #6
 8010c12:	2102      	movs	r1, #2
 8010c14:	f7ff ff74 	bl	8010b00 <spi_RxBuffer>
  return TRUE;
 8010c18:	2001      	movs	r0, #1
}
 8010c1a:	b002      	add	sp, #8
 8010c1c:	bd70      	pop	{r4, r5, r6, pc}
    return FALSE;
 8010c1e:	2000      	movs	r0, #0
}
 8010c20:	b002      	add	sp, #8
 8010c22:	bd70      	pop	{r4, r5, r6, pc}
 8010c24:	40020000 	.word	0x40020000
 8010c28:	0801b9fc 	.word	0x0801b9fc

08010c2c <SD_SendCmd>:

// Transmit command to SD
static uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg) {
 8010c2c:	b530      	push	{r4, r5, lr}
  uint8_t buf[6];
  uint8_t r1;
  // Advanced command (ACMD__), need send CMD55 before
  if ((cmd & 0x80) && (r1 = SD_SendCmd(CMD55, 0)) > 1) return r1;
 8010c2e:	0602      	lsls	r2, r0, #24
static uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg) {
 8010c30:	b083      	sub	sp, #12
 8010c32:	4604      	mov	r4, r0
 8010c34:	460d      	mov	r5, r1
  if ((cmd & 0x80) && (r1 = SD_SendCmd(CMD55, 0)) > 1) return r1;
 8010c36:	d42f      	bmi.n	8010c98 <SD_SendCmd+0x6c>
  // wait SD ready after last Tx (recommended timeout is 250ms (500ms for SDXC) set 250ms
  if ((r1 = SD_WaitNotBusy(MS2ST(500))) != 0xFF) {
 8010c38:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8010c3c:	f7ff ff82 	bl	8010b44 <SD_WaitNotBusy>
 8010c40:	28ff      	cmp	r0, #255	@ 0xff
 8010c42:	d135      	bne.n	8010cb0 <SD_SendCmd+0x84>
    DEBUG_PRINT(" SD_WaitNotBusy CMD%d err, %02x\r\n", cmd-0x40, (uint32_t)r1);
    return 0xFF;
  }
  // Transmit command
  buf[0] = cmd & 0x7F;
 8010c44:	f004 027f 	and.w	r2, r4, #127	@ 0x7f
 8010c48:	2300      	movs	r3, #0
 8010c4a:	f362 0307 	bfi	r3, r2, #0, #8
  buf[1] = (arg >> 24)&0xFF;
 8010c4e:	0e2a      	lsrs	r2, r5, #24
  buf[0] = cmd & 0x7F;
 8010c50:	f362 230f 	bfi	r3, r2, #8, #8
  buf[2] = (arg >> 16)&0xFF;
 8010c54:	0c2a      	lsrs	r2, r5, #16
  buf[0] = cmd & 0x7F;
 8010c56:	f362 4317 	bfi	r3, r2, #16, #8
  buf[3] = (arg >>  8)&0xFF;
 8010c5a:	0a2a      	lsrs	r2, r5, #8
  buf[0] = cmd & 0x7F;
 8010c5c:	f362 631f 	bfi	r3, r2, #24, #8
  buf[4] = (arg >>  0)&0xFF;
#ifdef SD_USE_COMMAND_CRC
  buf[5] = crc7(buf, 5)|0x01;
#else
  uint8_t crc = 0x01;              // Dummy CRC + Stop
       if (cmd == CMD0) crc = 0x95;// Valid CRC for CMD0(0)
 8010c60:	2c40      	cmp	r4, #64	@ 0x40
  buf[0] = cmd & 0x7F;
 8010c62:	9300      	str	r3, [sp, #0]
  buf[4] = (arg >>  0)&0xFF;
 8010c64:	f88d 5004 	strb.w	r5, [sp, #4]
       if (cmd == CMD0) crc = 0x95;// Valid CRC for CMD0(0)
 8010c68:	d025      	beq.n	8010cb6 <SD_SendCmd+0x8a>
  else if (cmd == CMD8) crc = 0x87;// Valid CRC for CMD8(0x1AA)
 8010c6a:	2c48      	cmp	r4, #72	@ 0x48
 8010c6c:	d02e      	beq.n	8010ccc <SD_SendCmd+0xa0>
  buf[5] = crc;
 8010c6e:	2301      	movs	r3, #1
#endif
  spi_TxBuffer(buf, 6);
 8010c70:	2106      	movs	r1, #6
 8010c72:	4668      	mov	r0, sp
  buf[5] = crc;
 8010c74:	f88d 3005 	strb.w	r3, [sp, #5]
  spi_TxBuffer(buf, 6);
 8010c78:	f7ff fef4 	bl	8010a64 <spi_TxBuffer>
// Skip a stuff byte when STOP_TRANSMISSION
  if (cmd == CMD12) spi_RxByte();
 8010c7c:	2c4c      	cmp	r4, #76	@ 0x4c
 8010c7e:	d022      	beq.n	8010cc6 <SD_SendCmd+0x9a>
  spi_DropRx();
 8010c80:	f7ff ff52 	bl	8010b28 <spi_DropRx>
  while(((r1=spi_RxByte())&0x80) && --cnt)
 8010c84:	2164      	movs	r1, #100	@ 0x64
 8010c86:	e001      	b.n	8010c8c <SD_SendCmd+0x60>
 8010c88:	3901      	subs	r1, #1
 8010c8a:	d003      	beq.n	8010c94 <SD_SendCmd+0x68>
 8010c8c:	f7ff ff1a 	bl	8010ac4 <spi_RxByte>
 8010c90:	0603      	lsls	r3, r0, #24
 8010c92:	d4f9      	bmi.n	8010c88 <SD_SendCmd+0x5c>
    return r1;
  }
  if (r1&(~SD_R1_IDLE))
    DEBUG_PRINT(" SD_SendCmd CMD%d, 0x%x, 0x%08x\r\n", (uint32_t)cmd-0x40, (uint32_t)r1, arg);
  return r1;
}
 8010c94:	b003      	add	sp, #12
 8010c96:	bd30      	pop	{r4, r5, pc}
  if ((cmd & 0x80) && (r1 = SD_SendCmd(CMD55, 0)) > 1) return r1;
 8010c98:	2100      	movs	r1, #0
 8010c9a:	2077      	movs	r0, #119	@ 0x77
 8010c9c:	f7ff ffc6 	bl	8010c2c <SD_SendCmd>
 8010ca0:	2801      	cmp	r0, #1
 8010ca2:	d8f7      	bhi.n	8010c94 <SD_SendCmd+0x68>
  if ((r1 = SD_WaitNotBusy(MS2ST(500))) != 0xFF) {
 8010ca4:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8010ca8:	f7ff ff4c 	bl	8010b44 <SD_WaitNotBusy>
 8010cac:	28ff      	cmp	r0, #255	@ 0xff
 8010cae:	d0c9      	beq.n	8010c44 <SD_SendCmd+0x18>
    return 0xFF;
 8010cb0:	20ff      	movs	r0, #255	@ 0xff
}
 8010cb2:	b003      	add	sp, #12
 8010cb4:	bd30      	pop	{r4, r5, pc}
  buf[5] = crc;
 8010cb6:	2395      	movs	r3, #149	@ 0x95
  spi_TxBuffer(buf, 6);
 8010cb8:	2106      	movs	r1, #6
 8010cba:	4668      	mov	r0, sp
  buf[5] = crc;
 8010cbc:	f88d 3005 	strb.w	r3, [sp, #5]
  spi_TxBuffer(buf, 6);
 8010cc0:	f7ff fed0 	bl	8010a64 <spi_TxBuffer>
  if (cmd == CMD12) spi_RxByte();
 8010cc4:	e7dc      	b.n	8010c80 <SD_SendCmd+0x54>
 8010cc6:	f7ff fefd 	bl	8010ac4 <spi_RxByte>
 8010cca:	e7d9      	b.n	8010c80 <SD_SendCmd+0x54>
  buf[5] = crc;
 8010ccc:	2387      	movs	r3, #135	@ 0x87
  spi_TxBuffer(buf, 6);
 8010cce:	2106      	movs	r1, #6
 8010cd0:	4668      	mov	r0, sp
  buf[5] = crc;
 8010cd2:	f88d 3005 	strb.w	r3, [sp, #5]
  spi_TxBuffer(buf, 6);
 8010cd6:	f7ff fec5 	bl	8010a64 <spi_TxBuffer>
  if (cmd == CMD12) spi_RxByte();
 8010cda:	e7d1      	b.n	8010c80 <SD_SendCmd+0x54>

08010cdc <lcd_get_cell_buffer>:
  return &spi_buffer[(LCD_dma_status&LCD_BUFFER_1) ? SPI_BUFFER_SIZE/2 : 0];
 8010cdc:	4b03      	ldr	r3, [pc, #12]	@ (8010cec <lcd_get_cell_buffer+0x10>)
 8010cde:	4804      	ldr	r0, [pc, #16]	@ (8010cf0 <lcd_get_cell_buffer+0x14>)
 8010ce0:	781b      	ldrb	r3, [r3, #0]
 8010ce2:	02db      	lsls	r3, r3, #11
 8010ce4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
}
 8010ce8:	4418      	add	r0, r3
 8010cea:	4770      	bx	lr
 8010cec:	20008a37 	.word	0x20008a37
 8010cf0:	20008a3c 	.word	0x20008a3c

08010cf4 <lcd_set_rotation>:
  lcd_send_command(LCD_MADCTL, 1, &ST7796S_rotation_const[r]);
 8010cf4:	4a02      	ldr	r2, [pc, #8]	@ (8010d00 <lcd_set_rotation+0xc>)
 8010cf6:	2101      	movs	r1, #1
 8010cf8:	4402      	add	r2, r0
 8010cfa:	2036      	movs	r0, #54	@ 0x36
 8010cfc:	f7ff bec4 	b.w	8010a88 <lcd_send_command>
 8010d00:	08016ec8 	.word	0x08016ec8

08010d04 <lcd_setWindow>:
void lcd_setWindow(int x, int y, int w, int h, uint16_t cmd) {
 8010d04:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010d06:	4617      	mov	r7, r2
 8010d08:	b083      	sub	sp, #12
  uint32_t xx = __REV16(x | ((x + w - 1) << 16));
 8010d0a:	4407      	add	r7, r0
 8010d0c:	3f01      	subs	r7, #1
void lcd_setWindow(int x, int y, int w, int h, uint16_t cmd) {
 8010d0e:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 8010d12:	460c      	mov	r4, r1
 8010d14:	461d      	mov	r5, r3
  uint32_t xx = __REV16(x | ((x + w - 1) << 16));
 8010d16:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
  dmaChannelWaitCompletionRxTx();
 8010d1a:	f7ff fe75 	bl	8010a08 <dmaChannelWaitCompletionRxTx>
  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 8010d1e:	ba40      	rev16	r0, r0
  uint32_t yy = __REV16(y | ((y + h - 1) << 16));
 8010d20:	4425      	add	r5, r4
 8010d22:	3d01      	subs	r5, #1
  uint32_t xx = __REV16(x | ((x + w - 1) << 16));
 8010d24:	9000      	str	r0, [sp, #0]
  uint32_t yy = __REV16(y | ((y + h - 1) << 16));
 8010d26:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8010d2a:	ba64      	rev16	r4, r4
  lcd_send_command(LCD_CASET, 4, (uint8_t *)&xx);
 8010d2c:	2104      	movs	r1, #4
 8010d2e:	466a      	mov	r2, sp
 8010d30:	202a      	movs	r0, #42	@ 0x2a
  uint32_t yy = __REV16(y | ((y + h - 1) << 16));
 8010d32:	9401      	str	r4, [sp, #4]
  lcd_send_command(LCD_CASET, 4, (uint8_t *)&xx);
 8010d34:	f7ff fea8 	bl	8010a88 <lcd_send_command>
  lcd_send_command(LCD_RASET, 4, (uint8_t *)&yy);
 8010d38:	2104      	movs	r1, #4
 8010d3a:	eb0d 0201 	add.w	r2, sp, r1
 8010d3e:	202b      	movs	r0, #43	@ 0x2b
 8010d40:	f7ff fea2 	bl	8010a88 <lcd_send_command>
  lcd_send_command(cmd, 0, NULL);
 8010d44:	2200      	movs	r2, #0
 8010d46:	4611      	mov	r1, r2
 8010d48:	b2f0      	uxtb	r0, r6
}
 8010d4a:	b003      	add	sp, #12
 8010d4c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  lcd_send_command(cmd, 0, NULL);
 8010d50:	f7ff be9a 	b.w	8010a88 <lcd_send_command>

08010d54 <lcd_bulk_buffer>:
static void lcd_bulk_buffer(int x, int y, int w, int h, pixel_t *buffer) {
 8010d54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010d58:	b086      	sub	sp, #24
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 8010d5a:	242c      	movs	r4, #44	@ 0x2c
 8010d5c:	9400      	str	r4, [sp, #0]
static void lcd_bulk_buffer(int x, int y, int w, int h, pixel_t *buffer) {
 8010d5e:	4615      	mov	r5, r2
 8010d60:	461c      	mov	r4, r3
 8010d62:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8010d64:	460f      	mov	r7, r1
 8010d66:	4680      	mov	r8, r0
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 8010d68:	f7ff ffcc 	bl	8010d04 <lcd_setWindow>
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 8010d6c:	4b16      	ldr	r3, [pc, #88]	@ (8010dc8 <lcd_bulk_buffer+0x74>)
  if (sweep_mode & SWEEP_REMOTE) {
 8010d6e:	4a17      	ldr	r2, [pc, #92]	@ (8010dcc <lcd_bulk_buffer+0x78>)
  dmaChannelSetMemory(LCD_DMA_TX, buffer);
 8010d70:	63de      	str	r6, [r3, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, w * h);
 8010d72:	fb04 f105 	mul.w	r1, r4, r5
 8010d76:	6359      	str	r1, [r3, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | LCD_DMA_MODE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010d78:	f241 5191 	movw	r1, #5521	@ 0x1591
 8010d7c:	6319      	str	r1, [r3, #48]	@ 0x30
  if (sweep_mode & SWEEP_REMOTE) {
 8010d7e:	7813      	ldrb	r3, [r2, #0]
 8010d80:	065b      	lsls	r3, r3, #25
 8010d82:	d402      	bmi.n	8010d8a <lcd_bulk_buffer+0x36>
}
 8010d84:	b006      	add	sp, #24
 8010d86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 8010d8a:	4a11      	ldr	r2, [pc, #68]	@ (8010dd0 <lcd_bulk_buffer+0x7c>)
 8010d8c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8010d90:	2300      	movs	r3, #0
 8010d92:	f8ad 100c 	strh.w	r1, [sp, #12]
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 8010d96:	fb15 f204 	smulbb	r2, r5, r4
 8010d9a:	4631      	mov	r1, r6
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 8010d9c:	461e      	mov	r6, r3
 8010d9e:	f365 060f 	bfi	r6, r5, #0, #16
 8010da2:	f368 030f 	bfi	r3, r8, #0, #16
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 8010da6:	0052      	lsls	r2, r2, #1
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 8010da8:	9002      	str	r0, [sp, #8]
 8010daa:	f367 431f 	bfi	r3, r7, #16, #16
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 8010dae:	b292      	uxth	r2, r2
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 8010db0:	f364 461f 	bfi	r6, r4, #16, #16
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 8010db4:	a802      	add	r0, sp, #8
    remote_region_t rd = {"bulk\r\n", x, y, w, h};
 8010db6:	f8cd 300e 	str.w	r3, [sp, #14]
 8010dba:	f8cd 6012 	str.w	r6, [sp, #18]
    send_region(&rd, (uint8_t *)buffer, w * h * sizeof(pixel_t));
 8010dbe:	f7f8 fb79 	bl	80094b4 <send_region>
}
 8010dc2:	b006      	add	sp, #24
 8010dc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010dc8:	40020000 	.word	0x40020000
 8010dcc:	200003c4 	.word	0x200003c4
 8010dd0:	0801474c 	.word	0x0801474c

08010dd4 <lcd_read_memory>:
void lcd_read_memory(int x, int y, int w, int h, uint16_t *out) {
 8010dd4:	b570      	push	{r4, r5, r6, lr}
 8010dd6:	b082      	sub	sp, #8
  lcd_setWindow(x, y, w, h, LCD_RAMRD);
 8010dd8:	252e      	movs	r5, #46	@ 0x2e
 8010dda:	9500      	str	r5, [sp, #0]
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_RX_SPEED);
 8010ddc:	4d15      	ldr	r5, [pc, #84]	@ (8010e34 <lcd_read_memory+0x60>)
void lcd_read_memory(int x, int y, int w, int h, uint16_t *out) {
 8010dde:	461e      	mov	r6, r3
 8010de0:	4614      	mov	r4, r2
  lcd_setWindow(x, y, w, h, LCD_RAMRD);
 8010de2:	f7ff ff8f 	bl	8010d04 <lcd_setWindow>
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_RX_SPEED);
 8010de6:	682a      	ldr	r2, [r5, #0]
 8010de8:	f022 0238 	bic.w	r2, r2, #56	@ 0x38
 8010dec:	f042 0208 	orr.w	r2, r2, #8
 8010df0:	602a      	str	r2, [r5, #0]
  spi_DropRx();         // Skip data from rx buffer
 8010df2:	f7ff fe99 	bl	8010b28 <spi_DropRx>
  spi_RxByte();         // require 8bit dummy clock
 8010df6:	f7ff fe65 	bl	8010ac4 <spi_RxByte>
  spi_DMARxBuffer((uint8_t *)out, len * 2, true);
 8010dfa:	fb14 f206 	smulbb	r2, r4, r6
  dmaChannelSetMemory(LCD_DMA_RX, buffer);
 8010dfe:	490e      	ldr	r1, [pc, #56]	@ (8010e38 <lcd_read_memory+0x64>)
 8010e00:	9806      	ldr	r0, [sp, #24]
 8010e02:	6288      	str	r0, [r1, #40]	@ 0x28
  spi_DMARxBuffer((uint8_t *)out, len * 2, true);
 8010e04:	0052      	lsls	r2, r2, #1
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 8010e06:	b292      	uxth	r2, r2
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010e08:	f241 0381 	movw	r3, #4225	@ 0x1081
  dmaChannelSetTransactionSize(LCD_DMA_RX, len);
 8010e0c:	620a      	str	r2, [r1, #32]
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 8010e0e:	480b      	ldr	r0, [pc, #44]	@ (8010e3c <lcd_read_memory+0x68>)
  dmaChannelSetMode(LCD_DMA_RX, rxdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_MINC | STM32_DMA_CR_EN);
 8010e10:	61cb      	str	r3, [r1, #28]
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 8010e12:	f241 0311 	movw	r3, #4113	@ 0x1011
  dmaChannelSetMemory(LCD_DMA_TX, &dummy_tx);
 8010e16:	63c8      	str	r0, [r1, #60]	@ 0x3c
  dmaChannelSetTransactionSize(LCD_DMA_TX, len);
 8010e18:	634a      	str	r2, [r1, #52]	@ 0x34
  dmaChannelSetMode(LCD_DMA_TX, txdmamode | STM32_DMA_CR_BYTE | STM32_DMA_CR_EN);
 8010e1a:	630b      	str	r3, [r1, #48]	@ 0x30
    dmaChannelWaitCompletionRxTx();
 8010e1c:	f7ff fdf4 	bl	8010a08 <dmaChannelWaitCompletionRxTx>
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_SPEED);
 8010e20:	682b      	ldr	r3, [r5, #0]
  LCD_CS_HIGH;
 8010e22:	4a07      	ldr	r2, [pc, #28]	@ (8010e40 <lcd_read_memory+0x6c>)
 8010e24:	2140      	movs	r1, #64	@ 0x40
  if (LCD_SPI_RX_SPEED != LCD_SPI_SPEED) SPI_BR_SET(LCD_SPI, LCD_SPI_SPEED);
 8010e26:	f023 0338 	bic.w	r3, r3, #56	@ 0x38
 8010e2a:	602b      	str	r3, [r5, #0]
  LCD_CS_HIGH;
 8010e2c:	6191      	str	r1, [r2, #24]
}
 8010e2e:	b002      	add	sp, #8
 8010e30:	bd70      	pop	{r4, r5, r6, pc}
 8010e32:	bf00      	nop
 8010e34:	40013000 	.word	0x40013000
 8010e38:	40020000 	.word	0x40020000
 8010e3c:	0801b9fc 	.word	0x0801b9fc
 8010e40:	48000400 	.word	0x48000400

08010e44 <lcd_set_flip>:
void lcd_set_flip(bool flip) {
 8010e44:	b508      	push	{r3, lr}
  lcd_set_rotation(flip ? DISPLAY_ROTATION_180 : DISPLAY_ROTATION_0);
 8010e46:	0040      	lsls	r0, r0, #1
  dmaChannelWaitCompletionRxTx();
 8010e48:	f7ff fdde 	bl	8010a08 <dmaChannelWaitCompletionRxTx>
  lcd_set_rotation(flip ? DISPLAY_ROTATION_180 : DISPLAY_ROTATION_0);
 8010e4c:	f000 00fe 	and.w	r0, r0, #254	@ 0xfe
}
 8010e50:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  lcd_set_rotation(flip ? DISPLAY_ROTATION_180 : DISPLAY_ROTATION_0);
 8010e54:	f7ff bf4e 	b.w	8010cf4 <lcd_set_rotation>

08010e58 <lcd_bulk_finish>:
  dmaChannelWaitCompletion(LCD_DMA_TX);  // Wait DMA
 8010e58:	4a02      	ldr	r2, [pc, #8]	@ (8010e64 <lcd_bulk_finish+0xc>)
 8010e5a:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 8010e5c:	2b00      	cmp	r3, #0
 8010e5e:	d1fc      	bne.n	8010e5a <lcd_bulk_finish+0x2>
 8010e60:	6313      	str	r3, [r2, #48]	@ 0x30
}
 8010e62:	4770      	bx	lr
 8010e64:	40020000 	.word	0x40020000

08010e68 <lcd_bulk_continue>:
void lcd_bulk_continue(int x, int y, int w, int h) {
 8010e68:	b530      	push	{r4, r5, lr}
 8010e6a:	b083      	sub	sp, #12
 8010e6c:	4604      	mov	r4, r0
 8010e6e:	461d      	mov	r5, r3
  lcd_bulk_buffer(x, y, w, h, lcd_get_cell_buffer());  // Send new cell data
 8010e70:	f7ff ff34 	bl	8010cdc <lcd_get_cell_buffer>
 8010e74:	462b      	mov	r3, r5
 8010e76:	9000      	str	r0, [sp, #0]
 8010e78:	4620      	mov	r0, r4
 8010e7a:	f7ff ff6b 	bl	8010d54 <lcd_bulk_buffer>
  LCD_dma_status^=LCD_BUFFER_1;                        // Switch buffer
 8010e7e:	4a03      	ldr	r2, [pc, #12]	@ (8010e8c <lcd_bulk_continue+0x24>)
 8010e80:	7813      	ldrb	r3, [r2, #0]
 8010e82:	f083 0301 	eor.w	r3, r3, #1
 8010e86:	7013      	strb	r3, [r2, #0]
}
 8010e88:	b003      	add	sp, #12
 8010e8a:	bd30      	pop	{r4, r5, pc}
 8010e8c:	20008a37 	.word	0x20008a37

08010e90 <lcd_bulk>:
void lcd_bulk(int x, int y, int w, int h) {
 8010e90:	b510      	push	{r4, lr}
 8010e92:	b082      	sub	sp, #8
  lcd_bulk_buffer(x, y, w, h, spi_buffer);  // Send data
 8010e94:	4c04      	ldr	r4, [pc, #16]	@ (8010ea8 <lcd_bulk+0x18>)
 8010e96:	9400      	str	r4, [sp, #0]
 8010e98:	f7ff ff5c 	bl	8010d54 <lcd_bulk_buffer>
}
 8010e9c:	b002      	add	sp, #8
 8010e9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  lcd_bulk_finish();                        // Wait
 8010ea2:	f7ff bfd9 	b.w	8010e58 <lcd_bulk_finish>
 8010ea6:	bf00      	nop
 8010ea8:	20008a3c 	.word	0x20008a3c

08010eac <lcd_fill>:
void lcd_fill(int x, int y, int w, int h) {
 8010eac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010eb0:	b086      	sub	sp, #24
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 8010eb2:	242c      	movs	r4, #44	@ 0x2c
 8010eb4:	9400      	str	r4, [sp, #0]
void lcd_fill(int x, int y, int w, int h) {
 8010eb6:	4615      	mov	r5, r2
 8010eb8:	461c      	mov	r4, r3
 8010eba:	4688      	mov	r8, r1
 8010ebc:	4607      	mov	r7, r0
  lcd_setWindow(x, y, w, h, LCD_RAMWR);
 8010ebe:	f7ff ff21 	bl	8010d04 <lcd_setWindow>
  dmaChannelSetMemory(LCD_DMA_TX, &background_color);
 8010ec2:	4a1c      	ldr	r2, [pc, #112]	@ (8010f34 <lcd_fill+0x88>)
 8010ec4:	4b1c      	ldr	r3, [pc, #112]	@ (8010f38 <lcd_fill+0x8c>)
 8010ec6:	63d3      	str	r3, [r2, #60]	@ 0x3c
  uint32_t len = w * h;
 8010ec8:	fb04 f105 	mul.w	r1, r4, r5
  while(len) {
 8010ecc:	b179      	cbz	r1, 8010eee <lcd_fill+0x42>
    uint32_t delta = len > 0xFFFF ? 0xFFFF : len; // DMA can send only 65535 data in one run
 8010ece:	f64f 7eff 	movw	lr, #65535	@ 0xffff
    dmaChannelSetMode(LCD_DMA_TX, txdmamode | LCD_DMA_MODE | STM32_DMA_CR_EN);
 8010ed2:	f241 5611 	movw	r6, #5393	@ 0x1511
    uint32_t delta = len > 0xFFFF ? 0xFFFF : len; // DMA can send only 65535 data in one run
 8010ed6:	4571      	cmp	r1, lr
 8010ed8:	4608      	mov	r0, r1
 8010eda:	bf28      	it	cs
 8010edc:	4670      	movcs	r0, lr
    dmaChannelSetTransactionSize(LCD_DMA_TX, delta);
 8010ede:	6350      	str	r0, [r2, #52]	@ 0x34
    dmaChannelSetMode(LCD_DMA_TX, txdmamode | LCD_DMA_MODE | STM32_DMA_CR_EN);
 8010ee0:	6316      	str	r6, [r2, #48]	@ 0x30
    dmaChannelWaitCompletion(LCD_DMA_TX);
 8010ee2:	6b53      	ldr	r3, [r2, #52]	@ 0x34
 8010ee4:	2b00      	cmp	r3, #0
 8010ee6:	d1fc      	bne.n	8010ee2 <lcd_fill+0x36>
  while(len) {
 8010ee8:	1a09      	subs	r1, r1, r0
    dmaChannelWaitCompletion(LCD_DMA_TX);
 8010eea:	6313      	str	r3, [r2, #48]	@ 0x30
  while(len) {
 8010eec:	d1f3      	bne.n	8010ed6 <lcd_fill+0x2a>
  if (sweep_mode & SWEEP_REMOTE) {
 8010eee:	4b13      	ldr	r3, [pc, #76]	@ (8010f3c <lcd_fill+0x90>)
 8010ef0:	781b      	ldrb	r3, [r3, #0]
 8010ef2:	065b      	lsls	r3, r3, #25
 8010ef4:	d402      	bmi.n	8010efc <lcd_fill+0x50>
}
 8010ef6:	b006      	add	sp, #24
 8010ef8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    remote_region_t rd = {"fill\r\n", x, y, w, h};
 8010efc:	4a10      	ldr	r2, [pc, #64]	@ (8010f40 <lcd_fill+0x94>)
 8010efe:	2300      	movs	r3, #0
 8010f00:	e892 0003 	ldmia.w	r2, {r0, r1}
 8010f04:	469c      	mov	ip, r3
 8010f06:	f365 0c0f 	bfi	ip, r5, #0, #16
 8010f0a:	f367 030f 	bfi	r3, r7, #0, #16
 8010f0e:	9002      	str	r0, [sp, #8]
 8010f10:	f8ad 100c 	strh.w	r1, [sp, #12]
 8010f14:	f368 431f 	bfi	r3, r8, #16, #16
 8010f18:	f364 4c1f 	bfi	ip, r4, #16, #16
    send_region(&rd, (uint8_t *)&background_color, sizeof(pixel_t));
 8010f1c:	4906      	ldr	r1, [pc, #24]	@ (8010f38 <lcd_fill+0x8c>)
    remote_region_t rd = {"fill\r\n", x, y, w, h};
 8010f1e:	f8cd 300e 	str.w	r3, [sp, #14]
    send_region(&rd, (uint8_t *)&background_color, sizeof(pixel_t));
 8010f22:	2202      	movs	r2, #2
 8010f24:	a802      	add	r0, sp, #8
    remote_region_t rd = {"fill\r\n", x, y, w, h};
 8010f26:	f8cd c012 	str.w	ip, [sp, #18]
    send_region(&rd, (uint8_t *)&background_color, sizeof(pixel_t));
 8010f2a:	f7f8 fac3 	bl	80094b4 <send_region>
}
 8010f2e:	b006      	add	sp, #24
 8010f30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010f34:	40020000 	.word	0x40020000
 8010f38:	20008a38 	.word	0x20008a38
 8010f3c:	200003c4 	.word	0x200003c4
 8010f40:	08014754 	.word	0x08014754

08010f44 <lcd_line>:
void lcd_line(int x0, int y0, int x1, int y1) {
 8010f44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (x1 < x0) { SWAP(int, x0, x1); SWAP(int, y0, y1); }      // Need draw from left to right
 8010f48:	4282      	cmp	r2, r0
void lcd_line(int x0, int y0, int x1, int y1) {
 8010f4a:	468a      	mov	sl, r1
 8010f4c:	b085      	sub	sp, #20
 8010f4e:	4607      	mov	r7, r0
 8010f50:	4693      	mov	fp, r2
 8010f52:	4619      	mov	r1, r3
  if (x1 < x0) { SWAP(int, x0, x1); SWAP(int, y0, y1); }      // Need draw from left to right
 8010f54:	db05      	blt.n	8010f62 <lcd_line+0x1e>
 8010f56:	461a      	mov	r2, r3
 8010f58:	465b      	mov	r3, fp
 8010f5a:	4651      	mov	r1, sl
 8010f5c:	4683      	mov	fp, r0
 8010f5e:	4692      	mov	sl, r2
 8010f60:	461f      	mov	r7, r3
  int dy = (y1 - y0), sy = 1; if (dy < 0) {dy = -dy; sy = -1;}
 8010f62:	ebba 0601 	subs.w	r6, sl, r1
  int dx =-(x1 - x0), sx = 1;
 8010f66:	ebab 0807 	sub.w	r8, fp, r7
  int dy = (y1 - y0), sy = 1; if (dy < 0) {dy = -dy; sy = -1;}
 8010f6a:	bf46      	itte	mi
 8010f6c:	eba1 060a 	submi.w	r6, r1, sl
 8010f70:	f04f 33ff 	movmi.w	r3, #4294967295
 8010f74:	2301      	movpl	r3, #1
  int err = -((dx + dy) < 0 ? dx : dy) / 2;
 8010f76:	eb16 0f08 	cmn.w	r6, r8
  int dy = (y1 - y0), sy = 1; if (dy < 0) {dy = -dy; sy = -1;}
 8010f7a:	9303      	str	r3, [sp, #12]
  int err = -((dx + dy) < 0 ? dx : dy) / 2;
 8010f7c:	d42c      	bmi.n	8010fd8 <lcd_line+0x94>
 8010f7e:	eb06 75d6 	add.w	r5, r6, r6, lsr #31
 8010f82:	106d      	asrs	r5, r5, #1
 8010f84:	426d      	negs	r5, r5
 8010f86:	f8df 9060 	ldr.w	r9, [pc, #96]	@ 8010fe8 <lcd_line+0xa4>
      while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8010f8a:	4c16      	ldr	r4, [pc, #88]	@ (8010fe4 <lcd_line+0xa0>)
    lcd_setWindow(x0, y0, LCD_WIDTH-x0, 1, LCD_RAMWR);        // prepare send Horizontal line
 8010f8c:	9102      	str	r1, [sp, #8]
 8010f8e:	232c      	movs	r3, #44	@ 0x2c
 8010f90:	9300      	str	r3, [sp, #0]
 8010f92:	f5cb 72f0 	rsb	r2, fp, #480	@ 0x1e0
 8010f96:	2301      	movs	r3, #1
 8010f98:	4658      	mov	r0, fp
 8010f9a:	f7ff feb3 	bl	8010d04 <lcd_setWindow>
 8010f9e:	9902      	ldr	r1, [sp, #8]
      while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8010fa0:	68a3      	ldr	r3, [r4, #8]
 8010fa2:	079b      	lsls	r3, r3, #30
 8010fa4:	d5fc      	bpl.n	8010fa0 <lcd_line+0x5c>
      SPI_WRITE_16BIT(LCD_SPI, foreground_color);             // Send color
 8010fa6:	f8b9 3000 	ldrh.w	r3, [r9]
 8010faa:	81a3      	strh	r3, [r4, #12]
      if (x0 == x1 && y0 == y1)
 8010fac:	455f      	cmp	r7, fp
 8010fae:	d009      	beq.n	8010fc4 <lcd_line+0x80>
      if (e2 > dx) { err-= dy; x0+= sx; }
 8010fb0:	45a8      	cmp	r8, r5
 8010fb2:	bfba      	itte	lt
 8010fb4:	1bab      	sublt	r3, r5, r6
 8010fb6:	f10b 0b01 	addlt.w	fp, fp, #1
 8010fba:	462b      	movge	r3, r5
      if (e2 < dy) { err-= dx; y0+= sy; break;}               // Y coordinate change, next horizontal line
 8010fbc:	42ae      	cmp	r6, r5
 8010fbe:	dc06      	bgt.n	8010fce <lcd_line+0x8a>
 8010fc0:	461d      	mov	r5, r3
 8010fc2:	e7ed      	b.n	8010fa0 <lcd_line+0x5c>
      if (x0 == x1 && y0 == y1)
 8010fc4:	4551      	cmp	r1, sl
 8010fc6:	d1f3      	bne.n	8010fb0 <lcd_line+0x6c>
}
 8010fc8:	b005      	add	sp, #20
 8010fca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (e2 < dy) { err-= dx; y0+= sy; break;}               // Y coordinate change, next horizontal line
 8010fce:	eba3 0508 	sub.w	r5, r3, r8
 8010fd2:	9b03      	ldr	r3, [sp, #12]
 8010fd4:	4419      	add	r1, r3
    lcd_setWindow(x0, y0, LCD_WIDTH-x0, 1, LCD_RAMWR);        // prepare send Horizontal line
 8010fd6:	e7d9      	b.n	8010f8c <lcd_line+0x48>
  int err = -((dx + dy) < 0 ? dx : dy) / 2;
 8010fd8:	eb08 75d8 	add.w	r5, r8, r8, lsr #31
 8010fdc:	106d      	asrs	r5, r5, #1
 8010fde:	426d      	negs	r5, r5
 8010fe0:	e7d1      	b.n	8010f86 <lcd_line+0x42>
 8010fe2:	bf00      	nop
 8010fe4:	40013000 	.word	0x40013000
 8010fe8:	20008a3a 	.word	0x20008a3a

08010fec <lcd_clear_screen>:
  lcd_fill(0, 0, LCD_WIDTH, LCD_HEIGHT);
 8010fec:	2100      	movs	r1, #0
 8010fee:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 8010ff2:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
 8010ff6:	4608      	mov	r0, r1
 8010ff8:	f7ff bf58 	b.w	8010eac <lcd_fill>

08010ffc <lcd_init>:
void lcd_init(void) {
 8010ffc:	b538      	push	{r3, r4, r5, lr}
  rccEnableSPI1(FALSE);
 8010ffe:	4c1d      	ldr	r4, [pc, #116]	@ (8011074 <lcd_init+0x78>)
  LCD_SPI->CR1 = 0;
 8011000:	4b1d      	ldr	r3, [pc, #116]	@ (8011078 <lcd_init+0x7c>)
  rccEnableSPI1(FALSE);
 8011002:	69a2      	ldr	r2, [r4, #24]
  dmaChannelSetPeripheral(LCD_DMA_TX, &LCD_SPI->DR); // DMA Peripheral Tx
 8011004:	491d      	ldr	r1, [pc, #116]	@ (801107c <lcd_init+0x80>)
 8011006:	481e      	ldr	r0, [pc, #120]	@ (8011080 <lcd_init+0x84>)
  rccEnableSPI1(FALSE);
 8011008:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 801100c:	61a2      	str	r2, [r4, #24]
  LCD_SPI->CR1 = 0;
 801100e:	2500      	movs	r5, #0
  LCD_SPI->CR1 = SPI_CR1_MSTR      // SPI is MASTER
 8011010:	f240 3207 	movw	r2, #775	@ 0x307
  LCD_SPI->CR1 = 0;
 8011014:	601d      	str	r5, [r3, #0]
  LCD_SPI->CR1 = SPI_CR1_MSTR      // SPI is MASTER
 8011016:	601a      	str	r2, [r3, #0]
  LCD_SPI->CR2 = SPI_CR2_8BIT      // SPI data size, set to 8 bit
 8011018:	f241 7203 	movw	r2, #5891	@ 0x1703
 801101c:	605a      	str	r2, [r3, #4]
  dmaChannelSetPeripheral(LCD_DMA_TX, &LCD_SPI->DR); // DMA Peripheral Tx
 801101e:	6388      	str	r0, [r1, #56]	@ 0x38
  dmaChannelSetPeripheral(LCD_DMA_RX, &LCD_SPI->DR); // DMA Peripheral Rx
 8011020:	6248      	str	r0, [r1, #36]	@ 0x24
  LCD_SPI->CR1|= SPI_CR1_SPE;       //SPI enable
 8011022:	681a      	ldr	r2, [r3, #0]
  LCD_RESET_ASSERT;
 8011024:	f04f 4490 	mov.w	r4, #1207959552	@ 0x48000000
 8011028:	f04f 4100 	mov.w	r1, #2147483648	@ 0x80000000
  LCD_SPI->CR1|= SPI_CR1_SPE;       //SPI enable
 801102c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8011030:	601a      	str	r2, [r3, #0]
  chThdSleepMilliseconds(5);
 8011032:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  LCD_RESET_ASSERT;
 8011036:	61a1      	str	r1, [r4, #24]
  chThdSleepMilliseconds(5);
 8011038:	f7ef ff2a 	bl	8000e90 <chThdSleep>
  LCD_RESET_NEGATE;
 801103c:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  chThdSleepMilliseconds(5); // need time before LCD ready after reset
 8011040:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
  LCD_RESET_NEGATE;
 8011044:	61a3      	str	r3, [r4, #24]
  chThdSleepMilliseconds(5); // need time before LCD ready after reset
 8011046:	f7ef ff23 	bl	8000e90 <chThdSleep>
  const uint8_t *p = get_lcd_init();
 801104a:	4c0e      	ldr	r4, [pc, #56]	@ (8011084 <lcd_init+0x88>)
  while (*p) {
 801104c:	2001      	movs	r0, #1
  chThdSleepMilliseconds(5); // need time before LCD ready after reset
 801104e:	4629      	mov	r1, r5
 8011050:	e000      	b.n	8011054 <lcd_init+0x58>
    lcd_send_command(p[0], p[1], &p[2]);
 8011052:	7861      	ldrb	r1, [r4, #1]
 8011054:	1ca2      	adds	r2, r4, #2
 8011056:	f7ff fd17 	bl	8010a88 <lcd_send_command>
    p += 2 + p[1];
 801105a:	7863      	ldrb	r3, [r4, #1]
 801105c:	3302      	adds	r3, #2
 801105e:	441c      	add	r4, r3
    chThdSleepMilliseconds(2);
 8011060:	20c8      	movs	r0, #200	@ 0xc8
 8011062:	f7ef ff15 	bl	8000e90 <chThdSleep>
  while (*p) {
 8011066:	7820      	ldrb	r0, [r4, #0]
 8011068:	2800      	cmp	r0, #0
 801106a:	d1f2      	bne.n	8011052 <lcd_init+0x56>
}
 801106c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  lcd_clear_screen();
 8011070:	f7ff bfbc 	b.w	8010fec <lcd_clear_screen>
 8011074:	40021000 	.word	0x40021000
 8011078:	40013000 	.word	0x40013000
 801107c:	40020000 	.word	0x40020000
 8011080:	4001300c 	.word	0x4001300c
 8011084:	0801b9cc 	.word	0x0801b9cc

08011088 <lcd_set_foreground>:
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 8011088:	4b03      	ldr	r3, [pc, #12]	@ (8011098 <lcd_set_foreground+0x10>)
 801108a:	4a04      	ldr	r2, [pc, #16]	@ (801109c <lcd_set_foreground+0x14>)
 801108c:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8011090:	8bdb      	ldrh	r3, [r3, #30]
 8011092:	8013      	strh	r3, [r2, #0]
}
 8011094:	4770      	bx	lr
 8011096:	bf00      	nop
 8011098:	20000318 	.word	0x20000318
 801109c:	20008a3a 	.word	0x20008a3a

080110a0 <lcd_set_background>:
  background_color = GET_PALTETTE_COLOR(bg_idx);
 80110a0:	4b03      	ldr	r3, [pc, #12]	@ (80110b0 <lcd_set_background+0x10>)
 80110a2:	4a04      	ldr	r2, [pc, #16]	@ (80110b4 <lcd_set_background+0x14>)
 80110a4:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80110a8:	8bdb      	ldrh	r3, [r3, #30]
 80110aa:	8013      	strh	r3, [r2, #0]
}
 80110ac:	4770      	bx	lr
 80110ae:	bf00      	nop
 80110b0:	20000318 	.word	0x20000318
 80110b4:	20008a38 	.word	0x20008a38

080110b8 <lcd_set_colors>:
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 80110b8:	4b05      	ldr	r3, [pc, #20]	@ (80110d0 <lcd_set_colors+0x18>)
  background_color = GET_PALTETTE_COLOR(bg_idx);
 80110ba:	4a06      	ldr	r2, [pc, #24]	@ (80110d4 <lcd_set_colors+0x1c>)
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 80110bc:	eb03 0040 	add.w	r0, r3, r0, lsl #1
  background_color = GET_PALTETTE_COLOR(bg_idx);
 80110c0:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 80110c4:	4904      	ldr	r1, [pc, #16]	@ (80110d8 <lcd_set_colors+0x20>)
 80110c6:	8bc0      	ldrh	r0, [r0, #30]
  background_color = GET_PALTETTE_COLOR(bg_idx);
 80110c8:	8bdb      	ldrh	r3, [r3, #30]
  foreground_color = GET_PALTETTE_COLOR(fg_idx);
 80110ca:	8008      	strh	r0, [r1, #0]
  background_color = GET_PALTETTE_COLOR(bg_idx);
 80110cc:	8013      	strh	r3, [r2, #0]
}
 80110ce:	4770      	bx	lr
 80110d0:	20000318 	.word	0x20000318
 80110d4:	20008a38 	.word	0x20008a38
 80110d8:	20008a3a 	.word	0x20008a3a

080110dc <lcd_blitBitmap>:
void lcd_blitBitmap(uint16_t x, uint16_t y, uint16_t width, uint16_t height, const uint8_t *b) {
 80110dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80110e0:	9e09      	ldr	r6, [sp, #36]	@ 0x24
  for (uint32_t c = 0; c < height; c++) {
 80110e2:	b35b      	cbz	r3, 801113c <lcd_blitBitmap+0x60>
      *buf++ = (0x80 & bits) ? foreground_color : background_color;
 80110e4:	4c17      	ldr	r4, [pc, #92]	@ (8011144 <lcd_blitBitmap+0x68>)
 80110e6:	8827      	ldrh	r7, [r4, #0]
 80110e8:	4c17      	ldr	r4, [pc, #92]	@ (8011148 <lcd_blitBitmap+0x6c>)
 80110ea:	f8b4 8000 	ldrh.w	r8, [r4]
    for (uint32_t r = 0; r < width; r++) {
 80110ee:	b32a      	cbz	r2, 801113c <lcd_blitBitmap+0x60>
 80110f0:	f04f 0900 	mov.w	r9, #0
 80110f4:	f8df a054 	ldr.w	sl, [pc, #84]	@ 801114c <lcd_blitBitmap+0x70>
 80110f8:	46cc      	mov	ip, r9
 80110fa:	ea4f 0b42 	mov.w	fp, r2, lsl #1
 80110fe:	4655      	mov	r5, sl
 8011100:	f04f 0e00 	mov.w	lr, #0
      if ((r&7) == 0) bits = *b++;
 8011104:	4634      	mov	r4, r6
 8011106:	f01e 0f07 	tst.w	lr, #7
 801110a:	bf08      	it	eq
 801110c:	f814 cb01 	ldrbeq.w	ip, [r4], #1
    for (uint32_t r = 0; r < width; r++) {
 8011110:	f10e 0e01 	add.w	lr, lr, #1
      if ((r&7) == 0) bits = *b++;
 8011114:	bf08      	it	eq
 8011116:	4626      	moveq	r6, r4
      *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8011118:	f01c 0f80 	tst.w	ip, #128	@ 0x80
 801111c:	bf14      	ite	ne
 801111e:	4644      	movne	r4, r8
 8011120:	463c      	moveq	r4, r7
      bits <<= 1;
 8011122:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
    for (uint32_t r = 0; r < width; r++) {
 8011126:	4596      	cmp	lr, r2
      *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8011128:	f825 4b02 	strh.w	r4, [r5], #2
      bits <<= 1;
 801112c:	fa5f fc8c 	uxtb.w	ip, ip
    for (uint32_t r = 0; r < width; r++) {
 8011130:	d1e8      	bne.n	8011104 <lcd_blitBitmap+0x28>
  for (uint32_t c = 0; c < height; c++) {
 8011132:	f109 0901 	add.w	r9, r9, #1
 8011136:	454b      	cmp	r3, r9
 8011138:	44da      	add	sl, fp
 801113a:	d1e0      	bne.n	80110fe <lcd_blitBitmap+0x22>
}
 801113c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  lcd_bulk(x, y, width, height);
 8011140:	f7ff bea6 	b.w	8010e90 <lcd_bulk>
 8011144:	20008a38 	.word	0x20008a38
 8011148:	20008a3a 	.word	0x20008a3a
 801114c:	20008a3c 	.word	0x20008a3c

08011150 <lcd_put>:
static msg_t lcd_put(void *ip, uint8_t ch) {
 8011150:	b530      	push	{r4, r5, lr}
  if (ps->state) {
 8011152:	8983      	ldrh	r3, [r0, #12]
static msg_t lcd_put(void *ip, uint8_t ch) {
 8011154:	b083      	sub	sp, #12
 8011156:	4604      	mov	r4, r0
  if (ps->state) {
 8011158:	bb1b      	cbnz	r3, 80111a2 <lcd_put+0x52>
  } else if (ch < 0x09) {
 801115a:	2908      	cmp	r1, #8
 801115c:	d803      	bhi.n	8011166 <lcd_put+0x16>
    ps->state = ch;
 801115e:	8181      	strh	r1, [r0, #12]
}
 8011160:	2000      	movs	r0, #0
 8011162:	b003      	add	sp, #12
 8011164:	bd30      	pop	{r4, r5, pc}
  if (ch == '\n') {ps->x = ps->start_x; ps->y+=FONT_STR_HEIGHT; return;}
 8011166:	290a      	cmp	r1, #10
 8011168:	8942      	ldrh	r2, [r0, #10]
 801116a:	d023      	beq.n	80111b4 <lcd_put+0x64>
  uint16_t w = FONT_GET_WIDTH(ch);
 801116c:	f1a1 0316 	sub.w	r3, r1, #22
 8011170:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8011174:	4817      	ldr	r0, [pc, #92]	@ (80111d4 <lcd_put+0x84>)
 8011176:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 801117a:	4611      	mov	r1, r2
  uint16_t w = FONT_GET_WIDTH(ch);
 801117c:	5cc5      	ldrb	r5, [r0, r3]
 801117e:	f005 0507 	and.w	r5, r5, #7
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 8011182:	4403      	add	r3, r0
  uint16_t w = FONT_GET_WIDTH(ch);
 8011184:	f1c5 0508 	rsb	r5, r5, #8
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 8011188:	9300      	str	r3, [sp, #0]
  uint16_t w = FONT_GET_WIDTH(ch);
 801118a:	b2ad      	uxth	r5, r5
  lcd_blitBitmap(ps->x, ps->y, w, FONT_GET_HEIGHT, FONT_GET_DATA(ch));
 801118c:	8920      	ldrh	r0, [r4, #8]
 801118e:	462a      	mov	r2, r5
 8011190:	230b      	movs	r3, #11
 8011192:	f7ff ffa3 	bl	80110dc <lcd_blitBitmap>
  ps->x+= w;
 8011196:	8923      	ldrh	r3, [r4, #8]
}
 8011198:	2000      	movs	r0, #0
  ps->x+= w;
 801119a:	441d      	add	r5, r3
 801119c:	8125      	strh	r5, [r4, #8]
}
 801119e:	b003      	add	sp, #12
 80111a0:	bd30      	pop	{r4, r5, pc}
         if (ps->state == R_BGCOLOR[0]) lcd_set_background(ch);
 80111a2:	2b01      	cmp	r3, #1
 80111a4:	d00d      	beq.n	80111c2 <lcd_put+0x72>
    else if (ps->state == R_FGCOLOR[0]) lcd_set_foreground(ch);
 80111a6:	2b02      	cmp	r3, #2
 80111a8:	d00f      	beq.n	80111ca <lcd_put+0x7a>
    ps->state = 0;
 80111aa:	2300      	movs	r3, #0
}
 80111ac:	2000      	movs	r0, #0
    ps->state = 0;
 80111ae:	81a3      	strh	r3, [r4, #12]
}
 80111b0:	b003      	add	sp, #12
 80111b2:	bd30      	pop	{r4, r5, pc}
  if (ch == '\n') {ps->x = ps->start_x; ps->y+=FONT_STR_HEIGHT; return;}
 80111b4:	8883      	ldrh	r3, [r0, #4]
 80111b6:	8103      	strh	r3, [r0, #8]
 80111b8:	320b      	adds	r2, #11
 80111ba:	8142      	strh	r2, [r0, #10]
}
 80111bc:	2000      	movs	r0, #0
 80111be:	b003      	add	sp, #12
 80111c0:	bd30      	pop	{r4, r5, pc}
         if (ps->state == R_BGCOLOR[0]) lcd_set_background(ch);
 80111c2:	4608      	mov	r0, r1
 80111c4:	f7ff ff6c 	bl	80110a0 <lcd_set_background>
 80111c8:	e7ef      	b.n	80111aa <lcd_put+0x5a>
    else if (ps->state == R_FGCOLOR[0]) lcd_set_foreground(ch);
 80111ca:	4608      	mov	r0, r1
 80111cc:	f7ff ff5c 	bl	8011088 <lcd_set_foreground>
 80111d0:	e7eb      	b.n	80111aa <lcd_put+0x5a>
 80111d2:	bf00      	nop
 80111d4:	080154e0 	.word	0x080154e0

080111d8 <lcd_printf>:
int lcd_printf(int16_t x, int16_t y, const char *fmt, ...) {
 80111d8:	b40c      	push	{r2, r3}
 80111da:	b510      	push	{r4, lr}
 80111dc:	b08a      	sub	sp, #40	@ 0x28
 80111de:	aa0c      	add	r2, sp, #48	@ 0x30
 80111e0:	2300      	movs	r3, #0
 80111e2:	f852 4b04 	ldr.w	r4, [r2], #4
  va_start(ap, fmt);
 80111e6:	9201      	str	r2, [sp, #4]
 80111e8:	f360 030f 	bfi	r3, r0, #0, #16
 80111ec:	f361 431f 	bfi	r3, r1, #16, #16
  } lcd_vmt = {NULL, NULL, lcd_put, NULL};
 80111f0:	2000      	movs	r0, #0
 80111f2:	e9cd 0002 	strd	r0, r0, [sp, #8]
  lcdPrintStream ps = {&lcd_vmt, x, y, x, y, 0};
 80111f6:	e9cd 3307 	strd	r3, r3, [sp, #28]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 80111fa:	4621      	mov	r1, r4
  } lcd_vmt = {NULL, NULL, lcd_put, NULL};
 80111fc:	9005      	str	r0, [sp, #20]
  lcdPrintStream ps = {&lcd_vmt, x, y, x, y, 0};
 80111fe:	f8ad 0024 	strh.w	r0, [sp, #36]	@ 0x24
 8011202:	ab02      	add	r3, sp, #8
  } lcd_vmt = {NULL, NULL, lcd_put, NULL};
 8011204:	4c05      	ldr	r4, [pc, #20]	@ (801121c <lcd_printf+0x44>)
 8011206:	9404      	str	r4, [sp, #16]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 8011208:	a806      	add	r0, sp, #24
  lcdPrintStream ps = {&lcd_vmt, x, y, x, y, 0};
 801120a:	9306      	str	r3, [sp, #24]
  int retval = chvprintf((BaseSequentialStream *)(void *)&ps, fmt, ap);
 801120c:	f7f1 fa06 	bl	800261c <chvprintf>
}
 8011210:	b00a      	add	sp, #40	@ 0x28
 8011212:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8011216:	b002      	add	sp, #8
 8011218:	4770      	bx	lr
 801121a:	bf00      	nop
 801121c:	08011151 	.word	0x08011151

08011220 <lcd_blitBitmapScale>:
void lcd_blitBitmapScale(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t size, const uint8_t *b) {
 8011220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011224:	b085      	sub	sp, #20
 8011226:	461e      	mov	r6, r3
 8011228:	f8bd 4038 	ldrh.w	r4, [sp, #56]	@ 0x38
  lcd_setWindow(x, y, w * size, h * size, LCD_RAMWR);
 801122c:	232c      	movs	r3, #44	@ 0x2c
void lcd_blitBitmapScale(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t size, const uint8_t *b) {
 801122e:	4615      	mov	r5, r2
  lcd_setWindow(x, y, w * size, h * size, LCD_RAMWR);
 8011230:	9300      	str	r3, [sp, #0]
 8011232:	fb04 f202 	mul.w	r2, r4, r2
 8011236:	fb06 f304 	mul.w	r3, r6, r4
 801123a:	f7ff fd63 	bl	8010d04 <lcd_setWindow>
  for (int c = 0; c < h; c++) {
 801123e:	b126      	cbz	r6, 801124a <lcd_blitBitmapScale+0x2a>
 8011240:	2200      	movs	r2, #0
    for (int i = 0; i < size; i++) {
 8011242:	b92c      	cbnz	r4, 8011250 <lcd_blitBitmapScale+0x30>
  for (int c = 0; c < h; c++) {
 8011244:	3201      	adds	r2, #1
 8011246:	4296      	cmp	r6, r2
 8011248:	d1fc      	bne.n	8011244 <lcd_blitBitmapScale+0x24>
}
 801124a:	b005      	add	sp, #20
 801124c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8011250:	4b22      	ldr	r3, [pc, #136]	@ (80112dc <lcd_blitBitmapScale+0xbc>)
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 8011252:	f8df e090 	ldr.w	lr, [pc, #144]	@ 80112e4 <lcd_blitBitmapScale+0xc4>
 8011256:	4f22      	ldr	r7, [pc, #136]	@ (80112e0 <lcd_blitBitmapScale+0xc0>)
 8011258:	4630      	mov	r0, r6
      for (int r = 0; r < w; r++, bits <<= 1) {
 801125a:	2d00      	cmp	r5, #0
 801125c:	d036      	beq.n	80112cc <lcd_blitBitmapScale+0xac>
 801125e:	2100      	movs	r1, #0
 8011260:	460e      	mov	r6, r1
 8011262:	4692      	mov	sl, r2
      ptr = b;
 8011264:	f8dd 903c 	ldr.w	r9, [sp, #60]	@ 0x3c
      for (int r = 0; r < w; r++, bits <<= 1) {
 8011268:	46d3      	mov	fp, sl
 801126a:	f04f 0800 	mov.w	r8, #0
 801126e:	468a      	mov	sl, r1
        if ((r&7) == 0) bits = *ptr++;
 8011270:	f018 0f07 	tst.w	r8, #7
 8011274:	bf08      	it	eq
 8011276:	f819 6b01 	ldrbeq.w	r6, [r9], #1
        for (int j = 0; j < size; j++) {
 801127a:	9003      	str	r0, [sp, #12]
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 801127c:	b272      	sxtb	r2, r6
        for (int j = 0; j < size; j++) {
 801127e:	f04f 0c00 	mov.w	ip, #0
          while (SPI_TX_IS_NOT_EMPTY(LCD_SPI));
 8011282:	6899      	ldr	r1, [r3, #8]
 8011284:	0789      	lsls	r1, r1, #30
 8011286:	d5fc      	bpl.n	8011282 <lcd_blitBitmapScale+0x62>
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 8011288:	2a00      	cmp	r2, #0
 801128a:	bfb4      	ite	lt
 801128c:	8839      	ldrhlt	r1, [r7, #0]
 801128e:	f8be 1000 	ldrhge.w	r1, [lr]
 8011292:	4608      	mov	r0, r1
        for (int j = 0; j < size; j++) {
 8011294:	f10c 0101 	add.w	r1, ip, #1
 8011298:	428c      	cmp	r4, r1
          SPI_WRITE_16BIT(LCD_SPI, (0x80 & bits) ? foreground_color : background_color);
 801129a:	8198      	strh	r0, [r3, #12]
        for (int j = 0; j < size; j++) {
 801129c:	d001      	beq.n	80112a2 <lcd_blitBitmapScale+0x82>
 801129e:	468c      	mov	ip, r1
 80112a0:	e7ef      	b.n	8011282 <lcd_blitBitmapScale+0x62>
      for (int r = 0; r < w; r++, bits <<= 1) {
 80112a2:	f108 0801 	add.w	r8, r8, #1
 80112a6:	0076      	lsls	r6, r6, #1
 80112a8:	4545      	cmp	r5, r8
 80112aa:	9803      	ldr	r0, [sp, #12]
 80112ac:	b2f6      	uxtb	r6, r6
 80112ae:	d1df      	bne.n	8011270 <lcd_blitBitmapScale+0x50>
    for (int i = 0; i < size; i++) {
 80112b0:	4652      	mov	r2, sl
 80112b2:	4562      	cmp	r2, ip
 80112b4:	46da      	mov	sl, fp
 80112b6:	f102 0101 	add.w	r1, r2, #1
 80112ba:	d1d3      	bne.n	8011264 <lcd_blitBitmapScale+0x44>
 80112bc:	465a      	mov	r2, fp
  for (int c = 0; c < h; c++) {
 80112be:	3201      	adds	r2, #1
 80112c0:	4290      	cmp	r0, r2
 80112c2:	d0c2      	beq.n	801124a <lcd_blitBitmapScale+0x2a>
 80112c4:	f8cd 903c 	str.w	r9, [sp, #60]	@ 0x3c
      for (int r = 0; r < w; r++, bits <<= 1) {
 80112c8:	2d00      	cmp	r5, #0
 80112ca:	d1c8      	bne.n	801125e <lcd_blitBitmapScale+0x3e>
 80112cc:	4606      	mov	r6, r0
  for (int c = 0; c < h; c++) {
 80112ce:	3201      	adds	r2, #1
 80112d0:	4296      	cmp	r6, r2
 80112d2:	d1fc      	bne.n	80112ce <lcd_blitBitmapScale+0xae>
}
 80112d4:	b005      	add	sp, #20
 80112d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80112da:	bf00      	nop
 80112dc:	40013000 	.word	0x40013000
 80112e0:	20008a3a 	.word	0x20008a3a
 80112e4:	20008a38 	.word	0x20008a38

080112e8 <lcd_drawchar_size>:
  const uint8_t *char_buf = FONT_GET_DATA(ch);
 80112e8:	3816      	subs	r0, #22
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 80112ea:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const uint8_t *char_buf = FONT_GET_DATA(ch);
 80112ee:	eb00 0480 	add.w	r4, r0, r0, lsl #2
 80112f2:	eb00 0444 	add.w	r4, r0, r4, lsl #1
 80112f6:	4e37      	ldr	r6, [pc, #220]	@ (80113d4 <lcd_drawchar_size+0xec>)
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 80112f8:	468c      	mov	ip, r1
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 80112fa:	4937      	ldr	r1, [pc, #220]	@ (80113d8 <lcd_drawchar_size+0xf0>)
  uint16_t w = FONT_GET_WIDTH(ch);
 80112fc:	5d35      	ldrb	r5, [r6, r4]
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 80112fe:	880f      	ldrh	r7, [r1, #0]
 8011300:	4936      	ldr	r1, [pc, #216]	@ (80113dc <lcd_drawchar_size+0xf4>)
  uint16_t w = FONT_GET_WIDTH(ch);
 8011302:	f005 0507 	and.w	r5, r5, #7
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8011306:	f8b1 8000 	ldrh.w	r8, [r1]
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 801130a:	4610      	mov	r0, r2
  uint16_t w = FONT_GET_WIDTH(ch);
 801130c:	f1c5 0508 	rsb	r5, r5, #8
  const uint8_t *char_buf = FONT_GET_DATA(ch);
 8011310:	19a2      	adds	r2, r4, r6
  uint16_t w = FONT_GET_WIDTH(ch);
 8011312:	1e59      	subs	r1, r3, #1
 8011314:	005e      	lsls	r6, r3, #1
 8011316:	b2ad      	uxth	r5, r5
  for (uint32_t c = 0; c < FONT_GET_HEIGHT; c++, char_buf++) {
 8011318:	fb06 f101 	mul.w	r1, r6, r1
int lcd_drawchar_size(uint8_t ch, int x, int y, uint8_t size) {
 801131c:	b089      	sub	sp, #36	@ 0x24
 801131e:	fb03 f405 	mul.w	r4, r3, r5
 8011322:	fb05 f101 	mul.w	r1, r5, r1
    for (uint32_t i = 0; i < size; i++) {
 8011326:	fb06 fa05 	mul.w	sl, r6, r5
 801132a:	2b00      	cmp	r3, #0
 801132c:	d042      	beq.n	80113b4 <lcd_drawchar_size+0xcc>
 801132e:	3c01      	subs	r4, #1
 8011330:	0064      	lsls	r4, r4, #1
 8011332:	3102      	adds	r1, #2
 8011334:	eb01 0e04 	add.w	lr, r1, r4
 8011338:	e9cd c003 	strd	ip, r0, [sp, #12]
 801133c:	4c28      	ldr	r4, [pc, #160]	@ (80113e0 <lcd_drawchar_size+0xf8>)
 801133e:	4671      	mov	r1, lr
 8011340:	f102 0b0b 	add.w	fp, r2, #11
 8011344:	46a6      	mov	lr, r4
 8011346:	460c      	mov	r4, r1
 8011348:	e9cd 2b06 	strd	r2, fp, [sp, #24]
      uint8_t bits = *char_buf;
 801134c:	f892 9000 	ldrb.w	r9, [r2]
    for (uint32_t i = 0; i < size; i++) {
 8011350:	f8cd e014 	str.w	lr, [sp, #20]
      uint8_t bits = *char_buf;
 8011354:	4670      	mov	r0, lr
    for (uint32_t i = 0; i < size; i++) {
 8011356:	2100      	movs	r1, #0
 8011358:	f8cd 9008 	str.w	r9, [sp, #8]
 801135c:	46a4      	mov	ip, r4
      uint8_t bits = *char_buf;
 801135e:	f8dd e008 	ldr.w	lr, [sp, #8]
 8011362:	9101      	str	r1, [sp, #4]
 8011364:	4683      	mov	fp, r0
      for (uint32_t r = 0; r < w; r++, bits <<= 1)
 8011366:	f04f 0900 	mov.w	r9, #0
        for (uint32_t j = 0; j < size; j++)
 801136a:	f01e 0f80 	tst.w	lr, #128	@ 0x80
 801136e:	bf14      	ite	ne
 8011370:	4644      	movne	r4, r8
 8011372:	463c      	moveq	r4, r7
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 8011374:	4659      	mov	r1, fp
        for (uint32_t j = 0; j < size; j++)
 8011376:	2200      	movs	r2, #0
 8011378:	3201      	adds	r2, #1
 801137a:	429a      	cmp	r2, r3
          *buf++ = (0x80 & bits) ? foreground_color : background_color;
 801137c:	f821 4b02 	strh.w	r4, [r1], #2
        for (uint32_t j = 0; j < size; j++)
 8011380:	d1fa      	bne.n	8011378 <lcd_drawchar_size+0x90>
      for (uint32_t r = 0; r < w; r++, bits <<= 1)
 8011382:	f109 0901 	add.w	r9, r9, #1
 8011386:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 801138a:	454d      	cmp	r5, r9
 801138c:	44b3      	add	fp, r6
 801138e:	fa5f fe8e 	uxtb.w	lr, lr
 8011392:	d1ea      	bne.n	801136a <lcd_drawchar_size+0x82>
    for (uint32_t i = 0; i < size; i++) {
 8011394:	9901      	ldr	r1, [sp, #4]
 8011396:	3101      	adds	r1, #1
 8011398:	4299      	cmp	r1, r3
 801139a:	4450      	add	r0, sl
 801139c:	d1df      	bne.n	801135e <lcd_drawchar_size+0x76>
  for (uint32_t c = 0; c < FONT_GET_HEIGHT; c++, char_buf++) {
 801139e:	e9dd e205 	ldrd	lr, r2, [sp, #20]
 80113a2:	f8dd b01c 	ldr.w	fp, [sp, #28]
 80113a6:	3201      	adds	r2, #1
 80113a8:	455a      	cmp	r2, fp
 80113aa:	4664      	mov	r4, ip
 80113ac:	44e6      	add	lr, ip
 80113ae:	d1cb      	bne.n	8011348 <lcd_drawchar_size+0x60>
 80113b0:	e9dd c003 	ldrd	ip, r0, [sp, #12]
  lcd_bulk(x, y, w * size, FONT_GET_HEIGHT * size);
 80113b4:	fb15 f503 	smulbb	r5, r5, r3
 80113b8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80113bc:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80113c0:	4601      	mov	r1, r0
 80113c2:	462a      	mov	r2, r5
 80113c4:	4660      	mov	r0, ip
 80113c6:	f7ff fd63 	bl	8010e90 <lcd_bulk>
}
 80113ca:	4628      	mov	r0, r5
 80113cc:	b009      	add	sp, #36	@ 0x24
 80113ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80113d2:	bf00      	nop
 80113d4:	080154e0 	.word	0x080154e0
 80113d8:	20008a38 	.word	0x20008a38
 80113dc:	20008a3a 	.word	0x20008a3a
 80113e0:	20008a3c 	.word	0x20008a3c

080113e4 <lcd_drawfont>:
void lcd_drawfont(uint8_t ch, int x, int y) {
 80113e4:	b500      	push	{lr}
  lcd_blitBitmap(x, y, NUM_FONT_GET_WIDTH, NUM_FONT_GET_HEIGHT, NUM_FONT_GET_DATA(ch));
 80113e6:	eb00 0c80 	add.w	ip, r0, r0, lsl #2
 80113ea:	4b09      	ldr	r3, [pc, #36]	@ (8011410 <lcd_drawfont+0x2c>)
void lcd_drawfont(uint8_t ch, int x, int y) {
 80113ec:	b083      	sub	sp, #12
  lcd_blitBitmap(x, y, NUM_FONT_GET_WIDTH, NUM_FONT_GET_HEIGHT, NUM_FONT_GET_DATA(ch));
 80113ee:	eb00 004c 	add.w	r0, r0, ip, lsl #1
 80113f2:	eb03 0380 	add.w	r3, r3, r0, lsl #2
void lcd_drawfont(uint8_t ch, int x, int y) {
 80113f6:	468c      	mov	ip, r1
 80113f8:	4611      	mov	r1, r2
  lcd_blitBitmap(x, y, NUM_FONT_GET_WIDTH, NUM_FONT_GET_HEIGHT, NUM_FONT_GET_DATA(ch));
 80113fa:	9300      	str	r3, [sp, #0]
 80113fc:	2210      	movs	r2, #16
 80113fe:	2316      	movs	r3, #22
 8011400:	b289      	uxth	r1, r1
 8011402:	fa1f f08c 	uxth.w	r0, ip
 8011406:	f7ff fe69 	bl	80110dc <lcd_blitBitmap>
}
 801140a:	b003      	add	sp, #12
 801140c:	f85d fb04 	ldr.w	pc, [sp], #4
 8011410:	080150ec 	.word	0x080150ec

08011414 <lcd_drawstring_size>:
void lcd_drawstring_size(const char *str, int x, int y, uint8_t size) {
 8011414:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  while (*str)
 8011418:	7805      	ldrb	r5, [r0, #0]
 801141a:	b175      	cbz	r5, 801143a <lcd_drawstring_size+0x26>
 801141c:	4606      	mov	r6, r0
 801141e:	460c      	mov	r4, r1
 8011420:	4690      	mov	r8, r2
 8011422:	461f      	mov	r7, r3
    x += lcd_drawchar_size(*str++, x, y, size);
 8011424:	4621      	mov	r1, r4
 8011426:	4628      	mov	r0, r5
 8011428:	463b      	mov	r3, r7
 801142a:	4642      	mov	r2, r8
 801142c:	f7ff ff5c 	bl	80112e8 <lcd_drawchar_size>
  while (*str)
 8011430:	f816 5f01 	ldrb.w	r5, [r6, #1]!
    x += lcd_drawchar_size(*str++, x, y, size);
 8011434:	4404      	add	r4, r0
  while (*str)
 8011436:	2d00      	cmp	r5, #0
 8011438:	d1f4      	bne.n	8011424 <lcd_drawstring_size+0x10>
}
 801143a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801143e:	bf00      	nop

08011440 <get_fattime>:
//       diskio.c functions for file system library
//*******************************************************
// If enable RTC - get RTC time
#if FF_FS_NORTC == 0
DWORD get_fattime (void) {
  return rtc_get_FAT();
 8011440:	f000 bc1a 	b.w	8011c78 <rtc_get_FAT>

08011444 <disk_initialize>:
  r_cnt = 0;
  r_time = 0;
  crc_time = 0;
  total_time = chVTGetSystemTimeX();
#endif
  if (pdrv != 0) return disk_status(pdrv);
 8011444:	2800      	cmp	r0, #0
 8011446:	d147      	bne.n	80114d8 <disk_initialize+0x94>
DSTATUS disk_initialize(BYTE pdrv) {
 8011448:	b570      	push	{r4, r5, r6, lr}
  // Start init SD card
  CardStatus = 0;
  LCD_CS_HIGH;
 801144a:	4b3d      	ldr	r3, [pc, #244]	@ (8011540 <disk_initialize+0xfc>)
  CardStatus = 0;
 801144c:	4e3d      	ldr	r6, [pc, #244]	@ (8011544 <disk_initialize+0x100>)
  LCD_CS_HIGH;
 801144e:	2240      	movs	r2, #64	@ 0x40
DSTATUS disk_initialize(BYTE pdrv) {
 8011450:	b082      	sub	sp, #8
  LCD_CS_HIGH;
 8011452:	240a      	movs	r4, #10
  CardStatus = 0;
 8011454:	7030      	strb	r0, [r6, #0]
  LCD_CS_HIGH;
 8011456:	619a      	str	r2, [r3, #24]
  // Power on, try detect on bus, set card to idle state:
  //   Dummy TxRx 80 bits for power up SD
  for(int n = 0; n < 10; n++)
    spi_RxByte();
 8011458:	f7ff fb34 	bl	8010ac4 <spi_RxByte>
  for(int n = 0; n < 10; n++)
 801145c:	3c01      	subs	r4, #1
 801145e:	d1fb      	bne.n	8011458 <disk_initialize+0x14>
  // check disk type
  uint8_t  type = 0;
  uint32_t cnt = 100;
  // Set low SPI bus speed = PLL/256 (on 72MHz =281.250kHz)
  SD_Select_SPI(SD_INIT_SPI_SPEED);
 8011460:	2038      	movs	r0, #56	@ 0x38
 8011462:	f7ff fadf 	bl	8010a24 <SD_Select_SPI>
  // send GO_IDLE_STATE command
  if (SD_SendCmd(CMD0, 0) == SD_R1_IDLE) {
 8011466:	4621      	mov	r1, r4
 8011468:	2040      	movs	r0, #64	@ 0x40
 801146a:	f7ff fbdf 	bl	8010c2c <SD_SendCmd>
 801146e:	2801      	cmp	r0, #1
 8011470:	d004      	beq.n	801147c <disk_initialize+0x38>
      if (cnt && SD_SendCmd(CMD16, SD_SECTOR_SIZE) == 0)          // SET_BLOCKLEN and set type
        type = cmd == ACMD41 ? CT_SD1 : CT_MMC;
      DEBUG_PRINT(" CMD16 %d %d\r\n", cnt, type);
    }
  }
  SD_Unselect_SPI();
 8011472:	f7ff fb31 	bl	8010ad8 <SD_Unselect_SPI>
  DEBUG_PRINT("CardType %d\r\n", type);
  if (type)
 8011476:	2001      	movs	r0, #1
    CardStatus = CT_POWER_ON | type;
  return disk_status(pdrv);
}
 8011478:	b002      	add	sp, #8
 801147a:	bd70      	pop	{r4, r5, r6, pc}
    if (SD_SendCmd(CMD8, 0x00001AAU) == SD_R1_IDLE) {
 801147c:	f44f 71d5 	mov.w	r1, #426	@ 0x1aa
 8011480:	2048      	movs	r0, #72	@ 0x48
 8011482:	f7ff fbd3 	bl	8010c2c <SD_SendCmd>
 8011486:	2801      	cmp	r0, #1
 8011488:	d028      	beq.n	80114dc <disk_initialize+0x98>
      uint8_t cmd = (SD_SendCmd(ACMD41, 0) <= 1) ? ACMD41 : CMD1; // cmd for idle state
 801148a:	4621      	mov	r1, r4
 801148c:	20e9      	movs	r0, #233	@ 0xe9
 801148e:	f7ff fbcd 	bl	8010c2c <SD_SendCmd>
 8011492:	2801      	cmp	r0, #1
 8011494:	bf8c      	ite	hi
 8011496:	2541      	movhi	r5, #65	@ 0x41
 8011498:	25e9      	movls	r5, #233	@ 0xe9
  uint32_t cnt = 100;
 801149a:	2464      	movs	r4, #100	@ 0x64
      while(SD_SendCmd(cmd, 0) && --cnt)                          // Wait idle state (depend from card type)
 801149c:	e003      	b.n	80114a6 <disk_initialize+0x62>
 801149e:	3c01      	subs	r4, #1
 80114a0:	d046      	beq.n	8011530 <disk_initialize+0xec>
        chThdSleepMilliseconds(10);
 80114a2:	f7ef fcf5 	bl	8000e90 <chThdSleep>
      while(SD_SendCmd(cmd, 0) && --cnt)                          // Wait idle state (depend from card type)
 80114a6:	2100      	movs	r1, #0
 80114a8:	4628      	mov	r0, r5
 80114aa:	f7ff fbbf 	bl	8010c2c <SD_SendCmd>
 80114ae:	4603      	mov	r3, r0
        chThdSleepMilliseconds(10);
 80114b0:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
      while(SD_SendCmd(cmd, 0) && --cnt)                          // Wait idle state (depend from card type)
 80114b4:	2b00      	cmp	r3, #0
 80114b6:	d1f2      	bne.n	801149e <disk_initialize+0x5a>
      if (cnt && SD_SendCmd(CMD16, SD_SECTOR_SIZE) == 0)          // SET_BLOCKLEN and set type
 80114b8:	f44f 7100 	mov.w	r1, #512	@ 0x200
 80114bc:	2050      	movs	r0, #80	@ 0x50
 80114be:	f7ff fbb5 	bl	8010c2c <SD_SendCmd>
 80114c2:	2800      	cmp	r0, #0
 80114c4:	d134      	bne.n	8011530 <disk_initialize+0xec>
        type = cmd == ACMD41 ? CT_SD1 : CT_MMC;
 80114c6:	2de9      	cmp	r5, #233	@ 0xe9
 80114c8:	bf14      	ite	ne
 80114ca:	2481      	movne	r4, #129	@ 0x81
 80114cc:	2482      	moveq	r4, #130	@ 0x82
  SD_Unselect_SPI();
 80114ce:	f7ff fb03 	bl	8010ad8 <SD_Unselect_SPI>
    CardStatus = CT_POWER_ON | type;
 80114d2:	7034      	strb	r4, [r6, #0]
 80114d4:	2000      	movs	r0, #0
  return disk_status(pdrv);
 80114d6:	e7cf      	b.n	8011478 <disk_initialize+0x34>
  if (pdrv != 0) return disk_status(pdrv);
 80114d8:	2001      	movs	r0, #1
}
 80114da:	4770      	bx	lr
      uint32_t ocr; spi_RxBuffer((uint8_t *)&ocr, 4);
 80114dc:	2104      	movs	r1, #4
 80114de:	4668      	mov	r0, sp
 80114e0:	f7ff fb0e 	bl	8010b00 <spi_RxBuffer>
      if (ocr == _OCR(0x00001AAU)) {
 80114e4:	4b18      	ldr	r3, [pc, #96]	@ (8011548 <disk_initialize+0x104>)
 80114e6:	9a00      	ldr	r2, [sp, #0]
 80114e8:	429a      	cmp	r2, r3
 80114ea:	d1c2      	bne.n	8011472 <disk_initialize+0x2e>
  uint32_t cnt = 100;
 80114ec:	2464      	movs	r4, #100	@ 0x64
 80114ee:	e003      	b.n	80114f8 <disk_initialize+0xb4>
        while (SD_SendCmd(ACMD41, SD_OCR_CAPACITY) != 0 && --cnt)   // Check OCR
 80114f0:	3c01      	subs	r4, #1
 80114f2:	d01d      	beq.n	8011530 <disk_initialize+0xec>
          chThdSleepMilliseconds(10);
 80114f4:	f7ef fccc 	bl	8000e90 <chThdSleep>
        while (SD_SendCmd(ACMD41, SD_OCR_CAPACITY) != 0 && --cnt)   // Check OCR
 80114f8:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 80114fc:	20e9      	movs	r0, #233	@ 0xe9
 80114fe:	f7ff fb95 	bl	8010c2c <SD_SendCmd>
 8011502:	4601      	mov	r1, r0
          chThdSleepMilliseconds(10);
 8011504:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
        while (SD_SendCmd(ACMD41, SD_OCR_CAPACITY) != 0 && --cnt)   // Check OCR
 8011508:	2900      	cmp	r1, #0
 801150a:	d1f1      	bne.n	80114f0 <disk_initialize+0xac>
        if (cnt && SD_SendCmd(CMD58, 0) == 0) {
 801150c:	207a      	movs	r0, #122	@ 0x7a
 801150e:	f7ff fb8d 	bl	8010c2c <SD_SendCmd>
 8011512:	b968      	cbnz	r0, 8011530 <disk_initialize+0xec>
          DWORD ocr; spi_RxBuffer((uint8_t *)&ocr, 4);
 8011514:	2104      	movs	r1, #4
 8011516:	eb0d 0001 	add.w	r0, sp, r1
 801151a:	f7ff faf1 	bl	8010b00 <spi_RxBuffer>
          type = (ocr & _OCR(SD_OCR_CAPACITY)) ? CT_SD2 | CT_BLOCK : CT_SD2;
 801151e:	9b01      	ldr	r3, [sp, #4]
 8011520:	f013 0f40 	tst.w	r3, #64	@ 0x40
 8011524:	bf0c      	ite	eq
 8011526:	2484      	moveq	r4, #132	@ 0x84
 8011528:	248c      	movne	r4, #140	@ 0x8c
  SD_Unselect_SPI();
 801152a:	f7ff fad5 	bl	8010ad8 <SD_Unselect_SPI>
  if (type)
 801152e:	e7d0      	b.n	80114d2 <disk_initialize+0x8e>
  SD_Unselect_SPI();
 8011530:	f7ff fad2 	bl	8010ad8 <SD_Unselect_SPI>

// diskio.c - Return disk status
DSTATUS disk_status(BYTE pdrv) {
  if (pdrv != 0) return STA_NOINIT;
  return CardStatus == 0 ? STA_NOINIT : 0;
 8011534:	7830      	ldrb	r0, [r6, #0]
 8011536:	fab0 f080 	clz	r0, r0
 801153a:	0940      	lsrs	r0, r0, #5
}
 801153c:	b002      	add	sp, #8
 801153e:	bd70      	pop	{r4, r5, r6, pc}
 8011540:	48000400 	.word	0x48000400
 8011544:	20008a36 	.word	0x20008a36
 8011548:	aa010000 	.word	0xaa010000

0801154c <disk_status>:
  if (pdrv != 0) return STA_NOINIT;
 801154c:	b928      	cbnz	r0, 801155a <disk_status+0xe>
  return CardStatus == 0 ? STA_NOINIT : 0;
 801154e:	4b04      	ldr	r3, [pc, #16]	@ (8011560 <disk_status+0x14>)
 8011550:	7818      	ldrb	r0, [r3, #0]
 8011552:	fab0 f080 	clz	r0, r0
 8011556:	0940      	lsrs	r0, r0, #5
 8011558:	4770      	bx	lr
  if (pdrv != 0) return STA_NOINIT;
 801155a:	2001      	movs	r0, #1
}
 801155c:	4770      	bx	lr
 801155e:	bf00      	nop
 8011560:	20008a36 	.word	0x20008a36

08011564 <disk_read>:

// diskio.c - Read sector
DRESULT disk_read(BYTE pdrv, BYTE* buff, DWORD sector, UINT count) {
 8011564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // No disk or wrong block count
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 8011566:	b9e0      	cbnz	r0, 80115a2 <disk_read+0x3e>
 8011568:	461c      	mov	r4, r3
 801156a:	4b1e      	ldr	r3, [pc, #120]	@ (80115e4 <disk_read+0x80>)
 801156c:	4615      	mov	r5, r2
 801156e:	f993 2000 	ldrsb.w	r2, [r3]
 8011572:	781f      	ldrb	r7, [r3, #0]
 8011574:	2a00      	cmp	r2, #0
 8011576:	da14      	bge.n	80115a2 <disk_read+0x3e>
#if DEBUG == 1
  r_cnt+= count;
  r_time-= chVTGetSystemTimeX();
#endif
  SD_Select_SPI(SD_SPI_RX_SPEED);
 8011578:	460e      	mov	r6, r1
 801157a:	f7ff fa53 	bl	8010a24 <SD_Select_SPI>
  // convert to byte address if no block mode
  if (!(CardStatus & CT_BLOCK)) sector*= SD_SECTOR_SIZE;
 801157e:	073b      	lsls	r3, r7, #28
 8011580:	bf58      	it	pl
 8011582:	026d      	lslpl	r5, r5, #9
  if (count == 1) {                               // Read single block
 8011584:	2c01      	cmp	r4, #1
    if (SD_SendCmd(CMD17, sector) == 0 && SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 8011586:	4629      	mov	r1, r5
  if (count == 1) {                               // Read single block
 8011588:	d01f      	beq.n	80115ca <disk_read+0x66>
      count--;
  } else if (SD_SendCmd(CMD18, sector) == 0) {    // Read multiple blocks
 801158a:	2052      	movs	r0, #82	@ 0x52
 801158c:	f7ff fb4e 	bl	8010c2c <SD_SendCmd>
 8011590:	4605      	mov	r5, r0
 8011592:	b168      	cbz	r0, 80115b0 <disk_read+0x4c>
      DEBUG_PRINT("\r\n");
    }
  }
#endif
#endif
  return count ? RES_ERROR : RES_OK;
 8011594:	1e25      	subs	r5, r4, #0
 8011596:	bf18      	it	ne
 8011598:	2501      	movne	r5, #1
  SD_Unselect_SPI();
 801159a:	f7ff fa9d 	bl	8010ad8 <SD_Unselect_SPI>
}
 801159e:	4628      	mov	r0, r5
 80115a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80115a2:	2503      	movs	r5, #3
}
 80115a4:	4628      	mov	r0, r5
 80115a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while(SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK) && --count)
 80115a8:	3c01      	subs	r4, #1
 80115aa:	d009      	beq.n	80115c0 <disk_read+0x5c>
      buff+= SD_SECTOR_SIZE;
 80115ac:	f506 7600 	add.w	r6, r6, #512	@ 0x200
    while(SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK) && --count)
 80115b0:	4630      	mov	r0, r6
 80115b2:	f7ff fb09 	bl	8010bc8 <SD_RxDataBlock.constprop.0>
 80115b6:	2800      	cmp	r0, #0
 80115b8:	d1f6      	bne.n	80115a8 <disk_read+0x44>
  return count ? RES_ERROR : RES_OK;
 80115ba:	1e25      	subs	r5, r4, #0
 80115bc:	bf18      	it	ne
 80115be:	2501      	movne	r5, #1
    SD_SendCmd(CMD12, 0);                         // Finish multiple block read
 80115c0:	2100      	movs	r1, #0
 80115c2:	204c      	movs	r0, #76	@ 0x4c
 80115c4:	f7ff fb32 	bl	8010c2c <SD_SendCmd>
 80115c8:	e7e7      	b.n	801159a <disk_read+0x36>
    if (SD_SendCmd(CMD17, sector) == 0 && SD_RxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 80115ca:	2051      	movs	r0, #81	@ 0x51
 80115cc:	f7ff fb2e 	bl	8010c2c <SD_SendCmd>
 80115d0:	b108      	cbz	r0, 80115d6 <disk_read+0x72>
 80115d2:	4625      	mov	r5, r4
 80115d4:	e7e1      	b.n	801159a <disk_read+0x36>
 80115d6:	4630      	mov	r0, r6
 80115d8:	f7ff faf6 	bl	8010bc8 <SD_RxDataBlock.constprop.0>
 80115dc:	f080 0501 	eor.w	r5, r0, #1
  return count ? RES_ERROR : RES_OK;
 80115e0:	b2ed      	uxtb	r5, r5
 80115e2:	e7da      	b.n	801159a <disk_read+0x36>
 80115e4:	20008a36 	.word	0x20008a36

080115e8 <disk_write>:

// diskio.c - Write sector
DRESULT disk_write(BYTE pdrv, const BYTE* buff, DWORD sector, UINT count) {
 80115e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // No disk or wrong block count
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80115ea:	2800      	cmp	r0, #0
 80115ec:	d139      	bne.n	8011662 <disk_write+0x7a>
 80115ee:	461c      	mov	r4, r3
 80115f0:	4b24      	ldr	r3, [pc, #144]	@ (8011684 <disk_write+0x9c>)
 80115f2:	4616      	mov	r6, r2
 80115f4:	f993 2000 	ldrsb.w	r2, [r3]
 80115f8:	781f      	ldrb	r7, [r3, #0]
 80115fa:	2a00      	cmp	r2, #0
 80115fc:	da31      	bge.n	8011662 <disk_write+0x7a>
  // Write protection
  if (CardStatus & CT_WRPROTECT) return RES_WRPRT;
 80115fe:	067a      	lsls	r2, r7, #25
 8011600:	d42c      	bmi.n	801165c <disk_write+0x74>
    }
#endif
  w_cnt+=count;
  w_time-= chVTGetSystemTimeX();
#endif
  SD_Select_SPI(SD_SPI_SPEED);
 8011602:	460d      	mov	r5, r1
 8011604:	f7ff fa0e 	bl	8010a24 <SD_Select_SPI>
#if 1                                                 // Write multiple block mode
  // convert to byte address if no block mode
  if (!(CardStatus & CT_BLOCK)) sector*= SD_SECTOR_SIZE;
 8011608:	073b      	lsls	r3, r7, #28
 801160a:	bf58      	it	pl
 801160c:	0276      	lslpl	r6, r6, #9
  if (count == 1) {                                   // Write single block
 801160e:	2c01      	cmp	r4, #1
    if (SD_SendCmd(CMD24, sector) == 0 && SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 8011610:	4631      	mov	r1, r6
  if (count == 1) {                                   // Write single block
 8011612:	d029      	beq.n	8011668 <disk_write+0x80>
      count--;
  } else if (SD_SendCmd(CMD25, sector) == 0) {        // Write multiple blocks, wait busy
 8011614:	2059      	movs	r0, #89	@ 0x59
 8011616:	f7ff fb09 	bl	8010c2c <SD_SendCmd>
 801161a:	4606      	mov	r6, r0
 801161c:	b170      	cbz	r0, 801163c <disk_write+0x54>
  w_time+= chVTGetSystemTimeX();
  if (count)
    DEBUG_PRINT(" WRITE_BLOCK %d 0x%08x\r\n", count, sector);
#endif

  return count ? RES_ERROR : RES_OK;
 801161e:	1e26      	subs	r6, r4, #0
 8011620:	bf18      	it	ne
 8011622:	2601      	movne	r6, #1
  SD_Unselect_SPI();
 8011624:	f7ff fa58 	bl	8010ad8 <SD_Unselect_SPI>
}
 8011628:	4630      	mov	r0, r6
 801162a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while (SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_M_BLOCK) && SD_WaitNotBusy(MS2ST(250)) == 0xFF && --count)
 801162c:	f7ff fa8a 	bl	8010b44 <SD_WaitNotBusy>
 8011630:	28ff      	cmp	r0, #255	@ 0xff
 8011632:	d10c      	bne.n	801164e <disk_write+0x66>
 8011634:	3c01      	subs	r4, #1
 8011636:	d00d      	beq.n	8011654 <disk_write+0x6c>
      buff+= SD_SECTOR_SIZE;
 8011638:	f505 7500 	add.w	r5, r5, #512	@ 0x200
    while (SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_M_BLOCK) && SD_WaitNotBusy(MS2ST(250)) == 0xFF && --count)
 801163c:	21fc      	movs	r1, #252	@ 0xfc
 801163e:	4628      	mov	r0, r5
 8011640:	f7ff fa94 	bl	8010b6c <SD_TxDataBlock.constprop.0>
 8011644:	4603      	mov	r3, r0
 8011646:	f246 10a8 	movw	r0, #25000	@ 0x61a8
 801164a:	2b00      	cmp	r3, #0
 801164c:	d1ee      	bne.n	801162c <disk_write+0x44>
  return count ? RES_ERROR : RES_OK;
 801164e:	1e26      	subs	r6, r4, #0
 8011650:	bf18      	it	ne
 8011652:	2601      	movne	r6, #1
    spi_TxByte(SD_TOKEN_STOP_M_BLOCK);                // Finish multiple block write
 8011654:	20fd      	movs	r0, #253	@ 0xfd
 8011656:	f7ff f9fd 	bl	8010a54 <spi_TxByte>
 801165a:	e7e3      	b.n	8011624 <disk_write+0x3c>
  if (CardStatus & CT_WRPROTECT) return RES_WRPRT;
 801165c:	2602      	movs	r6, #2
}
 801165e:	4630      	mov	r0, r6
 8011660:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 8011662:	2603      	movs	r6, #3
}
 8011664:	4630      	mov	r0, r6
 8011666:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (SD_SendCmd(CMD24, sector) == 0 && SD_TxDataBlock(buff, SD_SECTOR_SIZE, SD_TOKEN_START_BLOCK))
 8011668:	2058      	movs	r0, #88	@ 0x58
 801166a:	f7ff fadf 	bl	8010c2c <SD_SendCmd>
 801166e:	b108      	cbz	r0, 8011674 <disk_write+0x8c>
 8011670:	4626      	mov	r6, r4
 8011672:	e7d7      	b.n	8011624 <disk_write+0x3c>
 8011674:	21fe      	movs	r1, #254	@ 0xfe
 8011676:	4628      	mov	r0, r5
 8011678:	f7ff fa78 	bl	8010b6c <SD_TxDataBlock.constprop.0>
 801167c:	f080 0601 	eor.w	r6, r0, #1
  return count ? RES_ERROR : RES_OK;
 8011680:	b2f6      	uxtb	r6, r6
 8011682:	e7cf      	b.n	8011624 <disk_write+0x3c>
 8011684:	20008a36 	.word	0x20008a36

08011688 <disk_ioctl>:

// The disk_ioctl function is called to control device specific features and miscellaneous functions other than generic read/write.
// Implement only five device independent commands used by FatFS module
DRESULT disk_ioctl(BYTE pdrv, BYTE cmd, void* buff) {
 8011688:	b510      	push	{r4, lr}
  (void)buff;
  DRESULT res = RES_PARERR;
  // No disk or not ready
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 801168a:	b968      	cbnz	r0, 80116a8 <disk_ioctl+0x20>
 801168c:	4b0d      	ldr	r3, [pc, #52]	@ (80116c4 <disk_ioctl+0x3c>)
 801168e:	f993 3000 	ldrsb.w	r3, [r3]
 8011692:	2b00      	cmp	r3, #0
 8011694:	da08      	bge.n	80116a8 <disk_ioctl+0x20>
  SD_Select_SPI(SD_SPI_RX_SPEED);
 8011696:	460c      	mov	r4, r1
 8011698:	f7ff f9c4 	bl	8010a24 <SD_Select_SPI>
  switch (cmd){
 801169c:	b13c      	cbz	r4, 80116ae <disk_ioctl+0x26>
  DRESULT res = RES_PARERR;
 801169e:	2404      	movs	r4, #4
      }
    }
    break;
#endif
  }
  SD_Unselect_SPI();
 80116a0:	f7ff fa1a 	bl	8010ad8 <SD_Unselect_SPI>
  DEBUG_PRINT("disk_ioctl(%d) = %d,\r\n", cmd, res);
#if DEBUG == 1
  testLog();
#endif
  return res;
}
 80116a4:	4620      	mov	r0, r4
 80116a6:	bd10      	pop	{r4, pc}
  if (pdrv != 0 || !(CardStatus & CT_POWER_ON)) return RES_NOTRDY;
 80116a8:	2403      	movs	r4, #3
}
 80116aa:	4620      	mov	r0, r4
 80116ac:	bd10      	pop	{r4, pc}
      if (SD_WaitNotBusy(MS2ST(200)) == 0xFF) res = RES_OK;
 80116ae:	f644 6020 	movw	r0, #20000	@ 0x4e20
 80116b2:	f7ff fa47 	bl	8010b44 <SD_WaitNotBusy>
 80116b6:	f1b0 04ff 	subs.w	r4, r0, #255	@ 0xff
 80116ba:	bf18      	it	ne
 80116bc:	2401      	movne	r4, #1
 80116be:	00a4      	lsls	r4, r4, #2
 80116c0:	e7ee      	b.n	80116a0 <disk_ioctl+0x18>
 80116c2:	bf00      	nop
 80116c4:	20008a36 	.word	0x20008a36

080116c8 <lcd_show_logo>:

#include "HB9IIUlogo.h"   // make sure this path is correct for your project

// Draw centered 1bpp logo (no arguments)
void lcd_show_logo(void)
{
 80116c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80116cc:	4d1d      	ldr	r5, [pc, #116]	@ (8011744 <lcd_show_logo+0x7c>)
 80116ce:	4f1e      	ldr	r7, [pc, #120]	@ (8011748 <lcd_show_logo+0x80>)
 80116d0:	b083      	sub	sp, #12
 80116d2:	23ff      	movs	r3, #255	@ 0xff
  const pixel_t bg = RGB565(255,255,255); // white
  const pixel_t fg = RGB565(0,0,0);       // black

  const int bytes_per_row = (w + 7) >> 3;

  for (int y = 0; y < h; y++) {
 80116d4:	f04f 0900 	mov.w	r9, #0
 80116d8:	f1a5 043c 	sub.w	r4, r5, #60	@ 0x3c
 80116dc:	f1c5 0800 	rsb	r8, r5, #0
 80116e0:	463e      	mov	r6, r7

      for (int i = 0; i < chunk; i++) {
        int px = x + i;
        int byte_i = px >> 3;
        int bit_i  = 7 - (px & 7);        // MSB-first
        int on = (row[byte_i] >> bit_i) & 1;
 80116e2:	11db      	asrs	r3, r3, #7
        spi_buffer[i] = on ? fg : bg;
 80116e4:	3b01      	subs	r3, #1
 80116e6:	4818      	ldr	r0, [pc, #96]	@ (8011748 <lcd_show_logo+0x80>)
 80116e8:	803b      	strh	r3, [r7, #0]
 80116ea:	eb08 0c05 	add.w	ip, r8, r5
      for (int i = 0; i < chunk; i++) {
 80116ee:	4637      	mov	r7, r6
 80116f0:	2201      	movs	r2, #1
        int on = (row[byte_i] >> bit_i) & 1;
 80116f2:	eb0c 03e2 	add.w	r3, ip, r2, asr #3
        int bit_i  = 7 - (px & 7);        // MSB-first
 80116f6:	43d1      	mvns	r1, r2
        int on = (row[byte_i] >> bit_i) & 1;
 80116f8:	5ce3      	ldrb	r3, [r4, r3]
        int bit_i  = 7 - (px & 7);        // MSB-first
 80116fa:	f001 0107 	and.w	r1, r1, #7
        int on = (row[byte_i] >> bit_i) & 1;
 80116fe:	410b      	asrs	r3, r1
 8011700:	f003 0301 	and.w	r3, r3, #1
      for (int i = 0; i < chunk; i++) {
 8011704:	3201      	adds	r2, #1
        spi_buffer[i] = on ? fg : bg;
 8011706:	3b01      	subs	r3, #1
      for (int i = 0; i < chunk; i++) {
 8011708:	f5b2 7ff0 	cmp.w	r2, #480	@ 0x1e0
        spi_buffer[i] = on ? fg : bg;
 801170c:	f820 3f02 	strh.w	r3, [r0, #2]!
      for (int i = 0; i < chunk; i++) {
 8011710:	d1ef      	bne.n	80116f2 <lcd_show_logo+0x2a>
      }

      lcd_bulk_buffer(x0 + x, y0 + y, chunk, 1, spi_buffer);
 8011712:	2301      	movs	r3, #1
 8011714:	4649      	mov	r1, r9
 8011716:	9600      	str	r6, [sp, #0]
 8011718:	2000      	movs	r0, #0
  for (int y = 0; y < h; y++) {
 801171a:	f109 0901 	add.w	r9, r9, #1
      lcd_bulk_buffer(x0 + x, y0 + y, chunk, 1, spi_buffer);
 801171e:	f7ff fb19 	bl	8010d54 <lcd_bulk_buffer>
      lcd_bulk_finish();
 8011722:	f7ff fb99 	bl	8010e58 <lcd_bulk_finish>
  for (int y = 0; y < h; y++) {
 8011726:	f5b9 7fa0 	cmp.w	r9, #320	@ 0x140
 801172a:	f105 053c 	add.w	r5, r5, #60	@ 0x3c
 801172e:	d002      	beq.n	8011736 <lcd_show_logo+0x6e>
        int on = (row[byte_i] >> bit_i) & 1;
 8011730:	f815 3c3c 	ldrb.w	r3, [r5, #-60]
 8011734:	e7d5      	b.n	80116e2 <lcd_show_logo+0x1a>
      x += chunk;
    }
  }
  chThdSleepMilliseconds(3000);
 8011736:	4805      	ldr	r0, [pc, #20]	@ (801174c <lcd_show_logo+0x84>)
}
 8011738:	b003      	add	sp, #12
 801173a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
  chThdSleepMilliseconds(3000);
 801173e:	f7ef bba7 	b.w	8000e90 <chThdSleep>
 8011742:	bf00      	nop
 8011744:	08016f08 	.word	0x08016f08
 8011748:	20008a3c 	.word	0x20008a3c
 801174c:	000493e0 	.word	0x000493e0

08011750 <config_save>:
  while (len-- > 0)
    value = __ROR(value, 31) + *p++;
  return value;
}

int config_save(void) {
 8011750:	b538      	push	{r3, r4, r5, lr}
  // Apply magic word and calculate checksum
  config.magic = CONFIG_MAGIC;
 8011752:	4d0a      	ldr	r5, [pc, #40]	@ (801177c <config_save+0x2c>)
 8011754:	4b0a      	ldr	r3, [pc, #40]	@ (8011780 <config_save+0x30>)
 8011756:	602b      	str	r3, [r5, #0]
  uint32_t value = 0;
 8011758:	2400      	movs	r4, #0
  uint32_t *p = (uint32_t*)start;
 801175a:	462b      	mov	r3, r5
 801175c:	f105 0170 	add.w	r1, r5, #112	@ 0x70
    value = __ROR(value, 31) + *p++;
 8011760:	f853 2b04 	ldr.w	r2, [r3], #4
  while (len-- > 0)
 8011764:	428b      	cmp	r3, r1
    value = __ROR(value, 31) + *p++;
 8011766:	eb02 74f4 	add.w	r4, r2, r4, ror #31
  while (len-- > 0)
 801176a:	d1f9      	bne.n	8011760 <config_save+0x10>
  config.checksum = checksum(&config, sizeof config - sizeof config.checksum);

  // write to flash
  flash_program_half_word_buffer((uint16_t*)SAVE_CONFIG_ADDR, (uint16_t*)&config, sizeof(config_t));
 801176c:	4903      	ldr	r1, [pc, #12]	@ (801177c <config_save+0x2c>)
 801176e:	4805      	ldr	r0, [pc, #20]	@ (8011784 <config_save+0x34>)
  config.checksum = checksum(&config, sizeof config - sizeof config.checksum);
 8011770:	672c      	str	r4, [r5, #112]	@ 0x70
  flash_program_half_word_buffer((uint16_t*)SAVE_CONFIG_ADDR, (uint16_t*)&config, sizeof(config_t));
 8011772:	2274      	movs	r2, #116	@ 0x74
 8011774:	f000 fbaa 	bl	8011ecc <flash_program_half_word_buffer>
  return 0;
}
 8011778:	2000      	movs	r0, #0
 801177a:	bd38      	pop	{r3, r4, r5, pc}
 801177c:	20000318 	.word	0x20000318
 8011780:	434f4e56 	.word	0x434f4e56
 8011784:	0803f800 	.word	0x0803f800

08011788 <config_recall>:

int config_recall(void) {
 8011788:	b508      	push	{r3, lr}
  const config_t *src = (const config_t*)SAVE_CONFIG_ADDR;

  if (src->magic != CONFIG_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 801178a:	4b0d      	ldr	r3, [pc, #52]	@ (80117c0 <config_recall+0x38>)
 801178c:	4a0d      	ldr	r2, [pc, #52]	@ (80117c4 <config_recall+0x3c>)
 801178e:	6819      	ldr	r1, [r3, #0]
 8011790:	4291      	cmp	r1, r2
 8011792:	d112      	bne.n	80117ba <config_recall+0x32>
  while (len-- > 0)
 8011794:	480c      	ldr	r0, [pc, #48]	@ (80117c8 <config_recall+0x40>)
  uint32_t value = 0;
 8011796:	2200      	movs	r2, #0
    \param [in]    value  Number of Bits to rotate
    \return               Rotated value
 */
__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  return (op1 >> op2) | (op1 << (32 - op2));
 8011798:	4619      	mov	r1, r3
    value = __ROR(value, 31) + *p++;
 801179a:	3304      	adds	r3, #4
 801179c:	6809      	ldr	r1, [r1, #0]
  while (len-- > 0)
 801179e:	4283      	cmp	r3, r0
    value = __ROR(value, 31) + *p++;
 80117a0:	eb01 72f2 	add.w	r2, r1, r2, ror #31
  while (len-- > 0)
 80117a4:	d1f8      	bne.n	8011798 <config_recall+0x10>
  if (src->magic != CONFIG_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 80117a6:	4906      	ldr	r1, [pc, #24]	@ (80117c0 <config_recall+0x38>)
 80117a8:	6f0b      	ldr	r3, [r1, #112]	@ 0x70
 80117aa:	4293      	cmp	r3, r2
 80117ac:	d105      	bne.n	80117ba <config_recall+0x32>
    return -1;
  // duplicated saved data onto sram to be able to modify marker/trace
  memcpy(&config, src, sizeof(config_t));
 80117ae:	2274      	movs	r2, #116	@ 0x74
 80117b0:	4806      	ldr	r0, [pc, #24]	@ (80117cc <config_recall+0x44>)
 80117b2:	f001 f833 	bl	801281c <memcpy>
  return 0;
 80117b6:	2000      	movs	r0, #0
}
 80117b8:	bd08      	pop	{r3, pc}
    return -1;
 80117ba:	f04f 30ff 	mov.w	r0, #4294967295
}
 80117be:	bd08      	pop	{r3, pc}
 80117c0:	0803f800 	.word	0x0803f800
 80117c4:	434f4e56 	.word	0x434f4e56
 80117c8:	0803f870 	.word	0x0803f870
 80117cc:	20000318 	.word	0x20000318

080117d0 <caldata_save>:

int caldata_save(uint32_t id) {
  if (id >= SAVEAREA_MAX)
 80117d0:	2806      	cmp	r0, #6
 80117d2:	d81d      	bhi.n	8011810 <caldata_save+0x40>
int caldata_save(uint32_t id) {
 80117d4:	b538      	push	{r3, r4, r5, lr}
    return -1;

  // Apply magic word and calculate checksum
  current_props.magic = PROPERTIES_MAGIC;
 80117d6:	4b10      	ldr	r3, [pc, #64]	@ (8011818 <caldata_save+0x48>)
 80117d8:	4a10      	ldr	r2, [pc, #64]	@ (801181c <caldata_save+0x4c>)
 80117da:	4c11      	ldr	r4, [pc, #68]	@ (8011820 <caldata_save+0x50>)
 80117dc:	601a      	str	r2, [r3, #0]
 80117de:	4605      	mov	r5, r0
  uint32_t value = 0;
 80117e0:	2200      	movs	r2, #0
    value = __ROR(value, 31) + *p++;
 80117e2:	f853 1b04 	ldr.w	r1, [r3], #4
  while (len-- > 0)
 80117e6:	42a3      	cmp	r3, r4
    value = __ROR(value, 31) + *p++;
 80117e8:	eb01 72f2 	add.w	r2, r1, r2, ror #31
  while (len-- > 0)
 80117ec:	d1f9      	bne.n	80117e2 <caldata_save+0x12>
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 80117ee:	4b0d      	ldr	r3, [pc, #52]	@ (8011824 <caldata_save+0x54>)
  current_props.checksum = checksum(&current_props, sizeof current_props - sizeof current_props.checksum);
 80117f0:	490d      	ldr	r1, [pc, #52]	@ (8011828 <caldata_save+0x58>)
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 80117f2:	b228      	sxth	r0, r5

  // write to flash
  uint16_t *dst = (uint16_t*)calibration_slot_area(id);
  flash_program_half_word_buffer(dst, (uint16_t*)&current_props, sizeof(properties_t));
 80117f4:	eb03 3080 	add.w	r0, r3, r0, lsl #14
  current_props.checksum = checksum(&current_props, sizeof current_props - sizeof current_props.checksum);
 80117f8:	f8c1 2f78 	str.w	r2, [r1, #3960]	@ 0xf78
  flash_program_half_word_buffer(dst, (uint16_t*)&current_props, sizeof(properties_t));
 80117fc:	f5a1 5140 	sub.w	r1, r1, #12288	@ 0x3000
 8011800:	f643 727c 	movw	r2, #16252	@ 0x3f7c
 8011804:	f000 fb62 	bl	8011ecc <flash_program_half_word_buffer>

  lastsaveid = id;
 8011808:	4b08      	ldr	r3, [pc, #32]	@ (801182c <caldata_save+0x5c>)
  return 0;
 801180a:	2000      	movs	r0, #0
  lastsaveid = id;
 801180c:	801d      	strh	r5, [r3, #0]
}
 801180e:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 8011810:	f04f 30ff 	mov.w	r0, #4294967295
}
 8011814:	4770      	bx	lr
 8011816:	bf00      	nop
 8011818:	20000aa8 	.word	0x20000aa8
 801181c:	434f4e54 	.word	0x434f4e54
 8011820:	20004a20 	.word	0x20004a20
 8011824:	08023800 	.word	0x08023800
 8011828:	20003aa8 	.word	0x20003aa8
 801182c:	20009a3e 	.word	0x20009a3e

08011830 <get_properties>:

const properties_t * get_properties(uint32_t id) {
  if (id >= SAVEAREA_MAX)
 8011830:	2806      	cmp	r0, #6
 8011832:	d82b      	bhi.n	801188c <get_properties+0x5c>
const properties_t * get_properties(uint32_t id) {
 8011834:	b530      	push	{r4, r5, lr}
    return NULL;
  // point to saved area on the flash memory
  properties_t *src = (properties_t*)calibration_slot_area(id);
  // Check crc cache mask (made it only 1 time)
  if (checksum_ok&(1<<id))
 8011836:	4d16      	ldr	r5, [pc, #88]	@ (8011890 <get_properties+0x60>)
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 8011838:	4a16      	ldr	r2, [pc, #88]	@ (8011894 <get_properties+0x64>)
  if (checksum_ok&(1<<id))
 801183a:	f895 e000 	ldrb.w	lr, [r5]
 801183e:	4601      	mov	r1, r0
  return SAVE_PROP_CONFIG_ADDR + id * SAVE_PROP_CONFIG_SIZE;
 8011840:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 8011844:	fb11 2000 	smlabb	r0, r1, r0, r2
  if (checksum_ok&(1<<id))
 8011848:	fa4e f201 	asr.w	r2, lr, r1
 801184c:	f012 0201 	ands.w	r2, r2, #1
 8011850:	d119      	bne.n	8011886 <get_properties+0x56>
    return src;
  if (src->magic != PROPERTIES_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 8011852:	4b11      	ldr	r3, [pc, #68]	@ (8011898 <get_properties+0x68>)
 8011854:	6804      	ldr	r4, [r0, #0]
 8011856:	429c      	cmp	r4, r3
 8011858:	d116      	bne.n	8011888 <get_properties+0x58>
 801185a:	4b10      	ldr	r3, [pc, #64]	@ (801189c <get_properties+0x6c>)
 801185c:	eb03 3c81 	add.w	ip, r3, r1, lsl #14
  uint32_t *p = (uint32_t*)start;
 8011860:	4603      	mov	r3, r0
 8011862:	461c      	mov	r4, r3
    value = __ROR(value, 31) + *p++;
 8011864:	3304      	adds	r3, #4
 8011866:	6824      	ldr	r4, [r4, #0]
  while (len-- > 0)
 8011868:	459c      	cmp	ip, r3
    value = __ROR(value, 31) + *p++;
 801186a:	eb04 72f2 	add.w	r2, r4, r2, ror #31
  while (len-- > 0)
 801186e:	d1f8      	bne.n	8011862 <get_properties+0x32>
  if (src->magic != PROPERTIES_MAGIC || checksum(src, sizeof *src - sizeof src->checksum) != src->checksum)
 8011870:	f500 5340 	add.w	r3, r0, #12288	@ 0x3000
 8011874:	f8d3 3f78 	ldr.w	r3, [r3, #3960]	@ 0xf78
 8011878:	4293      	cmp	r3, r2
 801187a:	d105      	bne.n	8011888 <get_properties+0x58>
    return NULL;
  checksum_ok|=1<<id;
 801187c:	2301      	movs	r3, #1
 801187e:	408b      	lsls	r3, r1
 8011880:	ea4e 0303 	orr.w	r3, lr, r3
 8011884:	702b      	strb	r3, [r5, #0]
  return src;
}
 8011886:	bd30      	pop	{r4, r5, pc}
    return NULL;
 8011888:	2000      	movs	r0, #0
}
 801188a:	bd30      	pop	{r4, r5, pc}
    return NULL;
 801188c:	2000      	movs	r0, #0
}
 801188e:	4770      	bx	lr
 8011890:	20009a3c 	.word	0x20009a3c
 8011894:	08023800 	.word	0x08023800
 8011898:	434f4e54 	.word	0x434f4e54
 801189c:	08027778 	.word	0x08027778

080118a0 <caldata_recall>:

int caldata_recall(uint32_t id) {
 80118a0:	b538      	push	{r3, r4, r5, lr}
  lastsaveid = NO_SAVE_SLOT;
 80118a2:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 80118a6:	4d09      	ldr	r5, [pc, #36]	@ (80118cc <caldata_recall+0x2c>)
  if (id == NO_SAVE_SLOT)
 80118a8:	4298      	cmp	r0, r3
  lastsaveid = NO_SAVE_SLOT;
 80118aa:	802b      	strh	r3, [r5, #0]
  if (id == NO_SAVE_SLOT)
 80118ac:	d00a      	beq.n	80118c4 <caldata_recall+0x24>
    return 0;
  // point to saved area on the flash memory
  const properties_t *src = get_properties(id);
 80118ae:	4604      	mov	r4, r0
 80118b0:	f7ff ffbe 	bl	8011830 <get_properties>
  if (src == NULL){
 80118b4:	4601      	mov	r1, r0
 80118b6:	b138      	cbz	r0, 80118c8 <caldata_recall+0x28>
    return 1;
  }
  // active configuration points to save data on flash memory
  lastsaveid = id;
  // duplicated saved data onto sram to be able to modify marker/trace
  memcpy(&current_props, src, sizeof(properties_t));
 80118b8:	4805      	ldr	r0, [pc, #20]	@ (80118d0 <caldata_recall+0x30>)
  lastsaveid = id;
 80118ba:	802c      	strh	r4, [r5, #0]
  memcpy(&current_props, src, sizeof(properties_t));
 80118bc:	f643 727c 	movw	r2, #16252	@ 0x3f7c
 80118c0:	f000 ffac 	bl	801281c <memcpy>
    return 0;
 80118c4:	2000      	movs	r0, #0
  return 0;
}
 80118c6:	bd38      	pop	{r3, r4, r5, pc}
    return 1;
 80118c8:	2001      	movs	r0, #1
}
 80118ca:	bd38      	pop	{r3, r4, r5, pc}
 80118cc:	20009a3e 	.word	0x20009a3e
 80118d0:	20000aa8 	.word	0x20000aa8

080118d4 <clear_all_config_prop_data>:

void clear_all_config_prop_data(void) {
  lastsaveid = NO_SAVE_SLOT;
  checksum_ok = 0;
 80118d4:	4b07      	ldr	r3, [pc, #28]	@ (80118f4 <clear_all_config_prop_data+0x20>)
  // unlock and erase flash pages
  flash_erase_pages(SAVE_PROP_CONFIG_ADDR, SAVE_FULL_AREA_SIZE);
 80118d6:	4808      	ldr	r0, [pc, #32]	@ (80118f8 <clear_all_config_prop_data+0x24>)
void clear_all_config_prop_data(void) {
 80118d8:	b410      	push	{r4}
  checksum_ok = 0;
 80118da:	2200      	movs	r2, #0
  lastsaveid = NO_SAVE_SLOT;
 80118dc:	4c07      	ldr	r4, [pc, #28]	@ (80118fc <clear_all_config_prop_data+0x28>)
  checksum_ok = 0;
 80118de:	701a      	strb	r2, [r3, #0]
  lastsaveid = NO_SAVE_SLOT;
 80118e0:	f64f 7cff 	movw	ip, #65535	@ 0xffff
 80118e4:	f8a4 c000 	strh.w	ip, [r4]
  flash_erase_pages(SAVE_PROP_CONFIG_ADDR, SAVE_FULL_AREA_SIZE);
 80118e8:	f44f 31e4 	mov.w	r1, #116736	@ 0x1c800
}
 80118ec:	f85d 4b04 	ldr.w	r4, [sp], #4
  flash_erase_pages(SAVE_PROP_CONFIG_ADDR, SAVE_FULL_AREA_SIZE);
 80118f0:	f000 bac2 	b.w	8011e78 <flash_erase_pages>
 80118f4:	20009a3c 	.word	0x20009a3c
 80118f8:	08023800 	.word	0x08023800
 80118fc:	20009a3e 	.word	0x20009a3e

08011900 <adcStartMeasure>:
//nvicEnableVector(STM32_ADC3_NUMBER, STM32_ADC_ADC3_IRQ_PRIORITY);
//ADC3_4_COMMON->CCR = STM32_ADC_ADC34_CLOCK_MODE;
}

#define ADC_AVERAGE_N 4
static void adcStartMeasure(ADC_TypeDef *adc, uint32_t sqr0, uint16_t *samples) {
 8011900:	b570      	push	{r4, r5, r6, lr}
 8011902:	4603      	mov	r3, r0
 8011904:	4615      	mov	r5, r2
  // ADC setup
  adc->ISR   = adc->ISR;            // reset interrupts
 8011906:	6800      	ldr	r0, [r0, #0]
 8011908:	6018      	str	r0, [r3, #0]
  adc->IER   = 0;                   // disable interrupts
 801190a:	2200      	movs	r2, #0
//adc->SQR3  = sqr2;
//adc->SQR4  = sqr3;
  adc->CFGR = ADC_CFGR1_RES_12BIT;  // ADC configuration.
  // Starting conversion.
  uint16_t count = sqr0 & 0xF;
  for (uint16_t i = 0; i <= count; i++) samples[i] = 0;
 801190c:	f011 060f 	ands.w	r6, r1, #15
  adc->IER   = 0;                   // disable interrupts
 8011910:	605a      	str	r2, [r3, #4]
  adc->TR1   = ADC_TR(0, 0);        // reset threshold
 8011912:	eb05 0c46 	add.w	ip, r5, r6, lsl #1
 8011916:	621a      	str	r2, [r3, #32]
static void adcStartMeasure(ADC_TypeDef *adc, uint32_t sqr0, uint16_t *samples) {
 8011918:	f04f 0e10 	mov.w	lr, #16
  adc->SQR1  = sqr0;                // set measure sequence
 801191c:	6319      	str	r1, [r3, #48]	@ 0x30
  adc->CFGR = ADC_CFGR1_RES_12BIT;  // ADC configuration.
 801191e:	f1a5 0402 	sub.w	r4, r5, #2
 8011922:	60da      	str	r2, [r3, #12]
  for (uint16_t i = 0; i <= count; i++) samples[i] = 0;
 8011924:	802a      	strh	r2, [r5, #0]
 8011926:	bf18      	it	ne
 8011928:	806a      	strhne	r2, [r5, #2]
  int j = 1<<ADC_AVERAGE_N;
  do {
    adc->CR|= ADC_CR_ADSTART;
 801192a:	689a      	ldr	r2, [r3, #8]
 801192c:	f042 0204 	orr.w	r2, r2, #4
 8011930:	4621      	mov	r1, r4
 8011932:	609a      	str	r2, [r3, #8]
    for (uint16_t i = 0; i <= count; i++) {
 8011934:	e002      	b.n	801193c <adcStartMeasure+0x3c>
      while((adc->ISR & ADC_ISR_EOC) == 0 && adc->CR & ADC_CR_ADSTART); // wait one sample ready
 8011936:	689a      	ldr	r2, [r3, #8]
 8011938:	0752      	lsls	r2, r2, #29
 801193a:	d502      	bpl.n	8011942 <adcStartMeasure+0x42>
 801193c:	681a      	ldr	r2, [r3, #0]
 801193e:	0750      	lsls	r0, r2, #29
 8011940:	d5f9      	bpl.n	8011936 <adcStartMeasure+0x36>
      samples[i]+= adc->DR;
 8011942:	f831 0f02 	ldrh.w	r0, [r1, #2]!
 8011946:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
    for (uint16_t i = 0; i <= count; i++) {
 8011948:	4561      	cmp	r1, ip
      samples[i]+= adc->DR;
 801194a:	4402      	add	r2, r0
 801194c:	800a      	strh	r2, [r1, #0]
    for (uint16_t i = 0; i <= count; i++) {
 801194e:	d1f5      	bne.n	801193c <adcStartMeasure+0x3c>
    }
  } while (--j);
 8011950:	f1be 0e01 	subs.w	lr, lr, #1
 8011954:	d1e9      	bne.n	801192a <adcStartMeasure+0x2a>
  for (uint16_t i = 0; i <= count; i++) samples[i]>>= ADC_AVERAGE_N;
 8011956:	882b      	ldrh	r3, [r5, #0]
 8011958:	091b      	lsrs	r3, r3, #4
 801195a:	802b      	strh	r3, [r5, #0]
 801195c:	b116      	cbz	r6, 8011964 <adcStartMeasure+0x64>
 801195e:	886b      	ldrh	r3, [r5, #2]
 8011960:	091b      	lsrs	r3, r3, #4
 8011962:	806b      	strh	r3, [r5, #2]
}
 8011964:	bd70      	pop	{r4, r5, r6, pc}
 8011966:	bf00      	nop

08011968 <rtc_enter_init>:
  RTC->ISR &= ~RTC_ISR_INIT;
}

// Beginning of configuration procedure.
static bool rtc_enter_init(void){
  RTC->ISR |= RTC_ISR_INIT;
 8011968:	4a07      	ldr	r2, [pc, #28]	@ (8011988 <rtc_enter_init+0x20>)
 801196a:	4808      	ldr	r0, [pc, #32]	@ (801198c <rtc_enter_init+0x24>)
 801196c:	68d3      	ldr	r3, [r2, #12]
 801196e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8011972:	60d3      	str	r3, [r2, #12]
  uint32_t count = 4*65536;
  while (--count)
 8011974:	e001      	b.n	801197a <rtc_enter_init+0x12>
 8011976:	3801      	subs	r0, #1
 8011978:	d004      	beq.n	8011984 <rtc_enter_init+0x1c>
    if (RTC->ISR & RTC_ISR_INITF)
 801197a:	68d3      	ldr	r3, [r2, #12]
 801197c:	065b      	lsls	r3, r3, #25
 801197e:	d5fa      	bpl.n	8011976 <rtc_enter_init+0xe>
      return true;
 8011980:	2001      	movs	r0, #1
  return false;
}
 8011982:	4770      	bx	lr
 8011984:	4770      	bx	lr
 8011986:	bf00      	nop
 8011988:	40002800 	.word	0x40002800
 801198c:	0003ffff 	.word	0x0003ffff

08011990 <rtc_start_source>:
#else
#define STM32_LSE_BYPASS     0
#endif

// Startup LSE or if not work, LSI generator
static void rtc_start_source(void){
 8011990:	b510      	push	{r4, lr}
  // LSE already work (enabled and ready)
  if ((RCC->BDCR & (RCC_BDCR_LSEON|RCC_BDCR_LSERDY|STM32_LSE_BYPASS)) == (RCC_BDCR_LSEON|RCC_BDCR_LSERDY|STM32_LSE_BYPASS))
 8011992:	4c0c      	ldr	r4, [pc, #48]	@ (80119c4 <rtc_start_source+0x34>)
 8011994:	6a23      	ldr	r3, [r4, #32]
 8011996:	f003 0303 	and.w	r3, r3, #3
 801199a:	2b03      	cmp	r3, #3
 801199c:	d011      	beq.n	80119c2 <rtc_start_source+0x32>
    return;

  // If LSE not enabled, try startup
  RCC->BDCR |= STM32_LSEDRV | STM32_LSE_BYPASS | RCC_BDCR_LSEON;
 801199e:	6a23      	ldr	r3, [r4, #32]
 80119a0:	f043 0319 	orr.w	r3, r3, #25
 80119a4:	6223      	str	r3, [r4, #32]
  // Waits until LSE is stable (need ~150ms for startup).
  chThdSleepMilliseconds(200);
 80119a6:	f644 6020 	movw	r0, #20000	@ 0x4e20
 80119aa:	f7ef fa71 	bl	8000e90 <chThdSleep>
  if (RCC->BDCR & RCC_BDCR_LSERDY) return;
 80119ae:	6a23      	ldr	r3, [r4, #32]
 80119b0:	079a      	lsls	r2, r3, #30
 80119b2:	d406      	bmi.n	80119c2 <rtc_start_source+0x32>

  // Startup LSI if not allow start LSE
  RCC->CSR |= RCC_CSR_LSION;
 80119b4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80119b6:	f043 0301 	orr.w	r3, r3, #1
 80119ba:	6263      	str	r3, [r4, #36]	@ 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0);
 80119bc:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80119be:	079b      	lsls	r3, r3, #30
 80119c0:	d5fc      	bpl.n	80119bc <rtc_start_source+0x2c>
}
 80119c2:	bd10      	pop	{r4, pc}
 80119c4:	40021000 	.word	0x40021000

080119c8 <adc_init>:
  rccEnableADC12(FALSE);
 80119c8:	4921      	ldr	r1, [pc, #132]	@ (8011a50 <adc_init+0x88>)
 80119ca:	694b      	ldr	r3, [r1, #20]
  adc->CR = 0;                            // Master ADC calibration.
 80119cc:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
{
 80119d0:	b510      	push	{r4, lr}
  rccEnableADC12(FALSE);
 80119d2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
  adc->CR = 0;                            // Master ADC calibration.
 80119d6:	2400      	movs	r4, #0
  adc->CR = ADC_CR_ADVREGEN_0;
 80119d8:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
  rccEnableADC12(FALSE);
 80119dc:	614b      	str	r3, [r1, #20]
  adc->CR = 0;                            // Master ADC calibration.
 80119de:	6094      	str	r4, [r2, #8]
  adc->CR = ADC_CR_ADVREGEN_0;
 80119e0:	6090      	str	r0, [r2, #8]
  adc->CR|= ADC_CR_ADCAL;
 80119e2:	6893      	ldr	r3, [r2, #8]
 80119e4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80119e8:	6093      	str	r3, [r2, #8]
  while (adc->CR & ADC_CR_ADCAL);
 80119ea:	6893      	ldr	r3, [r2, #8]
 80119ec:	2b00      	cmp	r3, #0
 80119ee:	dbfc      	blt.n	80119ea <adc_init+0x22>
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 80119f0:	6893      	ldr	r3, [r2, #8]
 80119f2:	f043 0301 	orr.w	r3, r3, #1
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 80119f6:	f04f 41a0 	mov.w	r1, #1342177280	@ 0x50000000
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 80119fa:	6093      	str	r3, [r2, #8]
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 80119fc:	680b      	ldr	r3, [r1, #0]
 80119fe:	07da      	lsls	r2, r3, #31
 8011a00:	d5fc      	bpl.n	80119fc <adc_init+0x34>
  adc->CR = 0;                            // Master ADC calibration.
 8011a02:	4a14      	ldr	r2, [pc, #80]	@ (8011a54 <adc_init+0x8c>)
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8011a04:	4b14      	ldr	r3, [pc, #80]	@ (8011a58 <adc_init+0x90>)
  adc->SMPR1 = ADC_SMPR1_SMP_AN3(ADC_TOUCH_SMP_TIME) | ADC_SMPR1_SMP_AN4(ADC_TOUCH_SMP_TIME);
 8011a06:	f44f 44fc 	mov.w	r4, #32256	@ 0x7e00
 8011a0a:	614c      	str	r4, [r1, #20]
  adc->CR = 0;                            // Master ADC calibration.
 8011a0c:	2000      	movs	r0, #0
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8011a0e:	618b      	str	r3, [r1, #24]
  adc->CR = ADC_CR_ADVREGEN_0;
 8011a10:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
  adc->CR = 0;                            // Master ADC calibration.
 8011a14:	6090      	str	r0, [r2, #8]
  adc->CR = ADC_CR_ADVREGEN_0;
 8011a16:	6093      	str	r3, [r2, #8]
  adc->CR|= ADC_CR_ADCAL;
 8011a18:	6893      	ldr	r3, [r2, #8]
 8011a1a:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8011a1e:	6093      	str	r3, [r2, #8]
  while (adc->CR & ADC_CR_ADCAL);
 8011a20:	6893      	ldr	r3, [r2, #8]
 8011a22:	2b00      	cmp	r3, #0
 8011a24:	dbfc      	blt.n	8011a20 <adc_init+0x58>
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 8011a26:	6893      	ldr	r3, [r2, #8]
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 8011a28:	480a      	ldr	r0, [pc, #40]	@ (8011a54 <adc_init+0x8c>)
  adc->CR|= ADC_CR_ADEN;                  // Master ADC enabled here in order to reduce conversions latencies.
 8011a2a:	f043 0301 	orr.w	r3, r3, #1
 8011a2e:	6093      	str	r3, [r2, #8]
  while ((adc->ISR & ADC_ISR_ADRD) == 0); // wait ready
 8011a30:	6803      	ldr	r3, [r0, #0]
 8011a32:	07db      	lsls	r3, r3, #31
 8011a34:	d5fc      	bpl.n	8011a30 <adc_init+0x68>
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8011a36:	4b08      	ldr	r3, [pc, #32]	@ (8011a58 <adc_init+0x90>)
  adc->SMPR1 = ADC_SMPR1_SMP_AN3(ADC_TOUCH_SMP_TIME) | ADC_SMPR1_SMP_AN4(ADC_TOUCH_SMP_TIME);
 8011a38:	f44f 42fc 	mov.w	r2, #32256	@ 0x7e00
 8011a3c:	6142      	str	r2, [r0, #20]
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY); // ADC 1 and 2 interrupt
 8011a3e:	2102      	movs	r1, #2
  adc->SMPR2 = ADC_SMPR2_SMP_AN17(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN18(ADC_VBAT_SMP_TIME) | ADC_SMPR2_SMP_AN16(ADC_VBAT_SMP_TIME);
 8011a40:	6183      	str	r3, [r0, #24]
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY); // ADC 1 and 2 interrupt
 8011a42:	2012      	movs	r0, #18
 8011a44:	f7f0 f96e 	bl	8001d24 <nvicEnableVector>
  ADC1_2_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_CCR_VBAT_ENABLE | ADC_CCR_VREF_ENABLE;
 8011a48:	4b04      	ldr	r3, [pc, #16]	@ (8011a5c <adc_init+0x94>)
 8011a4a:	4a05      	ldr	r2, [pc, #20]	@ (8011a60 <adc_init+0x98>)
 8011a4c:	609a      	str	r2, [r3, #8]
}
 8011a4e:	bd10      	pop	{r4, pc}
 8011a50:	40021000 	.word	0x40021000
 8011a54:	50000100 	.word	0x50000100
 8011a58:	07fc0000 	.word	0x07fc0000
 8011a5c:	50000300 	.word	0x50000300
 8011a60:	01410000 	.word	0x01410000

08011a64 <adc_single_read>:

uint16_t adc_single_read(uint32_t chsel)
{
 8011a64:	b500      	push	{lr}
 8011a66:	4601      	mov	r1, r0
 8011a68:	b083      	sub	sp, #12
  uint16_t samples[1];
  adcStartMeasure(TOUCH_ADC, ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(chsel), samples);
 8011a6a:	4805      	ldr	r0, [pc, #20]	@ (8011a80 <adc_single_read+0x1c>)
 8011a6c:	aa01      	add	r2, sp, #4
 8011a6e:	0189      	lsls	r1, r1, #6
 8011a70:	f7ff ff46 	bl	8011900 <adcStartMeasure>
  return samples[0];
}
 8011a74:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8011a78:	b003      	add	sp, #12
 8011a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011a7e:	bf00      	nop
 8011a80:	50000100 	.word	0x50000100

08011a84 <adc_vbat_read>:
{
  static int16_t   vbat_raw = 0;
#ifdef VBAT_MEASURE_INTERVAL
  static systime_t vbat_time = -VBAT_MEASURE_INTERVAL-1;
  systime_t _time = chVTGetSystemTimeX();
  if (_time - vbat_time < VBAT_MEASURE_INTERVAL)
 8011a84:	4a20      	ldr	r2, [pc, #128]	@ (8011b08 <adc_vbat_read+0x84>)
 8011a86:	4821      	ldr	r0, [pc, #132]	@ (8011b0c <adc_vbat_read+0x88>)
 8011a88:	6813      	ldr	r3, [r2, #0]
 8011a8a:	f04f 4180 	mov.w	r1, #1073741824	@ 0x40000000
 8011a8e:	6a49      	ldr	r1, [r1, #36]	@ 0x24
 8011a90:	1acb      	subs	r3, r1, r3
 8011a92:	4283      	cmp	r3, r0
 8011a94:	d80a      	bhi.n	8011aac <adc_vbat_read+0x28>
  // vbat_raw = (3300 * 2 * vbat / 4095) * (VREFINT_CAL / vrefint)
  // uint16_t vbat_raw = (VREFINT * VREFINT_CAL * (float)vbat * 2 / (vrefint * ((1<<12)-1)));
  // For speed divide not on 4095, divide on 4096, get little error, but no matter
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
return_cached:
  if (vbat_raw < 100) {
 8011a96:	4b1e      	ldr	r3, [pc, #120]	@ (8011b10 <adc_vbat_read+0x8c>)
 8011a98:	f9b3 0000 	ldrsh.w	r0, [r3]
 8011a9c:	2863      	cmp	r0, #99	@ 0x63
 8011a9e:	dd2a      	ble.n	8011af6 <adc_vbat_read+0x72>
    // maybe D2 is not installed
    return -1;
  }
  return vbat_raw + config._vbat_offset;
 8011aa0:	4b1c      	ldr	r3, [pc, #112]	@ (8011b14 <adc_vbat_read+0x90>)
 8011aa2:	8b1b      	ldrh	r3, [r3, #24]
 8011aa4:	4418      	add	r0, r3
 8011aa6:	b280      	uxth	r0, r0
}
 8011aa8:	b200      	sxth	r0, r0
 8011aaa:	4770      	bx	lr
{
 8011aac:	b510      	push	{r4, lr}
  const uint16_t VREFINT_CAL = (*((uint16_t*)0x1FFFF7BA));
 8011aae:	4b1a      	ldr	r3, [pc, #104]	@ (8011b18 <adc_vbat_read+0x94>)
{
 8011ab0:	b082      	sub	sp, #8
  adcStartMeasure(BAT_ADC, ADC_SQR1_NUM_CH(N_CH_VBAT) | ADC_SQR1_SQ1_N(17) | ADC_SQR1_SQ2_N(18)/*| ADC_SQR1_SQ3_N(16)*/, samplesVBAT);
 8011ab2:	f04f 40a0 	mov.w	r0, #1342177280	@ 0x50000000
  vbat_time = _time;
 8011ab6:	6011      	str	r1, [r2, #0]
  adcStartMeasure(BAT_ADC, ADC_SQR1_NUM_CH(N_CH_VBAT) | ADC_SQR1_SQ1_N(17) | ADC_SQR1_SQ2_N(18)/*| ADC_SQR1_SQ3_N(16)*/, samplesVBAT);
 8011ab8:	4918      	ldr	r1, [pc, #96]	@ (8011b1c <adc_vbat_read+0x98>)
  const uint16_t VREFINT_CAL = (*((uint16_t*)0x1FFFF7BA));
 8011aba:	f8b3 40ba 	ldrh.w	r4, [r3, #186]	@ 0xba
  adcStartMeasure(BAT_ADC, ADC_SQR1_NUM_CH(N_CH_VBAT) | ADC_SQR1_SQ1_N(17) | ADC_SQR1_SQ2_N(18)/*| ADC_SQR1_SQ3_N(16)*/, samplesVBAT);
 8011abe:	aa01      	add	r2, sp, #4
 8011ac0:	f7ff ff1e 	bl	8011900 <adcStartMeasure>
  uint32_t vbat    = samplesVBAT[0];
 8011ac4:	f8bd 0004 	ldrh.w	r0, [sp, #4]
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
 8011ac8:	4b11      	ldr	r3, [pc, #68]	@ (8011b10 <adc_vbat_read+0x8c>)
  uint32_t vrefint = samplesVBAT[1];
 8011aca:	f8bd 2006 	ldrh.w	r2, [sp, #6]
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
 8011ace:	f641 11c8 	movw	r1, #6600	@ 0x19c8
 8011ad2:	fb01 f000 	mul.w	r0, r1, r0
 8011ad6:	0b00      	lsrs	r0, r0, #12
 8011ad8:	fb04 f000 	mul.w	r0, r4, r0
 8011adc:	fbb0 f0f2 	udiv	r0, r0, r2
 8011ae0:	b200      	sxth	r0, r0
  if (vbat_raw < 100) {
 8011ae2:	2863      	cmp	r0, #99	@ 0x63
  vbat_raw = ((VREFINT * 2 * vbat)>>12) * VREFINT_CAL / vrefint;
 8011ae4:	8018      	strh	r0, [r3, #0]
  if (vbat_raw < 100) {
 8011ae6:	dd0a      	ble.n	8011afe <adc_vbat_read+0x7a>
  return vbat_raw + config._vbat_offset;
 8011ae8:	4b0a      	ldr	r3, [pc, #40]	@ (8011b14 <adc_vbat_read+0x90>)
 8011aea:	8b1b      	ldrh	r3, [r3, #24]
 8011aec:	4418      	add	r0, r3
 8011aee:	b280      	uxth	r0, r0
}
 8011af0:	b200      	sxth	r0, r0
 8011af2:	b002      	add	sp, #8
 8011af4:	bd10      	pop	{r4, pc}
 8011af6:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 8011afa:	b200      	sxth	r0, r0
 8011afc:	4770      	bx	lr
 8011afe:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 8011b02:	b200      	sxth	r0, r0
 8011b04:	b002      	add	sp, #8
 8011b06:	bd10      	pop	{r4, pc}
 8011b08:	200003f4 	.word	0x200003f4
 8011b0c:	0007a11f 	.word	0x0007a11f
 8011b10:	20009a40 	.word	0x20009a40
 8011b14:	20000318 	.word	0x20000318
 8011b18:	1ffff700 	.word	0x1ffff700
 8011b1c:	00012441 	.word	0x00012441

08011b20 <adc_start_analog_watchdog>:

void adc_start_analog_watchdog(void)
{
  ADC_TypeDef *adc = TOUCH_ADC;                                 // ADC setup
  adc->ISR  = adc->ISR;                                         // reset interrupts
 8011b20:	4b0a      	ldr	r3, [pc, #40]	@ (8011b4c <adc_start_analog_watchdog+0x2c>)
  adc->IER = /*ADC_ISR_OVR |*/ ADC_IER_AWD1;                    // enable watchdog interrupt (ignore overflow)
  adc->TR1  = ADC_TR(0, TOUCH_THRESHOLD);                       // Threshold
  adc->SQR1 = ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(ADC_TOUCH_Y); // Set channel, and count
  adc->CFGR = ADC_CFGR1_RES_12BIT                               // 12 bit mode
 8011b22:	4a0b      	ldr	r2, [pc, #44]	@ (8011b50 <adc_start_analog_watchdog+0x30>)
{
 8011b24:	b410      	push	{r4}
  adc->IER = /*ADC_ISR_OVR |*/ ADC_IER_AWD1;                    // enable watchdog interrupt (ignore overflow)
 8011b26:	2180      	movs	r1, #128	@ 0x80
  adc->ISR  = adc->ISR;                                         // reset interrupts
 8011b28:	681c      	ldr	r4, [r3, #0]
 8011b2a:	601c      	str	r4, [r3, #0]
  adc->TR1  = ADC_TR(0, TOUCH_THRESHOLD);                       // Threshold
 8011b2c:	f04f 60fa 	mov.w	r0, #131072000	@ 0x7d00000
  adc->IER = /*ADC_ISR_OVR |*/ ADC_IER_AWD1;                    // enable watchdog interrupt (ignore overflow)
 8011b30:	6059      	str	r1, [r3, #4]
  adc->SQR1 = ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(ADC_TOUCH_Y); // Set channel, and count
 8011b32:	f44f 7180 	mov.w	r1, #256	@ 0x100
  adc->TR1  = ADC_TR(0, TOUCH_THRESHOLD);                       // Threshold
 8011b36:	6218      	str	r0, [r3, #32]
  adc->SQR1 = ADC_SQR1_NUM_CH(1) | ADC_SQR1_SQ1_N(ADC_TOUCH_Y); // Set channel, and count
 8011b38:	6319      	str	r1, [r3, #48]	@ 0x30
  adc->CFGR = ADC_CFGR1_RES_12BIT                               // 12 bit mode
 8011b3a:	60da      	str	r2, [r3, #12]
          | ADC_CFGR_EXTEN_0                                    // rising edge of external trigger
          | ADC_CFGR_EXTSEL_2                                   // EXT4 0x1000 event (TIM3_TRGO)
          | ADC_CFGR_AWD1EN                                     // Enable Analog watchdog check interrupt
          | ADC_CFGR_OVRMOD                                     // Overrun Mode
          ;
  adc->CR|= ADC_CR_ADSTART;                                     // Starting watchdog
 8011b3c:	689a      	ldr	r2, [r3, #8]
}
 8011b3e:	f85d 4b04 	ldr.w	r4, [sp], #4
  adc->CR|= ADC_CR_ADSTART;                                     // Starting watchdog
 8011b42:	f042 0204 	orr.w	r2, r2, #4
 8011b46:	609a      	str	r2, [r3, #8]
}
 8011b48:	4770      	bx	lr
 8011b4a:	bf00      	nop
 8011b4c:	50000100 	.word	0x50000100
 8011b50:	00801500 	.word	0x00801500

08011b54 <adc_stop_analog_watchdog>:

void adc_stop_analog_watchdog(void)
{
  ADC_TypeDef *adc = TOUCH_ADC;  // ADC setup
  if (adc->CR & ADC_CR_ADSTART) {
 8011b54:	4a05      	ldr	r2, [pc, #20]	@ (8011b6c <adc_stop_analog_watchdog+0x18>)
 8011b56:	6893      	ldr	r3, [r2, #8]
 8011b58:	0759      	lsls	r1, r3, #29
 8011b5a:	d506      	bpl.n	8011b6a <adc_stop_analog_watchdog+0x16>
    adc->CR|= ADC_CR_ADSTP;
 8011b5c:	6893      	ldr	r3, [r2, #8]
 8011b5e:	f043 0310 	orr.w	r3, r3, #16
 8011b62:	6093      	str	r3, [r2, #8]
    while (adc->CR & ADC_CR_ADSTP);
 8011b64:	6893      	ldr	r3, [r2, #8]
 8011b66:	06db      	lsls	r3, r3, #27
 8011b68:	d4fc      	bmi.n	8011b64 <adc_stop_analog_watchdog+0x10>
  }
}
 8011b6a:	4770      	bx	lr
 8011b6c:	50000100 	.word	0x50000100

08011b70 <Vector88>:

static inline void adc_interrupt(void)
{
  ADC_TypeDef *adc = TOUCH_ADC;
  uint32_t isr = adc->ISR;
 8011b70:	4a07      	ldr	r2, [pc, #28]	@ (8011b90 <Vector88+0x20>)
    handle_touch_interrupt();
  }
}

OSAL_IRQ_HANDLER(STM32_ADC2_HANDLER)
{
 8011b72:	b508      	push	{r3, lr}
  uint32_t isr = adc->ISR;
 8011b74:	6813      	ldr	r3, [r2, #0]
  adc->ISR = isr;
 8011b76:	6013      	str	r3, [r2, #0]
  if (isr & ADC_ISR_AWD1) {  // Analog watchdog error.
 8011b78:	061b      	lsls	r3, r3, #24
 8011b7a:	d403      	bmi.n	8011b84 <Vector88+0x14>
  OSAL_IRQ_PROLOGUE();

  adc_interrupt();

  OSAL_IRQ_EPILOGUE();
}
 8011b7c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8011b80:	f7ef b9d8 	b.w	8000f34 <_port_irq_epilogue>
    handle_touch_interrupt();
 8011b84:	f7fe fece 	bl	8010924 <handle_touch_interrupt>
}
 8011b88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8011b8c:	f7ef b9d2 	b.w	8000f34 <_port_irq_epilogue>
 8011b90:	50000100 	.word	0x50000100

08011b94 <i2c_set_timings>:
#define VNA_I2C                         I2C1
#define I2C_CR2_SADD_7BIT_SHIFT         1
#define I2C_CR2_NBYTES_SHIFT            16

void i2c_set_timings(uint32_t timings) {
  VNA_I2C->CR1&=~I2C_CR1_PE;
 8011b94:	4b05      	ldr	r3, [pc, #20]	@ (8011bac <i2c_set_timings+0x18>)
 8011b96:	681a      	ldr	r2, [r3, #0]
 8011b98:	f022 0201 	bic.w	r2, r2, #1
 8011b9c:	601a      	str	r2, [r3, #0]
  VNA_I2C->TIMINGR = timings;
 8011b9e:	6118      	str	r0, [r3, #16]
  VNA_I2C->CR1|= I2C_CR1_PE;
 8011ba0:	681a      	ldr	r2, [r3, #0]
 8011ba2:	f042 0201 	orr.w	r2, r2, #1
 8011ba6:	601a      	str	r2, [r3, #0]
}
 8011ba8:	4770      	bx	lr
 8011baa:	bf00      	nop
 8011bac:	40005400 	.word	0x40005400

08011bb0 <i2c_start>:

void i2c_start(void) {
  rccEnableI2C1(FALSE);
 8011bb0:	4a03      	ldr	r2, [pc, #12]	@ (8011bc0 <i2c_start+0x10>)
  i2c_set_timings(STM32_I2C_INIT_T);
 8011bb2:	4804      	ldr	r0, [pc, #16]	@ (8011bc4 <i2c_start+0x14>)
  rccEnableI2C1(FALSE);
 8011bb4:	69d3      	ldr	r3, [r2, #28]
 8011bb6:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8011bba:	61d3      	str	r3, [r2, #28]
  i2c_set_timings(STM32_I2C_INIT_T);
 8011bbc:	f7ff bfea 	b.w	8011b94 <i2c_set_timings>
 8011bc0:	40021000 	.word	0x40021000
 8011bc4:	01545064 	.word	0x01545064

08011bc8 <i2c_transfer>:
}

// I2C TX only (compact version)
bool i2c_transfer(uint8_t addr, const uint8_t *w, size_t wn)
{
 8011bc8:	b410      	push	{r4}
  //if (wn == 0) return false;
  while(VNA_I2C->ISR & I2C_ISR_BUSY); // wait last transaction
 8011bca:	4c14      	ldr	r4, [pc, #80]	@ (8011c1c <i2c_transfer+0x54>)
 8011bcc:	69a3      	ldr	r3, [r4, #24]
 8011bce:	041b      	lsls	r3, r3, #16
 8011bd0:	d4fc      	bmi.n	8011bcc <i2c_transfer+0x4>
  VNA_I2C->CR1|= I2C_CR1_PE;
 8011bd2:	6823      	ldr	r3, [r4, #0]
 8011bd4:	f043 0301 	orr.w	r3, r3, #1
 8011bd8:	6023      	str	r3, [r4, #0]
  VNA_I2C->CR2 = (addr << I2C_CR2_SADD_7BIT_SHIFT) | (wn << I2C_CR2_NBYTES_SHIFT) | I2C_CR2_AUTOEND | I2C_CR2_START;
 8011bda:	0413      	lsls	r3, r2, #16
 8011bdc:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
 8011be0:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8011be4:	468c      	mov	ip, r1
 8011be6:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
  do {
    while ((VNA_I2C->ISR & (I2C_ISR_TXE|I2C_ISR_NACKF)) == 0);
 8011bea:	490c      	ldr	r1, [pc, #48]	@ (8011c1c <i2c_transfer+0x54>)
  VNA_I2C->CR2 = (addr << I2C_CR2_SADD_7BIT_SHIFT) | (wn << I2C_CR2_NBYTES_SHIFT) | I2C_CR2_AUTOEND | I2C_CR2_START;
 8011bec:	6063      	str	r3, [r4, #4]
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
    VNA_I2C->TXDR = *w++;
  } while (--wn);
 8011bee:	4462      	add	r2, ip
    while ((VNA_I2C->ISR & (I2C_ISR_TXE|I2C_ISR_NACKF)) == 0);
 8011bf0:	698b      	ldr	r3, [r1, #24]
 8011bf2:	f013 0f11 	tst.w	r3, #17
 8011bf6:	d0fb      	beq.n	8011bf0 <i2c_transfer+0x28>
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
 8011bf8:	698b      	ldr	r3, [r1, #24]
 8011bfa:	06db      	lsls	r3, r3, #27
 8011bfc:	d408      	bmi.n	8011c10 <i2c_transfer+0x48>
    VNA_I2C->TXDR = *w++;
 8011bfe:	f81c 3b01 	ldrb.w	r3, [ip], #1
 8011c02:	628b      	str	r3, [r1, #40]	@ 0x28
  } while (--wn);
 8011c04:	4594      	cmp	ip, r2
 8011c06:	d1f3      	bne.n	8011bf0 <i2c_transfer+0x28>
  return true;
 8011c08:	2001      	movs	r0, #1
}
 8011c0a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011c0e:	4770      	bx	lr
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
 8011c10:	2000      	movs	r0, #0
}
 8011c12:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (VNA_I2C->ISR & I2C_ISR_NACKF) {VNA_I2C->CR1 = 0; return false;}  // NO ASK error
 8011c16:	6008      	str	r0, [r1, #0]
}
 8011c18:	4770      	bx	lr
 8011c1a:	bf00      	nop
 8011c1c:	40005400 	.word	0x40005400

08011c20 <rtc_get_tr_bin>:
  uint32_t tr = RTC->TR;
 8011c20:	4b07      	ldr	r3, [pc, #28]	@ (8011c40 <rtc_get_tr_bin+0x20>)
  uint32_t v = (tr&0x0F0F0F) + ((tr&0x707070)>>1) + ((tr&0x707070)>>3);
 8011c22:	4808      	ldr	r0, [pc, #32]	@ (8011c44 <rtc_get_tr_bin+0x24>)
  uint32_t tr = RTC->TR;
 8011c24:	681b      	ldr	r3, [r3, #0]
  uint32_t v = (tr&0x0F0F0F) + ((tr&0x707070)>>1) + ((tr&0x707070)>>3);
 8011c26:	4a08      	ldr	r2, [pc, #32]	@ (8011c48 <rtc_get_tr_bin+0x28>)
 8011c28:	ea00 0053 	and.w	r0, r0, r3, lsr #1
 8011c2c:	ea02 02d3 	and.w	r2, r2, r3, lsr #3
 8011c30:	f003 330f 	and.w	r3, r3, #252645135	@ 0xf0f0f0f
 8011c34:	4410      	add	r0, r2
 8011c36:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
}
 8011c3a:	4418      	add	r0, r3
 8011c3c:	4770      	bx	lr
 8011c3e:	bf00      	nop
 8011c40:	40002800 	.word	0x40002800
 8011c44:	00383838 	.word	0x00383838
 8011c48:	000e0e0e 	.word	0x000e0e0e

08011c4c <rtc_get_dr_bin>:
  uint32_t dr = RTC->DR;
 8011c4c:	4b07      	ldr	r3, [pc, #28]	@ (8011c6c <rtc_get_dr_bin+0x20>)
  uint32_t v = (dr&0x000F0F0F) + ((dr&0x00F01030)>>1) + ((dr&0x00F01030)>>3);
 8011c4e:	4808      	ldr	r0, [pc, #32]	@ (8011c70 <rtc_get_dr_bin+0x24>)
  uint32_t dr = RTC->DR;
 8011c50:	685b      	ldr	r3, [r3, #4]
  uint32_t v = (dr&0x000F0F0F) + ((dr&0x00F01030)>>1) + ((dr&0x00F01030)>>3);
 8011c52:	4a08      	ldr	r2, [pc, #32]	@ (8011c74 <rtc_get_dr_bin+0x28>)
 8011c54:	ea00 0053 	and.w	r0, r0, r3, lsr #1
 8011c58:	ea02 02d3 	and.w	r2, r2, r3, lsr #3
 8011c5c:	f003 330f 	and.w	r3, r3, #252645135	@ 0xf0f0f0f
 8011c60:	4410      	add	r0, r2
 8011c62:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
}
 8011c66:	4418      	add	r0, r3
 8011c68:	4770      	bx	lr
 8011c6a:	bf00      	nop
 8011c6c:	40002800 	.word	0x40002800
 8011c70:	00780818 	.word	0x00780818
 8011c74:	001e0206 	.word	0x001e0206

08011c78 <rtc_get_FAT>:
uint32_t rtc_get_FAT(void) {
 8011c78:	b508      	push	{r3, lr}
  uint32_t tr = rtc_get_tr_bin();
 8011c7a:	f7ff ffd1 	bl	8011c20 <rtc_get_tr_bin>
 8011c7e:	4601      	mov	r1, r0
  uint32_t dr = rtc_get_dr_bin();
 8011c80:	f7ff ffe4 	bl	8011c4c <rtc_get_dr_bin>
  fattime |= ((tr>>16)&0xFF) << 11U; // Hour
 8011c84:	ea4f 4c11 	mov.w	ip, r1, lsr #16
  fattime  = ((tr>> 0)&0xFF) >>  1U; // Seconds / 2
 8011c88:	f3c1 0246 	ubfx	r2, r1, #1, #7
  fattime |= ((dr>> 0)&0xFF) << 16U; // Day
 8011c8c:	0403      	lsls	r3, r0, #16
 8011c8e:	ea42 22cc 	orr.w	r2, r2, ip, lsl #11
 8011c92:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  fattime |= ((tr>> 8)&0xFF) <<  5U; // Minutes
 8011c96:	08c9      	lsrs	r1, r1, #3
 8011c98:	431a      	orrs	r2, r3
 8011c9a:	f401 51ff 	and.w	r1, r1, #8160	@ 0x1fe0
  fattime |= ((dr>> 8)&0xFF) << 21U; // Month
 8011c9e:	0343      	lsls	r3, r0, #13
  fattime |= ((dr>> 0)&0xFF) << 16U; // Day
 8011ca0:	4311      	orrs	r1, r2
  fattime |= ((dr>> 8)&0xFF) << 21U; // Month
 8011ca2:	f003 53ff 	and.w	r3, r3, #534773760	@ 0x1fe00000
  fattime |= (((dr>>16)&0xFF) + RTC_START_YEAR - 1980) << 25U; // Local year begin from 2000, fat from 1980
 8011ca6:	0c00      	lsrs	r0, r0, #16
  fattime |= ((dr>> 8)&0xFF) << 21U; // Month
 8011ca8:	430b      	orrs	r3, r1
  fattime |= (((dr>>16)&0xFF) + RTC_START_YEAR - 1980) << 25U; // Local year begin from 2000, fat from 1980
 8011caa:	3014      	adds	r0, #20
}
 8011cac:	ea43 6040 	orr.w	r0, r3, r0, lsl #25
 8011cb0:	bd08      	pop	{r3, pc}
 8011cb2:	bf00      	nop

08011cb4 <rtc_set_time>:
void rtc_set_time(uint32_t dr, uint32_t tr) {
 8011cb4:	b510      	push	{r4, lr}
 8011cb6:	4604      	mov	r4, r0
  if (rtc_enter_init()){
 8011cb8:	f7ff fe56 	bl	8011968 <rtc_enter_init>
 8011cbc:	b110      	cbz	r0, 8011cc4 <rtc_set_time+0x10>
    RTC->TR = tr;     // Write TR register
 8011cbe:	4b04      	ldr	r3, [pc, #16]	@ (8011cd0 <rtc_set_time+0x1c>)
 8011cc0:	6019      	str	r1, [r3, #0]
    RTC->DR = dr;     // Write TD register
 8011cc2:	605c      	str	r4, [r3, #4]
  RTC->ISR &= ~RTC_ISR_INIT;
 8011cc4:	4a02      	ldr	r2, [pc, #8]	@ (8011cd0 <rtc_set_time+0x1c>)
 8011cc6:	68d3      	ldr	r3, [r2, #12]
 8011cc8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8011ccc:	60d3      	str	r3, [r2, #12]
}
 8011cce:	bd10      	pop	{r4, pc}
 8011cd0:	40002800 	.word	0x40002800

08011cd4 <auto_backup_domain_init>:

void auto_backup_domain_init(void){
  // Init Backup domain, RTC clock source
  uint32_t rtc_drv;
  // Backup domain access enabled and left open.
  PWR->CR |= PWR_CR_DBP;
 8011cd4:	4a10      	ldr	r2, [pc, #64]	@ (8011d18 <auto_backup_domain_init+0x44>)
void auto_backup_domain_init(void){
 8011cd6:	b538      	push	{r3, r4, r5, lr}
  PWR->CR |= PWR_CR_DBP;
 8011cd8:	6813      	ldr	r3, [r2, #0]
  // Start/check source
  rtc_start_source();
  // Check LSE ready, if ok, select as source
  rtc_drv = RCC->BDCR & RCC_BDCR_LSERDY ? STM32_RTCSEL_LSE|RCC_BDCR_RTCEN :  // Select LSE as source
 8011cda:	4c10      	ldr	r4, [pc, #64]	@ (8011d1c <auto_backup_domain_init+0x48>)
  PWR->CR |= PWR_CR_DBP;
 8011cdc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8011ce0:	6013      	str	r3, [r2, #0]
  rtc_start_source();
 8011ce2:	f7ff fe55 	bl	8011990 <rtc_start_source>
  rtc_drv = RCC->BDCR & RCC_BDCR_LSERDY ? STM32_RTCSEL_LSE|RCC_BDCR_RTCEN :  // Select LSE as source
 8011ce6:	6a22      	ldr	r2, [r4, #32]
                                          STM32_RTCSEL_LSI|RCC_BDCR_RTCEN;   // Select LSI as source
  // If the backup domain hasn't been initialized yet or work on different source, then proceed with initialization
  if ((RCC->BDCR & (STM32_RTCSEL_MASK|RCC_BDCR_RTCEN)) != rtc_drv)
 8011ce8:	6a23      	ldr	r3, [r4, #32]
  rtc_drv = RCC->BDCR & RCC_BDCR_LSERDY ? STM32_RTCSEL_LSE|RCC_BDCR_RTCEN :  // Select LSE as source
 8011cea:	f012 0f02 	tst.w	r2, #2
 8011cee:	bf0c      	ite	eq
 8011cf0:	f44f 4502 	moveq.w	r5, #33280	@ 0x8200
 8011cf4:	f44f 4501 	movne.w	r5, #33024	@ 0x8100
  if ((RCC->BDCR & (STM32_RTCSEL_MASK|RCC_BDCR_RTCEN)) != rtc_drv)
 8011cf8:	f403 4303 	and.w	r3, r3, #33536	@ 0x8300
 8011cfc:	42ab      	cmp	r3, r5
 8011cfe:	d100      	bne.n	8011d02 <auto_backup_domain_init+0x2e>
  if (rtc_enter_init())
    rtc_exit_init();
  else
    resetBCDR(STM32_RTCSEL_LSI|RCC_BDCR_RTCEN);
*/
}
 8011d00:	bd38      	pop	{r3, r4, r5, pc}
  RCC->BDCR = 0;
 8011d02:	2300      	movs	r3, #0
  RCC->BDCR = RCC_BDCR_BDRST;
 8011d04:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8011d08:	6222      	str	r2, [r4, #32]
  RCC->BDCR = 0;
 8011d0a:	6223      	str	r3, [r4, #32]
  rtc_start_source();
 8011d0c:	f7ff fe40 	bl	8011990 <rtc_start_source>
  RCC->BDCR|= rtc_drv;
 8011d10:	6a23      	ldr	r3, [r4, #32]
 8011d12:	431d      	orrs	r5, r3
 8011d14:	6225      	str	r5, [r4, #32]
}
 8011d16:	bd38      	pop	{r3, r4, r5, pc}
 8011d18:	40007000 	.word	0x40007000
 8011d1c:	40021000 	.word	0x40021000

08011d20 <rtc_init>:
#endif

// Initiate RTC clock
void rtc_init(void){
 8011d20:	b508      	push	{r3, lr}
#ifdef VNA_AUTO_SELECT_RTC_SOURCE
  // Auto start LSE or LSI source for RTC
  auto_backup_domain_init();
 8011d22:	f7ff ffd7 	bl	8011cd4 <auto_backup_domain_init>
  // ChibiOS init BDCR LSE or LSI source by self from user defined in mcuconf.h source
  // For add auto select RTC source need rewrite it
  // see hal_lld_backup_domain_init() in hal_lld.c for every CPU
  // Default RTC clock is LSE, but it possible not launch if no quartz installed
#endif
  uint32_t src = RCC->BDCR & STM32_RTCSEL_MASK;
 8011d26:	4b16      	ldr	r3, [pc, #88]	@ (8011d80 <rtc_init+0x60>)
 8011d28:	6a1b      	ldr	r3, [r3, #32]
  if (src == STM32_RTCSEL_NOCLOCK) return;
 8011d2a:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 8011d2e:	d021      	beq.n	8011d74 <rtc_init+0x54>
  // If calendar has not been initialized yet or different PRER settings then proceed with the initial setup.
  // Disable write protection.
  RTC->WPR = 0xCA;
 8011d30:	4a14      	ldr	r2, [pc, #80]	@ (8011d84 <rtc_init+0x64>)
  RTC->WPR = 0x53;
  uint32_t rtc_prer = (src == STM32_RTCSEL_LSE) ? STM32_RTC_LSE_PRER :
 8011d32:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
  RTC->WPR = 0x53;
 8011d36:	f04f 0153 	mov.w	r1, #83	@ 0x53
                                                  STM32_RTC_LSI_PRER;
  // If calendar has not been initialized yet then proceed with the initial setup.
  if ((RTC->ISR & RTC_ISR_INITS) == 0 || RTC->PRER != rtc_prer) {
 8011d3a:	4b12      	ldr	r3, [pc, #72]	@ (8011d84 <rtc_init+0x64>)
  RTC->WPR = 0xCA;
 8011d3c:	f04f 00ca 	mov.w	r0, #202	@ 0xca
 8011d40:	6250      	str	r0, [r2, #36]	@ 0x24
  RTC->WPR = 0x53;
 8011d42:	6251      	str	r1, [r2, #36]	@ 0x24
  if ((RTC->ISR & RTC_ISR_INITS) == 0 || RTC->PRER != rtc_prer) {
 8011d44:	68da      	ldr	r2, [r3, #12]
  uint32_t rtc_prer = (src == STM32_RTCSEL_LSE) ? STM32_RTC_LSE_PRER :
 8011d46:	bf0c      	ite	eq
 8011d48:	490f      	ldreq	r1, [pc, #60]	@ (8011d88 <rtc_init+0x68>)
 8011d4a:	4910      	ldrne	r1, [pc, #64]	@ (8011d8c <rtc_init+0x6c>)
  if ((RTC->ISR & RTC_ISR_INITS) == 0 || RTC->PRER != rtc_prer) {
 8011d4c:	06d2      	lsls	r2, r2, #27
 8011d4e:	d502      	bpl.n	8011d56 <rtc_init+0x36>
 8011d50:	691a      	ldr	r2, [r3, #16]
 8011d52:	428a      	cmp	r2, r1
 8011d54:	d00f      	beq.n	8011d76 <rtc_init+0x56>
    if (rtc_enter_init()){
 8011d56:	f7ff fe07 	bl	8011968 <rtc_enter_init>
 8011d5a:	b130      	cbz	r0, 8011d6a <rtc_init+0x4a>
      RTC->CR   = 0
 8011d5c:	4b09      	ldr	r3, [pc, #36]	@ (8011d84 <rtc_init+0x64>)
 8011d5e:	2000      	movs	r0, #0
//              | RTC_CR_COSEL    // RTC output 1Hz (or 512Hz if disabled)
                 ;
      RTC->ISR  = RTC_ISR_INIT;     // Clearing all but RTC_ISR_INIT.
 8011d60:	2280      	movs	r2, #128	@ 0x80
      RTC->CR   = 0
 8011d62:	6098      	str	r0, [r3, #8]
      RTC->ISR  = RTC_ISR_INIT;     // Clearing all but RTC_ISR_INIT.
 8011d64:	60da      	str	r2, [r3, #12]
      RTC->PRER = rtc_prer;         // Prescaler value loaded in registers 2 times
 8011d66:	6119      	str	r1, [r3, #16]
      RTC->PRER = rtc_prer;
 8011d68:	6119      	str	r1, [r3, #16]
  RTC->ISR &= ~RTC_ISR_INIT;
 8011d6a:	4a06      	ldr	r2, [pc, #24]	@ (8011d84 <rtc_init+0x64>)
 8011d6c:	68d3      	ldr	r3, [r2, #12]
 8011d6e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8011d72:	60d3      	str	r3, [r2, #12]
    // Finalizing of configuration procedure.
    rtc_exit_init();
  }
  else
    RTC->ISR &= ~RTC_ISR_RSF;
}
 8011d74:	bd08      	pop	{r3, pc}
    RTC->ISR &= ~RTC_ISR_RSF;
 8011d76:	68da      	ldr	r2, [r3, #12]
 8011d78:	f022 0220 	bic.w	r2, r2, #32
 8011d7c:	60da      	str	r2, [r3, #12]
}
 8011d7e:	bd08      	pop	{r3, pc}
 8011d80:	40021000 	.word	0x40021000
 8011d84:	40002800 	.word	0x40002800
 8011d88:	007f00ff 	.word	0x007f00ff
 8011d8c:	002703e7 	.word	0x002703e7

08011d90 <rtc_set_cal>:

void rtc_set_cal(float ppm) {
  int32_t cal = ppm * (1<<20) / 1000000.0f + 511.5f;
  if ((RTC->ISR & RTC_ISR_RECALPF) || (uint32_t)cal > 1024)
 8011d90:	4a0c      	ldr	r2, [pc, #48]	@ (8011dc4 <rtc_set_cal+0x34>)
 8011d92:	68d3      	ldr	r3, [r2, #12]
 8011d94:	03db      	lsls	r3, r3, #15
 8011d96:	d413      	bmi.n	8011dc0 <rtc_set_cal+0x30>
  int32_t cal = ppm * (1<<20) / 1000000.0f + 511.5f;
 8011d98:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 8011dc8 <rtc_set_cal+0x38>
 8011d9c:	eddf 7a0b 	vldr	s15, [pc, #44]	@ 8011dcc <rtc_set_cal+0x3c>
 8011da0:	eee0 7a07 	vfma.f32	s15, s0, s14
 8011da4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011da8:	ee17 3a90 	vmov	r3, s15
  if ((RTC->ISR & RTC_ISR_RECALPF) || (uint32_t)cal > 1024)
 8011dac:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8011db0:	d806      	bhi.n	8011dc0 <rtc_set_cal+0x30>
    return;
  RTC->CALR = ((511 - cal) & (RTC_CALR_CALP | RTC_CALR_CALM));
 8011db2:	f5c3 73ff 	rsb	r3, r3, #510	@ 0x1fe
 8011db6:	3301      	adds	r3, #1
 8011db8:	f248 11ff 	movw	r1, #33279	@ 0x81ff
 8011dbc:	400b      	ands	r3, r1
 8011dbe:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
 8011dc0:	4770      	bx	lr
 8011dc2:	bf00      	nop
 8011dc4:	40002800 	.word	0x40002800
 8011dc8:	3f8637bd 	.word	0x3f8637bd
 8011dcc:	43ffc000 	.word	0x43ffc000

08011dd0 <rtc_get_cal>:

float rtc_get_cal(void) {
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8011dd0:	4a09      	ldr	r2, [pc, #36]	@ (8011df8 <rtc_get_cal+0x28>)
  if (RTC->CALR & RTC_CALR_CALP)
    cal += 512;
  return cal * (1000000.0f / (1<<20));
 8011dd2:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 8011dfc <rtc_get_cal+0x2c>
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8011dd6:	6bd3      	ldr	r3, [r2, #60]	@ 0x3c
  if (RTC->CALR & RTC_CALR_CALP)
 8011dd8:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8011dda:	f3c3 0308 	ubfx	r3, r3, #0, #9
  if (RTC->CALR & RTC_CALR_CALP)
 8011dde:	0412      	lsls	r2, r2, #16
  int32_t cal = -(RTC->CALR & RTC_CALR_CALM);
 8011de0:	bf54      	ite	pl
 8011de2:	425b      	negpl	r3, r3
    cal += 512;
 8011de4:	f5c3 7300 	rsbmi	r3, r3, #512	@ 0x200
 8011de8:	ee00 3a10 	vmov	s0, r3
  return cal * (1000000.0f / (1<<20));
 8011dec:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
}
 8011df0:	ee20 0a27 	vmul.f32	s0, s0, s15
 8011df4:	4770      	bx	lr
 8011df6:	bf00      	nop
 8011df8:	40002800 	.word	0x40002800
 8011dfc:	3f742400 	.word	0x3f742400

08011e00 <dac_init>:
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

void dac_init(void) {
  rccEnableDAC1(false); // Use DAC1
 8011e00:	4905      	ldr	r1, [pc, #20]	@ (8011e18 <dac_init+0x18>)
  DAC->CR|= DAC_CR_EN2; // Enable DAC1 ch2
 8011e02:	4a06      	ldr	r2, [pc, #24]	@ (8011e1c <dac_init+0x1c>)
  rccEnableDAC1(false); // Use DAC1
 8011e04:	69cb      	ldr	r3, [r1, #28]
 8011e06:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8011e0a:	61cb      	str	r3, [r1, #28]
  DAC->CR|= DAC_CR_EN2; // Enable DAC1 ch2
 8011e0c:	6813      	ldr	r3, [r2, #0]
 8011e0e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8011e12:	6013      	str	r3, [r2, #0]
}
 8011e14:	4770      	bx	lr
 8011e16:	bf00      	nop
 8011e18:	40021000 	.word	0x40021000
 8011e1c:	40007400 	.word	0x40007400

08011e20 <dac_setvalue_ch2>:

void dac_setvalue_ch1(uint16_t v) {DAC->DHR12R1 = v;}
void dac_setvalue_ch2(uint16_t v) {DAC->DHR12R2 = v;}
 8011e20:	4b01      	ldr	r3, [pc, #4]	@ (8011e28 <dac_setvalue_ch2+0x8>)
 8011e22:	6158      	str	r0, [r3, #20]
 8011e24:	4770      	bx	lr
 8011e26:	bf00      	nop
 8011e28:	40007400 	.word	0x40007400

08011e2c <initI2S>:
#define SPI_I2S_PCM_MODE       (SPI_I2SCFGR_I2SSTD_0 | SPI_I2SCFGR_I2SSTD_1)

/*
 * Run I2S bus in Circular mode, fill buffer, and handle read in I2S DMA RX interrupt
 */
void initI2S(void *buffer, uint16_t count) {
 8011e2c:	b538      	push	{r3, r4, r5, lr}
 8011e2e:	4604      	mov	r4, r0
 8011e30:	460d      	mov	r5, r1
    | STM32_DMA_CR_HTIE        // Half transfer complete interrupt enable
    | STM32_DMA_CR_TCIE        // Full transfer complete interrupt enable
//  | STM32_DMA_CR_TEIE        // Transfer error interrupt enable
    ;
  // I2S RX DMA setup.
  nvicEnableVector(STM32_SPI2_RX_DMA_IRQ_NUMBER, STM32_I2S_SPI2_IRQ_PRIORITY);
 8011e32:	200e      	movs	r0, #14
 8011e34:	2103      	movs	r1, #3
 8011e36:	f7ef ff75 	bl	8001d24 <nvicEnableVector>
  dmaChannelSetTransactionSize(I2S_DMA_RX, count);                 // number of data register
 8011e3a:	4b0c      	ldr	r3, [pc, #48]	@ (8011e6c <initI2S+0x40>)
  dmaChannelSetPeripheral(I2S_DMA_RX, &SPI2->DR);                  // peripheral address register
  dmaChannelSetMemory(I2S_DMA_RX, buffer);                         // memory address register
  dmaChannelSetMode(I2S_DMA_RX, I2S_DMA_RX_ccr | STM32_DMA_CR_EN); // configuration register

  // Starting I2S
  rccEnableSPI2(FALSE);           // Enabling I2S unit clock.
 8011e3c:	480c      	ldr	r0, [pc, #48]	@ (8011e70 <initI2S+0x44>)
  dmaChannelSetPeripheral(I2S_DMA_RX, &SPI2->DR);                  // peripheral address register
 8011e3e:	490d      	ldr	r1, [pc, #52]	@ (8011e74 <initI2S+0x48>)
  dmaChannelSetTransactionSize(I2S_DMA_RX, count);                 // number of data register
 8011e40:	649d      	str	r5, [r3, #72]	@ 0x48
  dmaChannelSetMode(I2S_DMA_RX, I2S_DMA_RX_ccr | STM32_DMA_CR_EN); // configuration register
 8011e42:	f243 52a7 	movw	r2, #13735	@ 0x35a7
  dmaChannelSetPeripheral(I2S_DMA_RX, &SPI2->DR);                  // peripheral address register
 8011e46:	64d9      	str	r1, [r3, #76]	@ 0x4c
  dmaChannelSetMemory(I2S_DMA_RX, buffer);                         // memory address register
 8011e48:	651c      	str	r4, [r3, #80]	@ 0x50
  dmaChannelSetMode(I2S_DMA_RX, I2S_DMA_RX_ccr | STM32_DMA_CR_EN); // configuration register
 8011e4a:	645a      	str	r2, [r3, #68]	@ 0x44
  rccEnableSPI2(FALSE);           // Enabling I2S unit clock.
 8011e4c:	69c2      	ldr	r2, [r0, #28]
  SPI2->CR1 = 0;                  // CRs settings
 8011e4e:	f5a3 33e4 	sub.w	r3, r3, #116736	@ 0x1c800
  rccEnableSPI2(FALSE);           // Enabling I2S unit clock.
 8011e52:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8011e56:	61c2      	str	r2, [r0, #28]
  SPI2->CR1 = 0;                  // CRs settings
 8011e58:	2100      	movs	r1, #0
  SPI2->CR2 = SPI_CR2_RXDMAEN;    // Enable RX DMA
 8011e5a:	2401      	movs	r4, #1
  SPI2->I2SPR   = 0;              // I2S (re)configuration.
  SPI2->I2SCFGR = 0
 8011e5c:	f44f 625b 	mov.w	r2, #3504	@ 0xdb0
  SPI2->CR1 = 0;                  // CRs settings
 8011e60:	6019      	str	r1, [r3, #0]
  SPI2->CR2 = SPI_CR2_RXDMAEN;    // Enable RX DMA
 8011e62:	605c      	str	r4, [r3, #4]
  SPI2->I2SPR   = 0;              // I2S (re)configuration.
 8011e64:	6219      	str	r1, [r3, #32]
  SPI2->I2SCFGR = 0
 8011e66:	61da      	str	r2, [r3, #28]
    | SPI_I2SCFGR_I2SMOD          // I2S mode is selected
    | SPI_I2S_PCM_MODE            // I2S PCM standard (aic3204 use DSP mode, short sync)
    | SPI_I2SCFGR_PCMSYNC         // Short sync
    | SPI_I2SCFGR_I2SE            // I2S enable
    ;
}
 8011e68:	bd38      	pop	{r3, r4, r5, pc}
 8011e6a:	bf00      	nop
 8011e6c:	40020000 	.word	0x40020000
 8011e70:	40021000 	.word	0x40021000
 8011e74:	4000380c 	.word	0x4000380c

08011e78 <flash_erase_pages>:
}

static inline void flash_unlock(void)
{
  // unlock sequence
  FLASH->KEYR = FLASH_KEY1;
 8011e78:	4b11      	ldr	r3, [pc, #68]	@ (8011ec0 <flash_erase_pages+0x48>)
  FLASH->KEYR = FLASH_KEY2;
 8011e7a:	4a12      	ldr	r2, [pc, #72]	@ (8011ec4 <flash_erase_pages+0x4c>)
void flash_erase_pages(uint32_t page_address, uint32_t size)
{
  // Unlock for erase
  flash_unlock();
  // erase flash pages
  size+=page_address;
 8011e7c:	4401      	add	r1, r0
{
 8011e7e:	b410      	push	{r4}
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8011e80:	4288      	cmp	r0, r1
  FLASH->KEYR = FLASH_KEY1;
 8011e82:	4c11      	ldr	r4, [pc, #68]	@ (8011ec8 <flash_erase_pages+0x50>)
 8011e84:	605c      	str	r4, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 8011e86:	605a      	str	r2, [r3, #4]
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8011e88:	d216      	bcs.n	8011eb8 <flash_erase_pages+0x40>
  while (FLASH->SR == FLASH_SR_BSY) {
 8011e8a:	68da      	ldr	r2, [r3, #12]
 8011e8c:	2a01      	cmp	r2, #1
 8011e8e:	d0fc      	beq.n	8011e8a <flash_erase_pages+0x12>
  FLASH->CR|= FLASH_CR_PER;
 8011e90:	691a      	ldr	r2, [r3, #16]
 8011e92:	f042 0202 	orr.w	r2, r2, #2
 8011e96:	611a      	str	r2, [r3, #16]
  FLASH->AR = page_address;
 8011e98:	6158      	str	r0, [r3, #20]
  FLASH->CR|= FLASH_CR_STRT;
 8011e9a:	691a      	ldr	r2, [r3, #16]
 8011e9c:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8011ea0:	611a      	str	r2, [r3, #16]
  while (FLASH->SR == FLASH_SR_BSY) {
 8011ea2:	68da      	ldr	r2, [r3, #12]
 8011ea4:	2a01      	cmp	r2, #1
 8011ea6:	d0fc      	beq.n	8011ea2 <flash_erase_pages+0x2a>
  FLASH->CR&=~FLASH_CR_PER;
 8011ea8:	691a      	ldr	r2, [r3, #16]
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8011eaa:	f500 6000 	add.w	r0, r0, #2048	@ 0x800
  FLASH->CR&=~FLASH_CR_PER;
 8011eae:	f022 0202 	bic.w	r2, r2, #2
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8011eb2:	4281      	cmp	r1, r0
  FLASH->CR&=~FLASH_CR_PER;
 8011eb4:	611a      	str	r2, [r3, #16]
  for (; page_address < size; page_address+= FLASH_PAGESIZE)
 8011eb6:	d8e8      	bhi.n	8011e8a <flash_erase_pages+0x12>
    flash_erase_page0(page_address);
}
 8011eb8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8011ebc:	4770      	bx	lr
 8011ebe:	bf00      	nop
 8011ec0:	40022000 	.word	0x40022000
 8011ec4:	cdef89ab 	.word	0xcdef89ab
 8011ec8:	45670123 	.word	0x45670123

08011ecc <flash_program_half_word_buffer>:

void flash_program_half_word_buffer(uint16_t* dst, uint16_t *data, uint16_t size)
{
 8011ecc:	b570      	push	{r4, r5, r6, lr}
 8011ece:	4616      	mov	r6, r2
 8011ed0:	460c      	mov	r4, r1
  uint32_t i;
  // unlock, and erase flash pages for buffer (aligned to FLASH_PAGESIZE)
  flash_erase_pages((uint32_t)dst, size);
 8011ed2:	4611      	mov	r1, r2
 8011ed4:	4605      	mov	r5, r0
 8011ed6:	f7ff ffcf 	bl	8011e78 <flash_erase_pages>
  // Save buffer
  __IO uint16_t* p = dst;
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8011eda:	0870      	lsrs	r0, r6, #1
 8011edc:	d018      	beq.n	8011f10 <flash_program_half_word_buffer+0x44>
  while (FLASH->SR == FLASH_SR_BSY) {
 8011ede:	4b0d      	ldr	r3, [pc, #52]	@ (8011f14 <flash_program_half_word_buffer+0x48>)
 8011ee0:	4621      	mov	r1, r4
 8011ee2:	eb04 0040 	add.w	r0, r4, r0, lsl #1
 8011ee6:	68da      	ldr	r2, [r3, #12]
 8011ee8:	2a01      	cmp	r2, #1
 8011eea:	d0fc      	beq.n	8011ee6 <flash_program_half_word_buffer+0x1a>
    flash_wait_for_last_operation();
    FLASH->CR|= FLASH_CR_PG;
 8011eec:	691a      	ldr	r2, [r3, #16]
    p[i] = data[i];
 8011eee:	f831 4b02 	ldrh.w	r4, [r1], #2
    FLASH->CR|= FLASH_CR_PG;
 8011ef2:	f042 0201 	orr.w	r2, r2, #1
 8011ef6:	611a      	str	r2, [r3, #16]
    p[i] = data[i];
 8011ef8:	802c      	strh	r4, [r5, #0]
  while (FLASH->SR == FLASH_SR_BSY) {
 8011efa:	68da      	ldr	r2, [r3, #12]
 8011efc:	2a01      	cmp	r2, #1
 8011efe:	d0fc      	beq.n	8011efa <flash_program_half_word_buffer+0x2e>
    flash_wait_for_last_operation();
    FLASH->CR&=~FLASH_CR_PG;
 8011f00:	691a      	ldr	r2, [r3, #16]
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8011f02:	4281      	cmp	r1, r0
    FLASH->CR&=~FLASH_CR_PG;
 8011f04:	f022 0201 	bic.w	r2, r2, #1
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8011f08:	f105 0502 	add.w	r5, r5, #2
    FLASH->CR&=~FLASH_CR_PG;
 8011f0c:	611a      	str	r2, [r3, #16]
  for (i = 0; i < size/sizeof(uint16_t); i++){
 8011f0e:	d1ea      	bne.n	8011ee6 <flash_program_half_word_buffer+0x1a>
  }
}
 8011f10:	bd70      	pop	{r4, r5, r6, pc}
 8011f12:	bf00      	nop
 8011f14:	40022000 	.word	0x40022000

08011f18 <initPal>:
  port->AFR[0]  = config->afrl;
  port->AFR[1]  = config->afrh;
  port->MODER   = config->moder;
}

void initPal(void) {
 8011f18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rccEnableAHB(STM32_GPIO_EN_MASK, TRUE);
 8011f1c:	4c1f      	ldr	r4, [pc, #124]	@ (8011f9c <initPal+0x84>)
  port->OSPEEDR = config->ospeedr;
 8011f1e:	4d20      	ldr	r5, [pc, #128]	@ (8011fa0 <initPal+0x88>)
  rccEnableAHB(STM32_GPIO_EN_MASK, TRUE);
 8011f20:	6963      	ldr	r3, [r4, #20]
  port->OTYPER  = config->otyper;
 8011f22:	4a20      	ldr	r2, [pc, #128]	@ (8011fa4 <initPal+0x8c>)
  port->AFR[1]  = config->afrh;
 8011f24:	f8df a090 	ldr.w	sl, [pc, #144]	@ 8011fb8 <initPal+0xa0>
  port->MODER   = config->moder;
 8011f28:	f8df 9090 	ldr.w	r9, [pc, #144]	@ 8011fbc <initPal+0xa4>
  port->PUPDR   = config->pupdr;
 8011f2c:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 8011fc0 <initPal+0xa8>
  port->AFR[0]  = config->afrl;
 8011f30:	f8df e090 	ldr.w	lr, [pc, #144]	@ 8011fc4 <initPal+0xac>
  port->AFR[1]  = config->afrh;
 8011f34:	f8df c090 	ldr.w	ip, [pc, #144]	@ 8011fc8 <initPal+0xb0>
  port->MODER   = config->moder;
 8011f38:	4f1b      	ldr	r7, [pc, #108]	@ (8011fa8 <initPal+0x90>)
  port->OTYPER  = config->otyper;
 8011f3a:	f04f 4190 	mov.w	r1, #1207959552	@ 0x48000000
 8011f3e:	2000      	movs	r0, #0
  rccEnableAHB(STM32_GPIO_EN_MASK, TRUE);
 8011f40:	f443 03fc 	orr.w	r3, r3, #8257536	@ 0x7e0000
 8011f44:	6163      	str	r3, [r4, #20]
  port->ODR     = config->odr;
 8011f46:	f64f 1bdf 	movw	fp, #63967	@ 0xf9df
  port->OTYPER  = config->otyper;
 8011f4a:	6048      	str	r0, [r1, #4]
  port->OSPEEDR = config->ospeedr;
 8011f4c:	608d      	str	r5, [r1, #8]
  port->PUPDR   = config->pupdr;
 8011f4e:	4d17      	ldr	r5, [pc, #92]	@ (8011fac <initPal+0x94>)
 8011f50:	60cd      	str	r5, [r1, #12]
  port->OTYPER  = config->otyper;
 8011f52:	4b17      	ldr	r3, [pc, #92]	@ (8011fb0 <initPal+0x98>)
  port->ODR     = config->odr;
 8011f54:	f8c1 b014 	str.w	fp, [r1, #20]
 8011f58:	f64f 74ff 	movw	r4, #65535	@ 0xffff
  port->AFR[0]  = config->afrl;
 8011f5c:	6208      	str	r0, [r1, #32]
  port->AFR[1]  = config->afrh;
 8011f5e:	f8c1 a024 	str.w	sl, [r1, #36]	@ 0x24
  port->MODER   = config->moder;
 8011f62:	f8c1 9000 	str.w	r9, [r1]
  port->OSPEEDR = config->ospeedr;
 8011f66:	f06f 010f 	mvn.w	r1, #15
  port->OTYPER  = config->otyper;
 8011f6a:	6050      	str	r0, [r2, #4]
  port->PUPDR   = config->pupdr;
 8011f6c:	4d11      	ldr	r5, [pc, #68]	@ (8011fb4 <initPal+0x9c>)
  port->OSPEEDR = config->ospeedr;
 8011f6e:	6091      	str	r1, [r2, #8]
 8011f70:	f04f 36ff 	mov.w	r6, #4294967295
  port->PUPDR   = config->pupdr;
 8011f74:	f8c2 800c 	str.w	r8, [r2, #12]
  port->ODR     = config->odr;
 8011f78:	6154      	str	r4, [r2, #20]
  port->AFR[0]  = config->afrl;
 8011f7a:	f8c2 e020 	str.w	lr, [r2, #32]
  port->AFR[1]  = config->afrh;
 8011f7e:	f8c2 c024 	str.w	ip, [r2, #36]	@ 0x24
  port->MODER   = config->moder;
 8011f82:	6017      	str	r7, [r2, #0]
 8011f84:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
  port->OTYPER  = config->otyper;
 8011f88:	6058      	str	r0, [r3, #4]
  port->OSPEEDR = config->ospeedr;
 8011f8a:	609e      	str	r6, [r3, #8]
  port->PUPDR   = config->pupdr;
 8011f8c:	60dd      	str	r5, [r3, #12]
  port->ODR     = config->odr;
 8011f8e:	615c      	str	r4, [r3, #20]
  port->AFR[0]  = config->afrl;
 8011f90:	6218      	str	r0, [r3, #32]
  port->AFR[1]  = config->afrh;
 8011f92:	6258      	str	r0, [r3, #36]	@ 0x24
  port->MODER   = config->moder;
 8011f94:	601a      	str	r2, [r3, #0]
  initgpio(GPIOA, &pal_config[0]);
  initgpio(GPIOB, &pal_config[1]);
  initgpio(GPIOC, &pal_config[2]);
//  initgpio(GPIOD, &pal_config[3]);
}
 8011f96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011f9a:	bf00      	nop
 8011f9c:	40021000 	.word	0x40021000
 8011fa0:	ffff0000 	.word	0xffff0000
 8011fa4:	48000400 	.word	0x48000400
 8011fa8:	aa5a5a9f 	.word	0xaa5a5a9f
 8011fac:	a80101aa 	.word	0xa80101aa
 8011fb0:	48000800 	.word	0x48000800
 8011fb4:	01555555 	.word	0x01555555
 8011fb8:	000ee770 	.word	0x000ee770
 8011fbc:	6aaafc00 	.word	0x6aaafc00
 8011fc0:	55555550 	.word	0x55555550
 8011fc4:	00555000 	.word	0x00555000
 8011fc8:	50550044 	.word	0x50550044

08011fcc <palSetPadMode>:
    moder <<= 2;
    bit++;
  }
}

void palSetPadMode(GPIO_TypeDef *port, int bit, uint32_t mode) {
 8011fcc:	b530      	push	{r4, r5, lr}
  uint32_t pupdr   = ((mode & PAL_STM32_PUPDR_MASK)  >> 5)<<(bit*2);
  uint32_t moder   = ((mode & PAL_STM32_MODE_MASK)   >> 0)<<(bit*2);
  uint32_t m1 = 0x1 << (bit * 1);
  uint32_t m2 = 0x3 << (bit * 2);

  port->OTYPER  = (port->OTYPER  & ~m1) | otyper;
 8011fce:	6843      	ldr	r3, [r0, #4]
  uint32_t m1 = 0x1 << (bit * 1);
 8011fd0:	2401      	movs	r4, #1
 8011fd2:	408c      	lsls	r4, r1
  port->OTYPER  = (port->OTYPER  & ~m1) | otyper;
 8011fd4:	ea23 0304 	bic.w	r3, r3, r4
  uint32_t otyper  = ((mode & PAL_STM32_OTYPE_MASK)  >> 2)<<(bit*1);
 8011fd8:	f3c2 0480 	ubfx	r4, r2, #2, #1
 8011fdc:	408c      	lsls	r4, r1
  port->OTYPER  = (port->OTYPER  & ~m1) | otyper;
 8011fde:	4323      	orrs	r3, r4
 8011fe0:	6043      	str	r3, [r0, #4]
  uint32_t ospeedr = ((mode & PAL_STM32_OSPEED_MASK) >> 3)<<(bit*2);
 8011fe2:	ea4f 0c41 	mov.w	ip, r1, lsl #1
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8011fe6:	6885      	ldr	r5, [r0, #8]
  uint32_t m2 = 0x3 << (bit * 2);
 8011fe8:	2303      	movs	r3, #3
 8011fea:	fa03 f30c 	lsl.w	r3, r3, ip
  uint32_t ospeedr = ((mode & PAL_STM32_OSPEED_MASK) >> 3)<<(bit*2);
 8011fee:	f3c2 04c1 	ubfx	r4, r2, #3, #2
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8011ff2:	ea25 0503 	bic.w	r5, r5, r3
  uint32_t ospeedr = ((mode & PAL_STM32_OSPEED_MASK) >> 3)<<(bit*2);
 8011ff6:	fa04 f40c 	lsl.w	r4, r4, ip
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8011ffa:	432c      	orrs	r4, r5
 8011ffc:	6084      	str	r4, [r0, #8]
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 8011ffe:	68c5      	ldr	r5, [r0, #12]
  uint32_t pupdr   = ((mode & PAL_STM32_PUPDR_MASK)  >> 5)<<(bit*2);
 8012000:	f3c2 1441 	ubfx	r4, r2, #5, #2
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 8012004:	ea25 0503 	bic.w	r5, r5, r3
  uint32_t pupdr   = ((mode & PAL_STM32_PUPDR_MASK)  >> 5)<<(bit*2);
 8012008:	fa04 f40c 	lsl.w	r4, r4, ip
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 801200c:	432c      	orrs	r4, r5
  uint32_t moder   = ((mode & PAL_STM32_MODE_MASK)   >> 0)<<(bit*2);
 801200e:	f002 0e03 	and.w	lr, r2, #3
  port->PUPDR   = (port->PUPDR   & ~m2) | pupdr;
 8012012:	60c4      	str	r4, [r0, #12]
#if 0
  port->MODER   = (port->MODER & ~m2) | moder;
#else
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 8012014:	f001 0407 	and.w	r4, r1, #7
  uint32_t moder   = ((mode & PAL_STM32_MODE_MASK)   >> 0)<<(bit*2);
 8012018:	fa0e fe0c 	lsl.w	lr, lr, ip
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 801201c:	00a4      	lsls	r4, r4, #2
  uint32_t m4       = 0xF << ((bit&7) * 4);
 801201e:	f04f 0c0f 	mov.w	ip, #15
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 8012022:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  if (moder == PAL_STM32_MODE_ALTERNATE) {
    // If going in alternate mode then the alternate number is set before switching mode in order to avoid glitches.
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 8012026:	f3c1 01c0 	ubfx	r1, r1, #3, #1
  uint32_t m4       = 0xF << ((bit&7) * 4);
 801202a:	fa0c fc04 	lsl.w	ip, ip, r4
  if (moder == PAL_STM32_MODE_ALTERNATE) {
 801202e:	f1be 0f02 	cmp.w	lr, #2
  port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8012032:	ea6f 0303 	mvn.w	r3, r3
  uint32_t altrmask = ((mode & PAL_STM32_ALTERNATE_MASK) >> 7) << ((bit&7) * 4);
 8012036:	fa02 f204 	lsl.w	r2, r2, r4
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 801203a:	ea6f 0c0c 	mvn.w	ip, ip
 801203e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
  if (moder == PAL_STM32_MODE_ALTERNATE) {
 8012042:	d00a      	beq.n	801205a <palSetPadMode+0x8e>
    port->MODER = (port->MODER   & ~m2) | moder;
  }
  else {
    // If going into a non-alternate mode then the mode is switched before setting the alternate mode in order to avoid glitches.
    port->MODER = (port->MODER   & ~m2) | moder;
 8012044:	6804      	ldr	r4, [r0, #0]
 8012046:	4023      	ands	r3, r4
 8012048:	ea43 030e 	orr.w	r3, r3, lr
 801204c:	6003      	str	r3, [r0, #0]
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 801204e:	6a0b      	ldr	r3, [r1, #32]
 8012050:	ea03 030c 	and.w	r3, r3, ip
 8012054:	4313      	orrs	r3, r2
 8012056:	620b      	str	r3, [r1, #32]
  }
#endif
}
 8012058:	bd30      	pop	{r4, r5, pc}
    port->AFR[(bit>>3)&1] = (port->AFR[(bit>>3)&1] & ~m4) | altrmask;
 801205a:	6a0c      	ldr	r4, [r1, #32]
 801205c:	ea04 040c 	and.w	r4, r4, ip
 8012060:	4322      	orrs	r2, r4
 8012062:	620a      	str	r2, [r1, #32]
    port->MODER = (port->MODER   & ~m2) | moder;
 8012064:	6802      	ldr	r2, [r0, #0]
 8012066:	4013      	ands	r3, r2
 8012068:	f043 0302 	orr.w	r3, r3, #2
 801206c:	6003      	str	r3, [r0, #0]
}
 801206e:	bd30      	pop	{r4, r5, pc}

08012070 <Vector78>:
}
#endif

#if defined(DMA1_CH4_HANDLER_FUNC) || defined(DMA1_USE_ALL_HANDLERS)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags = DMA1->ISR; DMA1->IFCR = flags;  // reset interrupt vector
 8012070:	4b05      	ldr	r3, [pc, #20]	@ (8012088 <Vector78+0x18>)
 8012072:	6818      	ldr	r0, [r3, #0]
 8012074:	6058      	str	r0, [r3, #4]
#ifdef DMA1_CH4_HANDLER_FUNC
  if (flags & (STM32_DMA_ISR_MASK<<12)) DMA1_CH4_HANDLER_FUNC((flags>>12)&STM32_DMA_ISR_MASK); // DMA Channel 4 handler
 8012076:	f410 4f70 	tst.w	r0, #61440	@ 0xf000
 801207a:	d100      	bne.n	801207e <Vector78+0xe>
#endif
}
 801207c:	4770      	bx	lr
  if (flags & (STM32_DMA_ISR_MASK<<12)) DMA1_CH4_HANDLER_FUNC((flags>>12)&STM32_DMA_ISR_MASK); // DMA Channel 4 handler
 801207e:	f3c0 3003 	ubfx	r0, r0, #12, #4
 8012082:	f7f4 bd17 	b.w	8006ab4 <i2s_lld_serve_rx_interrupt>
 8012086:	bf00      	nop
 8012088:	40020000 	.word	0x40020000

0801208c <Vector5C>:
}
#endif

#if defined(EXT_CH1_HANDLER_FUNC)
OSAL_IRQ_HANDLER(Vector5C) {  // EXTI[1] interrupt handler.
  uint32_t pr = EXTI->PR & (1U << 1);
 801208c:	4a04      	ldr	r2, [pc, #16]	@ (80120a0 <Vector5C+0x14>)
 801208e:	6953      	ldr	r3, [r2, #20]
 8012090:	f003 0302 	and.w	r3, r3, #2
  EXTI->PR = pr;
 8012094:	6153      	str	r3, [r2, #20]
#ifdef EXT_CH1_HANDLER_FUNC
  if (pr & (1U << 1)) EXT_CH1_HANDLER_FUNC(1);
 8012096:	b903      	cbnz	r3, 801209a <Vector5C+0xe>
#endif
}
 8012098:	4770      	bx	lr
  if (pr & (1U << 1)) EXT_CH1_HANDLER_FUNC(1);
 801209a:	2001      	movs	r0, #1
 801209c:	f7fe bc3a 	b.w	8010914 <handle_button_interrupt>
 80120a0:	40010400 	.word	0x40010400

080120a4 <Vector60>:
#endif

#if defined(EXT_CH2_HANDLER_FUNC)
OSAL_IRQ_HANDLER(Vector60) {  // EXTI[2] interrupt handler.
  uint32_t pr = EXTI->PR & (1U << 2);
 80120a4:	4a04      	ldr	r2, [pc, #16]	@ (80120b8 <Vector60+0x14>)
 80120a6:	6953      	ldr	r3, [r2, #20]
 80120a8:	f003 0304 	and.w	r3, r3, #4
  EXTI->PR = pr;
 80120ac:	6153      	str	r3, [r2, #20]
#ifdef EXT_CH2_HANDLER_FUNC
  if (pr & (1U << 2)) EXT_CH2_HANDLER_FUNC(2);
 80120ae:	b903      	cbnz	r3, 80120b2 <Vector60+0xe>
#endif
}
 80120b0:	4770      	bx	lr
  if (pr & (1U << 2)) EXT_CH2_HANDLER_FUNC(2);
 80120b2:	2002      	movs	r0, #2
 80120b4:	f7fe bc2e 	b.w	8010914 <handle_button_interrupt>
 80120b8:	40010400 	.word	0x40010400

080120bc <Vector64>:
#endif

#if defined(EXT_CH3_HANDLER_FUNC)
OSAL_IRQ_HANDLER(Vector64) {  // EXTI[3] interrupt handler.
  uint32_t pr = EXTI->PR & (1U << 3);
 80120bc:	4a04      	ldr	r2, [pc, #16]	@ (80120d0 <Vector64+0x14>)
 80120be:	6953      	ldr	r3, [r2, #20]
 80120c0:	f003 0308 	and.w	r3, r3, #8
  EXTI->PR = pr;
 80120c4:	6153      	str	r3, [r2, #20]
#ifdef EXT_CH3_HANDLER_FUNC
  if (pr & (1U << 3)) EXT_CH3_HANDLER_FUNC(3);
 80120c6:	b903      	cbnz	r3, 80120ca <Vector64+0xe>
#endif
}
 80120c8:	4770      	bx	lr
  if (pr & (1U << 3)) EXT_CH3_HANDLER_FUNC(3);
 80120ca:	2003      	movs	r0, #3
 80120cc:	f7fe bc22 	b.w	8010914 <handle_button_interrupt>
 80120d0:	40010400 	.word	0x40010400

080120d4 <extStart>:
  if (pr & (1U << 15)) EXT_CH15_HANDLER_FUNC(15);
#endif
}
#endif

void extStart(void) {
 80120d4:	b508      	push	{r3, lr}
#ifdef EXT_CH0_HANDLER_FUNC
  nvicEnableVector(EXTI0_IRQn, STM32_EXT_EXTI0_IRQ_PRIORITY);
#endif
#ifdef EXT_CH1_HANDLER_FUNC
  nvicEnableVector(EXTI1_IRQn, STM32_EXT_EXTI1_IRQ_PRIORITY);
 80120d6:	2106      	movs	r1, #6
 80120d8:	2007      	movs	r0, #7
 80120da:	f7ef fe23 	bl	8001d24 <nvicEnableVector>
#endif
#ifdef EXT_CH2_HANDLER_FUNC
  nvicEnableVector(EXTI2_TSC_IRQn, STM32_EXT_EXTI2_IRQ_PRIORITY);
 80120de:	2106      	movs	r1, #6
 80120e0:	2008      	movs	r0, #8
 80120e2:	f7ef fe1f 	bl	8001d24 <nvicEnableVector>
    defined(EXT_CH13_HANDLER_FUNC) || defined(EXT_CH14_HANDLER_FUNC) || defined(EXTI_CH15_HANDLER_FUNC)
  nvicEnableVector(EXTI15_10_IRQn, STM32_EXT_EXTI10_15_IRQ_PRIORITY);
#endif
//  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
//  nvicEnableVector(RTC_Alarm_IRQn, STM32_EXT_EXTI17_IRQ_PRIORITY);
}
 80120e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  nvicEnableVector(EXTI3_IRQn, STM32_EXT_EXTI3_IRQ_PRIORITY);
 80120ea:	2106      	movs	r1, #6
 80120ec:	2009      	movs	r0, #9
 80120ee:	f7ef be19 	b.w	8001d24 <nvicEnableVector>
 80120f2:	bf00      	nop

080120f4 <ext_channel_enable>:

void ext_channel_enable(uint16_t channel, uint16_t mode) {
  // Setting the associated GPIO for external channels.
  if (channel < 16) {
 80120f4:	280f      	cmp	r0, #15
void ext_channel_enable(uint16_t channel, uint16_t mode) {
 80120f6:	b510      	push	{r4, lr}
  if (channel < 16) {
 80120f8:	d816      	bhi.n	8012128 <ext_channel_enable+0x34>
    uint16_t port =  (mode & EXT_MODE_GPIO_MASK) >> EXT_MODE_GPIO_OFF;
    uint32_t old_reg = SYSCFG->EXTICR[channel>>2] & ~(0xF << ((channel & 3) * 4));
 80120fa:	0883      	lsrs	r3, r0, #2
 80120fc:	009b      	lsls	r3, r3, #2
 80120fe:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8012102:	f503 3380 	add.w	r3, r3, #65536	@ 0x10000
 8012106:	f000 0203 	and.w	r2, r0, #3
 801210a:	689c      	ldr	r4, [r3, #8]
 801210c:	0092      	lsls	r2, r2, #2
 801210e:	f04f 0c0f 	mov.w	ip, #15
 8012112:	fa0c fc02 	lsl.w	ip, ip, r2
 8012116:	ea24 0e0c 	bic.w	lr, r4, ip
    SYSCFG->EXTICR[channel>>2] = old_reg          |  (port<< ((channel & 3) * 4));
 801211a:	f3c1 1c03 	ubfx	ip, r1, #4, #4
 801211e:	fa0c f202 	lsl.w	r2, ip, r2
 8012122:	ea42 020e 	orr.w	r2, r2, lr
 8012126:	609a      	str	r2, [r3, #8]
  }
  uint32_t cmask = (1 << (channel & 0x1F));
  // Programming edge registers.
  if (mode & EXT_CH_MODE_RISING_EDGE)  EXTI->RTSR|= cmask;
 8012128:	4a0f      	ldr	r2, [pc, #60]	@ (8012168 <ext_channel_enable+0x74>)
  uint32_t cmask = (1 << (channel & 0x1F));
 801212a:	f000 031f 	and.w	r3, r0, #31
 801212e:	2001      	movs	r0, #1
 8012130:	4098      	lsls	r0, r3
  if (mode & EXT_CH_MODE_RISING_EDGE)  EXTI->RTSR|= cmask;
 8012132:	6893      	ldr	r3, [r2, #8]
  else                                 EXTI->RTSR&=~cmask;
 8012134:	ea6f 0c00 	mvn.w	ip, r0
  if (mode & EXT_CH_MODE_RISING_EDGE)  EXTI->RTSR|= cmask;
 8012138:	07cc      	lsls	r4, r1, #31
 801213a:	bf4c      	ite	mi
 801213c:	4303      	orrmi	r3, r0
  else                                 EXTI->RTSR&=~cmask;
 801213e:	ea03 030c 	andpl.w	r3, r3, ip
 8012142:	6093      	str	r3, [r2, #8]
  if (mode & EXT_CH_MODE_FALLING_EDGE) EXTI->FTSR|= cmask;
 8012144:	4a08      	ldr	r2, [pc, #32]	@ (8012168 <ext_channel_enable+0x74>)
 8012146:	68d3      	ldr	r3, [r2, #12]
 8012148:	0789      	lsls	r1, r1, #30
 801214a:	bf4c      	ite	mi
 801214c:	4303      	orrmi	r3, r0
  else                                 EXTI->FTSR&=~cmask;
 801214e:	ea03 030c 	andpl.w	r3, r3, ip
 8012152:	60d3      	str	r3, [r2, #12]
  // Programming interrupt and event registers.
  EXTI->IMR|= cmask;
 8012154:	4b04      	ldr	r3, [pc, #16]	@ (8012168 <ext_channel_enable+0x74>)
 8012156:	681a      	ldr	r2, [r3, #0]
 8012158:	4302      	orrs	r2, r0
 801215a:	601a      	str	r2, [r3, #0]
  EXTI->EMR&=~cmask;
 801215c:	685a      	ldr	r2, [r3, #4]
 801215e:	ea02 020c 	and.w	r2, r2, ip
 8012162:	605a      	str	r2, [r3, #4]
}
 8012164:	bd10      	pop	{r4, pc}
 8012166:	bf00      	nop
 8012168:	40010400 	.word	0x40010400

0801216c <initTimers>:
#if HAL_USE_GPT == FALSE
// Run TIM2 as us timer counter (used as STM32_ST_TIM timer in ChibiOS)
// Run TIM3 as ms timer counter
void initTimers(void) {
//  rccEnableTIM2(FALSE);
  rccEnableTIM3(FALSE);
 801216c:	4906      	ldr	r1, [pc, #24]	@ (8012188 <initTimers+0x1c>)
  // TIM2 use AHB1 bus clock (32 bit timer), use STM32_TIMCLK1 clock source
//  TIM2->PSC = STM32_TIMCLK1 / (1000000U) - 1; // 1MHz tick
  // TIM3 use AHB1 bus clock (16 bit timer), used in touch period handler
  TIM3->PSC = STM32_TIMCLK1 / (1000U) - 1;    // 1kHz tick
 801216e:	4a07      	ldr	r2, [pc, #28]	@ (801218c <initTimers+0x20>)
  rccEnableTIM3(FALSE);
 8012170:	69cb      	ldr	r3, [r1, #28]
void initTimers(void) {
 8012172:	b410      	push	{r4}
  rccEnableTIM3(FALSE);
 8012174:	f043 0302 	orr.w	r3, r3, #2
  TIM3->PSC = STM32_TIMCLK1 / (1000U) - 1;    // 1kHz tick
 8012178:	4c05      	ldr	r4, [pc, #20]	@ (8012190 <initTimers+0x24>)
  rccEnableTIM3(FALSE);
 801217a:	61cb      	str	r3, [r1, #28]
  TIM3->CR2 = 0x20;                          // Generate TRIGO event for ADC watchdog
 801217c:	2020      	movs	r0, #32
  TIM3->PSC = STM32_TIMCLK1 / (1000U) - 1;    // 1kHz tick
 801217e:	6294      	str	r4, [r2, #40]	@ 0x28
}
 8012180:	f85d 4b04 	ldr.w	r4, [sp], #4
  TIM3->CR2 = 0x20;                          // Generate TRIGO event for ADC watchdog
 8012184:	6050      	str	r0, [r2, #4]
}
 8012186:	4770      	bx	lr
 8012188:	40021000 	.word	0x40021000
 801218c:	40000400 	.word	0x40000400
 8012190:	0001193f 	.word	0x0001193f

08012194 <startTimer>:

//
void startTimer(TIM_TypeDef *timer, uint32_t period) {
 8012194:	b410      	push	{r4}
  timer->ARR = period - 1;
 8012196:	3901      	subs	r1, #1
  timer->EGR = STM32_TIM_EGR_UG;
 8012198:	2401      	movs	r4, #1
  timer->CNT = 0;
 801219a:	2200      	movs	r2, #0
  timer->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 801219c:	2305      	movs	r3, #5
  timer->ARR = period - 1;
 801219e:	62c1      	str	r1, [r0, #44]	@ 0x2c
  timer->EGR = STM32_TIM_EGR_UG;
 80121a0:	6144      	str	r4, [r0, #20]
  timer->CNT = 0;
 80121a2:	6242      	str	r2, [r0, #36]	@ 0x24
}
 80121a4:	f85d 4b04 	ldr.w	r4, [sp], #4
  timer->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80121a8:	6003      	str	r3, [r0, #0]
}
 80121aa:	4770      	bx	lr

080121ac <vna_sincosf>:
__attribute__((always_inline)) __STATIC_INLINE float vna_fabsf(float x){__asm__ ("vabs.f32 %0, %1" : "=t"(x) : "t"(x)); return x;}
 80121ac:	eef0 7ac0 	vabs.f32	s15, s0
  float f1, f2, d1, d2;     // Two nearest output values
  float fract, temp;

  // Round angle to range 0.0 to 1.0
  temp = vna_fabsf(angle);
  temp-= (uint32_t)temp;
 80121b0:	eebc 7ae7 	vcvt.u32.f32	s14, s15

  // Scale input from range 0.0 to 1.0 to table size
  temp*= FAST_MATH_TABLE_SIZE;
 80121b4:	eddf 6a44 	vldr	s13, [pc, #272]	@ 80122c8 <vna_sincosf+0x11c>
  temp-= (uint32_t)temp;
 80121b8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
{
 80121bc:	b510      	push	{r4, lr}
  temp-= (uint32_t)temp;
 80121be:	ee77 7ac7 	vsub.f32	s15, s15, s14
  temp*= FAST_MATH_TABLE_SIZE;
 80121c2:	ee67 7aa6 	vmul.f32	s15, s15, s13

  indexS = temp;
 80121c6:	eebc 7ae7 	vcvt.u32.f32	s14, s15
 80121ca:	ee17 3a10 	vmov	r3, s14
 80121ce:	b29b      	uxth	r3, r3
  indexC = indexS + (FAST_MATH_TABLE_SIZE / 4); // cosine add 0.25 (pi/2) to read from sine table
  // Calculation of fractional value
  fract  = temp - indexS;
 80121d0:	ee07 3a10 	vmov	s14, r3
  indexC = indexS + (FAST_MATH_TABLE_SIZE / 4); // cosine add 0.25 (pi/2) to read from sine table
 80121d4:	f103 0280 	add.w	r2, r3, #128	@ 0x80
  fract  = temp - indexS;
 80121d8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
  f1 = GET_SIN_TABLE(indexC  );
  f2 = GET_SIN_TABLE(indexC+1);
  d1 = GET_SIN_TABLE(indexS  );
  d2 = GET_SIN_TABLE(indexS+1);
#else
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 80121dc:	f412 7f80 	tst.w	r2, #256	@ 0x100
 80121e0:	f3c2 0c08 	ubfx	ip, r2, #0, #9
  fract  = temp - indexS;
 80121e4:	ee77 7ac7 	vsub.f32	s15, s15, s14
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 80121e8:	4a38      	ldr	r2, [pc, #224]	@ (80122cc <vna_sincosf+0x120>)
  indexS&= (FAST_MATH_TABLE_SIZE-1);
 80121ea:	f3c3 0e08 	ubfx	lr, r3, #0, #9
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 80121ee:	d148      	bne.n	8012282 <vna_sincosf+0xd6>
 80121f0:	eb02 048c 	add.w	r4, r2, ip, lsl #2
  else             {f1 =-sin_table_512[indexC-256+0];f2 =-sin_table_512[indexC-256+1];}
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 80121f4:	05db      	lsls	r3, r3, #23
  if (indexC < 256){f1 = sin_table_512[indexC    +0];f2 = sin_table_512[indexC    +1];}
 80121f6:	ed94 6a00 	vldr	s12, [r4]
 80121fa:	edd4 4a01 	vldr	s9, [r4, #4]
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 80121fe:	d452      	bmi.n	80122a6 <vna_sincosf+0xfa>
 8012200:	eb02 038e 	add.w	r3, r2, lr, lsl #2
 8012204:	edd3 5a00 	vldr	s11, [r3]
 8012208:	ed93 4a01 	vldr	s8, [r3, #4]
 801220c:	469e      	mov	lr, r3
#if 1
  // 1e-7 error on 512 size table
  const float Dn = 2 * VNA_PI / FAST_MATH_TABLE_SIZE; // delta between the two points in table (fixed);
  float Df;
  // Calculation of cos value
  Df = f2 - f1; // delta between the values of the functions
 801220e:	ee74 6ac6 	vsub.f32	s13, s9, s12
  temp = Dn * (d1 + d2) + 2 * Df;
  temp = Df + (d1 * Dn + temp - fract * temp);
  temp = fract * temp - d1 * Dn;
  *pCosVal = f1 + fract * temp;
  // Calculation of sin value
  Df = d1 - d2; // delta between the values of the functions
 8012212:	ee35 7ac4 	vsub.f32	s14, s11, s8
  temp = Dn * (d1 + d2) + 2 * Df;
 8012216:	ed9f 5a2e 	vldr	s10, [pc, #184]	@ 80122d0 <vna_sincosf+0x124>
 801221a:	ee35 4a84 	vadd.f32	s8, s11, s8
 801221e:	ee36 3aa6 	vadd.f32	s6, s13, s13
  temp = Dn * (f1 + f2) + 2 * Df;
 8012222:	ee77 3a07 	vadd.f32	s7, s14, s14
 8012226:	ee76 4a24 	vadd.f32	s9, s12, s9
  temp = Dn * (d1 + d2) + 2 * Df;
 801222a:	eea4 3a05 	vfma.f32	s6, s8, s10
  temp = Dn * (f1 + f2) + 2 * Df;
 801222e:	eeb0 4a63 	vmov.f32	s8, s7
 8012232:	eea4 4a85 	vfma.f32	s8, s9, s10
 8012236:	eea6 7a05 	vfma.f32	s14, s12, s10
 801223a:	eee5 6a85 	vfma.f32	s13, s11, s10
 801223e:	ee34 7a07 	vadd.f32	s14, s8, s14
 8012242:	ee73 6a26 	vadd.f32	s13, s6, s13
  temp = Df + (f1 * Dn + temp - fract * temp);
 8012246:	eea7 7ac4 	vfms.f32	s14, s15, s8
  temp = Df + (d1 * Dn + temp - fract * temp);
 801224a:	eee7 6ac3 	vfms.f32	s13, s15, s6
  temp = fract * temp - f1 * Dn;
 801224e:	ee27 7a87 	vmul.f32	s14, s15, s14
  temp = fract * temp - d1 * Dn;
 8012252:	ee67 6aa6 	vmul.f32	s13, s15, s13
  temp = fract * temp - f1 * Dn;
 8012256:	eea6 7a45 	vfms.f32	s14, s12, s10
  temp = fract * temp - d1 * Dn;
 801225a:	eee5 6ac5 	vfms.f32	s13, s11, s10
  // 1e-5 error  on 512 size table
  // Calculation of sin and cos value, use simple linear interpolation
  *pCosVal = fract * (f2 - f1) + f1;
  *pSinVal = fract * (d2 - d1) + d1;
#endif
  if (angle < 0)
 801225e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
  *pCosVal = f1 + fract * temp;
 8012262:	eea7 6aa6 	vfma.f32	s12, s15, s13
  *pSinVal = d1 - fract * temp;
 8012266:	ee67 7a87 	vmul.f32	s15, s15, s14
  if (angle < 0)
 801226a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  *pSinVal = d1 - fract * temp;
 801226e:	bf54      	ite	pl
 8012270:	ee75 7ae7 	vsubpl.f32	s15, s11, s15
    *pSinVal = -*pSinVal;
 8012274:	ee77 7ae5 	vsubmi.f32	s15, s15, s11
  *pCosVal = f1 + fract * temp;
 8012278:	ed81 6a00 	vstr	s12, [r1]
  *pSinVal = d1 - fract * temp;
 801227c:	edc0 7a00 	vstr	s15, [r0]
#endif
}
 8012280:	bd10      	pop	{r4, pc}
  else             {f1 =-sin_table_512[indexC-256+0];f2 =-sin_table_512[indexC-256+1];}
 8012282:	f5ac 7480 	sub.w	r4, ip, #256	@ 0x100
 8012286:	f1ac 0cff 	sub.w	ip, ip, #255	@ 0xff
 801228a:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 801228e:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
 8012292:	ed94 6a00 	vldr	s12, [r4]
 8012296:	eddc 4a00 	vldr	s9, [ip]
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 801229a:	05db      	lsls	r3, r3, #23
  else             {f1 =-sin_table_512[indexC-256+0];f2 =-sin_table_512[indexC-256+1];}
 801229c:	eeb1 6a46 	vneg.f32	s12, s12
 80122a0:	eef1 4a64 	vneg.f32	s9, s9
  if (indexS < 256){d1 = sin_table_512[indexS    +0];d2 = sin_table_512[indexS    +1];}
 80122a4:	d5ac      	bpl.n	8012200 <vna_sincosf+0x54>
  else             {d1 =-sin_table_512[indexS-256+0];d2 =-sin_table_512[indexS-256+1];}
 80122a6:	f5ae 7380 	sub.w	r3, lr, #256	@ 0x100
 80122aa:	f1ae 0eff 	sub.w	lr, lr, #255	@ 0xff
 80122ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80122b2:	eb02 028e 	add.w	r2, r2, lr, lsl #2
 80122b6:	edd3 5a00 	vldr	s11, [r3]
 80122ba:	ed92 4a00 	vldr	s8, [r2]
 80122be:	eef1 5a65 	vneg.f32	s11, s11
 80122c2:	eeb1 4a44 	vneg.f32	s8, s8
 80122c6:	e7a2      	b.n	801220e <vna_sincosf+0x62>
 80122c8:	44000000 	.word	0x44000000
 80122cc:	0801ba00 	.word	0x0801ba00
 80122d0:	3c490fdb 	.word	0x3c490fdb

080122d4 <vna_logf>:

//**********************************************************************************
// logf
//**********************************************************************************
float vna_logf(float x)
{
 80122d4:	ee10 3a10 	vmov	r3, s0
  // Give up to 0.00005 error (2x faster original code)
  // fast log2f approximation, give 0.0002 error
  union { float f; uint32_t i; } vx = { x };
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
  // if <=0 return NAN
  if (vx.i <=0) return -1/(x*x);
 80122d8:	1e1a      	subs	r2, r3, #0
 80122da:	d01e      	beq.n	801231a <vna_logf+0x46>
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
 80122dc:	f3c2 0316 	ubfx	r3, r2, #0, #23
  return vx.i * (MULTIPLIER / (1 << 23)) - (124.22544637f * MULTIPLIER) - (1.498030302f * MULTIPLIER) * mx.f - (1.72587999f * MULTIPLIER) / (0.3520887068f + mx.f);
 80122e0:	f043 537c 	orr.w	r3, r3, #1056964608	@ 0x3f000000
 80122e4:	ee07 3a10 	vmov	s14, r3
 80122e8:	eddf 6a0f 	vldr	s13, [pc, #60]	@ 8012328 <vna_logf+0x54>
 80122ec:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 801232c <vna_logf+0x58>
 80122f0:	ed9f 0a0f 	vldr	s0, [pc, #60]	@ 8012330 <vna_logf+0x5c>
 80122f4:	ee77 6a26 	vadd.f32	s13, s14, s13
 80122f8:	ee07 2a90 	vmov	s15, r2
 80122fc:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 8012300:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012304:	eddf 5a0b 	vldr	s11, [pc, #44]	@ 8012334 <vna_logf+0x60>
 8012308:	eddf 6a0b 	vldr	s13, [pc, #44]	@ 8012338 <vna_logf+0x64>
 801230c:	eea7 0aa5 	vfma.f32	s0, s15, s11
 8012310:	ee30 0a46 	vsub.f32	s0, s0, s12
 8012314:	eea7 0a66 	vfms.f32	s0, s14, s13
  R = t2 + t1;
  hfsq = 0.5f * f * f;
  dk = k;
  return s*(hfsq+R) + dk*ln2_lo - hfsq + f + dk*ln2_hi;
#endif
}
 8012318:	4770      	bx	lr
  if (vx.i <=0) return -1/(x*x);
 801231a:	ee60 7a00 	vmul.f32	s15, s0, s0
 801231e:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8012322:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8012326:	4770      	bx	lr
 8012328:	3eb444f9 	.word	0x3eb444f9
 801232c:	3f991ffe 	.word	0x3f991ffe
 8012330:	c2ac368a 	.word	0xc2ac368a
 8012334:	33b17218 	.word	0x33b17218
 8012338:	3f84e8d5 	.word	0x3f84e8d5

0801233c <vna_log10f_x_10>:

float vna_log10f_x_10(float x)
{
 801233c:	ee10 3a10 	vmov	r3, s0
  // Give up to 0.0001 error (2x faster original code)
  // fast log2f approximation, give 0.0004 error
  union { float f; uint32_t i; } vx = { x };
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
  // if <=0 return NAN
  if (vx.i <=0) return -1/(x*x);
 8012340:	1e1a      	subs	r2, r3, #0
 8012342:	d01e      	beq.n	8012382 <vna_log10f_x_10+0x46>
  union { uint32_t i; float f; } mx = { (vx.i & 0x007FFFFF) | 0x3f000000 };
 8012344:	f3c2 0316 	ubfx	r3, r2, #0, #23
  return vx.i * (MULTIPLIER / (1 << 23)) - (124.22544637f * MULTIPLIER) - (1.498030302f * MULTIPLIER) * mx.f - (1.72587999f * MULTIPLIER) / (0.3520887068f + mx.f);
 8012348:	f043 537c 	orr.w	r3, r3, #1056964608	@ 0x3f000000
 801234c:	ee07 3a10 	vmov	s14, r3
 8012350:	eddf 6a0f 	vldr	s13, [pc, #60]	@ 8012390 <vna_log10f_x_10+0x54>
 8012354:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 8012394 <vna_log10f_x_10+0x58>
 8012358:	ed9f 0a0f 	vldr	s0, [pc, #60]	@ 8012398 <vna_log10f_x_10+0x5c>
 801235c:	ee77 6a26 	vadd.f32	s13, s14, s13
 8012360:	ee07 2a90 	vmov	s15, r2
 8012364:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 8012368:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801236c:	eddf 5a0b 	vldr	s11, [pc, #44]	@ 801239c <vna_log10f_x_10+0x60>
 8012370:	eddf 6a0b 	vldr	s13, [pc, #44]	@ 80123a0 <vna_log10f_x_10+0x64>
 8012374:	eea7 0aa5 	vfma.f32	s0, s15, s11
 8012378:	ee30 0a46 	vsub.f32	s0, s0, s12
 801237c:	eea7 0a66 	vfms.f32	s0, s14, s13
#endif
}
 8012380:	4770      	bx	lr
  if (vx.i <=0) return -1/(x*x);
 8012382:	ee60 7a00 	vmul.f32	s15, s0, s0
 8012386:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 801238a:	ee87 0a27 	vdiv.f32	s0, s14, s15
 801238e:	4770      	bx	lr
 8012390:	3eb444f9 	.word	0x3eb444f9
 8012394:	40a640da 	.word	0x40a640da
 8012398:	c3bafa5a 	.word	0xc3bafa5a
 801239c:	34c0a8c1 	.word	0x34c0a8c1
 80123a0:	40904dfe 	.word	0x40904dfe

080123a4 <vna_atan2f>:
#else
// Polynomial approximation to atan2f
float vna_atan2f(float y, float x)
{
  union {float f; int32_t i;} ux = {x};
  union {float f; int32_t i;} uy = {y};
 80123a4:	ee10 3a10 	vmov	r3, s0
  union {float f; int32_t i;} ux = {x};
 80123a8:	ee10 2a90 	vmov	r2, s1
  if (ux.i == 0 && uy.i == 0)
 80123ac:	ea53 0102 	orrs.w	r1, r3, r2
 80123b0:	d042      	beq.n	8012438 <vna_atan2f+0x94>
 80123b2:	eef0 0ae0 	vabs.f32	s1, s1
 80123b6:	eeb0 0ac0 	vabs.f32	s0, s0
    return 0.0f;

  float ax, ay, r, s;
  ax = vna_fabsf(x);
  ay = vna_fabsf(y);
  r = (ay < ax) ? ay / ax : ax / ay;
 80123ba:	eef4 0ac0 	vcmpe.f32	s1, s0
 80123be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80123c2:	dc21      	bgt.n	8012408 <vna_atan2f+0x64>
 80123c4:	eec0 7a80 	vdiv.f32	s15, s1, s0
  r*= 0.994949366116654f - s * (0.287060635532652f - 0.078037176446441f * s);
  //r*= vna_fmaf(-s, vna_fmaf(-s, 0.078037176446441f, 0.287060635532652f), 0.994949366116654f);
  //r*= 0.995354f  s * (0.288679f + 0.079331f * s);
#else
  // give 0.005 degree error
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 80123c8:	eddf 5a1d 	vldr	s11, [pc, #116]	@ 8012440 <vna_atan2f+0x9c>
 80123cc:	ed9f 6a1d 	vldr	s12, [pc, #116]	@ 8012444 <vna_atan2f+0xa0>
 80123d0:	eddf 6a1d 	vldr	s13, [pc, #116]	@ 8012448 <vna_atan2f+0xa4>
 80123d4:	ed9f 0a1d 	vldr	s0, [pc, #116]	@ 801244c <vna_atan2f+0xa8>
  s = r * r;
 80123d8:	ee27 7aa7 	vmul.f32	s14, s15, s15
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 80123dc:	eea7 6a65 	vfms.f32	s12, s14, s11
 80123e0:	eee6 6a07 	vfma.f32	s13, s12, s14
 80123e4:	eea6 0a87 	vfma.f32	s0, s13, s14
 80123e8:	ee20 0a27 	vmul.f32	s0, s0, s15
  //r*= vna_fmaf(-s, vna_fmaf(-s, vna_fmaf(-s, 0.038254464970299f, 0.144982490144465f), 0.320533292381664f), 0.999133448222780f);
#endif
  // Map to full circle
  if (ay  > ax) r = VNA_PI/2.0f - r;
 80123ec:	bf44      	itt	mi
 80123ee:	eddf 7a18 	vldrmi	s15, [pc, #96]	@ 8012450 <vna_atan2f+0xac>
 80123f2:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
  if (ux.i < 0) r = VNA_PI      - r;
 80123f6:	2a00      	cmp	r2, #0
 80123f8:	bfbc      	itt	lt
 80123fa:	eddf 7a16 	vldrlt	s15, [pc, #88]	@ 8012454 <vna_atan2f+0xb0>
 80123fe:	ee37 0ac0 	vsublt.f32	s0, s15, s0
  if (uy.i < 0) r = -r;
 8012402:	2b00      	cmp	r3, #0
 8012404:	db15      	blt.n	8012432 <vna_atan2f+0x8e>
  return r;
}
 8012406:	4770      	bx	lr
  r = (ay < ax) ? ay / ax : ax / ay;
 8012408:	eec0 7a20 	vdiv.f32	s15, s0, s1
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 801240c:	ed9f 5a0c 	vldr	s10, [pc, #48]	@ 8012440 <vna_atan2f+0x9c>
 8012410:	eddf 5a0c 	vldr	s11, [pc, #48]	@ 8012444 <vna_atan2f+0xa0>
 8012414:	ed9f 6a0c 	vldr	s12, [pc, #48]	@ 8012448 <vna_atan2f+0xa4>
 8012418:	ed9f 7a0c 	vldr	s14, [pc, #48]	@ 801244c <vna_atan2f+0xa8>
  s = r * r;
 801241c:	ee67 6aa7 	vmul.f32	s13, s15, s15
  r*= 0.999133448222780f - s * (0.320533292381664f - s * (0.144982490144465f - s * 0.038254464970299f));
 8012420:	eee6 5ac5 	vfms.f32	s11, s13, s10
 8012424:	eea5 6aa6 	vfma.f32	s12, s11, s13
 8012428:	eea6 7a26 	vfma.f32	s14, s12, s13
 801242c:	ee27 0a87 	vmul.f32	s0, s15, s14
  if (ay  > ax) r = VNA_PI/2.0f - r;
 8012430:	e7e1      	b.n	80123f6 <vna_atan2f+0x52>
  if (uy.i < 0) r = -r;
 8012432:	eeb1 0a40 	vneg.f32	s0, s0
 8012436:	4770      	bx	lr
    return 0.0f;
 8012438:	ed9f 0a07 	vldr	s0, [pc, #28]	@ 8012458 <vna_atan2f+0xb4>
}
 801243c:	4770      	bx	lr
 801243e:	bf00      	nop
 8012440:	3d1cb0b7 	.word	0x3d1cb0b7
 8012444:	3e14764a 	.word	0x3e14764a
 8012448:	bea41cf1 	.word	0xbea41cf1
 801244c:	3f7fc736 	.word	0x3f7fc736
 8012450:	3fc90fdb 	.word	0x3fc90fdb
 8012454:	40490fdb 	.word	0x40490fdb
 8012458:	00000000 	.word	0x00000000

0801245c <vna_expf>:
// Fast expf approximation
//**********************************************************************************
float vna_expf(float x)
{
  union { float f; int32_t i; } v;
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 801245c:	eddf 7a12 	vldr	s15, [pc, #72]	@ 80124a8 <vna_expf+0x4c>
 8012460:	ee20 0a27 	vmul.f32	s0, s0, s15
  int32_t m = (v.i >> 7) & 0xFFFF;  // copy mantissa
#if 1
  // cubic spline approximation, empirical values for small maximum relative error (8.34e-5):
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 8012464:	f240 40fd 	movw	r0, #1277	@ 0x4fd
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 8012468:	eefd 7ac0 	vcvt.s32.f32	s15, s0
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 801246c:	f643 13e9 	movw	r3, #14825	@ 0x39e9
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 8012470:	ee17 2a90 	vmov	r2, s15
  int32_t m = (v.i >> 7) & 0xFFFF;  // copy mantissa
 8012474:	f3c2 11cf 	ubfx	r1, r2, #7, #16
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 8012478:	fb01 f000 	mul.w	r0, r1, r0
 801247c:	eb03 33a0 	add.w	r3, r3, r0, asr #14
 8012480:	fb01 f303 	mul.w	r3, r1, r3
 8012484:	139b      	asrs	r3, r3, #14
 8012486:	f46f 70c2 	mvn.w	r0, #388	@ 0x184
 801248a:	f5a3 339b 	sub.w	r3, r3, #79360	@ 0x13600
 801248e:	4403      	add	r3, r0
 8012490:	fb01 f303 	mul.w	r3, r1, r3
 8012494:	12db      	asrs	r3, r3, #11
  v.i = (int32_t)(12102203.0f*x) + 0x3F800000;
 8012496:	f102 527e 	add.w	r2, r2, #1065353216	@ 0x3f800000
  v.i += ((((((((1277*m) >> 14) + 14825)*m) >> 14) - 79749)*m) >> 11) - 626;
 801249a:	f2a3 2372 	subw	r3, r3, #626	@ 0x272
#else
  // quartic spline approximation, empirical values for small maximum relative error (1.21e-5):
  v.i += (((((((((((3537*m) >> 16) + 13668)*m) >> 18) + 15817)*m) >> 14) - 80470)*m) >> 11);
#endif
  return v.f;
 801249e:	4413      	add	r3, r2
 80124a0:	ee00 3a10 	vmov	s0, r3
}
 80124a4:	4770      	bx	lr
 80124a6:	bf00      	nop
 80124a8:	4b38aa3b 	.word	0x4b38aa3b

080124ac <infinityf>:
 80124ac:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 80124b4 <infinityf+0x8>
 80124b0:	4770      	bx	lr
 80124b2:	bf00      	nop
 80124b4:	7f800000 	.word	0x7f800000

080124b8 <__udivmoddi4>:
 80124b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80124bc:	9d08      	ldr	r5, [sp, #32]
 80124be:	460f      	mov	r7, r1
 80124c0:	4604      	mov	r4, r0
 80124c2:	468c      	mov	ip, r1
 80124c4:	2b00      	cmp	r3, #0
 80124c6:	d148      	bne.n	801255a <__udivmoddi4+0xa2>
 80124c8:	428a      	cmp	r2, r1
 80124ca:	4616      	mov	r6, r2
 80124cc:	d961      	bls.n	8012592 <__udivmoddi4+0xda>
 80124ce:	fab2 f382 	clz	r3, r2
 80124d2:	b14b      	cbz	r3, 80124e8 <__udivmoddi4+0x30>
 80124d4:	f1c3 0220 	rsb	r2, r3, #32
 80124d8:	fa01 fc03 	lsl.w	ip, r1, r3
 80124dc:	fa20 f202 	lsr.w	r2, r0, r2
 80124e0:	409e      	lsls	r6, r3
 80124e2:	ea42 0c0c 	orr.w	ip, r2, ip
 80124e6:	409c      	lsls	r4, r3
 80124e8:	ea4f 4e16 	mov.w	lr, r6, lsr #16
 80124ec:	b2b7      	uxth	r7, r6
 80124ee:	fbbc f1fe 	udiv	r1, ip, lr
 80124f2:	0c22      	lsrs	r2, r4, #16
 80124f4:	fb0e cc11 	mls	ip, lr, r1, ip
 80124f8:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 80124fc:	fb01 f007 	mul.w	r0, r1, r7
 8012500:	4290      	cmp	r0, r2
 8012502:	d909      	bls.n	8012518 <__udivmoddi4+0x60>
 8012504:	18b2      	adds	r2, r6, r2
 8012506:	f101 3cff 	add.w	ip, r1, #4294967295
 801250a:	f080 80ee 	bcs.w	80126ea <__udivmoddi4+0x232>
 801250e:	4290      	cmp	r0, r2
 8012510:	f240 80eb 	bls.w	80126ea <__udivmoddi4+0x232>
 8012514:	3902      	subs	r1, #2
 8012516:	4432      	add	r2, r6
 8012518:	1a12      	subs	r2, r2, r0
 801251a:	b2a4      	uxth	r4, r4
 801251c:	fbb2 f0fe 	udiv	r0, r2, lr
 8012520:	fb0e 2210 	mls	r2, lr, r0, r2
 8012524:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8012528:	fb00 f707 	mul.w	r7, r0, r7
 801252c:	42a7      	cmp	r7, r4
 801252e:	d909      	bls.n	8012544 <__udivmoddi4+0x8c>
 8012530:	1934      	adds	r4, r6, r4
 8012532:	f100 32ff 	add.w	r2, r0, #4294967295
 8012536:	f080 80da 	bcs.w	80126ee <__udivmoddi4+0x236>
 801253a:	42a7      	cmp	r7, r4
 801253c:	f240 80d7 	bls.w	80126ee <__udivmoddi4+0x236>
 8012540:	4434      	add	r4, r6
 8012542:	3802      	subs	r0, #2
 8012544:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8012548:	1be4      	subs	r4, r4, r7
 801254a:	2100      	movs	r1, #0
 801254c:	b11d      	cbz	r5, 8012556 <__udivmoddi4+0x9e>
 801254e:	40dc      	lsrs	r4, r3
 8012550:	2300      	movs	r3, #0
 8012552:	e9c5 4300 	strd	r4, r3, [r5]
 8012556:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801255a:	428b      	cmp	r3, r1
 801255c:	d906      	bls.n	801256c <__udivmoddi4+0xb4>
 801255e:	b10d      	cbz	r5, 8012564 <__udivmoddi4+0xac>
 8012560:	e9c5 0100 	strd	r0, r1, [r5]
 8012564:	2100      	movs	r1, #0
 8012566:	4608      	mov	r0, r1
 8012568:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801256c:	fab3 f183 	clz	r1, r3
 8012570:	2900      	cmp	r1, #0
 8012572:	d148      	bne.n	8012606 <__udivmoddi4+0x14e>
 8012574:	42bb      	cmp	r3, r7
 8012576:	d302      	bcc.n	801257e <__udivmoddi4+0xc6>
 8012578:	4282      	cmp	r2, r0
 801257a:	f200 8107 	bhi.w	801278c <__udivmoddi4+0x2d4>
 801257e:	1a84      	subs	r4, r0, r2
 8012580:	eb67 0203 	sbc.w	r2, r7, r3
 8012584:	2001      	movs	r0, #1
 8012586:	4694      	mov	ip, r2
 8012588:	2d00      	cmp	r5, #0
 801258a:	d0e4      	beq.n	8012556 <__udivmoddi4+0x9e>
 801258c:	e9c5 4c00 	strd	r4, ip, [r5]
 8012590:	e7e1      	b.n	8012556 <__udivmoddi4+0x9e>
 8012592:	2a00      	cmp	r2, #0
 8012594:	f000 8092 	beq.w	80126bc <__udivmoddi4+0x204>
 8012598:	fab2 f382 	clz	r3, r2
 801259c:	2b00      	cmp	r3, #0
 801259e:	f040 80a8 	bne.w	80126f2 <__udivmoddi4+0x23a>
 80125a2:	1a8a      	subs	r2, r1, r2
 80125a4:	ea4f 4e16 	mov.w	lr, r6, lsr #16
 80125a8:	fa1f fc86 	uxth.w	ip, r6
 80125ac:	2101      	movs	r1, #1
 80125ae:	0c20      	lsrs	r0, r4, #16
 80125b0:	fbb2 f7fe 	udiv	r7, r2, lr
 80125b4:	fb0e 2217 	mls	r2, lr, r7, r2
 80125b8:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
 80125bc:	fb0c f007 	mul.w	r0, ip, r7
 80125c0:	4290      	cmp	r0, r2
 80125c2:	d907      	bls.n	80125d4 <__udivmoddi4+0x11c>
 80125c4:	18b2      	adds	r2, r6, r2
 80125c6:	f107 38ff 	add.w	r8, r7, #4294967295
 80125ca:	d202      	bcs.n	80125d2 <__udivmoddi4+0x11a>
 80125cc:	4290      	cmp	r0, r2
 80125ce:	f200 80e2 	bhi.w	8012796 <__udivmoddi4+0x2de>
 80125d2:	4647      	mov	r7, r8
 80125d4:	1a12      	subs	r2, r2, r0
 80125d6:	b2a4      	uxth	r4, r4
 80125d8:	fbb2 f0fe 	udiv	r0, r2, lr
 80125dc:	fb0e 2210 	mls	r2, lr, r0, r2
 80125e0:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80125e4:	fb0c fc00 	mul.w	ip, ip, r0
 80125e8:	45a4      	cmp	ip, r4
 80125ea:	d907      	bls.n	80125fc <__udivmoddi4+0x144>
 80125ec:	1934      	adds	r4, r6, r4
 80125ee:	f100 32ff 	add.w	r2, r0, #4294967295
 80125f2:	d202      	bcs.n	80125fa <__udivmoddi4+0x142>
 80125f4:	45a4      	cmp	ip, r4
 80125f6:	f200 80cb 	bhi.w	8012790 <__udivmoddi4+0x2d8>
 80125fa:	4610      	mov	r0, r2
 80125fc:	eba4 040c 	sub.w	r4, r4, ip
 8012600:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8012604:	e7a2      	b.n	801254c <__udivmoddi4+0x94>
 8012606:	f1c1 0620 	rsb	r6, r1, #32
 801260a:	408b      	lsls	r3, r1
 801260c:	fa22 fc06 	lsr.w	ip, r2, r6
 8012610:	ea4c 0c03 	orr.w	ip, ip, r3
 8012614:	fa07 f401 	lsl.w	r4, r7, r1
 8012618:	fa20 f306 	lsr.w	r3, r0, r6
 801261c:	40f7      	lsrs	r7, r6
 801261e:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8012622:	4323      	orrs	r3, r4
 8012624:	fa00 f801 	lsl.w	r8, r0, r1
 8012628:	fa1f fe8c 	uxth.w	lr, ip
 801262c:	fbb7 f0f9 	udiv	r0, r7, r9
 8012630:	0c1c      	lsrs	r4, r3, #16
 8012632:	fb09 7710 	mls	r7, r9, r0, r7
 8012636:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
 801263a:	fb00 f70e 	mul.w	r7, r0, lr
 801263e:	42a7      	cmp	r7, r4
 8012640:	fa02 f201 	lsl.w	r2, r2, r1
 8012644:	d90a      	bls.n	801265c <__udivmoddi4+0x1a4>
 8012646:	eb1c 0404 	adds.w	r4, ip, r4
 801264a:	f100 3aff 	add.w	sl, r0, #4294967295
 801264e:	f080 809b 	bcs.w	8012788 <__udivmoddi4+0x2d0>
 8012652:	42a7      	cmp	r7, r4
 8012654:	f240 8098 	bls.w	8012788 <__udivmoddi4+0x2d0>
 8012658:	3802      	subs	r0, #2
 801265a:	4464      	add	r4, ip
 801265c:	1be4      	subs	r4, r4, r7
 801265e:	b29f      	uxth	r7, r3
 8012660:	fbb4 f3f9 	udiv	r3, r4, r9
 8012664:	fb09 4413 	mls	r4, r9, r3, r4
 8012668:	ea47 4404 	orr.w	r4, r7, r4, lsl #16
 801266c:	fb03 fe0e 	mul.w	lr, r3, lr
 8012670:	45a6      	cmp	lr, r4
 8012672:	d909      	bls.n	8012688 <__udivmoddi4+0x1d0>
 8012674:	eb1c 0404 	adds.w	r4, ip, r4
 8012678:	f103 37ff 	add.w	r7, r3, #4294967295
 801267c:	f080 8082 	bcs.w	8012784 <__udivmoddi4+0x2cc>
 8012680:	45a6      	cmp	lr, r4
 8012682:	d97f      	bls.n	8012784 <__udivmoddi4+0x2cc>
 8012684:	3b02      	subs	r3, #2
 8012686:	4464      	add	r4, ip
 8012688:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 801268c:	eba4 040e 	sub.w	r4, r4, lr
 8012690:	fba0 e702 	umull	lr, r7, r0, r2
 8012694:	42bc      	cmp	r4, r7
 8012696:	4673      	mov	r3, lr
 8012698:	46b9      	mov	r9, r7
 801269a:	d363      	bcc.n	8012764 <__udivmoddi4+0x2ac>
 801269c:	d060      	beq.n	8012760 <__udivmoddi4+0x2a8>
 801269e:	b15d      	cbz	r5, 80126b8 <__udivmoddi4+0x200>
 80126a0:	ebb8 0203 	subs.w	r2, r8, r3
 80126a4:	eb64 0409 	sbc.w	r4, r4, r9
 80126a8:	fa04 f606 	lsl.w	r6, r4, r6
 80126ac:	fa22 f301 	lsr.w	r3, r2, r1
 80126b0:	431e      	orrs	r6, r3
 80126b2:	40cc      	lsrs	r4, r1
 80126b4:	e9c5 6400 	strd	r6, r4, [r5]
 80126b8:	2100      	movs	r1, #0
 80126ba:	e74c      	b.n	8012556 <__udivmoddi4+0x9e>
 80126bc:	0862      	lsrs	r2, r4, #1
 80126be:	0848      	lsrs	r0, r1, #1
 80126c0:	ea42 71c1 	orr.w	r1, r2, r1, lsl #31
 80126c4:	0c0b      	lsrs	r3, r1, #16
 80126c6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 80126ca:	b28a      	uxth	r2, r1
 80126cc:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 80126d0:	fbb3 f1f6 	udiv	r1, r3, r6
 80126d4:	07e4      	lsls	r4, r4, #31
 80126d6:	46b4      	mov	ip, r6
 80126d8:	4637      	mov	r7, r6
 80126da:	46b6      	mov	lr, r6
 80126dc:	231f      	movs	r3, #31
 80126de:	fbb0 f0f6 	udiv	r0, r0, r6
 80126e2:	1bd2      	subs	r2, r2, r7
 80126e4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80126e8:	e761      	b.n	80125ae <__udivmoddi4+0xf6>
 80126ea:	4661      	mov	r1, ip
 80126ec:	e714      	b.n	8012518 <__udivmoddi4+0x60>
 80126ee:	4610      	mov	r0, r2
 80126f0:	e728      	b.n	8012544 <__udivmoddi4+0x8c>
 80126f2:	f1c3 0120 	rsb	r1, r3, #32
 80126f6:	fa20 f201 	lsr.w	r2, r0, r1
 80126fa:	409e      	lsls	r6, r3
 80126fc:	fa27 f101 	lsr.w	r1, r7, r1
 8012700:	409f      	lsls	r7, r3
 8012702:	433a      	orrs	r2, r7
 8012704:	ea4f 4e16 	mov.w	lr, r6, lsr #16
 8012708:	fa1f fc86 	uxth.w	ip, r6
 801270c:	fbb1 f7fe 	udiv	r7, r1, lr
 8012710:	fb0e 1017 	mls	r0, lr, r7, r1
 8012714:	0c11      	lsrs	r1, r2, #16
 8012716:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 801271a:	fb07 f80c 	mul.w	r8, r7, ip
 801271e:	4588      	cmp	r8, r1
 8012720:	fa04 f403 	lsl.w	r4, r4, r3
 8012724:	d93a      	bls.n	801279c <__udivmoddi4+0x2e4>
 8012726:	1871      	adds	r1, r6, r1
 8012728:	f107 30ff 	add.w	r0, r7, #4294967295
 801272c:	d201      	bcs.n	8012732 <__udivmoddi4+0x27a>
 801272e:	4588      	cmp	r8, r1
 8012730:	d81f      	bhi.n	8012772 <__udivmoddi4+0x2ba>
 8012732:	eba1 0108 	sub.w	r1, r1, r8
 8012736:	fbb1 f8fe 	udiv	r8, r1, lr
 801273a:	fb08 f70c 	mul.w	r7, r8, ip
 801273e:	fb0e 1118 	mls	r1, lr, r8, r1
 8012742:	b292      	uxth	r2, r2
 8012744:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8012748:	42ba      	cmp	r2, r7
 801274a:	d22f      	bcs.n	80127ac <__udivmoddi4+0x2f4>
 801274c:	18b2      	adds	r2, r6, r2
 801274e:	f108 31ff 	add.w	r1, r8, #4294967295
 8012752:	d2c6      	bcs.n	80126e2 <__udivmoddi4+0x22a>
 8012754:	42ba      	cmp	r2, r7
 8012756:	d2c4      	bcs.n	80126e2 <__udivmoddi4+0x22a>
 8012758:	f1a8 0102 	sub.w	r1, r8, #2
 801275c:	4432      	add	r2, r6
 801275e:	e7c0      	b.n	80126e2 <__udivmoddi4+0x22a>
 8012760:	45f0      	cmp	r8, lr
 8012762:	d29c      	bcs.n	801269e <__udivmoddi4+0x1e6>
 8012764:	ebbe 0302 	subs.w	r3, lr, r2
 8012768:	eb67 070c 	sbc.w	r7, r7, ip
 801276c:	3801      	subs	r0, #1
 801276e:	46b9      	mov	r9, r7
 8012770:	e795      	b.n	801269e <__udivmoddi4+0x1e6>
 8012772:	eba6 0808 	sub.w	r8, r6, r8
 8012776:	4441      	add	r1, r8
 8012778:	1eb8      	subs	r0, r7, #2
 801277a:	fbb1 f8fe 	udiv	r8, r1, lr
 801277e:	fb08 f70c 	mul.w	r7, r8, ip
 8012782:	e7dc      	b.n	801273e <__udivmoddi4+0x286>
 8012784:	463b      	mov	r3, r7
 8012786:	e77f      	b.n	8012688 <__udivmoddi4+0x1d0>
 8012788:	4650      	mov	r0, sl
 801278a:	e767      	b.n	801265c <__udivmoddi4+0x1a4>
 801278c:	4608      	mov	r0, r1
 801278e:	e6fb      	b.n	8012588 <__udivmoddi4+0xd0>
 8012790:	4434      	add	r4, r6
 8012792:	3802      	subs	r0, #2
 8012794:	e732      	b.n	80125fc <__udivmoddi4+0x144>
 8012796:	3f02      	subs	r7, #2
 8012798:	4432      	add	r2, r6
 801279a:	e71b      	b.n	80125d4 <__udivmoddi4+0x11c>
 801279c:	eba1 0108 	sub.w	r1, r1, r8
 80127a0:	4638      	mov	r0, r7
 80127a2:	fbb1 f8fe 	udiv	r8, r1, lr
 80127a6:	fb08 f70c 	mul.w	r7, r8, ip
 80127aa:	e7c8      	b.n	801273e <__udivmoddi4+0x286>
 80127ac:	4641      	mov	r1, r8
 80127ae:	e798      	b.n	80126e2 <__udivmoddi4+0x22a>

080127b0 <memmove>:
 80127b0:	4288      	cmp	r0, r1
 80127b2:	b510      	push	{r4, lr}
 80127b4:	eb01 0402 	add.w	r4, r1, r2
 80127b8:	d902      	bls.n	80127c0 <memmove+0x10>
 80127ba:	4284      	cmp	r4, r0
 80127bc:	4623      	mov	r3, r4
 80127be:	d807      	bhi.n	80127d0 <memmove+0x20>
 80127c0:	1e43      	subs	r3, r0, #1
 80127c2:	42a1      	cmp	r1, r4
 80127c4:	d007      	beq.n	80127d6 <memmove+0x26>
 80127c6:	f811 2b01 	ldrb.w	r2, [r1], #1
 80127ca:	f803 2f01 	strb.w	r2, [r3, #1]!
 80127ce:	e7f8      	b.n	80127c2 <memmove+0x12>
 80127d0:	4402      	add	r2, r0
 80127d2:	4282      	cmp	r2, r0
 80127d4:	d100      	bne.n	80127d8 <memmove+0x28>
 80127d6:	bd10      	pop	{r4, pc}
 80127d8:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 80127dc:	f802 1d01 	strb.w	r1, [r2, #-1]!
 80127e0:	e7f7      	b.n	80127d2 <memmove+0x22>
	...

080127e4 <memset>:
 80127e4:	4402      	add	r2, r0
 80127e6:	4603      	mov	r3, r0
 80127e8:	4293      	cmp	r3, r2
 80127ea:	d100      	bne.n	80127ee <memset+0xa>
 80127ec:	4770      	bx	lr
 80127ee:	f803 1b01 	strb.w	r1, [r3], #1
 80127f2:	e7f9      	b.n	80127e8 <memset+0x4>

080127f4 <strncpy>:
 80127f4:	b510      	push	{r4, lr}
 80127f6:	3901      	subs	r1, #1
 80127f8:	4603      	mov	r3, r0
 80127fa:	b132      	cbz	r2, 801280a <strncpy+0x16>
 80127fc:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8012800:	f803 4b01 	strb.w	r4, [r3], #1
 8012804:	3a01      	subs	r2, #1
 8012806:	2c00      	cmp	r4, #0
 8012808:	d1f7      	bne.n	80127fa <strncpy+0x6>
 801280a:	441a      	add	r2, r3
 801280c:	2100      	movs	r1, #0
 801280e:	4293      	cmp	r3, r2
 8012810:	d100      	bne.n	8012814 <strncpy+0x20>
 8012812:	bd10      	pop	{r4, pc}
 8012814:	f803 1b01 	strb.w	r1, [r3], #1
 8012818:	e7f9      	b.n	801280e <strncpy+0x1a>
	...

0801281c <memcpy>:
 801281c:	440a      	add	r2, r1
 801281e:	4291      	cmp	r1, r2
 8012820:	f100 33ff 	add.w	r3, r0, #4294967295
 8012824:	d100      	bne.n	8012828 <memcpy+0xc>
 8012826:	4770      	bx	lr
 8012828:	b510      	push	{r4, lr}
 801282a:	f811 4b01 	ldrb.w	r4, [r1], #1
 801282e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8012832:	4291      	cmp	r1, r2
 8012834:	d1f9      	bne.n	801282a <memcpy+0xe>
 8012836:	bd10      	pop	{r4, pc}
